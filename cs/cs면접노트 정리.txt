1.디자인패턴
	싱글톤:하나의 클래스에 딱 하나의 인스턴스만 생성되게 강제하는패턴,db에 많이 사용되고 생성자에서 없을시 생성,있으면 있는거 리턴하는식으로 작동시키면됨
		단점으로는 유닛테스트를 할때도 딱 하나만 생성돼서,각 유닛별로 분리가 어려워짐
		그리고 이걸 사용하면 모듈간의 의존성이 강해지는데,
		이걸 해결하기위해 의존성주입(상위 하위 중간에 인터페이스를 두고,양쪽다 그거에 의존하는거)을 하면 해결할수있음
		
	팩토리:객체 생성을 하는 부분을 떼어내서,그부분만 추상화하는 패턴,
		이걸하면 상속관계에 있는 두 클래스에서 상위클래스가 중요한 뼈대를 결정하고,하위클래스는 객체생성에 관한 구체적내용을 결정할수있음
		그래서 상위와 하위가 분리되니까 느슨한 결합을 가지게되고,유연성이 높아지고,객체생성이 떨어져나가서 코드수정할때 한곳만 고치면됨
		
	전략:객체의 행위를 바꾸고싶을때,직접 수정하지않고 전략클래스를 교체해가면서 사용할수 있게 만드는 패턴,passport같은곳에서 사용됨
	
	옵저버:객체가 자기 상태가 바뀌었을때 자기를 구독한 애들한테 바뀌었다고 신호를 보내주는 패턴
		이렇게하면 객체와 구독자들 간에 연결이 끊기고,밑에를 생각할필요없이 객체는 자기자신을 수정할수있음,
		주로 mvc패턴에도 사용되고,이벤트기반ms에도 사용됨
		js에서는 프록시를 통해 구현할수있음
	
	프록시:객체의 앞에 프록시객체를 둬서 프록시객체가 객체를 실행하게 하는패턴,
		객체 앞에 프록시가 있으니까,거기서 추가작업을 하든가,객체연결을 거부하든가 등등 여러가지 일을 할수있음
		프록시에 캐시를 넣어서 캐시프록시로도 사용할수있음
		웹서버에선 nodejs앞에 nginx를 넣어서 사용하기도 하고,프런트엔드 앞단에 프록시를 둬서 cors에러를 막을수도있음
		
	이터레이터:반복자를 사용해서 컬렉션들을 같은인터페이스로 조회하는 패턴,foreach임
	
	노출모듈:private나 public가 없는 자바스크립트에서 그걸 생성하는패턴,클로저를 사용함
		  클로저를 만들고,그 클로저가 public고 그외의 내부변수가 private인 식임
		  
	mvc:앱을 모델,뷰,컨트롤러로 분할하고,뷰는 진짜 보이는것만,모델은 실제 상태변화나 db같은걸 넣고,
		컨트롤러는 실제 이벤트등 메인로직으로 뷰가 변경되면 컨트롤러가 작동해서 모델을 건드림,컨트롤러는 간단한 뷰컨트롤(버튼비활성화정도)을 할수있음		
		모델과 컨트롤러,뷰는 서로 옵저버패턴으로 연결되어있고,뷰와 컨트롤러는 뷰가 컨트롤러를 전략패턴으로 사용할수있음
		
	
2.프로그래밍 패러다임
	기본적으로 선언형과 명령형으로 나뉘고,선언형은 하위에 함수형을 포함하고,명령형은 객체지향과 절차지향으로 나뉨
	
	함수형 프로그래밍은,순수함수들을 쌓아나가서 로직을 구현하고,고차함수(함수가 함수를 매개변수로 받는거)를 통해 재사용성을 높이는 방식임
	이러려면 일급객체(변수나 메서드에 함수할당가능,함수안에 함수 매개변수담기 가능,함수가함수를 반환가능)여야 함
	
	객체지향은 객체들의 집합으로 상호작용을 표현하고,데이터를 객체로 취급해서 객체 내부에 선언된 메서드를 활용하는식임
	얘는 추상화,캡슐화,상속성,다형성등이 특징임
	설계원칙으로는 
		단일책임원칙,
		개방폐쇄원칙,
		리스코프치환원칙(부모객체대신 자식객체를 넣어도 동작해야함),
		인터페이스분리원칙(인터페이스 하나보단 구체적인 여러개),
		의존역전원칙(상위와 하위의 중간에 인터페이스를 둬서,상위가 하위에 의존하는걸 역전시킴)
	등이 있음
	
	절차지향은 로직이 수행되는 순서대로 구현하는식,머신러닝같은데에 자주쓰임,단점으로 모듈화가 어렵고 유지보수성이 떨어짐
	
	
	
3.네트워크
	네트워크의 구조엔 트리토폴로지,
	버스(중앙회선에 각노드들이 연결된형태,단 스푸핑이 가능해서 잘안쓰는듯)토폴로지,
	스타토폴로지(중앙에 메인스위치가 있고,거기에 다 연결된형태,단 중앙이 뻗으면 네트워크가 다뻗음),
	링형 토폴로지(각 노드가 양쪽에 연결을 갖고,양쪽으로 통신,단점으로 하나가 뻗으면 전체네트워크가 영향을받음,끊기진않음 양방향연결이니까)
	메시토폴로지(각 노드가 모든 노드에 연결을 가지는구조,단점으로 추가가어렵고 구축,운용이 비쌈)
	
	네트워크 성능분석 명령어로는
		ping:핑
		netstat:접속된 서비스들의 네트워크상태를 표시,보통 서비스포트확인할때 주로사용함
		nslookup:dns에 매핑된 ip를 확인할때 사용
		tracert(traceroute):목적지까지의 라우터경로를 알수있음
		
	osi 7계층으론 피지컬,데이터링크,네트워크,트랜스퍼,세션,프레젠테이션,애플리케이션 층이 있고
	tcp/ip4계층엔 링크,인터넷,트랜스퍼,애플리케이션 4계층이 있음
	각각 링크는 피지컬,데이터링크에 대응하고,인터넷은 네트워크,트랜스퍼는 트랜스퍼,애플리케이션은 세션,프레젠테이션,애플리케이션에 호환됨
	
	링크층은 실질적으로 전기나 광신호를 받아서 데이터로 변환하거나,데이터를 전기나 광신호로 변환하는 계층
	인터넷층은 받거나 보낼 데이터의 ip를  확인하고 그 주소를 지정해서 데이터를 전달하는 층,여기선 상대방이 제대로받았는지 보장하지않음
	트랜스퍼층은 송신자와 수신자를 연결하는 통신서비스를 제공함,여기서 tcp/udp가 선택됨
	애플리케이션층은 ftp,http,ssh같은걸 선택하는 층
	
	tcp에선 데이터전달할때 가상회선패킷교환방식으로,각 패킷에 번호를 부여해 순서대로 도착하는걸 보장하고,udp에선 싹무시하고 걍 집어던짐,도착할지말지도 모름
	tcp는 연결할땐 3way handshake를 사용하고(syn,synack,ack),해제할땐 4way handshake를 사용함(fin,ack,fin,ack)
	해제할때 마지막에 클라이언트가 ack를 보내고나면,클라이언트는 바로 해제하지않고 잠시 대기하는데,지연패킷이 있을수도 있어서 그거 대기해주는거
	
	
	앱에서 데이터를 전송할땐,전송할떈 캡슐화(위에서부터 순서대로 각층에서 헤더를 붙여서 전달하는작업),받을땐 언캡슐화(캡슐을 해제하는작업)을 함
	
	네트워크기기는 계층별로 처리범위를 나눌수있음,보통 높은곳에 있는건 그 밑의 모든 프로토콜을 처리할수있지만,
	낮은계층에 있는건 자기보다 위에있는건 처리할수없음
	
	그리고 보통 l7스위치와 l4스위치를 로드밸런서라고 부르고,l3스위치를 라우터라고 부름
	
	로드밸런서는 여러 조건들에 맞춰서 연결된 여러개의 서버로 부하를 분산해주는 장치임
	얘는 현재 상태가 맛이간애가 있으면 그걸체크하고 거기로는 안보내야하는데,그래서 정기적으로 서버에 헬스체크를 함(핑을 날려서 확인하던가,특정 rest를 날리던가)
	l4와 l7로드밸런서의 차이는,
	l4는 ip,포트단위로만 처리할수있어서 스트리밍관련엔 사용할수없음
	l7은 ip,포트외에도 url,http헤더,쿠키들을 기반으로 트래픽을 분산할수있음
	
	보통 aws에서는 l7을 alb라고 하고,l4를 nlb라고 함
	
	라우터는 여러 네트워크를 연결,분할,구분시켜주는 애임,얘는 다른 네트워크에 존재하는 장치끼리 서로 데이터를 주고받을때 패킷소모를 최소화하고,
	경로를 최적화해서 최소경로로 패킷을 포워딩하는 장치임
	
	l2스위치는 맥주소로 들어온 패킷을 전달해주는 장치임
	
	
	통신을 할땐 ip주소에서 arp를 통해 mac주소를 찾아서 mac주소를 기반으로 통신하게됨
	arp는 ip주소로부터 mac주소를 구하는,ip와 mac의 다리역할을 하는 프로토콜임
	arp를 통해 가상주소인 ip를 실제주소인 맥으로 변환하고,또 반대로 rarp를 통해 실제주소인 mac을 가상주소인 ip로 변환하기도 함
	
	즉 공유기까진 ip로 간다음에,공유기에서 내부 연결된 기기로 갈땐 맥으로 가야하니까,보낼쪽에서도 ip와 맥 두개가 다 필요함
	
	nat은 사설ip를 공인ip로 바꿔치기하는 방법임,보통 게이트웨이가 이걸 처리함(공유기)
	
	http1과 http2의 차이점은,동시에 여러파일을 보낼수 있게된것과,클라가 요청하지않아도 서버가 먼저 리소스를 푸시할수있게된것
	
	http에서 https의 차이는,ssl/tls가 추가되었다는것
	ssl은 공개되어있는 서버의 공개키(공개키는 서버에 요청하면 줌)로 내 대칭키를 암호화 해서 보낸다음에,
	그 대칭키를 사용해서 통신을 해서,인터셉터를 방지하는 프로토콜임
	단 이건 해커가 아예 사이트채로 만들어버리면 답이없어서 나온게 인증서(ca)임
	믿을수있는 기관에서,여긴 믿을수있는곳이라는걸 보증해주는거임
	
	
4.운영체제
	운영체제의 역할은 크게 4가지가 있음
		cpu스케줄링과 프로세스 관리
		메모리 관리
		디스크파일 관리
		io디바이스 관리
	운영체제는
		프로세스
		gui
		시스템콜
		커널
		드라이버
		하드웨어
	순으로 구성되어있음
	
	시스템콜은 운영체제가 커널에 접근하기위한 인터페이스고,유저프로그램이 운영체제의 서비스를 받기위해 커널함수를 호출할때 사용함
	유저프로그램이 io요청으로 트랩을 발동하면,올바른 io요청인지 확인후 유저모드가 시스템콜을 통해 커널모드로 바뀌고,행동을 한다음에 다시 유저모드로 바꿈
	즉 프로그램이 컴퓨터자원에 대한 직접적인 접근을 차단할수있음
	
	이때 유저모드와 커널모드를 구분하는건,modebit을 통해 구분함
	커널모드로 들어갈때 이걸 0으로 바꾸고,나올때 다시 1로 바꿈,0일때만 시스템접근가능
	
	컴퓨터는 cpu,메모리,dma컨트롤러,타이머,디바이스컨트롤러 등으로 구성됨
	cpu안에는 
		cu(입출력장치간 통신을 제어하고,명령어를 읽고해석함),
		레지스터(cpu안에있는 메모리,메모리보다 훨씬빠름),
		alu(덧셈뺄셈,논리연산등을 함)
	등이 있음
	
	이때 cpu가 연산하는 순서는
		cu가 메모리에 계산할값을 로드하고,레지스터에도 로드함
		cu가 레지스터에 있는값을 연산하라고 alu에 명령
		cu가 계산된값을 레지스터에서 메모리로 저장함
	순임
	
	인터럽트는 어떤 신호가 들어왔을때 cpu를 잠깐 정지시키는거임
	이게 발생되는 조건은,io로인한 인터럽트,0나누기인터럽트,프로세스오류등으로 발생함
	이건 또 하드웨어인터럽트와 소프트웨어인터럽트로 나눠짐
	
	하드웨어인터럽트는 io디바이스에서 발생하는 인터럽트임
	이때 인터럽트라인이 설계된이후 순차적으로 인터럽트실행을 중지하고 운영체제에 시스템콜을 요청해서,원하는 디바이스로 가서 그안의 로컬버퍼에 접근해서 일을 함
	
	소프트웨어 인터럽트는 트랩이라고도 함,프로세스오류등으로 프로세스가 시스템콜을 호출할때 발동함
	
	dma컨트롤러는 io디바이스가 직접 메모리에 접근할수있게 해주는 하드웨어장치임
	cpu에 모든 인터럽트를 맡기면 부하가 너무 커서,얘가 대신 해주는거
	그리고 하나의작업을 cpu와 dma컨트롤러가 동시에하는것도 막음
	
	메모리는 데이터나 상태등을 저장하는 공간
	
	타이머는 몇초안에 작업이 끝나야한다는걸 정하고,특정프로그램에 시간제한을 담
	
	디바이스컨트롤러는 io디바이스안의 작은 cpu를 뜻함
	
	메모리는 레지스터,캐시,메모리,저장장치로 구성됨
		레지스터:cpu안에있는 작은메모리,휘발성,속도가 가장빠름,용량이 가장작음
		캐시:휘발성,속도빠름,기억용량이 작음
		메모리:휘발성,속도보통,기억용량도 보통
		보조기억장치:ssd같은거,비휘발성,속도느림,용량이 가장큼
		
	램은 보조기억장치로부터 일정량의 데이터를 복사해서,임시저장하고 이를 필요할때마다 cpu(레지스터)에 빠르게 전달하는역할을 함
	캐시는 데이터를 미리 복사해두는 임시저장소이자,레지스터와 메모리의 속도차이를 줄이기위한 메모리임
	이렇게 속도차이를 해결하기위해 계층과 계층사이에 있는 계층을 캐싱계층이라고 함
	
	캐시를 직접 설정할땐 시간지역성과 공간지역성을 기반으로 설정하면됨
	시간지역성은 최근에 건드린곳은 또 건드릴 확률이 높다는 근거
	공간지역성은 건드린곳 근처에 건드릴게 있을확률이 높다는 근거(보통파편화생각해도 같은줄로 쭉 할당받으니까)
	
	이때 캐시에서 원하는 데이터를 찾으면 캐시히트,못찾으면 캐시미스임
	캐시미스가 나면 주메모리로 가서 데이터를 찾아와야함
	
	캐시매핑은 캐시가 히트되기위해 매핑하는 방법을 말함
	방법에는
		직접매핑:메모리가 1~100이 있고 캐시가 1~10이면 1:1~10 2:1~20 이렇게 매핑하는것,빠른데 충돌이 잦음
		연관매핑:순서를 일치시키지않고 관련있는 캐시와 메모리를 매핑함,충돌이 적지만 탐색이 많아서 속도가 느림
		집합연관매핑:둘을 합쳐둔거,순서는 일치시키지만 집합을 둬서 저장하며,블록화되어있어서 검색이 빠름
	
	캐싱은 여러곳에서 잘쓰이는데 대표적으로 웹브라우저의 쿠키,로컬스토리지,세션등이 있음
	쿠키는 만료기간이 있는 키-값저장소임
	로컬스토리지는 만료기한이 없는 키-값저장소임,10mb까지 저장할수있고,브라우저를 닫아도 유지됨
	세션스토리지는 만료기한이 없는 키-값저장소임,5mb까지 저장할수있음
	
	그리고 데이터베이스에도 레디스같은걸 캐시층으로 둬서,레디스에서 검색하고 없으면 mysql에서 검색하는식으로도 잘 사용됨
	
	
	운영체제의 대표적인 할일에는 메모리 관리가 있음
	이때 관리방법으로 가상메모리가 있는데,하드의 특정구간을 메모리로 떼어내고,
	메모리의 일부에 그 하드구간을 나눠서 페이지번호를 넣은다음,페이지를 교체하는식으로 사용함
	이때 가상메모리엔 존재하지만 실제메모리에 없어서 페이지폴트가 일어나는걸 스와핑이라고 함
	이때 페이지폴트가 일어날때 트랩이 발동해서,cpu를 잠시멈추고 페이지를 부르고 다시 작업을해서 프로세스가 뻗지않게함
	
	스레싱은 이 페이지폴트율이 높은걸 의미함,이렇게되면 컴퓨터가 성능이 심하게나빠짐
	
	작업세트는 프로세스의 과거사용이력인 지역성을 통해 페이지집합을 만들어서 미리 메모리에 로드하는것,이렇게되면 탐색비용도 줄일수있고 스와핑도 줄일수있음
	pff는 페이지폴트 빈도를 조정하는방법으로,상한선과 하한선을 만드는방법임,상한선에 도달하면 페이지를 늘리고,하한선이면 페이지를 줄이는식
	
	메모리에 프로그램을 할당할땐,시작메모리위치,메모리의 할당크기를 기반으로 할당하는데,연속할당과 불연속할당으로 나눠짐
	
	연속할당은 메모리에 연속적으로 공간을 할당하는것,
	이건 고정분할방식과 가변분할방식으로 나눠지는데,
	고정분할은 미리 메모리를 나누어두고,거기에 프로그램을 맞춰넣는것,내부단편화가 발생함
	가변분할은 매 시점 프로그램의 크기에 맞게 동적으로 메모리를 나눠 사용함,당연히 내부단편화는 없고,외부단편화는 생길수있음
	
	불연속할당은 메모리를 연속적으로 할당하지않고,메모리를 페이지(4kb)로 나눈다음에 프로그램을 거기에 맞게 다 나눠넣고,페이징테이블을 통해 읽는것
	
	이거말고도 세그멘테이션과 페이지드세그멘테이션이 있음
	
	세그멘테이션은 페이지단위가 아닌,의미단위인 세그먼트로 나누는 방식
	즉,코드와 데이터등을 기반으로 함수단위같이 의미있는단위로 나눠서 넣는거
	
	페이지드 세그먼테이션은,공유나 보안을 의미단위의 세그먼트로 나누고,물리적 메모리는 페이지로 나누는것
	
	페이지 교체 알고리즘은,메모리가 스와핑할때 최대한 스와핑이 덜일어나게 하는방법
	
	fifo는 가장 먼저온 페이지를 교체영역에 놓는것
	lru는 참조가 오래된페이지를 바꾸는거,단 이건 각페이지마다 계수기,스택을 두어야하는 문제가있음
	이건 보통 해시테이블과 이중연결리스트로 나타냄
	nur은 lru에서 발전한 알고리즘,0과 1비트를 두고,시계방향으로 돌면서 0을찾고 찾았으면 그걸 교체하고 해당부분을 1로 바꿈
	
	프로세스는 컴퓨터에서 실행되고 있는 프로그램,태스크와 같은의미로 쓰임
	스레드는 프로세스내에서 작업의 흐름을 의미함
	
	프로그램은 컴파일러가 컴파일과정을 거쳐 기계어로 번역됨
	이때 과정은
		전처리:소스코드의 주석을 제고하고 헤더파일을 병합해서 매크로를 치환함
		컴파일러:오류처리,코드최적화작업을 하며,어셈블리어로 변환
		어셈블러:어셈블리어를 목적코드로 변환함
		링커:프로그램내의 라이브러리함수,다른파일들과 목적코드를 결합해서 실행파일을 만듬
		
	라이브러리는 정적라이브러리와 동적라이브러리로 나뉘어짐,
	정적 라이브러리는 빌드시 라이브러리가 제공하는 모든코드를 실행파일에 넣는것,시스템환경등 외부의존도가 낮고,코드중복등 메모리효율성이 떨어짐
	동적 라이브러리는 프로그램이 필요할때만 dll을 통해 참조하는방식,메모리효율성은 높지만 외부의존도가 높아짐
	
	프로세스는 여러 상태값을 가짐
		생성상태:프로세스가 생성된상태,fork(),exec()를 가짐
			fork는 부모프로세스의 주소공간을 복사하고,새 자식프로세스를 생성하는함수,주소공간만 복사하지,비동기작업상속은 안함
			exec는 새롭게 프로세스를 생성하는 함수
		대기상태:메모리공간이 충분하면 메모리를 할당받고 아니면 아닌상태로 대기하고있음,cpu스케줄러로부터 cpu소유권넘어오길 기다리는상태
		대기중단상태:메모리부족으로 일시중단된상태
		실행상태:cpu와 메모리를 할당받고,인스트럭션을 수행중인 상태
		중단상태:io인터럽트등으로 프로세스가 차단된상태
		일시중단상태:중단상태에서 다시실행하려다가 메모리모자라서 다시중단된상태
		종료상태:메모리와 cpu소유권을 모두 두고 가는상태,비자발적종료와 자발적종료가 있음,비자발적종료는 할당된 자원한계치를 넘기거나 프로세스킬들을 했을때
		
	프로세스의 메모리할당은 스택,힙,데이터영역,코드영역으로 나눠짐
	스택엔 지역변수,매개변수,함수가 저장되고,컴파일시에 크기가 결정되고 동적인 특징을 가짐(함수 재귀호출떄문),그래서 힙과 스택사이공간을 비워둠(재귀)
	
	힙은 동적할당할때 사용되고,런타임시 크기가 결정됨,벡터같은 동적배열은 힙에 동적할당됨
	
	데이터영역은 전역변수,정적변수가 저장되고 정적인 특징을 가짐,프로그램이 종료되면 사라지는 변수들이 들어있음
	이건 bss영역과 data영역으로 나뉘는데,bss는 초기화가 되지않은변수가 0으로 초기화되어서 저장되고,data영역은 0이아닌 다른값할당된 변수가 저장됨
	
	코드영역은 소스코드가 들어있음,정적이고 수정불가능함
	
	pcb는 운영체제에서 프로세스에 대한 메타데이터를 저장한 데이터,프로세스 제어블록이라고도 함
	프로세스가 생성되면 운영체제는 해당pcb를 생성함
	즉,프로그램이 실행되면 프로세스가 생성되고,프로세스 주소값들에 스택,힙구조등을 기반으로 메모리가 할당되고,이 메타데이터들이 pcb에 저장되어 관리됨
	이건 프로세스의 중요한정보를 포함하니까,커널스택에서 관리함 
	
	pcb에는 
		프로세스 스케줄링상태:준비,일시중단 프로세스가 cpu에 대한 소유권을 얻은이후 경과된시간같은 정보
		프로세스id:프로세스의 id와 자식프로세스의 id
		프로세스권한:컴퓨터자원 또는 io디바이스에 대한 권한정보
		프로그램카운터:프로세스에서 실행할 다음 명령어의 주소에 대한 포인터
		cpu레지스터:프로세스를 실행하기위해 저장해야할 레지스터 정보
		cpu스케줄링 정보:cpu스케줄러에 의해 중단된시간등에 대한 정보
		계정정보:프로세스 실행에 사용된 cpu사용량,실행한 유저정보
		io상태정보:프로세스에 할당된 io디바이스 목록
	이 있음
	
	컨텍스트 스위칭은 이 pcb를 교환하는 과정임,한 프로세스에 할당된 시간이 끝나거나 인터럽트가 발생했을때 발생함
	컴퓨터는 동시에 단 하나의 프로세스밖에 실행하지못함(정확히는 코어당하나)
	
	멀티프로세싱은 여러 프로세스,즉 멀티프로세스를 통해 동시에 두가지이상의 일을 수행하는것,이거로 하나이상의 일을 병렬적으로 처리할수있음
	예로 웹브라우저가 있음
	브라우저는
		브라우저프로세스:주소표시줄,앞뒤이동등을 담당
		렌더러프로세스:화면그리기를 담당
		플러그인프로세스:웹사이트에서 사용하는 플러그인을 제어
		gpu프로세스:gpu를 이용해서 화면그리는부분을 제어
	이런식으로 멀티프로세싱을 함
	
	멀티프로세스는 ipc(프로세스끼리 데이터를 주고받고 공유데이터를 관리하는 메커니즘)이 가능함
	이거의 종류로는,공유메모리,파일,소켓,익명파이프,명명파이프,메시지큐가 있음,단 모두 메모리가 완전히 공유되는 쓰레드보단 속도가 느림
	
	공유메모리는 여러프로세스에 동일한 메모리블록에 대한 접근권한이 부여되어 서로 통신할수있게 공유버퍼를 생성하는것
	
	파일은 디스크에 저장된 데이터등으로 통신하는것
	
	소켓은 동일한 컴퓨터의 다른프로세스나 네트워크의 다른컴퓨터로 tcp/udp를 통해 통신하는것
	
	익명파이프는 프로세스간 fifo방식으로 읽히는 임시공간인 파이프를 기반으로 데이터를 주고받고,단방향방식의 읽기전용,쓰기전용 파이프를 만들어서 작동하는방식
	이건 다른네트워크간엔 사용불가능함
	
	명명된 파이프는 파이프서버와 하나이상의 파이프클라이언트간의 통신을 위한 단방향,또는 이중파이프를 말함,이건 여러파이프를 동시에사용할수도있고
	다른네트워크간에도 사용가능
	
	메시지큐는 메시지를 큐형태로 관리하는걸 의미함,이는 커널의 전역변수형태등 커널에서 전역적으로 관리되며,접근이 쉽고 사용방법이 직관적임
	주로 사용되는듯
	
	스레드는 프로세스의 실행가능한 가장 작은단위임,프로세스는 여러스레드를 가질수있음
	스레드는 코드,데이터,힙은 서로 공유하고 스택만 따로생성함
	
	멀티스레딩은 프로세스내 작업을 여러스레드로 나눠서 처리하는 기법,스레드끼리 자원을 공유해서 효율이높음
	단점으론 임계영역때문에 문제가 생길수있다는거
	
	이 임계영역을 처리하는 방법은
		뮤텍스:그냥 잠그고 나갈때 문여는거
		세마포:안에 들어갈수있는 갯수센다음에 0되면 못들어가고 들어갈때 1감소 나올때 1증가하는거,일반화된 뮤텍스
		모니터:둘이상의 스레드나 프로세스가 공유자원에 안전하게 접근할수잇게 공유자원을 숨기고,해당접근에 대해 인터페이스 제공
		
	교착상태는 두개이상의 프로세스들이 서로가 가진 자원을 기다리며 중단된상태임(젓가락 두개필요한데 서로 하나씩들고있는거)
	이걸 해결하기위해 
		교착가능성이 없을때만 자원할당되고,최대치를 통해 할당가능여부를 파악하는 은행원 알고리즘사용
		교착상태가 발생하면 사이클이 있는지 찾아보고,이에 관련된 프로세스를 하나씩 지움
	같은걸 썼지만
	요즘은 그냥 프로세스를 꺼버림(잘안일어나니까 그냥꺼버림)
	
	cpu스케줄러는 알고리즘에 따라 스케줄링함
	이 알고리즘은 선점형과 비선점형이 있음
	비선점형엔
		fcfs:선입선출,먼저온애 먼저처리,단점으로 길게수행되는애때문에 뒤에 짧게끝나는애들도 기다려야함
		sjf:빠른애부터 처리,단점으로 긴애는 아예 수행안될수도있음,그리고 실행시간을 실행시키기전엔 알수없기때문에,과거기록을통해 추측해야함
		우선순위:sjf기반으로 오래기다린애는 우선순위를 올려줌
	선점형은 요즘 주로쓰는방식들,지금사용하고있는 프로세스를 중단시켜버리고 딴애한테 주는방식임
		라운드로빈:각 프로세스에 같은할당시간을 주고,그시간안에 안끝나면 다시 뒤로가서 줄서야함,로드밸런서에서 트래픽분산알고리즘으로도 잘 사용됨
		srf:sjf기반에,현재 실행중인애보다 짧은애오면 지금실행중인애 쫒아내고 개부터처리함
		다단계큐:우선순위에 따른 준비큐를 여러개 사용하고,큐마다 다른 알고리즘을 적용함
	
	
	
	
5.데이터베이스	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	