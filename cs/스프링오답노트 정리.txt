1.컨벤션
	자바에선
		변수:카멜케이스(abcCase)
		함수(메서드):카멜케이스(abcCase)
		클래스:파스칼케이스(AbcCase)
		패키지:전부소문자(abccase)
		상수:전부대문자(ABCCASE)
	추가로,메서드이름은 동사로시작해야함(get,set)	
	
	줄여쓰기는 가능하면 안하는게좋음,ws가 webSocket인지 webServer인지 알수없기때문
		msg->message
		ws->WebSocket
		ws->WebServer
	단,관습적으로 사용하는거(Id,app)는 그냥쓰면됨
	즉 가능하면 풀어쓰는게 코드일관성에 좋음
	
	축약어(id,ip,api같은거)는,그냥 하나의 단어로 취급해서,userID가 아닌 userId로 쓰는게 좋음
	막 IP같은거 앞에 소문자로 적어야한다고 iP이따구되니까 그냥 일반명사처럼 취급하는게 낫대
	근데 OAuth같이 일부만 축약한거(Open Auth)는 컨벤션없으니까 그때그때 알아서해줘야함
	이런건 유명한오픈소스 참고하는게좋음
	
	클래스이름에서 Simple,Light,Base같은거 사용하지말고(5개필드에서 중요한 3개필드로 줄여서쓰는 dto라던가),유의미한 정보로 대체해야함
	사람마다 심플과 복잡한거의 기준이 다르니까
	그래서 목적에 맞는 클래스명으로 짓는게 나음(SimpleDto->CreateUserDto)
	같은이유로 Util도 사용하지않는게 좋음,이러면 여기에 온갖 스태틱메서드가 모임
	그래서 생성코드면 팩토리,이런식으로 명시적으로 나눠서 사용하는게좋음
	
	메서드명에서 
		get은 리턴이 T일경우(널일경우 예외던질떄)
		find는 리턴이 Optional<T>일 경우(널이라도 리턴할떄,즉 값이 없다는 정보를 줘야할때)
	사용됨,즉 널을 허용하냐 안하냐에 따라 다름,둘을 구분해야함
	단,TypeORM같은경우엔 그런거 구분안하고사용함
	
	isExist(이게존재하냐)는 사용하지않고,exists로 대체,동사반복이라서 없는단어임
	
	get은 기본적으로 내가 가지고있는 멤버변수를 그대로 돌려주는거임,이걸 어디서 찾아오거나 계산해야하면 get이 아님
	즉 내가가진 모든값을 더한걸 반환한다고 하면,getSumPrice가 아닌 SumPrice가 맞음
	
	롬복 getter과 setter은 생각하고 넣어야함,사실상 멤버변수를 퍼블릭으로 여는거랑 똑같고,객체를 수동적으로 만듬
	객체가 수동적이라는건,객체가 데이터를 저장하고 보여주는것 말곤 아무일도 하지않는것(아무 메서드 없는 도메인)
	그래서 객체를 능동적으로 만드는게 좋음(자기가 할일은 자기가 처리하게)
	즉 
		user.setStatus(Status.ACTIVE)
	를
		user.inactive()
	처럼 도메인내부에 자기멤버변수를 가지고 할수있는일은 도메인 자기자신이 처리하게 만드는게 좋음(TDA원칙)	
	setter는 dto정도말곤 안넣는게좋고
	
	주석은 정말 필요할때만 사용,어지간하면 주석을 다는거보다,그 내용을 유의미한의미를 가진 메서드로 분리하는게 나음
	즉 주석을 달고싶다고 느껴지면,메서드를 분리하라는 신호임
	
	Optional을 자주 사용하면,코드의 완성도를 높이고 런타임에러를 줄여줌(널포인트익셉션)
	
	Collection.Map를 남발하면 안됨,다른사람이 이해하기 매우어려워짐
	가급적 직접 맵을 쓰는대신 일급클래스(다른맴버변수가 없고 클래스내에 맵같은 콜렉션만 있는 클래스)로 뽑아서 만들고,
	만약 사용해도 지정된 스코프 밖(현재 클래스 밖에서 get해서 뭐한다던가)을 넘나들면안됨
	
	range는 보통 start는 포함시키고,end는 제외시킴(0부터10까지 루프면 start=0 end=11),관습적으로 이럼
	end만 있을경우에도 제외시킴
	for문짤때 <로 사용하는거처럼
	
	검증이 필요할떄 verify,validate,check,is --->늬앙스차이있으니 검색해보자
	추가적으로 구글 코드 스타일 가이드 참고하면되고(eslint처럼 적용할수도있음),
	클래스이름의 단어조합은 가능한3개이하로 하는게좋음
	그리고 컨벤션은 사내규칙에 따라 일관적으로 쓰는게좋음
		
2.객체지향적 코드짜기		
	객체의 종류엔
		vo(value Object):단순히 값만 가지고있는 객체,모든 필드에 final이 붙어있고,생성자를 통해서 만들면 변경할수없음,
			변수는 변해도 값은 변할수없으니 값객체라고 부르는거,
			vo는 불변해야하고,동일하게 생성된 두 vo는 영원히 동일해야함,즉 그래서 인스턴스화된 vo는 항상 유효해야함
			객체를 메서드의 파라미터로 던져줄때,항상 처음만들어졌을때와 동일하다는게 보장되기때문에 개발복잡도와 시스템복잡도가 낮아짐
			그리고 vo는 항상 유효해야하기때문에,생성자에서 무조건 값이 유효한지 밸리데이션을 해야함,그래야 믿고쓸수있음
		DTO(Data Transfer Object):데이터 전달에 사용되는 객체,그냥 메서드간,클래스간,프로세스간 통신할때 사용하는 모든객체를 dto라고함
			그래서 getter setter 다 열려있어도 상관없음(아예 멤버변수를 퍼블릭으로 둬도 된다고그러긴함 어짜피 getset둘다달면 똑같으니)
			이건 그냥 데이터를 하나하나 던지기 힘드니까,묶어서 던지는 객체라고 보면됨
		Entity:id값이 있고,수명주기(영속성컨텍스트같은)가 있어야함,일반적으로 db에 저장할수있어서 지속성을 가져서 나중에 다시불러올수있음
	등이 있음
	단,모든객체가 이 3가지안에 들어가지않고,vo이면서 엔티티일수도 잇고,dto이면서 po일수도있고,셋 다 아닐수도있음
	분류보다 어떤값을 final로 쓸건지,어떤 인터페이스를 노출할것인지(어떤메서드를 public로 선언할건지)가 더 중요
	추가적으로 dao는 repository와 같은말임
							
	그리고 생성자는 가급적 값을 검증하고,값을 할당하는 이 두가지일만 하는게 좋음
	
	디미터법칙은 최소지식법칙이라고도 불리며,모듈은 자신이 조작하는 객체의 속사정을 몰라야 한다는것
	즉,객체내부를 체이닝으로 줄줄히 들어가서 조작하는 코드가 잇거나 그러면 디미터법칙 위반임
		foreach
			size+=com.getDisks().get(i).getSize(); //총디스크크기 
	이러면 안된다는것
	이소리는,tda원칙으로 해당 객체에 그 일을 할수있는 메서드를 만들어야 한다는것
	이때도 메서드의 이름을 getDiskSize()로 뽑고,이걸 println으로 뽑는게 아닌(일단 계산하니까 get떼야하고)
		System.out.println(com.getDiskSize())
	해당객체한테 프린트하는거까지 시키면됨
		com.printSpec();
	이렇게
	
	클래스를 만들땐,필드를 먼저 생각하는게 아닌 메서드를 먼저 생각하고,그 메서드에서 필요한 필드를 생성하는게 맞는순서임
	자동차를 만든다고하면,운전메서드,속도조절메서드,방향전환메서드를 먼저 생각해야함
	즉 데이터위주의 사고가 아닌,행동위주의 사고를 해야함
	즉 덕타이핑과 같은소리임,필드가 중요한게 아니라 객체는 메서드가 제일 중요하니 ..
	
	순환참조(양방향참조,jpa oneToMany+ManyToOne)는 기본적으로 만들면 안됨,정 어쩔수없을때만 만들어야함
		순환의존성이 있다는거 자체가 결합도가 올라감
		순환참조가 있으면 직렬화가 불가능해짐(서로 참조하니까 양방향부분은떼고해야함,toString생각하면됨)
	차라리 간접참조로,엔티티는 외래키만 가지고있고 연관관계는 단방향으로 해둔다음 필요할때마다 그거로 레포지토리에서 찾아오는게 나음
	순환참조를 유도하는 기능이 있으면,이걸 어케 별도의 클래스로 분할할수없는지 고민해야함
	순환참조가 없으면
		mappedBy를 고민안해도됨
		복잡도를 낮추고 응집도를 높임
	같은 장점이 있음
	
	그리고 추가적으로
		가능하면 final로 선언하고,안되면 안되는 이유를 찾자
		vo에서도 변경자가 들어갈수있는데,단 이경우엔 무조건 새로운 vo를 반환하는 메서드가 되어야함
		그래서 이름도 changePassword같은게 아닌 withNewPassword같은게 더 좋음(일반변경메서드와 구분하기위해 메서드이름을 전치사로 시작)
	도 신경쓰면좋음
		
		
		
		
		
		
		
		
		
		
		
		
		