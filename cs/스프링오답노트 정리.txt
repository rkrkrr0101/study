1.컨벤션
	자바에선
		변수:카멜케이스(abcCase)
		함수(메서드):카멜케이스(abcCase)
		클래스:파스칼케이스(AbcCase)
		패키지:전부소문자(abccase)
		상수:전부대문자(ABCCASE)
	추가로,메서드이름은 동사로시작해야함(get,set)	
	
	줄여쓰기는 가능하면 안하는게좋음,ws가 webSocket인지 webServer인지 알수없기때문
		msg->message
		ws->WebSocket
		ws->WebServer
	단,관습적으로 사용하는거(Id,app)는 그냥쓰면됨
	즉 가능하면 풀어쓰는게 코드일관성에 좋음
	
	축약어(id,ip,api같은거)는,그냥 하나의 단어로 취급해서,userID가 아닌 userId로 쓰는게 좋음
	막 IP같은거 앞에 소문자로 적어야한다고 iP이따구되니까 그냥 일반명사처럼 취급하는게 낫대
	근데 OAuth같이 일부만 축약한거(Open Auth)는 컨벤션없으니까 그때그때 알아서해줘야함
	이런건 유명한오픈소스 참고하는게좋음
	
	클래스이름에서 Simple,Light,Base같은거 사용하지말고(5개필드에서 중요한 3개필드로 줄여서쓰는 dto라던가),유의미한 정보로 대체해야함
	사람마다 심플과 복잡한거의 기준이 다르니까
	그래서 목적에 맞는 클래스명으로 짓는게 나음(SimpleDto->CreateUserDto)
	같은이유로 Util도 사용하지않는게 좋음,이러면 여기에 온갖 스태틱메서드가 모임
	그래서 생성코드면 팩토리,이런식으로 명시적으로 나눠서 사용하는게좋음
	
	메서드명에서 
		get은 리턴이 T일경우(널일경우 예외던질떄)
		find는 리턴이 Optional<T>일 경우(널이라도 리턴할떄,즉 값이 없다는 정보를 줘야할때)
	사용됨,즉 널을 허용하냐 안하냐에 따라 다름,둘을 구분해야함
	단,TypeORM같은경우엔 그런거 구분안하고사용함
	
	isExist(이게존재하냐)는 사용하지않고,exists로 대체,동사반복이라서 없는단어임
	
	get은 기본적으로 내가 가지고있는 멤버변수를 그대로 돌려주는거임,이걸 어디서 찾아오거나 계산해야하면 get이 아님
	즉 내가가진 모든값을 더한걸 반환한다고 하면,getSumPrice가 아닌 SumPrice가 맞음
	
	롬복 getter과 setter은 생각하고 넣어야함,사실상 멤버변수를 퍼블릭으로 여는거랑 똑같고,객체를 수동적으로 만듬
	객체가 수동적이라는건,객체가 데이터를 저장하고 보여주는것 말곤 아무일도 하지않는것(아무 메서드 없는 도메인)
	그래서 객체를 능동적으로 만드는게 좋음(자기가 할일은 자기가 처리하게)
	즉 
		user.setStatus(Status.ACTIVE)
	를
		user.inactive()
	처럼 도메인내부에 자기멤버변수를 가지고 할수있는일은 도메인 자기자신이 처리하게 만드는게 좋음(TDA원칙)	
	setter는 dto정도말곤 안넣는게좋고
	
	주석은 정말 필요할때만 사용,어지간하면 주석을 다는거보다,그 내용을 유의미한의미를 가진 메서드로 분리하는게 나음
	즉 주석을 달고싶다고 느껴지면,메서드를 분리하라는 신호임
	
	Optional을 자주 사용하면,코드의 완성도를 높이고 런타임에러를 줄여줌(널포인트익셉션)
	
	Collection.Map를 남발하면 안됨,다른사람이 이해하기 매우어려워짐
	가급적 직접 맵을 쓰는대신 일급클래스(다른맴버변수가 없고 클래스내에 맵같은 콜렉션만 있는 클래스)로 뽑아서 만들고,
	만약 사용해도 지정된 스코프 밖(현재 클래스 밖에서 get해서 뭐한다던가)을 넘나들면안됨
	
	range는 보통 start는 포함시키고,end는 제외시킴(0부터10까지 루프면 start=0 end=11),관습적으로 이럼
	end만 있을경우에도 제외시킴
	for문짤때 <로 사용하는거처럼
	
	검증이 필요할떄 verify,validate,check,is --->늬앙스차이있으니 검색해보자
	추가적으로 구글 코드 스타일 가이드 참고하면되고(eslint처럼 적용할수도있음),
	클래스이름의 단어조합은 가능한3개이하로 하는게좋음
	그리고 컨벤션은 사내규칙에 따라 일관적으로 쓰는게좋음
		
2.객체지향적 코드짜기		
	객체의 종류엔
		vo(value Object):단순히 값만 가지고있는 객체,모든 필드에 final이 붙어있고,생성자를 통해서 만들면 변경할수없음,
			변수는 변해도 값은 변할수없으니 값객체라고 부르는거,
			vo는 불변해야하고,동일하게 생성된 두 vo는 영원히 동일해야함,즉 그래서 인스턴스화된 vo는 항상 유효해야함
			객체를 메서드의 파라미터로 던져줄때,항상 처음만들어졌을때와 동일하다는게 보장되기때문에 개발복잡도와 시스템복잡도가 낮아짐
			그리고 vo는 항상 유효해야하기때문에,생성자에서 무조건 값이 유효한지 밸리데이션을 해야함,그래야 믿고쓸수있음
		DTO(Data Transfer Object):데이터 전달에 사용되는 객체,그냥 메서드간,클래스간,프로세스간 통신할때 사용하는 모든객체를 dto라고함
			그래서 getter setter 다 열려있어도 상관없음(아예 멤버변수를 퍼블릭으로 둬도 된다고그러긴함 어짜피 getset둘다달면 똑같으니)
			이건 그냥 데이터를 하나하나 던지기 힘드니까,묶어서 던지는 객체라고 보면됨
		Entity:id값이 있고,수명주기(영속성컨텍스트같은)가 있어야함,일반적으로 db에 저장할수있어서 지속성을 가져서 나중에 다시불러올수있음
	등이 있음
	단,모든객체가 이 3가지안에 들어가지않고,vo이면서 엔티티일수도 잇고,dto이면서 po일수도있고,셋 다 아닐수도있음
	분류보다 어떤값을 final로 쓸건지,어떤 인터페이스를 노출할것인지(어떤메서드를 public로 선언할건지)가 더 중요
	추가적으로 dao는 repository와 같은말임
							
	그리고 생성자는 가급적 값을 검증하고,값을 할당하는 이 두가지일만 하는게 좋음
	
	디미터법칙은 최소지식법칙이라고도 불리며,모듈은 자신이 조작하는 객체의 속사정을 몰라야 한다는것
	즉,객체내부를 체이닝으로 줄줄히 들어가서 조작하는 코드가 잇거나 그러면 디미터법칙 위반임
		foreach
			size+=com.getDisks().get(i).getSize(); //총디스크크기 
	이러면 안된다는것
	이소리는,tda원칙으로 해당 객체에 그 일을 할수있는 메서드를 만들어야 한다는것
	이때도 메서드의 이름을 getDiskSize()로 뽑고,이걸 println으로 뽑는게 아닌(일단 계산하니까 get떼야하고)
		System.out.println(com.getDiskSize())
	해당객체한테 프린트하는거까지 시키면됨
		com.printSpec();
	이렇게
	
	클래스를 만들땐,필드를 먼저 생각하는게 아닌 메서드를 먼저 생각하고,그 메서드에서 필요한 필드를 생성하는게 맞는순서임
	자동차를 만든다고하면,운전메서드,속도조절메서드,방향전환메서드를 먼저 생각해야함
	즉 데이터위주의 사고가 아닌,행동위주의 사고를 해야함
	즉 덕타이핑과 같은소리임,필드가 중요한게 아니라 객체는 메서드가 제일 중요하니 ..
	
	순환참조(양방향참조,jpa oneToMany+ManyToOne)는 기본적으로 만들면 안됨,정 어쩔수없을때만 만들어야함
		순환의존성이 있다는거 자체가 결합도가 올라감
		순환참조가 있으면 직렬화가 불가능해짐(서로 참조하니까 양방향부분은떼고해야함,toString생각하면됨)
	차라리 간접참조로,엔티티는 외래키만 가지고있고 연관관계는 단방향으로 해둔다음 필요할때마다 그거로 레포지토리에서 찾아오는게 나음
	순환참조를 유도하는 기능이 있으면,이걸 어케 별도의 클래스로 분할할수없는지 고민해야함
	순환참조가 없으면
		mappedBy를 고민안해도됨
		복잡도를 낮추고 응집도를 높임
	같은 장점이 있음
	
	그리고 추가적으로
		가능하면 final로 선언하고,안되면 안되는 이유를 찾자
		vo에서도 변경자가 들어갈수있는데,단 이경우엔 무조건 새로운 vo를 반환하는 메서드가 되어야함
		그래서 이름도 changePassword같은게 아닌 withNewPassword같은게 더 좋음(일반변경메서드와 구분하기위해 메서드이름을 전치사로 시작)
	도 신경쓰면좋음
		
		
3.설계 
	solid
		단일책임원칙:클래스는 하나의책임만 가져야하고,그 책임을 완전히 캡슐화해야함,클래스에 코드라인이 100줄이상이면 의심
		개방폐쇄원칙:확장에열리고,수정에닫혀야함,보통 추상화(인터페이스화)가 부족할경우 이게 깨짐
		리스코프치환원칙:하위객체는 상위객체가 하는일을 완전히 대체할수있어야함,상위와하위의 계약(인터페이스)이 깨질때 이게 깨짐
			이거때문에 상속이 구현보다 사용하기꺼려지는것
		인터페이스분리원칙:클라이언트가 자신이 이용하지않는 메서드에 의존하면안됨,이건 인터페이스를 분리해서 조립하듯이 개발하지않으면 깨짐
			인터페이스는,이기능을 사용하려면 이 방법을 사용하게 만들어라라고 계약하고,계약을 지켜서 만드는것(인터페이스의 메서드)
			굳이 interface가 아니라도,클래스의 퍼블릭메서드도 인터페이스긴함,인터페이스가 생략되고 바로 구현체에 붙은거지
			그래서 api도 인터페이스임
			이 인터페이스는,구현체 안에서 사용하지않는 메서드가 없도록 각각 잘 분리해서,2개이상이 필요하면 2개를 구현하도록 만들어져야함
		의존성역전원칙:상위모듈은 하위모듈에 의존하면안됨,상위하위둘다 인터페이스에 의존해야함
			추상화는 세부사항에 의존하면안됨,세부사항이 추상화에 의존해야함
			즉 인터페이스가 있고 구현체가 있는거지,구현체에 인터페이스를 맞추면안됨
	이렇게있음
	
	여기서 의존성이란,a가 b를 사용하기만 해도 a는 b에 의존성을 가지는것,즉 import되면 의존성이 있다고 할수있음
	이 의존성을 직접 new해서 생성하지않고(강결합),외부에서 넣어주는걸 사용하면(약결합) 이게 의존성주입임
	즉 구현체에 직접 의존하는게 강결합이고,
	인터페이스에 의존하고,인터페이스 구현체를 받아서 사용하는게 약결합임
	
	의존성 주입과 의존성 역전은 다름
	의존성 주입은 단순히 의존성을 주입받는,강결합을 약결합으로 만드는걸 말하고
	의존성 역전은 모듈사이에 인터페이스를 두고 통신하게되는걸 말함(상위하위 모두 인터페이스만 의존)
	즉 의존성역전을 위해,의존성 주입을 사용하는것
	스프링은 의존성 주입도구임,의존성 역전을 만들어주지않음
	
	그래서 레이어드아키텍쳐를 사용할때,컨트롤러서비스레포지토리를 추상화없이 사용하면,일반적으로 나쁘고,절차지향적 코드가 나올가능성이 커짐
	물론 그렇다고 전부 추상화하면 개귀찮으니까,각보고 알아서정해야함
	
	그리고 생성자주입이 7개,파라미터주입이 4개이상 넘어간다면,클래스분할이나 메서드분할을 고려해야하는 신호임
	
	가능하면 의존성은 드러내는게 좋음
	즉,내부로직에서 의존하고있는건 가능하면 파라미터같은거로 받는게,그걸 사용하는사람이 확인하기 쉬움
	그리고 이렇게 하는게 테스트하기도 쉬움(특히 시간이나 랜덤같은,실행할때마다 변하는값)
	즉,변하는값은 외부에서 주입받는게 좋음
	근데 이렇게하려면,계속 상위객체로 갈때마다 해당메서드에 파라미터가 하나씩 추가됨(상위에서도 감춰진거 풀고 하려면)
	결국 누군가는 고정된 의존성을 주입해줘야함
	그래서 가장 괜찮은방법은,런타임의존성과 컴파일타임의존성을 다르게하는것(변하는값을 추상화해서 스프링같은거로 di받는것)
	즉 인터페이스에만 의존하고,구현체는 스프링이 알아서 넣어달라고 '해줘' 하는거임
	이렇게해서,테스트시와 배포시에 의존성넣는걸 변경해서 처리할수있음(의존성역전을 사용해서 처리하는것)
	그 스프링게시판만들기할때 사용했던,레포지토리 의존 나누는거 그거임
	
	보통 테스트하기가 쉬우면,좋은코드일 확률이 높음
	
	cqrs는,명령과 쿼리를 분리하는것
	즉 메서드나 클래스를 명령과 쿼리로 나누는것
	이때 주의해야할건,명령에서 return this로 변경되거나 추가된 결과물을 던져버리면,쿼리결과가 날아간거라서 cqrs가 아님
	그래서 명령은 void가 되는게 맞음
	쿼리는 값을 변경시켜선 안됨
	즉
		하나의 메서드는 명령이나 쿼리여야하고
		명령은 객체의 상태를 변경할수있지만,값을 반환하지않음
		쿼리는 값을 반환하지만 객체를 변경하지않음
		
4.실수
	api500에러는 사실상 장애상황임
	api가 실패하면 원인을 반드시 리턴해줘야하고,거기에 맞는 http상태코드를 내려줘야함
	500은 그냥 장애선언임
	
	좋은프로그램은
		1.돌아가야함
		2.유지보수가 가능해야함
	설계만 백만년하고있으면 안됨,80점짜리 코드를 빨리뽑는걸 목표로하는게좋음
	
	디자인패턴에 너무 집착하면안됨
	패턴은 그냥 도구일뿐임
	
	코드의 기대수명을 생각해서 개발해야함
	
	oop는 객체 이지 클래스 가 아님
	tdd,ddd,fp 모두 잘설계된 oop를 만들기위한 방법론들임
	
	절차지향이 꼭 나쁜건아님,단지 객체지향의 ocp가 없어서 수정이 좀 빡센거지,개발속도나 이해가 쉬운코드로 보면 걔가 더 나은점도 있음
	
	oop에서 중요한건 역할/책임/협력 임
	
	객체지향에서 지키면좋은 규칙
		한메서드에 오직 한단계의 들여쓰기만 한다(뎁스깊게쓰지말라고)
		else를 사용하지않는다
		모든 원시값과 문자열을 포장한다
		한줄에 점을 하나만 찍는다(다 엔터로 내리라고)
		줄여쓰지않는다
		모든 엔티티를 작게 유지한다
		3개이상의 인스턴스변수를 가진 클래스를 사용하지않는다(클래스내변수,static이 안붙은)
		일급컬렉션을 사용한다(map같은 컬렉션이 클래스로 래핑되고,다른맴버변수가 없는것)
		게터세터프로퍼티를 사용하지않는다(그래도 게터는쓰자..)
	가 있음
	CollectionUtils,StringUtils,ObjectUtils중에 좋은 메서드들이 많음(가독성이 올라감)
	잘사용하자
	
	상속을 지양하고,composition(공통기능분리하고,그걸 멤버변수로 갖는형태)를 지향하자
	
	테스트를 먼저 생각하고,테스트하기 쉽게 짜자,짜고나서 테스트생각하는게 아니라
	
	블락(메서드내에 개행으로 분리된거)이 생기면,메서드분할을 고려하자
	
	뎁스가 2개이상 들어가면,메서드분할을 고려하자
	
	
5.스프링을 oop스럽게 사용하기	
	백엔드에서 ui란 컨트롤러임
	이 컨트롤러가 똑똑해지면 안됨(스마트ui)
	컨트롤러는 어떤 서비스를 실행할지 선택하는정도의 일만 해야함,안그래도 밸리데이션도 하고 이것저것 웹단 할거많은데,서비스로직까지 들어오면 ㄹㅇ개판됨
	보통 하위레벨의 레이어는 전부(컨트롤러->레포지토리)건드릴수 있는데,이게 스마트ui를 만들확률이 높음
	그래서 바로 하위레이어만 건드릴수있게 하는게 깔끔할확률이 높음
	
	그리고 서비스가 너무 두꺼우면(온갖 로직이 다들어가있으면),ddd처럼 domain층을 생각해봐야함
	서비스컴포넌트는 도메인객체에 작업을 위임한다(컨트롤러-서비스-도메인-레포지토리)
	즉 도메인객체가,수동적이 아닌 능동적으로 자기일을 처리할수있어야하고
	레포지토리는 jpa레포지토리를 그대로 사용하는게 아닌 추상화가 되어있어야함
	
	이게 안된,그 스프링 처음짤때처럼 짜는 코드를 트랜잭션스크립트라고 함
	이건
		수동적도메인
		모든업무규칙과 지식이 포함된 뚱뚱한 서비스
		객체지향이 아님
		테스트가힘듬
		단,개발이 빠름
	이라는 특징을 가지고있음
	이런애들은 테스트도 힘들고,객체지향도 아닌 안티패턴임
	물론 개발속도가 중요할땐 찍어내기좋긴한데,서비스가 커지면 반드시 문제가 생김
	
	비즈니스로직은 서비스가 들고있는게 아닌,도메인이 들고있어야하고,서비스는 단지 작업을 실행시키는 순서를 맞춘다거나만 해야하는것
	이렇게하면 비즈니스로직과 레포지토리의 결합을 끊어서,테스트도 편해짐
	그 스프링게시판만들기할때 썼던방식 그거그대로임(거기서 직접 레포지토리호출하는걸 다 도메인서비스로 뽑은거)
	도메인에 다 넘기고 서비스는 그거 호출하는거만 하는거
	즉 값객체가 아닌,행동이 있어야 도메인이라고 부를수있음
	
	근데 어떤 도메인도 해당 비즈니스로직을 가지고있기 애매한경우(여러도메인에 걸쳐서 값을 내야하거나)엔,새로운 도메인을 만들면됨(해당도메인들을 다 di받는)
	이렇게 만들어진 도메인을,도메인서비스라고 부름,객체로 표현하기 애매한 논리로직자체가 목적인 행위자들을 이렇게 부름
	보통 이런애들은,이름붙이기가 어려워서 뒤에 manager를 붙임
	이때 도메인서비스들은 한가지 트레이드오프가 있는데
		priceCalculator같이 하나의 책임에 특화된 객체로 만들건지(단일책임원칙을 지킴,단 함수를 래핑하는 클래스가 엄청나게 생겨남)
		Cashier같이 여러행동을 할수있게 만들건지(중복코드를 막음,단 단일책임원칙에 어긋남)
	이건 트레이드오프의 영역임
	
	기존 서비스(어플리케이션서비스)는,비즈니스결정을 내리지 않아야함(if(user.dontHaveMoney())같은))
	앱서비스는 단지 요청을 도메인과 도메인서비스에 위임할뿐임,얘들은 가능한 얇게 유지되어야함
	
	도메인서비스는 도메인레이어에 해당하는 객체임,얘는 서비스에서 건네받은 책임을 처리함
	
	이 도메인서비스는,빈으로 만들수도있고,안만들수도 있는데 이건 호불호의 영역임
		안만드는쪽은,얘들은 순수자바의 영역이라 생각해서 안만들고
		만드는쪽은 어짜피 생성자주입시기에 수동으로 주입해줘야하는데 뭐하러귀찮게 안만드냐
	라는것
	
	
	추상화는,핵심적인 개념과 기능을 간추려내는것
	즉 모듈을 격리하고 인터페이스로 만드는과정,즉 책임을 선별하는 과정임
	
	이 추상화를 어디까지해야하나?는
		시스템외부연동(db연동,즉 레포지토리,web클라이언트나 restTemplate로 외부통신)은 가능하면 추상화
			서비스->인터페이스레포지토리->인터페이스레포지토리구현체->jpa레포지토리 (게시판만들기에서 썼던방법)
			이러면 결합도가 낮아져서 레포지토리변경이 쉽고,테스트시 모킹하기가 쉬움(ocp)
			이때 중요한건,인터페이스레포지토리는 비즈니스레이어(서비스단)임
			그렇지않으면 고수준모듈이 저수준모듈을 의존하는거기때문
		서비스와 컨트롤러,엔티티는 가능한 추상화할필요없음(서비스는 구체로)
			얘네들은 한번생성으로 영원히 같은일을 할수있는 객체여야 하기때문
		도메인레이어를 추가하고,필요에따라 자유롭게 추상화(각보고 하고싶으면하고 말려면 말고)
			단,도메인레이어는 원칙적으론 레포지토리를 사용하지못함
			그래서 원칙적으론 도메인레이어쓸땐 어플리케이션서비스에서 미리 다 준비해서 도메인한테 넘겨줘야함
			단,장단이 있어서 트레이드오프임(이게안되면 불필요한쿼리가 발생해서)		
	jpa엔티티와 도메인을 분리(jpa엔티티를 도메인으로 toDomain하는식으로)는,하냐 안하냐 둘다 장단이있음
	
	개발할때,올바른 설계인가?싶으면,이코드가 테스트가 쉬운가?를 고민해보면됨
	
	
	서비스는,비즈니스레이어의 퍼사드임,즉 도메인과 도메인서비스의 퍼사드라고 해석할수도있음
	즉 도메인과 도메인서비스에게 책임을 위임하는,퍼사드패턴의 일종임
	
	도메인 연산이 필요한데,어디들어갈지 애매한게 있는데,이게 사물이 아니라 행동에 가깝고,적당한이름이 없어서 뒤에 manager같은게 붙는데,
	이때 매니저보단 서비스가 더 다른객체와의 관계성이 있어보여서 붙은거라,그냥 서비스는 매니저라고 보면됨
	즉 애들행동을 대신하는게 아닌,애들을 관리하는역할
	
	서비스는,레포지토리에 접근하는동작은 어떤 도메인도 들고있기 애매해서,서비스가 들고있는게 맞음(레포지토리에서 도메인객체를 가져온다던가)
	그래서 사실,도메인서비스를 사용하지않고 서비스에서 처리하는거도 ddd에 위배되진않음 그냥 ddd와 oop방향성에 그게 더 맞는거지
	
	그리고 도메인서비스를 도메인으로 바꿀수있으면,바꾸는게 낫고(priceCalculator->Cashier)
	단 그래도 못바꾸는로직들이 존재하긴함(뒤에 manager를 붙이면 어색하면 도메인,안어색하면 도메인서비스)
	
	대충
		어플리케이션서비스:스프링의 서비스컴포넌트에 종속되는서비스
		도메인서비스:스프링의 서비스컴포넌트에 종속되지 않는 서비스
	라고 이해해도됨
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
		
		
		
		