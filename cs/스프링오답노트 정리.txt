1.컨벤션
	자바에선
		변수:카멜케이스(abcCase)
		함수(메서드):카멜케이스(abcCase)
		클래스:파스칼케이스(AbcCase)
		패키지:전부소문자(abccase)
		상수:전부대문자(ABCCASE)
	추가로,메서드이름은 동사로시작해야함(get,set)	
	
	줄여쓰기는 가능하면 안하는게좋음,ws가 webSocket인지 webServer인지 알수없기때문
		msg->message
		ws->WebSocket
		ws->WebServer
	단,관습적으로 사용하는거(Id,app)는 그냥쓰면됨
	즉 가능하면 풀어쓰는게 코드일관성에 좋음
	
	축약어(id,ip,api같은거)는,그냥 하나의 단어로 취급해서,userID가 아닌 userId로 쓰는게 좋음
	막 IP같은거 앞에 소문자로 적어야한다고 iP이따구되니까 그냥 일반명사처럼 취급하는게 낫대
	근데 OAuth같이 일부만 축약한거(Open Auth)는 컨벤션없으니까 그때그때 알아서해줘야함
	이런건 유명한오픈소스 참고하는게좋음
	
	클래스이름에서 Simple,Light,Base같은거 사용하지말고(5개필드에서 중요한 3개필드로 줄여서쓰는 dto라던가),유의미한 정보로 대체해야함
	사람마다 심플과 복잡한거의 기준이 다르니까
	그래서 목적에 맞는 클래스명으로 짓는게 나음(SimpleDto->CreateUserDto)
	같은이유로 Util도 사용하지않는게 좋음,이러면 여기에 온갖 스태틱메서드가 모임
	그래서 생성코드면 팩토리,이런식으로 명시적으로 나눠서 사용하는게좋음
	
	메서드명에서 
		get은 리턴이 T일경우(널일경우 예외던질떄)
		find는 리턴이 Optional<T>일 경우(널이라도 리턴할떄,즉 값이 없다는 정보를 줘야할때)
	사용됨,즉 널을 허용하냐 안하냐에 따라 다름,둘을 구분해야함
	단,TypeORM같은경우엔 그런거 구분안하고사용함
	
	isExist(이게존재하냐)는 사용하지않고,exists로 대체,동사반복이라서 없는단어임
	
	get은 기본적으로 내가 가지고있는 멤버변수를 그대로 돌려주는거임,이걸 어디서 찾아오거나 계산해야하면 get이 아님
	즉 내가가진 모든값을 더한걸 반환한다고 하면,getSumPrice가 아닌 SumPrice가 맞음
	
	롬복 getter과 setter은 생각하고 넣어야함,사실상 멤버변수를 퍼블릭으로 여는거랑 똑같고,객체를 수동적으로 만듬
	객체가 수동적이라는건,객체가 데이터를 저장하고 보여주는것 말곤 아무일도 하지않는것(아무 메서드 없는 도메인)
	그래서 객체를 능동적으로 만드는게 좋음(자기가 할일은 자기가 처리하게)
	즉 
		user.setStatus(Status.ACTIVE)
	를
		user.inactive()
	처럼 도메인내부에 자기멤버변수를 가지고 할수있는일은 도메인 자기자신이 처리하게 만드는게 좋음(TDA원칙)	
	setter는 dto정도말곤 안넣는게좋고
	
	주석은 정말 필요할때만 사용,어지간하면 주석을 다는거보다,그 내용을 유의미한의미를 가진 메서드로 분리하는게 나음
	즉 주석을 달고싶다고 느껴지면,메서드를 분리하라는 신호임
	
	Optional을 자주 사용하면,코드의 완성도를 높이고 런타임에러를 줄여줌(널포인트익셉션)
	
	Collection.Map를 남발하면 안됨,다른사람이 이해하기 매우어려워짐
	가급적 직접 맵을 쓰는대신 일급클래스(다른맴버변수가 없고 클래스내에 맵같은 콜렉션만 있는 클래스)로 뽑아서 만들고,
	만약 사용해도 지정된 스코프 밖(현재 클래스 밖에서 get해서 뭐한다던가)을 넘나들면안됨
	
	range는 보통 start는 포함시키고,end는 제외시킴(0부터10까지 루프면 start=0 end=11),관습적으로 이럼
	end만 있을경우에도 제외시킴
	for문짤때 <로 사용하는거처럼
	
	검증이 필요할떄 verify,validate,check,is --->늬앙스차이있으니 검색해보자
	추가적으로 구글 코드 스타일 가이드 참고하면되고(eslint처럼 적용할수도있음),
	클래스이름의 단어조합은 가능한3개이하로 하는게좋음
	그리고 컨벤션은 사내규칙에 따라 일관적으로 쓰는게좋음
		
2.객체지향적 코드짜기		
	객체의 종류엔
		vo(value Object):단순히 값만 가지고있는 객체,모든 필드에 final이 붙어있고,생성자를 통해서 만들면 변경할수없음,
			변수는 변해도 값은 변할수없으니 값객체라고 부르는거,
			vo는 불변해야하고,동일하게 생성된 두 vo는 영원히 동일해야함,즉 그래서 인스턴스화된 vo는 항상 유효해야함
			객체를 메서드의 파라미터로 던져줄때,항상 처음만들어졌을때와 동일하다는게 보장되기때문에 개발복잡도와 시스템복잡도가 낮아짐
			그리고 vo는 항상 유효해야하기때문에,생성자에서 무조건 값이 유효한지 밸리데이션을 해야함,그래야 믿고쓸수있음
		DTO(Data Transfer Object):데이터 전달에 사용되는 객체,그냥 메서드간,클래스간,프로세스간 통신할때 사용하는 모든객체를 dto라고함
			그래서 getter setter 다 열려있어도 상관없음(아예 멤버변수를 퍼블릭으로 둬도 된다고그러긴함 어짜피 getset둘다달면 똑같으니)
			이건 그냥 데이터를 하나하나 던지기 힘드니까,묶어서 던지는 객체라고 보면됨
		Entity:id값이 있고,수명주기(영속성컨텍스트같은)가 있어야함,일반적으로 db에 저장할수있어서 지속성을 가져서 나중에 다시불러올수있음
	등이 있음
	단,모든객체가 이 3가지안에 들어가지않고,vo이면서 엔티티일수도 잇고,dto이면서 po일수도있고,셋 다 아닐수도있음
	분류보다 어떤값을 final로 쓸건지,어떤 인터페이스를 노출할것인지(어떤메서드를 public로 선언할건지)가 더 중요
	추가적으로 dao는 repository와 같은말임
							
	그리고 생성자는 가급적 값을 검증하고,값을 할당하는 이 두가지일만 하는게 좋음
	
	디미터법칙은 최소지식법칙이라고도 불리며,모듈은 자신이 조작하는 객체의 속사정을 몰라야 한다는것
	즉,객체내부를 체이닝으로 줄줄히 들어가서 조작하는 코드가 잇거나 그러면 디미터법칙 위반임
		foreach
			size+=com.getDisks().get(i).getSize(); //총디스크크기 
	이러면 안된다는것
	이소리는,tda원칙으로 해당 객체에 그 일을 할수있는 메서드를 만들어야 한다는것
	이때도 메서드의 이름을 getDiskSize()로 뽑고,이걸 println으로 뽑는게 아닌(일단 계산하니까 get떼야하고)
		System.out.println(com.getDiskSize())
	해당객체한테 프린트하는거까지 시키면됨
		com.printSpec();
	이렇게
	
	클래스를 만들땐,필드를 먼저 생각하는게 아닌 메서드를 먼저 생각하고,그 메서드에서 필요한 필드를 생성하는게 맞는순서임
	자동차를 만든다고하면,운전메서드,속도조절메서드,방향전환메서드를 먼저 생각해야함
	즉 데이터위주의 사고가 아닌,행동위주의 사고를 해야함
	즉 덕타이핑과 같은소리임,필드가 중요한게 아니라 객체는 메서드가 제일 중요하니 ..
	
	순환참조(양방향참조,jpa oneToMany+ManyToOne)는 기본적으로 만들면 안됨,정 어쩔수없을때만 만들어야함
		순환의존성이 있다는거 자체가 결합도가 올라감
		순환참조가 있으면 직렬화가 불가능해짐(서로 참조하니까 양방향부분은떼고해야함,toString생각하면됨)
	차라리 간접참조로,엔티티는 외래키만 가지고있고 연관관계는 단방향으로 해둔다음 필요할때마다 그거로 레포지토리에서 찾아오는게 나음
	순환참조를 유도하는 기능이 있으면,이걸 어케 별도의 클래스로 분할할수없는지 고민해야함
	순환참조가 없으면
		mappedBy를 고민안해도됨
		복잡도를 낮추고 응집도를 높임
	같은 장점이 있음
	
	그리고 추가적으로
		가능하면 final로 선언하고,안되면 안되는 이유를 찾자
		vo에서도 변경자가 들어갈수있는데,단 이경우엔 무조건 새로운 vo를 반환하는 메서드가 되어야함
		그래서 이름도 changePassword같은게 아닌 withNewPassword같은게 더 좋음(일반변경메서드와 구분하기위해 메서드이름을 전치사로 시작)
	도 신경쓰면좋음
		
		
3.설계 
	solid
		단일책임원칙:클래스는 하나의책임만 가져야하고,그 책임을 완전히 캡슐화해야함,클래스에 코드라인이 100줄이상이면 의심
		개방폐쇄원칙:확장에열리고,수정에닫혀야함,보통 추상화(인터페이스화)가 부족할경우 이게 깨짐
		리스코프치환원칙:하위객체는 상위객체가 하는일을 완전히 대체할수있어야함,상위와하위의 계약(인터페이스)이 깨질때 이게 깨짐
			이거때문에 상속이 구현보다 사용하기꺼려지는것
		인터페이스분리원칙:클라이언트가 자신이 이용하지않는 메서드에 의존하면안됨,이건 인터페이스를 분리해서 조립하듯이 개발하지않으면 깨짐
			인터페이스는,이기능을 사용하려면 이 방법을 사용하게 만들어라라고 계약하고,계약을 지켜서 만드는것(인터페이스의 메서드)
			굳이 interface가 아니라도,클래스의 퍼블릭메서드도 인터페이스긴함,인터페이스가 생략되고 바로 구현체에 붙은거지
			그래서 api도 인터페이스임
			이 인터페이스는,구현체 안에서 사용하지않는 메서드가 없도록 각각 잘 분리해서,2개이상이 필요하면 2개를 구현하도록 만들어져야함
		의존성역전원칙:상위모듈은 하위모듈에 의존하면안됨,상위하위둘다 인터페이스에 의존해야함
			추상화는 세부사항에 의존하면안됨,세부사항이 추상화에 의존해야함
			즉 인터페이스가 있고 구현체가 있는거지,구현체에 인터페이스를 맞추면안됨
	이렇게있음
	
	여기서 의존성이란,a가 b를 사용하기만 해도 a는 b에 의존성을 가지는것,즉 import되면 의존성이 있다고 할수있음
	이 의존성을 직접 new해서 생성하지않고(강결합),외부에서 넣어주는걸 사용하면(약결합) 이게 의존성주입임
	즉 구현체에 직접 의존하는게 강결합이고,
	인터페이스에 의존하고,인터페이스 구현체를 받아서 사용하는게 약결합임
	
	의존성 주입과 의존성 역전은 다름
	의존성 주입은 단순히 의존성을 주입받는,강결합을 약결합으로 만드는걸 말하고
	의존성 역전은 모듈사이에 인터페이스를 두고 통신하게되는걸 말함(상위하위 모두 인터페이스만 의존)
	즉 의존성역전을 위해,의존성 주입을 사용하는것
	스프링은 의존성 주입도구임,의존성 역전을 만들어주지않음
	
	그래서 레이어드아키텍쳐를 사용할때,컨트롤러서비스레포지토리를 추상화없이 사용하면,일반적으로 나쁘고,절차지향적 코드가 나올가능성이 커짐
	물론 그렇다고 전부 추상화하면 개귀찮으니까,각보고 알아서정해야함
	
	그리고 생성자주입이 7개,파라미터주입이 4개이상 넘어간다면,클래스분할이나 메서드분할을 고려해야하는 신호임
	
	가능하면 의존성은 드러내는게 좋음
	즉,내부로직에서 의존하고있는건 가능하면 파라미터같은거로 받는게,그걸 사용하는사람이 확인하기 쉬움
	그리고 이렇게 하는게 테스트하기도 쉬움(특히 시간이나 랜덤같은,실행할때마다 변하는값)
	즉,변하는값은 외부에서 주입받는게 좋음
	근데 이렇게하려면,계속 상위객체로 갈때마다 해당메서드에 파라미터가 하나씩 추가됨(상위에서도 감춰진거 풀고 하려면)
	결국 누군가는 고정된 의존성을 주입해줘야함
	그래서 가장 괜찮은방법은,런타임의존성과 컴파일타임의존성을 다르게하는것(변하는값을 추상화해서 스프링같은거로 di받는것)
	즉 인터페이스에만 의존하고,구현체는 스프링이 알아서 넣어달라고 '해줘' 하는거임
	이렇게해서,테스트시와 배포시에 의존성넣는걸 변경해서 처리할수있음(의존성역전을 사용해서 처리하는것)
	그 스프링게시판만들기할때 사용했던,레포지토리 의존 나누는거 그거임
	
	보통 테스트하기가 쉬우면,좋은코드일 확률이 높음
	
	cqrs는,명령과 쿼리를 분리하는것
	즉 메서드나 클래스를 명령과 쿼리로 나누는것
	이때 주의해야할건,명령에서 return this로 변경되거나 추가된 결과물을 던져버리면,쿼리결과가 날아간거라서 cqrs가 아님
	그래서 명령은 void가 되는게 맞음
	쿼리는 값을 변경시켜선 안됨
	즉
		하나의 메서드는 명령이나 쿼리여야하고
		명령은 객체의 상태를 변경할수있지만,값을 반환하지않음
		쿼리는 값을 반환하지만 객체를 변경하지않음
		
4.실수
	api500에러는 사실상 장애상황임
	api가 실패하면 원인을 반드시 리턴해줘야하고,거기에 맞는 http상태코드를 내려줘야함
	500은 그냥 장애선언임
	
	좋은프로그램은
		1.돌아가야함
		2.유지보수가 가능해야함
	설계만 백만년하고있으면 안됨,80점짜리 코드를 빨리뽑는걸 목표로하는게좋음
	
	디자인패턴에 너무 집착하면안됨
	패턴은 그냥 도구일뿐임
	
	코드의 기대수명을 생각해서 개발해야함
	
	oop는 객체 이지 클래스 가 아님
	tdd,ddd,fp 모두 잘설계된 oop를 만들기위한 방법론들임
	
	절차지향이 꼭 나쁜건아님,단지 객체지향의 ocp가 없어서 수정이 좀 빡센거지,개발속도나 이해가 쉬운코드로 보면 걔가 더 나은점도 있음
	
	oop에서 중요한건 역할/책임/협력 임
	
	객체지향에서 지키면좋은 규칙
		한메서드에 오직 한단계의 들여쓰기만 한다(뎁스깊게쓰지말라고)
		else를 사용하지않는다
		모든 원시값과 문자열을 포장한다
		한줄에 점을 하나만 찍는다(다 엔터로 내리라고)
		줄여쓰지않는다
		모든 엔티티를 작게 유지한다
		3개이상의 인스턴스변수를 가진 클래스를 사용하지않는다(클래스내변수,static이 안붙은)
		일급컬렉션을 사용한다(map같은 컬렉션이 클래스로 래핑되고,다른맴버변수가 없는것)
		게터세터프로퍼티를 사용하지않는다(그래도 게터는쓰자..)
	가 있음
	CollectionUtils,StringUtils,ObjectUtils중에 좋은 메서드들이 많음(가독성이 올라감)
	잘사용하자
	
	상속을 지양하고,composition(공통기능분리하고,그걸 멤버변수로 갖는형태)를 지향하자
	
	테스트를 먼저 생각하고,테스트하기 쉽게 짜자,짜고나서 테스트생각하는게 아니라
	
	블락(메서드내에 개행으로 분리된거)이 생기면,메서드분할을 고려하자
	
	뎁스가 2개이상 들어가면,메서드분할을 고려하자
	
	
5.스프링을 oop스럽게 사용하기	
	백엔드에서 ui란 컨트롤러임
	이 컨트롤러가 똑똑해지면 안됨(스마트ui)
	컨트롤러는 어떤 서비스를 실행할지 선택하는정도의 일만 해야함,안그래도 밸리데이션도 하고 이것저것 웹단 할거많은데,서비스로직까지 들어오면 ㄹㅇ개판됨
	보통 하위레벨의 레이어는 전부(컨트롤러->레포지토리)건드릴수 있는데,이게 스마트ui를 만들확률이 높음
	그래서 바로 하위레이어만 건드릴수있게 하는게 깔끔할확률이 높음
	
	그리고 서비스가 너무 두꺼우면(온갖 로직이 다들어가있으면),ddd처럼 domain층을 생각해봐야함
	서비스컴포넌트는 도메인객체에 작업을 위임한다(컨트롤러-서비스-도메인-레포지토리)
	즉 도메인객체가,수동적이 아닌 능동적으로 자기일을 처리할수있어야하고
	레포지토리는 jpa레포지토리를 그대로 사용하는게 아닌 추상화가 되어있어야함
	
	이게 안된,그 스프링 처음짤때처럼 짜는 코드를 트랜잭션스크립트라고 함
	이건
		수동적도메인
		모든업무규칙과 지식이 포함된 뚱뚱한 서비스
		객체지향이 아님
		테스트가힘듬
		단,개발이 빠름
	이라는 특징을 가지고있음
	이런애들은 테스트도 힘들고,객체지향도 아닌 안티패턴임
	물론 개발속도가 중요할땐 찍어내기좋긴한데,서비스가 커지면 반드시 문제가 생김
	
	비즈니스로직은 서비스가 들고있는게 아닌,도메인이 들고있어야하고,서비스는 단지 작업을 실행시키는 순서를 맞춘다거나만 해야하는것
	이렇게하면 비즈니스로직과 레포지토리의 결합을 끊어서,테스트도 편해짐
	그 스프링게시판만들기할때 썼던방식 그거그대로임(거기서 직접 레포지토리호출하는걸 다 도메인서비스로 뽑은거)
	도메인에 다 넘기고 서비스는 그거 호출하는거만 하는거
	즉 값객체가 아닌,행동이 있어야 도메인이라고 부를수있음
	
	근데 어떤 도메인도 해당 비즈니스로직을 가지고있기 애매한경우(여러도메인에 걸쳐서 값을 내야하거나)엔,새로운 도메인을 만들면됨(해당도메인들을 다 di받는)
	이렇게 만들어진 도메인을,도메인서비스라고 부름,객체로 표현하기 애매한 논리로직자체가 목적인 행위자들을 이렇게 부름
	보통 이런애들은,이름붙이기가 어려워서 뒤에 manager를 붙임
	이때 도메인서비스들은 한가지 트레이드오프가 있는데
		priceCalculator같이 하나의 책임에 특화된 객체로 만들건지(단일책임원칙을 지킴,단 함수를 래핑하는 클래스가 엄청나게 생겨남)
		Cashier같이 여러행동을 할수있게 만들건지(중복코드를 막음,단 단일책임원칙에 어긋남)
	이건 트레이드오프의 영역임
	
	기존 서비스(어플리케이션서비스)는,비즈니스결정을 내리지 않아야함(if(user.dontHaveMoney())같은))
	앱서비스는 단지 요청을 도메인과 도메인서비스에 위임할뿐임,얘들은 가능한 얇게 유지되어야함
	
	도메인서비스는 도메인레이어에 해당하는 객체임,얘는 서비스에서 건네받은 책임을 처리함
	
	이 도메인서비스는,빈으로 만들수도있고,안만들수도 있는데 이건 호불호의 영역임
		안만드는쪽은,얘들은 순수자바의 영역이라 생각해서 안만들고
		만드는쪽은 어짜피 생성자주입시기에 수동으로 주입해줘야하는데 뭐하러귀찮게 안만드냐
	라는것
	
	
	추상화는,핵심적인 개념과 기능을 간추려내는것
	즉 모듈을 격리하고 인터페이스로 만드는과정,즉 책임을 선별하는 과정임
	
	이 추상화를 어디까지해야하나?는
		시스템외부연동(db연동,즉 레포지토리,web클라이언트나 restTemplate로 외부통신)은 가능하면 추상화
			서비스->인터페이스레포지토리->인터페이스레포지토리구현체->jpa레포지토리 (게시판만들기에서 썼던방법)
			이러면 결합도가 낮아져서 레포지토리변경이 쉽고,테스트시 모킹하기가 쉬움(ocp)
			이때 중요한건,인터페이스레포지토리는 비즈니스레이어(서비스단)임
			그렇지않으면 고수준모듈이 저수준모듈을 의존하는거기때문
		서비스와 컨트롤러,엔티티는 가능한 추상화할필요없음(서비스는 구체로)
			얘네들은 한번생성으로 영원히 같은일을 할수있는 객체여야 하기때문
		도메인레이어를 추가하고,필요에따라 자유롭게 추상화(각보고 하고싶으면하고 말려면 말고)
			단,도메인레이어는 원칙적으론 레포지토리를 사용하지못함
			그래서 원칙적으론 도메인레이어쓸땐 어플리케이션서비스에서 미리 다 준비해서 도메인한테 넘겨줘야함
			단,장단이 있어서 트레이드오프임(이게안되면 불필요한쿼리가 발생해서)		
	jpa엔티티와 도메인을 분리(jpa엔티티를 도메인으로 toDomain하는식으로)는,하냐 안하냐 둘다 장단이있음
	
	개발할때,올바른 설계인가?싶으면,이코드가 테스트가 쉬운가?를 고민해보면됨
	
	
	서비스는,비즈니스레이어의 퍼사드임,즉 도메인과 도메인서비스의 퍼사드라고 해석할수도있음
	즉 도메인과 도메인서비스에게 책임을 위임하는,퍼사드패턴의 일종임
	
	도메인 연산이 필요한데,어디들어갈지 애매한게 있는데,이게 사물이 아니라 행동에 가깝고,적당한이름이 없어서 뒤에 manager같은게 붙는데,
	이때 매니저보단 서비스가 더 다른객체와의 관계성이 있어보여서 붙은거라,그냥 서비스는 매니저라고 보면됨
	즉 애들행동을 대신하는게 아닌,애들을 관리하는역할
	
	서비스는,레포지토리에 접근하는동작은 어떤 도메인도 들고있기 애매해서,서비스가 들고있는게 맞음(레포지토리에서 도메인객체를 가져온다던가)
	그래서 사실,도메인서비스를 사용하지않고 서비스에서 처리하는거도 ddd에 위배되진않음 그냥 ddd와 oop방향성에 그게 더 맞는거지
	
	그리고 도메인서비스를 도메인으로 바꿀수있으면,바꾸는게 낫고(priceCalculator->Cashier)
	단 그래도 못바꾸는로직들이 존재하긴함(뒤에 manager를 붙이면 어색하면 도메인,안어색하면 도메인서비스)
	
	대충
		어플리케이션서비스:스프링의 서비스컴포넌트에 종속되는서비스
		도메인서비스:스프링의 서비스컴포넌트에 종속되지 않는 서비스
	라고 이해해도됨
	가장 중요한건
		도메인을 풍부하게 만들고
		서비스를 가능한 얇게 만들자
	임,도메인이 핵심이고 스프링은 껍데기
	
	서비스는 한번생성하면 영원히 쓸수있어야함,그래서 생성자주입만 써서 di받고나선 의존성을 바꿀수있으면 안됨(final이 강제됨)
	즉
		서비스에 setter가 있으면안됨
		반드시 생성자주입
		서비스의 멤버변수는 전부 final
	이어야함
	
	추가적으로,생성자주입을 하면,순환참조를 막아줌(순환참조는 사실 하나의컴포넌트라는 의미일수있음)
	그래서 a와 b를 서로 순환참조하는게 아닌,a와b를 참조하는 c가 있는게 나음
	
	
	
	jpa자체는 자바표준이고,하이버네이트가 그거 구현한 구현체,스프링jpa는 이걸 좀 래핑한거
	
	연관관계의 주인은,many쪽이 해당되는데,얘들이 외래키를 가지고있음(외래키자체를 연관관계의 주인이라고 표현해도됨)
	왜 연관관계의 주인이냐면,주도권을 얘들이 가지고있기때문
	기본키가 사라지면,그냥 애초에 잘못된 엔티티이고,연관관계측면에선 외래키가 없어지면 서로간의 연관관계가 사라지기때문
	그리고 애초에 양방향관계를 만들지않는게 좋음
	
	n+1은,패치조인으로 해결(애초에 모든 연관관계는 lazy여야하고 일단)
	그리고 애초에 레포지토리단에서 쿼리를 두번날리는거로 해결하는 방법도있음(팀과,팀아이디외래키를 가지고있는 대상)
	그리고 이 두개를 조합해서 도메인으로 바꾸는거
	
	jpa레포지토리를 쓸때,jpa레포지토리에 입력된타입과 리턴된값이 일치하는게 좋음
	즉,post레포지토리에서 comment가 반환되면 몬가몬가 이상하니까..
	
	jpa 낙관적잠금은,버전로우를 추가해서 이거로 변경감지하는것,락보단 충돌방지에 가까움
	비관적잠금은,for update를 사용해서 실제로 락을 거는방식
	
	cqrs를 적용하는곳에선,repository대신 reader과 writer라는 이름을 사용하고,
	같은테이블을 참조해도 UserReadonly(vo),UserEditable(변경가능한객체)라는 엔티티를 2개만드는 경우도있음
	
	스프링에서 aop 내부호출이 일어나면,스프링 프록시구조상 aop가 적용되지않음(프라이빗과 똑같이취급)
	
	스프링에서 List<인터페이스>를 di받으면,그 인터페이스를 구현하는 모든 구현체가(빈으로 만들어진)주입됨
	
	테스트용으로 레포지토리를 직접 구현해서 사용하기도 함(그 게시판만들기에서 했던 그거,이거 비효율적인거 아닌가 생각들던 그거맞음)
	장점으로,h2안띄워도되고,nosql같이 인메모리db가없는거도 테스트가 가능해지고,테스트실행속도가 빨라짐
	단점으로,개발할게 2배로 늘어나고,실제 실행환경과 같다는걸 보장할수없음
	이런걸 fake라고 부름
	
	
	
6.테스트
	테스트의 가장 큰 이유는,회귀테스트임
	회귀테스트로 다른곳에 영향을줬으면 바로 알수있게하고,수정이 덜 무섭게 하는것
	
	테스트는 크게 인수테스트와 자동테스트로 나눌수있음
	인수테스트는,체크리스트로 관리하면서 테스트항목을 하나하나 사람이 검사하는것
	자동테스트는,테스트코드로 돌리는것
	
	단위테스트는,단일서버,단일프로세스,단일스레드에서 돌아가야하고,디스크io를 허용하지않고,블록킹을 허용하지않음
	그래서 외부랑 통신이 있으면(db나 외부api호출),더미나 모킹같은걸 사용해야함
	통합테스트는,단일서버,멀티프로세스,멀티스레드에서 돌아가고,테스트용db를 사용할수있음(h2)
	멀티스레드+외부통신이 있기때문에,결과가 항상 같을거라는 보장을 하지못함
	api테스트는,멀티서버까지 허용해서,e2e테스트를 할수있어짐
	
	여기서 가장 중요한건 단위테스트임
	빠르고 결정적인 테스트를 여러개만들어서,코드커버리지를 높여야함
	대충 비율은 유닛80%,통합15%,api5%인게 이상적
	
	만약 api테스트만 계속늘리면,테스트실행이 길어지고 결과가 불안정해서 실패가 많아짐
	그리고 코드커버리지가 약하기도하고
	이게 아이스크림패턴이라는 안티패턴임
	
	그리고 여기서 api테스트와 단위테스트만 늘리면(통합이 작은 모래시계모양) 이거도 안티패턴임
	
	테스트에서 사용하는 개념들은
		SUT:테스트를 하려는 대상
		tdd:깨지는테스트를 먼저 작성하고,이걸 성공시키고(통과만하면됨 코드퀄리티상관x) 리팩토링하는 기법
			이떄,인터페이스에게 기대하는 모든 동작을 테스트로 만들어야함
		bdd:메소드위주의 테스트코드보다 시나리오기반 테스트를 하는방식(GWT랑 같은거)
		불규칙한테스트:대상코드에 아무 변화가 없음에도 실패하는테스트(결정적이지 않은 테스트)
		깨지기쉬운테스트:검증대상코드와 관련없는 변경으로 실패하는 테스트,테스트에 필요한 가정들이 명시적으로 작성되어있지않아 발생함
		상호작용테스트:메소드가 실제로 호출이 됐는지 검증하는테스트,별로 좋은테스트는아님(캡슐화에 위배)
			상호작용테스트보단,상태(결과)를 테스트하는게좋음
		테스트더블:테스트대역,즉 더미,모킹같은걸 말함
	이 있고,테스트더블(대역)에는
		더미:아무동작도 하지않고(메서드에 코드가 아예없음),코드가 정상적으로 돌아가기위해 전달하는 객체
			즉 인터페이스만 구현한거임
		fake:로컬에서 사용하거나(로컬에서 개발할때 이걸써서 개발하기도함),테스트에서 사용하기위해 만들어진 가짜객체,
			자체적인 로직이 있음(실제로직이랑 다르긴하겠지만),그 게시판만들기에서 레포지토리 테스트한다고 썼던방식
		stub:미리 준비된 값을 출력하는 객체,주로 외부연동하는컴포넌트에서 많이사용함(ex:return "abcd")
			보통 mockito프레임워크를 사용함
		mock:메소드호출을 확인하기 위한 객체,자가검증능력을 갖춤(사실 테스트더블과 같은의미로 사용됨,그래서 fake,더미,stub 전부 mock임)
		spy:모든 메서드호출을 전부 기록해서 나중에 확인하기위한 객체(mock+로그저장)
	이 있음
	
	mock프레임워크는,자바쪽에선 mockito나 bddMockito를 사용함
	사실상 똑같은데,bddMockito는 메서드이름만 바꾼거임(bdd스럽게)
	
	그리고 mock프레임워크 사용은 가능하면 지양하는게 나음
	테스트코드의 목적은
		회귀버그방지
		유연한설계
	인데 여기서 유연한설계부분을 전혀 챙길수 없게됨
	너무 날먹이라서 ㅋㅋ
	
	테스트코드는 좀더 사람이 읽기쉽게(아무것도 모르는사람이라도)짜는게 좋음
	
	코틀린에서 테스트도구는 kotest가 있음(그냥 자바꺼 써도되긴하지만)
	
	같은테스트인데 파라미터수치만 바꿔서 테스트해야할떄,Parameterized test라는걸 사용할수있음
	
	
	private메서드는 테스트할필요없음,즉 모든 메서드에 테스트를 할필요는 없음
	private메서드를 테스트하고싶은 느낌이 든다면,책임할당이 제대로 안됐을수있음,
	즉 다른클래스로 분리하고 퍼블릭으로 만들었어야 하는거였을수있음	
	메서드 지향의 테스트가 아닌,행위에 집중해서 테스트를 해야함
	
	final메서드를 stub해야하면,설계가 잘못된것
	해당메서드에 걸린 의존성을 약하게 하는방법을 찾아봐야함
	이런경우 해당final메서드를 사용하는 별도의 클래스를 만들어서,의존성을 약하게만드는 방법에 대해 고민해야함
	
	테스트는,반복을 허용하고 독립적이고 서술적이며 의미있는 문구로 작성해야함
	
	테스트에 논리로직을 넣으면안됨(for,if,덧셈,뺄셈)
	테스트에서 버그가 생기면 머리아프니까 직관적이게 짜야함
	
	
	테스트하기 어려운 의존성이 있을땐,의존성 추상화(레포지토리 추상화같은거)를 사용할수있음(실제 객체를 인터페이스로 싸서 그걸의존)
	이건
		다루기 까다로운경우:random,time
		테스트에 필요한 인스턴스생성이 힘든경우:httpRequest
		재정의가 까다로운경우:final,전역참조
	같은 문제가 있을때 사용할수있음
	이렇게 의존성을 약하게 만들어서(의존성역전) 테스트를 쉽게하는것
	
	테스트코드를 위한 getter가 남발되면 힘드니,이벤트 기반으로(이때까지 했던 기록들을 전부 기록)해서,역산하는 방법도 있음
	이게 이벤트기록임
	
	
	오버엔지니어링도 언더엔지니어링과 마찬가지로 좋지않음
	추상화는 대체적으로 좋음,고민되면 해도됨
	테스트는 행동위주의 사고를 도와줌(객체의 행동은 이렇게해야하고,이런 책임이 주어져야해)
	tdd는
		요구사항이 명확하지않으면 적용이 힘듬
		환경제어가 힘듬
		기존코드를 tdd하기 어려움
		프로젝트가 유지보수를 하지못하고 터지면,그대로 손해임(오버엔지니어링)
	라는 한계가 있음
	
	
	
7.실무개념정리	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
		
		
		
		