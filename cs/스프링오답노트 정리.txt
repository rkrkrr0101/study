1.컨벤션
	자바에선
		변수:카멜케이스(abcCase)
		함수(메서드):카멜케이스(abcCase)
		클래스:파스칼케이스(AbcCase)
		패키지:전부소문자(abccase)
		상수:전부대문자(ABCCASE)
	추가로,메서드이름은 동사로시작해야함(get,set)	
	
	줄여쓰기는 가능하면 안하는게좋음,ws가 webSocket인지 webServer인지 알수없기때문
		msg->message
		ws->WebSocket
		ws->WebServer
	단,관습적으로 사용하는거(Id,app)는 그냥쓰면됨
	즉 가능하면 풀어쓰는게 코드일관성에 좋음
	
	축약어(id,ip,api같은거)는,그냥 하나의 단어로 취급해서,userID가 아닌 userId로 쓰는게 좋음
	막 IP같은거 앞에 소문자로 적어야한다고 iP이따구되니까 그냥 일반명사처럼 취급하는게 낫대
	근데 OAuth같이 일부만 축약한거(Open Auth)는 컨벤션없으니까 그때그때 알아서해줘야함
	이런건 유명한오픈소스 참고하는게좋음
	
	클래스이름에서 Simple,Light,Base같은거 사용하지말고(5개필드에서 중요한 3개필드로 줄여서쓰는 dto라던가),유의미한 정보로 대체해야함
	사람마다 심플과 복잡한거의 기준이 다르니까
	그래서 목적에 맞는 클래스명으로 짓는게 나음(SimpleDto->CreateUserDto)
	같은이유로 Util도 사용하지않는게 좋음,이러면 여기에 온갖 스태틱메서드가 모임
	그래서 생성코드면 팩토리,이런식으로 명시적으로 나눠서 사용하는게좋음
	
	메서드명에서 
		get은 리턴이 T일경우(널일경우 예외던질떄)
		find는 리턴이 Optional<T>일 경우(널이라도 리턴할떄,즉 값이 없다는 정보를 줘야할때)
	사용됨,즉 널을 허용하냐 안하냐에 따라 다름,둘을 구분해야함
	단,TypeORM같은경우엔 그런거 구분안하고사용함
	
	isExist(이게존재하냐)는 사용하지않고,exists로 대체,동사반복이라서 없는단어임
	
	get은 기본적으로 내가 가지고있는 멤버변수를 그대로 돌려주는거임,이걸 어디서 찾아오거나 계산해야하면 get이 아님
	즉 내가가진 모든값을 더한걸 반환한다고 하면,getSumPrice가 아닌 SumPrice가 맞음
	
	롬복 getter과 setter은 생각하고 넣어야함,사실상 멤버변수를 퍼블릭으로 여는거랑 똑같고,객체를 수동적으로 만듬
	객체가 수동적이라는건,객체가 데이터를 저장하고 보여주는것 말곤 아무일도 하지않는것(아무 메서드 없는 도메인)
	그래서 객체를 능동적으로 만드는게 좋음(자기가 할일은 자기가 처리하게)
	즉 
		user.setStatus(Status.ACTIVE)
	를
		user.inactive()
	처럼 도메인내부에 자기멤버변수를 가지고 할수있는일은 도메인 자기자신이 처리하게 만드는게 좋음(TDA원칙)	
	setter는 dto정도말곤 안넣는게좋고
	
	주석은 정말 필요할때만 사용,어지간하면 주석을 다는거보다,그 내용을 유의미한의미를 가진 메서드로 분리하는게 나음
	즉 주석을 달고싶다고 느껴지면,메서드를 분리하라는 신호임
	
	Optional을 자주 사용하면,코드의 완성도를 높이고 런타임에러를 줄여줌(널포인트익셉션)
	
	Collection.Map를 남발하면 안됨,다른사람이 이해하기 매우어려워짐
	가급적 직접 맵을 쓰는대신 일급클래스(다른맴버변수가 없고 클래스내에 맵같은 콜렉션만 있는 클래스)로 뽑아서 만들고,
	만약 사용해도 지정된 스코프 밖(현재 클래스 밖에서 get해서 뭐한다던가)을 넘나들면안됨
	
	range는 보통 start는 포함시키고,end는 제외시킴(0부터10까지 루프면 start=0 end=11),관습적으로 이럼
	end만 있을경우에도 제외시킴
	for문짤때 <로 사용하는거처럼
	
	검증이 필요할떄 verify,validate,check,is --->늬앙스차이있으니 검색해보자
	추가적으로 구글 코드 스타일 가이드 참고하면되고(eslint처럼 적용할수도있음),
	클래스이름의 단어조합은 가능한3개이하로 하는게좋음
	그리고 컨벤션은 사내규칙에 따라 일관적으로 쓰는게좋음
		
2.객체지향적 코드짜기		
	객체의 종류엔
		vo(value Object):단순히 값만 가지고있는 객체,모든 필드에 final이 붙어있고,생성자를 통해서 만들면 변경할수없음,
			변수는 변해도 값은 변할수없으니 값객체라고 부르는거,
			vo는 불변해야하고,동일하게 생성된 두 vo는 영원히 동일해야함,즉 그래서 인스턴스화된 vo는 항상 유효해야함
			객체를 메서드의 파라미터로 던져줄때,항상 처음만들어졌을때와 동일하다는게 보장되기때문에 개발복잡도와 시스템복잡도가 낮아짐
			그리고 vo는 항상 유효해야하기때문에,생성자에서 무조건 값이 유효한지 밸리데이션을 해야함,그래야 믿고쓸수있음
		DTO(Data Transfer Object):데이터 전달에 사용되는 객체,그냥 메서드간,클래스간,프로세스간 통신할때 사용하는 모든객체를 dto라고함
			그래서 getter setter 다 열려있어도 상관없음(아예 멤버변수를 퍼블릭으로 둬도 된다고그러긴함 어짜피 getset둘다달면 똑같으니)
			이건 그냥 데이터를 하나하나 던지기 힘드니까,묶어서 던지는 객체라고 보면됨
		Entity:id값이 있고,수명주기(영속성컨텍스트같은)가 있어야함,일반적으로 db에 저장할수있어서 지속성을 가져서 나중에 다시불러올수있음
	등이 있음
	단,모든객체가 이 3가지안에 들어가지않고,vo이면서 엔티티일수도 잇고,dto이면서 po일수도있고,셋 다 아닐수도있음
	분류보다 어떤값을 final로 쓸건지,어떤 인터페이스를 노출할것인지(어떤메서드를 public로 선언할건지)가 더 중요
	추가적으로 dao는 repository와 같은말임
							
	그리고 생성자는 가급적 값을 검증하고,값을 할당하는 이 두가지일만 하는게 좋음
	
	디미터법칙은 최소지식법칙이라고도 불리며,모듈은 자신이 조작하는 객체의 속사정을 몰라야 한다는것
	즉,객체내부를 체이닝으로 줄줄히 들어가서 조작하는 코드가 잇거나 그러면 디미터법칙 위반임
		foreach
			size+=com.getDisks().get(i).getSize(); //총디스크크기 
	이러면 안된다는것
	이소리는,tda원칙으로 해당 객체에 그 일을 할수있는 메서드를 만들어야 한다는것
	이때도 메서드의 이름을 getDiskSize()로 뽑고,이걸 println으로 뽑는게 아닌(일단 계산하니까 get떼야하고)
		System.out.println(com.getDiskSize())
	해당객체한테 프린트하는거까지 시키면됨
		com.printSpec();
	이렇게
	
	클래스를 만들땐,필드를 먼저 생각하는게 아닌 메서드를 먼저 생각하고,그 메서드에서 필요한 필드를 생성하는게 맞는순서임
	자동차를 만든다고하면,운전메서드,속도조절메서드,방향전환메서드를 먼저 생각해야함
	즉 데이터위주의 사고가 아닌,행동위주의 사고를 해야함
	즉 덕타이핑과 같은소리임,필드가 중요한게 아니라 객체는 메서드가 제일 중요하니 ..
	
	순환참조(양방향참조,jpa oneToMany+ManyToOne)는 기본적으로 만들면 안됨,정 어쩔수없을때만 만들어야함
		순환의존성이 있다는거 자체가 결합도가 올라감
		순환참조가 있으면 직렬화가 불가능해짐(서로 참조하니까 양방향부분은떼고해야함,toString생각하면됨)
	차라리 간접참조로,엔티티는 외래키만 가지고있고 연관관계는 단방향으로 해둔다음 필요할때마다 그거로 레포지토리에서 찾아오는게 나음
	순환참조를 유도하는 기능이 있으면,이걸 어케 별도의 클래스로 분할할수없는지 고민해야함
	순환참조가 없으면
		mappedBy를 고민안해도됨
		복잡도를 낮추고 응집도를 높임
	같은 장점이 있음
	
	그리고 추가적으로
		가능하면 final로 선언하고,안되면 안되는 이유를 찾자
		vo에서도 변경자가 들어갈수있는데,단 이경우엔 무조건 새로운 vo를 반환하는 메서드가 되어야함
		그래서 이름도 changePassword같은게 아닌 withNewPassword같은게 더 좋음(일반변경메서드와 구분하기위해 메서드이름을 전치사로 시작)
	도 신경쓰면좋음
		
		
3.설계 
	solid
		단일책임원칙:클래스는 하나의책임만 가져야하고,그 책임을 완전히 캡슐화해야함,클래스에 코드라인이 100줄이상이면 의심
		개방폐쇄원칙:확장에열리고,수정에닫혀야함,보통 추상화(인터페이스화)가 부족할경우 이게 깨짐
		리스코프치환원칙:하위객체는 상위객체가 하는일을 완전히 대체할수있어야함,상위와하위의 계약(인터페이스)이 깨질때 이게 깨짐
			이거때문에 상속이 구현보다 사용하기꺼려지는것
		인터페이스분리원칙:클라이언트가 자신이 이용하지않는 메서드에 의존하면안됨,이건 인터페이스를 분리해서 조립하듯이 개발하지않으면 깨짐
			인터페이스는,이기능을 사용하려면 이 방법을 사용하게 만들어라라고 계약하고,계약을 지켜서 만드는것(인터페이스의 메서드)
			굳이 interface가 아니라도,클래스의 퍼블릭메서드도 인터페이스긴함,인터페이스가 생략되고 바로 구현체에 붙은거지
			그래서 api도 인터페이스임
			이 인터페이스는,구현체 안에서 사용하지않는 메서드가 없도록 각각 잘 분리해서,2개이상이 필요하면 2개를 구현하도록 만들어져야함
		의존성역전원칙:상위모듈은 하위모듈에 의존하면안됨,상위하위둘다 인터페이스에 의존해야함
			추상화는 세부사항에 의존하면안됨,세부사항이 추상화에 의존해야함
			즉 인터페이스가 있고 구현체가 있는거지,구현체에 인터페이스를 맞추면안됨
	이렇게있음
	
	여기서 의존성이란,a가 b를 사용하기만 해도 a는 b에 의존성을 가지는것,즉 import되면 의존성이 있다고 할수있음
	이 의존성을 직접 new해서 생성하지않고(강결합),외부에서 넣어주는걸 사용하면(약결합) 이게 의존성주입임
	즉 구현체에 직접 의존하는게 강결합이고,
	인터페이스에 의존하고,인터페이스 구현체를 받아서 사용하는게 약결합임
	
	의존성 주입과 의존성 역전은 다름
	의존성 주입은 단순히 의존성을 주입받는,강결합을 약결합으로 만드는걸 말하고
	의존성 역전은 모듈사이에 인터페이스를 두고 통신하게되는걸 말함(상위하위 모두 인터페이스만 의존)
	즉 의존성역전을 위해,의존성 주입을 사용하는것
	스프링은 의존성 주입도구임,의존성 역전을 만들어주지않음
	
	그래서 레이어드아키텍쳐를 사용할때,컨트롤러서비스레포지토리를 추상화없이 사용하면,일반적으로 나쁘고,절차지향적 코드가 나올가능성이 커짐
	물론 그렇다고 전부 추상화하면 개귀찮으니까,각보고 알아서정해야함
	
	그리고 생성자주입이 7개,파라미터주입이 4개이상 넘어간다면,클래스분할이나 메서드분할을 고려해야하는 신호임
	
	가능하면 의존성은 드러내는게 좋음
	즉,내부로직에서 의존하고있는건 가능하면 파라미터같은거로 받는게,그걸 사용하는사람이 확인하기 쉬움
	그리고 이렇게 하는게 테스트하기도 쉬움(특히 시간이나 랜덤같은,실행할때마다 변하는값)
	즉,변하는값은 외부에서 주입받는게 좋음
	근데 이렇게하려면,계속 상위객체로 갈때마다 해당메서드에 파라미터가 하나씩 추가됨(상위에서도 감춰진거 풀고 하려면)
	결국 누군가는 고정된 의존성을 주입해줘야함
	그래서 가장 괜찮은방법은,런타임의존성과 컴파일타임의존성을 다르게하는것(변하는값을 추상화해서 스프링같은거로 di받는것)
	즉 인터페이스에만 의존하고,구현체는 스프링이 알아서 넣어달라고 '해줘' 하는거임
	이렇게해서,테스트시와 배포시에 의존성넣는걸 변경해서 처리할수있음(의존성역전을 사용해서 처리하는것)
	그 스프링게시판만들기할때 사용했던,레포지토리 의존 나누는거 그거임
	
	보통 테스트하기가 쉬우면,좋은코드일 확률이 높음
	
	cqrs는,명령과 쿼리를 분리하는것
	즉 메서드나 클래스를 명령과 쿼리로 나누는것
	이때 주의해야할건,명령에서 return this로 변경되거나 추가된 결과물을 던져버리면,쿼리결과가 날아간거라서 cqrs가 아님
	그래서 명령은 void가 되는게 맞음
	쿼리는 값을 변경시켜선 안됨
	즉
		하나의 메서드는 명령이나 쿼리여야하고
		명령은 객체의 상태를 변경할수있지만,값을 반환하지않음
		쿼리는 값을 반환하지만 객체를 변경하지않음
		
4.실수
	api500에러는 사실상 장애상황임
	api가 실패하면 원인을 반드시 리턴해줘야하고,거기에 맞는 http상태코드를 내려줘야함
	500은 그냥 장애선언임
	
	좋은프로그램은
		1.돌아가야함
		2.유지보수가 가능해야함
	설계만 백만년하고있으면 안됨,80점짜리 코드를 빨리뽑는걸 목표로하는게좋음
	
	디자인패턴에 너무 집착하면안됨
	패턴은 그냥 도구일뿐임
	
	코드의 기대수명을 생각해서 개발해야함
	
	oop는 객체 이지 클래스 가 아님
	tdd,ddd,fp 모두 잘설계된 oop를 만들기위한 방법론들임
	
	절차지향이 꼭 나쁜건아님,단지 객체지향의 ocp가 없어서 수정이 좀 빡센거지,개발속도나 이해가 쉬운코드로 보면 걔가 더 나은점도 있음
	
	oop에서 중요한건 역할/책임/협력 임
	
	객체지향에서 지키면좋은 규칙
		한메서드에 오직 한단계의 들여쓰기만 한다(뎁스깊게쓰지말라고)
		else를 사용하지않는다
		모든 원시값과 문자열을 포장한다
		한줄에 점을 하나만 찍는다(다 엔터로 내리라고)
		줄여쓰지않는다
		모든 엔티티를 작게 유지한다
		3개이상의 인스턴스변수를 가진 클래스를 사용하지않는다(클래스내변수,static이 안붙은)
		일급컬렉션을 사용한다(map같은 컬렉션이 클래스로 래핑되고,다른맴버변수가 없는것)
		게터세터프로퍼티를 사용하지않는다(그래도 게터는쓰자..)
	가 있음
	CollectionUtils,StringUtils,ObjectUtils중에 좋은 메서드들이 많음(가독성이 올라감)
	잘사용하자
	
	상속을 지양하고,composition(공통기능분리하고,그걸 멤버변수로 갖는형태)를 지향하자
	
	테스트를 먼저 생각하고,테스트하기 쉽게 짜자,짜고나서 테스트생각하는게 아니라
	
	블락(메서드내에 개행으로 분리된거)이 생기면,메서드분할을 고려하자
	
	뎁스가 2개이상 들어가면,메서드분할을 고려하자
	
	
5.스프링을 oop스럽게 사용하기	
	백엔드에서 ui란 컨트롤러임
	이 컨트롤러가 똑똑해지면 안됨(스마트ui)
	컨트롤러는 어떤 서비스를 실행할지 선택하는정도의 일만 해야함,안그래도 밸리데이션도 하고 이것저것 웹단 할거많은데,서비스로직까지 들어오면 ㄹㅇ개판됨
	보통 하위레벨의 레이어는 전부(컨트롤러->레포지토리)건드릴수 있는데,이게 스마트ui를 만들확률이 높음
	그래서 바로 하위레이어만 건드릴수있게 하는게 깔끔할확률이 높음
	
	그리고 서비스가 너무 두꺼우면(온갖 로직이 다들어가있으면),ddd처럼 domain층을 생각해봐야함
	서비스컴포넌트는 도메인객체에 작업을 위임한다(컨트롤러-서비스-도메인-레포지토리)
	즉 도메인객체가,수동적이 아닌 능동적으로 자기일을 처리할수있어야하고
	레포지토리는 jpa레포지토리를 그대로 사용하는게 아닌 추상화가 되어있어야함
	
	이게 안된,그 스프링 처음짤때처럼 짜는 코드를 트랜잭션스크립트라고 함
	이건
		수동적도메인
		모든업무규칙과 지식이 포함된 뚱뚱한 서비스
		객체지향이 아님
		테스트가힘듬
		단,개발이 빠름
	이라는 특징을 가지고있음
	이런애들은 테스트도 힘들고,객체지향도 아닌 안티패턴임
	물론 개발속도가 중요할땐 찍어내기좋긴한데,서비스가 커지면 반드시 문제가 생김
	
	비즈니스로직은 서비스가 들고있는게 아닌,도메인이 들고있어야하고,서비스는 단지 작업을 실행시키는 순서를 맞춘다거나만 해야하는것
	이렇게하면 비즈니스로직과 레포지토리의 결합을 끊어서,테스트도 편해짐
	그 스프링게시판만들기할때 썼던방식 그거그대로임(거기서 직접 레포지토리호출하는걸 다 도메인서비스로 뽑은거)
	도메인에 다 넘기고 서비스는 그거 호출하는거만 하는거
	즉 값객체가 아닌,행동이 있어야 도메인이라고 부를수있음
	
	근데 어떤 도메인도 해당 비즈니스로직을 가지고있기 애매한경우(여러도메인에 걸쳐서 값을 내야하거나)엔,새로운 도메인을 만들면됨(해당도메인들을 다 di받는)
	이렇게 만들어진 도메인을,도메인서비스라고 부름,객체로 표현하기 애매한 논리로직자체가 목적인 행위자들을 이렇게 부름
	보통 이런애들은,이름붙이기가 어려워서 뒤에 manager를 붙임
	이때 도메인서비스들은 한가지 트레이드오프가 있는데
		priceCalculator같이 하나의 책임에 특화된 객체로 만들건지(단일책임원칙을 지킴,단 함수를 래핑하는 클래스가 엄청나게 생겨남)
		Cashier같이 여러행동을 할수있게 만들건지(중복코드를 막음,단 단일책임원칙에 어긋남)
	이건 트레이드오프의 영역임
	
	기존 서비스(어플리케이션서비스)는,비즈니스결정을 내리지 않아야함(if(user.dontHaveMoney())같은))
	앱서비스는 단지 요청을 도메인과 도메인서비스에 위임할뿐임,얘들은 가능한 얇게 유지되어야함
	
	도메인서비스는 도메인레이어에 해당하는 객체임,얘는 서비스에서 건네받은 책임을 처리함
	
	이 도메인서비스는,빈으로 만들수도있고,안만들수도 있는데 이건 호불호의 영역임
		안만드는쪽은,얘들은 순수자바의 영역이라 생각해서 안만들고
		만드는쪽은 어짜피 생성자주입시기에 수동으로 주입해줘야하는데 뭐하러귀찮게 안만드냐
	라는것
	
	
	추상화는,핵심적인 개념과 기능을 간추려내는것
	즉 모듈을 격리하고 인터페이스로 만드는과정,즉 책임을 선별하는 과정임
	
	이 추상화를 어디까지해야하나?는
		시스템외부연동(db연동,즉 레포지토리,web클라이언트나 restTemplate로 외부통신)은 가능하면 추상화
			서비스->인터페이스레포지토리->인터페이스레포지토리구현체->jpa레포지토리 (게시판만들기에서 썼던방법)
			이러면 결합도가 낮아져서 레포지토리변경이 쉽고,테스트시 모킹하기가 쉬움(ocp)
			이때 중요한건,인터페이스레포지토리는 비즈니스레이어(서비스단)임
			그렇지않으면 고수준모듈이 저수준모듈을 의존하는거기때문
		서비스와 컨트롤러,엔티티는 가능한 추상화할필요없음(서비스는 구체로)
			얘네들은 한번생성으로 영원히 같은일을 할수있는 객체여야 하기때문
		도메인레이어를 추가하고,필요에따라 자유롭게 추상화(각보고 하고싶으면하고 말려면 말고)
			단,도메인레이어는 원칙적으론 레포지토리를 사용하지못함
			그래서 원칙적으론 도메인레이어쓸땐 어플리케이션서비스에서 미리 다 준비해서 도메인한테 넘겨줘야함
			단,장단이 있어서 트레이드오프임(이게안되면 불필요한쿼리가 발생해서)		
	jpa엔티티와 도메인을 분리(jpa엔티티를 도메인으로 toDomain하는식으로)는,하냐 안하냐 둘다 장단이있음
	
	개발할때,올바른 설계인가?싶으면,이코드가 테스트가 쉬운가?를 고민해보면됨
	
	
	서비스는,비즈니스레이어의 퍼사드임,즉 도메인과 도메인서비스의 퍼사드라고 해석할수도있음
	즉 도메인과 도메인서비스에게 책임을 위임하는,퍼사드패턴의 일종임
	
	도메인 연산이 필요한데,어디들어갈지 애매한게 있는데,이게 사물이 아니라 행동에 가깝고,적당한이름이 없어서 뒤에 manager같은게 붙는데,
	이때 매니저보단 서비스가 더 다른객체와의 관계성이 있어보여서 붙은거라,그냥 서비스는 매니저라고 보면됨
	즉 애들행동을 대신하는게 아닌,애들을 관리하는역할
	
	서비스는,레포지토리에 접근하는동작은 어떤 도메인도 들고있기 애매해서,서비스가 들고있는게 맞음(레포지토리에서 도메인객체를 가져온다던가)
	그래서 사실,도메인서비스를 사용하지않고 서비스에서 처리하는거도 ddd에 위배되진않음 그냥 ddd와 oop방향성에 그게 더 맞는거지
	
	그리고 도메인서비스를 도메인으로 바꿀수있으면,바꾸는게 낫고(priceCalculator->Cashier)
	단 그래도 못바꾸는로직들이 존재하긴함(뒤에 manager를 붙이면 어색하면 도메인,안어색하면 도메인서비스)
	
	대충
		어플리케이션서비스:스프링의 서비스컴포넌트에 종속되는서비스
		도메인서비스:스프링의 서비스컴포넌트에 종속되지 않는 서비스
	라고 이해해도됨
	가장 중요한건
		도메인을 풍부하게 만들고
		서비스를 가능한 얇게 만들자
	임,도메인이 핵심이고 스프링은 껍데기
	
	서비스는 한번생성하면 영원히 쓸수있어야함,그래서 생성자주입만 써서 di받고나선 의존성을 바꿀수있으면 안됨(final이 강제됨)
	즉
		서비스에 setter가 있으면안됨
		반드시 생성자주입
		서비스의 멤버변수는 전부 final
	이어야함
	
	추가적으로,생성자주입을 하면,순환참조를 막아줌(순환참조는 사실 하나의컴포넌트라는 의미일수있음)
	그래서 a와 b를 서로 순환참조하는게 아닌,a와b를 참조하는 c가 있는게 나음
	
	
	
	jpa자체는 자바표준이고,하이버네이트가 그거 구현한 구현체,스프링jpa는 이걸 좀 래핑한거
	
	연관관계의 주인은,many쪽이 해당되는데,얘들이 외래키를 가지고있음(외래키자체를 연관관계의 주인이라고 표현해도됨)
	왜 연관관계의 주인이냐면,주도권을 얘들이 가지고있기때문
	기본키가 사라지면,그냥 애초에 잘못된 엔티티이고,연관관계측면에선 외래키가 없어지면 서로간의 연관관계가 사라지기때문
	그리고 애초에 양방향관계를 만들지않는게 좋음
	
	n+1은,패치조인으로 해결(애초에 모든 연관관계는 lazy여야하고 일단)
	그리고 애초에 레포지토리단에서 쿼리를 두번날리는거로 해결하는 방법도있음(팀과,팀아이디외래키를 가지고있는 대상)
	그리고 이 두개를 조합해서 도메인으로 바꾸는거
	
	jpa레포지토리를 쓸때,jpa레포지토리에 입력된타입과 리턴된값이 일치하는게 좋음
	즉,post레포지토리에서 comment가 반환되면 몬가몬가 이상하니까..
	
	jpa 낙관적잠금은,버전로우를 추가해서 이거로 변경감지하는것,락보단 충돌방지에 가까움
	비관적잠금은,for update를 사용해서 실제로 락을 거는방식
	
	cqrs를 적용하는곳에선,repository대신 reader과 writer라는 이름을 사용하고,
	같은테이블을 참조해도 UserReadonly(vo),UserEditable(변경가능한객체)라는 엔티티를 2개만드는 경우도있음
	
	스프링에서 aop 내부호출이 일어나면,스프링 프록시구조상 aop가 적용되지않음(프라이빗과 똑같이취급)
	
	스프링에서 List<인터페이스>를 di받으면,그 인터페이스를 구현하는 모든 구현체가(빈으로 만들어진)주입됨
	
	테스트용으로 레포지토리를 직접 구현해서 사용하기도 함(그 게시판만들기에서 했던 그거,이거 비효율적인거 아닌가 생각들던 그거맞음)
	장점으로,h2안띄워도되고,nosql같이 인메모리db가없는거도 테스트가 가능해지고,테스트실행속도가 빨라짐
	단점으로,개발할게 2배로 늘어나고,실제 실행환경과 같다는걸 보장할수없음
	이런걸 fake라고 부름
	
	
	
6.테스트
	테스트의 가장 큰 이유는,회귀테스트임
	회귀테스트로 다른곳에 영향을줬으면 바로 알수있게하고,수정이 덜 무섭게 하는것
	
	테스트는 크게 인수테스트와 자동테스트로 나눌수있음
	인수테스트는,체크리스트로 관리하면서 테스트항목을 하나하나 사람이 검사하는것
	자동테스트는,테스트코드로 돌리는것
	
	단위테스트는,단일서버,단일프로세스,단일스레드에서 돌아가야하고,디스크io를 허용하지않고,블록킹을 허용하지않음
	그래서 외부랑 통신이 있으면(db나 외부api호출),더미나 모킹같은걸 사용해야함
	통합테스트는,단일서버,멀티프로세스,멀티스레드에서 돌아가고,테스트용db를 사용할수있음(h2)
	멀티스레드+외부통신이 있기때문에,결과가 항상 같을거라는 보장을 하지못함
	api테스트는,멀티서버까지 허용해서,e2e테스트를 할수있어짐
	
	여기서 가장 중요한건 단위테스트임
	빠르고 결정적인 테스트를 여러개만들어서,코드커버리지를 높여야함
	대충 비율은 유닛80%,통합15%,api5%인게 이상적
	
	만약 api테스트만 계속늘리면,테스트실행이 길어지고 결과가 불안정해서 실패가 많아짐
	그리고 코드커버리지가 약하기도하고
	이게 아이스크림패턴이라는 안티패턴임
	
	그리고 여기서 api테스트와 단위테스트만 늘리면(통합이 작은 모래시계모양) 이거도 안티패턴임
	
	테스트에서 사용하는 개념들은
		SUT:테스트를 하려는 대상
		tdd:깨지는테스트를 먼저 작성하고,이걸 성공시키고(통과만하면됨 코드퀄리티상관x) 리팩토링하는 기법
			이떄,인터페이스에게 기대하는 모든 동작을 테스트로 만들어야함
		bdd:메소드위주의 테스트코드보다 시나리오기반 테스트를 하는방식(GWT랑 같은거)
		불규칙한테스트:대상코드에 아무 변화가 없음에도 실패하는테스트(결정적이지 않은 테스트)
		깨지기쉬운테스트:검증대상코드와 관련없는 변경으로 실패하는 테스트,테스트에 필요한 가정들이 명시적으로 작성되어있지않아 발생함
		상호작용테스트:메소드가 실제로 호출이 됐는지 검증하는테스트,별로 좋은테스트는아님(캡슐화에 위배)
			상호작용테스트보단,상태(결과)를 테스트하는게좋음
		테스트더블:테스트대역,즉 더미,모킹같은걸 말함
	이 있고,테스트더블(대역)에는
		더미:아무동작도 하지않고(메서드에 코드가 아예없음),코드가 정상적으로 돌아가기위해 전달하는 객체
			즉 인터페이스만 구현한거임
		fake:로컬에서 사용하거나(로컬에서 개발할때 이걸써서 개발하기도함),테스트에서 사용하기위해 만들어진 가짜객체,
			자체적인 로직이 있음(실제로직이랑 다르긴하겠지만),그 게시판만들기에서 레포지토리 테스트한다고 썼던방식
		stub:미리 준비된 값을 출력하는 객체,주로 외부연동하는컴포넌트에서 많이사용함(ex:return "abcd")
			보통 mockito프레임워크를 사용함
		mock:메소드호출을 확인하기 위한 객체,자가검증능력을 갖춤(사실 테스트더블과 같은의미로 사용됨,그래서 fake,더미,stub 전부 mock임)
		spy:모든 메서드호출을 전부 기록해서 나중에 확인하기위한 객체(mock+로그저장)
	이 있음
	
	mock프레임워크는,자바쪽에선 mockito나 bddMockito를 사용함
	사실상 똑같은데,bddMockito는 메서드이름만 바꾼거임(bdd스럽게)
	
	그리고 mock프레임워크 사용은 가능하면 지양하는게 나음
	테스트코드의 목적은
		회귀버그방지
		유연한설계
	인데 여기서 유연한설계부분을 전혀 챙길수 없게됨
	너무 날먹이라서 ㅋㅋ
	
	테스트코드는 좀더 사람이 읽기쉽게(아무것도 모르는사람이라도)짜는게 좋음
	
	코틀린에서 테스트도구는 kotest가 있음(그냥 자바꺼 써도되긴하지만)
	
	같은테스트인데 파라미터수치만 바꿔서 테스트해야할떄,Parameterized test라는걸 사용할수있음
	
	
	private메서드는 테스트할필요없음,즉 모든 메서드에 테스트를 할필요는 없음
	private메서드를 테스트하고싶은 느낌이 든다면,책임할당이 제대로 안됐을수있음,
	즉 다른클래스로 분리하고 퍼블릭으로 만들었어야 하는거였을수있음	
	메서드 지향의 테스트가 아닌,행위에 집중해서 테스트를 해야함
	
	final메서드를 stub해야하면,설계가 잘못된것
	해당메서드에 걸린 의존성을 약하게 하는방법을 찾아봐야함
	이런경우 해당final메서드를 사용하는 별도의 클래스를 만들어서,의존성을 약하게만드는 방법에 대해 고민해야함
	
	테스트는,반복을 허용하고 독립적이고 서술적이며 의미있는 문구로 작성해야함
	
	테스트에 논리로직을 넣으면안됨(for,if,덧셈,뺄셈)
	테스트에서 버그가 생기면 머리아프니까 직관적이게 짜야함
	
	
	테스트하기 어려운 의존성이 있을땐,의존성 추상화(레포지토리 추상화같은거)를 사용할수있음(실제 객체를 인터페이스로 싸서 그걸의존)
	이건
		다루기 까다로운경우:random,time
		테스트에 필요한 인스턴스생성이 힘든경우:httpRequest
		재정의가 까다로운경우:final,전역참조
	같은 문제가 있을때 사용할수있음
	이렇게 의존성을 약하게 만들어서(의존성역전) 테스트를 쉽게하는것
	
	테스트코드를 위한 getter가 남발되면 힘드니,이벤트 기반으로(이때까지 했던 기록들을 전부 기록)해서,역산하는 방법도 있음
	이게 이벤트기록임
	
	
	오버엔지니어링도 언더엔지니어링과 마찬가지로 좋지않음
	추상화는 대체적으로 좋음,고민되면 해도됨
	테스트는 행동위주의 사고를 도와줌(객체의 행동은 이렇게해야하고,이런 책임이 주어져야해)
	tdd는
		요구사항이 명확하지않으면 적용이 힘듬
		환경제어가 힘듬
		기존코드를 tdd하기 어려움
		프로젝트가 유지보수를 하지못하고 터지면,그대로 손해임(오버엔지니어링)
	라는 한계가 있음
	
	
	
7.실무개념정리
	거의아는거니까 모르는거만적자
	
	slb=lb와 같은것
	gslb=글로벌 로드밸런싱,서버를 전세계에 분산시켜둔걸 묶기위해,이중화구성으로 로드밸런서를 2개이상쓸때
		이경우 한군데서 장애가 발생하면 처리가 안되니,로드밸런서들의 앞에 로드밸런서를 하나 더둬서,거기서 부하분산을 한번 더하는것
	l4로드밸런싱:ip,port기반 로드밸런싱
	l7로드밸런싱:uri,헤더,쿠키기반 로드밸런싱
	fqdn:풀도메인(서브도메인을 포함한 풀도메인)
	
	cdn:컨텐츠(이미지같은)를 효율적으로 송수신하기위해 만들어진 네트워크,보통 중앙에 cdn서버를 두고,거기서 이미지같은걸 가져가게함
		이러면,국가별 cdn서버를 설치해서,페이지로딩을 빠르게할수있음
	acl:접근제어목록,네트워크망에 접근을 허가하는 ip리스트
		내부통신에선 신경쓸필요없고,외부로 나갈경우 acl이 허용되어야함(즉 외부통신이 안되면 의심할수있음)
	프록시:프록시를쓰면 캐시,접근제어,보안,사용률파악등의 이점이 있음
		포워드프록시=프록시
		리버스프록시=로드밸런서
	ws:웹서버,즉 리버스프록시서버,아파치나 엔진엑스같은거,정적컨텐츠를 내려주기도함,보통 로드밸런싱할때 사용하거나(백엔드),싱글페이지앱을 내려줄때사용(프론트)
		요청횟수를 limit걸수도있음(limit request)
	was:톰켓같은 웹어플리케이션서버
	ssl:https만드는프로토콜,공개키비밀키 그거맞음
	인증서:도메인,공개키,담당자정보로 이루어진 정보를,인증기관의 프라이빗키로 암호화한것
		이걸 ca의 공개키로 해제할수있으면 맞는정보라서 믿어도됨(이 공개키는 브라우저에 있음)
		그래서 해당도메인이 일치하는지 확인하고,맞으면 해당 공개키로 대칭키를 암호화해서 서버로 던지고,이거로 통신함
		이 인증서는 공인이 안되는거지,내가만들수도있음
	
	iaas:vm을 제공해주는 서비스
	paas:colab같은 이미 환경을 다 만들어둔곳에서 사용만 하는거
	saas:온라인으로 액세스 가능한 소프트웨어,구글드라이브같은거
	
	온프레미스:회사에서 서버가지고있는거
	온디멘드:수요가 필요한 즉시 서비스를 전달하는거(스케일아웃,스케일인이 즉시일어나는)
	
	x축확장:복제해서 확장,서버갯수를 늘리는것
	y축확장:기능을 분할(모놀리틱->msa)
	z축확장:데이터 파티셔닝
	
	msa:하나의 큰서비스를,작은 서비스들로 나눠서 배포하는식
		서버뿐 아니라 db도 각각 하나씩 가지게됨
	ha:고가용성
	
	액티브-스탠바이:이중화구성할때,하나는쓰고 하나는 놀게하고,하나죽으면 대체
	액티브-액티브:이중화구성할때,로드밸런서를 사용해서 둘다굴리는방식(마스터슬레이브방식(라이트는 마스터에서만,리드는 마스터슬레이브 둘다)이 여기포함됨)
	페일오버:죽으면 자동으로 대체
	스위치오버:죽으면 수동으로 대체
	페일백:장애가끝나면 원상복구하는것(보통 수동으로함)
	
	vault:패스워드관리오픈소스(해시코프꺼)
	
	cs:고객문의
	유불:유저불량,사용자잘못이라서 생긴문제
	
	roi:가성비
	r&r:역할과 책임
	
	sso:한번로그인해서 여러 서비스를 이용할수있게 되는것(네이버로그인해서 네이버페이도 같이쓰는거)
	
	불변성:같은응답에 대한 요청으로 항상 같은 값을 내려주는것,설계를 단순화시킬수있는 핵심 요소(자바스트링이나 add(2,3))
	
	함수형프로그래밍(fp):자료처리를 수학적함수계산으로 취급하고,가변데이터를 멀리함(사이드이펙트가 없는 순수함수를 지향함)
	사이드이펙트:명시적입출력값(매개변수,리턴값) 이외에 모든 암묵적 입출력
		암묵적입력:전역변수같은 매개변수외에 다른입력
		암묵적출력:리턴값 외 다른 출력(전역변수수정,api호출)
		
	라이브러리와 프레임워크의 차이:ioc컨테이너의 유무,컨포넌트생성과 호출의 주체가 누구인가에 따라 달라짐
	
	cors:api서버가 지정한 도메인에서만 통신이 이뤄지게하는거,브라우저단에서 동작하는 정책이라,포스트맨을 쓰면 동작하지않음
	xss:사이트에 스크립트를 삽입해서,이상한 자바스크립트를 실행시켜서 정보를빼내는공격
	
	공변성:서브타입과 슈퍼타입간에 치환이 가능한가
	
	패키지매니저:npm,yum같은거
		os단
			ubuntu:apt-get
			centOS:yum
			redhat:rpm
			mac:brew
		언어단:
			java:maven,gradle
			nodejs:npm,yarn
			python:pip
			Ruby:gem
	
	
	restapi는
		url에는 반드시 리소스를 칭하는 명사가 나오고
		리소스생성엔 post
		하위데이터접근은 /로 드릴다운(users/1)
		put은 데이터 전체를 바꾸는요청
		patch는 데이터 일부를 바꾸는 요청
		삭제는 delete
	restapi에서 자주나오는 실수로는
		명사는 복수형으로 써야함(user->users)
		끝에 /를 붙이면안됨
		검색을 post로 하면안좋음(리퀘스트바디쓰려고하는건데,어쩔수없을떄도 있긴함..)
		url에 동사가 들어가면안됨,이경우 patch로 state파라미터를 변경하는식으로 해야함
	뭐 사실,그냥 감수하고써도되긴함..
		
	oauth는,특정 유명한 사이트에만 가입하고,거기서 토큰을받아 회원가입하는방식
	장점은,비밀번호를 저장안해도되고,사용자도 맘편하게 가입할수있음
	방식은
		프론트에서 로그인요청이 들어옴
		백엔드에서 프로바이더에게 요청을 넘기면,로그인페이지를 돌려줌
		백엔드에서 로그인페이지를 프론트로 리턴
		로그인을 하면,authorization code(인가코드)와 함께 백엔드서버로 리다이렉트됨
		이 인가코드와 함께 백엔드서버로 리다이렉트되고
		프로바이더에게 인가코드를 주며 액세스토큰을 만들어달라고 요청하면
		인가코드가 맞으면 액세스토큰과 리프레시토큰을 리턴해줌
		백엔드는 받은 토큰들을 db에 저장해두고,사용자가 사용하는 자체토큰을 만들어서(jwt를 사용) 프론트로 전달
	하면 일단 로그인은 끝
	사용할땐
		프론트에서 jwt토큰과 함께 api요청
		백엔드에서 jwt토큰과 일치하는게 db에 있는지(인증),해당토큰이 해당api에 접근할수있는지(인가)를 확인하고
		필요에따라(선택사항),소셜기능이 필요하면,프로바이더에 액세스토큰과 같이 요청을 날려서 프로필정보같은걸 받아올수있고
		인증인가가 성공하면 api를 동작시켜서 값을 돌려줌
	이렇게함
	이때 프로바이더서버는,
		인증서버로써의 역할,즉 로그인을 확인해주고 토큰을 발급해주는 역할과,
		리소스서버로써의 역할,접근권한이 있는지를 확인하고,프로필같은걸 던져주는 역할
	2개를 함
	
	이때,
		이 토큰이 유효한 토큰이 아니면 401(인증실패)
		이 토큰이 이 리소스에 접근불가능하면 403(허락되지않은요청,인가실패)
	을 던져야함
	

	
	
	
	nosql은
		중앙화된 캐시가 필요한경우
			조회수,좋아요,재고상황등,redis사용
		메시지큐가 필요한경우
			데이터유실이 걱정될때,카프카,래빗mq,레디스사용
		검색이 필요한경우
			검색엔진이 필요할때,elasticsearch
		시계열 차트를 그려야하는경우
			influxdb,openTSDB,druid를 사용
	같은 이유로 사용됨
	
	키벨류맵처럼 구성된거엔 레디스가 있음,거대한 맵이 메모리에 올라와있다고 보면됨
	레디스에서 유의사항은
		싱글스레드임,병렬처리로부터 자유로워져서 고성능이 됨
		샤딩과 클러스터모드가 있음,싱글스레드라서 확장전략을 이렇게쓰는거
		keys는 사용하면안됨
	이 있음
	
	대량의 데이터를 저장하는데 특화된 db로,cassandra,HBase가 있음	
	카산드라는
		consistent hashing,데이터를 해시를 돌려서 나온값을 노드별로 분산저장하는데,노드도 가상노드로 분할해서 근처에있는노드에 분할함
			노드하나에 너무 많은 데이터가 집중적으로 저장되는걸 막기위함
		파티션키가 중요
		쓰기성능이 매우빠름
	이런특징이 있고
	
	json처럼생긴 도큐멘트를 읽고 저장하는 db로,mongoDB나 elasticsearch가 있음
	elasticsearch는
		검색에 사용할수있는 db,전문검색에 성능이좋음
		인덱스라는(rdb에서 database)걸 사용하는데,클러스터에 인덱스가 너무많아지면 문제가생김
		update를 사용할수없음,정확히는 있긴한데 지우고 다시넣는식으로 동작
		통계내기가 편함
	mongoDB는
		트랜잭션을 지원
		전문검색기능 제공
	이런특징이 있음
	
	graphDB는,소셜관계망,구독모델을 표현할때 사용됨(팔로우구현할때 사용)
	neo4j가 있음
	
	message system는,거대한 quere를 생각하면됨,db라기엔 좀 부족함(데이터를 적재하는게 목적이 아니라)
	여긴 카프카나 래빗mq가 있음
	래빗mq는 그냥 옵저버패턴으로 동작하는데,
		프로듀서가 exchange에 데이터를 발행하면,
		그걸 구독하고있는 컨슈머들이 동시에 받는거(바인딩된 큐로 라우트해줌)
		이떄 데이터를 하나의큐에만 보낼수도있고,모든큐에 보낼수도있음(exchange설정따라)
	카프카도 똑같음
		프로듀서가 토픽에 데이터를 발행하면
		토픽은 데이터의 키값에 따라서 특정 파티션으로 데이터를 보냄
		그러면 그 파티션을 바라보고있는 컨슈머들이 데이터를 들고와서 처리하는거
		여기서 중요한건,하나의 컨슈머그룹에선 하나의 파티션엔 하나의 컨슈머만 붙을수있고(같은그룹내에서 중복수령을 방지하기위해,다른그룹은 상관없음)
	여기서 중요한건,컨슈머마다 데이터를 읽는 속도와 시기가 달라서,메시지순서를 보장하지않음,
	그래서 파티션키가 중요(한군데서 일 죽어라 몰빵하고,다른데 노는일방지하기위해)
	파티션의 갯수는 확장은되는데 축소는 안돼서,처음부터 너무 큰값을 잡으면안됨
	
	
	
	
	
	
	
	
	
	
	
	
	
		
		
		
		