앤서블,치프등은 이미 만들어진 인프라에 소프트웨어를 설치하고 관리하는데 사용됨(db,서버,네트워크등 )
여기서 가장 중요한건 멱등성이 있어서,실행할때마다 변경사항만 적용된다는것

도커,베이그란트는 컨테이너의 이미지를 만드는것

테라폼,클라우드포메이션은 프로비저닝을 하는데 사용됨(즉 실제로 ec2같은걸 할당받는거)

테라폼의 장점은 여러 플랫폼(aws,gcp,azure)에 똑같이 사용할수있다는것,즉 플랫폼종속성이 없음

테라폼도 선언적으로 작동하고,선언을 하면 거기서 바뀐거만 추가하거나 삭제해서,멱등성이 있음

테라폼은 hcl언어를 사용함

hcl은 기본적으로
	<block> <parameters>{
		키1=밸류1
		키2=밸류2
	}
로 구성됨
만약 파일을 만들거면 만들폴더로 이동해서
	resource "local_file" "pet"{
		filename="/root/pets.txt"
		content='abcd'
	}
여기서 리소스는 키워드임,블록으로 리소스타입을 지정하고,그뒤에(로컬파일)원하는 리소스타입을 적음
로컬파일은 로컬과 파일 2개의 정보인데,앞의 로컬은 프로바이더고(원하는곳)뒤의 파일은 리소스타입임
그뒤의 pet는 리소스이름임

그리고 안의 키밸류들은 아규멘트임
기본적으로 저건 리소스 유형에따라 달라지고,정확한 이름에 따라 거기에 값이 들어가는형태
여기서 파일네임은 이름을 정하고,컨텐츠는 그안에 들어갈 값을 정함
만약 ec2에선 
	resource "aws_instance" "webserver"{
		ami= "ami-0c2f25c1f66a1ff4d"
		instance_type= "t2.micro"
	}
이런식으로 적고,저런 아규멘트를 받아먹음
s3버킷에선
	resource "aws_s3_bucket" "data"{
		bucket="webserver-bucket-org-2207"
		acl="private"
	}
이런식

보통 간단한 테라폼의 워크플로는
	구성파일작성
	terraform init
	terraform plan
	terraform apply
이런식으로 감

여기서 init는 구성파일을 확인하고 그 디렉토리를 초기화하고,리소스에서 작업할수있게(aws같은 클라우드에서 작업할수있게)플러그인을 받음
이때 선언한 리소스에 맞는 플러그인을 자동으로 받음
plan은 이 구성파일을 적용하면 수행할 작업을 미리보기함,여기엔 적용되는 아규멘트들같은거도 다표시되고,전과 바뀐게 뭔지같은게 표시됨
여기서 +기호는 이번적용에 추가된다는거고 -는 빠진다는것 ~는 업데이트,업데이트가있으면 삭제하고 다시생성됨(변경할수없는인프라의경우)
그리고 apply로 적용하면됨
만약 삭제하고싶으면 terraform destroy하면됨

그리고 terraform show로 만든 리소스의 세부정보를 볼수도있음(플랜에서 표시되던거와 같음)
그리고 저기서 리소스타입과 아규멘트는 종류마다 다르니까(aws랑 구글이랑 아주레랑) 테라폼공식도큐가서 찾아서쓰래

init할때 프로바이더엔 
	공식프로바이더(aws,구글같은 큰데,로컬프로바이더),
	검증된프로바이더(해쉬코프랑 파트너맺은 작은곳),
	커뮤니티프로바이더(개인이올린거,검증안됨)
가 있음
이때 보이는 플러그인이름도 기본적으론 조직이름/타입(플러그인이름) 으로 적힘
	hasgicorp/local
이때 그 앞에 호스트네임이 붙을수있음(레지스트리이름)이건 기본값레지스트리가 아닐경우 붙음
	terraform.io/hasgicorp/local
기본적으론 최신버전을 받지만,당연히 여기도 버전명시해서 고정으로받는게 좋음


테라폼은 지정폴더에 있는 모든 tf파일을 실행함,그리고 단일tf파일에 여러개의 리소스가 들어갈수도있음




프로바이더엔 뭐 이상한거 다있는데,랜덤도 있음
	resource "random_pet" "mypet"{
		prefix="Mrs"  //접두사,앞에 붙음
		separator="."//접두사와 이름사이 구분기호
		length="1" //펫이름길이
	}


변수를 사용할땐,변수파일을 만들어두고
	variable "변수명"{default="디폴트값"}
	
	filename=var.변수명
으로 불러오면됨
이때 변수의 파라미터엔 3개가 있음
	variable "변수명"{
		default="디폴트값"
		type=string  //타입,옵션이긴한데 있는게좋음,
		description //주석,옵션임
	}

타입은
	string
	number
	bool
	any
	list  //["a","b","c"]  filename=var.변수명[1]으로 참조가능,list(string)이런식의선언도 가능
	map   //{"a":1,"b":2,"c":3}  filename=var.변수명["a"]로 참조가능  map(string)도 가능
	set   //["a","b","c"]이건 리스트랑 비슷한데 중복이 불가능함,수학에서 집합이라보면됨
	object//객체임,여러값을 가지고있는 단일객체를 넣을수있음
			type=object({
				name=string
				color=string
				age=number
				food=list(string)
			})
	tuple  //[string,number,bool] ["cat",2,true]이렇게 여러타입을 묶어서 하나로쓸수있음
를 지원함	
안적으면 any들어감(아무거나다되는거)

그리고 terraform apply뒤에 -var "변수명=값"으로 그 변수명의 값을 바꿀수있음
	terraform apply -var "filename=/root/ppt.txt" -var "content=abcd"
아니면
	export TF_VAR_변수명="abcd"
	terraform apply
할수도있음
그리고 이런걸 terraform.tfvars나 terraform.tfvars.json,*.auto.tfvars,*.auto.tfvars.json에 넣어두면 자동으로 로드해서 적용함
	terraform.tfvars안에
		filename="abcd"
		content="fff"

자동적용을 원하지않으면,*.tfvars로 만들고 terraform apply -var-file 파일이름.tfvars로 적용할수도있음
그리고 아예 기본값을 안주고 타입만 줄수도있는데 이러면 파일명을 안받으면 에러나게 할수있음

그리고 변수의 적용순서는
	export로 적은거
	tfvar에 적힌변수
	*.auto.tfvars에 적힌변수(알파벳순)
	-var로 apply에 수동입력한거 
순으로 덮어씌워짐

중요한건,tfvars는 값을 넣는거지,변수를 선언하는게 아니라서 변수를 선언하는건 꼭 필요함(.tf에 변수선언)

그리고 만약 어떤 리소스가 다른리소스에 종속성을 가지게하려면(그리소스의 특정값을 가져간다던가)
이경우엔
	${리소스유형.리소스이름.가져갈값}
	${random_pet.my_pet.id}
	content="my ff is ${random_pet.my_pet.id}"
이런식으로 하면됨

이렇게되면 종속성을 주는(값을 주는)쪽부터 먼저 만들고 그값을 받는애를 그 뒤에 만들게됨
삭제할때도 역순으로 함
이렇게 생기는 종속성이 암시적 종속성임
아예 이걸 명시적으로 줄수도 있음
	resource "local_file" "pet"{
		filename="/root/pets.txt"
		content='abcd'
		depends_on=[
			random_pet.my-pet
		]
	}
	depends_on으로 종속항목을 추가할수있음
	이건 리소스가 다른 리소스에 간접적으로 의존할때만 사용함(직접 명시적으로 적을수없을때 이거로 강제로 종속성을 박음)
	즉 거기서 무슨값을 가져오는건 아닌데,그게 있어야 존재할수있을때



그리고 뭘 출력하고싶으면
	output 이름{
		value=출력할값,참조표현식이어야함
		description="설명"
	}
으로 출력할수있음
이걸 tf파일에 넣으면,apply할떄 outputs에 표시됨
terraform output으로 저거만 볼수도있음 
특정값만 보려면
	terraform output 변수명
으로 특정값만 볼수도있음
저거로 원하는값을 빼서 쉘스크립트나 엔서블에 줘서 그쪽에서 보고 대응하는식으로 사용함



