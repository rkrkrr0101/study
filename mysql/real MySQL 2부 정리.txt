11.쿼리 작성 및 최적화
	필요없는건 스킵
	앞부분에 5.7이랑 8.0이랑 호환설정같은거 있으니 책 참고(안시쿼리호환설정도있음)
	
	테이블은 항상 대문자나 소문자로 통일해서 만들기
	예약어인지 확인할떈,해당이름으로 테이블만들어서 만들어지면 예약어아니고,안만들어지면 예약어임
	이때 역따옴표를 붙이면 테스트가 안되고,기본적으로 테이블생성시 역따옴표를 안쓰는게좋음
	
	mysql 메뉴얼에서
		대문자는 키워드
		이탤릭체는 토큰(테이블명,칼럼명,표현식)
		대괄호는 선택사항
		파이프는 하나만 선택가능
		중괄호는 괄호내에서 반드시 하나를 선택해야함(필수사항)
		...은 앞에 명시된 키워드나 표현식의 조합이 반복될수있음을 의미함
	이거알면 대충볼수있음
	
1.mysql연산자와 내장함수
	문자열은 ''와 ""를 혼용가능,예약어충돌은 ``쓰면되는데 안쓰는게좋음 가능하면
	숫자는 그냥 넣으면되고,문자열과 숫자를 비교하는건 가능하면 안하고 통일시키는게좋음 타입을
	날짜타입은 date고 스트링도 포맷만 맞으면 날짜랑 비교를 할수있음
	불리언타입은 있긴한데,이건 그냥 tinyint임,그래서 이거쓰지말고 enum쓰는게좋음
	
	연산자는
		= 동등비교(null=null   -> null)
		<=> 널을포함한 동등비교(null<=>null -> true)
		<>,!=부정비교
		not,! 부정연산(tf연산을 뒤집음)
		and(&&),or(||) 연산결합,기호대신 문자쓰는게 가독성좋음
		/,div 나누기
		%,mod 나머지
		regexp 정규식일치확인
		rlike 정규식 라이크
		like 부분일치(인덱스타려면 aaa%식으로 써야함 %aaa는 못탐),%와 _를 사용할수있음
		between 양쪽사이의 값(이건 인덱스타기 힘드니까 인덱스 작업범위결정조건용 조건을 앞에 넣어두는게좋음),가능하면 in으로 바꾸는게 성능상좋음
		in 여러값에 대해 이퀄연산
	등이 있음	
	
	내장함수에는
		ifnull():널이면 다른값으로 변경
		isnull():널인지 아닌지 확인
		now():현재시간반환,정확히는 트랜잭션을 시작한시간을 반환함
		sysdate():사용금지
		date_format():datetime타입을 스트링으로 반환
		str_to_date():스트링을 datetime타입으로 변경
		date_add():날짜시간을 지정한만큼 추가
		date_sub():날짜시간을 지정한만큼 감소
		unix_timestamp():1970년1월1일 00:00:00로 부터 경과된 초를 반환(디폴트는 현재,해당데이트타임넣으면 그때의 타임스탬프반환)
		rpad():해당문자열의 오른쪽을 해당길이만큼 해당문자로 채워줌
		lpad():해당문자열의 왼쪽을 해당길이만큼 해당문자로 채워줌
		rtrim():해당문자열의 오른쪽의 공백을 지워줌
		ltrim():해당문자열의 왼쪽의 공백을 지워줌
		trim():해당문자열의 양쪽의 공백을 지워줌
		concat():여러문자열을 합쳐서 리턴(숫자를넣으면 문자열로 바꿔서더함)
		concat_ws():여러문자열을 합쳐서 리턴,중간에 구분자넣기도 가능(숫자를넣으면 문자열로 바꿔서더함)
		group_concat():그룹바이된 결과의 문자열들을 다 더해줌,구분자넣기도 가능,이때 메모리버퍼쓰는데 제한이 1kb니 시스템변수에서 늘릴수있음
		case when구문:스위치문임,보통 서브쿼리의 필요없는 동작을 막을때 사용(어짜피 버리는데 돌아가는거 막는다던가)
		cast():해당타입으로 변형
		convert():해당타입으로 변형 or 해당문자열의 인코딩형식 변경
		hex():해당숫자를 16진수스트링으로 변경
		unhex():16진수스트링을 바이너리로 변경
		md5():암호화함수,해시할때 사용하기도함
		sleep():쿼리를 해당시간동안 멈출수있음,보통 디버깅에사용
		benchmark():해당쿼리를 n번 실행시켜서 평균실행시간 리턴,단 계획수립은 1번만하니 이건 주의(두쿼리를 비교분석할때 사용하면됨)
		inet_aton():스트링ip주소를 바이너리타입으로 변형
		inet_ntoa():바이너리타입을 스트링ip주소로 변형
		json_pretty():json칼럼의 가독성을 좋게해줌
		json_storage_size():json칼럼의 바이트크기를 리턴해줌
		json_extract():json에서 특정값을 추출해옴,따옴표붙어있음,->연산자와 같음
		json_unquote():json에서 특정값을 추출해옴,따옴표없음,->>연산자와 같음
		json_contains():json전체,혹은 해당위치의 아래에 해당json필드가 있는지 확인
		json_object():해당칼럼들의 값으로 json을 생성
		json_objectagg():group by함수,칼럼들의 값으로 json을 생성
		json_arrayagg():group by함수,칼럼들의 값으로 json배열을 생성
		json_table():json값들을 모아서 rdbms테이블로 만들어서 반환함(임시테이블)
	등이 있음	
	
2.select
	셀렉트 문장은 조회 전체를 말하고,셀렉트절은 조회칼럼선택을 말함
		select절:select *,count(e.name) as cnt
		from절:from qwetable q inner join emp e on e.emp_no=q.emp_no
		where절:where a in 1
		group by절:group by q.emp_no
		having절:having avg(q.money>1000)
		order by절:order by avg(q.money)
		limit절:limit 10
	이런구성임
	이떄 실행순서를 알아야하는데,
		1.select,from,where절로 인덱스를 사용해서 데이터를 가져오고 조인함
		2.group by
		3.distinct
		4.having
		5.order by
		6.limit
	순으로 진행됨,또한 인덱스를 사용할수있을땐 order by와 group by는 생략됨(어짜피 정렬됐고 그대로 쭉 긁어서 그룹바이하면되니까)
	예외적으로,order by만 있고 group by가 없을땐
		1.1.select,from,where절로 인덱스를 사용해서 데이터를 가져옴
		2.order by함
		3.정렬된 데이터를 조인함
	이런순서로 진행됨
	
	만약 이런순서를 벗어나고싶으면 서브쿼리를 사용한 인라인뷰를 사용해야함(from절 서브쿼리로 임시테이블을 생성해서 거기서 진행)
	
	where나 order by,group by가 인덱스를 사용하려면 만족해야하는 조건은
		인덱스된 칼럼의 값을 절대 변형하면안됨(substr,a*10=100),가능하면 우항쪽으로 옮겨야 인덱스탈수있음,해싱같은경우 가상컬럼사용
		where절의 경우,양쪽의 데이터타입이 일치해야함(이거도 값을 변형하면안된다는거랑 사실같은소리)
	가 일단 전제조건임
	
	where에서 인덱스를 사용하는 방법은 작업범위결정조건과 체크조건 두가지가 있고,가능하면 작업범위결정조건을 늘려야함
	이때,인덱스에서의 왼쪽부터 조건이 하나씩 들어있을수록 효율성이 올라감(반대로말하면,왼쪽이 없으면 인덱스풀스캔을 함)
	그리고 딱히 where안에서의 순서와,인덱스의 순서는 상관없음
	이건 and조건이고,
	or조건은 전혀 데이터를 줄여주지못하고,오히려 해당조건으로 한번 더읽어야해서 풀테이블스캔의 확률을 높임
	가능하면 or은 빼고,넣더라도 and로 감싸서넣어야함
	
	group by에서 인덱스는,여긴 따로 작업범위결정조건과 체크조건같은게 없고,단순하게 group by에 있는 칼럼들의 순서와 인덱스의 순서만 같으면됨
	이때
		group by에 명시된 칼럼이 인덱스칼럼과 순서가 같아야함
		인덱스의 앞쪽에 있는걸 생략할순없음(뒤에있는건 생략가능)
		group by에 인덱스에 명시되지않은 칼럼이 하나라도 있으면 인덱스를 전혀 못탐
	가 있음,
	추가적으로,where조건절에 인덱스의 앞에있는칼럼을 이퀄로 비교했을경우,이걸 대신사용해서 인덱스를 타는경우도 있음
	즉 group by와 where 이퀄비교를 합쳐서 생각해도됨
	물론 where가 대신해줄수있는건 맨앞이 비어있을때뿐임,즉 group by의 맨앞에 where의 이퀄비교들이 있다고 보면됨
	
	order by는 group by와 거의비슷한데,정렬방식이 인덱스와 같거나 정반대여야한다는 추가조건 하나만 더있음
	
	쿼리에 where절이나 groupby,orderby가 동시에 있을경우에도 서로 같은 인덱스를 사용해야함(제약조건)
	이때(여기서 groupby와 orderby를 치환해도 똑같음)
		where절과 orderby가 같은인덱스를 사용:둘다 조건을 만족할때 가능,제일빠름
		where절만 인덱스를 사용:orderby는 파일소트로 정렬해야함,where로 많이 거를수있을때 효율적
			where로 임시테이블을 만들고 그안에서 정렬한다고 생각하면됨
		order by절만 인덱스를 사용:orderby를 인덱스로 처리하면서 where를 전부 체크조건으로 사용함,레코드가 아주 많은걸 정렬해야할때 사용함
			인덱스 풀테이블스캔으로 정렬하면서 where도 겸사겸사 처리하는느낌
	이렇게됨
	양쪽다 인덱스를 사용하려면,where절의 이퀄칼럼과 orderby의 칼럼들이 순서대로 빠짐없이 인덱스의 왼쪽부터 일치해야함
	중첩되는건 상관없는데,둘중 하나라도 빠지는칼럼이 있으면 동시사용은 불가능,이떈 보통 where이 인덱스를 탐
	
	group by와 order by가 동시에 인덱스를 타려면,양쪽이 모두 명시된 칼럼의 순서와 내용이 완전히 같아야함
	이때 둘중 하나라도 인덱스를 못타면,양쪽다 인덱스를 못타니까 주의해야함(즉 양쪽이 인덱스타는건 연대조건임)
	
	where와 orderby,groupby가 전부 동시에 인덱스를 타려면
		where이 인덱스를 사용할수있는가?
		groupby가 인덱스를 사용할수있는가?
		groupby와 orderby가 동시에 인덱스를 사용할수있는가?
	이 3개를 다 만족해야함
	즉
		3개다 만족하면 3개다 타는거고
		1번을 만족못하고 나머지는 만족하면 groupby,orderby만 타는거고
		1번을 만족하고 2,3번중 하나라도 만족못하면 where만 타고
		1번을 만족못하고 2,3번중 하나라도 만족못하면 인덱스 사용불가
	이렇게됨
	
	
	where에서 비교조건(이퀄)을 사용할때 주의해야할건
	null은 비교불가값이라 a=null 사용하면 tf로 안나옴,이떈 a is null이나 isnull(a)써야함
	그리고 isnull(a)쓸때 그냥 저대로 던지면됨
		isnull(a)=true //이렇게쓰면안됨
	이렇게 쓰면 안됨,변형일어났으니 풀테이블스캔함
	
	문자열이나 숫자를 비교할땐,반드시 그타입에 맞는 상숫값을 사용해야함,즉 문자열이면 문자열과 비교,숫자면 숫자와 비교
	
	date와 datetime과 문자열을 비교할땐,문자열을 자동으로 datetime으로 변환해서 수행하고,이때는 인덱스 타니까 신경안써도됨
	당연히 왼쪽의 칼럼을 스트링으로 변형하는거도 안됨
	날짜를 빼거나 더해서 비교할떄도,좌항은 그대로두고 우항쪽에서 빼고더하고를 거꾸로해서 처리해야함
	
	date와 datetime끼리 비교할땐,자동으로 date를 datetime으로 변형해서 사용하는데,
	이떄도 인덱스는 똑같이씀(왼쪽에 변형일어나도 인덱스씀,예외케이스)
	
	date,datetime과 timestamp를 비교할땐 주의해야함,실행계획도 레인지스캔하는거같은데 아님
	칼럼이(우항이) datetime이라면 from_unixtime()로 timestamp를 datetime으로 변환해야하고,
	칼럼이(우항이) timestamp라면 from_timestamp()로 datetime을 timestamp로 변환해야됨(now를 써도됨)
	이래야 인덱스를 탐,타임스탬프는 mysql에선 단순 상수로 취급되기때문에 변형을 해줘야함
	
	mysql도 Short-Circuit Evaluation(if문에서 앞에서부터 체크하고 나가리면 뒤에거 체크안하고 넘어가는거)가 있기때문에
	where의 조건의 순서가 성능에 영향을 미침(근데 cpu쪽부하라서 크진않은듯)
	그리고 where에서 인덱스에 관련된 조건이 있으면 그걸 맨앞으로 떙겨서 처리함(그래서 where에서 인덱스순서랑 조건순서랑 맞출필요없는거)
	일단 서브쿼리로 뽑아오는거나 그런건 맨뒤에 배치하면될듯
	
	distinct는 1권참고
	
	limit는 항상 마지막에 실행되고,중요한건 리미트에 표시된 레코드건수만 준비되면 바로 쿼리가 종료됨,
	그래서 groupby나 orderby에서도 약간의 성능향상이 있긴하고,where에서도 약간의 성능향상은 있음
	distinct의 경우엔 정렬은 안해도되고 유니크하기만 하면되니까 많은 성능향상이 있음
	풀테이블스캔이라도 따로 처리가 없으면 굉장히 빨리끝남
	그리고 리미트에서는 인자로 표현식이나 서브쿼리를 넣을수없음
	추가적으로 페이징을 위해 리미트를 쓰는건(limit 100,10),페이지가 커질경우에 비효율적이됨(앞에있는페이지를 다 읽고 가야하기때문에)
	그래서 페이지가 무한정 늘어날거같으면,where로 위치를 찾고(키값이나 날짜인덱스사용,81p참고),거기서 고정된 limit를 읽는게좋음
	
	count는 결과레코드의 건수를 반환함
	이떄 count(1)과 count(*)은 같음
	이노디비는 카운트를 쓸때 무조건 데이터나 인덱스를 읽어야(풀테이블스캔)하기때문에 주의해야함
	그리고 count쿼리에서는,order by와 left join같은건 넣으면안됨
	보통 페이징처리를 위해 사용할때가 많은데,이때 쓸데없는 부하임 이건
	order by는 어떤경우에도 필요없고(8.0부터는 무시하긴함),left join은 레코드수의 변화가 없으면 빼버리는게 성능상 좋음
	그리고 count함수에 칼럼명이나 표현식을 인자로 사용하면,거기서 널이 아닌거만 세는거도 주의해야함
	카운트쿼리는 부하가 엄청나기때문에,가능하면 빼는방향으로 가는게 좋음
	
	
	join작업을 할때,드라이빌테이블을 읽을땐 인덱스탐색을 한번만 하고,그뒤로는 스캔만 하면됨
	근데 드리븐테이블에서는 인덱스탐색작업과 스캔작업을 드라이빙테이블에서 읽은 레코드건수만큼 반복해야함
	그래서 드리븐테이블을 읽는게 훨씬 큰 부하를 차지함
	그래서 옵티마이저는 항상 드리븐테이블을 최적으로 읽을수있게 실행계획을 짬
	이때 각 테이블별로 인덱스가 있고없고에 따라
		양쪽다 인덱스있음:신경안써도됨 알아서잘함
		한쪽만 인덱스있음:일반적으로 인덱스있는쪽을 드리븐으로 잡음
		양쪽다 인덱스없음:인덱스만들생각부터 하자,어케하든 망했음
	이렇게 잡음
	그리고 조인조건(on)에서도 데이터타입의 변형없이,데이터타입의 타입을 서로 맞춰줘야 인덱스를 탈수있음(이쪽은 양변이 다 변형없어야함)
	
	이너조인은 조인대상테이블 양쪽에 모두 존재하는 레코드만 결과집합으로 반환함
	그래서 아우터조인(left join)을 자주 사용하게되는데,이건 이너조인보다 비효율적임
	그래서,한쪽 테이블에 존재하는 사원중에 반대쪽테이블이 null인 레코드를 반드시 반환해야하는게 아니면 이너조인쓰는게좋음
	이게 왜 비효율적이냐면,아우터조인을 쓰면 대상테이블은 절대 드라이빙테이블이 될수없어져서,옵티마이저가 성능을 좋게할 건덕지가 없어짐
	
	그리고 추가적으로,아우터조인을 하면서 아우터조인테이블에 대한 조건을 where에 넣으면안됨,이 조건은 on절에 들어가야함
	예외적으로,안티조인을 쓸때만 where에 조건을 넣을수있음
	
	그리고 db에서 외래키는 참조무결성을 위한거지 조인과는 전혀상관없음
	
	
	일반적으론 조인쓰면서 groupby와 orderby를 쓰면 알아서 최적화를하는데,만약 못한다면 조인을 끝내고나서 그룹바이나 오더바이를 처리함
	이때 조인이 실행되기전에 그룹바이나 오더바이를 처리하면 효율이 올라가는데,이게 지연된 조인임
	보통 이건 limit가 있는 쿼리에서 효과가 좋음
	이건 어떻게하냐면,메인쿼리의 from절에 원래쿼리에서 조인뺴고 오더바이랑 그룹바이를 친 결과물을 서브쿼리로 넣고,거기다가 조인을 하는거임
	이걸 하기위한 조건은
		left join일경우 1:1 또는 n:1이어야함
		inner join일경우 1:1 또는 n:1임과 동시에 양쪽테이블에 모두 존재해야함
	보통 페이징쿼리를 이런식으로 하면 성능차가 좀 남(조인갯수도 줄이면서 그룹바이나 오더바이를 처리할레코드수도 줄이니)
	
	
	8.0부터는 래터럴조인을 사용해서 특정그룹별로 서브쿼리를 실행해,그 결과와 조인하는게 가능해졌음
	즉 서브쿼리로 임시테이블을 만들고 그거와 조인거는거(이때 프롬절내부의 서브쿼리가 외부의 칼럼을 참조할수있음)
	이건
		let join lateral(서브쿼리) on ...
	이렇게씀
	이 lateral이 들어가야 from안에서 외부칼럼을 접근할수있음
	이 lateral서브쿼리는 조인순서상 후순위로 밀리고,결과로 외부테이블이 생성되기때문에 성능에 주의해야함(꼭 필요할때만 사용)
	
	그리고 조인쓰면 정렬된거처럼 보일수도있는데,orderby가 없으면 정렬에 대한 보장이 되지않으니,정렬이 필요하면 반드시 명시적으로 넣어줘야함
	드라이빙테이블이 바뀌거나 그러면 머리아파짐
	
	
	group by가 사용된 쿼리에선,그룹필된 그룹별로 소계를 가져올수있는 rollup기능이 있음(총합을 표시해줌)
	즉 그룹바이를 친 칼럼으로,나머지 칼럼들은 다 null로 적히고 카운트에 총합이 있는 형태임,이건 항상 해당그룹의 마지막에 나타남
	이 null을 바꾸고싶으면,grouping()함수를 사용해서 기본값을 바꿀수있음
	
	case when end를 사용하면,레코드를 칼럼으로 변환하거나(99p쿼리참고),
		SUM(CASE WHEN dept_no='d001' THEN emp_count ELSE 0 END) AS count_d001
	하나의 칼럼을 2개이상의 칼럼으로 변환할수있음(100p쿼리참고)
		SUM(CASE WHEN e.hire_date BETWEEN '1980-01-01' AND '1989-12-31' THEN 1 ELSE 0 END) AS cnt_1980
	이걸 with rollup과 같이쓰면 더 쓸만함
	
	
	order by는 정렬할때쓰는데,만약 이게 없다면
		인덱스를 사용하면 인덱스에 정렬된순으로 가져옴
		풀테이블스캔은 프라이머리키 순서대로 가져옴
		임시테이블을 거치면 아무도모름
	이런식으로 출력됨
	보통 정렬이 필요하다면,반드시 명시적으로 orderby를 넣어주는게 좋음,만약 인덱스타면 무시되니까 성능이슈도 글케없음
	근데 인덱스를 못탈경우엔 파일소트를 써야해서 많이 느려질수있으니,인덱스를 만들거나 정렬을 무시해도되면 무시하는방법도 있음
	이 orderby를 쓸때,숫자를 넣으면 해당위치의 칼럼(select절의 순서대로)으로 정렬,문자열을 넣으면 무시됨
	그래서 쌍따옴표를 넣으면 문자열이라서 무시되니까 주의
	
	하나 또는 여러칼럼의 연산결과를 사용해 정렬할수도 있음,이때 함수기반의 인덱스를 사용하면 인덱스도 탈수있음
	
	
	서브쿼리는 서브쿼리를 사용하면 단위처리별로 쿼리를 독립적으로 작성할수있음
	이건 select from where에 보통 사용할수있는데,위치에 따라 쿼리의 성능영햑과 최적화방법이 완전히 달라짐
	
	select절은 별로 신경쓸거없고,인덱스만 사용하는지 보면됨(따로 임시테이블만들거나 그런게없어서)
	그리고 주의해야할건 select절의 서브쿼리는 항상 칼럼과 레코드가 하나인 결과를 반환해야하는데,mysql에선 이거 체크가 좀 느슨함
		쿼리결과가 0이면 null반환
		쿼리결과가 2레코드이상이면 에러
		쿼리결과가 2칼럼이상이면 에러
	이런식임
	그리고 서브쿼리보단 조인이 조금 더 빠르니,가능하면 조인쓰는게 더 좋음
	그리고 래터럴조인을 사용하면,select절에 같은 서브쿼리를 칼럼만 바꿔서 여러번 던질필요없고,한번에 처리할수있음(107p)
	
	from절 서브쿼리는,8.0이전에선 항상 서브쿼리결과를 임시테이블에 저장하고 읽고그랬는데,좀 최적화가 돼서 괜찮아졌음
	서브쿼리를 외부쿼리와 병합하는방식으로 알아서 최적화를 해줌
	이때
		집합함수사용(sum,min,max,count등)
		distinct
		groupby
		limit
		union
		select절 서브쿼리
		사용자변수사용
	을 하면 이렇게 최적화를 못하니 주의해야함
	
	where절 서브쿼리는
		이퀄 or 크다작다비교
		in비교
		not in비교
	3가지로 나눠짐
	
	이퀄비교(대소비교도 동일)는 8.0부터는 서브쿼리를 먼저 돌려서 상수로 바꾸고,그걸가지고 나머지쿼리를 처리함
	단 단일값비교(a_col=(서브쿼리))가 아닌 튜플비교((a_col,bcol)=(서브쿼리))를 하면,
	서브쿼리가 먼저처리되긴하는데 외부쿼리는 인덱스를 사용하지못함
	
	in비교는 5.5이전까진 금기였는데,이후부터는 괜찮아졌음,이떈 세미조인을 사용해서 최적화함
	
	not in비교는 안티세미조인인데,이건 최적화할 방법이 많지않아서 가능하면 피하는게좋음(where에 이거만있으면 풀테이블스캔을 피할수없음)
	
	
	
	cte는 이름있는 임시테이블로,쿼리내에서 한번이상 사용가능하고(재사용가능) 쿼리가 끝나면 자동으로 삭제됨
	이건 재귀여부를 기준으로 non-recurisive와 recurisive로 나눔
	사용방법은 재귀여부에 상관없이
		with cte1 as (select ...) select,delete,update문
	이렇게씀,서브쿼리도 마찬가지로 괄호안에 제일앞에 쓸수있음
	
	cte는 with절로 정의하고,그뒤에 이름을 붙이고 쿼리를 붙이면됨
	이때 여러 임시테이블을 같이사용할수있고,물론 이 cte를 메인쿼리에서 가져다쓸수있고,다른cte에서 가져다쓸수도있음
	즉 임시테이블과 조인하는식으로 쓰면됨,from절 서브쿼리의 친척이라고 생각하면됨
	from서브쿼리에 비해 장점은
		재사용가능
		다른cte에서 참조가능
		임시테이블부분과 사용부분의 코드분리가능
	이라는 장점이 있음
	
	재귀cte는 비재귀적쿼리파트와 재귀적파트로 구분되며,이 둘을 반드시 union all해줘야함
	재귀적파트는 쿼리결과가 없을때까지 반복실행됨
		WITH RECURSIVE cte (no) AS (
			SELECT 1
			UNION ALL
			SELECT (no + 1) FROM cte WHERE no < 5
		)
		SELECT * FROM cte;	
	이런느낌임(WITH RECURSIVE로 시동)
	여기서 select 1이 재귀파트의 입력이고,그걸 where로 걸러서 쿼리결과가 없을때까지 반복하는거임
	이때,재귀를돌떄의 입력값은 바로 직전의 출력값이 그대로 입력됨(레코드 한줄이기만하면 칼럼이 몇개든 상관없음,as로 이름붙여서 가져다쓰면됨)
	
	일단 재귀니까 무한루프 돌수도 있어서,이거 제한기본값이 1000인데 이 기본값은 너무 크고 10으로 낮춰두는게 좋음
	그리고 꼭 필요한 쿼리에선 set_var힌트로 저 숫자를 그 쿼리에서만 변경하는게좋음(121p)
	
	이건 쓰기좋아보이니 나중에 다시한번보자
	
	
	윈도우함수는 현재 레코드를 기준으로,groupby연산같은걸 따로 레코드를 안건드리고 실행함
	즉 레코드는 그대로 출력되는데,거기서 groupby의 값을 가져다붙일수있는거임
	그래서 특정조건별 평균값을 모든 레코드를 보면서,거기다가 붙일수있음
	이 윈도우함수에서 주의할건,
		where,from,groupby,having
		윈도우
		select절,orderby,limit
	순으로 실행된다는거임
	그래서 윈도우함수를 그룹바이칼럼으로 사용할수없고,where절에도 사용할수없음
	그리고 limit를 붙여봐야 효과가 없기때문에,from절을 서브쿼리로 돌리고 그안에서 limit를 걸어야함
	이건
		함수() over(파티션바이 오더바이 프레임) as 별칭
	순으로 사용하면됨(파티션과 오더바이는 생략가능,안넣으면 각 개별레코드로 진행)
	파티션바이는 해당조건으로 묶는다는거,group by와 똑같이 동작(저기서만 쓰일뿐)
	적용순서에서 알수있는거처럼 where로 거른다음에 윈도우가 돌아가니까,테이블전체가 아닌 검색된 결과내에서 윈도우집계가 돌아감
	
	그리고 윈도우함수의 파티션안에서도 연산을 수행할 소그룹을 지정할수있는데 이게 프레임임
	이건 지정하지않으면 알아서 선택하고,명시적으로 지정하면,현재 레코드를 기준으로 어디까지 읽을건지를 정할수있음(앞뒤1개나 전체나 이런느낌)
	묵시적선택의 경우엔 orderby가 있냐없냐에 따라 결과가 달라짐
	그리고 일부 윈도우함수들은 프레임이 고정되어있는데,이때 프레임을 넣으면 무시되고 에러는 안나니까 주의
	
	이 윈도우함수엔 집계함수와 비집계함수가 둘다 있음
	집계함수는 groupby에 쓰는거고,얘들은 over없이 단독으로도 쓸수있고 over넣고 쓸수도있음
	비집계함수는 반드시 over절이 있어야함
	집계함수엔
		count,max,min,sum,avg
	등등이 있고(대표적인거만 적음)
	비집계함수엔
		first_value(파티션의 첫번째값반환),Rank(랭킹반환,갭있음),dense_rank(랭킹반환,갭없음),row_number(파티션내 레코드순번반환)
	등이 있음
	
	rank나 dense_rank나 둘다 orderby기준 순위반환인데,
	rank는 동률등수가 있으면 다음을 한칸미루고(공동1등 2명이면 다음등수 3등)
	dense_rank는 동률등수가 있어도 다음을 미루지않음(공동1등 2명이면 다음등수 2등)
	row_number은 동점에대한 고려없이 그냥 오더바이순서대로 1,2,3적음
	
	이 윈도우함수는 8.0부터 도입됐고,아직 인덱스를 이용한 최적화가 안될때가 있으니 explain해보면서 써야함
	그래서 윈도우함수에 크게 의존하진 않는게 좋지만,어짜피 where로 거르기때문에 잘걸러서 레코드양을 줄일수있으면 걍 써도됨
	
	
	select도 잠글수있는데,for update와 for share로 잠글수있음
	for share는 select로 읽은 쿼리에 대해 읽기잠금(읽기만 가능,쓰기는 불가)을 걸고
	for update는 select로 읽은쿼리에 대해 쓰기잠금(읽기도 불가,쓰기도 불가)을 검
	둘다 트랜잭션이니,자동커밋을 끄고 트랜잭션을 시작해야 잠금이 유지됨
	그리고 서로 for update,for share가 붙은 조회쿼리끼리만 잠금이 먹히고,그냥 저게 없는애들은 잠금무시하고 읽을수있음
	
	그리고 조인을 하거나해서 여러테이블을 건드릴때도 특정 테이블에만 잠금거는거도 가능(141p)
	
	그리고 nowait와 skip locked를 사용하면,
	만약 레코드가 잠겨있을경우 기다리지않고 즉시 실패처리를 하고싶다면 nowait
	해당 레코드를 무시하고 다른레코드들만 읽고싶다면 skip locked
	를 사용할수있음,물론 for update나 for share가 있어야 적용됨,없으면 어짜피 잠금무시하니까 의미없음
		select * from abc for update nowait
	이런식으로 쓰면됨
	
	skip locked를 쓰면 비확정적인 쿼리가 되니까 이건 주의해야함
	이 nowait와 skip locked는,큐를 mysql에서 만들때(선착순쿠폰발급) 유용함
	이때 for update skip_locked limit 1로 다른애가 잠그고있는건 무시하고 다음거를 가져와서 잠그고 이름적는느낌
	이러면 순차처리가(1번트랜잭션 끝나면 2번트랜잭션...끝까지 반복),동시처리가 돼서(서로 다른 레코드를 잠그고있으니) 속도가 올라감
	
	
3.insert
	보통 셀렉트의 성능을 올리면(인덱스추가)인서트의 성능을 떨어짐
	그래도 보통 조회성능이 훨씬 더 중요한경우가 많기때문에 인덱스를 만드는게 합리적임
	
	사실 인서트에서는 특별히 쿼리로 성능을 올릴수있는방법은 없음
	그냥 몇가지 알아두면 편한기능들은 있음
	
	insert ignore는,저장하는 레코드의 프라이머리키나 유니크키가 이미 있을때,해당 레코드를 무시하고 다음레코드를 처리할수 있게 해줌
	이건 보통 여러레코드를 하나의 인서트문장으로 처리할때 유용함
	이건 단순히 유니크의 중복뿐아니라,데이터타입이 일치하지않아서 인서트가 불가능할때도,칼럼의 기본값으로 인서트를 하게 만들기도 함
	즉 낫널에서 널이 들어가면 기본값인 0으로 세팅해서 인서트하는느낌
	이게 발동되면 경고메시지가 뜸,이건 주의해서 사용하는게 좋음
	
	insert ... on duplicate key update는 중복이 발생하면 현재값으로 해당레코드를 업데이트해줌
	즉 인서트 or 업데이트임
	
	인서트의 load data는,데이터를 빠르게 적재할수있지만,단일스레드에 단일트랜잭션이라는 단점이 있음
	그래서 가능하면 인서트를 쪼개서 나눠서 던지는 방식을 취하면 더 효율적으로 던질수있음(프라이머리키 기준으로 자르면됨)
	
	인서트의 성능은 쿼리보다 테이블의 구조의 영향을 많이받음
	보통 소량을 넣는경우가 많기때문
	그리고 데이터가 정렬되어있으면 훨씬 더 저렴하게 넣을수있음
	
	그리고 오토인크리즈먼트를 키로잡으면 이게 가장 빠른 인서트를 보장해줌
	
	
4.update와 delete
	update와 딜리트에 orderby를 넣고 limit를 걸어서 정렬해서 상위몇개만 지우는방식도 가능함
	이건 너무 많은 레코드를 건드려야할때 커넥션을 끊어가면서 가기위해 사용할수있음(과부하방지+언두로그 리셋)
	단 복제소스서버에서 이렇게하면 경고메시지가 뜰수있음(바이너리로그포맷이 row면 상관없는데,statement면 그럴수있음)
	이건 orderby에 의해 정렬되더라도 중복된값의 순서가 복제소스와 원본과 다를수있기때문(프라이머리키나 유니크키 기반이면 상관없겠지만 경고메시지는 뜸)
	
	
	join update는 두개이상의 테이블을 조인해서 결과레코드를 변경 및 삭제하는걸 말함
	보통 조인된 테이블중 특정 테이블의 칼럼값을 다른테이블에 업데이트해야할때 주로 사용됨(프라이머리키가 같은 레코드중 a테이블의값으로 b테이블값을 덮을때)
	혹은 조인되는 양쪽테이블에 공통으로 존재하는 레코드만 찾아서 업데이트할때도 사용할수있음
	
	이건 조인되는 모든테이블에 대해 읽기참조만 되는 테이블은 읽기잠금이,변경이 일어나는 테이블은 쓰기잠금이 걸림
	그래서 데드락확률이 올라가니 너무 자주쓰는건 피하는게 좋지만,통계용 update나 배치프로그램에선 유용하게 쓸수있음
	이 조인업데이트도 조인을 쓰니,드라이빙테이블과 드리븐테이블의 선택에 따라 성능이 바뀜,그래서 explain돌리는게좋음
	
	그리고 조인업데이트에선 그룹바이나 오더바이를 사용할수없음,그래서 서브쿼리를 사용해서 임시테이블을 생성해서 처리해야함
	
	
	여러레코드를 업데이트할때,만약 동일한값으로 업데이트하는게 아닌,변수를 사용한 업데이트도 가능함
	values row()나 row()를사용해서 임시테이블을 생성해서 그걸 참조하는식으로 할수있음(164p)
	
	
	조인딜리트는 조인이 성공한 레코드에 대해 특정테이블에서만 그 레코드들을 삭제하는거임
	즉 조인으로 체인걸어서 외래키로 같은프라이머리키가 있는 c테이블에 특정값이 있다면,a테이블에서 레코드를 삭제하는식
	물론 delete절에 여러개를 적으면,여러테이블도 삭제할수있음
	
	
5.스키마조작	
	8.0부터는 스키마 조작의 많은부분이 온라인처리가 돼서,따른테이블같은걸 따로 잠금을 걸지않고 진행하지만,아직도 락을 잡아야하는애들이 많이있음
	그리고 테이블에서 프라이머리키를 추가하는작업같은건 데이터파일의 재배열이 필요해서 테이블리빌드가 필요함
	단순히 칼럼이름바꾸는 그런건 메타데이터만 바꾸면되니 저런게 필요없고
	이런건 버전별로 차이가 크기때문에,작업하기전에 매뉴얼과 테스트를 해보는게 좋음
	
	온라인처리가 가능한 명령들은 169p참고
	그리고 보통 테이블 리빌드가 필요하고,최종로그적용이 필요해지면 중간과정에서 실패할 확률이 올라감
	그래서 이걸 최대한 줄이는게 좋음
	실패케이스는 
		alter table명령이 장시간 실행되고,동시에 다른커넥셔에서 dml이 많이 실행되거나,온라인변경로그공간이 부족
		alter table명령이 실행되는동안 alter table이후의 테이블구조에 적합하지않은 레코드가 인서트 or 업데이트되면 실패
		스키마변경을 위해 필요한 잠금수준보다 낮은잠금옵션일경우
		lock=none라도 처음과끝은 락이 필요한데,이걸 획득하지못하고 타임아웃걸리면 실패(메타데이터락)
		온라인 인덱스생성의 경우 정렬을위해 temdir에 명시된 경로를 사용해서 정렬하는데,디스크공간부족시 실패
	가 있음	
	모든 alter table명령은,performance_schema를 통해 진행상황을 모니터링할수있음(175p)
	
	
	mysql은 1개이상의 데이터베이스를 가질수있음,mysql에서 스키마와 데이터베이스는 동격의 개념임
	이건 그냥 객체에 대한 권한을 구분하는 용도정도로만 사용됨(그래서 use 데이터베이스명을 서버접속했을때 바로쓰는거)
	
	mysql은 전통적으로 테이블별로 테이블스페이스를 사용했음(각 테이블별 저장공간)
	이걸 제너럴테이블스페이스를 사용하면(8.0부터 가능),여러테이블의 데이터를 한테이블스페이스에 저장할수있음
	이건 여러제약사항이 있긴한데,테이블갯수가 매우많을땐 도움이됨
	중요한건 아닌듯
	
	
	테이블은 사용자데이터를 가지는 주체임
	테이블의 구조를 조회할땐
		show create table 테이블명 //해당테이블을 생성할수있는 쿼리 리턴
		desc 테이블명 //테이블의 메타데이터 리턴,k8s의 describe같은거임,단 인덱스칼럼의 순서나,외래키,테이블자체속성은 보여주지않음
	테이블 구조를 변경할떈,alter table을 사용함
	이건 테이블구조만이 아닌 인덱스 추가삭제와 칼럼추가삭제에서도 사용됨
	테이블단에서 이걸 사용하는건,보통 테이블의 인코딩이나 스토리지엔진,파티션구조등을 변경할때 사용됨
	스토리지엔진은 보통 바꿀일없을거고,인코딩변경은 가끔할일이 생김
	
	테이블명을 변경할떈 
		rename table 원래테이블명 to 바꿀테이블명
		rename table db1.원래테이블명 to db2.바꿀테이블명
	이렇게함,같은 db내에서 변경은 메타데이터만 바꿔서 매우빠른데,다른 db내 변경은 파티션이 보통 다르기떄문에 다 복사붙여넣기해야해서 오래걸림
	그리고 블루그린방식같이 서로 이름을 교체할땐
		rename table a to a_old,a_new to a
	이런식으로 묶어서 처리하면 중간에 a테이블이 비는시간이 안생김(잠금대기만 발생)
	
	테이블의 정보를 볼땐
		show table status like '테이블명'
	으로 할수있음,여기선 전체레코드갯수,레코드평균크기등을 알수있음
	이정보들은 information_schema에 관리되는걸 가져오기때문에,
	저기에 직접 접근해서 mysql의 테이블들이 사용하는 디스크공간정보를 조회할수도있음
	
	데이터는 복사하지않고,테이블의 구조만 동일하게 복사할땐
		create table 새로만들테이블명 like 테이블명
	으로 인덱스까지 완전히 복사할수있음
	데이터까지 복사하려면
		create table 새로만들테이블명 like 테이블명
		insert into 새로만들테이블명 select * from 테이블명
	이 두개를 같이돌리면됨
	테이블 삭제는 drop table을 쓰고,딱히 다른테이블에 영향을 직접적으로 주진않는데
	큰테이블삭제는 부하가 크기때문에 간접적인 영향을 줄수는있음(속도감소)
	
	테이블구조변경은 대부분 칼럼을 추가하거나 칼럼타입을 변경하는 작업임
	가장 마지막에 새칼럼추가
		alter table 테이블명 add column 칼럼명 타입
	이경우엔 그냥 마지막에 넣으면돼서 instant로 즉발추가가 가능함
	근데 중간에 새칼럼을 추가할땐
		alter table 테이블명 add column 칼럼명 타입 after 추가할위치의칼럼명
	이렇게하는데,이경우엔 테이블의 리빌드가 필요해서 오래걸림
	테이블이 크다면 가능하면 마지막에 추가하는게좋음
	
	삭제는 항상 리빌드가 필요함
		alter table 테이블명 drop column 칼럼명
	이름 및 타입을 변경할땐
		alter table 테이블명 change 이전칼럼명 이후칼럼명 타입 속성 //이름변경,속성은 not null같은거 그냥적으면됨
		alter table 테이블명 modify 칼럼명 바꿀타입 속성  //타입변경,varchar길이도 똑같음
	이렇게함
	이떄 이름변경은 즉발,타입변경은 많이느리고 쓰기락,varchar 길이증가는 리빌드할수도있고 안할수도있음,varchar 길이감소는 많이느리고 쓰기락
	varchar이 리빌드 하는 조건은,255(1바이트)이하에서 256~(2바이트이상)으로 늘어날땐 리빌드를 해야하고,그안에서 놀땐 상관없음
	
	

	
	
	
	
	