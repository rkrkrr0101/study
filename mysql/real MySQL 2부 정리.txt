11.쿼리 작성 및 최적화
	필요없는건 스킵
	앞부분에 5.7이랑 8.0이랑 호환설정같은거 있으니 책 참고(안시쿼리호환설정도있음)
	
	테이블은 항상 대문자나 소문자로 통일해서 만들기
	예약어인지 확인할떈,해당이름으로 테이블만들어서 만들어지면 예약어아니고,안만들어지면 예약어임
	이때 역따옴표를 붙이면 테스트가 안되고,기본적으로 테이블생성시 역따옴표를 안쓰는게좋음
	
	mysql 메뉴얼에서
		대문자는 키워드
		이탤릭체는 토큰(테이블명,칼럼명,표현식)
		대괄호는 선택사항
		파이프는 하나만 선택가능
		중괄호는 괄호내에서 반드시 하나를 선택해야함(필수사항)
		...은 앞에 명시된 키워드나 표현식의 조합이 반복될수있음을 의미함
	이거알면 대충볼수있음
	
1.mysql연산자와 내장함수
	문자열은 ''와 ""를 혼용가능,예약어충돌은 ``쓰면되는데 안쓰는게좋음 가능하면
	숫자는 그냥 넣으면되고,문자열과 숫자를 비교하는건 가능하면 안하고 통일시키는게좋음 타입을
	날짜타입은 date고 스트링도 포맷만 맞으면 날짜랑 비교를 할수있음
	불리언타입은 있긴한데,이건 그냥 tinyint임,그래서 이거쓰지말고 enum쓰는게좋음
	
	연산자는
		= 동등비교(null=null   -> null)
		<=> 널을포함한 동등비교(null<=>null -> true)
		<>,!=부정비교
		not,! 부정연산(tf연산을 뒤집음)
		and(&&),or(||) 연산결합,기호대신 문자쓰는게 가독성좋음
		/,div 나누기
		%,mod 나머지
		regexp 정규식일치확인
		rlike 정규식 라이크
		like 부분일치(인덱스타려면 aaa%식으로 써야함 %aaa는 못탐),%와 _를 사용할수있음
		between 양쪽사이의 값(이건 인덱스타기 힘드니까 인덱스 작업범위결정조건용 조건을 앞에 넣어두는게좋음),가능하면 in으로 바꾸는게 성능상좋음
		in 여러값에 대해 이퀄연산
	등이 있음	
	
	내장함수에는
		ifnull():널이면 다른값으로 변경
		isnull():널인지 아닌지 확인
		now():현재시간반환,정확히는 트랜잭션을 시작한시간을 반환함
		sysdate():사용금지
		date_format():datetime타입을 스트링으로 반환
		str_to_date():스트링을 datetime타입으로 변경
		date_add():날짜시간을 지정한만큼 추가
		date_sub():날짜시간을 지정한만큼 감소
		unix_timestamp():1970년1월1일 00:00:00로 부터 경과된 초를 반환(디폴트는 현재,해당데이트타임넣으면 그때의 타임스탬프반환)
		rpad():해당문자열의 오른쪽을 해당길이만큼 해당문자로 채워줌
		lpad():해당문자열의 왼쪽을 해당길이만큼 해당문자로 채워줌
		rtrim():해당문자열의 오른쪽의 공백을 지워줌
		ltrim():해당문자열의 왼쪽의 공백을 지워줌
		trim():해당문자열의 양쪽의 공백을 지워줌
		concat():여러문자열을 합쳐서 리턴(숫자를넣으면 문자열로 바꿔서더함)
		concat_ws():여러문자열을 합쳐서 리턴,중간에 구분자넣기도 가능(숫자를넣으면 문자열로 바꿔서더함)
		group_concat():그룹바이된 결과의 문자열들을 다 더해줌,구분자넣기도 가능,이때 메모리버퍼쓰는데 제한이 1kb니 시스템변수에서 늘릴수있음
		case when구문:스위치문임,보통 서브쿼리의 필요없는 동작을 막을때 사용(어짜피 버리는데 돌아가는거 막는다던가)
		cast():해당타입으로 변형
		convert():해당타입으로 변형 or 해당문자열의 인코딩형식 변경
		hex():해당숫자를 16진수스트링으로 변경
		unhex():16진수스트링을 바이너리로 변경
		md5():암호화함수,해시할때 사용하기도함
		sleep():쿼리를 해당시간동안 멈출수있음,보통 디버깅에사용
		benchmark():해당쿼리를 n번 실행시켜서 평균실행시간 리턴,단 계획수립은 1번만하니 이건 주의(두쿼리를 비교분석할때 사용하면됨)
		inet_aton():스트링ip주소를 바이너리타입으로 변형
		inet_ntoa():바이너리타입을 스트링ip주소로 변형
		json_pretty():json칼럼의 가독성을 좋게해줌
		json_storage_size():json칼럼의 바이트크기를 리턴해줌
		json_extract():json에서 특정값을 추출해옴,따옴표붙어있음,->연산자와 같음
		json_unquote():json에서 특정값을 추출해옴,따옴표없음,->>연산자와 같음
		json_contains():json전체,혹은 해당위치의 아래에 해당json필드가 있는지 확인
		json_object():해당칼럼들의 값으로 json을 생성
		json_objectagg():group by함수,칼럼들의 값으로 json을 생성
		json_arrayagg():group by함수,칼럼들의 값으로 json배열을 생성
		json_table():json값들을 모아서 rdbms테이블로 만들어서 반환함(임시테이블)
	등이 있음	
	
2.select
	셀렉트 문장은 조회 전체를 말하고,셀렉트절은 조회칼럼선택을 말함
		select절:select *,count(e.name) as cnt
		from절:from qwetable q inner join emp e on e.emp_no=q.emp_no
		where절:where a in 1
		group by절:group by q.emp_no
		having절:having avg(q.money>1000)
		order by절:order by avg(q.money)
		limit절:limit 10
	이런구성임
	이떄 실행순서를 알아야하는데,
		1.select,from,where절로 인덱스를 사용해서 데이터를 가져오고 조인함
		2.group by
		3.distinct
		4.having
		5.order by
		6.limit
	순으로 진행됨,또한 인덱스를 사용할수있을땐 order by와 group by는 생략됨(어짜피 정렬됐고 그대로 쭉 긁어서 그룹바이하면되니까)
	예외적으로,order by만 있고 group by가 없을땐
		1.1.select,from,where절로 인덱스를 사용해서 데이터를 가져옴
		2.order by함
		3.정렬된 데이터를 조인함
	이런순서로 진행됨
	
	만약 이런순서를 벗어나고싶으면 서브쿼리를 사용한 인라인뷰를 사용해야함(from절 서브쿼리로 임시테이블을 생성해서 거기서 진행)
	
	where나 order by,group by가 인덱스를 사용하려면 만족해야하는 조건은
		인덱스된 칼럼의 값을 절대 변형하면안됨(substr,a*10=100),가능하면 우항쪽으로 옮겨야 인덱스탈수있음,해싱같은경우 가상컬럼사용
		where절의 경우,양쪽의 데이터타입이 일치해야함(이거도 값을 변형하면안된다는거랑 사실같은소리)
	가 일단 전제조건임
	
	where에서 인덱스를 사용하는 방법은 작업범위결정조건과 체크조건 두가지가 있고,가능하면 작업범위결정조건을 늘려야함
	이때,인덱스에서의 왼쪽부터 조건이 하나씩 들어있을수록 효율성이 올라감(반대로말하면,왼쪽이 없으면 인덱스풀스캔을 함)
	그리고 딱히 where안에서의 순서와,인덱스의 순서는 상관없음
	이건 and조건이고,
	or조건은 전혀 데이터를 줄여주지못하고,오히려 해당조건으로 한번 더읽어야해서 풀테이블스캔의 확률을 높임
	가능하면 or은 빼고,넣더라도 and로 감싸서넣어야함
	
	group by에서 인덱스는,여긴 따로 작업범위결정조건과 체크조건같은게 없고,단순하게 group by에 있는 칼럼들의 순서와 인덱스의 순서만 같으면됨
	이때
		group by에 명시된 칼럼이 인덱스칼럼과 순서가 같아야함
		인덱스의 앞쪽에 있는걸 생략할순없음(뒤에있는건 생략가능)
		group by에 인덱스에 명시되지않은 칼럼이 하나라도 있으면 인덱스를 전혀 못탐
	가 있음,
	추가적으로,where조건절에 인덱스의 앞에있는칼럼을 이퀄로 비교했을경우,이걸 대신사용해서 인덱스를 타는경우도 있음
	즉 group by와 where 이퀄비교를 합쳐서 생각해도됨
	물론 where가 대신해줄수있는건 맨앞이 비어있을때뿐임,즉 group by의 맨앞에 where의 이퀄비교들이 있다고 보면됨
	
	order by는 group by와 거의비슷한데,정렬방식이 인덱스와 같거나 정반대여야한다는 추가조건 하나만 더있음
	
	쿼리에 where절이나 groupby,orderby가 동시에 있을경우에도 서로 같은 인덱스를 사용해야함(제약조건)
	이때(여기서 groupby와 orderby를 치환해도 똑같음)
		where절과 orderby가 같은인덱스를 사용:둘다 조건을 만족할때 가능,제일빠름
		where절만 인덱스를 사용:orderby는 파일소트로 정렬해야함,where로 많이 거를수있을때 효율적
			where로 임시테이블을 만들고 그안에서 정렬한다고 생각하면됨
		order by절만 인덱스를 사용:orderby를 인덱스로 처리하면서 where를 전부 체크조건으로 사용함,레코드가 아주 많은걸 정렬해야할때 사용함
			인덱스 풀테이블스캔으로 정렬하면서 where도 겸사겸사 처리하는느낌
	이렇게됨
	양쪽다 인덱스를 사용하려면,where절의 이퀄칼럼과 orderby의 칼럼들이 순서대로 빠짐없이 인덱스의 왼쪽부터 일치해야함
	중첩되는건 상관없는데,둘중 하나라도 빠지는칼럼이 있으면 동시사용은 불가능,이떈 보통 where이 인덱스를 탐
	
	group by와 order by가 동시에 인덱스를 타려면,양쪽이 모두 명시된 칼럼의 순서와 내용이 완전히 같아야함
	이때 둘중 하나라도 인덱스를 못타면,양쪽다 인덱스를 못타니까 주의해야함(즉 양쪽이 인덱스타는건 연대조건임)
	
	where와 orderby,groupby가 전부 동시에 인덱스를 타려면
		where이 인덱스를 사용할수있는가?
		groupby가 인덱스를 사용할수있는가?
		groupby와 orderby가 동시에 인덱스를 사용할수있는가?
	이 3개를 다 만족해야함
	즉
		3개다 만족하면 3개다 타는거고
		1번을 만족못하고 나머지는 만족하면 groupby,orderby만 타는거고
		1번을 만족하고 2,3번중 하나라도 만족못하면 where만 타고
		1번을 만족못하고 2,3번중 하나라도 만족못하면 인덱스 사용불가
	이렇게됨
	
	
	where에서 비교조건(이퀄)을 사용할때 주의해야할건
	null은 비교불가값이라 a=null 사용하면 tf로 안나옴,이떈 a is null이나 isnull(a)써야함
	그리고 isnull(a)쓸때 그냥 저대로 던지면됨
		isnull(a)=true //이렇게쓰면안됨
	이렇게 쓰면 안됨,변형일어났으니 풀테이블스캔함
	
	문자열이나 숫자를 비교할땐,반드시 그타입에 맞는 상숫값을 사용해야함,즉 문자열이면 문자열과 비교,숫자면 숫자와 비교
	
	date와 datetime과 문자열을 비교할땐,문자열을 자동으로 datetime으로 변환해서 수행하고,이때는 인덱스 타니까 신경안써도됨
	당연히 왼쪽의 칼럼을 스트링으로 변형하는거도 안됨
	날짜를 빼거나 더해서 비교할떄도,좌항은 그대로두고 우항쪽에서 빼고더하고를 거꾸로해서 처리해야함
	
	date와 datetime끼리 비교할땐,자동으로 date를 datetime으로 변형해서 사용하는데,
	이떄도 인덱스는 똑같이씀(왼쪽에 변형일어나도 인덱스씀,예외케이스)
	
	date,datetime과 timestamp를 비교할땐 주의해야함,실행계획도 레인지스캔하는거같은데 아님
	칼럼이(우항이) datetime이라면 from_unixtime()로 timestamp를 datetime으로 변환해야하고,
	칼럼이(우항이) timestamp라면 from_timestamp()로 datetime을 timestamp로 변환해야됨(now를 써도됨)
	이래야 인덱스를 탐,타임스탬프는 mysql에선 단순 상수로 취급되기때문에 변형을 해줘야함
	
	mysql도 Short-Circuit Evaluation(if문에서 앞에서부터 체크하고 나가리면 뒤에거 체크안하고 넘어가는거)가 있기때문에
	where의 조건의 순서가 성능에 영향을 미침(근데 cpu쪽부하라서 크진않은듯)
	그리고 where에서 인덱스에 관련된 조건이 있으면 그걸 맨앞으로 떙겨서 처리함(그래서 where에서 인덱스순서랑 조건순서랑 맞출필요없는거)
	일단 서브쿼리로 뽑아오는거나 그런건 맨뒤에 배치하면될듯
	
	distinct는 1권참고
	
	limit는 항상 마지막에 실행되고,중요한건 리미트에 표시된 레코드건수만 준비되면 바로 쿼리가 종료됨,
	그래서 groupby나 orderby에서도 약간의 성능향상이 있긴하고,where에서도 약간의 성능향상은 있음
	distinct의 경우엔 정렬은 안해도되고 유니크하기만 하면되니까 많은 성능향상이 있음
	풀테이블스캔이라도 따로 처리가 없으면 굉장히 빨리끝남
	그리고 리미트에서는 인자로 표현식이나 서브쿼리를 넣을수없음
	추가적으로 페이징을 위해 리미트를 쓰는건(limit 100,10),페이지가 커질경우에 비효율적이됨(앞에있는페이지를 다 읽고 가야하기때문에)
	그래서 페이지가 무한정 늘어날거같으면,where로 위치를 찾고(키값이나 날짜인덱스사용,81p참고),거기서 고정된 limit를 읽는게좋음
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	