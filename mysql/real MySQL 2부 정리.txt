11.쿼리 작성 및 최적화
	필요없는건 스킵
	앞부분에 5.7이랑 8.0이랑 호환설정같은거 있으니 책 참고(안시쿼리호환설정도있음)
	
	테이블은 항상 대문자나 소문자로 통일해서 만들기
	예약어인지 확인할떈,해당이름으로 테이블만들어서 만들어지면 예약어아니고,안만들어지면 예약어임
	이때 역따옴표를 붙이면 테스트가 안되고,기본적으로 테이블생성시 역따옴표를 안쓰는게좋음
	
	mysql 메뉴얼에서
		대문자는 키워드
		이탤릭체는 토큰(테이블명,칼럼명,표현식)
		대괄호는 선택사항
		파이프는 하나만 선택가능
		중괄호는 괄호내에서 반드시 하나를 선택해야함(필수사항)
		...은 앞에 명시된 키워드나 표현식의 조합이 반복될수있음을 의미함
	이거알면 대충볼수있음
	
1.mysql연산자와 내장함수
	문자열은 ''와 ""를 혼용가능,예약어충돌은 ``쓰면되는데 안쓰는게좋음 가능하면
	숫자는 그냥 넣으면되고,문자열과 숫자를 비교하는건 가능하면 안하고 통일시키는게좋음 타입을
	날짜타입은 date고 스트링도 포맷만 맞으면 날짜랑 비교를 할수있음
	불리언타입은 있긴한데,이건 그냥 tinyint임,그래서 이거쓰지말고 enum쓰는게좋음
	
	연산자는
		= 동등비교(null=null   -> null)
		<=> 널을포함한 동등비교(null<=>null -> true)
		<>,!=부정비교
		not,! 부정연산(tf연산을 뒤집음)
		and(&&),or(||) 연산결합,기호대신 문자쓰는게 가독성좋음
		/,div 나누기
		%,mod 나머지
		regexp 정규식일치확인
		rlike 정규식 라이크
		like 부분일치(인덱스타려면 aaa%식으로 써야함 %aaa는 못탐),%와 _를 사용할수있음
		between 양쪽사이의 값(이건 인덱스타기 힘드니까 인덱스 작업범위결정조건용 조건을 앞에 넣어두는게좋음),가능하면 in으로 바꾸는게 성능상좋음
		in 여러값에 대해 이퀄연산
	등이 있음	
	
	내장함수에는
		ifnull():널이면 다른값으로 변경
		isnull():널인지 아닌지 확인
		now():현재시간반환,정확히는 트랜잭션을 시작한시간을 반환함
		sysdate():사용금지
		date_format():datetime타입을 스트링으로 반환
		str_to_date():스트링을 datetime타입으로 변경
		date_add():날짜시간을 지정한만큼 추가
		date_sub():날짜시간을 지정한만큼 감소
		unix_timestamp():1970년1월1일 00:00:00로 부터 경과된 초를 반환(디폴트는 현재,해당데이트타임넣으면 그때의 타임스탬프반환)
		rpad():해당문자열의 오른쪽을 해당길이만큼 해당문자로 채워줌
		lpad():해당문자열의 왼쪽을 해당길이만큼 해당문자로 채워줌
		rtrim():해당문자열의 오른쪽의 공백을 지워줌
		ltrim():해당문자열의 왼쪽의 공백을 지워줌
		trim():해당문자열의 양쪽의 공백을 지워줌
		concat():여러문자열을 합쳐서 리턴(숫자를넣으면 문자열로 바꿔서더함)
		concat_ws():여러문자열을 합쳐서 리턴,중간에 구분자넣기도 가능(숫자를넣으면 문자열로 바꿔서더함)
		group_concat():그룹바이된 결과의 문자열들을 다 더해줌,구분자넣기도 가능,이때 메모리버퍼쓰는데 제한이 1kb니 시스템변수에서 늘릴수있음
		case when구문:스위치문임,보통 서브쿼리의 필요없는 동작을 막을때 사용(어짜피 버리는데 돌아가는거 막는다던가)
		cast():해당타입으로 변형
		convert():해당타입으로 변형 or 해당문자열의 인코딩형식 변경
		hex():해당숫자를 16진수스트링으로 변경
		unhex():16진수스트링을 바이너리로 변경
		md5():암호화함수,해시할때 사용하기도함
		sleep():쿼리를 해당시간동안 멈출수있음,보통 디버깅에사용
		benchmark():해당쿼리를 n번 실행시켜서 평균실행시간 리턴,단 계획수립은 1번만하니 이건 주의(두쿼리를 비교분석할때 사용하면됨)
		inet_aton():스트링ip주소를 바이너리타입으로 변형
		inet_ntoa():바이너리타입을 스트링ip주소로 변형
		json_pretty():json칼럼의 가독성을 좋게해줌
		json_storage_size():json칼럼의 바이트크기를 리턴해줌
		json_extract():json에서 특정값을 추출해옴,따옴표붙어있음,->연산자와 같음
		json_unquote():json에서 특정값을 추출해옴,따옴표없음,->>연산자와 같음
		json_contains():json전체,혹은 해당위치의 아래에 해당json필드가 있는지 확인
		json_object():해당칼럼들의 값으로 json을 생성
		json_objectagg():group by함수,칼럼들의 값으로 json을 생성
		json_arrayagg():group by함수,칼럼들의 값으로 json배열을 생성
		json_table():json값들을 모아서 rdbms테이블로 만들어서 반환함(임시테이블)
	등이 있음	
	
2.select
	셀렉트 문장은 조회 전체를 말하고,셀렉트절은 조회칼럼선택을 말함
		select절:select *,count(e.name) as cnt
		from절:from qwetable q inner join emp e on e.emp_no=q.emp_no
		where절:where a in 1
		group by절:group by q.emp_no
		having절:having avg(q.money>1000)
		order by절:order by avg(q.money)
		limit절:limit 10
	이런구성임
	이떄 실행순서를 알아야하는데,
		1.select,from,where절로 인덱스를 사용해서 데이터를 가져오고 조인함
		2.group by
		3.distinct
		4.having
		5.order by
		6.limit
	순으로 진행됨,또한 인덱스를 사용할수있을땐 order by와 group by는 생략됨(어짜피 정렬됐고 그대로 쭉 긁어서 그룹바이하면되니까)
	예외적으로,order by만 있고 group by가 없을땐
		1.1.select,from,where절로 인덱스를 사용해서 데이터를 가져옴
		2.order by함
		3.정렬된 데이터를 조인함
	이런순서로 진행됨
	
	만약 이런순서를 벗어나고싶으면 서브쿼리를 사용한 인라인뷰를 사용해야함(from절 서브쿼리로 임시테이블을 생성해서 거기서 진행)
	
	where나 order by,group by가 인덱스를 사용하려면 만족해야하는 조건은
		인덱스된 칼럼의 값을 절대 변형하면안됨(substr,a*10=100),가능하면 우항쪽으로 옮겨야 인덱스탈수있음,해싱같은경우 가상컬럼사용
		where절의 경우,양쪽의 데이터타입이 일치해야함(이거도 값을 변형하면안된다는거랑 사실같은소리)
	가 일단 전제조건임
	
	where에서 인덱스를 사용하는 방법은 작업범위결정조건과 체크조건 두가지가 있고,가능하면 작업범위결정조건을 늘려야함
	이때,인덱스에서의 왼쪽부터 조건이 하나씩 들어있을수록 효율성이 올라감(반대로말하면,왼쪽이 없으면 인덱스풀스캔을 함)
	그리고 딱히 where안에서의 순서와,인덱스의 순서는 상관없음
	이건 and조건이고,
	or조건은 전혀 데이터를 줄여주지못하고,오히려 해당조건으로 한번 더읽어야해서 풀테이블스캔의 확률을 높임
	가능하면 or은 빼고,넣더라도 and로 감싸서넣어야함
	
	group by에서 인덱스는,여긴 따로 작업범위결정조건과 체크조건같은게 없고,단순하게 group by에 있는 칼럼들의 순서와 인덱스의 순서만 같으면됨
	이때
		group by에 명시된 칼럼이 인덱스칼럼과 순서가 같아야함
		인덱스의 앞쪽에 있는걸 생략할순없음(뒤에있는건 생략가능)
		group by에 인덱스에 명시되지않은 칼럼이 하나라도 있으면 인덱스를 전혀 못탐
	가 있음,
	추가적으로,where조건절에 인덱스의 앞에있는칼럼을 이퀄로 비교했을경우,이걸 대신사용해서 인덱스를 타는경우도 있음
	즉 group by와 where 이퀄비교를 합쳐서 생각해도됨
	물론 where가 대신해줄수있는건 맨앞이 비어있을때뿐임,즉 group by의 맨앞에 where의 이퀄비교들이 있다고 보면됨
	
	order by는 group by와 거의비슷한데,정렬방식이 인덱스와 같거나 정반대여야한다는 추가조건 하나만 더있음
	
	쿼리에 where절이나 groupby,orderby가 동시에 있을경우에도 서로 같은 인덱스를 사용해야함(제약조건)
	이때(여기서 groupby와 orderby를 치환해도 똑같음)
		where절과 orderby가 같은인덱스를 사용:둘다 조건을 만족할때 가능,제일빠름
		where절만 인덱스를 사용:orderby는 파일소트로 정렬해야함,where로 많이 거를수있을때 효율적
			where로 임시테이블을 만들고 그안에서 정렬한다고 생각하면됨
		order by절만 인덱스를 사용:orderby를 인덱스로 처리하면서 where를 전부 체크조건으로 사용함,레코드가 아주 많은걸 정렬해야할때 사용함
			인덱스 풀테이블스캔으로 정렬하면서 where도 겸사겸사 처리하는느낌
	이렇게됨
	양쪽다 인덱스를 사용하려면,where절의 이퀄칼럼과 orderby의 칼럼들이 순서대로 빠짐없이 인덱스의 왼쪽부터 일치해야함
	중첩되는건 상관없는데,둘중 하나라도 빠지는칼럼이 있으면 동시사용은 불가능,이떈 보통 where이 인덱스를 탐
	
	group by와 order by가 동시에 인덱스를 타려면,양쪽이 모두 명시된 칼럼의 순서와 내용이 완전히 같아야함
	이때 둘중 하나라도 인덱스를 못타면,양쪽다 인덱스를 못타니까 주의해야함(즉 양쪽이 인덱스타는건 연대조건임)
	
	where와 orderby,groupby가 전부 동시에 인덱스를 타려면
		where이 인덱스를 사용할수있는가?
		groupby가 인덱스를 사용할수있는가?
		groupby와 orderby가 동시에 인덱스를 사용할수있는가?
	이 3개를 다 만족해야함
	즉
		3개다 만족하면 3개다 타는거고
		1번을 만족못하고 나머지는 만족하면 groupby,orderby만 타는거고
		1번을 만족하고 2,3번중 하나라도 만족못하면 where만 타고
		1번을 만족못하고 2,3번중 하나라도 만족못하면 인덱스 사용불가
	이렇게됨
	
	
	where에서 비교조건(이퀄)을 사용할때 주의해야할건
	null은 비교불가값이라 a=null 사용하면 tf로 안나옴,이떈 a is null이나 isnull(a)써야함
	그리고 isnull(a)쓸때 그냥 저대로 던지면됨
		isnull(a)=true //이렇게쓰면안됨
	이렇게 쓰면 안됨,변형일어났으니 풀테이블스캔함
	
	문자열이나 숫자를 비교할땐,반드시 그타입에 맞는 상숫값을 사용해야함,즉 문자열이면 문자열과 비교,숫자면 숫자와 비교
	
	date와 datetime과 문자열을 비교할땐,문자열을 자동으로 datetime으로 변환해서 수행하고,이때는 인덱스 타니까 신경안써도됨
	당연히 왼쪽의 칼럼을 스트링으로 변형하는거도 안됨
	날짜를 빼거나 더해서 비교할떄도,좌항은 그대로두고 우항쪽에서 빼고더하고를 거꾸로해서 처리해야함
	
	date와 datetime끼리 비교할땐,자동으로 date를 datetime으로 변형해서 사용하는데,
	이떄도 인덱스는 똑같이씀(왼쪽에 변형일어나도 인덱스씀,예외케이스)
	
	date,datetime과 timestamp를 비교할땐 주의해야함,실행계획도 레인지스캔하는거같은데 아님
	칼럼이(우항이) datetime이라면 from_unixtime()로 timestamp를 datetime으로 변환해야하고,
	칼럼이(우항이) timestamp라면 from_timestamp()로 datetime을 timestamp로 변환해야됨(now를 써도됨)
	이래야 인덱스를 탐,타임스탬프는 mysql에선 단순 상수로 취급되기때문에 변형을 해줘야함
	
	mysql도 Short-Circuit Evaluation(if문에서 앞에서부터 체크하고 나가리면 뒤에거 체크안하고 넘어가는거)가 있기때문에
	where의 조건의 순서가 성능에 영향을 미침(근데 cpu쪽부하라서 크진않은듯)
	그리고 where에서 인덱스에 관련된 조건이 있으면 그걸 맨앞으로 떙겨서 처리함(그래서 where에서 인덱스순서랑 조건순서랑 맞출필요없는거)
	일단 서브쿼리로 뽑아오는거나 그런건 맨뒤에 배치하면될듯
	
	distinct는 1권참고
	
	limit는 항상 마지막에 실행되고,중요한건 리미트에 표시된 레코드건수만 준비되면 바로 쿼리가 종료됨,
	그래서 groupby나 orderby에서도 약간의 성능향상이 있긴하고,where에서도 약간의 성능향상은 있음
	distinct의 경우엔 정렬은 안해도되고 유니크하기만 하면되니까 많은 성능향상이 있음
	풀테이블스캔이라도 따로 처리가 없으면 굉장히 빨리끝남
	그리고 리미트에서는 인자로 표현식이나 서브쿼리를 넣을수없음
	추가적으로 페이징을 위해 리미트를 쓰는건(limit 100,10),페이지가 커질경우에 비효율적이됨(앞에있는페이지를 다 읽고 가야하기때문에)
	그래서 페이지가 무한정 늘어날거같으면,where로 위치를 찾고(키값이나 날짜인덱스사용,81p참고),거기서 고정된 limit를 읽는게좋음
	
	count는 결과레코드의 건수를 반환함
	이떄 count(1)과 count(*)은 같음
	이노디비는 카운트를 쓸때 무조건 데이터나 인덱스를 읽어야(풀테이블스캔)하기때문에 주의해야함
	그리고 count쿼리에서는,order by와 left join같은건 넣으면안됨
	보통 페이징처리를 위해 사용할때가 많은데,이때 쓸데없는 부하임 이건
	order by는 어떤경우에도 필요없고(8.0부터는 무시하긴함),left join은 레코드수의 변화가 없으면 빼버리는게 성능상 좋음
	그리고 count함수에 칼럼명이나 표현식을 인자로 사용하면,거기서 널이 아닌거만 세는거도 주의해야함
	카운트쿼리는 부하가 엄청나기때문에,가능하면 빼는방향으로 가는게 좋음
	
	
	join작업을 할때,드라이빌테이블을 읽을땐 인덱스탐색을 한번만 하고,그뒤로는 스캔만 하면됨
	근데 드리븐테이블에서는 인덱스탐색작업과 스캔작업을 드라이빙테이블에서 읽은 레코드건수만큼 반복해야함
	그래서 드리븐테이블을 읽는게 훨씬 큰 부하를 차지함
	그래서 옵티마이저는 항상 드리븐테이블을 최적으로 읽을수있게 실행계획을 짬
	이때 각 테이블별로 인덱스가 있고없고에 따라
		양쪽다 인덱스있음:신경안써도됨 알아서잘함
		한쪽만 인덱스있음:일반적으로 인덱스있는쪽을 드리븐으로 잡음
		양쪽다 인덱스없음:인덱스만들생각부터 하자,어케하든 망했음
	이렇게 잡음
	그리고 조인조건(on)에서도 데이터타입의 변형없이,데이터타입의 타입을 서로 맞춰줘야 인덱스를 탈수있음(이쪽은 양변이 다 변형없어야함)
	
	이너조인은 조인대상테이블 양쪽에 모두 존재하는 레코드만 결과집합으로 반환함
	그래서 아우터조인(left join)을 자주 사용하게되는데,이건 이너조인보다 비효율적임
	그래서,한쪽 테이블에 존재하는 사원중에 반대쪽테이블이 null인 레코드를 반드시 반환해야하는게 아니면 이너조인쓰는게좋음
	이게 왜 비효율적이냐면,아우터조인을 쓰면 대상테이블은 절대 드라이빙테이블이 될수없어져서,옵티마이저가 성능을 좋게할 건덕지가 없어짐
	
	그리고 추가적으로,아우터조인을 하면서 아우터조인테이블에 대한 조건을 where에 넣으면안됨,이 조건은 on절에 들어가야함
	예외적으로,안티조인을 쓸때만 where에 조건을 넣을수있음
	
	그리고 db에서 외래키는 참조무결성을 위한거지 조인과는 전혀상관없음
	
	
	일반적으론 조인쓰면서 groupby와 orderby를 쓰면 알아서 최적화를하는데,만약 못한다면 조인을 끝내고나서 그룹바이나 오더바이를 처리함
	이때 조인이 실행되기전에 그룹바이나 오더바이를 처리하면 효율이 올라가는데,이게 지연된 조인임
	보통 이건 limit가 있는 쿼리에서 효과가 좋음
	이건 어떻게하냐면,메인쿼리의 from절에 원래쿼리에서 조인뺴고 오더바이랑 그룹바이를 친 결과물을 서브쿼리로 넣고,거기다가 조인을 하는거임
	이걸 하기위한 조건은
		left join일경우 1:1 또는 n:1이어야함
		inner join일경우 1:1 또는 n:1임과 동시에 양쪽테이블에 모두 존재해야함
	보통 페이징쿼리를 이런식으로 하면 성능차가 좀 남(조인갯수도 줄이면서 그룹바이나 오더바이를 처리할레코드수도 줄이니)
	
	
	8.0부터는 래터럴조인을 사용해서 특정그룹별로 서브쿼리를 실행해,그 결과와 조인하는게 가능해졌음
	즉 서브쿼리로 임시테이블을 만들고 그거와 조인거는거(이때 프롬절내부의 서브쿼리가 외부의 칼럼을 참조할수있음)
	이건
		let join lateral(서브쿼리) on ...
	이렇게씀
	이 lateral이 들어가야 from안에서 외부칼럼을 접근할수있음
	이 lateral서브쿼리는 조인순서상 후순위로 밀리고,결과로 외부테이블이 생성되기때문에 성능에 주의해야함(꼭 필요할때만 사용)
	
	그리고 조인쓰면 정렬된거처럼 보일수도있는데,orderby가 없으면 정렬에 대한 보장이 되지않으니,정렬이 필요하면 반드시 명시적으로 넣어줘야함
	드라이빙테이블이 바뀌거나 그러면 머리아파짐
	
	
	group by가 사용된 쿼리에선,그룹필된 그룹별로 소계를 가져올수있는 rollup기능이 있음(총합을 표시해줌)
	즉 그룹바이를 친 칼럼으로,나머지 칼럼들은 다 null로 적히고 카운트에 총합이 있는 형태임,이건 항상 해당그룹의 마지막에 나타남
	이 null을 바꾸고싶으면,grouping()함수를 사용해서 기본값을 바꿀수있음
	
	case when end를 사용하면,레코드를 칼럼으로 변환하거나(99p쿼리참고),
		SUM(CASE WHEN dept_no='d001' THEN emp_count ELSE 0 END) AS count_d001
	하나의 칼럼을 2개이상의 칼럼으로 변환할수있음(100p쿼리참고)
		SUM(CASE WHEN e.hire_date BETWEEN '1980-01-01' AND '1989-12-31' THEN 1 ELSE 0 END) AS cnt_1980
	이걸 with rollup과 같이쓰면 더 쓸만함
	
	
	order by는 정렬할때쓰는데,만약 이게 없다면
		인덱스를 사용하면 인덱스에 정렬된순으로 가져옴
		풀테이블스캔은 프라이머리키 순서대로 가져옴
		임시테이블을 거치면 아무도모름
	이런식으로 출력됨
	보통 정렬이 필요하다면,반드시 명시적으로 orderby를 넣어주는게 좋음,만약 인덱스타면 무시되니까 성능이슈도 글케없음
	근데 인덱스를 못탈경우엔 파일소트를 써야해서 많이 느려질수있으니,인덱스를 만들거나 정렬을 무시해도되면 무시하는방법도 있음
	이 orderby를 쓸때,숫자를 넣으면 해당위치의 칼럼(select절의 순서대로)으로 정렬,문자열을 넣으면 무시됨
	그래서 쌍따옴표를 넣으면 문자열이라서 무시되니까 주의
	
	하나 또는 여러칼럼의 연산결과를 사용해 정렬할수도 있음,이때 함수기반의 인덱스를 사용하면 인덱스도 탈수있음
	
	
	서브쿼리는 서브쿼리를 사용하면 단위처리별로 쿼리를 독립적으로 작성할수있음
	이건 select from where에 보통 사용할수있는데,위치에 따라 쿼리의 성능영햑과 최적화방법이 완전히 달라짐
	
	select절은 별로 신경쓸거없고,인덱스만 사용하는지 보면됨(따로 임시테이블만들거나 그런게없어서)
	그리고 주의해야할건 select절의 서브쿼리는 항상 칼럼과 레코드가 하나인 결과를 반환해야하는데,mysql에선 이거 체크가 좀 느슨함
		쿼리결과가 0이면 null반환
		쿼리결과가 2레코드이상이면 에러
		쿼리결과가 2칼럼이상이면 에러
	이런식임
	그리고 서브쿼리보단 조인이 조금 더 빠르니,가능하면 조인쓰는게 더 좋음
	그리고 래터럴조인을 사용하면,select절에 같은 서브쿼리를 칼럼만 바꿔서 여러번 던질필요없고,한번에 처리할수있음(107p)
	
	from절 서브쿼리는,8.0이전에선 항상 서브쿼리결과를 임시테이블에 저장하고 읽고그랬는데,좀 최적화가 돼서 괜찮아졌음
	서브쿼리를 외부쿼리와 병합하는방식으로 알아서 최적화를 해줌
	이때
		집합함수사용(sum,min,max,count등)
		distinct
		groupby
		limit
		union
		select절 서브쿼리
		사용자변수사용
	을 하면 이렇게 최적화를 못하니 주의해야함
	
	where절 서브쿼리는
		이퀄 or 크다작다비교
		in비교
		not in비교
	3가지로 나눠짐
	
	이퀄비교(대소비교도 동일)는 8.0부터는 서브쿼리를 먼저 돌려서 상수로 바꾸고,그걸가지고 나머지쿼리를 처리함
	단 단일값비교(a_col=(서브쿼리))가 아닌 튜플비교((a_col,bcol)=(서브쿼리))를 하면,
	서브쿼리가 먼저처리되긴하는데 외부쿼리는 인덱스를 사용하지못함
	
	in비교는 5.5이전까진 금기였는데,이후부터는 괜찮아졌음,이떈 세미조인을 사용해서 최적화함
	
	not in비교는 안티세미조인인데,이건 최적화할 방법이 많지않아서 가능하면 피하는게좋음(where에 이거만있으면 풀테이블스캔을 피할수없음)
	
	
	
	cte는 이름있는 임시테이블로,쿼리내에서 한번이상 사용가능하고(재사용가능) 쿼리가 끝나면 자동으로 삭제됨
	이건 재귀여부를 기준으로 non-recurisive와 recurisive로 나눔
	사용방법은 재귀여부에 상관없이
		with cte1 as (select ...) select,delete,update문
	이렇게씀,서브쿼리도 마찬가지로 괄호안에 제일앞에 쓸수있음
	
	cte는 with절로 정의하고,그뒤에 이름을 붙이고 쿼리를 붙이면됨
	이때 여러 임시테이블을 같이사용할수있고,물론 이 cte를 메인쿼리에서 가져다쓸수있고,다른cte에서 가져다쓸수도있음
	즉 임시테이블과 조인하는식으로 쓰면됨,from절 서브쿼리의 친척이라고 생각하면됨
	from서브쿼리에 비해 장점은
		재사용가능
		다른cte에서 참조가능
		임시테이블부분과 사용부분의 코드분리가능
	이라는 장점이 있음
	
	재귀cte는 비재귀적쿼리파트와 재귀적파트로 구분되며,이 둘을 반드시 union all해줘야함
	재귀적파트는 쿼리결과가 없을때까지 반복실행됨
		WITH RECURSIVE cte (no) AS (
			SELECT 1
			UNION ALL
			SELECT (no + 1) FROM cte WHERE no < 5
		)
		SELECT * FROM cte;	
	이런느낌임(WITH RECURSIVE로 시동)
	여기서 select 1이 재귀파트의 입력이고,그걸 where로 걸러서 쿼리결과가 없을때까지 반복하는거임
	이때,재귀를돌떄의 입력값은 바로 직전의 출력값이 그대로 입력됨(레코드 한줄이기만하면 칼럼이 몇개든 상관없음,as로 이름붙여서 가져다쓰면됨)
	
	일단 재귀니까 무한루프 돌수도 있어서,이거 제한기본값이 1000인데 이 기본값은 너무 크고 10으로 낮춰두는게 좋음
	그리고 꼭 필요한 쿼리에선 set_var힌트로 저 숫자를 그 쿼리에서만 변경하는게좋음(121p)
	
	이건 쓰기좋아보이니 나중에 다시한번보자
	
	
	윈도우함수는 현재 레코드를 기준으로,groupby연산같은걸 따로 레코드를 안건드리고 실행함
	즉 레코드는 그대로 출력되는데,거기서 groupby의 값을 가져다붙일수있는거임
	그래서 특정조건별 평균값을 모든 레코드를 보면서,거기다가 붙일수있음
	이 윈도우함수에서 주의할건,
		where,from,groupby,having
		윈도우
		select절,orderby,limit
	순으로 실행된다는거임
	그래서 윈도우함수를 그룹바이칼럼으로 사용할수없고,where절에도 사용할수없음
	그리고 limit를 붙여봐야 효과가 없기때문에,from절을 서브쿼리로 돌리고 그안에서 limit를 걸어야함
	이건
		함수() over(파티션바이 오더바이 프레임) as 별칭
	순으로 사용하면됨(파티션과 오더바이는 생략가능,안넣으면 각 개별레코드로 진행)
	파티션바이는 해당조건으로 묶는다는거,group by와 똑같이 동작(저기서만 쓰일뿐)
	적용순서에서 알수있는거처럼 where로 거른다음에 윈도우가 돌아가니까,테이블전체가 아닌 검색된 결과내에서 윈도우집계가 돌아감
	
	그리고 윈도우함수의 파티션안에서도 연산을 수행할 소그룹을 지정할수있는데 이게 프레임임
	이건 지정하지않으면 알아서 선택하고,명시적으로 지정하면,현재 레코드를 기준으로 어디까지 읽을건지를 정할수있음(앞뒤1개나 전체나 이런느낌)
	묵시적선택의 경우엔 orderby가 있냐없냐에 따라 결과가 달라짐
	그리고 일부 윈도우함수들은 프레임이 고정되어있는데,이때 프레임을 넣으면 무시되고 에러는 안나니까 주의
	
	이 윈도우함수엔 집계함수와 비집계함수가 둘다 있음
	집계함수는 groupby에 쓰는거고,얘들은 over없이 단독으로도 쓸수있고 over넣고 쓸수도있음
	비집계함수는 반드시 over절이 있어야함
	집계함수엔
		count,max,min,sum,avg
	등등이 있고(대표적인거만 적음)
	비집계함수엔
		first_value(파티션의 첫번째값반환),Rank(랭킹반환,갭있음),dense_rank(랭킹반환,갭없음),row_number(파티션내 레코드순번반환)
	등이 있음
	
	rank나 dense_rank나 둘다 orderby기준 순위반환인데,
	rank는 동률등수가 있으면 다음을 한칸미루고(공동1등 2명이면 다음등수 3등)
	dense_rank는 동률등수가 있어도 다음을 미루지않음(공동1등 2명이면 다음등수 2등)
	row_number은 동점에대한 고려없이 그냥 오더바이순서대로 1,2,3적음
	
	이 윈도우함수는 8.0부터 도입됐고,아직 인덱스를 이용한 최적화가 안될때가 있으니 explain해보면서 써야함
	그래서 윈도우함수에 크게 의존하진 않는게 좋지만,어짜피 where로 거르기때문에 잘걸러서 레코드양을 줄일수있으면 걍 써도됨
	
	
	select도 잠글수있는데,for update와 for share로 잠글수있음
	for share는 select로 읽은 쿼리에 대해 읽기잠금(읽기만 가능,쓰기는 불가)을 걸고
	for update는 select로 읽은쿼리에 대해 쓰기잠금(읽기도 불가,쓰기도 불가)을 검
	둘다 트랜잭션이니,자동커밋을 끄고 트랜잭션을 시작해야 잠금이 유지됨
	그리고 서로 for update,for share가 붙은 조회쿼리끼리만 잠금이 먹히고,그냥 저게 없는애들은 잠금무시하고 읽을수있음
	
	그리고 조인을 하거나해서 여러테이블을 건드릴때도 특정 테이블에만 잠금거는거도 가능(141p)
	
	그리고 nowait와 skip locked를 사용하면,
	만약 레코드가 잠겨있을경우 기다리지않고 즉시 실패처리를 하고싶다면 nowait
	해당 레코드를 무시하고 다른레코드들만 읽고싶다면 skip locked
	를 사용할수있음,물론 for update나 for share가 있어야 적용됨,없으면 어짜피 잠금무시하니까 의미없음
		select * from abc for update nowait
	이런식으로 쓰면됨
	
	skip locked를 쓰면 비확정적인 쿼리가 되니까 이건 주의해야함
	이 nowait와 skip locked는,큐를 mysql에서 만들때(선착순쿠폰발급) 유용함
	이때 for update skip_locked limit 1로 다른애가 잠그고있는건 무시하고 다음거를 가져와서 잠그고 이름적는느낌
	이러면 순차처리가(1번트랜잭션 끝나면 2번트랜잭션...끝까지 반복),동시처리가 돼서(서로 다른 레코드를 잠그고있으니) 속도가 올라감
	
	
3.insert
	보통 셀렉트의 성능을 올리면(인덱스추가)인서트의 성능을 떨어짐
	그래도 보통 조회성능이 훨씬 더 중요한경우가 많기때문에 인덱스를 만드는게 합리적임
	
	사실 인서트에서는 특별히 쿼리로 성능을 올릴수있는방법은 없음
	그냥 몇가지 알아두면 편한기능들은 있음
	
	insert ignore는,저장하는 레코드의 프라이머리키나 유니크키가 이미 있을때,해당 레코드를 무시하고 다음레코드를 처리할수 있게 해줌
	이건 보통 여러레코드를 하나의 인서트문장으로 처리할때 유용함
	이건 단순히 유니크의 중복뿐아니라,데이터타입이 일치하지않아서 인서트가 불가능할때도,칼럼의 기본값으로 인서트를 하게 만들기도 함
	즉 낫널에서 널이 들어가면 기본값인 0으로 세팅해서 인서트하는느낌
	이게 발동되면 경고메시지가 뜸,이건 주의해서 사용하는게 좋음
	
	insert ... on duplicate key update는 중복이 발생하면 현재값으로 해당레코드를 업데이트해줌
	즉 인서트 or 업데이트임
	
	인서트의 load data는,데이터를 빠르게 적재할수있지만,단일스레드에 단일트랜잭션이라는 단점이 있음
	그래서 가능하면 인서트를 쪼개서 나눠서 던지는 방식을 취하면 더 효율적으로 던질수있음(프라이머리키 기준으로 자르면됨)
	
	인서트의 성능은 쿼리보다 테이블의 구조의 영향을 많이받음
	보통 소량을 넣는경우가 많기때문
	그리고 데이터가 정렬되어있으면 훨씬 더 저렴하게 넣을수있음
	
	그리고 오토인크리즈먼트를 키로잡으면 이게 가장 빠른 인서트를 보장해줌
	
	
4.update와 delete
	update와 딜리트에 orderby를 넣고 limit를 걸어서 정렬해서 상위몇개만 지우는방식도 가능함
	이건 너무 많은 레코드를 건드려야할때 커넥션을 끊어가면서 가기위해 사용할수있음(과부하방지+언두로그 리셋)
	단 복제소스서버에서 이렇게하면 경고메시지가 뜰수있음(바이너리로그포맷이 row면 상관없는데,statement면 그럴수있음)
	이건 orderby에 의해 정렬되더라도 중복된값의 순서가 복제소스와 원본과 다를수있기때문(프라이머리키나 유니크키 기반이면 상관없겠지만 경고메시지는 뜸)
	
	
	join update는 두개이상의 테이블을 조인해서 결과레코드를 변경 및 삭제하는걸 말함
	보통 조인된 테이블중 특정 테이블의 칼럼값을 다른테이블에 업데이트해야할때 주로 사용됨(프라이머리키가 같은 레코드중 a테이블의값으로 b테이블값을 덮을때)
	혹은 조인되는 양쪽테이블에 공통으로 존재하는 레코드만 찾아서 업데이트할때도 사용할수있음
	
	이건 조인되는 모든테이블에 대해 읽기참조만 되는 테이블은 읽기잠금이,변경이 일어나는 테이블은 쓰기잠금이 걸림
	그래서 데드락확률이 올라가니 너무 자주쓰는건 피하는게 좋지만,통계용 update나 배치프로그램에선 유용하게 쓸수있음
	이 조인업데이트도 조인을 쓰니,드라이빙테이블과 드리븐테이블의 선택에 따라 성능이 바뀜,그래서 explain돌리는게좋음
	
	그리고 조인업데이트에선 그룹바이나 오더바이를 사용할수없음,그래서 서브쿼리를 사용해서 임시테이블을 생성해서 처리해야함
	
	
	여러레코드를 업데이트할때,만약 동일한값으로 업데이트하는게 아닌,변수를 사용한 업데이트도 가능함
	values row()나 row()를사용해서 임시테이블을 생성해서 그걸 참조하는식으로 할수있음(164p)
	
	
	조인딜리트는 조인이 성공한 레코드에 대해 특정테이블에서만 그 레코드들을 삭제하는거임
	즉 조인으로 체인걸어서 외래키로 같은프라이머리키가 있는 c테이블에 특정값이 있다면,a테이블에서 레코드를 삭제하는식
	물론 delete절에 여러개를 적으면,여러테이블도 삭제할수있음
	
	
5.스키마조작	
	8.0부터는 스키마 조작의 많은부분이 온라인처리가 돼서,따른테이블같은걸 따로 잠금을 걸지않고 진행하지만,아직도 락을 잡아야하는애들이 많이있음
	그리고 테이블에서 프라이머리키를 추가하는작업같은건 데이터파일의 재배열이 필요해서 테이블리빌드가 필요함
	단순히 칼럼이름바꾸는 그런건 메타데이터만 바꾸면되니 저런게 필요없고
	이런건 버전별로 차이가 크기때문에,작업하기전에 매뉴얼과 테스트를 해보는게 좋음
	
	온라인처리가 가능한 명령들은 169p참고
	그리고 보통 테이블 리빌드가 필요하고,최종로그적용이 필요해지면 중간과정에서 실패할 확률이 올라감
	그래서 이걸 최대한 줄이는게 좋음
	실패케이스는 
		alter table명령이 장시간 실행되고,동시에 다른커넥셔에서 dml이 많이 실행되거나,온라인변경로그공간이 부족
		alter table명령이 실행되는동안 alter table이후의 테이블구조에 적합하지않은 레코드가 인서트 or 업데이트되면 실패
		스키마변경을 위해 필요한 잠금수준보다 낮은잠금옵션일경우
		lock=none라도 처음과끝은 락이 필요한데,이걸 획득하지못하고 타임아웃걸리면 실패(메타데이터락)
		온라인 인덱스생성의 경우 정렬을위해 temdir에 명시된 경로를 사용해서 정렬하는데,디스크공간부족시 실패
	가 있음	
	모든 alter table명령은,performance_schema를 통해 진행상황을 모니터링할수있음(175p)
	
	
	mysql은 1개이상의 데이터베이스를 가질수있음,mysql에서 스키마와 데이터베이스는 동격의 개념임
	이건 그냥 객체에 대한 권한을 구분하는 용도정도로만 사용됨(그래서 use 데이터베이스명을 서버접속했을때 바로쓰는거)
	
	mysql은 전통적으로 테이블별로 테이블스페이스를 사용했음(각 테이블별 저장공간)
	이걸 제너럴테이블스페이스를 사용하면(8.0부터 가능),여러테이블의 데이터를 한테이블스페이스에 저장할수있음
	이건 여러제약사항이 있긴한데,테이블갯수가 매우많을땐 도움이됨
	중요한건 아닌듯
	
	
	테이블은 사용자데이터를 가지는 주체임
	테이블의 구조를 조회할땐
		show create table 테이블명 //해당테이블을 생성할수있는 쿼리 리턴
		desc 테이블명 //테이블의 메타데이터 리턴,k8s의 describe같은거임,단 인덱스칼럼의 순서나,외래키,테이블자체속성은 보여주지않음
	테이블 구조를 변경할떈,alter table을 사용함
	이건 테이블구조만이 아닌 인덱스 추가삭제와 칼럼추가삭제에서도 사용됨
	테이블단에서 이걸 사용하는건,보통 테이블의 인코딩이나 스토리지엔진,파티션구조등을 변경할때 사용됨
	스토리지엔진은 보통 바꿀일없을거고,인코딩변경은 가끔할일이 생김
	
	테이블명을 변경할떈 
		rename table 원래테이블명 to 바꿀테이블명
		rename table db1.원래테이블명 to db2.바꿀테이블명
	이렇게함,같은 db내에서 변경은 메타데이터만 바꿔서 매우빠른데,다른 db내 변경은 파티션이 보통 다르기떄문에 다 복사붙여넣기해야해서 오래걸림
	그리고 블루그린방식같이 서로 이름을 교체할땐
		rename table a to a_old,a_new to a
	이런식으로 묶어서 처리하면 중간에 a테이블이 비는시간이 안생김(잠금대기만 발생)
	
	테이블의 정보를 볼땐
		show table status like '테이블명'
	으로 할수있음,여기선 전체레코드갯수,레코드평균크기등을 알수있음
	이정보들은 information_schema에 관리되는걸 가져오기때문에,
	저기에 직접 접근해서 mysql의 테이블들이 사용하는 디스크공간정보를 조회할수도있음
	
	데이터는 복사하지않고,테이블의 구조만 동일하게 복사할땐
		create table 새로만들테이블명 like 테이블명
	으로 인덱스까지 완전히 복사할수있음
	데이터까지 복사하려면
		create table 새로만들테이블명 like 테이블명
		insert into 새로만들테이블명 select * from 테이블명
	이 두개를 같이돌리면됨
	테이블 삭제는 drop table을 쓰고,딱히 다른테이블에 영향을 직접적으로 주진않는데
	큰테이블삭제는 부하가 크기때문에 간접적인 영향을 줄수는있음(속도감소)
	
	테이블구조변경은 대부분 칼럼을 추가하거나 칼럼타입을 변경하는 작업임
	가장 마지막에 새칼럼추가
		alter table 테이블명 add column 칼럼명 타입
	이경우엔 그냥 마지막에 넣으면돼서 instant로 즉발추가가 가능함
	근데 중간에 새칼럼을 추가할땐
		alter table 테이블명 add column 칼럼명 타입 after 추가할위치의칼럼명
	이렇게하는데,이경우엔 테이블의 리빌드가 필요해서 오래걸림
	테이블이 크다면 가능하면 마지막에 추가하는게좋음
	
	삭제는 항상 리빌드가 필요함
		alter table 테이블명 drop column 칼럼명
	이름 및 타입을 변경할땐
		alter table 테이블명 change 이전칼럼명 이후칼럼명 타입 속성 //이름변경,속성은 not null같은거 그냥적으면됨
		alter table 테이블명 modify 칼럼명 바꿀타입 속성  //타입변경,varchar길이도 똑같음
	이렇게함
	이떄 이름변경은 즉발,타입변경은 많이느리고 쓰기락,varchar 길이증가는 리빌드할수도있고 안할수도있음,varchar 길이감소는 많이느리고 쓰기락
	varchar이 리빌드 하는 조건은,255(1바이트)이하에서 256~(2바이트이상)으로 늘어날땐 리빌드를 해야하고,그안에서 놀땐 상관없음
	
	
	인덱스변경도 대부분이 온라인ddl임
	b트리인덱스추가는 뭐든 상관없이 inplace에 잠금없이 동작하고,전문인덱스와 공간인덱스는 shared잠금이 필요함
	
	mysql에서 인덱스목록을 조회할땐 
		show index from 테이블명
	을 하면 됨
	여기서
		seq_in_index:인덱스에서 해당칼럼의 위치(2개이상칼럼을쓰는경우를위해)
		cardinality:인덱스에서 해당칼럼까지의 유니크한 값의 갯수(복합칼럼의 경우 해당값까지의 유니크갯수를 보여줌)
	등만 알아두면됨
	그리고 show create table로 쿼리받아보면,여기서도 인덱스 다 나오긴함
	
	인덱스 이름 변경은
		alter table 테이블명 rename index 전인덱스명 to 변경인덱스명
	으로 할수있음
	이건 5.7부터는 메타데이터변경이라 즉발로됨
	
	인덱스 삭제는 즉발로되지만,인덱스를 실수로 삭제했으면 복구는 매우 오래걸릴수도있음
	그래서 삭제를 좀 더 안전하게 하기위해 가시성을 변경하는 옵션도있음
		alter table 테이블명 alter index 인덱스명 invisible
	풀때는 invisible을 visible로 바꾸면됨
	이건 숨길때나 풀때나 즉발로 작동하고,숨기면 해당인덱스가 없는거처럼 작동함
	그래서 삭제전에 몇일 인비지블걸어두고 안전하다싶으면 삭제하면됨
	
	인덱스삭제는
		alter table 테이블명 drop index 인덱스명
	으로 할수있음
	이건 보통은 따로 잠금필요없지만(세컨더리),프라이머리키는 shared잠금이 필요함
	
	
	인덱스 생성을 여러개해야할떈,alter를 여러번날릴수도있지만 묶어서 날리는게 더 빠르게됨(1번만 풀스캔해서 여러개를 생성함)
		alter table 테이블명 add index 인덱스명1(칼럼1),add index 인덱스명2 (칼럼2,칼럼3)
	단 두 변경작업이 서로 다른 알고리즘을 사용하면 어짜피 여러번돌아야해서 의미없음
	
	
	mysql에서 프로세스를 조회할땐
		show processlist
		show full processlist//쿼리 전부표시
	로 할수있고,여기서 현재 실행중인 스레드와 실행중인 쿼리들이 표시됨
	문제상황에서 여기서 시간이 매우길게잡히고,커맨드가 쿼리인 애들을 킬할수있음
	그리고 state가 copying이거나 sorting이 나오면 얘들도 주의해서봐야함
	이때 킬은
		kill query id //해당쿼리종료
		kill id //해당세션종료
	로 할수있음
	이렇게되면 해당 트랜잭션은 롤백처리됨
	
	쿼리뿐아니라 트랜잭션이 오래 활성상태로 남아있는거도 문제가 될수있음
	이 트랜잭션들은 203p쿼리를 복사해서 볼수있음
	이떄 트랜잭션을 종료시키고싶으면 그냥 세션자체를 kill해버리면 바로 트랜잭션이 끝남
		
	
6.쿼리 성능 테스트	
	쿼리를 작성하고나면 일단 explain을 해봐야함
	그리고 특별히 문제될부분이 없으면 직접 실행해보는게 좋음,실행계획으로 안잡히는 문제가 있을수도있으니
	이떄 눈으로만 성능을 보는건 정확하지않음
	
	쿼리성능에 영향을 미치는 요소로는
		운영체제캐시:같은데이터반복이면 캐시를 리턴해줌(단 innodb는 관계없음)
		mysql버퍼풀:mysql단에서 같은데이터반복이면 버퍼에있는값을 리턴함
		다른 프로세스의 시스템자원 점유:다른곳에서 시스템자원쓰고있으면 값이 다르게나올수있음
		쿼리테스트횟수:핫에서 테스트할지 콜드테스트할지도 고려해야함
	같은 변인들을 통제해가면서 테스트를 해야함
	그래도 실제상황보단 좀 빠르게 나오니 이것도 신경써야함(실제상황에선 쿼리들이 여러개실행되며 경합이 일어나니)
	
	

	
12.확장검색
1.전문검색
	전문검색에서의 인덱스생성은,형태소분석과 엔그램 2가지방법이 있음
	형태소분석은 난이도가 높기때문에 보통 엔그램을 사용함(mysql에 엔그램은 내장되어있기도함)
	엔그램을 사용할때,ngram_token_size로 몇글자씩 잘라서 인덱스로 등록할지 정할수있음
	보통 2나 3을 사용함(이때 변경후엔 mysql재시작해야함)
	그리고 전문검색인덱스를 생성할떄 반드시 with parser ngram 옵션을 추가해야만 엔그램토큰을 생성할수있음
	
	이 엔그램은 주의할점은,토큰사이즈보다 작은 글을 검색할수는 없음,즉 2일경우 최소 2글자를 검색해야한다는 제약이생김
	그래서 3보단 2가 더 잘 사용됨
	이걸가지고 검색할때는,검색어를 해당토큰사이즈에 맞는 토큰으로 분할해서,각각의 토큰들을 이퀄로 검색하는식으로 검색함
	
	mysql의 전문검색쿼리는 자연어모드와 불리언모드 두가지가 있고,기본값은 자연어임
	자연어모드는 검색어에 제시된 단어들을 많이 가지고 있는 순서대로 정렬해서 결과를 반환함
	이때는 그냥 자연어를 쿼리에 넣을수있는데,그러면 공백기준으로 분리한다음 엔그램토큰으로 변환해서 검색후 일치율을 계산해서 정렬하는식으로 동작함
	불리언모드는 쿼리에 사용되는 검색어의 존재여부에 대해 논리적연산이 가능함(논문검색)
	
	검색어확장은,쿼리에 사용된 검색어로 검색된결과에서,공통으로 발견되는 단어들을 모아서 한번 더 검색을 수행하는 방식임
	즉 해당 검색어를 고정으로 한 결과에서의 tf계산이라고 보면될듯
	근데 이건 아직 불안정한듯,별로 추천하진않는 늬앙스
	
	이 전문검색인덱스는 어떻게 검색될지 알기 어려운데(값을 가공해서 인덱싱하니),그래서
		set global innodb_ft_aux_table='test/tb_bi_gram';
	을 넣으면 전문검색인덱스가 어떻게 저장,관리되는지를 볼수있게해줌


2.공간검색
	공간좌표는 종이처럼 평면상에 좌표를 투영한 평면좌표계(투영좌표계)와,지구구면까지 계산한 구면좌표계(지리좌표계)로 나뉘어짐
	보통 한 나라수준으로 처리를 하면 그냥 평면좌표계써도되고,좀 글로벌하면 구면좌표계를 사용해야함
	그래서 투영좌표계의 경우 매우 많은 수가 있음(나라마다 있어도되니까)
	
	공간좌표에서 위도경도를 받을때,st_x()로 위도를,st_y()로 경도를 받을수있음
	두 점 사이의 거리를 계산할떈
		select ST_Distance(ST_PointFromText('point(0 0'),0),ST_PointFromText('point(1 1'),0)
	이렇게 하면됨,ST_PointFromText의 첫번쨰는 좌표,두번째는 사용할 공간좌표계의 id값임
	만약 평면좌표계일경우 단순하게 피타고라스로 계산한값을 돌려주고,구면좌표계일경우 실제 미터로 값을 돌려줌
	보통 넣지않으면 평면좌표계라고 계산함
	
	추가적으로 st_가 붙은 함수와 안붙은함수가 있는데,st_가 붙은게 표준이니 얘들만쓰면됨
	테이블을 만들때 좌표를 넣을땐,좌표와 srid도 같이 넣어줘야함,그러면 srid가 다른게 들어오면 튕겨낼수있음
	물론 저걸 명시하지않으면 다 받아먹을수있지만,명시적이어야 인덱스를 사용할수있음
	
	그리고 평면이 아닌 구면체상의 두 점간의 거리를 계산할땐 ST_Distance_sphere()를 사용할수있음
	
	공간인덱스를 생성할떄,해당칼럼들은 전부 not null이어야함
	그리고 특정위치를 기준으로,반경 nkm안의 데이터를 검색할땐 st_distance_sphere를 사용하게되는데,이건 인덱스를 타지못함
	그래서 mbr을 통한,st_within함수를 사용해야함
	이건 해당 원을 감싸는 가장 작은 사각형을 만들고,그안에서 검색하는거임(248p참고)




13.파티션
1.개요
	파티션은 테이블이 너무커서 인덱스의 크기가 물리적인 메모리의 크기보다 커지거나,주기적인 데이터삭제작업이 필요할경우 유용함(로그)
	인덱스는 보통 select에 사용하지만,업데이트나 딜리트처리를 위해서도 검색을 해야해서 필요함
	그래서 인덱스를 사용해야할때 메모리보다 인덱스가 크면,인덱스를 쪼개서 메모리에 넣으면 스왑을 안해도돼서 빨라지는데,이때 사용되는게 파티션임
	또한,활발하게 이용되는부분과 아닌부분을 나눌수있다면 이것도 도움이됨(쓸데없는걸 메모리에 안가져와도됨)
	
	이런 파티션은 로그를 관리할때 제일 효과적임
	대량의 데이터가 단기간에 누적되고,시간이 지나면 쓸모없어지는 특성때문에,시간을 키로 파티셔닝을 해두고,오래된 파티션을 통째로 버리는식의 운용이 가능해짐
	이러면 따로 백업,삭제작업을 고부하로 할필요도 없고 좋음
	
	이 파티션이 있는테이블에 인서트는,그냥 파티션조건보고 넣으면되고
	업데이트는 파티션키업데이트와 그외업데이트로 나눠짐
	파티션키 업데이트는 해당파티션에서 해당레코드를 삭제하고,다시 인서트하는식으로 하고
	그외 업데이트는 그냥 고쳐적음
	
	가장 중요한 select에선
		where의 조건으로 검색할파티션을 선택할수있는가?
		where의 조건이 인덱스를 효율적으로 레인지스캔할수있는가?
	에 영향을 받음
	두번째는 항상 중요한거고,첫번째가 파티셔닝을 하면 추가적으로 생기는 조건임
	파티션테이블에선 첫번째에 의해 두번째 선택사항의 작업내용이 달라질수있기때문임
	이떄
		파티션선택가능+레인지스캔:최상효율
		파티션선택불가+레인지스캔:모든파티션대상으로 각각 레인지스캔후 병합
		파티션선택가능+풀스캔:해당파티션대상으로 풀스캔
		파티션선택불가+풀스캔:최악
	3번과 4번은 가능하면 피하는게 좋고,2번은 파티션의 갯수가 많을때는 주의해야함

	파티션테이블의 인덱스는 모두 로컬인덱스임
	모든 인덱스는 파티션단위로 생성되고,전파티션 통합의 인덱스는 지원하지않음
	그래서 파티션되지않은 테이블에선 인덱스를 순서대로읽으면 그 칼럼정렬된 결과를 바로얻을수있지만,파티션테이블은 그렇지않음
	그래서 레인지스캔에서 여러파티션을 읽어야할때,원칙상으론 정렬이 안된결과를 줘야하지만,우선순위큐에 담아서 임시로 저장하는식으로 땜빵을 침
	그래서 직접 정렬만큼은 아니라도 추가비용이 발생함
	
	파티션테이블을 접근할때,접근할필요가 없다고 판단되는 파티션엔 옵티마이저는 접근하지않음
	이렇게 필요한 파티션을 골라내는걸 파티션프루닝이라고 함
	이걸 통해 옵티마이저가 어떤 파티션에만 접근하는지 알수있음(explain에서도 나옴)

2.주의사항
	파티션엔 제약사항들이 있음(태생적인 제약사항)
		스토어드루틴이나 사용자 변수등을 파티션표현식에 사용할수없음
		파티션표현식은 칼럼이나 mysql내장함수를 사용할수있는데,일부함수는 파티션생성은 되는데 프루닝은 안돼서 주의해야함
		프라이머리키를 포함한 모든 유니크 인덱스는 파티션키칼럼을 포함해야함
		파티션테이블의 인덱스는 모두 로컬인덱스이고,모든 파티션은 같은구조의 인덱스만 가질수있음(특정파티션용 인덱스생성불가)
		동일테이블의 모든 파티션은 같은 스토리지엔진을 사용해야함
		파티션테이블은 외래키 사용불가
		전문검색인덱스생성이나 전문검색쿼리 사용불가
		공간데이터저장불가
		임시테이블은 파티션사용불가
	가장 중요한건 모든 유니크인덱스는 파티션키 칼럼을 포함해야한다는것
	즉 date를 기반으로 파티셔닝을 하면,프라이머리키에 id와 date 다중칼럼인덱스가 무조건 강제된다는것임
	각 유니크키에 대해 값이 주어졌을때 해당 레코드가 어느파티션에 저장됐는지를 계산할수 있어야하기때문

3.파티션의 종류
	파티션은 파티션키를 지정하는 방식에 따라 여러가지로 나뉘는데,가장 중요한건 레인지파티션임
	이게 가장 일반적으로 사용됨
	이건 파티션키의 연속된 범위(날짜같은)로 파티션을 정의하는데,
	이건 다른 파티션방법과 달리 maxvalue키워드를 사용해 명시되지않은 범위의 키값이 담긴 레코드를 저장하는 파티션을 정의할수있음
	
	이 레인지파티션은,
		날짜를 기반으로 누적되고,날짜를 기반으로 분석 및 삭제를 해야할때(로그)
		범위기반으로 데이터를 여러파티션에 균등하게 나눌수있을때
		파티션키 위주로 검색이 자주 사용될떄
	유용함
	파티션의 장점은
		큰 테이블을 작은파티션여러개로 분리
		필요한파티션만 접근(읽기쓰기 모두)
	두가지인데,이중 두번째가 특히 중요함
	이 두가지 장점을 로그파티션테이블의 경우 다 챙기기가 쉬움
	그래서 보통 파티션쓰는거도 로그가 많은편
	그래서 레인지파티션만 알아둬도 파티션 80퍼는 넘어감
	
	레인지파티션 생성은
		create table ...
		
		...
		partition by range(year(날짜칼럼명))(
			partition p0 values less than (1991)
			partition p1 values less than (1996)
			partition p2 values less than (2001)
			partition p3 values less than (maxvalue)
		)
	이런식으로 생성함
	마지막엔 맥스밸류를 넣어서 그이후꺼 다 거기다 박다가,좀 커졌다싶으면 나중에 나누는식임
	
	파티션을 추가할땐
		alter table 테이블명
		add partition (partion p4 values less than (2011))
	이렇게하면됨,주의할건 maxvalue를 사용했을경우 에러가나는데(이미 저장된애들은 그파티션에 있으니 파티션유일원칙이 깨짐),maxvalue를 사용했을땐
		alter table 테이블명
		reoganize partition p3 into(
		partion p3 values less than (2011),
		partion p4 values less than maxvalue,
		}
	이렇게 reoganize를 사용해서 maxvalue파티션을 분할하는느낌으로 해야함
	이작업은 오래걸려서,그냥 처음에 파티션을 만들떄,미래에 사용될 파티션을 2~3개 정도 더 만들어두는형태로 테이블을 생성하기도함
	그리고 배치스크립트돌려서 파티션을 자동으로 추가하는형태
	그리고 해당 파티션의 데이터가 없다면,reoganize를 해도 o(1)로 처리되므로,
	좀 미래거를 몇개 잡아두고,하나 꺼내쓸떄마다 maxvalue를 분할하는식으로 처리해도됨
	
	파티션삭제는 drop partition을 사용하면됨
	이건 o(1)에 가깝게 처리됨(그냥 파일을 버리는거니까)
	이때 주의할건,가장 오래된 파티션 순서대로만 삭제할수있음
	즉 가장 오래된 파티션만 삭제할수있음
	
	그리고 reoganize를 사용하면,기존 중간에있던 파티션도 분할할수있음(maxvalue말고도 분리가 가능)
	이건 안에 데이터양에 따라 시간이 오래걸릴수도있고,해당시간동안 쓰기가 불가능해지니 조심
	그리고 reoganize를 사용해서 여러파티션을 하나로 병합할수도있음
		alter table 테이블명
		reoganize partition p2,p3 into(
		partion p23 values less than (2011),		
		}		
	이런식
	
	
	리스트 파티션은 레인지파티션과 비슷하게돌아가지만,여기는 파티션 키값의 범위가 아닌 키 값 하나하나가 다 파티션임
	그래서 maxvalue를 사용할수없음
	이걸 사용할때는
		파티션키값이 코드값이나 카테고리처럼 고정적일때
		키값이 연속되지않고 정렬순서와 상관없이 파티션을 해야할때
		파티션 키값을 기준으로 레코드건수가 균일하고 검색조건에 파티션키가 자주 사용될떄
	사용됨
	사용법은 281p참고,잘 사용되진않을듯,추가장점으로는,리스트라서 int가 아닌 string형태도 리스트파티션을 사용할수있음
	
	해시파티션은 해시함수의 결과로 레코드저장파티션을 지정함
	그래서 int형태의 키만 사용가능
	이건
		레인지파티션이나 리스트파티션으로 데이터균등분배가 어려울때
		모든 레코드가 비슷한 사용빈도를 가지지만,테이블이 너무 커서 파티션을 적용해야할때
	사용됨
	그래서 보통 회원테이블같은곳에 사용됨
	얘는 특성상 
		특정파티션만 삭제하는게 불가능(해시결과에 따라 분배되니 지울필요도없고 지워도안됨)
		새파티션을 추가할땐 모든데이터의 재배치가 필요
		보통 파티션의 조작과 특성과 많이 달라서 주의가 필요
	라는 특성이 있음 

	키파티션은 해시파티션과 거의같은데,해시함수대신 직접 해당 키결정함수를 넣는것,그래서 특성도 같음
	리니어 해시 및 리니어 키 파티션은,해시파티션과 키파티션에서 새파티션추가나 통합해서 개수를 줄일때,전체재분배가 필요한걸 좀 줄이기위해 나옴
	이걸사용하면 좀 더 효율적인 통합및 분배가 가능해짐(전체가 아닌 명시된 두개에 대해서만 작업이 가능함)
	단점으론,균등성이 좀 떨어져서,해시나 키파티션으로 충분하다면(파티션조정요건이 거의없다면),그거쓰는게나음
	
	
	파티션테이블에서 쿼리를 실행할때,모든파티션을 읽어야할지 특정파티션만 읽어도될지는 성능에 큰 영향을 미침
	즉 파티션프루닝을 할수있냐없냐는 매우 중요하고,이때 얼마나 프루닝할수있냐없냐가 핵심임
	보통 레인지파티션이나 리스트파티션은 파티션수가 적고(파티션명을 명시해야해서),해시나 키파티션은 매우많음(명시안해도돼서)
	프루닝을 할수없다면,파티셔닝이 되지않았다면 매우 효율적이었을 쿼리가 매우 비효율적이 되니(각 파티션마다 해당쿼리를 실행해야해서)
	테이블을 10개로 파티셔닝했을때 1~3개만 주로 읽고쓴다면 파티션이 좋지만,파티션된 10개를 균등하게 사용하면 오버헤드만 심해질수있음
	이경우엔 파티션이 아닌 샤딩을 해야함,파티션과 샤딩은 다른거임
	즉 파티션을 적용할떈,프루닝을 얼마나 할수있을지를 예측해보고,테스트한다음 적용해야함
	그리고 레인지파티션을 로그에 적용할때 말고는,파티션 쓰는거 자체를 좀 많이 고민해봐야함


14.스토어드 프로그램
1.문법
	그 프로시저라고 부르는 그거맞음 사람들이 혐오하는거
	실제로 db단에서 연산을 하는거다보니 선호되진않는듯
	db단에서 세밀한 권한제어나 해당영역의 추상화를 할수있지만,일단 성능이 낮고,db가 보통 병목인데 여기다가 추가하는게 맞냐는 근본적인 문제가있음
	어짜피 안쓸거같으니 대충 읽을수만 있을정도로 하자
	
	일단 프로시저를 돌릴때 296p를 보고 세팅을 해야함
	그리고 프로시저나 함수이름과 (사이에 모든 공백을 제거해야함
	
	스토어드 프로시저는 서로 데이터를 주고받아야하는 여러쿼리를 하나의 그룹으로 묶어서 독립적으로 실행하기위해 사용함
	즉 첫쿼리의 결과로 두번째쿼리를 실행해야할때 이럴떄 사용함
	스토어드프로시저는
		create procedure 프로시저명 (in파람,out파람)
		프로시저본문
	이렇게 구성됨,in파라미터로 값이 들어오고 아웃파라미터로 값이 출력됨
	즉 기본 반환값이 없고,파라미터를 사용해서 받아가야함
	이걸 실행할땐 call명령어로 실행해야하고,아웃파라미터를 받을 세션변수를 생성해서 넣어줘야함
	
	그리고 따로 커서를 파라미터로 전달받거나 반환할수없음
	하지만 프로시저내에서 커서를 오픈하지않거나 셀렉트의 결과를 페치하지않으면 해당쿼리결과셋은 클라로 바로 전송됨(출력을 안하면 해당쿼리가 아웃으로 나감)
	이걸통해 2개이상의 결과셋을 반환할수도있음
	
	
	스토어드함수는 하나의 sql쿼리로 작성이 불가능한 기능을 하나의 sql쿼리로 구현할떄 사용함
	예를들어 부서별로 가장 최근에 추가된 사원2명씩을 가져오는경우같을떄 사용함
	이건 반환값이 있고(return)반드시 반환값과 타입을 명시해야함
	그리고 결과셋을 리턴하지못함
	이 스토어드함수는 call이 아닌 select를 통해 실행할수있음
		select 함수명(매개변수)
	
	트리거는 테이블의 레코드가 저장,변경될때 미리 정의해둔작업을 자동으로 실행해주는데,잘사용하진않음
	이벤트는 특정시간에 스토어드프로그램을 실행시켜줌,즉 리눅스의 크론탭같은거임
	
	스토어드프로그램의 상세작성법은 317p참고

2.보안옵션
	8.0부터는 스토어드프로그램별로 권한을 설정할수있음
	만약 스토어드프로그램사용하는데 실행이 안되거나 할경우 343p참고해보면됨
	sql security옵션관련 문제때문에 실행이 안될수있음
	왜냐면,해당 스토어드프로그램을 실행할권한+각각 sql테이블의 권한을 둘다 가지고있어야하기때문
	
	그리고 추가적으로 deterministic와 non deterministic옵션도 있는데,이거 둘중에 하나를 선택해야함
	이건 입력이 같을때 결과를 확정적으로 낼거냐,시점에따라 결과를 달라지게 낼거냐임
	이게 non deterministic이면 호출시점에 해당sql을 실행하고,deterministic이면 만들때 한번 실행해서 값을 캐싱해두고,그값을 계속 리턴함
	그리고 non deterministic이면 풀스캔을 유도하는데,이게 디폴트라서  deterministic으로 바꾸는게좋음(상황따라 매번계산해야할수도있지만)
3.참고사항
	스토어드프로그램의 소스에 한글을 쓰면 깨지는경우가 있는데,이건 접속한 클라프로그램이 어떤 인코딩을 쓰냐에따라 달라짐 347p참고
	스토어드프로그램에서 declare를 사용해 로컬변수를 정의할수있음,이게 세션변수(전역변수)보다 안전함
	재귀호출을 할떄 스택의 최대수치는 max_sp_recursion_depth로 설정할수있음
	중첩루프안에서 2개이상의 커서를 열어야하면 예외핸들링에 주의



15.데이터타입












	
	
	