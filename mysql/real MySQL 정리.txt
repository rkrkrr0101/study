1.소개
	생략
2.설치와 설정
	설치버전은 가능한 최신버전에서 15~20릴리즈 버전을 선택(즉 최신-1이나 최신이 ~20넘기면 최신선택)
	연결은 
		mysql -uroot -p 패스워드 --host=ip입력 --port=3306
	이렇게
	
	버전업데이트는,한버전만 업데이트할거면 그냥 업데이트를 하고(인플레이스 업그레이드),
	두버전이상 뛰어야하면 mysqldump등으로 덤프뜬다음에 걍 새로깔고 다시 덮는게좋음(논리적 업그레이드)
	
	서버설정은,리눅스는 my.cnf,윈도우는 my.ini를 사용함
	현재읽고있는 파일의 위치는
		mysqld --verbose --help
	로 알수있음(앞에서부터 우선순위)
	
	설정파일은,각 []구역마다 각각의 응용프로그램이고,기본적으론 자기영역만 읽음(가끔 2개이상,즉 남의영역도 읽는애들도있음 보통 코어쪽읽음)
	mysql의 서버는,켜지면서 설정파일을 읽어 메모리에 저장해둠(시스템변수)
	이건
		show global variables
	로 볼수있음
	이건 또 글로벌변수와 세션변수로 나뉘고,
		cmd-line:cmd창에서 변경가능한지
		option file:my.ini로 제어가능한지
		system var:시스템변수인지 아닌지
		var scope:시스템변수의 적용범위,즉 전역인지 세션인지 둘다인지
		dynamic:변경시 다시 껐다켜야하는지
	같은 속성들이 있음	
		
	글로벌과 세션은 적용범위에 따라 나뉘는데,일반적으로 세션별로 적용되는 시스템변수의 경우 글로벌뿐아니라 세션변수에도 동시에 존재함
	이경우 both로 표시됨
	보통 세션변수가 시스템에 있는건,세션이 접속할때 기본값을 적어둔거,이걸 바꿔서 세션쪽에서 접근할수있게하는거임(autocommit같은거)
	
	동적변수일경우 set으로 변경하면 즉시적용되지만,my.ini에 저장되진않음,그래서 set persist로 해야 my.ini를 수정해서 영구적으로 적용됨
	그리고 이렇게 변경한 기록은 performance_schema.persisted_variables테이블에 남으니 확인할수있음
	그리고 아예 리셋하고싶으면 
		reset persist
	하면됨
		
		
3.사용자 및 권한		
	mysql에서의 계정은,단순한 아이디뿐 아니라 해당 사용자가 어느 ip에서 접속했는지까지 체크하고,해당 ip영역중 가장 좁은 영역으로 인식하게됨
	즉, abc라는 아이디와 192.168.0.1이라는 ip가 있으면,이 둘을 묶어서 아이디처럼 사용하는것(물론 ip에서 와일드카드사용가능)
	이거때문에 조심해야할건,같은아이디가 다른ip대역으로 있는데,서로 패스워드가 다르다면 접근에 문제가 생길수있음
	
	mysql 8.0부터 계정은 system_user권한을 가지고있냐에 따라 시스템계정과 일반계정으로 구분됨
	시스템계정은 계정관리(계정생성삭제,권한부여제거),다른세션의 쿼리 강제종료,혹은 세션종료,스토어드프로그램 생성시 definer을 타사용자로 설정등을 할수있음
	그리고
		mysql.sys@localhost
		mysql.session@localhost
		mysql.infoschema@localhost
	이 3개는 mysql이 사용하는계정이니 지우면안됨(보통 지우기도힘듬)
	
	그리고 8.0부터는 grant로 계정생성하면서 권한부여가 안되니,
		create user abc
		grant 권한명 on 객체대상 to abc //객체
		grant 권한명 on *.* to abc //글로벌
	이렇게 생성하고 권한부여를 해줘야함
	글로벌은 항상 대상자리에 *.*이 들어감,이건 서버전체를 의미,그래서 객체권한을 이렇게넣으면 서버전체적용
	
	아이디 생성시엔 56p참고해서 옵션들을 붙일수있음
	대충
		identified with:인증방식과 비밀번호설정(기본적으론 identified by '비밀번호' 쓰면됨)
	이게 메인이고,비밀번호의 유효기간과 변경강제 이런것들 있음
	그리고 비밀번호의 글자조합강제와 금칙어설정들도 가능함
	
	그리고 비밀번호를 2개설정하는거도 가능한데,이거로 응용프로그램서버들이 비밀번호를 db서버와 동시에 바꾸지않아도 되게 할수있음(순차적으로 수정)
	
	그리고 권한은,글로벌권한과 객체단위의 권한으로 나뉘는데(상세는 65p참조)
	db나 테이블 이외에서 사용하는건 글로벌권한,db나 테이블제어에 필요한권한을 객체권한이라고 함
	글로벌권한을 부여할땐 특정 객체가 나오면 안되고,객체권한을 부여할땐 반드시 특정객체가 나와야함
	예외적으로 all은 두가지용도로 다 사용될수있는데,객체에 all하면 해당객체의 모든권한,글로벌 all은 글로벌수준 모든권한을 부여함
	추가적으로 8.0부터는 동적권한도 추가됐는데,이건 서버가 시작되면서 동적으로 생성되는 권한임
	
	테이블의 특정 칼럼에 대해서만 권한을 줄수도있는데 이건 책보자(보통잘안씀)
	
	8.0부터는 권한을 묶어서 역할(role)로 만들수있음,그 k8s나 aws나 있던 그거랑 똑같음 권한들의 집합을 편하게쓰는거
		create role abcRole,bcdRole
		grant 권한명 on *.* to abcRole
		grant abcRole To abc
		set role 'abcRole'
	이렇게 똑같이 주면됨
	이때 주의할점은,반드시 set role로 롤을 활성화시켜야됨,그리고 이 롤은 계정이 로그아웃됐다 다시로그인하면 다시 활성화가 풀림
	그래서 이걸 영구적용하려면
		SET GLOBAL activate_all_roles_on_login=ON;
	이 옵션을 켜둬야함
	
	그리고 롤과 계정은 구분하기힘드므로(내부적으론 같은거로 취급함),롤에는 role_같은걸 붙여두는게좋음
	
4.아키텍쳐
1.엔진아키텍쳐
	mysql서버는 머리역할의 mysql엔진과 손발역할의 스토리지엔진으로 구성됨
	여기서 스토리지엔진이 그 innoDB같은 그런분류임
	
	mysql엔진은 sql파서,sql옵티마이저,캐시&버퍼등을 하고,얘들이 만들어주면 그걸 스토리지엔진이 디스크와 상호작용해서 파일로 넣고읽고하는거
	즉 데이터를 디스크에 저장하거나 읽거나 하는건 스토리지엔진이 하는일임
	이 스토리지엔진은 테이블별로 다르게설정할수있음
	
	mysql엔진의 쿼리실행기에서 데이터를 쓰거나 읽어야할때는 각 스토리지엔진에 쓰기 또는 읽기를 요청하는데,이런걸 핸들러요청이라 하고,
	여기서 사용되는 api를 핸들러api라고 함
	스토리지엔진도 이 핸들러api를 통해 mysql엔진과 데이터를 주고받음
	이 핸들러api를 통해,얼마나 많은 데이터작업이 있었는지를
		show global status like 'handler%'
	로 알수있음
	
	mysql은 프로세스기반이 아닌 스레드기반으로 작동하며,포그라운드와 백그라운드로 나뉘는데 거의 백그라운드임
	그중 같은이름으로 2개이상있는건 병렬처리하는거
	포그라운드 스레드는 최소한 mysql서버에 접속된 클라의 수만큼 존재하고,얘들은 각 클라가 요청하는 쿼리문장을 처리함
	클라가 커넥션을 종료하면 스레드는 스레드캐시로 돌아가게됨(갯수설정가능)
	
	innoDB에서는
		인서트버퍼 병합스레드
		로그 디스크기록 스레드
		버퍼풀데이터 디스크기록 스레드
		데이터를 버퍼로부터 읽는 스레드
		잠금 or 데드락 모니터링 스레드
	들은 다 백그라운드로 처리됨,이중에서 로그스레드와 버퍼풀데이터 기록스레드가 가장 중요하고,얘들의 갯수를 2개이상으로 설정할수있음
	db의 작업중 쓰기작업은 버퍼처리해서 일괄처리할수있지만,읽기작업은 반드시 즉발로 동작해야함
	innoDB에서는 자동으로 인서트 업데이트 딜리트는 버퍼를 사용해서 동작함
	
	메모리는 그냥 시스템변수에다 적어둔만큼만 할당받는다고 생각하면됨(각 운영체제마다 다른데 이게 디폴트임)
	이중 글로벌영역은 무조건 그만큼 존재하고,로컬영역은 할당된영역안에서 켜졌다꺼졌다하면서 변동이 있지만 선은 안넘음
	로컬영역은 절대 공유되어 사용되지않고,최악의경우 서버가 멈출수도 있으니,적절한 메모리크기를 선택해야함
	
	mysql의 독특한 구조가 플러그인임,즉 무언가를 설치해서 부가기능을 추가할수있음
	인증,전문검색파서,쿼리재작성등의 플러그인이 있고,비밀번호검증 커넥션제어등도 있음
	그리고 이 플러그인을 8.0부터는 단점을 보완한 컴포넌트로 바꿨음
	그래서
		플러그인끼리 통신불가
		캡슐화안됨
		플러그인끼리 상호의존불가
	등이 고쳐짐
	
	컴포넌트는
		install component '경로 or 파일경로'
		select * from mysql.component
	로 설치하고 확인할수있음
	
	우리가 mysql에 쿼리를 날리면,
		쿼리파서(쿼리를 토큰으로 분리해 트리형태구조를 만들어냄,여기서 문법적오류가 있으면 오류를 돌려줌)
		전처리기(쿼리의 구조적 문제가 있는지 확인,즉 문법이 아닌 해당객체가 없다거나 하는 오류를 돌려줌)
		옵티마이저(쿼리변환->비용최적화->실행계획수립,가장중요한거)
		쿼리실행기(핸들러)
		스토리지엔진(실제 일을 하는대상)
	순으로 동작함
	
	쿼리캐시는 8.0에서 삭제됨,여러 문제때문에 사용하기 힘들었음
	스레드풀은 엔터프라이즈버전에서만 기능을 제공함,그리고 성능향상을 잘 보여주지도않음
	그리고 8.0부터는 테이블의 구조정보나 스토어드프로그램의 코드관련정보,인증과 권한관련들을 innoDB의 테이블에 저장해서(시스템테이블)
	트랜잭션을 지원해 비정상종료시에도 깨지는일을 없앴음
	이건 mysql.ibd라는 테이블스페이스에 저장되는데,이건 특별히 조심해야함(ibd는 다 조심해야함)

2.innodb	
	mysql스토리지엔진중에선 innodb를 가장 많이 사용함
	이건 유일하게 레코드기반 잠금을 제공해서 높은 동시성처리가 가능함
	
	이노디비는 프라이머리키를 기준으로 클러스터링됨,즉 레코드의 주소가 아닌,프라이머리키값을 논리주소로 사용함
	그래서 프라이머리키를 이용한 레인지스캔은 빨리처리가 됨(실행계획에서의 비중도 높음)
	그리고 추가적으로 외래키지원도 스토리지레벨로 처리해줌
	단,이때 외래키가 있으면 부모자식 양쪽테이블 다 해당컬럼에 인덱스를 생성해야하고,
	변경시엔 반드시 부모테이블이나 자식테이블에 데이터가 있는지 체크하는 작업이 필요해서 잠금이 여러테이블로 전파되고,데드락확률이 올라서 주의해야함
	
	수동으로 데이터적재하거나 스키마변경등 관리작업이 실패했는데 만약 급해서 외래키관계체크를 끄고싶으면
		set session foreign_key_checks=off
	시스템변수를 off로 설정하면 일단 끌수있음,이때 세션으로 꺼야함,안그러면 딴테이블도 영향을 미치니까(일단 session을 빼도 기본값으로 세션이긴함)
	물론 불꺼지고 난다음엔 바로 관계성체크하고 다시켜야함(관계깨진상태로 두면안됨)
	그리고 이걸끄면 캐스케이드도 꺼지니 주의
	
	그리고 mvcc를 지원하는데,이건 잠금을 사용하지않는 일관된 읽기를 제공함
	이노디비는 언두로그를 사용해서 이 기능을 구현함
	이때 멀티버전은 하나의 레코드에 대해 여러버전이 동시에 관리된다는것
	이 mvcc덕에 격리수준에 따라 다르지만,일반적인 격리수준에서는 트랜잭션이 끝나지않았는데 해당레코드 변경기록이 있으면,
	언두로그를 참고해서 셀렉트결과를 리턴함
	이렇게 격리수준에 따른 여러 버전을 레코드단위로 지원하는게 mvcc
	
	이거덕에 읽기작업은 다른트랜잭션이 가진 잠금을 기다리지않고 읽기가 가능함(serializable제외하고)
	즉 해당레코드가 트랜잭션으로 변경당했으면,언두로그를 타고 다음레코드로 넘어가는식
	그리고 이런게 있더라도,트랜잭션은 시작했으면 가능한 빨리 롤백이나 커밋을 해야함
	
	이노디비는 잠금이 교착상태에 빠지지않았는지 체크하기위해,잠금대기목록을 그래프로 가지고있고,
	데드락감지스레드가 주기적으로 이목록을 순회해 교착이 없는지확인함
	이때 교착이 있으면,언두로그가 적은쪽을 날려버림
	그리고 이노디비는 기본값으로는 mysql엔진의 테이블잠금은 볼수없어서(lock tables명령을 잠긴테이블)저쪽은 못건드리는데,
	특별한 이유가 없다면 innodb_table_locks를 활성화해서 볼수있게 하는게좋음
	이 데드락감지도 부담되면
		innodb_deadlock_detect
	를 끄고
		innodb_lock_wait_timeout
	를 숫자를 50보다 훨씬 낮은값으로 잡아서 그냥 일정시간이상 잠금을 획득하지못하면 날려버리는식으로 구성할수도있음
	
	이노디비는 얘가 데이터파일을 손상시키거나,서버를 시작못하게 하는일은 거의없음
	근데 다른이슈로(디스크가 물리적으로 구멍났다던가)시작못할경우는 있음,이경우엔 자동으로 복구를 진행함
	근데 복구를 해야하는데 복구가 실패할경우 자동종료됨
	이때는,복구작업을 취소하고 켜야하는데,설정파일에서
		innodb_force_recovery
	를 1부터 6까지 1씩 올려가면서 켜보면됨,높을수록 복구가능성이 낮음(일단 로그파일손상이면 6,테이블데이터파일손상이면 1)
	그리고 켜졌으면,mysqldump로 데이터를 가능한만큼 백업하고,그데이터로 db와 테이블을 다시생성하는게 좋음
	1부터 6까지 상세내역은 책 106p참고
	6에서도 안켜지면,백업을 이용해 다시서버만드는방법밖에 없음
	
	이노디비에서의 가장 핵심은,버퍼풀임
	이건 디스크의 데이터파일이나 인덱스정보를 메모리에 캐시해두는 공간임
	여기서 쓰기작업의 버퍼도 같이 처리를함
	이 버퍼풀의 크기설정은,전체가 8기가면 4기가,50기가이상이면 30기가정도를 잡고 조금씩 올려가면됨(물론 뭐 더켜두냐에 따라 케바케임)
	
	이 버퍼풀은 lru와 mru를 섞은방식으로 작동함
	즉 마지막에 썼으면 나이가 0,나이를 일정이상 넘기면 삭제,거기서 자주쓴거는 따로 즐겨찾기에 등록하는식임
	이 버퍼풀은 크면클수록 쿼리성능이 올라감(데이터캐시),이때도 쓰기버퍼링은 향상되지않는데,클린페이지와 더티페이지를 알아야함
	클린페이지는 디스크에서 읽은 그대로의 상태,더티페이지는 거기서 인서트업데이트딜리트가 작동한상태
	이 더티페이지를 무한정 가지고있을순 없고,고정크기의 파일을 계속 밀어내는방식으로 작동함
	이러다가 데이터가 날아갈쯤되면 그걸 한번에 덮어서 버퍼링을 끝내는것
	이 버퍼풀과 리두로그공간은 서로에게 적절한크기로 설정되어야함,리두로그크기가 너무크면 쓰기과부하가 걸릴수있고,버퍼풀이 너무크면 버퍼효과가 없음
	보통 버퍼풀이 100기가이하면 5~10gb의 리두로그파일크기를 잡고 필요할때마다 조금씩 늘려가는게 좋음
	물론 8.0가면서 쓰기과부하는 많이 줄어서 크게 신경안써도된다고는 함
	
	그리고 버퍼에 담긴거에 따라 쿼리성능도 달라지니,컴껐다키면 버퍼초기화돼서 엄청 느려질수있음,그래서 버퍼를 백업시켜두고 켜질때 복구할수있는데
		innodb_buffer_pool_load_now
	에서 버퍼풀상태를 다시 복구할수있음
	그리고
		innodb_buffer_pool_dump_at_shutdown
		innodb_buffer_pool_load_at_startup
	를 설정파일에 추가해서 자동화할수도있음
	그리고 8.0부터는
		information_schema.innodb_cached_indexes
	테이블을 select해서,각 테이블의 인덱스별로 데이터페이지가 얼마나 버퍼풀에 적재된지도 볼수있음
	
	이노디비의 리두로그는,공간낭비를 막기위해 페이지의 변경된 내용만기록함
	그래서 더티페이지를 디스크파일로 플러시할때 일부만 기록되면 페이지내용을 복구하기 어려워질수있어서,더블라이트기법을 사용함
	이건 각 페이지들을 랜덤하게 중간중간에 기록해서,전체가 다 기록되거나 파일이 깨지거나 둘중 하나만 하고,파일이 꺠지면 롤백하는방법임
	근데 이건 hdd면 켜둘만한데,ssd면 끄는게 나음,부담스러움(물론 데이터무결성이 매우중요하면 켜두는게맞음)
		innodb_doublewrite
	로 키고끌수있음
	
	스토리지엔진은 트랜잭션과 격리수준을 보장하기위해 변경이전데이터를 별도로 백업하는데,이게 언두로그임
	이걸사용해서 트랜잭션롤백을 하고,격리수준에 따라 여길읽고지나가게함(트랜잭션커밋이 안됐을때)
	이건 매우 중요하긴한데 비용도 비쌈
	
	트랜잭션이 여러개일때는,한두개가 커밋이 되더라도 전부 커밋이나 롤백이 되기전까진 언두로그가 삭제되지않음
	그래서 트랜잭션이 오래유지되면 안되는것
	
	rdbms에서 레코드가 인서트되거나 업데이트되면,데이터뿐이 아닌 인덱스도 업데이트해야함
	근데 이 인덱스업데이트는 랜덤io라서 비용이 비쌈
	그래서 보통 그 페이지가 버퍼풀에 있으면 즉시처리하지만,없다면 버퍼에 모아뒀다 한번에처리하는데,이걸 체인지버퍼라고 함
	이때,유니크인덱스의 경우엔 반드시 확인해야하니 체인지버퍼를 사용할수없음
	
	
	리두로그는 acid중 d,즉 영속성과 가장 밀접하게 연관되어있음
	하드웨어나 소프트웨어등 여러 문제점으로 인해 서버가 비정상종료되었을때도 데이터파일에 기록하지못한 데이터를 잃지않게해줌
	이건 먼저 데이터변경내용을 로그에 기록한뒤에 실제 데이터에 기록하는루틴으로 처리함
	이때 비정상종료시엔
		커밋됐지만 데이터파일에 기록되지않은 데이터(그냥 리두로그로 다시덮으면됨)
		롤백됐지만 데이터파일에 이미 기록된 데이터(그냥 언두로그로 다시 덮으면됨)
	이때 2번도,변경이 일어났는지 아닌지는 확인해야하니까 리두로그의 존재는 확인을 해야함
	
	그리고 8.0부터는 리두로그를 아카이빙할수있는 기능이 추가됨,이건 필요해지면 책찾아보자
	그리고 리두로그를 비활성화하는 기능도 추가됐는데,이건 데이터를 복구하거나,대용량데이터를 한꺼번에 적재할때 잠시 비활성화할수있음
	이떈 반드시 작업이 끝나면 다시 켜야함,아니면 문제생겼을때 복구불가능해짐(데이터가 중요하지않더라도 시점은 맞춰야하니까 필수임)
	
	어댑티브 해시 인덱스란,사용자가 자주 접근하는 데이터에 대해 자동으로 스토리지엔진이 생성하는 인덱스임
	이건 innodb_adaptive_hash_index로 끄고켤수있음
	이걸통해 자주 읽히는 데이터페이지의 키값을 자기알아서 저장해서,속도를 올릴수있음
	이 어댑티브 해시 인덱스는,버퍼풀에 올려진 데이터페이지에 대해서만 관리되고,
	버퍼풀에서 해당데이터페이지가 없어지면 이 어댑티브인덱스에서도 해당페이지정보는 사라짐
	
	이 어댑티스 해시인덱스는,디스크읽기가 많거나,특정패턴쿼리가 많거나,매우큰데이터를 가진 테이블레코드를 폭넓게 읽을경우가 많으면,
	성능향상에 도움이 안돼는데 메모리는 차지해서 끄는경우도 많음(삭제성능도 떨어짐)
	반대로 도움이 될때는,디스크데이터가 버퍼풀크기와 비슷할경우(읽기가 많지않을경우),동등비교와 in연산자가 많을경우,쿼리가 일부데이터에만 집중될경우
	에는 성능이 많이 올라감
	
	이렇게 이 어댑티브 해시인덱스가 도움이 되는지 아닌지는
		HOW ENGINE INNODB STATUS\G
	로 검색해서 INSERT BUFFER AND ADAPTIVE HASH INDEX를 확인해서 얼마나 탔는지를 확인할수있음
	이 비율과,cpu사용률이 높다면 켜두는게 낫고 낮다면 꺼두는게나음
	
	
	보통 8.0부터는 innodb만 사용하고,myisam같은건 사용하지않음



3.myisam엔진
	생략
4.mysql 로그파일



















































		
		
		
		
		
		
		
	