1.소개
	생략
2.설치와 설정
	설치버전은 가능한 최신버전에서 15~20릴리즈 버전을 선택(즉 최신-1이나 최신이 ~20넘기면 최신선택)
	연결은 
		mysql -uroot -p 패스워드 --host=ip입력 --port=3306
	이렇게
	
	버전업데이트는,한버전만 업데이트할거면 그냥 업데이트를 하고(인플레이스 업그레이드),
	두버전이상 뛰어야하면 mysqldump등으로 덤프뜬다음에 걍 새로깔고 다시 덮는게좋음(논리적 업그레이드)
	
	서버설정은,리눅스는 my.cnf,윈도우는 my.ini를 사용함
	현재읽고있는 파일의 위치는
		mysqld --verbose --help
	로 알수있음(앞에서부터 우선순위)
	
	설정파일은,각 []구역마다 각각의 응용프로그램이고,기본적으론 자기영역만 읽음(가끔 2개이상,즉 남의영역도 읽는애들도있음 보통 코어쪽읽음)
	mysql의 서버는,켜지면서 설정파일을 읽어 메모리에 저장해둠(시스템변수)
	이건
		show global variables
	로 볼수있음
	이건 또 글로벌변수와 세션변수로 나뉘고,
		cmd-line:cmd창에서 변경가능한지
		option file:my.ini로 제어가능한지
		system var:시스템변수인지 아닌지
		var scope:시스템변수의 적용범위,즉 전역인지 세션인지 둘다인지
		dynamic:변경시 다시 껐다켜야하는지
	같은 속성들이 있음	
		
	글로벌과 세션은 적용범위에 따라 나뉘는데,일반적으로 세션별로 적용되는 시스템변수의 경우 글로벌뿐아니라 세션변수에도 동시에 존재함
	이경우 both로 표시됨
	보통 세션변수가 시스템에 있는건,세션이 접속할때 기본값을 적어둔거,이걸 바꿔서 세션쪽에서 접근할수있게하는거임(autocommit같은거)
	
	동적변수일경우 set으로 변경하면 즉시적용되지만,my.ini에 저장되진않음,그래서 set persist로 해야 my.ini를 수정해서 영구적으로 적용됨
	그리고 이렇게 변경한 기록은 performance_schema.persisted_variables테이블에 남으니 확인할수있음
	그리고 아예 리셋하고싶으면 
		reset persist
	하면됨
		
		
3.사용자 및 권한		
	mysql에서의 계정은,단순한 아이디뿐 아니라 해당 사용자가 어느 ip에서 접속했는지까지 체크하고,해당 ip영역중 가장 좁은 영역으로 인식하게됨
	즉, abc라는 아이디와 192.168.0.1이라는 ip가 있으면,이 둘을 묶어서 아이디처럼 사용하는것(물론 ip에서 와일드카드사용가능)
	이거때문에 조심해야할건,같은아이디가 다른ip대역으로 있는데,서로 패스워드가 다르다면 접근에 문제가 생길수있음
	
	mysql 8.0부터 계정은 system_user권한을 가지고있냐에 따라 시스템계정과 일반계정으로 구분됨
	시스템계정은 계정관리(계정생성삭제,권한부여제거),다른세션의 쿼리 강제종료,혹은 세션종료,스토어드프로그램 생성시 definer을 타사용자로 설정등을 할수있음
	그리고
		mysql.sys@localhost
		mysql.session@localhost
		mysql.infoschema@localhost
	이 3개는 mysql이 사용하는계정이니 지우면안됨(보통 지우기도힘듬)
	
	그리고 8.0부터는 grant로 계정생성하면서 권한부여가 안되니,
		create user abc
		grant 권한명 on 객체대상 to abc //객체
		grant 권한명 on *.* to abc //글로벌
	이렇게 생성하고 권한부여를 해줘야함
	글로벌은 항상 대상자리에 *.*이 들어감,이건 서버전체를 의미,그래서 객체권한을 이렇게넣으면 서버전체적용
	
	아이디 생성시엔 56p참고해서 옵션들을 붙일수있음
	대충
		identified with:인증방식과 비밀번호설정(기본적으론 identified by '비밀번호' 쓰면됨)
	이게 메인이고,비밀번호의 유효기간과 변경강제 이런것들 있음
	그리고 비밀번호의 글자조합강제와 금칙어설정들도 가능함
	
	그리고 비밀번호를 2개설정하는거도 가능한데,이거로 응용프로그램서버들이 비밀번호를 db서버와 동시에 바꾸지않아도 되게 할수있음(순차적으로 수정)
	
	그리고 권한은,글로벌권한과 객체단위의 권한으로 나뉘는데(상세는 65p참조)
	db나 테이블 이외에서 사용하는건 글로벌권한,db나 테이블제어에 필요한권한을 객체권한이라고 함
	글로벌권한을 부여할땐 특정 객체가 나오면 안되고,객체권한을 부여할땐 반드시 특정객체가 나와야함
	예외적으로 all은 두가지용도로 다 사용될수있는데,객체에 all하면 해당객체의 모든권한,글로벌 all은 글로벌수준 모든권한을 부여함
	추가적으로 8.0부터는 동적권한도 추가됐는데,이건 서버가 시작되면서 동적으로 생성되는 권한임
	
	테이블의 특정 칼럼에 대해서만 권한을 줄수도있는데 이건 책보자(보통잘안씀)
	
	8.0부터는 권한을 묶어서 역할(role)로 만들수있음,그 k8s나 aws나 있던 그거랑 똑같음 권한들의 집합을 편하게쓰는거
		create role abcRole,bcdRole
		grant 권한명 on *.* to abcRole
		grant abcRole To abc
		set role 'abcRole'
	이렇게 똑같이 주면됨
	이때 주의할점은,반드시 set role로 롤을 활성화시켜야됨,그리고 이 롤은 계정이 로그아웃됐다 다시로그인하면 다시 활성화가 풀림
	그래서 이걸 영구적용하려면
		SET GLOBAL activate_all_roles_on_login=ON;
	이 옵션을 켜둬야함
	
	그리고 롤과 계정은 구분하기힘드므로(내부적으론 같은거로 취급함),롤에는 role_같은걸 붙여두는게좋음
	
4.아키텍쳐
1.엔진아키텍쳐
	mysql서버는 머리역할의 mysql엔진과 손발역할의 스토리지엔진으로 구성됨
	여기서 스토리지엔진이 그 innoDB같은 그런분류임
	
	mysql엔진은 sql파서,sql옵티마이저,캐시&버퍼등을 하고,얘들이 만들어주면 그걸 스토리지엔진이 디스크와 상호작용해서 파일로 넣고읽고하는거
	즉 데이터를 디스크에 저장하거나 읽거나 하는건 스토리지엔진이 하는일임
	이 스토리지엔진은 테이블별로 다르게설정할수있음
	
	mysql엔진의 쿼리실행기에서 데이터를 쓰거나 읽어야할때는 각 스토리지엔진에 쓰기 또는 읽기를 요청하는데,이런걸 핸들러요청이라 하고,
	여기서 사용되는 api를 핸들러api라고 함
	스토리지엔진도 이 핸들러api를 통해 mysql엔진과 데이터를 주고받음
	이 핸들러api를 통해,얼마나 많은 데이터작업이 있었는지를
		show global status like 'handler%'
	로 알수있음
	
	mysql은 프로세스기반이 아닌 스레드기반으로 작동하며,포그라운드와 백그라운드로 나뉘는데 거의 백그라운드임
	그중 같은이름으로 2개이상있는건 병렬처리하는거
	포그라운드 스레드는 최소한 mysql서버에 접속된 클라의 수만큼 존재하고,얘들은 각 클라가 요청하는 쿼리문장을 처리함
	클라가 커넥션을 종료하면 스레드는 스레드캐시로 돌아가게됨(갯수설정가능)
	
	innoDB에서는
		인서트버퍼 병합스레드
		로그 디스크기록 스레드
		버퍼풀데이터 디스크기록 스레드
		데이터를 버퍼로부터 읽는 스레드
		잠금 or 데드락 모니터링 스레드
	들은 다 백그라운드로 처리됨,이중에서 로그스레드와 버퍼풀데이터 기록스레드가 가장 중요하고,얘들의 갯수를 2개이상으로 설정할수있음
	db의 작업중 쓰기작업은 버퍼처리해서 일괄처리할수있지만,읽기작업은 반드시 즉발로 동작해야함
	innoDB에서는 자동으로 인서트 업데이트 딜리트는 버퍼를 사용해서 동작함
	
	메모리는 그냥 시스템변수에다 적어둔만큼만 할당받는다고 생각하면됨(각 운영체제마다 다른데 이게 디폴트임)
	이중 글로벌영역은 무조건 그만큼 존재하고,로컬영역은 할당된영역안에서 켜졌다꺼졌다하면서 변동이 있지만 선은 안넘음
	로컬영역은 절대 공유되어 사용되지않고,최악의경우 서버가 멈출수도 있으니,적절한 메모리크기를 선택해야함
	
	mysql의 독특한 구조가 플러그인임,즉 무언가를 설치해서 부가기능을 추가할수있음
	인증,전문검색파서,쿼리재작성등의 플러그인이 있고,비밀번호검증 커넥션제어등도 있음
	그리고 이 플러그인을 8.0부터는 단점을 보완한 컴포넌트로 바꿨음
	그래서
		플러그인끼리 통신불가
		캡슐화안됨
		플러그인끼리 상호의존불가
	등이 고쳐짐
	
	컴포넌트는
		install component '경로 or 파일경로'
		select * from mysql.component
	로 설치하고 확인할수있음
	
	우리가 mysql에 쿼리를 날리면,
		쿼리파서(쿼리를 토큰으로 분리해 트리형태구조를 만들어냄,여기서 문법적오류가 있으면 오류를 돌려줌)
		전처리기(쿼리의 구조적 문제가 있는지 확인,즉 문법이 아닌 해당객체가 없다거나 하는 오류를 돌려줌)
		옵티마이저(쿼리변환->비용최적화->실행계획수립,가장중요한거)
		쿼리실행기(핸들러)
		스토리지엔진(실제 일을 하는대상)
	순으로 동작함
	
	쿼리캐시는 8.0에서 삭제됨,여러 문제때문에 사용하기 힘들었음
	스레드풀은 엔터프라이즈버전에서만 기능을 제공함,그리고 성능향상을 잘 보여주지도않음
	그리고 8.0부터는 테이블의 구조정보나 스토어드프로그램의 코드관련정보,인증과 권한관련들을 innoDB의 테이블에 저장해서(시스템테이블)
	트랜잭션을 지원해 비정상종료시에도 깨지는일을 없앴음
	이건 mysql.ibd라는 테이블스페이스에 저장되는데,이건 특별히 조심해야함(ibd는 다 조심해야함)

2.innodb	
	mysql스토리지엔진중에선 innodb를 가장 많이 사용함
	이건 유일하게 레코드기반 잠금을 제공해서 높은 동시성처리가 가능함
	
	이노디비는 프라이머리키를 기준으로 클러스터링됨,즉 레코드의 주소가 아닌,프라이머리키값을 논리주소로 사용함
	그래서 프라이머리키를 이용한 레인지스캔은 빨리처리가 됨(실행계획에서의 비중도 높음)
	그리고 추가적으로 외래키지원도 스토리지레벨로 처리해줌
	단,이때 외래키가 있으면 부모자식 양쪽테이블 다 해당컬럼에 인덱스를 생성해야하고,
	변경시엔 반드시 부모테이블이나 자식테이블에 데이터가 있는지 체크하는 작업이 필요해서 잠금이 여러테이블로 전파되고,데드락확률이 올라서 주의해야함
	
	수동으로 데이터적재하거나 스키마변경등 관리작업이 실패했는데 만약 급해서 외래키관계체크를 끄고싶으면
		set session foreign_key_checks=off
	시스템변수를 off로 설정하면 일단 끌수있음,이때 세션으로 꺼야함,안그러면 딴테이블도 영향을 미치니까(일단 session을 빼도 기본값으로 세션이긴함)
	물론 불꺼지고 난다음엔 바로 관계성체크하고 다시켜야함(관계깨진상태로 두면안됨)
	그리고 이걸끄면 캐스케이드도 꺼지니 주의
	
	그리고 mvcc를 지원하는데,이건 잠금을 사용하지않는 일관된 읽기를 제공함
	이노디비는 언두로그를 사용해서 이 기능을 구현함
	이때 멀티버전은 하나의 레코드에 대해 여러버전이 동시에 관리된다는것
	이 mvcc덕에 격리수준에 따라 다르지만,일반적인 격리수준에서는 트랜잭션이 끝나지않았는데 해당레코드 변경기록이 있으면,
	언두로그를 참고해서 셀렉트결과를 리턴함
	이렇게 격리수준에 따른 여러 버전을 레코드단위로 지원하는게 mvcc
	
	이거덕에 읽기작업은 다른트랜잭션이 가진 잠금을 기다리지않고 읽기가 가능함(serializable제외하고)
	즉 해당레코드가 트랜잭션으로 변경당했으면,언두로그를 타고 다음레코드로 넘어가는식
	그리고 이런게 있더라도,트랜잭션은 시작했으면 가능한 빨리 롤백이나 커밋을 해야함
	
	이노디비는 잠금이 교착상태에 빠지지않았는지 체크하기위해,잠금대기목록을 그래프로 가지고있고,
	데드락감지스레드가 주기적으로 이목록을 순회해 교착이 없는지확인함
	이때 교착이 있으면,언두로그가 적은쪽을 날려버림
	그리고 이노디비는 기본값으로는 mysql엔진의 테이블잠금은 볼수없어서(lock tables명령을 잠긴테이블)저쪽은 못건드리는데,
	특별한 이유가 없다면 innodb_table_locks를 활성화해서 볼수있게 하는게좋음
	이 데드락감지도 부담되면
		innodb_deadlock_detect
	를 끄고
		innodb_lock_wait_timeout
	를 숫자를 50보다 훨씬 낮은값으로 잡아서 그냥 일정시간이상 잠금을 획득하지못하면 날려버리는식으로 구성할수도있음
	
	이노디비는 얘가 데이터파일을 손상시키거나,서버를 시작못하게 하는일은 거의없음
	근데 다른이슈로(디스크가 물리적으로 구멍났다던가)시작못할경우는 있음,이경우엔 자동으로 복구를 진행함
	근데 복구를 해야하는데 복구가 실패할경우 자동종료됨
	이때는,복구작업을 취소하고 켜야하는데,설정파일에서
		innodb_force_recovery
	를 1부터 6까지 1씩 올려가면서 켜보면됨,높을수록 복구가능성이 낮음(일단 로그파일손상이면 6,테이블데이터파일손상이면 1)
	그리고 켜졌으면,mysqldump로 데이터를 가능한만큼 백업하고,그데이터로 db와 테이블을 다시생성하는게 좋음
	1부터 6까지 상세내역은 책 106p참고
	6에서도 안켜지면,백업을 이용해 다시서버만드는방법밖에 없음
	
	이노디비에서의 가장 핵심은,버퍼풀임
	이건 디스크의 데이터파일이나 인덱스정보를 메모리에 캐시해두는 공간임
	여기서 쓰기작업의 버퍼도 같이 처리를함
	이 버퍼풀의 크기설정은,전체가 8기가면 4기가,50기가이상이면 30기가정도를 잡고 조금씩 올려가면됨(물론 뭐 더켜두냐에 따라 케바케임)
	
	이 버퍼풀은 lru와 mru를 섞은방식으로 작동함
	즉 마지막에 썼으면 나이가 0,나이를 일정이상 넘기면 삭제,거기서 자주쓴거는 따로 즐겨찾기에 등록하는식임
	이 버퍼풀은 크면클수록 쿼리성능이 올라감(데이터캐시),이때도 쓰기버퍼링은 향상되지않는데,클린페이지와 더티페이지를 알아야함
	클린페이지는 디스크에서 읽은 그대로의 상태,더티페이지는 거기서 인서트업데이트딜리트가 작동한상태
	이 더티페이지를 무한정 가지고있을순 없고,고정크기의 파일을 계속 밀어내는방식으로 작동함
	이러다가 데이터가 날아갈쯤되면 그걸 한번에 덮어서 버퍼링을 끝내는것
	이 버퍼풀과 리두로그공간은 서로에게 적절한크기로 설정되어야함,리두로그크기가 너무크면 쓰기과부하가 걸릴수있고,버퍼풀이 너무크면 버퍼효과가 없음
	보통 버퍼풀이 100기가이하면 5~10gb의 리두로그파일크기를 잡고 필요할때마다 조금씩 늘려가는게 좋음
	물론 8.0가면서 쓰기과부하는 많이 줄어서 크게 신경안써도된다고는 함
	
	그리고 버퍼에 담긴거에 따라 쿼리성능도 달라지니,컴껐다키면 버퍼초기화돼서 엄청 느려질수있음,그래서 버퍼를 백업시켜두고 켜질때 복구할수있는데
		innodb_buffer_pool_load_now
	에서 버퍼풀상태를 다시 복구할수있음
	그리고
		innodb_buffer_pool_dump_at_shutdown
		innodb_buffer_pool_load_at_startup
	를 설정파일에 추가해서 자동화할수도있음
	그리고 8.0부터는
		information_schema.innodb_cached_indexes
	테이블을 select해서,각 테이블의 인덱스별로 데이터페이지가 얼마나 버퍼풀에 적재된지도 볼수있음
	
	이노디비의 리두로그는,공간낭비를 막기위해 페이지의 변경된 내용만기록함
	그래서 더티페이지를 디스크파일로 플러시할때 일부만 기록되면 페이지내용을 복구하기 어려워질수있어서,더블라이트기법을 사용함
	이건 각 페이지들을 랜덤하게 중간중간에 기록해서,전체가 다 기록되거나 파일이 깨지거나 둘중 하나만 하고,파일이 꺠지면 롤백하는방법임
	근데 이건 hdd면 켜둘만한데,ssd면 끄는게 나음,부담스러움(물론 데이터무결성이 매우중요하면 켜두는게맞음)
		innodb_doublewrite
	로 키고끌수있음
	
	스토리지엔진은 트랜잭션과 격리수준을 보장하기위해 변경이전데이터를 별도로 백업하는데,이게 언두로그임
	이걸사용해서 트랜잭션롤백을 하고,격리수준에 따라 여길읽고지나가게함(트랜잭션커밋이 안됐을때)
	이건 매우 중요하긴한데 비용도 비쌈
	
	트랜잭션이 여러개일때는,한두개가 커밋이 되더라도 전부 커밋이나 롤백이 되기전까진 언두로그가 삭제되지않음
	그래서 트랜잭션이 오래유지되면 안되는것
	
	rdbms에서 레코드가 인서트되거나 업데이트되면,데이터뿐이 아닌 인덱스도 업데이트해야함
	근데 이 인덱스업데이트는 랜덤io라서 비용이 비쌈
	그래서 보통 그 페이지가 버퍼풀에 있으면 즉시처리하지만,없다면 버퍼에 모아뒀다 한번에처리하는데,이걸 체인지버퍼라고 함
	이때,유니크인덱스의 경우엔 반드시 확인해야하니 체인지버퍼를 사용할수없음
	
	
	리두로그는 acid중 d,즉 영속성과 가장 밀접하게 연관되어있음
	하드웨어나 소프트웨어등 여러 문제점으로 인해 서버가 비정상종료되었을때도 데이터파일에 기록하지못한 데이터를 잃지않게해줌
	이건 먼저 데이터변경내용을 로그에 기록한뒤에 실제 데이터에 기록하는루틴으로 처리함
	이때 비정상종료시엔
		커밋됐지만 데이터파일에 기록되지않은 데이터(그냥 리두로그로 다시덮으면됨)
		롤백됐지만 데이터파일에 이미 기록된 데이터(그냥 언두로그로 다시 덮으면됨)
	이때 2번도,변경이 일어났는지 아닌지는 확인해야하니까 리두로그의 존재는 확인을 해야함
	
	그리고 8.0부터는 리두로그를 아카이빙할수있는 기능이 추가됨,이건 필요해지면 책찾아보자
	그리고 리두로그를 비활성화하는 기능도 추가됐는데,이건 데이터를 복구하거나,대용량데이터를 한꺼번에 적재할때 잠시 비활성화할수있음
	이떈 반드시 작업이 끝나면 다시 켜야함,아니면 문제생겼을때 복구불가능해짐(데이터가 중요하지않더라도 시점은 맞춰야하니까 필수임)
	
	어댑티브 해시 인덱스란,사용자가 자주 접근하는 데이터에 대해 자동으로 스토리지엔진이 생성하는 인덱스임
	이건 innodb_adaptive_hash_index로 끄고켤수있음
	이걸통해 자주 읽히는 데이터페이지의 키값을 자기알아서 저장해서,속도를 올릴수있음
	이 어댑티브 해시 인덱스는,버퍼풀에 올려진 데이터페이지에 대해서만 관리되고,
	버퍼풀에서 해당데이터페이지가 없어지면 이 어댑티브인덱스에서도 해당페이지정보는 사라짐
	
	이 어댑티스 해시인덱스는,디스크읽기가 많거나,특정패턴쿼리가 많거나,매우큰데이터를 가진 테이블레코드를 폭넓게 읽을경우가 많으면,
	성능향상에 도움이 안돼는데 메모리는 차지해서 끄는경우도 많음(삭제성능도 떨어짐)
	반대로 도움이 될때는,디스크데이터가 버퍼풀크기와 비슷할경우(읽기가 많지않을경우),동등비교와 in연산자가 많을경우,쿼리가 일부데이터에만 집중될경우
	에는 성능이 많이 올라감
	
	이렇게 이 어댑티브 해시인덱스가 도움이 되는지 아닌지는
		HOW ENGINE INNODB STATUS\G
	로 검색해서 INSERT BUFFER AND ADAPTIVE HASH INDEX를 확인해서 얼마나 탔는지를 확인할수있음
	이 비율과,cpu사용률이 높다면 켜두는게 낫고 낮다면 꺼두는게나음
	
	
	보통 8.0부터는 innodb만 사용하고,myisam같은건 사용하지않음



3.myisam엔진
	생략
4.mysql 로그파일
	문제가 생겼을때 가장 지식없이 처리하기 편한방법이 로그파일보는거임
	일단 mysql에 문제가 생기면 로그파일보는게 제일빠름
	
	에러로그파일의 위치는,my.cnf에서 log_error이라는 이름을 검색하면 나오는 경로에 있음
	확장자는 .err
	
	mysql의 설정을 변경했을때
	만약 서버가 정상적으로 기동되고(mysqld:ready for connections 메시지 확인),
	새로 변경한 파라미터에 특별한 에러나 경고메시지가 없으면 정상적용된거
	그렇지않고 특정변수가 ignore되면 서버는 켜졌지만 파라미터적용은 안된거(오타확인)
	변수명을 인식못했으면 에러띄우고 시작이 안됨
	
	마지막종료가 비정상종료시엔 복구가 성공하면 간단한메시지띄우고,실패하면 에러메시지띄우고 종료됨
	이경우엔 그 복구옵션 0부터 6까지 올려봐야함
	
	쿼리에러도 일단 저기에 로그로 기록되니,가끔 보면 도움됨
	
	비정상종료커넥션(aborted connection)도 저기 남는데,이게 많으면 클라쪽 커넥션종료루틴을 확인해봐야함
	그리고 맥스커넥션이 낮으면 host 호스트명 is blocked에러가 발생하는데,이건 max_connect_errors변수값을 증가시키면됨
	
	innodb의 테이블모니터링이나 락모니터링,엔진상태조회는 상대적으로 큰메시지를 에러로그에 남기는데,
	그래서 모니터링을 활성화해두고 안끄면 하드 다잡아먹을수도있으니까 모니터링쓰고나면 꺼야함
	
	그리고 아무도모르게 mysql이 종료되거나,재시작되었을때 원인을 파악하는 방법은 에러로그에서 
		Received shutdown from user ...
	을 검색하면됨
	만약 이게없고 16진수 주소값이 잔뜩 나오고 이러면 세그먼테이션폴트로 비정상종료된거니까 버전업을 하던가 해야함
	
	그리고 에러가 아닌 서버에서 실행되는 쿼리들이 뭐가있는지 목록을 뽑을수도있는데,이땐 쿼리로그를 활성화해서 기록한다음 그파일을 분석하면됨
	이건 시간단위로 쿼리내용이 기록됨(쿼리에러가나도 일단 기록함)
	이건 general_log_file에 설정되어있고,파일이 아닌 테이블에 기록하게할수도있음(log_output파라미터)
	
	그리고 슬로우쿼리로그를 기록할수도있음
	이건 long_query_time파라미터의 시간을 넘긴 쿼리가 모두 기록됨(이건 반드시 성공해야남음)
	
	이런 슬로우쿼리로그나 제너럴로그파일 보기가 힘들면,
	percona toolkit의 pt-query-digest스크립트를 이용하면 쉽게 빈도나 처리성능별로 쿼리를 정렬해서 살펴볼수있음(4.4.3.1참조)






5.트랜잭션과 잠금
1.트랜잭션
	myisam에서는 트랜잭션이 없어서 부분업데이트가 발생해버려서 안쓰고,innodb를 사용함
	트랜잭션은 dbms의 커넥션과 마찬가지로 꼭 필요한 최소의 코드에만 적용하고,트랜잭션로직안에 연산같은게 들어가는건 최대한막아야함
	그리고 외부통신로직이 트랜잭션안에 들어가있는건 금기임
	차라리 트랜잭션을 2번으로 나눠서 처리하는게나음 가능하다면
2.mysql 엔진의 잠금	
	mysql의 잠금은 스토리지엔진레벨과 mysql엔진레벨로 나눌수있음
	글로벌락은 mysql의 잠금중 가장 범위가 큼
	일단 한 세션에서 글로벌락을 획득하면,다른세션에서 셀렉트를 제외한 모든쿼리가 대기상태로 남음
	이거의 영향범위는 서버전체이고,작업대상테이블이나 db가 달라도 전부영향을 미침
	이건 mysqldump를 사용할때 사용됐는데,요즘은 잘안씀,백업락이 있기때문
	
	8.0부터는 좀 더 가벼운 백업락이 생겼음(innoDB가 디폴트돼서 가능)
	이건 획득하면 모든세션에서 테이블의 스키마나 사용자인증관련정보를 변경할수없어지지만,테이블의 데이터변경은 가능함
	즉 즉 한번 쫙 복사하고,트랜잭션걸렸던거들중 커밋된거 다시엎어서 백업본을 만드는식인듯

	테이블락은 테이블단위로 설정되는 락임
	이거도 앱단에선 사용할일 거의없고,묵시적으로는 데이터변경될때 자동으로 걸고 커밋하는식으로 알아서 사용해줌
	
	네임드락은,임의의 문자열에 대해 락을걸수있는데,잘 사용되진않음
	보통 여러대의 웹서버가 동기화해야할때나 이럴때 사용됨
	그리고 배치프로그램에서,동일데이터를 변경하거나 참조하는 프로그램끼리 네임드락을 걸고 쿼리를 돌리면 데드락위험성을 줄일수있음
	
	메타데이터락은 db객체의 이름이나 구조를 변경할때 획득하는 잠금임
	이건 따로 명시적으로 획득하거나 해제할순없고,테이블이름 바꿀때같을때 자동으로 알아서함

3.innoDB 스토리지 엔진 잠금
	이노디비는 mysql의 잠금과 별개로 스토리지엔진 내부에서 레코드기반의 잠금방식을 탑재하고있음
	그래서 동시성처리가 뛰어난대,대신 잠금에대한 정보에 접근하긴 까다로움
	그래도 8.0들어와서는 많이 편해졌음
	information_schema데이터베이스의 
		INNODB_TRX
		INNODB_LOCKS
		INNODB_LOCK_WAITS
	테이블을 조인해서 조회하면,해당잠금을 어떤트랜잭션이 가지고있고,얼마나 잠겨있었는지도 확인할수있음
	
	이노디비에서는 레코드락이 페이지락,테이블락으로 레벨업되는경우는 없음
	근데 레코드사이의 간격을 잠그는 갭락이라는게 존재함(인덱스기준으로 인덱스와 다음인덱스 사이에 들어가는게 가능한걸 잠그는것)
	
	레코드락은,레코드 자체를 잠그는게 아닌,인덱스의 레코드를 잠금
	인덱스를 하나도 없게만들어도 내부적으로 자동생성된 클러스터인덱스를 이용해 잠금을 설정함
	
	이노디비에서 대부분 보조인덱스를 이용한 변경은 넥스트키락이나 갭락을 사용하지만,
	프라이머리키나 유니크인덱스를 통한 변경은 갭락을 걸지않고 레코드자체에 대해서만 락을 검
	
	갭락은 레코드를 잠그는게 아닌 레코드와 바로 인접한 레코드사이를 잠그는것,즉 그 사이에 인서트가 들어오는걸 제어하는것임
	이건 이 자체로쓰기보단,넥스트키락의 일부로 자주 사용됨
	
	넥스트키락은 statement타입의 바이너리로그를 사용하는 서버에서는(8.0기본값) repeatable Read에서 사용되는데,
	이건 바이너리로그에 기록되는 쿼리가 레플리카 서버에서 실행될때 소스서버에서 만들어낸 결과와 동일한 결과를 만들어내도록 보장하는게 주 목적임
	근데 이거로 인한 데드락이(갭락포함) 자주 발생해서,가능하면 바이너리로그 포맷을 row타입으로 바꿔서 넥스트키락이나 갭락을 줄이는게 좋음
	
	자동증가락은 Auto_Increment를 켰을때,두 인서트가 동시에 실행될까봐 있는거,이건 단순하게 다음 숫자를 가져오고 나면 바로 풀림
	이건 그래서 명시적으로 획득하고 해제할수없고,신경안써도됨
	
	
	innoDB의 잠금과 인덱스는 상당히 중요한 관계가 있음,일단 락이라는건 인덱스를 잠그는거고 업데이트치려고 검색한 인덱스레코드는 전부 락이 걸려야함
	즉,인덱스를 타지 못한 조건은 무시되고 인덱스에 락이걸리게됨
	즉,해당 업데이트문(조건1,2)을 셀렉트쳐서 나온결과가 1개라고 해도,그 조건들중 인덱스가 없는 컬럼이 있다면 무시됨
		조건1은 인덱스
		조건2는 인덱스없음
		조건1 검색->250개
		조건1+2검색 ->1개
		조건1+2로 업데이트->250개 인덱스락
	그래서 인덱스가 없는 where조건이 들어가면 엄청 비효율적이 되버림
	그래서 mysql의 인덱스설계가 중요한거
		
	
	레코드잠금은 테이블잠금보단 복잡하고,그 레코드가 자주 사용되지않으면 오래잠겨있어도 찾기힘듬
	그래서 8.0와선 현재 잠겨있는 레코드를 확인할수있음(물론 서버재부팅하면 다 잠금풀림)
		performance_schema의 data_locks
		performance_schema의 data_lock_waits
	로 확인할수있음(174p참조)
		SELECT
		r.trx_id waiting_trx_id,
		r.trx_mysql_thread_id waiting_thread,
		r.trx_query waiting_query,
		b.trx_id blocking_trx_id,
		b.trx_mysql_thread_id blocking_thread,
		b.trx_query blocking_query
		FROM performance_schema.data_lock_waits w
		INNER JOIN information_schema.innodb_trx b
		ON b.trx_id = w.blocking_engine_transaction_id
		INNER JOIN information_schema.innodb_trx r
		ON r.trx_id = w.requesting_engine_transaction_id;
	이걸 복붙해서 치면 현재 블로킹된 스레드를 확인할수있고
	여기서 더 상세히 보려면
		SELECT * FROM performance_schema.data_locks\G
	를 치면됨
	이러면 무슨잠금인지도 나옴
	그리고 해당 스레드를 종료하려면
		kill 스레드번호
	하면 종료할수있음


4.mysql의 격리수준
	트랜잭션의 격리수준이란,여러 트랜잭션이 동시에 처리될때,
	특정 트랜잭션이 다른트랜잭션에서 변경하거나 조회하는 데이터를 볼수있게할지 허용할지 말지를 결정하는것
	이건
		read uncommitted //사용하지않음
		read committed
		repeatable read
		serializable //동시성이슈로 거의사용하지않음
	가 있음
	그리고 read committed이나 repeatable read나 사실 서버처리성능은 별차이없어서,보통 repeatable read를 사용함
	
	격리수준에 따라 발생하는 문제로는
		dirty read //어떤 트랜잭션에서 처리한 작업이 완료되지않았는데도 다른 트랜잭션에서 관측할수있는 현상,read uncommitted만 있음
		non-repeatable read //같은쿼리를 트랜잭션내에서 날렸는데 결과값이 다른현상,read committed이하면 발생
		phantom read //for update로 트랜잭션내에서 조회를할때,결과값이 다른현상,repeatable read이하면 발생,단 innoDB는 발생하지않음
	가 있음
	
	read uncommitted은,트랜잭션의 커밋과 롤백여부에 상관없이 다른트랜잭션에서 현재 작업중인게 보이는것,사용하지않음
	
	read committed는 커밋이 완료되어야 변경된점이 다른트랜잭션에서 관측되는것,그전까진 해당 레코드를 접근하면,언두로그로 가서 값을 가져옴
	이경우에도 트랜잭션내에서 조회를할때,다른트랜잭션이 커밋을 치면 언두로그가 아닌 레코드값을 들고와서,
	2번이상 조회를 할때 결과값이 달라질수있다는 문제가있음(non-repeatable read)
	
	repeatable read는,트랜잭션별로 id를 달아서 기록해서,해당 언두로그의 트랜잭션번호가 현재 접근한 트랜잭션의 번호보다 작은값을 가져오는방식임
	즉 자기가 시작한 이후에 발생한 트랜잭션의 작업은 자기한테 영향을 줄수없음
	단 이거도 업데이트만 그렇고 새 트랜잭션에서 인서트를 해버리면,새로운 레코드가 추가되기때문에 이거때문에 값이 달라질수있음
	단 innoDB는 발생하지않음
	
	serializable는 사용하지않음






6.데이터 압축
	mysql의 데이터압축방식에는 페이지압축과 테이블압축이 있는데,페이지압축은 사용하지않음
	
	테이블압축은 일단 디스크 데이터파일크기를 줄일수있지만,단점도 있음
		버퍼풀 공간활용률이 낮음
		쿼리처리성능이 낮음
		빈번한 데이터변경시 압축률이 떨어짐
	그래서 이걸 할지말지도 중요한 트레이드오프임
	
	테이블 압축을 사용할땐,innodb_file_per_table 시스템변수를 on으로 만들고 테이블이 생성되어야함
	추가적으로 테이블 압축을 사용할 테이블은 row_format=compressed옵션이 명시되어야함(명시되지않고 key_block_size만 있으면 자동으로 추가하긴함)
	추가로 key_block_size옵션으로 압축된 페이지의 타깃크기를 명시하는데,이건 2n단위로만 설정할수있고,
	innodb의 페이지크기가 16kb면 4나 8,32kb나 64kb면 테이블압축을 사용할수없음
	
	이 테이블압축은,해당 페이지를 압축하고,해당 페이지가 8kb를 이하이면 그대로 저장,
	이상이면 원본페이지를 반으로 쪼개서 2개의 페이지에 8kb씩 저장
	이걸 반복실행함
	즉 분할정복하는거임
	
	그래서 테이블압축에서 제일 중요한건,압축결과가 얼마정도될지를 예측해서 key_block_size를 정하는것
	보통 4kb나 8kb로 설정해서 샘플을 뽑아보고 결정하는게좋음(이때 페이지가 10페이지정도는 나오게 인서트해야함)
	이떄 190p를 보고 압축실패율확인쿼리를 사용해서 압축실패율이 3~5%정도 나오는 값을 선택하는게좋음
	
	그리고 성능에 민감한 서비스의경우엔 압축을 적용하지않는게 좋음(일단 테이블이 매우 빈번하게 조회되고 변경되면 압축을 안하는게좋음,이거 비용비쌈)
	
	이 압축된 페이지들은,lru를 사용해 메모리에 올려두고 사용이 없어지면 제거하는식으로 mysql은 사용함
	
	그리고 193p를 보면,테이블압축에 관련된 시스템변수들이 있는데,이건 전부 페이지의 압축실패율을 낮추기 위한 튜닝포인트들임 참고


7.데이터 암호화
	mysql에서 데이터 암호화를 하는부분은,데이터파일(테이블스페이스),리두로그와 언두로그,바이너리로그가 있음
	이건 보안감사에서 필수적으로 언급되는부분이고,핀테크같은곳에선 응용프로그램에서 암호화한 데이터를 db서버에서 다시 암호화하는 2중암호화를 선택하기도함
	보통 응용프로그램은 칼럼단위,db수준에서는 테이블단위로 암호화를 적용함	
	
	mysql서버의 암호화는,디스크입출력부분 즉 스토리지엔진부분에서만 암호화를 적용함
	즉 상위레벨인 서버에서는 전혀  신경쓸필요가없음
	그래서 쿼리에서도 암호화가있든없든 신경쓰지않아도됨
	이걸 tde방식이라고 함
	
	mysql서버의 암호화키는 키링플러그인에 의해 관리되며,keyring_file을 제외한 다른플러그인은 엔터프라이즈버전에서만 사용가능함
	물론 서드파티쓰면됨
	기본적으로 이 플러그인들은 동작방식은 동일하고,마스터키를 관리하는 방법만 다름
	
	mysql서버의 데이터암호화는,마스터키와 테이블스페이스키라는 두종류의 키를 가지고있는데,여기서 테이블스페이스키는 프라이빗키임
	즉 마스터키를 배포하고,테이블스페이스키는 서버만 가지고있는 암호화를 사용함
	이때 테이블스페이스키와 마스터키 페어는,각 테이블마다 발급되고,이 테이블 스페이스키는 테이블이 삭제되지않으면 절대 변경되지않음
	근데 마스터키는 외부의파일을 이용해서 노출될수있기때문에,이건
		alter instance rotate innodb master key
	로 변경할수있는데,이러면 기존의 마스터키로 테이블스페이스키를 복호화해서 평문으로 만들어두고,새마스터키로 다시 암호화함
	즉 테이블스페이스키는 바뀌지않고,마스터키로 건 암호화만 바뀌는식임
	이래야 테이블을 다시 복호화했다가 암호화해야하는 큰작업을 안해도됨
	
	mysql서버에서 한번 복호화를 하면,이건 메모리에 lru로 저장되고,메모리에 있으면 다시 복호화를 하지않아도됨
	그리고 압축과 암호화를 같이해야하면,압축부터하고 암호화를 진행함(이래야 싸니까)
	
	그리고 레플리카 서버들끼리도 마스터키와 테이블스페이스키는 서로 다 다름(원격으로 키관리 솔루션을 사용해도 서로 다른 마스터키를 갖게 설정해야함)
	그래서 같은 레코드를 암호화해도,디스크에 남은파일은 서로 내용이 달라짐

	
	키링플러그인은 마스터키를 생성하고 관리하는부분만 담당하니,어떤플러그인을 사용해도 암호화된 테이블을 생성하고 활용하는법은 동일함
	암호화테이블을 생성하는건,그냥
		create table abc(컬럼정보) encryption='y';
	이렇게 마지막에 encryption만 붙이면됨
	그리고 default_table_encryption 시스템변수를 on으로 설정하면,별도로 옵션설정을 안해도 암호화테이블로 생성됨
	
	그리고 응용프로그램에서 암호화를 걸면,그냥 ==비교로 가져오는건 상관없는데,만약 그게 숫자일경우 범위로 긁어온다던가 정렬해서 긁어온다던가는 불가능해짐
	그래서 둘중 한군데서만 암호화를 걸어도되면,db에서 암호화를 거는게 나음
	
	암호화가 걸린 테이블을 옮길땐,덤프떠서 옮기는거보다 export&import가 더 간단함
	근데 tde가 적용되어 암호화된 테이블은,서버가 다르니 마스터키가 달라서 하나 더 신경써야할게있음
		flush tables 소스테이블 for export
	로 뽑아서 데이터파일과 같이있는 *.cfp파일을 같이 복사해야함,이게 마스터키파일임
	이게 없어지면 복구가 불가능해짐


	이렇게 암호화를 해도 언두로그와 리드로그,바이너리로그는 평문으로 저장되는데,8.0부터는
		innodn_undo_log_encrypt
		innodn_redo_log_encrypt
	시스템변수로 암호화를 걸수있어짐
	이건 이전에 있던 로그들은 평문그대로쓰고,이걸 적용하고 난 다음부터 암호화를 적용함(반대도 마찬가지)
	그래서 켜서쓰다가 껐을경우에도,한참동안 암호화키가 필요할수있음
	
	얘들도 다 테이블스페이스키로 암호화하고,이건 다시 마스터키로 암호화됨(즉 리두로그와 언두로그 전용의 테이블스페이스키가 생김)

	
	바이너리로그는 바이너리로그 핸들러에서 암호화키를 사용해 암호화하는 방식을 취하고있음
	근데 그래서 한번 암호화되면 키가 없으면 복호화를 할수없어지는데,이건 mysql서버만 가지고있어서 mysqlbinlog가 사용이 안됨
	그래서 mysqlbinlog를 쓰려면 mysql서버에 접속해서 바이너리로그를 가져오는 방법밖에 없음(--read-from-remote-server 파라미터)




8.인덱스
1.디스크 읽기방식
	랜덤io는 말그대로 디스크에서 랜덤위치를 띡띡띡하고 읽는거고,순차io는 arr[1:10]처럼 한번에 쭉 읽는거
	당연히 하드시절에는 성능차가 엄청났고,지금도 상당히 심하게 차이남
	
	순차io는 하드나 스스디나 별 성능차이가 없는데,랜덤io에서 엄청나게 차이가 나게되고,db의 대부분일은 랜덤io임
	쿼리튜닝도 랜덤io를 순차io로 바꾸는일은 거의못하고,랜덤io의 수치를 줄이는게 목적임(꼭 필요한 데이터만 읽게)
	
	
2.b-Tree인덱스	
	인덱스는 칼럼의값과 해당 레코드의 주소를 키값쌍으로 만들어 정렬해 저장해두는 이게 인덱스임
	이 인덱스는 데이터가 저장될때마다 항상 값을 정렬해야해서 저장하는과정이 느려지지만,이미 정렬되어서 조회과정이 매우빨라짐
	즉 인덱스는 데이터의 저장(인서트,업데이트,딜리트)성능을 희생하고,조회(셀렉트)성능을 올리는기능임
	그래서 저장성능을 어디까지 희생해도될지,읽기속도를 얼마나 더 빠르게 만들어야할지에 따라 결정해야함
	select의 where에 있다고 전부 인덱스로 만들면,데이터저장성능이 떨어지고 인덱스가 비대해져서 오히려 역효과가 날수있음
	
	키와 인덱스는 같은의미고,인덱스는 프라이머리키와 보조키로 역할을 나눌수있음
	프라이머리키는 id같은 그 레코드를 대표하는칼럼의 값
	그걸 제외한 나머지 모든 인덱스는 보조키(세컨더리 인덱스)임
	
	데이터 저장방식에 따라 나누면,b-Tree인덱스와 hash인덱스로 나눌수있음
	
	데이터의 중복허용여부로 분류하면,유니크인덱스와 유니크하지않은 인덱스로도 나눌수있음
	이건 옵티마이저에겐 상당히 중요한문제임,이퀄로 검색했을때 항상 1개값이 존재하냐(찾고 바로나가도되냐),2개이상존재하냐(끝까지돌려야하냐)를 나눔


	b-tree는 밸런스트리로 인덱스알고리즘중 가장 일반적으로 사용되는 알고리즘임
	이 btree는 최상위에 하나의 루트노드가 존재하고,그하위에 자식노드가 붙어있는형태임
	트리의 가장하위를 리프노드,중간을 브랜치노드,맨위를 루트노드라고 부름
	정확한 데이터위치는 모두 리프노드가 가지고있고,브랜치와 루트는 그 리프노드를 찾아가는길임
	
	여기서 인덱스의 키값은 정렬되어있지만,데이터파일의 레코드는 정렬되어있지 않아 랜덤io인데(인서트순서로 쌓이는거도 아님,딜리트해서 자리비면 그자리에 넣어서)
	이걸 가능한 적은io로 긁어오는거임
	
	여기서 인덱스는 테이블의 키칼럼만(id값) 가지고있고,나머지칼럼을 접근해야하면 그때되서야 해당위치를 찾아감
	
	그리고 이노디비는 모든 세컨더리 인덱스 검색에서 데이터 레코드를 읽기위해,
	세컨더리인덱스에 프라이머리키를 저장하고,반드시 프라이머리키를 저장한 인덱스를 거쳐서 가야함
	이건 나름 장단점이 있음
	
	btree에 인덱스를 추가하거나 삭제할경우(레코드추가삭제시)의 작동방식을 알아두면 쿼리성능예측이 쉬워짐
	추가시엔 
		1.그냥추가됨(자리가 남았을때)
		2.리프노드를 split해야함(자리가없을때)->상위브랜치노드까지 값추가해야함(재귀타고 루트까지가서 루트까지 스플릿될수있음)
	이 둘중하나임
	그래서 인서트비용이 좀 비싼데,대충 테이블에 레코드를 추가하는 작업비용이 1이면,인덱스에 키추가비용은 1.5임
	즉
		1+(1.5*키갯수)
	라고 비용을 대충 예상할수있음
	이건 전부 디스크io병목시간이라 컴터 스펙올려서 줄이기 어려움
	그래서 보통 인덱스키 추가를 지연시켜 좀 버퍼에 모아서 처리하는데,프라이머리키나 유니크인덱스의경우 중복확인을 해야하니까 버퍼사용이 불가능함
	
	인덱스삭제는 그냥 해당키값이 저장된 위치를 찾아서 비워버리면끝임
	따로 노드들의 변화를 일으키지않고,이거도 좀 버퍼에 모아서 처리하고 그런데,신경쓸필요없음
	
	인덱스에 쓰이는 키를 업데이트한경우엔,해당 인덱스를 삭제하고 다시 새로운 키값을 추가하는형태로 진행됨
	즉 딜리트+인서트라고 생각하면됨(이거도 버퍼사용)
		
	인덱스 키 검색은,셀렉트뿐아니라 업데이트나 딜리트할때도 사용되는데,이걸 트리검색이라고 함
	이 b-tree를 사용한 검색은,완전일치(=)나 앞부분일치("abc%")에서만 사용할수있음
	즉 like에서 "%abc"는 인덱스를 타지못함
	그리고 부등호(<,>)검색시엔,인덱스를 타긴하는데,인덱스를 구성하는 키값의 뒷부분만 검색하는 용도로는 인덱스를 사용할수없음
	그리고 가장 중요한건,인덱스의 키값에 변형이 가해지면,절대 인덱스를 탈수없음(변형된값은 인덱스에없으니)
	그래서 함수나 연산의 결과로 정렬한다거나 검색하면 인덱스를 타지못함
	
	추가적으로 이노디비에서는 레코드잠금을 할때 인덱스를 잠그기때문에,
	업데이트나 딜리트를 할때 적절한 인덱스가 없으면 테이블전체를 잠가버리기도 해서 주의가필요함 
		
	btree인덱스는,인덱스를 구성하는 칼럼의 크기(키값의 크기)와 레코드의 건수,유니크한 인덱스키값의 갯수등에 의해 검색이나 변경작업이 영향을 받음
	
	인덱스 키값의 크기는,결국 인덱스도 페이지에 들어있어서 페이지채로 상하차하는데,한페이지에 몇개를 넣을수있냐가 달라져서 그럼
	즉 한번 페이지올려서 끝날걸 두번올려야하고 이런식
	
	btree의 깊이는,중요하지만 제어할방법은 없음,이거도 깊이따라 거쳐야하는게 늘어나니까 그런건데,이거도 최대한 인덱스키값크기를 줄여라라는 결론임
	
	선택도(기수성)는,전체 인덱스 키 값 가운데 유니크한 값의 수를 의미함
	이게 높을수록 검색대상이 줄어들어서 처리가 빨라짐(물론 케이스따라 선택도가 낮아도 인덱스로 만들어야하는경우도 있음,정렬이나 그룹핑땜에)
	키값중 유니크한값이 많으면,해당 인덱스페이지로 좀 더 정밀하게 접근할수 있어짐
	즉 조건이 2개이상일때,앞의조건부터 인덱스를 탈때,첫번째조건의 결과물 row수를 확 줄일수 있어지는거
	그러면 두번째조건은 검색대상자체가 줄어서 속도가 올라감
	
	그리고 읽어야하는 레코드의 건수가 많으면,그냥 레코드를 바로검색하는게 더 비용이 쌀수도있음
	보통 테이블에서 직접 레코드1건을 읽는것보다,인덱스를 타면 5배정도 더 비용이 비싸다고 예측함
	그래서 보통 테이블 전체에서 20~25%를 읽어야할거같으면 그냥 옵티마이저는 풀스캔을 때려버림	
	그래서 풀스캔을 해야하는일이 많을경우엔 인덱스는 쓰기성능만 나빠지고 도움이안됨
	
	
	어떻게 옵티마이저가 인덱스를 사용하게 유도할지,사용하지못하게할지를 판단하려면,어떻게 인덱스를 사용해서 실제레코드를 읽어내는지를 알아야함
	보통 3가지를 사용함 db는
	
	인덱스레인지스캔은,가장 대표적인 인덱스접근방식인데,이건 between을 사용하는 느낌임
	즉 해당조건을 만족하는 가장 첫 인덱스를 리프노드에서 찾고,
	따로 루트노드로 다시 검색하는게 아닌 리프노드의 인덱스페이지에서 쭉밑으로 내려가면서(정렬되어있으니)전부 메모리에 저장해둠,
	페이지가 넘어가면 다음페이지를 불러오다가 해당조건을 만족하는 마지막인덱스를 찾으면 지금까지 읽은 레코드를 반환하고 쿼리를 끝냄
	즉,루트노드와 브랜치노드의 접근을 최소화해서 성능을 올린거
	이경우에도 레코드한건당 1번의 랜덤io가 일어나서,그래서 테이블전체의 20%이상 읽어야하면 그냥 풀스캔을 때려버리는거임	
	이떄,그냥 키값만 필요한경우엔 랜덤io를 안해도돼서(커버링인덱스) 성능이 엄청빨라짐
		
	인덱스 풀스캔은,인덱스의 처음부터 끝까지를 모두 읽는 방식임
	대표적으로 쿼리의 조건절에 사용된 칼럼이,인덱스의 첫번째 칼럼이 아닌경우 이렇게됨
	일단 이게 테이블전체읽는거보단 효과적이고,쿼리가 인덱스에 명시된 칼럼만으로 조건을 처리할수있으면 이렇게 처리함
	인덱스만 아니라 데이터레코드까지 읽어야하면 절대 이방식으로 처리되지않음(다중컬럼인덱스가 가진 컬럼만 가지고 처리할수없을때)
	즉 해당인덱스 안에 쿼리조건이 전부 들어있는데,인덱스레인지스캔은 사용할수없을때 이걸 사용함
	이거도 일단 인덱스니까 안타는거보단 나은데,인덱스를 사용하는방법중엔 최하위라(풀스캔이니) 고치는게좋음
	
	루스인덱스스캔(인덱스 스킵 스캔)은 각 인덱스페이지에서 하나씩 줏어오는 방식임
	이건 그룹바이나 max,min을 인덱스를 통해 사용할때 이런식으로 사용함
	즉 숫자2개가 묶여서 인덱스로 만들어져있는데 앞의값만 사용해서 그룹바이를 치면,뒤의값정렬은 필요없으니 하나씩만 뚝딱뚝딱 읽고 끝내는거
	
	인덱스의 핵심은 값이 정렬되어있다는거,그래서 인덱스를 구성하는 칼럼의 순서가 매우중요함
	근데 8.0와서는 루스인덱스스캔을 사용해서,첫번째 조건을 제외하고 쿼리를날려도 뒤의 인덱스만 스킵해가면서 읽는식으로 나름 효율이 좀 올라가긴했음
	근데 아직 초기단계라,
		where조건절에 조건이 없는 인덱스의 선행칼럼의 유니크값갯수가 적어야함(스킵횟수가 적어짐)
		쿼리가 인덱스에 존재하는 칼럼만으로 처리가능해야함(커버링 인덱스)
	라는 조건을 만족해야함,특히 유니크값갯수가 적을때여야 한다는걸 알아둬야함
		
	보통 현업에서는 2개이상의 칼럼을 포함하는 인덱스를 많이사용됨,이걸 다중칼럼인덱스라고 함
	이 인덱스들은 인덱스안에 키값이 여러개있고,앞에서부터 정렬됨
	즉 두번째칼럼의 정렬은,똑같은 첫번째 칼럼에서만 의미가있음,그래서 인덱스를 생성할때의 칼럼의 순서가 매우중요하고,신중히 결정해야함
	
	
	추가적으로,인덱스의 키값은 항상 오름차순이거나 내림차순인데,다중칼럼인덱스의 경우 이걸 섞어서 쓸수도있음(8.0부터)
	즉 앞에거는 오름차순,뒤에거는 내림차순으로 쓸수있다는거
	그리고 오름차순이나 내림차순이나 옵티마이저는 뒤에서부터 읽기도하고 앞에서부터 읽기도 하는데,
	정순보다 역순이 성능이 20%정도 떨어지긴함,그래서 상황따라 바꾸는게좋음
	보통 쿼리에서 자주사용하는 정렬순서대로 인덱스를 만드는게 젤 맘편하고 만들기쉬움
	
	
	쿼리에서 where와 group by,order by가 어떤경우에 인덱스를 사용할수 있고,어떤방식으로 사용할수있는지를 알아야함
	인덱스를 만들때,쿼리에서 =이 가장 앞에오고,<>이 그 뒤에 오는식으로 인덱스순서가 나와야함,이게 가장 효율적
	이러면 일단 앞에있는거로 인덱스 범위를 줄이고,뒤에거로 그안에서 레인지검색을 효율적으로 칠수있는데(레인지범위안에서 레인지스캔),
	거꾸로할경우에도 일단 레인지검색을 하는데,그 범위를 전부 다 뒤져가면서 필터링을 해야해서 비효율적임(레인지범위안에서 풀스캔)
	
	이렇게 작업범위를 결정하는걸 작업범위 결정조건이라고 하고,단순 필터역할만 해주는걸 필터링조건이라고 하는데,
	작업범위 결정조건은 많으면 많을수록 좋은데,체크조건은 쿼리처리성능을 늘리지못함
	그래서 =로쓸걸 가장 앞에두면 작업범위조건이 되고,이걸 뒤에두면 체크조건이 돼서 가장 앞에두는거
	
	btree인덱스의 특징은 왼쪽값에 기준해서 오른쪽이 정렬되어있다는거
	이건 하나의 칼럼내에서뿐 아니라 다중컬럼인덱스에서도 함께 적용됨
	그래서 왼쪽부분이 없으면 인덱스레인지스캔이 불가능해짐 (like %abc검색이나 where에서 왼쪽조건이 없을때)
	
	btree인덱스를 작업범위결정조건으로 사용할수없는조건은
		not equal로 비교(not in,is not null,<>)
		like '%abc'
		스토어드함수나 연산자로 인덱스칼럼이 변형된 후 비교(substring,dayofmonth)
		not-deterministic속성의 스토어드함수가 비교조건에 사용
		데이터타입이 서로 다른 비교(char_column=10)
		문자열데이터타입의 인코딩값이 다른경우(utf8과 euckr의 비교)
	가 있음
	추가적으로 null도 mysql에서는 인덱스에 저장돼서,작업범위조건으로 사용할수있음
	
	다중칼럼인덱스에서 작업범위결정조건으로 사용할수없는경우(col1,col2,col3..colN순 인덱스)
		col1에 대한 조건이 없을때
		col1칼럼의 비교조건이 위의 인덱스사용불가조건중 하나일경우
	다중칼럼인덱스에서 작업범위결정조건으로 인덱스를 사용하는경우
		col1~colN까지 =나 in으로 비교하는경우
		colN에 대해 다음 연산자중 하나로 비교
			동등비교(=나 in)
			비교연산자(<,>)
			like 좌측일치(like 'abd%')
	일단 맨앞에거만 where에 들어있어도 레인지긴 한데,맨앞에 없으면 아예 풀스캔이고,순서대로 다 있으면 베스트
	즉 해당조건을 만족시키지 못한 다음 컬럼부터는 체크조건으로 들어가게됨(없거나 작업범위조건을 만족시키지못하거나)
		
3.r-tree인덱스	
	r-tree인덱스는,mysql의 공간인덱스임
	이걸 사용하면 지도를 만들때 편함,특정위치에서 5km안에 있는 편의점을 검색한다던가 할때 사용함
	이땐 st_contains()나 st_withIn()등을 사용해서 거리기반검색을 할수있음
	보통 현재위치를 주고,거기서 사각형안에 있는걸 검색 이런식임
4.전문검색인덱스	
	전문검색인덱스는,btree를 사용할수없음(왼쪽부터 정렬하는게 안먹히니)
	그래서 n그램이나 어근분석(영어)를 사용해서 처리하게됨
		n그램은 어떤언어든 할수있지만,인덱스가 커진다는 단점이 있고
		어근분석은 인덱스는 작지만 각 언어마다 따로개발해야한다는 단점이 있음
	전문검색인덱스를 사용할떈
		쿼리문장이 전문검색을 위한 문법(match ... against...)를 반드시 사용해야함
		테이블이 전문검색대상칼럼에 대해 전문인덱스를 보유
	이조건을 만족해야 인덱스를 탈수있음(저걸 안지켜도 검색은되지만,인덱스는 못탐)
5.함수기반인덱스	
	함수기반인덱스는 substring같이 변형된 결과값을 가지고 인덱스에 넣는거임
	이건 8.0부터 가능해짐
	이건 
		가상칼럼을 만들고 해당칼럼에 대해 인덱스를 생성하거나(이경우 따로 인서트할때 신경안써도 알아서넣음,5.7에서도 가능)
		함수를 직접 인덱스 구문에 사용하거나(8.0부터 가능)
	이 두가지방법으로 사용할수있음,보통 8.0에서는 그냥 함수를 인덱스에 넣는편
	그리고 주의할건,반드시 함수기반인덱스에 명시된 표현식과 쿼리의 표현식이 같아야함,결과가 같은건 중요하지않고 무조건 표현식이같아야함
	즉 함수인덱스에서 복붙해서 사용하는거랑 똑같아야함	
		
6.멀티밸류인덱스		
	전문검색인덱스를 제외한 모든인덱스는,레코드1건이 1개의 인덱스 키값을 가지는데,이건 하나의 레코드가 여러 인덱스를 가질수있는 형태의 인덱스임
	이건 json타입을 지원하면서,json의 필드에 저장된 원소들에 대한 인덱스요건때문에 생겼음
	이걸 사용할땐 일반 조건이 아닌
		Member of()
		json_contains()
		json_overlaps()
	함수들을 사용해야 멀티밸류인덱스를 사용할수있으니 주의
		
7.클러스터링 인덱스
	이건 인덱스가 아닌,테이블의 레코드들을 프라이머리키 기준으로 비슷한거끼리 묶어서 저장하는 방식을 말함
	그래서 이건 클러스터링 테이블이라고도 부름
	이때 프라이머리키값이 변경되면 물리적으로 위치가 바뀌어야하고,그래서 프라이머리키값에 대한 의존도가 높아서 신중히 결정해야함
	이건 키기반검색은 매우빠르고,레코드저장이나 프라이머리키변경이 상대적으로 느림
	이노디비에선 이게 디폴트임
	그래서 세컨더리인덱스들은,레코드의 주소가 아닌 프라이머리키를 가지게 설계되고,세컨더리인덱스를 타면 무조건 메인인덱스를 타게됨
	그래서 프라이머리키값이 변경되어도 세컨더리인덱스들은 변경을 피할수있어짐
	
	그래서 이노디비에서는,
		프라이머리키의 크기가 중요하고(세컨더리인덱스크기도 같이커지니),
		가능하면 오토인크리즈먼트보단 업무적인 칼럼으로 생성하는게 좋음(근데 이건 인조키를 선호하는사람들이 더많긴한듯)
		프라이머리키는 반드시 명시적으로 생성
		조회위주가 아닌 삽입위주의 경우엔 인조키가 더 빠름
	같은걸 지켜야함	
		
8.유니크 인덱스		
	유니크는 인덱스가 아닌 제약조건인데,mysql에서는 인덱스없이 유니크를 설정할수있는 방법이 없음
	추가적으로 여기엔 null도 들어갈수있는데 이건 값이 아니라서 2개이상 들어갈수있으니 주의해야함(not null붙여야함)
	
	유니크인덱스는 세컨더리인덱스와 읽기작업은 차이가 없음,둘다 레코드가 1개면 비슷한시간이 걸리게됨
	쓰기작업은 중복여부를 확인해야하고 버퍼도 사용할수없기때문에 일반인덱스보다 느리고,데드락이 자주발생함
	
	그래서 꼭 필요한경우에 유니크인덱스를 생성해야겠지만,유니크인덱스에 성능향상을 기대하고 생성하면 안됨
	그리고 유니크인덱스와 그냥인덱스를 똑같이 2개만들필요도없음(프라이머리키도 똑같음)
		
9.외래키
	외래키는 이노디비에서만 생성할수있고,외래키제약이 설정되면 자동으로 연관되는테이블의 칼럼에 인덱스까지 생성됨
	이때
		테이블의 변경이 발생하는 경우에만 잠금경합이 발생
		외래키와 관련되지않은 칼럼의 변경은 최대한 잠금경합을 발생시키지않음
	그래서 
		자식테이블의 외래키칼럼을 변경(인서트,업데이트)시킬때 부모가 잠겨있으면 부모를 기다려야하고
		자식테이블의 외래키가 아닌 칼럼을 변경(업데이트)할땐 부모를 확인안해도됨
		부모테이블의 레코드를 삭제할때 자식테이블에 해당외래키를 가진애들이 잠겨있으면,자식을 기다려야함(딜리트 캐스케이드)
		
		
		
09.옵티마이저와 힌트		
		
		
		
		
		
		
		
		
		
	