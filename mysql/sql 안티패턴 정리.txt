1.논리적 데이터베이스 설계 안티패턴
  1.무단횡단
	갑자기 스펙이 변경돼서 한 칼럼이 다중값을 가져야할때(일대다가 다대다가 되어야할때),
	그냥 무작정 1정규화를 깨고 쉼표로 구분해서 때려박으면 안됨
	이러면 쿼리가 어려워지고,조인도 어려워지고,집계쿼리도 어려워짐
	
	단, json을 사용해서 받는데,해당값을 파싱할필요없고 진짜 그대로 문자열로 던져주기만 할거라면 이렇게 반정규화해서 쓰는 경우도 있긴함
	근데 만약 안에서 하나를 선택한다던가 하는 로직이 필요하다면 정규화해야함
	
	해결법은 그냥 중간테이블을 생성하는것
	이렇게 쓰는게 인덱스도 더 잘타고(조인을 써도),쿼리읽기도 쉽고 좋음
	
  2.순진한 트리
	데이터가 재귀적구조를 가진 계층구조(회사 조직도같은)라면,트리구조를 가지게 됨
	이때 항상 부모에 의존하는(부모id칼럼)을 추가하는방식은 인접목록이라고 부르고,안티패턴임
	가장 큰 문제는 모든 자식을 대상으로하는 행위가 힘들다는것
	물론 새 노드 추가나 노드이동같은게 쉽다는 장점이 있긴한데,삭제가 어려운 단점도 있음(하위를 전부 지우고 삭제해야함)
	
	물론 해당노드의 부모나 자식정도만 필요하고,계층이 깊지않고 고정이라면 이정도로도 충분함,삽입이 쉽기도하고
	그리고 with를 사용한 재귀방식으로도 어느정도 처리되기도하고
	
	이를 대체하는 방법으로는 경로열거,중첩집합,클로저테이블같은 대안이 있음
	
	경로열거는 일련의 조상들은 윈도우탐색기처럼 a/aa/b/c 이런식으로 varchar로 저장해서 사용함
	이러면 해당값의 하위노드들을 찾기가 편해지고,변경도 쉬워지지만,일관성을 강제할순없음(무단횡단과 비슷한느낌),간단하게쓸때나 쓸만함
	
	중첩집합은 각 노드가 자신의 부모를 저장하는대신,자기자손의 집합에 관한 정보를 저장함
	즉 트리알고리즘을 구현해서,각 노드를 dfs,bfs할수있게만드는것
	이거의 장점은,자식을 가진 노드를 삭제했을때 그 자손이 자동으로 삭제된 노드부모의 자식이 된다는것
	단점은 자식이나 부모를 조회하는것같은게 많이 복잡해지고,노드를 추가,이동하는것같은거도 복잡해짐
	
	클로저테이블이 가장 나은 선택임, 부모자식관계에 대한 경로를 해당테이블에서 저장하지않고,별개의 테이블에서 트리의 모든 경로를 저장함
	즉 따로 테이블을 하나 만들고,거기에 자신과 모든 하위노드의 id를 전부 나열하는것
	이러면 해당노드의 하위를 전부 찾기도 쉽고,해당노드의 부모를 찾기도쉬움(그냥 자식에서 서치한뒤에 부모찾으면되니까)
	삭제도 그냥 클로저테이블과 해당칼럼을 같이날리면되고,이동도 간편함
	추가적으로 직계부모나 직계자식(바로위나 바로밑)이 필요하다면,필드를 하나 추가해서 path_length를 같이 적어주면됨
	그러면 자기자신으로부터 차이가 1이면 직계자식,2면 손자 이런식으로 바로 찾을수있음
	
  3.아이디가 필요해
	프라이머리키는 반드시 있어야하고,키가될게 없다면 인조키를 생성할수있음
	이 섹션은 키로쓸게있다면 인조키가 아닌 자연키를 쓰라고하지만,난 인조키를 쓰는게 맞는거같음

  4.키가 없는 엔트리
	테이블간에 명확한 관계가 있다면 참조정합성을 위해 외래키를 사용하는게좋음
	외래키를 사용하지않으면 참조정합성을 보장하기위한 코드를 직접 작성해야하고,스레드안전같은 이런영역도 처리를해야함
	또한 포린키를 사용하면 단계적 업데이트처리도 자동으로해줌(캐스케이드)

  5.엔티티-속성-값
	가변속성을 제공하기위해 별도테이블을 생성해서 해당값을 행으로 저장한후,그 속성을 id값으로 가지는건 안티패턴임(eav)
	즉 예전 loss테이블 생각하면됨(별도테이블을 생성하진않았지만 lot가 그역할을 했으니)
	이러면 제약조건을 사용하기어렵고(보통 넓은범위를 커버치려고 컬럼타입을 문자열로 두니까),속성이름을 강제할수없어지고
	참조정합성을 강제할수없어짐(포린키를 사용할수없음),또한 행을 업데이트하기 어려워짐
	이런걸 쓰고싶으면 rdb가 아닌 nosql을 써야함
	
	가장 단순한 해결법은 모든타입을 하나의 테이블에 저장하고(즉 모든타입을 쭉 나열하고,쓰지않는건 null)
	이거의 한계는 뭐 하나 추가되면 매번 메타데이터를 건드려야하고,어떤속성이 어떤 서브타입에 속하는지를 알수없음
	
	다른건 서브타입별로 별도의 테이블을 만드는것(loss로치면 각 공정마다 별개의테이블 사용)
	이거의 단점은 공통속성이 변경되면 다 건드려야하고,어떤게 공통속성인지 알기어려움,또한 모든게 필요할떄 union으로 묶어야함
	
	다른방법은 객체지향처럼 공통타입을 만들어두고,해당값을 상속받는느낌으로 포린키를 가져다가쓰는거
	
	완전 다른방법으로는 서브타입수가 많거나 새속성을 지원해야하는경우가 많다면 json으로 쓰는것
	이거의 장점은 확장이 쉽다는거고,단점은 sql에서 해당 특정속성에 접근하기 어려움(요즘은 되긴할듯)

  6.다형성 연관
	한 필드가 두군데이상의 부모테이블과 포린키를 맺는건 불가능하고,이걸 흉내내려고 키값과 부모테이블명을 받는식으로 처리하면안됨
	이러면 조회를할때,양쪽을 동시에 표기하는게 불가능해지고,orm으로 사용할수도 없음
	하이버네이트같은거 쓰면 이런식으로 만들어주긴하는데,그건 라이브러리가 알아서 처리하니까 상관없는문제임(참조정합성유지때문에)
	
	이렇게됐으면 그냥 db를 다시설계해야함,핵심은 다형성연관에서는 관계의 방향이 거꾸로라는것
	즉 연관관계의 주인을 many쪽에 다는건데,중간테이블을 만들면됨
	허용하고싶지않은 연관이 생기는게 싫으면,즉 부모끼리 연관생기는게 싫으면  one쪽 id에 유니크제약조건사용하면됨
	
	또한 해당연관관계 모두의 상위타입을 만들어서 가져다쓰는방법도 있음
	즉 원래 many쪽이었던애들의 pk를 pk이자 fk로 사용하는것,이러면 공통상위타입에서 하나만 생성될수있고,
	one쪽은 여러개를 생성하면서 부모의 유일성을 보장받을수있음

  7.다중 칼럼 속성
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	