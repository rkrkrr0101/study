1.논리적 데이터베이스 설계 안티패턴
  1.무단횡단
	갑자기 스펙이 변경돼서 한 칼럼이 다중값을 가져야할때(일대다가 다대다가 되어야할때),
	그냥 무작정 1정규화를 깨고 쉼표로 구분해서 때려박으면 안됨
	이러면 쿼리가 어려워지고,조인도 어려워지고,집계쿼리도 어려워짐
	
	단, json을 사용해서 받는데,해당값을 파싱할필요없고 진짜 그대로 문자열로 던져주기만 할거라면 이렇게 반정규화해서 쓰는 경우도 있긴함
	근데 만약 안에서 하나를 선택한다던가 하는 로직이 필요하다면 정규화해야함
	
	해결법은 그냥 중간테이블을 생성하는것
	이렇게 쓰는게 인덱스도 더 잘타고(조인을 써도),쿼리읽기도 쉽고 좋음
	
  2.순진한 트리
	데이터가 재귀적구조를 가진 계층구조(회사 조직도같은)라면,트리구조를 가지게 됨
	이때 항상 부모에 의존하는(부모id칼럼)을 추가하는방식은 인접목록이라고 부르고,안티패턴임
	가장 큰 문제는 모든 자식을 대상으로하는 행위가 힘들다는것
	물론 새 노드 추가나 노드이동같은게 쉽다는 장점이 있긴한데,삭제가 어려운 단점도 있음(하위를 전부 지우고 삭제해야함)
	
	물론 해당노드의 부모나 자식정도만 필요하고,계층이 깊지않고 고정이라면 이정도로도 충분함,삽입이 쉽기도하고
	그리고 with를 사용한 재귀방식으로도 어느정도 처리되기도하고
	
	이를 대체하는 방법으로는 경로열거,중첩집합,클로저테이블같은 대안이 있음
	
	경로열거는 일련의 조상들은 윈도우탐색기처럼 a/aa/b/c 이런식으로 varchar로 저장해서 사용함
	이러면 해당값의 하위노드들을 찾기가 편해지고,변경도 쉬워지지만,일관성을 강제할순없음(무단횡단과 비슷한느낌),간단하게쓸때나 쓸만함
	
	중첩집합은 각 노드가 자신의 부모를 저장하는대신,자기자손의 집합에 관한 정보를 저장함
	즉 트리알고리즘을 구현해서,각 노드를 dfs,bfs할수있게만드는것
	이거의 장점은,자식을 가진 노드를 삭제했을때 그 자손이 자동으로 삭제된 노드부모의 자식이 된다는것
	단점은 자식이나 부모를 조회하는것같은게 많이 복잡해지고,노드를 추가,이동하는것같은거도 복잡해짐
	
	클로저테이블이 가장 나은 선택임, 부모자식관계에 대한 경로를 해당테이블에서 저장하지않고,별개의 테이블에서 트리의 모든 경로를 저장함
	즉 따로 테이블을 하나 만들고,거기에 자신과 모든 하위노드의 id를 전부 나열하는것
	이러면 해당노드의 하위를 전부 찾기도 쉽고,해당노드의 부모를 찾기도쉬움(그냥 자식에서 서치한뒤에 부모찾으면되니까)
	삭제도 그냥 클로저테이블과 해당칼럼을 같이날리면되고,이동도 간편함
	추가적으로 직계부모나 직계자식(바로위나 바로밑)이 필요하다면,필드를 하나 추가해서 path_length를 같이 적어주면됨
	그러면 자기자신으로부터 차이가 1이면 직계자식,2면 손자 이런식으로 바로 찾을수있음
	
  3.아이디가 필요해
	프라이머리키는 반드시 있어야하고,키가될게 없다면 인조키를 생성할수있음
	이 섹션은 키로쓸게있다면 인조키가 아닌 자연키를 쓰라고하지만,난 인조키를 쓰는게 맞는거같음

  4.키가 없는 엔트리
	테이블간에 명확한 관계가 있다면 참조정합성을 위해 외래키를 사용하는게좋음
	외래키를 사용하지않으면 참조정합성을 보장하기위한 코드를 직접 작성해야하고,스레드안전같은 이런영역도 처리를해야함
	또한 포린키를 사용하면 단계적 업데이트처리도 자동으로해줌(캐스케이드)

  5.엔티티-속성-값
	가변속성을 제공하기위해 별도테이블을 생성해서 해당값을 행으로 저장한후,그 속성을 id값으로 가지는건 안티패턴임(eav)
	즉 예전 loss테이블 생각하면됨(별도테이블을 생성하진않았지만 lot가 그역할을 했으니)
	이러면 제약조건을 사용하기어렵고(보통 넓은범위를 커버치려고 컬럼타입을 문자열로 두니까),속성이름을 강제할수없어지고
	참조정합성을 강제할수없어짐(포린키를 사용할수없음),또한 행을 업데이트하기 어려워짐
	이런걸 쓰고싶으면 rdb가 아닌 nosql을 써야함
	
	가장 단순한 해결법은 모든타입을 하나의 테이블에 저장하고(즉 모든타입을 쭉 나열하고,쓰지않는건 null)
	이거의 한계는 뭐 하나 추가되면 매번 메타데이터를 건드려야하고,어떤속성이 어떤 서브타입에 속하는지를 알수없음
	
	다른건 서브타입별로 별도의 테이블을 만드는것(loss로치면 각 공정마다 별개의테이블 사용)
	이거의 단점은 공통속성이 변경되면 다 건드려야하고,어떤게 공통속성인지 알기어려움,또한 모든게 필요할떄 union으로 묶어야함
	
	다른방법은 객체지향처럼 공통타입을 만들어두고,해당값을 상속받는느낌으로 포린키를 가져다가쓰는거
	
	완전 다른방법으로는 서브타입수가 많거나 새속성을 지원해야하는경우가 많다면 json으로 쓰는것
	이거의 장점은 확장이 쉽다는거고,단점은 sql에서 해당 특정속성에 접근하기 어려움(요즘은 되긴할듯)

  6.다형성 연관
	한 필드가 두군데이상의 부모테이블과 포린키를 맺는건 불가능하고,이걸 흉내내려고 키값과 부모테이블명을 받는식으로 처리하면안됨
	이러면 조회를할때,양쪽을 동시에 표기하는게 불가능해지고,orm으로 사용할수도 없음
	하이버네이트같은거 쓰면 이런식으로 만들어주긴하는데,그건 라이브러리가 알아서 처리하니까 상관없는문제임(참조정합성유지때문에)
	
	이렇게됐으면 그냥 db를 다시설계해야함,핵심은 다형성연관에서는 관계의 방향이 거꾸로라는것
	즉 연관관계의 주인을 many쪽에 다는건데,중간테이블을 만들면됨
	허용하고싶지않은 연관이 생기는게 싫으면,즉 부모끼리 연관생기는게 싫으면  one쪽 id에 유니크제약조건사용하면됨
	
	또한 해당연관관계 모두의 상위타입을 만들어서 가져다쓰는방법도 있음
	즉 원래 many쪽이었던애들의 pk를 pk이자 fk로 사용하는것,이러면 공통상위타입에서 하나만 생성될수있고,
	one쪽은 여러개를 생성하면서 부모의 유일성을 보장받을수있음

  7.다중 칼럼 속성
	다중값을 저장해야할때(무단횡단과 같은목표),각 종류마다(집전화,핸드폰,회사전화 등) 칼럼을 만드는건 안티패턴임
	이경우엔 값검색도 힘들어지고 값추가삭제도 힘들어지고 유일성보장도 힘들어짐(유니크제약)
	제일큰문제는 칼럼이 늘어나는 갯수 예측이 불가능하다는것(추가적으로 이경우의 비용도 비쌈,db변경비용부터 앱도 변경해야함)
	이런식의 패턴은 속성의 갯수가 고정되고,선택의 위치나 순서가 중요할때는 사용할수있음(사용처의 위치가 각각 다 다를경우도)
	
	해결법은 종속테이블을 생성하는게 가장 좋음
	즉 해당로우의 id를 fk로 가지는 종속테이블을 만들고,거기다가 나열하는것
	
  8.메타데이터 트리블
	특정컬럼을 기반으로(주로 날짜)테이블을 분기할경우(테이블만 아니라 컬럼을 분기할경우도 포함),엄청나게 많은 테이블이나 컬럼을 만들어야하고
	실수하기도 매우쉬워짐
	올바른 테이블에 인서트하는거도 사용자책임이되고,잡아줄수있는방법도 없기때문
	또한 전테이블에 걸쳐 pk의 유일성을 보장하는거도 복잡해짐(별도의 테이블을 만들고 거기서 pk를 가져다써야함)
	
	이 패턴을 써도될때는,오래된데이터를 분리해서 보관하는식으로 써야지 새로운데이터를 새테이블에 받으면안됨
	
	이런방식대신 파티셔닝을 하는게 좋은방법임,수직분할 수평분할 종속테이블등
	수평분할은 그냥 파티셔닝임,선언만하면 db가 알아서 하나의 논리적테이블밑에 여러개의 실제테이블로 분할해줌
	수직분할은 칼럼으로 테이블을 나눠서,한 행이 여러테이블에 걸쳐 존재하게하는것,보통 text칼럼같은걸 나누는경우가많음
	종속테이블은 앞에서와 마찬가지로,별도의 테이블하나를 만들어서 분기가 생기는걸 거기다 때려박는것
	
2.물리적 데이터베이스 설계 안티패턴
  1.반올림 오류
	칼럼의 타입으로 float나 double를 사용하면 부동소수점부분에서 문제가 생길수있음
	물론 그렇게 정밀한값이 필요하지않거나하면 상관없을수있지만 정밀한값이 필요하다면 nummeric나 decimal을 사용해야함
	물론 float가 저 2개보다 큰값을 저장할수있어서,그럴경우엔 쓸수밖에없긴함
	
	nummeric나 decimal은 선언한 해당 자리수까지의 정확도를 보증해줌

  2.31가지 맛	
	칼럼타입으로 enum을 쓰는건,반드시 변하지않는다는 보장이 있을때(왼쪽,오른쪽같이)만 사용해야함
	아니면 칼럼으로 뭘 사용해도되는지 알기도 어렵고(따로 질의해야함),값목록을 추가하거나 삭제할때도 머리아픔
	특히 삭제는 이미 들어간데이터들이 있을때 머리가 아파짐
	
	차라리 색인테이블을 만들고,해당테이블을 참조하는식으로 만드는게 나음(fk),
	또한 삭제는 그냥 색인테이블에 칼럼하나늘려서 거기다가 표시하는식으로 처리할수있음
	
	즉 고정된값의 집합은 enum(메타데이터)를 사용하고,유동적값의 집합은 테이블(데이터)를 사용하는게 좋음

  3.유령파일
	파일을 db에 경로로 저장하면 문제가생겼을때 복구할방법이 없고,트랜잭션에 속하지도않음
	물론 이거자체는 완전한 트레이드오프의 영역임
	보통 해당데이터가 크게 중요하지않다면 외부에,같이 백업을 해야한다면 내부에 하는식으로 하는듯
	내부에 저장할때는 blob로 바이너리로 저장하면됨(보통 이미지까진 이렇게처리되는듯)

  4.인덱스 샷건
	인덱스는 추측으로 선정하는게 아닌,필요할때 필요한만큼 만들어야함
	오버해도 안되고,없어도 안됨
	쓸모없는인덱스의 예시로는 pk를 또 인덱싱한다거나,긴 텍스트같은 조회하지않을걸 인덱싱한다거나 하는건 다 낭비임
	
	인덱스를 막 추측해서 만들지말고,현재 가장 오래걸리는 쿼리를 찾아낸다음(슬로우쿼리) 실행계획을 확인해가면서 인덱스를 추가하는게 좋음
	
	
3.쿼리 안티패턴
  1.모르는것에 대한 두려움
	널은 값이 누락됐을때만 사용해야함
	널은 0이나 false가 아님,즉 진짜로 값이 없었을때만 사용하고,없을수없는 칼럼이라면 not null로 설정해야함
	
	null에 어떤 비교를해도 값은 null이고,null not를 해도 null임
	
	null인걸 찾으려면 is null을 써야하고,문자열과 null을 연결하면 null이 됨

  2.애매한 그룹
	그룹바이를 쓸때는 모든 셀렉트칼럼이 그룹바이의 대상인게 좋고(단일값규칙),그룹되지않은 칼럼을 참조하면 값이 어떻게나올지 모름
	일반적으로 안시표준으로는 에러가 나는게 맞는데,sqlite나 mysql의경우는 이경우도 실행은됨
	근데 이런식으로 꼭 해야겠다면 group_concat()함수를 사용해서 명시적으로 그룹바이지은곳과 묶는게좋음(이러면 ,기준으로 값들이 전부출력됨)

  3.임의의 선택
	데이터중 랜덤으로 값을 뽑는게 필요할때 rand를 쓰고 limit 1을 쓰는건 안티패턴임
	이건 정렬을 치고 제일위에있는걸 뽑는데 문제는 이러면 인덱스를 사용할수없다는거임
	이건 테이블의 행이 별로 없고,늘어나지않을때는 쓸수있는데,계속 커질예정이라면 사용할수없음
	
	해결법은,1과 max사이의 임의의 값을 어플리케이션단에서 고르거나,해당값과 가장 가까운값을 고르는식으로 할수있고
	오프셋을 이용해서 임의로 고를수도있음,또한 밴더별로 이런용도로 사용할 함수를 지원하기도함
	
  4.가난한 자들을 위한 검색엔진
	디비로 풀텍스트서치를 지원하기위해 패턴매칭을 사용하는건 안티패턴임
	일단 성능이 나쁘고 정확한 답을 찾기도 힘듬
	이걸 사용해도될때는 일회성쿼리라든가 이런경우에만 허용되고,가급적이면 db밴더별 확장기능을 사용하거나
	서드파티 검색엔진을 사용하거나,전치인덱스를 사용해서 직접 처리하는방법도있긴함(이거보단 걍 db밴더확장기능 찾아쓰는게 맞긴할듯)
	
  5.스파게티 쿼리
	모든쿼리를 한방쿼리로 만들필요는 없고,그럴경우 더 복잡해지기만 함
	가능하면 종류별로 쿼리를 쪼개서 만드는게 나음
	복잡한 쿼리는 읽기 힘들고,카테시안곱같은 문제가 생길확률도 높음
	
	이럴경우는 분할정복을 사용해서,뗄수있는곳은 떼서 따로처리하는게 좋음
	보통 카테시안곱같은 문제가 생길땐,두 테이블간 조인조건이 없어서 그럴수도 있고,이럴경우가 떼기 딱좋음
	그리고 한 쿼리로 꼭 받아야한다면 쿼리를 나누고 유니온으로 합치는게 나음
	
  6.암묵적 칼럼
	셀렉트절의 조회할 칼럼은 와일드카드가 아닌 명시적으로 적는게 좋음
	와일드카드가 짧아서 편하긴한데,이럴경우 리팩터링에 방해되고(추적이 힘들어져서 예외가 터져야하는데 안터짐),
	쿼리를 실행할때 성능손해를 볼수있음
	물론 임시쿼리나 즉석쿼리같은경우엔 별상관없음

3.어플리케이션 개발 안티패턴
  1.읽을수 있는 패스워드
	패스워드는 절대 평문으로 저장되면 안됨
	무조건 해시로 저장되어야하고,가급적 솔트를 추가하는게좋음(솔트를 추가안하면 레인보우테이블에 뚫리니까)
	또한 해시적용은 db단이 아닌 그 이전단계에서 처리해야 중간네트워크를 털릴때 패스워드가 안털림

  2.sql인젝션
	동적쿼리를 짤때는 sql인젝션을 조심해야함
	변수는 가능하면 int같은 완전히 딱 맞는 변수를 사용하고,문자열을 사용해야하면 문자열을 받아서 검증한다음 쿼리에 넣어야함
	보통 모든 따옴표를 이스케이프하거나,쿼리파라미터를 사용할수있음,또한 orm같은 라이브러리를 사용해도됨
  
  3.가상키 편집증
	키는 우연히 비슷한순서로 증감하는거지,그걸 기준으로 꽉꽉 들어차야하는건 아님
	중간에 삭제되면 키가 빌수도 있고 그런거,이런걸 다 메우려고하면 안됨
	차라리 uuid같은거로 알아볼수없게 해버리던가,셀렉트에서 id를 빼버리던가,사용자에게 설명하는게 맞음

  4.나쁜것 안보기
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
	
	
	
	
	
	
	