1.논리적 데이터베이스 설계 안티패턴
  1.무단횡단
	갑자기 스펙이 변경돼서 한 칼럼이 다중값을 가져야할때(일대다가 다대다가 되어야할때),
	그냥 무작정 1정규화를 깨고 쉼표로 구분해서 때려박으면 안됨
	이러면 쿼리가 어려워지고,조인도 어려워지고,집계쿼리도 어려워짐
	
	단, json을 사용해서 받는데,해당값을 파싱할필요없고 진짜 그대로 문자열로 던져주기만 할거라면 이렇게 반정규화해서 쓰는 경우도 있긴함
	근데 만약 안에서 하나를 선택한다던가 하는 로직이 필요하다면 정규화해야함
	
	해결법은 그냥 중간테이블을 생성하는것
	이렇게 쓰는게 인덱스도 더 잘타고(조인을 써도),쿼리읽기도 쉽고 좋음
	
  2.순진한 트리
	데이터가 재귀적구조를 가진 계층구조(회사 조직도같은)라면,트리구조를 가지게 됨
	이때 항상 부모에 의존하는(부모id칼럼)을 추가하는방식은 인접목록이라고 부르고,안티패턴임
	가장 큰 문제는 모든 자식을 대상으로하는 행위가 힘들다는것
	물론 새 노드 추가나 노드이동같은게 쉽다는 장점이 있긴한데,삭제가 어려운 단점도 있음(하위를 전부 지우고 삭제해야함)
	
	물론 해당노드의 부모나 자식정도만 필요하고,계층이 깊지않고 고정이라면 이정도로도 충분함,삽입이 쉽기도하고
	그리고 with를 사용한 재귀방식으로도 어느정도 처리되기도하고
	
	이를 대체하는 방법으로는 경로열거,중첩집합,클로저테이블같은 대안이 있음
	
	경로열거는 일련의 조상들은 윈도우탐색기처럼 a/aa/b/c 이런식으로 varchar로 저장해서 사용함
	이러면 해당값의 하위노드들을 찾기가 편해지고,변경도 쉬워지지만,일관성을 강제할순없음(무단횡단과 비슷한느낌),간단하게쓸때나 쓸만함
	
	중첩집합은 각 노드가 자신의 부모를 저장하는대신,자기자손의 집합에 관한 정보를 저장함
	즉 트리알고리즘을 구현해서,각 노드를 dfs,bfs할수있게만드는것
	이거의 장점은,자식을 가진 노드를 삭제했을때 그 자손이 자동으로 삭제된 노드부모의 자식이 된다는것
	단점은 자식이나 부모를 조회하는것같은게 많이 복잡해지고,노드를 추가,이동하는것같은거도 복잡해짐
	
	클로저테이블이 가장 나은 선택임, 부모자식관계에 대한 경로를 해당테이블에서 저장하지않고,별개의 테이블에서 트리의 모든 경로를 저장함
	즉 따로 테이블을 하나 만들고,거기에 자신과 모든 하위노드의 id를 전부 나열하는것
	이러면 해당노드의 하위를 전부 찾기도 쉽고,해당노드의 부모를 찾기도쉬움(그냥 자식에서 서치한뒤에 부모찾으면되니까)
	삭제도 그냥 클로저테이블과 해당칼럼을 같이날리면되고,이동도 간편함
	추가적으로 직계부모나 직계자식(바로위나 바로밑)이 필요하다면,필드를 하나 추가해서 path_length를 같이 적어주면됨
	그러면 자기자신으로부터 차이가 1이면 직계자식,2면 손자 이런식으로 바로 찾을수있음
	
  3.아이디가 필요해
	프라이머리키는 반드시 있어야하고,키가될게 없다면 인조키를 생성할수있음
	이 섹션은 키로쓸게있다면 인조키가 아닌 자연키를 쓰라고하지만,난 인조키를 쓰는게 맞는거같음

  4.키가 없는 엔트리
	테이블간에 명확한 관계가 있다면 참조정합성을 위해 외래키를 사용하는게좋음
	외래키를 사용하지않으면 참조정합성을 보장하기위한 코드를 직접 작성해야하고,스레드안전같은 이런영역도 처리를해야함
	또한 포린키를 사용하면 단계적 업데이트처리도 자동으로해줌(캐스케이드)

  5.엔티티 속성 값
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	