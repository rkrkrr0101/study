1.api개발 기본
	엔티티를 직접 받거나 보내면 안됨(dto를 거쳐서 받고 보내야함)
	만약 엔티티를 건드려야하는 일이 생기면,api스펙자체가 바뀌어버리기때문
	그래서 api스펙을 위한 데이터 트랜스퍼 오브젝트(dto)를 필수적으로 만들어야함
	
	기초적인 방법으론,dto를 받아서 컨트롤러내에서 엔티티를 만들어 삽입하는방식이 있음
	이거의 장점은
		현재 내가 여기서 받을수있는 데이터를 명확히 알수있음
		현재 로직에 대해 밸리데이션하기 편함
		엔티티와 api스펙을 명확히 분리할수있어서,엔티티를 마음놓고변경할수있음
	이 있음
	
	엔티티엔 롬복중 getter정도만 사용하고,dto는 막 써도됨(allRequestConstructor같은거)
	
	조회시에도 엔티티를 직접 노출하면,위의 문제 말고도  많은문제들이 있는데
	다른문제로 
		엔티티의 정보들이 다 클라로 가버리면 보안문제임(이걸 @jsonIgnore로 해당값을 뺴버리는식으로 처리할수있긴한데,워스트프렉티스)
		엔티티에 뷰를 위한 로직이 추가됨
		여러 api가 한 엔티티를 사용할때 머리아파짐
		컬렉션을 직접 반환하면,api스펙을 변경하기어려움(전체값을 하나의 키에다가 밀어넣어야,나중에 뭐 추가하기좋음)
			{
				data:[...], //컬렉션을 여기에 넣어야함
				count:30
			}
	이거도 dto를 쓰는게 나음
	그리고 컬렉션 직접반환을 해결하려고 제네릭(<T>)을 사용해서 데이터뭉치를 받은다음에 한변수에 그걸 다때려박아버리면 직접반환문제도 해결됨
	    @Data
		@AllArgsConstructor
		static class Result<T>{
			private T data; //여기에 컬렉션 때려박기
			private int count;
		}
	이후 사용할떈
	    List<MemberDTO> collect = findMembers.stream()
                .map(m -> new MemberDTO(m.getName()))
                .collect(Collectors.toList());

        return new Result(collect, collect.size());
	즉,리스트를 바로 던져버리면 안되고,그걸 싸서 던져야 나중에 뭐 추가할때 편함

2.api개발 고급-준비	
	성능문제가 되는건 어지간하면 조회에서 나옴
	
	xToOne(컬렉션이 아닐때)의 성
	
	그리고 엔티티를 바로리턴하면json으로 변환해서 넣게되는데,이때 양방향관계가 있으면 무한루프에 걸리게됨(반대쪽가서 다시 이쪽으로 넘어오니까)
	이때 @JsonIgnore로 막는 워스트프렉티스가 있음
	
	그리고 fetch가 lazy로 들어있으면 프록시로 들어가있는데,이걸 직접반환하면 json으로 변환할수없으니 에러가 나는데,
	그래서 Hibernate5JakartaModule라이브러리를 받아서 빈으로 등록해두면 일단 해결되긴함
	근데 이러면,만약 지연로딩엔티티를 한번 호출하면 그값이나오고,아니면 널이 나옴
	아예 설정으로 가져오게 할수도있고 그런데, 당연히 n+1이나가고,필요없는 엔티티필드도 다 긁어오고,엔티티노출되니까 스펙도못바꾸고 머리아파짐 ㅋㅋ
	
	그러니까 dto를 쓰고 페치조인을 하자..
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	