1.api개발 기본
	엔티티를 직접 받거나 보내면 안됨(dto를 거쳐서 받고 보내야함)
	만약 엔티티를 건드려야하는 일이 생기면,api스펙자체가 바뀌어버리기때문
	그래서 api스펙을 위한 데이터 트랜스퍼 오브젝트(dto)를 필수적으로 만들어야함
	
	기초적인 방법으론,dto를 받아서 컨트롤러내에서 엔티티를 만들어 삽입하는방식이 있음
	이거의 장점은
		현재 내가 여기서 받을수있는 데이터를 명확히 알수있음
		현재 로직에 대해 밸리데이션하기 편함
		엔티티와 api스펙을 명확히 분리할수있어서,엔티티를 마음놓고변경할수있음
	이 있음
	
	엔티티엔 롬복중 getter정도만 사용하고,dto는 막 써도됨(allRequestConstructor같은거)
	
	조회시에도 엔티티를 직접 노출하면,위의 문제 말고도  많은문제들이 있는데
	다른문제로 
		엔티티의 정보들이 다 클라로 가버리면 보안문제임(이걸 @jsonIgnore로 해당값을 뺴버리는식으로 처리할수있긴한데,워스트프렉티스)
		엔티티에 뷰를 위한 로직이 추가됨
		여러 api가 한 엔티티를 사용할때 머리아파짐
		컬렉션을 직접 반환하면,api스펙을 변경하기어려움(전체값을 하나의 키에다가 밀어넣어야,나중에 뭐 추가하기좋음)
			{
				data:[...], //컬렉션을 여기에 넣어야함
				count:30
			}
	이거도 dto를 쓰는게 나음
	그리고 컬렉션 직접반환을 해결하려고 제네릭(<T>)을 사용해서 데이터뭉치를 받은다음에 한변수에 그걸 다때려박아버리면 직접반환문제도 해결됨
	    @Data
		@AllArgsConstructor
		static class Result<T>{
			private T data; //여기에 컬렉션 때려박기
			private int count;
		}
	이후 사용할떈
	    List<MemberDTO> collect = findMembers.stream()
                .map(m -> new MemberDTO(m.getName()))
                .collect(Collectors.toList());

        return new Result(collect, collect.size());
	즉,리스트를 바로 던져버리면 안되고,그걸 싸서 던져야 나중에 뭐 추가할때 편함

2.api개발 고급-준비	
	성능문제가 되는건 어지간하면 조회에서 나옴
	
	xToOne(컬렉션이 아닐때)의 성
	
	그리고 엔티티를 바로리턴하면json으로 변환해서 넣게되는데,이때 양방향관계가 있으면 무한루프에 걸리게됨(반대쪽가서 다시 이쪽으로 넘어오니까)
	이때 @JsonIgnore로 막는 워스트프렉티스가 있음
	
	그리고 fetch가 lazy로 들어있으면 프록시로 들어가있는데,이걸 직접반환하면 json으로 변환할수없으니 에러가 나는데,
	그래서 Hibernate5JakartaModule라이브러리를 받아서 빈으로 등록해두면 일단 해결되긴함
	근데 이러면,만약 지연로딩엔티티를 한번 호출하면 그값이나오고,아니면 널이 나옴
	아예 설정으로 가져오게 할수도있고 그런데, 당연히 n+1이나가고,필요없는 엔티티필드도 다 긁어오고,엔티티노출되니까 스펙도못바꾸고 머리아파짐 ㅋㅋ
	
	그러니까 dto를 쓰고 페치조인을 하자..
	dto쓰는건 dto를 만들고,도메인을 받아서 dto로 변경하는 생성자를 만들고
	    List<Order> all = orderRepository.findAllByString(new OrderSearch());
        List<SimpleOrderDTO> collect = all.stream()
                .map(o -> new SimpleOrderDTO(o))
                .collect(Collectors.toList());
        return collect;
	이렇게 스트림돌리던가 for문돌리면됨(물론 이때 리스트 그대로 반환이 아닌,뭘로 한번 더 싸서 보내는게 좋음)
	그리고 dto는 엔티티를 참조해도 괜찮음,별로 안중요한데서 중요한걸 의존하는거라,문제생겨도 무시하면됨(dto를 피의존하는게 별로없으니)
	이거만하면 일단 엔티티노출문제는 해결되지만,n+1은 아직 남아있음
	이건 페치조인으로 해결해야함
		public List<Order> findAllWithMemberDelivery() {
			return em.createQuery(
					"select o from Order o" +
							" join fetch o.member m" +
							" join fetch o.delivery d", Order.class
			).getResultList();
		}	
	이런식으로 레포지토리에 만들어서 저거로 들고오면됨
		List<Order> all = orderRepository.findAllWithMemberDelivery()
	이렇게
	
	그리고 엔티티를 안거치고 바로 dto로 받을수도있음
	    return em.createQuery("select new jpabook.jpashop.repository.SimpleOrderQueryDTO(o.id,m.name,o.orderDate,o.status,d.address) " +
                        " From Order o " +
                        "join o.member m " +
                        "join o.delivery d ", SimpleOrderQueryDTO.class)
                .getResultList();
    이런식으로 하면 되긴함(이때 dto를 직접받을땐 fetch를 붙일수없기때문에,직접 깡조인해야함)
	이게 select가 적어서 부하가 적긴한데,쿼리가 ㄹㅇ개쓰레기같다는 단점이 있음,그냥 깡sql짜는거랑 별차이없음
	
	그래서 그냥 페치조인만 하는거랑,dto를 사용하는건
		dto로 직접안받음
			쿼리가 보기편하고
			재사용성이 좋음
			영속엔티티를 직접받기때문에 수정이 가능
			단,필요없는 컬럼도 다받아야함
		dto로 직접받음
			컬럼을 원하는거만 받아서 부하를 줄일수있음
			영속엔티티가 아닌 dto로 받기때문에,영속성컨텍스트 객체를 받지못해서 수정이 불가능 
			단,쿼리가 쓰레기같음
			단,재사용이 거의 불가능
			단,api스펙에 레포지토리가 종속됨(스펙바뀌면 바로 뜯어고쳐야함)
	두개는 트레이드오프가 있으니,상황따라 써야함(어지간하면 걍 엔티티로 받는게나아보이긴하다)
	그냥 기본을 엔티티로 가져가고,정 튜닝해야하면 그거만 수정하자(곱연산에 신경쓰고,합연산은 대충살자..)
	
	이런 튜닝된 dto검색쿼리는,따로 하위리포지토리로 빼는게 좋음(수정할일있으면 거기서 수정하는게 나음)
	리포지토리는 엔티티검색용으로 순수하게 유지하는게 좋음
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	