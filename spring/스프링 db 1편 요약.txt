1.jdbc이해
	jdbc는,각 db밴더마다 다른 연결방식을 통일하기위해,인터페이스로 래핑해서 구현을 알아서 밴더들이 하고,사용방식을 똑같게 만든거임
	여기서 구현체를 드라이버라고 함
	물론 각 db마다 다른(특히 페이징)sql같은건 각각 맞춰줘야했음(jpa사용하면 어느정도해결가능)
	
	이 db쪽에서의 발전순서는 깡jdbc->sql매퍼->orm순으로 발전해왔음
	
	jdbc커넥션만들땐
		Connection connection = DriverManager.getConnection(URL, USERNAME, PASSWORD);
	이런식으로 커넥션연결하면됨
	이러면 드라이버매니저가,현재 등록된 db드라이버를 바탕으로 해당되는 드라이버를(그 핸들러찾는거랑똑같음,입력값으로 체크하고 가능하면 T,아니면 F) 찾음
	
	그리고 커넥션을 직접연결할땐,finally로 꼭 닫아줘야함,그리고 각각 try캐치로 묶어줘야함
	
	그리고 롬복Data쓰면 EqualsAndHashcode도 같이들어있어서,안에있는값 같으면 같은객체로 취급
	
	테스트에서 예외체크는
		assertThatThrownBy(()->repository.findById(member.getMemberId()))
			.isInstanceOf(NoSuchElementException.class);
	이렇게하면됨
	
	그리고 테스트에서의 반복성을 위해서,트랜잭션을 사용해서 롤백하는식으로 동작하게해야함(jpa기본동작)

2.커넥션풀과 데이터소스 이해
	커넥션풀은,커넥션을 미리 잔뜩 만들어두고,로직에서 그걸 하나씩 가져가서 쓰고 다시돌려놓는식으로 하겠다는것(커넥션연결지연시간 줄이려고)
	커넥션풀의 기본갯수는 보통 10개고,상황에따라 늘리면됨
	그리고 사용하고나서 커넥션을 다시 반환해버리면되는거(닫는게아님)
	
	그리고 이런 커넥션을 획득하고 반환하는걸 추상화한게 데이터소스임(자바기본)
	그런데 드라이버매니저는 이런 데이터소스 인터페이스를 사용하지않아서,저거쓰다가 바꾸면 다바꿔야하는데,그래서 스프링은 드라이버매니저데이터소스라는
	데이터소스를 구현한 드라이버매니저 구현체를 제공함
	
	추가적인장점으로,데이터소스를 생성할때만 url,아이디패스워드같은걸 넣어주면되고,사용시점엔 이미 고정된상태라서 안넣어줘도된다는 장점이있음
	즉,저런 상수들같은거에 의존하지않아도됨 사용시점에서
	
	그리고 이런 커넥션풀을 생성할땐 별도의 쓰레드에서 동작하기때문에,테스트할땐 대기시간을 주든가 해야 저거테스트는 할수있음
	뭐 진짜로쓸땐 이미 깔려잇다고 가정하고하니까 상관없겟지만
	그리고 이렇게 직접 커넥션풀 받아다쓸땐,반드시 쓰고나서 반환해줘야함(con1.close(),클로즈하면 닫는게 아니라 반환을 함)
	
	만약 커넥션풀갯수 초과하게 받아가면,앞에하나가 끝날떄까지 블락됨(대기상태)
	이러다가 타임아웃나면 예외뜸



3.트랜잭션 이해
	트랜잭션은,트랜잭션 선언과 종료(커밋이나 롤백)까지의 모든 요청을 원자적으로(all or nothing)처리해주는거
	이 트랜잭션들은,ACID(원자성,일관성,격리성,지속성)을 보장해야함
		원자성:트랜잭션내에서 실행한 작업은 하나처럼 all or nothing으로 성공실패해야함
		일관성:모든 트랜잭션은 일관성있는 db상태를 유지해야함,즉 db에서 정한 무결성 제약조건을 항상 만족해야함
		격리성:동시에 실행되는 트랜잭션들이 서로에게 영향을 주지 못해야함,단 이건 격리수준설정에 따라 다를수있음
		지속성:트랜잭션이 성공적으로 끝나면 그 결과가 항상 기록되어야함
	이것들을 만족해야함
	
	여기서 트랜잭션 격리수준은
		커밋되지않은 읽기 //더티리드,즉 커밋후 실패보내기까지의 사이에도 읽을수있어서,다른스레드에서 롤백할걸 읽고 처리해버리는 문제가 있음,잘안씀
		커밋된 읽기 //부정합,한스레드에서 트랜잭션들어가고 수정하고 실패했는데,그사이에 다른스레드에서 2번읽으면 같은쿼리인데 값이 달라지는문제가 있음,
			그래도 가장많이쓰임
		반복가능한 읽기//트랜잭션이 시작되기전에 커밋된내용만 조회가능(자기보다 트랜잭션id가 낮은거)
			여기선  update부정합,팬텀리드(트랜잭션A가 인서트작업을 하고있는데,B가 A의 커밋전,커밋후를 2번 셀렉트하면 값이 달라지는거)가 일어남
			mysql의 기본값
		직렬화 가능  //읽기에도 잠금을 걸어서 격리레벨은 높은데 코스트가커서 잘안씀
	이 있음
	
	앱에서 커넥션을 만들면,db에선 그 커넥션으로 세션을 만듬(커넥션10개만들면 세션10개),
	모든 커넥션은 각각의 세션을갖고,모든 커넥션을 통한 요청은 자신의 세션을 통해 일어남
	이 세션은 커넥션을 닫거나,db에서 강제로 세션을 종료하면 종료됨
	이때 트랜잭션은 세션에 귀속되기때문에,
	한 세션내에선 트랜잭션 커밋되기 전의 데이터변경사항도 select로 읽을수있음(즉,트랜잭션외부로만 안퍼져나가고 내부에선 읽어진다는거)
	
	
	보통 트랜잭션을 사용한다는건,오토커밋을 끄고 수동커밋을 사용한다는것
	set autocommit false;
	...
	commit; rollback;
	이렇게 사용하면됨
	이때 이 수동커밋모드는 한번키면 그 세션내에서는 계속 유지됨(물론 변경은가능)
	
	db락은,트랜잭션이 걸려있는동안 해당세션말고는 건드린 로우를(테이블을 락거는경우도있는데 드뭄) 락걸어서 변경을 못하게하는것(조회도 불가능하게할수도있음)
	즉 트랜잭션끼리는 서로 간섭할수없게,먼저 로우를 선점한 트랜잭션이 사용하는걸 끝내고 커밋이나 롤백을 해야 다음 트랜잭션이 그걸 사용할수있는것
	이때 락을 획득하지못한 트랜잭션은 대기하게되는데,이때 일정시간이 넘어가면 락타임아웃이 남

	조회락은,일반적으로 기본값으로는 사용하지않음,만약 사용하고싶으면 select 마지막에 for update붙여주면됨
		select * from member for update;
	이걸 사용하면,조회시점에 락을 가져가버려서,다른세션에서 값을 변경할수없음,물론 이때도 트랜잭션이 끝나면 반환함
	이건 정산같은,트랜잭션 종료까지 반드시 값이 변하면 안되게 강제해야하는 상황에서 사용함(A쿼리와 B쿼리가 같은값이 나와야하는데 안나올수도있으니까 락이없으면)
	당연히 조회락을 걸어도 조회는 가능하고,변경만 불가능한거
	

	트랜잭션은 비즈니스로직이 있는 서비스계층에서 담당해야함(비즈니스로직을 기반으로 성공실패를 판단하고 롤백을걸어야하니까)
	
	어플리케이션에서 트랜잭션을 사용하려면,결국 커넥션이 필요하고 트랜잭션을 사용하는동안 같은커넥션을 유지해야함
	그래서 가장단순하게 해결하려면 레포지토리에서 파라미터로 커넥션을 받아서써야함(그래야 같은걸쓰니)
	그리고 레포지토리안에서 커넥션을 닫으면 안됨(닫는건 서비스에서해야하니까)
	
	그리고 서비스에서 커넥션 반환할때 오토커밋을 트루로해서 반환해야함
	
	서비스에서 코드분리할떈,예외가 다르다거나,완전히 다른애들(비즈니스로직과,그걸 하기위해 세팅하는부분이라든가)을 잘라버리는게좋음
	
	문제는 서비스로직에서 너무 많은 책임을 가지게되고,서비스계층이 엄청 지저분해짐
	그래서 스프링을 써서 이런문제를 해결할수있음


4.스프링과 문제 해결-트랜잭션
	어플리케이션에서 제일 중요한건 서비스계층임
	가장 중요하기도 하고,가장 변화도 없고 변화가 잦아도 안되는영역,
	그래서 뷰나 웹부분을 컨트롤러로 떠넘기고,db처리도 레포지토리로 떠넘긴다음에 순수 자바코드로 비즈니스로직만 있는게 이상적임
	그래서 서비스는 최대한 특정기술에 종속적이지않게 만들어야하고,레포지토리같은건 인터페이스로 생성해서 인터페이스에 의존하는것
	좋은 코드는,변경을했을때 변경의 범위가 최소화되는거,그래서 아키텍쳐고민할때 이기준으로 잡으면 도움됨
	
	그리고 예외같은건,가급적 자기꺼는 자기안에서 해결하는게 좋음,최소한 자바나 스프링의 예외로 바꿔서 줘야함,
	그래서 서비스단에 SQLException같은게 올라가면안됨
	
	근데 스프링을 안붙이고 깡으로쓰면,비즈니스로직보다 커넥션관리같은 코드들이 잔뜩 들어가게되고(어짜피 트랜잭션단위는 서비스메서드로 잡아야하니)
	커넥션을 파라미터로 보내야하고,try catch를 다 붙여야하고,예외가 누수되는 이런 문제들도 있음
	
	트랜잭션을 특정 기술에 의존적이지 않게만들려면,추상화를 하면됨(단일책임원칙을 지키자),
	이런방식으로 최종테크에 있는게,@transactional인걸보면,결국 반복되는부분이라는것과,추상화해서 di받는다는걸 알수있음
	스프링은 PaltformTransactionManager인터페이스를 기반으로,구현체들을 이미 만들어뒀음
	
	이 트랜잭션매니저는,트랜잭션추상화와 트랜잭션 동기화 두가지 역할을 함
	동기화는,결국 트랜잭션은 한메서드안에서는 같은커넥션을 계속 사용해야하니까,이걸 맞춰주는거임,즉 파라미터로 커넥션넣던걸 대신해주는거임
	이건 쓰레드로컬을 사용해서 일어나는데,얘가 멀티쓰레드상황에서 커넥션을 안전하게 동기화시켜줌(쓰레드로컬은 각 쓰레드마다 전용 저장소를 만들어줘서 이걸사용)
	
	이 트랜잭션매니저를 직접사용할땐
		Connection con = DataSourceUtils.getConnection(dataSource);
		DataSourceUtils.releaseConnection(con,dataSource);
	이렇게 하면되는데,getConnection을 하면 없으면 만들고 있으면 가져다주고,릴리즈하면 그냥 풀에 반환함(현재 쓰레드에서 저장정보를 지움)
	
	그리고 서비스에서
		TransactionStatus status = transactionManager.getTransaction(new DefaultTransactionDefinition());
		transactionManager.commit(status);
		transactionManager.rollback(status);
	이렇게 넣어주고,릴리즈는 안해도됨(커밋되거나 롤백될때 알아서함)
	
	이렇게되면,서비스에선 트랜잭션 시작과 종료만 트랜잭션매니저를 통해 선언하고,실제 트랜잭션 커넥션사용은 트랜잭션동기화매니저와 레포지토리사이의 일이 됨
	즉,서비스에선 해당기술에 대해 의존하는게아닌,트랜잭션 매니저만 의존해서 걔한테 실제 커넥션생성이나 획득등은 다 맡겨버리는거임
	
	트랜잭션매니저는,커넥션을 생성하고,이걸 오토커밋펄스로 바꾼뒤에 쓰레드로컬에다가 저장해둠
	서비스가 레포지토리에 요청을 날리면
	레포지토리는 쓰레드로컬에서 커넥션을 찾아서 작업을 해서,따로 뭘 해주지않아도 같은쓰레드니까 같은커넥션에서 작업을 하게됨
	
	이렇게 비즈니스로직이 끝나면,트랜잭션매니저에 커밋이나 롤백을 요청하면,
	트랜잭션매니저는 트랜잭션 동기화매니저에서 커넥션을 획득하고,
	이 커넥션으로 db에 커밋이나 롤백을 한다음,
	리소스를 정리함(동기화매니저를 제거,즉 쓰레드로컬을 제거,오토커밋을 true로 바꿈,con.close()로 커넥션종료나 반환을 함)
	
	이런식으로 진행됨
	
	
	트랜잭션을 사용하는 로직들을 보면,같은패턴이 반복됨
		트랜잭션시작
		비즈니스로직실행
		커밋 or 롤백
	특히 트라이캐치 반복되는게 꼴보기싫음(비즈니스로직뺴곤 다 반복됨)
	그래서 스프링에선 템플릿콜백패턴을 사용한 트랜잭션탬플릿을 제공함
	
	이건 트랜잭션매니저를 di받아서 생성자에서 생성하면됨(관례상 이렇게씀,외부빈으로 트랜잭션템플릿을 주입받아도되긴함)
		private final MemberRepositoryV3 memberRepository;
		private final TransactionTemplate txTemplate;

		public MemberServiceV3_2(MemberRepositoryV3 memberRepository, PlatformTransactionManager tm) {
			this.memberRepository = memberRepository;
			this.txTemplate=new TransactionTemplate(tm);
		}	
	그리고
	    public void accountTransfer(String fromId, String toId, int money) {
			txTemplate.executeWithoutResult((status)->{
				bizLogic( fromId, toId, money);
			});
		}
	이렇게 사용하면됨,즉 트랜잭션관련부분들을 다 알아서처리하고,중간을 람다로 받아서 실행시켜줌
	얘는 정상수행되면 커밋하고,언체크예외가 발생하면 롤백함,그래서 만약 로직에서 체크예외를 던지면
		txTemplate.executeWithoutResult((status)->{
			try{
				bizLogic( fromId, toId, money);
			}catch(SQLException e){
				throw new IllegalStateException(e);
			}
		});
	이렇게 언체크로 바꿔서 던져줘야함(이 람다식안에서 체크예외를 밖으로 던질수없게 코드가 짜져있음)
	
	체크예외는 RuntimeException을 상속받지않은 예외들인데,얘들은 복구가능성이 있는 예외라서 반드시 예외처리코드를 작성해서 처리해야함
	언체크예외는 RuntimeException를 상속받은 예외들인데,얘들은 복구가능성이 없는 예외임(널포인터익셉션등)
	
	근데 이렇게 처리해도,트랜잭션로직이 남아있긴함(txTemplate)
	그래서 관심사가 2개가 되버림
	그래서 이건 aop(프록시)로 해결함
	
	트랜잭션 aop는,아예 앞단을 새로만들고,거기로 트랜잭션을 가져가서 처리하는방식인데 이건 
		@Transactional
	을 사용해서 처리함(물론 직접 만들어도되는데,이미 있는데 왜만들어)
	이렇게 프록시를 사용해 다른곳에서 처리해버리면,서비스자체에는 비즈니스로직만 남길수있게됨
	
	이렇게되면
		클라이언트가 프록시를 호출
		프록시가 트랜잭션을 시작하고 실제 서비스호출
		서비스가 레포지토리 호출후 로직완료하고 서비스종료 후 프록시로 리턴
		서비스종료되고 프록시가 트랜잭션 종료
	이런 순서로 진행되게됨
	이러면
		@Transactional
		public void accountTransfer(String fromId, String toId, int money) {
				bizLogic( fromId, toId, money);
		}
	서비스로직은 이렇게 트랜잭션코드들은 다 외부로 빠지고 비즈니스로직만 남게됨
	그리고 이렇게할땐 주의할게,테스트코드쪽에서 스프링을 안쓰고 유닛테스트로 하면,aop가 없어서 트랜잭션이 안걸리게됨
	
	그래서 테스트에 
		@SpringBootTest
	붙이고
		@TestConfiguration
		static class TestConfig{
			@Bean
			DataSource dataSource(){
				return new DriverManagerDataSource(URL, USERNAME, PASSWORD);
			}
			@Bean
			PlatformTransactionManager transactionManager(){
				return new DataSourceTransactionManager(dataSource());
			}

		}
	이렇게 데이터소스와 트랜잭션매니저를 빈등록해주면됨
	이때 결국 aop도 트랜잭션매니저와 데이터소스가 있어야 트랜잭션을 시작하기때문에,이게 빈등록되어야함
	
	물론 기본적으로 스프링부트를 사용하면 이 데이터소스와 트랜잭션매니저를 등록해주기때문에,직접등록할필요는 없지만
	기본값이 히카리데이터소스인데 이걸 바꾸고싶다거나 하면 할수있음
	이 스프링부트가 주는걸 사용하려면 어플리케이션.프로퍼티에서 url,id,password를 등록해주면됨(맨날 세팅할때하던 그거)

	이때 진짜 aop인지 확인하려면
		assertThat(AopUtils.isAopProxy(memberService)).isTrue();
	이렇게 AopUtils를 사용해서 물어볼수있음
	
	@Transactional같이 어노테이션을 사용해서 하는걸,선언적 트랜잭션이라고 하고,
	트랜잭션 매니저나 탬플릿으로 직접 작성하는걸 프로그래밍방식 트랜잭션이라고 함
	요즘은 거의 선언적으로 사용하는데,테스트에서 가끔 프로그래밍적으로 해야할때가 있긴함
	
	스프링부트에서 자동등록하는 데이터소스는 이름이 dataSource고,만약 직접 빈으로 데이터소스를 등록하면,스프링부트는 등록하지않음
	이때 application.properties에 있는 속성들(spring.dataSource.url,username,password)를 보고 이걸가지고 등록함
	그리고 이때 url이 없으면 메모리db로 생성함
	스프링부트가 기본으로 생성하는 데이터소스는 히카리데이터소스임
	
	스프링부트가 자동등록하는 트랜잭션매니저는,이름이 transactionManager임
	얘도 직접 등록하면 스프링부트는 등록하지않음
	이떄 jpa를 사용하면 jpa트랜잭션매니저,jdbc를 사용하면 DataSourceTransactionManager를 사용해야하는데,
	스프링부트는 이걸 선택할때 현재 등록된 라이브러리를 보고 판단함
	
	그래서 테스트에서도 주입받아서쓰려면
		@TestConfiguration
		static class TestConfig{
			private final DataSource dataSource;
			public TestConfig(DataSource dataSource) {
				this.dataSource = dataSource;
			}
			@Bean
			MemberRepositoryV3 memberRepositoryV3(){
				return new MemberRepositoryV3(dataSource);
			}
		}
	이렇게 테스트클래스안에 클래스만들고 @TestConfiguration붙여서 주입받아서 쓰면됨
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	



	