1.jdbc이해
	jdbc는,각 db밴더마다 다른 연결방식을 통일하기위해,인터페이스로 래핑해서 구현을 알아서 밴더들이 하고,사용방식을 똑같게 만든거임
	여기서 구현체를 드라이버라고 함
	물론 각 db마다 다른(특히 페이징)sql같은건 각각 맞춰줘야했음(jpa사용하면 어느정도해결가능)
	
	이 db쪽에서의 발전순서는 깡jdbc->sql매퍼->orm순으로 발전해왔음
	
	jdbc커넥션만들땐
		Connection connection = DriverManager.getConnection(URL, USERNAME, PASSWORD);
	이런식으로 커넥션연결하면됨
	이러면 드라이버매니저가,현재 등록된 db드라이버를 바탕으로 해당되는 드라이버를(그 핸들러찾는거랑똑같음,입력값으로 체크하고 가능하면 T,아니면 F) 찾음
	
	그리고 커넥션을 직접연결할땐,finally로 꼭 닫아줘야함,그리고 각각 try캐치로 묶어줘야함
	
	그리고 롬복Data쓰면 EqualsAndHashcode도 같이들어있어서,안에있는값 같으면 같은객체로 취급
	
	테스트에서 예외체크는
		assertThatThrownBy(()->repository.findById(member.getMemberId()))
			.isInstanceOf(NoSuchElementException.class);
	이렇게하면됨
	
	그리고 테스트에서의 반복성을 위해서,트랜잭션을 사용해서 롤백하는식으로 동작하게해야함(jpa기본동작)

2.커넥션풀과 데이터소스 이해
	커넥션풀은,커넥션을 미리 잔뜩 만들어두고,로직에서 그걸 하나씩 가져가서 쓰고 다시돌려놓는식으로 하겠다는것(커넥션연결지연시간 줄이려고)
	커넥션풀의 기본갯수는 보통 10개고,상황에따라 늘리면됨
	그리고 사용하고나서 커넥션을 다시 반환해버리면되는거(닫는게아님)
	
	그리고 이런 커넥션을 획득하고 반환하는걸 추상화한게 데이터소스임(자바기본)
	그런데 드라이버매니저는 이런 데이터소스 인터페이스를 사용하지않아서,저거쓰다가 바꾸면 다바꿔야하는데,그래서 스프링은 드라이버매니저데이터소스라는
	데이터소스를 구현한 드라이버매니저 구현체를 제공함
	
	추가적인장점으로,데이터소스를 생성할때만 url,아이디패스워드같은걸 넣어주면되고,사용시점엔 이미 고정된상태라서 안넣어줘도된다는 장점이있음
	즉,저런 상수들같은거에 의존하지않아도됨 사용시점에서
	
	그리고 이런 커넥션풀을 생성할땐 별도의 쓰레드에서 동작하기때문에,테스트할땐 대기시간을 주든가 해야 저거테스트는 할수있음
	뭐 진짜로쓸땐 이미 깔려잇다고 가정하고하니까 상관없겟지만
	그리고 이렇게 직접 커넥션풀 받아다쓸땐,반드시 쓰고나서 반환해줘야함(con1.close(),클로즈하면 닫는게 아니라 반환을 함)
	
	만약 커넥션풀갯수 초과하게 받아가면,앞에하나가 끝날떄까지 블락됨(대기상태)
	이러다가 타임아웃나면 예외뜸



3.트랜잭션 이해
	트랜잭션은,트랜잭션 선언과 종료(커밋이나 롤백)까지의 모든 요청을 원자적으로(all or nothing)처리해주는거
	이 트랜잭션들은,ACID(원자성,일관성,격리성,지속성)을 보장해야함
		원자성:트랜잭션내에서 실행한 작업은 하나처럼 all or nothing으로 성공실패해야함
		일관성:모든 트랜잭션은 일관성있는 db상태를 유지해야함,즉 db에서 정한 무결성 제약조건을 항상 만족해야함
		격리성:동시에 실행되는 트랜잭션들이 서로에게 영향을 주지 못해야함,단 이건 격리수준설정에 따라 다를수있음
		지속성:트랜잭션이 성공적으로 끝나면 그 결과가 항상 기록되어야함
	이것들을 만족해야함
	
	여기서 트랜잭션 격리수준은
		커밋되지않은 읽기 //더티리드,즉 커밋후 실패보내기까지의 사이에도 읽을수있어서,다른스레드에서 롤백할걸 읽고 처리해버리는 문제가 있음,잘안씀
		커밋된 읽기 //부정합,한스레드에서 트랜잭션들어가고 수정하고 실패했는데,그사이에 다른스레드에서 2번읽으면 같은쿼리인데 값이 달라지는문제가 있음,
			그래도 가장많이쓰임
		반복가능한 읽기//트랜잭션이 시작되기전에 커밋된내용만 조회가능(자기보다 트랜잭션id가 낮은거)
			여기선  update부정합,팬텀리드(트랜잭션A가 인서트작업을 하고있는데,B가 A의 커밋전,커밋후를 2번 셀렉트하면 값이 달라지는거)가 일어남
			mysql의 기본값
		직렬화 가능  //읽기에도 잠금을 걸어서 격리레벨은 높은데 코스트가커서 잘안씀
	이 있음
	
	앱에서 커넥션을 만들면,db에선 그 커넥션으로 세션을 만듬(커넥션10개만들면 세션10개),
	모든 커넥션은 각각의 세션을갖고,모든 커넥션을 통한 요청은 자신의 세션을 통해 일어남
	이 세션은 커넥션을 닫거나,db에서 강제로 세션을 종료하면 종료됨
	이때 트랜잭션은 세션에 귀속되기때문에,
	한 세션내에선 트랜잭션 커밋되기 전의 데이터변경사항도 select로 읽을수있음(즉,트랜잭션외부로만 안퍼져나가고 내부에선 읽어진다는거)
	
	
	보통 트랜잭션을 사용한다는건,오토커밋을 끄고 수동커밋을 사용한다는것
	set autocommit false;
	...
	commit; rollback;
	이렇게 사용하면됨
	이때 이 수동커밋모드는 한번키면 그 세션내에서는 계속 유지됨(물론 변경은가능)
	
	db락은,트랜잭션이 걸려있는동안 해당세션말고는 건드린 로우를(테이블을 락거는경우도있는데 드뭄) 락걸어서 변경을 못하게하는것(조회도 불가능하게할수도있음)
	즉 트랜잭션끼리는 서로 간섭할수없게,먼저 로우를 선점한 트랜잭션이 사용하는걸 끝내고 커밋이나 롤백을 해야 다음 트랜잭션이 그걸 사용할수있는것
	이때 락을 획득하지못한 트랜잭션은 대기하게되는데,이때 일정시간이 넘어가면 락타임아웃이 남

	조회락은,일반적으로 기본값으로는 사용하지않음,만약 사용하고싶으면 select 마지막에 for update붙여주면됨
		select * from member for update;
	이걸 사용하면,조회시점에 락을 가져가버려서,다른세션에서 값을 변경할수없음,물론 이때도 트랜잭션이 끝나면 반환함
	이건 정산같은,트랜잭션 종료까지 반드시 값이 변하면 안되게 강제해야하는 상황에서 사용함(A쿼리와 B쿼리가 같은값이 나와야하는데 안나올수도있으니까 락이없으면)
	당연히 조회락을 걸어도 조회는 가능하고,변경만 불가능한거
	

	트랜잭션은 비즈니스로직이 있는 서비스계층에서 담당해야함(비즈니스로직을 기반으로 성공실패를 판단하고 롤백을걸어야하니까)
	
	어플리케이션에서 트랜잭션을 사용하려면,결국 커넥션이 필요하고 트랜잭션을 사용하는동안 같은커넥션을 유지해야함
	그래서 가장단순하게 해결하려면 레포지토리에서 파라미터로 커넥션을 받아서써야함(그래야 같은걸쓰니)
	그리고 레포지토리안에서 커넥션을 닫으면 안됨(닫는건 서비스에서해야하니까)
	
	그리고 서비스에서 커넥션 반환할때 오토커밋을 트루로해서 반환해야함
	
	서비스에서 코드분리할떈,예외가 다르다거나,완전히 다른애들(비즈니스로직과,그걸 하기위해 세팅하는부분이라든가)을 잘라버리는게좋음
	
	문제는 서비스로직에서 너무 많은 책임을 가지게되고,서비스계층이 엄청 지저분해짐
	그래서 스프링을 써서 이런문제를 해결할수있음
















	