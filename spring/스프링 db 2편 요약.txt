1.데이터접근기술-시작
	dto에 기능을 꼭 붙이면 안되는건아님,잇어도 상관없고,주목적이 데이터전송용이기만하면 됨(솔직히 중요하진않아서 그냥 택배상자라고 생각하면됨)
	서비스에 인터페이스를 도입하는경우는 많지않음
	인터페이스는 구현체를 바꿀 가능성이 있을때 도입하는데,보통 서비스는 만들어두고 고정일확률이 높기때문(애초에 바뀌면안되고)
	
	dto의 위치는,소유자(실제로 그걸 넣는애)의 폴더에 넣어두는게 좋음,다른데선 그냥 참조하는거니까
	즉 리포지토리에서 생성하면 리포지토리에,서비스에서 생성하고 컨트롤러로 반환하면 서비스에 두는게좋다는거
	아니면 그냥 별도의 dto폴더를 만들어도되고(여러군데서 생성하면 걍 이렇게뺴는게 나음)
	
	그리고 인터페이스에서 구현체선택은 당연히 별도의 컨피그파일만들어서 @Configration붙이고 빈등록해주면되고
	메인에서 @Import(abcConfig.class)해주면됨
	
	@EventListener()는,해당시점에 스프링이 이 메서드를 실행해주는거
	@EventListener(ApplicationReadyEvent.class)는 스프링의 초기화가 끝나고,준비가 끝나고 실행시키는거임
	@postConstruct랑 비슷한데,포스트컨스트럭터는 aop같은게 다 처리되지않은시점에 실행되는 경우가 있음(@Transactional같은)
	그래서 이벤트리스너가 더 나음
	그리고 빈등록도 해줘야하니까,메인같은데에 빈등록해두면됨(해당클래스 생성해서리턴,return new abc();)
	그리고 scalBasePackages="패키지경로"로 특정 패키지만 컴포넌트스캔을 할수있음,기본값은 자기하위전체
	
	@Profile("abc")는,이 프로필인 경우에만 해당 스프링빈을 등록함
	이 프로필은,어플리케이션 프로퍼티에서
		spring.profiles.active=프로필명
	으로 등록할수있음
	
	이걸 사용해서 dev,prod나누는거랑,
	테스트랑 메인 나눌때 두군데서 사용가능함,
	테스트의(src/test) 어플리케이션프로퍼티에 프로파일넣어두면 그거부터읽음
	
	테스트의 경우에도 인터페이스를 테스트해서,이렇게하면 구현체를 바꾸었을때도 해당 구현체가 잘 동작하는지를 쉽게 알수있어서 좋음
	그래서 구현체의 경우,최대한 인터페이스에 없는 기능들을 추가안하는게좋음
	
	db의 식별자(id)는,
		null허용불가
		유일해야함
		변해선 안됨
	3가지를 만족해야함
	근데 이때,자연키는 사용하지않는게 좋음,정책이나 이런거의 변경에 따라 어떻게될지 아무도 몰라서 인조키를 만들어서 사용하는게 좋은데
	이때 인조키엔 오토인크리즈먼트나 uuid같은걸 선택하는게좋음
	
	
2.JdbcTemplate
	sql을 직접 사용해야하는경우엔 JdbcTemplate은 괜찮은선택지임
	일단 스프링에 들어있어서 뭐 추가로  설정안해도되고,임포트만 하고,그냥 쿼리 날리면됨(커넥션같은거도 받고 반환하고 이런거도안해도됨)
	단점으로 동적쿼리가 힘듬
	
	사용할땐 JdbcTemplate생성자에서 데이터소스받아서 생성하고(데이터소스는 스프링에있으니 di받으면됨)
	기본적으로 생성할땐,키값을 생성하려면(오토인크리즈먼트)
	    String sql="insert into(item_name,price,quantity) values (?,?,?)";
        KeyHolder keyHolder=new GeneratedKeyHolder();
        template.update(con -> {
            PreparedStatement ps = con.prepareStatement(sql, new String[]{"id"});
            ps.setString(1,item.getItemName());
            ps.setInt(2,item.getPrice());
            ps.setInt(3,item.getQuantity());
            return ps;
        },keyHolder);
	이런식으로 생성해야함(db에서 id값을 받아와야해서 저렇게복잡해지는거),물론 더 나은방식이 있음
	업데이트는
		 template.update(sql,파라미터들...)
	단일조회는
	    public Optional<Item> findById(Long id) {
			String sql="select id,item_name,price,quantity where id=?";
			try {
				Item item = template.queryForObject(sql, itemRowMapper(), id);
				return Optional.of(item);
			}catch (EmptyResultDataAccessException e){
				return Optional.empty();
			}
		}
	이렇게하는데,결과가 없어도 예외,둘이상이어도 예외터지니까 주의
	전체조회는
	    String sql="select id,item_name,price from item";
        return template.query(sql,itemRowMapper());
	이렇게하고,로우매퍼는
	    private RowMapper<Item> itemRowMapper() {
			return (((rs, rowNum) -> {
				Item item=new Item();
				item.setId(rs.getLong("id"));
				item.setItemName(rs.getString("item_name"));
				item.setPrice(rs.getInt("price"));
				item.setPrice(rs.getInt("quantity"));
				return item;
			}));
		}
	그냥 값 엔티티에 담아서 리턴해주는거임(결과(rs)를 객체로 매핑해야하니까)
	근데 그냥
	    private RowMapper<Item> itemRowMapper() {
            return BeanPropertyRowMapper.newInstance(Item.class);
		}
	이런식으로 빈로우매퍼쓰는게 더편함(해당클래스의 필드명으로 매핑시킴)
	이경우엔 카멜변환을 지원함
	
	만약 동적쿼리를 넣고싶으면,if문으로 sql스트링 파싱해야함 ㅋㅋ
	그리고 순서바인딩도 이름바인딩으로 바꿀수있음
	
	동적쿼리는,그 할때 그 개같앗던거 그거 그대로해야됨,이걸 마이바티스에선 사용하기가 편해짐
	
	이름바인딩은 namedParameterJdbcTemplate로 파라미터를 바인딩할수있음
	이건 namedParameterJdbcTemplate를 jdbcTemplate대신 생성하고
	인서트는
	    String sql="insert into item(item_name,price,quantity) values (:ItemName,:price,:quantity)";

        SqlParameterSource param = new BeanPropertySqlParameterSource(item);
        KeyHolder keyHolder=new GeneratedKeyHolder();
        
        template.update(sql,param,keyHolder);
	이렇게 만들면됨
	이건 바인딩할때도 ps안만들어도되고 좀더 편하기도함
	이건,param의 인풋으로 들어온 엔티티의 필드를 보고 그거랑 같은이름으로 매핑시키는거,이거외에도 따로넣을수도있긴함
	        SqlParameterSource param = new MapSqlParameterSource()
                .addValue("itemName", updateParam.getItemName())
                .addValue("price", updateParam.getPrice())
                .addValue("quantity", updateParam.getQuantity())
                .addValue("id", itemId);
	이렇게 만들어주면됨
	아니면 걍 맵도됨
		Map<String, Object> param = Map.of("id", id);
	
	업데이트는
		template.update(sql,param);
	하면되고(똑같음)
	
	단일조회도 똑같고
		Item item = template.queryForObject(sql,param, itemRowMapper());
	전체조회도 똑같고 동적쿼리도 똑같음
	
	이 파라미터는 보통 
		Map
		SqlParameterSource인터페이스를 상속받는 
			MapSqlParameterSource
			BeanPropertySqlParameterSource
	를 사용하는데,키 밸류 구조만 맞으면 되는듯
	
	MapSqlParameterSource는 맵과 유사한데,sql타입을 저장할수있는등 좀 추가된기능이 있음,
	그리고 메서드체인(.addValue())으로 편하게넣을수있음
	
	BeanPropertySqlParameterSource는,
	자바빈프로퍼티규약(그 getItemName()이 있으면 itemName을 키로 넣고,게터값을 벨류로 넣는 그거)을 기반으로
	엔티티나 dto나 아무튼 클래스의 게터기반으로 맵을 만들어냄
	이게 젤 좋긴한데,만약 dto를 쓰는데 id값이 필요한경우같은(보통 dto엔 id가없으니까),해당 클래스에 해당필드가 없을땐 사용할수없어서
	그땐 MapSqlParameterSource를 사용해야함
	
	BeanPropertyRowMapper도 똑같이 빈프로퍼티기반으로 로우매핑을 해주는애임
	리절트셋을 빈규약에 맞춰서 set을 호출해서 넣어주는거임
	그리고 이떄는,만약 이름이 달라도,sql에서 as로 바꿔주면되고,
	언더바형식으로된건 알아서 없애고(item_name),언더바다음거를 대문자로 바꿈(itemName,카멜변환)
	
	
	simpleJdbcInsert는,인서트sql을 직접 작성하지않아도 되는 기능임
	이건
		private final SimpleJdbcInsert jdbcInsert;
	추가하고
		public JdbcTemplateItemRepositoryV3(DataSource dataSource) {
			this.template = new NamedParameterJdbcTemplate(dataSource);
			this.jdbcInsert=new SimpleJdbcInsert(dataSource)
					.withTableName("item")
					.usingGeneratedKeyColumns("id");
		}	
	이걸 생성자에 더해주고(데이터소스선택하고,테이블선택하고,pk컬럼선택하는거)
	    @Override
		public Item save(Item item) {
			SqlParameterSource param = new BeanPropertySqlParameterSource(item);
			Number key = jdbcInsert.executeAndReturnKey(param);
			item.setId(key.longValue());
			return item;
		}
	이렇게 파라미터만들고 넣으면됨(쿼리필요없음)
	
	만약 사용할일있으면,자료 마지막에 기능정리 참조하자
	

3.데이터접근기술-테스트
	테스트에 @SpringBootTest가 붙어있으면,
	상위패키지로 올라가서 메인으로간뒤 @SpringBootApplication을 찾아서(main실행클래스)그걸 기반으로 밑에있는 설정과 빈을 가져다가사용함
	즉 @Import같은거도 다 가져감
	
	기본적으로 테스트케이스를 실행시킬땐,반복가능성때문에 따로 db를 만들고(테스트전용db)실행시키는게좋음
	그래서 테스트의 리소스밑에있는 application.properties에다가 전용db 적어두면됨
	
	그리고 테스트는 서로 격리되어야하고,반복가능해야함
	그래서 트랜잭션을 사용해서 테스트가 끝나고 롤백시키는게 필요함(delete sql을 해도 이론상가능하긴 한데,중간에 예외터지면 바로 문제발생임)
	트랜잭션을 트랜잭션매니저를 통해 직접해도되지만,@Transactional쓰는게 젤 편하고좋음
	트랜잭션매니저를 통해 할땐
		@BeforeEach
		@AfterEach
	로 메서드만들어두면됨(별거아니니가 교재보자)
	
	@Transactional을 사용하면,테스트에서 사용하면 롤백하는데,커밋을 강제로 시키고싶으면 @commit붙이면됨
	이 @Transactional이 해당 클래스나 메서드에 있으면,그밑에있는게 전부 트랜잭션범위안에 들어감
	트랜잭션은 기본적으로 전파되기때문에,리포지토리에서 사용하는것도 같은트랜잭션을 사용하게됨(같은 범위안에있으면,모든게 전부 같은트랜잭션에 참여함)
	
	임베디드모드db는,스프링은 h2db를 내장하고있고,이걸 메모리모드로 켤수있음
	그래서 이걸 켜서 넣고 끝나면 메모리에서 날려버리는식으로 사용하는것,즉 라이브러리처럼 사용하는거임
	이건 db를 별도로 생성하고 운영하기 귀찮으니까 사용하는거
	
	이걸 사용할땐
		@Bean
		@Profile("test")
		public DataSource dataSource(){
			log.info("db초기화");
			DriverManagerDataSource dataSource=new DriverManagerDataSource();
			dataSource.setDriverClassName("org.h2.Driver");
			dataSource.setUrl("jdbc:h2:mem:db;DB_CLOSE_DELAY=-1");
			dataSource.setUsername("sa");
			dataSource.setPassword("");
			return dataSource;
		}	
	이걸 메인의 메인클래스에 추가하고(프로필로 구분해서 넣어줘야함)
	저기서 setUrl에서 mem으로 켜고,드라이버클래스에서 드라이버선택해준거
	DB_CLOSE_DELAY는 db커넥션이 모두 끊어지면 db도 종료되는데,-1로 넣으면 이게 막힘
	
	그리고 테이블자동생성(ddl)이 없는라이브러리면 테이블도 만들어줘야하는데,스프링부트에서 이걸 제공함(jpa쓰면 걍 엔티티보고 만들지만 sql매퍼일경우)
	test/resources/schema.sql로 생성하고(파일이름경로고정임),여기에 테이블생성쿼리를 넣어두면됨
	그러면 테스트시작전에 테이블생성하고 테스트를돌림
	
	이걸 스프링부트에서 더 간편하게 제공하는데,따로 db에 대한 설정을 안해버리면 디폴트값으로 임베디드db를 사용함
	
	즉 결론은
	따로 db설정하지말고 @Transactional만 붙이면됨
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	