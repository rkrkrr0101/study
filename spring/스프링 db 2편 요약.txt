1.데이터접근기술-시작
	dto에 기능을 꼭 붙이면 안되는건아님,잇어도 상관없고,주목적이 데이터전송용이기만하면 됨(솔직히 중요하진않아서 그냥 택배상자라고 생각하면됨)
	서비스에 인터페이스를 도입하는경우는 많지않음
	인터페이스는 구현체를 바꿀 가능성이 있을때 도입하는데,보통 서비스는 만들어두고 고정일확률이 높기때문(애초에 바뀌면안되고)
	
	dto의 위치는,소유자(실제로 그걸 넣는애)의 폴더에 넣어두는게 좋음,다른데선 그냥 참조하는거니까
	즉 리포지토리에서 생성하면 리포지토리에,서비스에서 생성하고 컨트롤러로 반환하면 서비스에 두는게좋다는거
	아니면 그냥 별도의 dto폴더를 만들어도되고(여러군데서 생성하면 걍 이렇게뺴는게 나음)
	
	그리고 인터페이스에서 구현체선택은 당연히 별도의 컨피그파일만들어서 @Configration붙이고 빈등록해주면되고
	메인에서 @Import(abcConfig.class)해주면됨
	
	@EventListener()는,해당시점에 스프링이 이 메서드를 실행해주는거
	@EventListener(ApplicationReadyEvent.class)는 스프링의 초기화가 끝나고,준비가 끝나고 실행시키는거임
	@postConstruct랑 비슷한데,포스트컨스트럭터는 aop같은게 다 처리되지않은시점에 실행되는 경우가 있음(@Transactional같은)
	그래서 이벤트리스너가 더 나음
	그리고 빈등록도 해줘야하니까,메인같은데에 빈등록해두면됨(해당클래스 생성해서리턴,return new abc();)
	그리고 scalBasePackages="패키지경로"로 특정 패키지만 컴포넌트스캔을 할수있음,기본값은 자기하위전체
	
	@Profile("abc")는,이 프로필인 경우에만 해당 스프링빈을 등록함
	이 프로필은,어플리케이션 프로퍼티에서
		spring.profiles.active=프로필명
	으로 등록할수있음
	
	이걸 사용해서 dev,prod나누는거랑,
	테스트랑 메인 나눌때 두군데서 사용가능함,
	테스트의(src/test) 어플리케이션프로퍼티에 프로파일넣어두면 그거부터읽음
	
	테스트의 경우에도 인터페이스를 테스트해서,이렇게하면 구현체를 바꾸었을때도 해당 구현체가 잘 동작하는지를 쉽게 알수있어서 좋음
	그래서 구현체의 경우,최대한 인터페이스에 없는 기능들을 추가안하는게좋음
	
	db의 식별자(id)는,
		null허용불가
		유일해야함
		변해선 안됨
	3가지를 만족해야함
	근데 이때,자연키는 사용하지않는게 좋음,정책이나 이런거의 변경에 따라 어떻게될지 아무도 몰라서 인조키를 만들어서 사용하는게 좋은데
	이때 인조키엔 오토인크리즈먼트나 uuid같은걸 선택하는게좋음
	
	
2.JdbcTemplate
	sql을 직접 사용해야하는경우엔 JdbcTemplate은 괜찮은선택지임
	일단 스프링에 들어있어서 뭐 추가로  설정안해도되고,임포트만 하고,그냥 쿼리 날리면됨(커넥션같은거도 받고 반환하고 이런거도안해도됨)
	단점으로 동적쿼리가 힘듬
	
	사용할땐 JdbcTemplate생성자에서 데이터소스받아서 생성하고(데이터소스는 스프링에있으니 di받으면됨)
	기본적으로 생성할땐,키값을 생성하려면(오토인크리즈먼트)
	    String sql="insert into(item_name,price,quantity) values (?,?,?)";
        KeyHolder keyHolder=new GeneratedKeyHolder();
        template.update(con -> {
            PreparedStatement ps = con.prepareStatement(sql, new String[]{"id"});
            ps.setString(1,item.getItemName());
            ps.setInt(2,item.getPrice());
            ps.setInt(3,item.getQuantity());
            return ps;
        },keyHolder);
	이런식으로 생성해야함(db에서 id값을 받아와야해서 저렇게복잡해지는거),물론 더 나은방식이 있음
	업데이트는
		 template.update(sql,파라미터들...)
	단일조회는
	    public Optional<Item> findById(Long id) {
			String sql="select id,item_name,price,quantity where id=?";
			try {
				Item item = template.queryForObject(sql, itemRowMapper(), id);
				return Optional.of(item);
			}catch (EmptyResultDataAccessException e){
				return Optional.empty();
			}
		}
	이렇게하는데,결과가 없어도 예외,둘이상이어도 예외터지니까 주의
	전체조회는
	    String sql="select id,item_name,price from item";
        return template.query(sql,itemRowMapper());
	이렇게하고,로우매퍼는
	    private RowMapper<Item> itemRowMapper() {
			return (((rs, rowNum) -> {
				Item item=new Item();
				item.setId(rs.getLong("id"));
				item.setItemName(rs.getString("item_name"));
				item.setPrice(rs.getInt("price"));
				item.setPrice(rs.getInt("quantity"));
				return item;
			}));
		}
	그냥 값 엔티티에 담아서 리턴해주는거임(결과(rs)를 객체로 매핑해야하니까)
	근데 그냥
	    private RowMapper<Item> itemRowMapper() {
            return BeanPropertyRowMapper.newInstance(Item.class);
		}
	이런식으로 빈로우매퍼쓰는게 더편함(해당클래스의 필드명으로 매핑시킴)
	이경우엔 카멜변환을 지원함
	
	만약 동적쿼리를 넣고싶으면,if문으로 sql스트링 파싱해야함 ㅋㅋ
	그리고 순서바인딩도 이름바인딩으로 바꿀수있음
	
	동적쿼리는,그 할때 그 개같앗던거 그거 그대로해야됨,이걸 마이바티스에선 사용하기가 편해짐
	
	이름바인딩은 namedParameterJdbcTemplate로 파라미터를 바인딩할수있음
	이건 namedParameterJdbcTemplate를 jdbcTemplate대신 생성하고
	인서트는
	    String sql="insert into item(item_name,price,quantity) values (:ItemName,:price,:quantity)";

        SqlParameterSource param = new BeanPropertySqlParameterSource(item);
        KeyHolder keyHolder=new GeneratedKeyHolder();
        
        template.update(sql,param,keyHolder);
	이렇게 만들면됨
	이건 바인딩할때도 ps안만들어도되고 좀더 편하기도함
	이건,param의 인풋으로 들어온 엔티티의 필드를 보고 그거랑 같은이름으로 매핑시키는거,이거외에도 따로넣을수도있긴함
	        SqlParameterSource param = new MapSqlParameterSource()
                .addValue("itemName", updateParam.getItemName())
                .addValue("price", updateParam.getPrice())
                .addValue("quantity", updateParam.getQuantity())
                .addValue("id", itemId);
	이렇게 만들어주면됨
	아니면 걍 맵도됨
		Map<String, Object> param = Map.of("id", id);
	
	업데이트는
		template.update(sql,param);
	하면되고(똑같음)
	
	단일조회도 똑같고
		Item item = template.queryForObject(sql,param, itemRowMapper());
	전체조회도 똑같고 동적쿼리도 똑같음
	
	이 파라미터는 보통 
		Map
		SqlParameterSource인터페이스를 상속받는 
			MapSqlParameterSource
			BeanPropertySqlParameterSource
	를 사용하는데,키 밸류 구조만 맞으면 되는듯
	
	MapSqlParameterSource는 맵과 유사한데,sql타입을 저장할수있는등 좀 추가된기능이 있음,
	그리고 메서드체인(.addValue())으로 편하게넣을수있음
	
	BeanPropertySqlParameterSource는,
	자바빈프로퍼티규약(그 getItemName()이 있으면 itemName을 키로 넣고,게터값을 벨류로 넣는 그거)을 기반으로
	엔티티나 dto나 아무튼 클래스의 게터기반으로 맵을 만들어냄
	이게 젤 좋긴한데,만약 dto를 쓰는데 id값이 필요한경우같은(보통 dto엔 id가없으니까),해당 클래스에 해당필드가 없을땐 사용할수없어서
	그땐 MapSqlParameterSource를 사용해야함
	
	BeanPropertyRowMapper도 똑같이 빈프로퍼티기반으로 로우매핑을 해주는애임
	리절트셋을 빈규약에 맞춰서 set을 호출해서 넣어주는거임
	그리고 이떄는,만약 이름이 달라도,sql에서 as로 바꿔주면되고,
	언더바형식으로된건 알아서 없애고(item_name),언더바다음거를 대문자로 바꿈(itemName,카멜변환)
	
	
	simpleJdbcInsert는,인서트sql을 직접 작성하지않아도 되는 기능임
	이건
		private final SimpleJdbcInsert jdbcInsert;
	추가하고
		public JdbcTemplateItemRepositoryV3(DataSource dataSource) {
			this.template = new NamedParameterJdbcTemplate(dataSource);
			this.jdbcInsert=new SimpleJdbcInsert(dataSource)
					.withTableName("item")
					.usingGeneratedKeyColumns("id");
		}	
	이걸 생성자에 더해주고(데이터소스선택하고,테이블선택하고,pk컬럼선택하는거)
	    @Override
		public Item save(Item item) {
			SqlParameterSource param = new BeanPropertySqlParameterSource(item);
			Number key = jdbcInsert.executeAndReturnKey(param);
			item.setId(key.longValue());
			return item;
		}
	이렇게 파라미터만들고 넣으면됨(쿼리필요없음)
	
	만약 사용할일있으면,자료 마지막에 기능정리 참조하자
	

3.데이터접근기술-테스트
	테스트에 @SpringBootTest가 붙어있으면,
	상위패키지로 올라가서 메인으로간뒤 @SpringBootApplication을 찾아서(main실행클래스)그걸 기반으로 밑에있는 설정과 빈을 가져다가사용함
	즉 @Import같은거도 다 가져감
	
	기본적으로 테스트케이스를 실행시킬땐,반복가능성때문에 따로 db를 만들고(테스트전용db)실행시키는게좋음
	그래서 테스트의 리소스밑에있는 application.properties에다가 전용db 적어두면됨
	
	그리고 테스트는 서로 격리되어야하고,반복가능해야함
	그래서 트랜잭션을 사용해서 테스트가 끝나고 롤백시키는게 필요함(delete sql을 해도 이론상가능하긴 한데,중간에 예외터지면 바로 문제발생임)
	트랜잭션을 트랜잭션매니저를 통해 직접해도되지만,@Transactional쓰는게 젤 편하고좋음
	트랜잭션매니저를 통해 할땐
		@BeforeEach
		@AfterEach
	로 메서드만들어두면됨(별거아니니가 교재보자)
	
	@Transactional을 사용하면,테스트에서 사용하면 롤백하는데,커밋을 강제로 시키고싶으면 @commit붙이면됨
	이 @Transactional이 해당 클래스나 메서드에 있으면,그밑에있는게 전부 트랜잭션범위안에 들어감
	트랜잭션은 기본적으로 전파되기때문에,리포지토리에서 사용하는것도 같은트랜잭션을 사용하게됨(같은 범위안에있으면,모든게 전부 같은트랜잭션에 참여함)
	
	임베디드모드db는,스프링은 h2db를 내장하고있고,이걸 메모리모드로 켤수있음
	그래서 이걸 켜서 넣고 끝나면 메모리에서 날려버리는식으로 사용하는것,즉 라이브러리처럼 사용하는거임
	이건 db를 별도로 생성하고 운영하기 귀찮으니까 사용하는거
	
	이걸 사용할땐
		@Bean
		@Profile("test")
		public DataSource dataSource(){
			log.info("db초기화");
			DriverManagerDataSource dataSource=new DriverManagerDataSource();
			dataSource.setDriverClassName("org.h2.Driver");
			dataSource.setUrl("jdbc:h2:mem:db;DB_CLOSE_DELAY=-1");
			dataSource.setUsername("sa");
			dataSource.setPassword("");
			return dataSource;
		}	
	이걸 메인의 메인클래스에 추가하고(프로필로 구분해서 넣어줘야함)
	저기서 setUrl에서 mem으로 켜고,드라이버클래스에서 드라이버선택해준거
	DB_CLOSE_DELAY는 db커넥션이 모두 끊어지면 db도 종료되는데,-1로 넣으면 이게 막힘
	
	그리고 테이블자동생성(ddl)이 없는라이브러리면 테이블도 만들어줘야하는데,스프링부트에서 이걸 제공함(jpa쓰면 걍 엔티티보고 만들지만 sql매퍼일경우)
	test/resources/schema.sql로 생성하고(파일이름경로고정임),여기에 테이블생성쿼리를 넣어두면됨
	그러면 테스트시작전에 테이블생성하고 테스트를돌림
	
	이걸 스프링부트에서 더 간편하게 제공하는데,따로 db에 대한 설정을 안해버리면 디폴트값으로 임베디드db를 사용함
	
	즉 결론은
	따로 db설정하지말고 @Transactional만 붙이면됨
	
4.데이터접근기술-마이바티스
	마이바티스는,이거도 sql매퍼인데 jdbcTemplate보다 좋은건 sql을 xml로 뺄수있다는것과 동적쿼리 작성이 매우 편해진다는게 있음
	그리고 쿼리가 길때,여러줄로 나눌때 +붙이고 띄울필요도없고 많이 편해짐
	동적쿼리도 그냥 <if>태그사용해서 넣으면 알아서 해줌
	
	단,스프링내장이 안돼있어서,직접 넣고 뭐 이런거해야함
	그래서 jpa쓰면 따로 깔기귀찮으니까 jdbcTemplate쓰는편(sql날릴일이 별로없기도하고)
	
	마이바티스 설정은 어플리케이션프로퍼티에
		mybatis.type-aliases-package=hello.itemservice.domain //경로넣으면 이경로에있는거 자동인식,즉 저기있는 클래스사용가능
		mybatis.configuration.map-underscore-to-camel-case=true//스네이크케이스를(언더스코어) 카멜케이스로바꿔줌
		logging.level.hello.itemservice.repository.mybatis=trace //경로마다 로그레벨설정가능
	당연히 메인에다가 적었으면,테스트에도 적어줘야함(자기밑에만 적용되니)
	
	그리고 db와 객체간의 이름이 다르면,이것도 sql에서 as쓰면됨(스네이크케이스는 자동으로 해결되는데,나머지)
	
	사용할땐,인터페이스를 만들고,위에 @Mapper를 붙이고
		@Mapper
		public interface ItemMapper {

			void save(Item item);
			void update(@Param("id")Long id, @Param("updateParam")ItemUpdateDto updateParam);
			List<Item> findAll(ItemSearchCond itemSearch);
			Optional<Item> findById(Long id);
		}
	이렇게 메서드정의하면됨(이떄 파라미터가 하나면 걍둬도되는데,둘이상이면 @Param으로 사용할이름지정을 해줘야함,하나일경우 그냥 필드네임그대로 사용)
	
	이 인터페이스의 메서드를 호출하면,xml의 해당 sql을 실행하고 결과를 돌려줌(구현체는 마이바티스가 만듬)
	xml파일은 인터페이스와 같은경로로 resources에 두면됨(경로는 맞춰줘야함)
		main/java/hello/itemservice/repository/mybais
		main/resources/hello/itemservice/repository/mybais
	이렇게 만들어야함
	xml은
		<?xml version="1.0" encoding="UTF-8"?>
		<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
				"http://mybatis.org/dtd/mybatis-3-mapper.dtd">
		<mapper namespace="hello.itemservice.repository.mybatis.ItemMapper">
			
		</mapper>
	이렇게 만든다음에 mapper안에 넣으면됨(이때 네임스페이스로 인터페이스경로를 넣어서 지정해야함)
	매퍼안에
	    <insert id="save" useGeneratedKeys="true" keyProperty="id"  >
			insert into item (item_name,price,quantity)
			values (#{itemName},#{price},#{quantity})
		</insert>
	이렇게 넣으면됨(안에있는게 실행됨)
	이때 파라미터는,인터페이스에 있는 @Param이랑 매칭되고,만약 붙이지않았고 그게 클래스면 해당 클래스의 필드명그대로 들어가게됨
	그리고 인서트의경우는,오토인크리즈먼트하려면 useGeneratedKeys="true"  keyProperty="id" 넣어주면됨
	
	즉 일반적으론
		<update id="update">
			update item
			set item_name=#{updateParam.itemName},
				price=#{updateParam.price},
				quantity=#{updateParam.quantity}
			where id=#{id}
		</update>
	이렇게들어가게됨	
	조회는
	    <select id="findById" resultType="Item">
			select id,item_name,price,quantity
			from item
			where id=#{id}
		</select>
	이렇게
	resultType으로 반환타입 적어주고(어플리케이션프로퍼티에서 설정해서 패키지전체 안적어도됨)
	동적쿼리는
	    <select id="findAll" resultType="Item">
			select id,item_name,price,quantity
			from item
			<where>
				<if test="itemName!=null and itemName != ''">
					and item_name like concat('%',#{itemName},'%')
				</if>
				<if test="maxPrice != null">
					and price &lt;= #{maxPrice}
				</if>
			</where>
		</select>
	이런식으로 if사용해서 넣으면,해당값이 참일때만 들어가고 where and 생각안해도됨(if다실패하면 where을 추가하지않고,처음and는 지워버림)
	그리고 xml이라서 <이나 >를 못써서,이거는 &lt ,&gt로 바꿔서써야함(&는 &amp임)
	
	아예 스트링처리해버리는방법도있는데,cdata검색해보면됨(단 이경우엔 <where>나 <if>를못씀)
	
	그리고 xml파일경로읽는걸 바꾸고싶으면
		mybatis.mapper-locations=classpath:mapper/**/*.xml 
	이걸 어플리케이션 프로퍼티에서 넣어두면됨
	기본적으로 리소스에서,그밑에서 찾음(테스트도 똑같이해야함)
	
	그리고 자바코드에서(인터페이스에서) 반환객체가 하나면 Item이나 Optional<Item>,여러개면 List사용하면됨
	
	사용할땐,itemMapper같은 매퍼를 만들고(@Mapper붙이면 구현체를 스프링빈에 등록해두니까 그냥 주입받으면됨) 사용하면됨
		private final ItemMapper itemMapper;

		@Override
		public Item save(Item item) {
			 itemMapper.save(item);
			return item;

		}
	이렇게 그냥쓰면됨
	그리고 설정에서
	    @Bean
		public ItemRepository itemRepository() {
			return new MyBatisItemRepository(itemMapper);
		}
	이렇게 등록하고(매퍼를 등록해주면됨,데이터소스나 트랜잭션매니저는 마이바티스가 알아서함)
	
	매퍼의 구현체 빈은,마이바티스 스프링연동모듈이 생성하는데,
	얘는 
		@mapper가 붙은 인터페이스를 검색하고,
		그거의 동적프록시객체를 생성하고,
		그 프록시객체를 스프링빈에 등록함
	이런식으로 작동함
	그리고 이 매퍼변환체는,예외변환까지 해줘서,스프링예외로 반환해줌(DataAccessException하위예외)
	
	
	즉 마이바티스를 사용하는이유는,동적쿼리때문임
	여기서 지원하는건,
		if와 
		choose+when+otherwise로 스위치문을 사용할수있음
		foreach로 컬렉션을 반복처리할수도있음,이건 좀 복잡하니 예제보자(파라미터를 리스트로 받아서,이걸 처리할수있음 in같은거)
	그리고 <where>로 동적으로 where를 추가할지말지도 알아서해주고
	
	그리고 xml대신 어노테이션에 붙일수도 있음
		@Select("select id from item where id=#{id}")
	근데 뭐 마이바티스쓰는데 사용할까싶긴함(xml로 각잡고쓰려고 쓰는거니까)
	
	그리고 #{}는 파라미터바인딩인데,만약 문자 그대로를 처리하고싶으면 ${}가 있음
	단 이건 sql인젝션에 노출되니까 사용하지않는게좋음
	
	<sql>로 sql코드조각을 재사용할수있음
		<sql id="userColumns">${alias}.id,${alias}.username  </sql>
	이렇게 만들고
		<select>
			<include refid="userColumns"><property name="alias value="t1" /> </include>
			<include refid="userColumns"><property name="alias value="t2" /> </include>
		</select>
	이런식으로 재사용할수있음(즉 프로젝션대상같은(id,username같은 컬럼들)이 중복되면 이걸 재사용할수있음)
	
	resultmaps로 as를 사용하지않고 객체와 컬럼명을 맞춰줄수있음
	별건아닌데 기니까 자료보자
	그냥 xml로 맵만드는거임
	
	그리고 마이바티스에서도 연관관계가있는 객체들을 조회해서 불러오는게 가능하긴한데(jpa처럼),
	복잡하고 공수도 많이들고 성능도 문제있어서 그냥 jpa쓰는게나음,아니면 그냥 통짜dto만들어서 두개한번에 받거나
	
5.데이터접근기술-jpa	
	비슷한건 스킵하자 어짜피 다본건데
	설정은
		implementation'org.springframework.boot:spring-boot-starter-data-jpa'
	추가(jdbc도 없어도됨,안에들어있음)
	jpa트랜잭션매니저같은건 스프링부트가 알아서해줌
	
	JPA에서 중요한건
		객체와 테이블의 매핑(일대다에선 연관관계의 주인이 다에 있어야한다던가)
		페치조인과 컬렉션 연관관계조회()+lazy설정
		더티체킹
	이 3가지인데,젤중요한건 객체와 테이블의 매핑임
	
	jpa를 사용할땐
		private final EntityManager em;
	를 di받고 사용하면됨
	jpql사용시엔
	    String jpql="select i from Item i";
        List<Item> res = em.createQuery(jpql, Item.class).getResultList();
        return res;
	이렇게 날리면되고
	동적쿼리는 쿼리dsl쓰자
	
	jpql은 엔티티객체(엔티티가 붙어있는 하나의 클래스의 모든 객체들,엔티티와 테이블이 같은급이라고 보면됨)를 대상으로 sql을 돌리는거
	
	그리고 일반적으론,서비스레벨에서 트랜잭션을 걸어야함(여러 레포지토리 로직들이 묶여서 트랜잭션이 걸려야하기때문)
	그리고 테스트코드에선 트랜잭션롤백되기때문에,업데이트쿼리가 나가지않음(표시안됨)
	
	jpa의 한계는,동적쿼리가 머리아프다는것
	
	jpa의경우 예외가 발생하면,jpa예외가 터지는데,이걸 스프링예외로 바꿔줘야함(스프링데이터jpa사용하면 자동으로 예외변환해줌)
	jpa는 PersistenceException과 IllegalStateException,IllegalArgumentException 3종류의 예외를 발생시킴
	이걸 변환하는건,@Repository를 붙이면 자동으로 예외변환aop가 적용되면서 자동으로 변환이됨
	
6.데이터접근기술-스프링 데이터 jpa	
	스프링데이터는 
		crud자동화
		같은인터페이스
		페이징처리
		메서드이름으로 쿼리생성
		mvc에서 id값만 넘겨도 도메인클래스로 바인딩
	등을 해줌
	여기서 젤 중요한건
		공통인터페이스
		쿼리메서드(메서드명으로 쿼리자동생성+@Query에 jpql만넣으면 그거실행)
		페이징처리
	임,이게 메인기능임
	그리고 쿼리메서드에서 깡sql을 넣을수도있음
	공통인터페이스는
	그냥 jpaRepository만 인터페이스에 상속받으면,구현체는 알아서 만들어주고,어지간한 crud는 다들어있음
	이건
		public interface ItemRepository extends JpaRepository<엔티티,엔티티id클래스>{}
	이렇게 만들면됨
	
	기본쿼리메서드는 걍 자잘한건만들만한데,조건여러개되면 ㄹㅇ개길어지니까 @Query에 쓰는게좋음
		List<Item> findByPriceLessThanEqualAndItemNameLike(Integer price, String itemName);
	이런건너무기니까
		@Query("select i from Item i where i.itemName like :itemName and i.price<=:price")
		List<Item> findItems(@Param("itemName" )String itemName,@Param("price" ) Integer price);	
	이런식으로 뽑아서 이름줄이는거
	
	그리고 스프링데이터jpa도 동적쿼리에 약해서,이런건 queryDSL로 해결해야함
	그리고 스프링데이터jpa 레포지토리는 이미 jpaRepository를 받고있어서,직접추상화하기 힘들기때문에,
	위에 추상화전용으로 클래스를 하나 더둬서 그거로 추상화를 하면됨
		public class JpaItemRepositoryV2 implements ItemRepository {
			private final SpringDataJpaItemRepository repository;
			...
		}
	그리고 걍
	    public void update(Long itemId, ItemUpdateDto updateParam) {
			Item findItem = repository.findById(itemId).orElseThrow();
			findItem.setPrice(222);
		}
	이런식으로 만들어서 저걸사용하면됨
	
7.데이터접근기술-queryDSL	
	queryDSL은 동적쿼리를 해결+쿼리를 자바로 타입세이프하게 작성할수있게 해주는 프레임워크임
	아예 null을 넣으면 무시하게 만들어서,걍 분기안타고 편하게 동적쿼리를 만들수있고,페이징도 편함
	그래서,스프링데이터가 약한 조회부분을(특히 동적조회)queryDSL로 채운다는느낌
	
	설정할땐,빌드툴 그래들기준 아더에 컴파일자바한번누르면 자동으로 빌드밑에 q파일생성됨(인텔리제이에서 메인이나 테스트실행시키면 걍생김)
	빌드툴 인텔리제이면 그냥 main실행하면생김(src/main/generated밑에 생김)
	
	삭제할땐 그래들에서 클린하면 빌드폴더채로 날려버림
	
	사용할땐,JPAQueryFactory가 있어야하는데
		public JpaItemRepositoryV3(EntityManager em) {
			this.em = em;
			this.query = new JPAQueryFactory(em);
		}
	이렇게 di받으면됨
	그리고 걍
		List<Item> result = query
			.select(item)
			.from(item)
			.where(itemNameLike(itemName),priceLoe(maxPrice))
			.fetch();
	이런식으로 만들고,where내부함수는
	    private BooleanExpression itemNameLike(String itemNameCond) {
			if( itemNameCond==null || itemNameCond.equals("")) {
				return null;
			}
			return item.itemName.like("%"+itemNameCond+"%");
		}
	이런식으로 만들면됨
	즉 where안에 널이들어오면 무시하니까 그걸 이용하는거
	where안에 ,로 구분되면,and로 작동함
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	