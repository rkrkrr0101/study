1.웹 애플리케이션 이해
	웹서버는,정적 리소스를 제공(html,css같은걸 배포하는 nginx,apache같은거)
	웹 어플리케이션 서버(WAS)는 웹서버+코드를 수행해서 애플리케이션로직을 수행할수있음(톰캣)
	
	보통 웹 시스템은,was와 db만 있으면 기본적시스템 구성은 다됨(동작시켜볼수있음)
	근데 애플리케이션로직이랑 정적 리소스를 같이두면,비용절감이 안됨
	그리고 was장애시 오류화면노출도 불가능함
	
	그래서 일반적으로,웹서버를 앞에두고,was를 뒤에둬서 웹서버와 was가 통신해서 받아가는식으로 처리함
	이러면 스케일링자체도 쉬위지고 좋은게많음(오류화면도 띄울수있고)

	서블릿은,공통되는 로직들을 전부 처리해줌(tcp연결과 http요청메시지 파싱 등)
	urlPatterns에 해당되는 url이 호출되면(http메시지에 있으면),그 안에있는 로직을 실행시켜줌
	그 안에 로직은,
	HttpServletRequest request,HttpServletResponse response 를 받아야함(각각 req와 res)
	정확히는,서블릿은 http요청메시지를 파싱해서 req를 만들고,res를 파싱해서 http응답메시지를 만드는거
	요청이 들어오면 req와 res를 만들고,응답할땐 res만 던지는식
	
	톰캣처럼 서블릿을 지원하는 was를 서블릿 컨테이너라고 함
	이 컨테이너는,서블릿객체를 생성,초기화,호출,종료하는 생명주기를 관리하고,
	서블릿은 싱글톤으로 관리됨(공유변수주의해야함)
	jsp도 서블릿으로 변환되고,동시요청을 위한 멀티쓰레드처리도 지원함
	
	쓰레드가 서블릿객체를 호출하는식으로,멀티쓰레드가 동작함(동시요청이 들어오면,쓰레드를 생성하고,걔가 서블릿을 호출하는것)
	각각의 쓰레드는 한줄한줄 절차지향처럼 읽음
	
	이떄 쓰레드갯수에 여러방식이 있는데,
		요청시마다 쓰레드생성(단점으로 생성비용이 비싸고,요청이 너무많이오면 oom으로 서버죽음)
		쓰레드풀(쓰레드를 n개 미리생성해두고,거기서 꺼내다가 쓰고나서 돌려놓는거,장점은 서버의 한계만큼까지만 생성하면,다운안되게 계산을 할수있음)

	쓰레드풀에서,was의 주요 튜닝포인트는 최대쓰레드임
	이게 너무 낮으면,서버리소스는 여유롭지만 클라이언트는 금방 응답지연되고
	이게 너무 높으면,oom뜨거나 쓰로틀링걸림
	
	장애발생시엔,
		클라우드면 일단 서버갯수부터 스케일링하고,이후 튜닝
		클라우드가 아니면,튜닝에 목숨걸어야함
	튜닝은,최대한 실제서비스와 유사하게 성능테스트를 시도해보면됨(nGrinder같은 툴로)
	
	결국 중요한건,멀티쓰레드를 was가 알아서 지원해주니까,싱글톤(서블릿,빈)인거만 신경쓰면됨(예전에 쓰레드만든다고 머리터졌는데 세상좋아졌다)
	
	html에서는 was가 정적리소스를 뱉거나,아니면 동적으로 html을 생성해서 전달하거나,api 세가지 방식이 있음
	이때 api는
		http js에서 호출
		모바일 클라이언트에서 호출
		다른 서버에서 호출
	이 3가지경우에서 사용됨
	api는 주로 json형식으로 통신
	
	서버사이드렌더링은,html 최종결과를 서버에서 생성해서 웹브라우저에 전달,
	정적화면에 사용,타임리프같은걸 사용
	
	클라이언트사이드렌더링은,html결과를 js를 사용해 웹브라우저에서 동적으로 생성해서 적용
	주로 동적화면에 사용하고,필요한부분만 리랜더링해서 갱신하는거(내가 나무실시간에서 한거)

	뷰템플릿은,html을 편하게 생성하는 뷰기능
	jsp->타임리프로 넘어옴

2.서블릿
	스프링부트는 서블릿을 등록할수있게 @ServletComponentScan을 지원함(쓸일은없을듯)
	서블릿 등록은 
		@WebServlet(name = "helloServlet",urlPatterns = "/hello")
		컨트롤o의 서비스(자물쇠잠긴거)등록후 내부에구현
	붙이면됨
	
	request.getParameter("abc")로 쿼리파라미터 조회가능
	res추가시엔
	    response.setContentType("text/plain");
        response.setCharacterEncoding("utf-8");
        response.getWriter().write("hello"+abc);
	이렇게 컨텐츠타입 정하고,텍스트면 인코딩정하고,저렇게 바디에 적으면됨

	main/resources/application.properties에서
		logging.level.org.apache.coyote.http11=debug
	넣어주면 로그를 디버그레벨로 올려서,http요청메시지볼수있음
	물론 운영서버는 저렇게하면안되고,개발환경에서만
	
	그리고 content-length같은건 was가 알아서 넣어줌
	
	서블릿은,http요청메시지를 파싱해서 httpservletRequest객체에 넣어서 제공해줌
	그리고 추가적으로,해당 http요청이 시작하고,끝날때까지 유지되는 임시저장소로 사용할수도 있음
		request.setAttribute(name,value)
		request.getAttribute(name)
	이렇게 저장,조회하는거,이렇게 지역변수가 할일을 싱글톤상태에서 사용할수있음
	세션관리기능도 있음
		request.getSession(create:true)
	그리고 httpservletRequest,httpservletResponse 둘 다 http요청,응답메시지를 기반으로 어댑팅된거니까 요청응답메시지를 알아야함

	req읽어올땐
		req.getMethod()
		req.getRequestURI()
		
	이런식으로 들고오면됨
	헤더전체읽을땐
		req.getHeaderNames().asIterator().
			forEachRemaining(headerName -> System.out.println("h = " + headerName));
	이렇게 이터레이터써서 읽으면됨
	그리고 값 가져오는건
		req.getServerName()
		req.getServerPort()
	로 호스트를 파싱해서 꺼낼수있고,
		req.getLocale()
	로 최우선적으로 원하는 언어(accept-Language)를 꺼낼수있음
	전부다꺼내려면
		req.getLocales().asIterator().
			forEachRemaining(headerName -> System.out.println("h = " + headerName));
	이렇게 getLocales를 사용하면 다 꺼낼수있음
	
	쿠키조회는
		Cookie cookie:req.getCookies()
	로 꺼내고
		cookie.getName()
		cookie.getValue()
	로 이름과 값을 읽을수있음
	쿠키는 getCookies() s붙었으니까 여러개가 들어오니까,여기서 자기가만든거 골라쓰면됨
	
	컨텐츠정보는
		req.getContentType()
		req.GetContentLength()
		req.getCharaterEncoding()
	로 받아올수있음

	물론 그냥
		req.getHeader("host")
	이렇게 getHeader로 꺼내는게 젤편하긴할듯


	req데이터에서 정보전달방식은
		get-쿼리파라미터
			/url?키1=값1&키2=값2
			검색,필터,페이징등에서 사용
		post-html form
			content-type:application/x-www-form-urlencodded
			메시지바디에 쿼리파라미터(키1=값1&키2=값2) 형식으로 전달
			회원가입,상품주문등에서 html form으로 사용
		http message body에 직접 데이터를 담아서 요청
			http api에서 주로 사용,json,xml,text
			데이터형식은 주로 json 사용
			post,put,patch


	쿼리파라미터는 URL에 ?를 시작으로 보내고,추가파라미터는 &로 구분하면됨
	쿼리파라미터를 전부꺼내려면
		req.getParameterNames()
	하면되고
	
	전체출력할땐
		parameterNames.asIterator().
			forEachRemaining(h -> System.out.println(h + "=" + req.getParameter(h)));
	이렇게 하면됨
		req.getParameter(h)
	로 해당파라미터이름을 꺼낼수있음


	그리고 ?username=hello&age=20&username=hello2
	이렇게 같은 이름으로 2개를 넣을수도있음
	이걸 뽑을땐
		req.getParameterValues("username")[1]
	이걸써서 이렇게 배열로뽑을수있음
	근데  이렇게 쓰면 헷갈리는데 이렇게쓰진않을거같다
	일단 이렇게됐을때 getParameter를 쓰면,처음넣은걸 반환하는듯

	html form이랑 쿼리파라미터랑은 서로 호환이 돼서,form도
		req.getParameter
	로 다꺼내면됨
	
	즉,클라입장에선 둘이 다른데,서버입장에선 둘다 똑같이 처리할수있음
	이 둘을 구분해야하면,content-type이 있나없나로 구분하면됨
	get은 바디가 없으니 content-type이 없고,form은 바디에 넣으니 content-type이 'application/x-www-form-urlencodded'임

	요청메시지바디에 데이터 담아서보낼땐,보통 json사용
	post,put,patch에서 주로 사용됨()
	
	바디에서 단순텍스트를 받고,이걸 꺼낼땐
	    ServletInputStream inputStream = req.getInputStream();
        String messageBody = StreamUtils.copyToString(inputStream, StandardCharsets.UTF_8);
	이렇게 getInputStream으로 받아서,StreamUtils.copyToString로 스트링으로 바꿔주면됨
	
	json을 받고,꺼낼땐,
	보통 json은 데이터클래스를 만들어서(도메인 클래스)사용함
	일단 텍스트로 그냥 받고꺼낼땐
	    ServletInputStream inputStream = req.getInputStream();
        String messageBody = StreamUtils.copyToString(inputStream, StandardCharsets.UTF_8);
	이렇게 똑같이꺼내면되고(어짜피 텍스트니까)

	데이터클래스로 꺼낼땐
		private ObjectMapper objectMapper = new ObjectMapper();
		HelloData helloData = objectMapper.readValue(messagebody, HelloData.class);
	이런식으로 꺼낼수있음(readValue의 2번째 매개변수에 클래스를넣으면,거기맞는 게터세터형식으로 넣어서 나옴)		


	httpservletResponse객체는
		응답메시지를 생성해주고(응답코드지정,헤더생성,바디생성)
		편의기능(content-type,쿠키,리다이렉트)
	등을 쉽게 지정할수있음
	
	응답코드지정은
		resp.setStatus(200);
		resp.setStatus(HttpServletResponse.SC_OK); //200상수
	이런식으로 넣을수있음
	컨텐츠타입은
		resp.setContentType("text/plain");
		resp.setCharacterEncoding("UTF-8");
	그외 각종 헤더입력은
		resp.setHeader("Cache-Control", "no-cache,no-store,must-revalidate");
		resp.setHeader("헤더명", "헤더값");
	사용자 지정 헤더도
		resp.setHeader("abcd123", "ttt123");
	이렇게 넣으면됨
	
	쿠키는
		Cookie cookie=new Cookie("mycookie","good")
		cookie.setMaxAge(600);
		resp.addCookie(cookie)
	이렇게 넣을수있음
	
	리다이렉트(location헤더+302상태코드)는
		resp.sendRedirect("/basic/hello-form.html");
	로 넣을수있음
	
	메시지바디에 뭐 적을땐
		resp.getWriter().println("ㅎㅇ요");
	이렇게 적으면됨
	
	
	html 응답메시지도
		단순텍스트응답(resp.getWriter().println(""))
		HTML응답
		HTTP API-messageBody json 응답
	이렇게 있음
	
	html보낼땐
		resp.setContentType("text/html"); //컨텐츠타입 html로
        resp.setCharacterEncoding("UTF-8");//인코딩정하고

        PrintWriter writer = resp.getWriter();
        writer.println("<html>");
		... html작성
	이렇게 보내면됨
	
	json으로 보낼땐
        resp.setContentType("application/json");
        resp.setCharacterEncoding("UTF-8");

        HelloData helloData = new HelloData();
        helloData.setUsername("afa");
        helloData.setAge(30);

        String result = objectMapper.writeValueAsString(helloData);
        resp.getWriter().write(result);	
	이렇게 객체생성하고,오브젝트매퍼로 스트링으로바꿔서 적으면됨(이러면 변수명을 getter콜해서 키값으로 만들어서 json형식으로 만듬)



3.서블릿,jsp,mvc패턴
	이렇게하면
		public List<Member> findAll() {
			return new ArrayList<>(store.values());
		}
	저걸 조작해도 스토어엔 영향을 안줌(DTO)
	
	배열안에 있는 멤버들 검증할땐
		List<Member> result = memberRepository.findAll();
		Assertions.assertThat(result).contains(member1, member2);

	서블릿에서 html보내는건 진짜불편하다->템플릿엔진의 등장
		템플릿엔진=html에 코드넣기
		서블릿은 코드에 html넣기
	대표적 템플릿엔진에 jsp,타임리프등이 있음
	
	jsp는
		<%@ page contentType="text/html;charset=UTF-8" language="java" %>
	가 맨위에 꼭 있어야함
	jsp에서 코드실행시킬땐 <% %>사이에 넣으면되고
	코드를 출력할땐
		<%= %>
	사이에 넣으면됨
	임포트는 맨위에 
		<%@ page import="hello.servlet.domain.member.Member" %>
	그리고 jsp에서는 request,response가 이 단어 그대로 문법상으로 지원이 됨
	out도 예약어
		out.write(<head>)

	jsp는 서블릿보다 나아지긴했는데,일단 html이랑 코드랑 붙어있는게 불편하고(관심사의 분리가 안됨)
	컨트롤러와 뷰가 붙어있어야하는거도 불편함
	
	이래서 나온게 mvc패턴
	하나의 서블릿이나 jsp만 가지고 처리하던걸,컨트롤러와 뷰로 나눈걸 말함
	
	나눈 이유는,일단 한곳에 코드가 너무많이 몰려있기도 하고,중요한건 변경주기가 서로 다르기때문임
	ui를 변경하는것과 비즈니스로직을 수정하는일은 빈도수가 다르고,서로에게 영향을 주지 않기때문
	
	컨트롤러는 http요청을 받아서 파라미터를 검증하고,비즈니스로직을 실행함,그리고 뷰에 전달할 결과 데이터를 조회해서 모델에 담음(서블릿)
	모델은 뷰에 출력할 데이터를 담아둠,뷰가 필요한 데이터를 모두 모델에 담아서 전달해줘서,뷰는 비즈니스로직이나 데이터접근을 몰라도되고,렌더링만 하면됨(req)
	뷰는 모델에 담겨있는 데이터를 사용해서 화면을 그리는일만 함(jsp)
	
	즉,원시적인 mvc는
		사용자가 http로 컨트롤러를 호출
		컨트롤러는 모델에 데이터를 담음
		컨트롤러는 뷰 로직을 실행함
		뷰 로직은 모델에서 데이터를 가져가서 화면을 그림(보통 매개변수로 모델을 던져줌)
	뷰에서 필요한 모든 데이터는 모델에서 꺼내가야하고,뷰가 외부일을 알면 안됨
	
	여기서 컨트롤러가 하는일이 너무 많다고,분리한게 컨트롤러,서비스,레포지토리임
		컨트롤러는 웹쪽의 입력을 받아서 서비스를 호출해서 결과값을 모델에 넣고 뷰를 호출하는 책임만 받고(말그대로 컨트롤하는일만 담당함),
		서비스가 비즈니스로직을 수행하는 책임
		레포지토리가 데이터 접근을 수행하는 책임
	을 맡음
	
	req에 값을 넣고뽑을땐 
		req.setAttribute()
		req.getAttribute()
	로 쓸수있음(모델로 쓸때)
	
	컨트롤러에서 뷰로 이동할때
		 RequestDispatcher dispatcher = req.getRequestDispatcher(viewPath);
		 dispatcher.forward(req,resp);
	로 이동가능(다른서블릿이나 jsp로 이동하는기능,서버내부에서 다시 호출이 발생함,즉 리다이렉트가 아님)
	
	리다이렉트는 클라이언트로 다시 갔다가 다시올라오는것,클라이언트가 인지할수있음,
	forward는 서버내부에서 콜하는것,클라에는 영향을안줌,즉 상단의 url이 안바뀜
	
	html에서 action=''이 절대경로가 아닌 상대경로면(/members/save는 절대경로,save는 상대경로),
	현재 url을 기준으로 /save를 붙여서 찾음
	즉
		mvc/members/new-form ->상대경로save호출 ->mvc/members/save
	일반적으론 절대경로사용함
	
	/WEB-INF경로안에 jsp가 있으면,이건 외부에서 직접 호출할수없고,
	서버내부에서 컨트롤러를 통해서만 접근할수있음(이 경로안에 있는 모든 리소스가 직접호출불가)

	jsp에서
		${}
		${member.id}
	이렇게하면,req안에 있는 해당 애트리뷰트를 접근할수있음(해당 애트리뷰트의 getter를 호출),이걸 프로퍼티접근이라고함

	jsp내에서 foreach돌려서 안에꺼 꺼내야할때
		<%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>
	위에 선언하고
		<c:forEach var="item" items="${members}">
			<tr>
				<td>${item.id}</td>
				<td>${item.username}</td>
				<td>${item.age}</td>
			</tr>
		</c:forEach>	
	이렇게 forEach를 돌릴수있음
	
	
	이렇게 서블릿과 jsp를 사용해서 mvc를 적용하면,컨트롤러단과 뷰단을 완전히 분리할수 있음
		근데 컨트롤러단에서의 중복(forward같은)과,
		viewPath의 중복(프리픽스와 서픽스),
		템플릿엔진변경시 코드를 다 갈아야한다는점,
		req와 res를 사용하지않을때(특히 res),
		테스트코드작성이 어려움
		공통처리가 어려움(제일 큰 단점,반드시 콜해야하는걸 까먹고 하지않았을때)
	단점이 있고
	가장 큰 문제는 공통처리임
	그래서 나온게,컨트롤러 호출 전에 공통기능을 처리하는,프론트 컨트롤러 기능임
	즉,api게이트웨이같은 컨트롤러를 두고,걔가 공통기능들을 다 처리하고 나서 뒤에 진짜컨트롤러들을 url에 맞게 호출하는식
	이게 스프링mvc의 핵심임
	
	
4.mvc 프레임워크 만들기	
	프론트컨트롤러 패턴은,모든 http요청을 한군데서 받아서,거기서 모든 공통로직을 실행시키고나서 각 url에 맞게 배분하는거임
	프록시라고 보면될듯
	
	서블릿으로 구현할땐,얘만 서블릿으로 구현하고 나머지 컨트롤러는 서블릿을 사용하지않아도됨(어짜피 얘가 다받고 호출할거니까)
	
	url매핑정보같은경우엔 어디다 모아두고 거기서 조회하는식
	
	프론트컨트롤러에서 url 전부 받을떈
		@WebServlet(name = "frontControllerServletV1", urlPatterns = "/front-controller/v1/*")
	이렇게 와일드카드로 현재 경로 밑에걸 전부 받으면됨
	
	그리고
	생성자로 경로들을 지정해둔뒤
		private Map<String, ControllerV1> controllerV1Map = new HashMap<>();
		public FrontControllerServletV1() {
			controllerV1Map.put("/front-controller/v1/members/new-form", new MemberFormControllerV1());
			controllerV1Map.put("/front-controller/v1/members/save", new MemberSaveControllerV1());
			controllerV1Map.put("/front-controller/v1/members", new MemberListControllerV1());
		}	
	서블릿 내에서 url을 받아서 해당 컨트롤러를 꺼내면됨
		String requestURI = req.getRequestURI();
		ControllerV1 controller = controllerV1Map.get(requestURI);
	
	없을경우 예외처리해주고
	    if (controller == null) {
            resp.setStatus(HttpServletResponse.SC_NOT_FOUND);
            return;
        }
	해당 컨트롤러 실행
		controller.process(req, resp);
	
	
	아키텍처 개선시,단계적으로 하나씩(구조건드릴땐 구조만,코드건드릴땐 코드만)해야함
	구조개선하고 커밋하고 동작확인하고,다음날부터 코드디테일개선하는식
	
	컨트롤러에서 뷰로 이동할때도 위에서 map만들어서 get하는거처럼 전담객체를 만들어서 똑같이할수있음(컨트롤러가 뷰 객체를 프론트컨트롤러에 반환하는식)
	
	그리고,하위 컨트롤러에선 req,res가 필요가 없음,
	어짜피 데이터만 받으면되는데 이거만 따로 map으로 받는게 더 테스트도 그렇고 편함(서블릿 종속성 제거)
	그래서 모델과 뷰가 묶여있는 모델뷰를 반환받고,모델을 떼서 뷰.렌더에 넣어주면됨
	
	그리고 뷰같은경우,겹치는 경로랑 확장자를 묶어서,경로변경이 일어나도 한군데서만 수정할수있게 하면 편함(뷰리졸버)
	
	req파라미터 전부 꺼내서 넣을땐
		Map<String, String> paramMap = new HashMap<>();
        req.getParameterNames().asIterator()
                .forEachRemaining(paramName -> paramMap.put(paramName, req.getParameter(paramName)));
	
	그리고 이런건 메서드로 뽑는게 좋음(컨트롤알트m)
	
	즉,컨트롤러에서 req를 맵으로 받고,모델뷰는 뷰이름과 모델(req대체,의존성제거목적)을 받은뒤,
	프론트컨트롤러는 req를 맵으로 바꿔서 하위컨트롤러를 콜함
	하위컨트롤러에선 처리할거 처리한후 뷰이름과 짬처리할데이터들을 모델에 담아서 모델뷰를 만들어 리턴함
	그럼 프론트컨트롤러에서 뷰리졸버로 뷰경로를 만들고,뷰를 생성함
	그리고 뷰에 모델을 던져서,
	뷰는 그 모델을 가지고 req에 setAttribute하든 뭘하든(jsp는 req에 넣는게 편함,템플릿엔진마다 다름) 해서 화면을 그림
	
	
	근데 이렇게하면,실제 구현할때 객체생성하고 반환하는부분이 귀찮음
	어짜피 모델뷰는 하는게 뷰이름+모델이니까,뷰이름만 반환하면되니,그렇게 객체생성을 없앨수있음
	
	/**엔터하면 현재파라미터와 리턴값 주석으로나옴
	
	자바에서 map은,얕은복사라서 매개변수로 넘겨주고 변경이 일어날경우,어디서든 그값이 적용됨
	
	만약 인터페이스를 여러개 쓰고싶으면,어댑터 패턴을 사용해서 구현하면됨
	즉 핸들러 어댑터를 구현해서,입력값에 따라 핸들러어댑터를 찾아서,그걸 사용해서 조회하면,핸들러어댑터가 컨트롤러를 호출해서 리턴을 받는식
	즉,직접 컨트롤러를 호출하는게 아닌,핸들러가 컨트롤러를 호출하는방식
	사실상 핸들러가 컨트롤러라고 봐도되는데,핸들러인 이유는 컨트롤러보다 더 넓은 범위를(컨트롤러를 포함한)처리할수있기때문
	
	어댑터를 사용하면,무조건 출력결과값을 맞춰야함
	만약 해당 컨트롤러의 출력이 거기 맞지 않으면,어댑터가 생성해서라도 맞춰서 반환해야함

	어댑터가 해당 인스턴스를 지원하는지 확인할땐
	    public boolean supports(Object handler) {
			return (handler instanceof ControllerV3);        
		}
	이렇게하면됨(bool값)
	
	알트 쉬프트 인서트=세로편집모드(엑셀블록선택처럼 선택됨)
	
	즉 어댑터를 사용하면,입출력형식을 맞출수있어서,여러 컨트롤러를 쓰고싶은걸 골라쓸수있어짐
	즉,핸들러어댑터의 인터페이스에만 의존하니까 구현클래스변경이 쉬워짐
	
5.스프링mvc 구조이해
	스프링에서 이름은
		프론트컨트롤러->DispatcherServlet
		handlerMappingMap->HandlerMapping
		ModelView->ModelAndView
	중요한건 DispatcherServlet
	얘도 프론트컨트롤러패턴이고,얘가 스프링mvc의 핵심임
	스프링부트는,DispatcherServlet을 서블릿으로 자동등록하면서,
	urlPatterns="/"에 매핑함(더 자세하게적은게 우선순위가 높아서 다른서블릿도 작동하는거)
	
	그리고 DispatcherServlet의 부모에 가보면,service를 오버라이드 해둬서,
	이걸시작으로 여러메소드가 호출되면서 DispatcherServlet.doDispatch()가 호출됨
	얘가 핵심인데,얘는 우리가 만들었던 프론트컨트롤러랑 비슷하게 동작함
		핸들러조회
		핸들러어댑터조회
		핸들러어댑터실행->어댑터를통해 핸들러실행->모델앤뷰 반환
		뷰 렌더링호출->뷰 리졸버로 뷰찾기->뷰 반환
		뷰 렌더링
	순서임
	
	스프링mvc의 가장 큰 강점은,DispatcherServlet을 변환하지않고 원하는 기능을 변경하거나 확장할수있음
	대부분이 인터페이스로 돼있어서,이 인터페이스를 구현해서 DispatcherServlet에 등록하면,커스텀 컨트롤러생성이 쉬움(커스텀이니까 안하는게좋지만)
	
	컨트롤러가 호출되려면
		핸들러매핑에서 컨트롤러를 찾고(스프링빈의 이름으로 핸들러를 찾을수있는 핸들러 매핑이 필요)
		핸들러매핑으로 찾은 핸들러를 실행할수있는 핸들러 어댑터가 필요(해당 인터페이스를 실행할수있는 어댑터를 찾아서 실행)
	
	스프링부트를 쓰면,자동으로 등록하는 핸들러매핑과 어댑터는(위부터 우선순위높음)
	핸들러매핑은
		RequestMappingHandlerMapping// 애노테이션기반의 컨트롤러인 @RequestMapping에서 사용
		BeanNameUrlHandlerMapping //스프링빈이름으로 핸들러찾음
	BeanNameUrlHandler는,@Component("/url") 저 이름으로 스프링빈이 등록되면,저 이름의 스프링빈을 찾는거(url이름의)
	핸들러 어댑터는(위부터 우선순위높음)
		RequestMappingHandlerAdapter// 애노테이션기반의 컨트롤러인 @RequestMapping에서 사용
		HttpRequestHandlerAdapter //httpRequestHandler 처리
		SimpleControllerHandlerAdapter //Controller 인터페이스(어노테이션이 아닌 과거에 쓰던거)처리
	
	즉 실행순서는
		1.핸들러 매핑의 우선순위대로 실행해서 핸들러를 찾고
		2.찾은 핸들러를 가지고 핸들러어댑터의 supports를 우선순위대로 신행해서 맞는걸 찾고
		3.핸들러어댑터에 핸들러를 들고 실행후 결과반환(디스패쳐서블릿이)
	
	뭐 실제로 쓰는건 @RequestMapping이겠지만
	
	뷰 리졸버는,application.properties에서
		spring.mvc.view.prefix=/WEB-INF/views/
		spring.mvc.view.suffix=.jsp
	를 추가해주면,기본 뷰리졸버가 modelandview에서 논리이름 앞뒤에 저걸 붙여서 거기로 던져줌
	즉
		return new ModelAndView("new-form");
	이거만해도 자동으로 뷰리졸버를 타고 
		/WEB-INF/views/new-form.jsp
	가 되는거임
	
	여기서 뷰리졸버는 (위부터 우선순위높음)
		BeanNameViewResolver //빈 이름으로 뷰를 찾아서 반환(엑셀파일생성등에 사용)
		InternalResourceViewResolver //jsp를 처리할수있는 뷰를 반환
	
	
	즉 실제로쓸땐 @RequestMapping만 쓰는데,
	얘는 @Controller로 어노테이션기반의 컨트롤러(@RequestMapping이 있으면,RequestMappingHandlerMapping을 사용하라는거)라고
	스프링빈으로 자동등록한뒤,
	그 안에서 @RequestMapping을 찾아서,그거의 url기반으로 핸들러를 찾아서 돌리는거
	이때는 어노테이션을 기반으로,어노테이션이 붙은 메서드를 동작시키기때문에,메서드의 이름은 아무거나써도됨
	그리고 이때 ModelAndView를 반환하면,모델을 뷰에 넣어서 그 화면을 그려줌
	
	즉,RequestMappingHandlerMapping은 스프링빈중에서 @RequestMapping이나 @Controller가 클래스레벨에 붙어있으면,
	매핑정보로 인식(자기가 처리하는 핸들러로 인식)
	
	모델앤뷰에 모델에 데이터추가할땐
		mv.addObject("member", member);
	키값으로 넣으면됨
	
	그리고 한 리소스에 대한 url들은 한군데 모아두는게 관리가 쉬움
	그리고
		@Controller
		@RequestMapping("/springmvc/v2/members")
		Class ...
	이런식으로 컨트롤러밑에 리퀘스트매핑으로,url공통부분을 묶어줄수있음
	
	그리고 리퀘스트매핑에서,루트출력할땐
		@RequestMapping
	이렇게 뒤에 아무것도안적으면됨
	
	그리고 스프링어노테이션 기반의 컨트롤러는,모델앤뷰를 반환해도되고,스트링을 반환해도,해당하는 스트링의 뷰를 찾아서 그걸 사용함(모델앤뷰만들필요없음)
	
	그리고 req와 res를 직접받지않고,거기서 req대신 파라미터만 떼서받을수도있고,res대신 모델을 받아서 거기다 값을 추가해줄수있음
	    public String save(@RequestParam("username") String username,
						   @RequestParam("age") int age,
                           Model model) {
			...
			model.addAttribute("member",member)
			return "뷰논리경로이름"
		}
	이경우 타입캐스팅도 알아서해줌
	
	즉,
		req대신 @RequestParam(얘는 쿼리파라미터와 post form을 지원)
		res대신 Model
		ModelAndView대신 스트링
	이렇게 처리할수있음
	즉,뷰리졸버는 스트링을 리턴하면 ModelAndView(스트링)가 자동으로 들어가고,만약 프리픽스 서픽스가 프로퍼티에 선언됐으면 경로앞뒤에 그걸붙이는식
	
	그리고 @RequestMapping에서 메서드 를 안넣어주면,get과 post 둘다받아먹음
	이걸 원하는 메서드로 지정할땐
		@RequestMapping(value = "/new-form", method = RequestMethod.GET)
		@RequestMapping(value = "/save",method = RequestMethod.POST)
	아니면 그냥
		@GetMapping ("/new-form")
		@PostMapping(value = "/save")
	써도됨
	
	
	
	
