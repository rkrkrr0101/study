1.웹 애플리케이션 이해
	웹서버는,정적 리소스를 제공(html,css같은걸 배포하는 nginx,apache같은거)
	웹 어플리케이션 서버(WAS)는 웹서버+코드를 수행해서 애플리케이션로직을 수행할수있음(톰캣)
	
	보통 웹 시스템은,was와 db만 있으면 기본적시스템 구성은 다됨(동작시켜볼수있음)
	근데 애플리케이션로직이랑 정적 리소스를 같이두면,비용절감이 안됨
	그리고 was장애시 오류화면노출도 불가능함
	
	그래서 일반적으로,웹서버를 앞에두고,was를 뒤에둬서 웹서버와 was가 통신해서 받아가는식으로 처리함
	이러면 스케일링자체도 쉬위지고 좋은게많음(오류화면도 띄울수있고)

	서블릿은,공통되는 로직들을 전부 처리해줌(tcp연결과 http요청메시지 파싱 등)
	urlPatterns에 해당되는 url이 호출되면(http메시지에 있으면),그 안에있는 로직을 실행시켜줌
	그 안에 로직은,
	HttpServletRequest request,HttpServletResponse response 를 받아야함(각각 req와 res)
	정확히는,서블릿은 http요청메시지를 파싱해서 req를 만들고,res를 파싱해서 http응답메시지를 만드는거
	요청이 들어오면 req와 res를 만들고,응답할땐 res만 던지는식
	
	톰캣처럼 서블릿을 지원하는 was를 서블릿 컨테이너라고 함
	이 컨테이너는,서블릿객체를 생성,초기화,호출,종료하는 생명주기를 관리하고,
	서블릿은 싱글톤으로 관리됨(공유변수주의해야함)
	jsp도 서블릿으로 변환되고,동시요청을 위한 멀티쓰레드처리도 지원함
	
	쓰레드가 서블릿객체를 호출하는식으로,멀티쓰레드가 동작함(동시요청이 들어오면,쓰레드를 생성하고,걔가 서블릿을 호출하는것)
	각각의 쓰레드는 한줄한줄 절차지향처럼 읽음
	
	이떄 쓰레드갯수에 여러방식이 있는데,
		요청시마다 쓰레드생성(단점으로 생성비용이 비싸고,요청이 너무많이오면 oom으로 서버죽음)
		쓰레드풀(쓰레드를 n개 미리생성해두고,거기서 꺼내다가 쓰고나서 돌려놓는거,장점은 서버의 한계만큼까지만 생성하면,다운안되게 계산을 할수있음)

	쓰레드풀에서,was의 주요 튜닝포인트는 최대쓰레드임
	이게 너무 낮으면,서버리소스는 여유롭지만 클라이언트는 금방 응답지연되고
	이게 너무 높으면,oom뜨거나 쓰로틀링걸림
	
	장애발생시엔,
		클라우드면 일단 서버갯수부터 스케일링하고,이후 튜닝
		클라우드가 아니면,튜닝에 목숨걸어야함
	튜닝은,최대한 실제서비스와 유사하게 성능테스트를 시도해보면됨(nGrinder같은 툴로)
	
	결국 중요한건,멀티쓰레드를 was가 알아서 지원해주니까,싱글톤(서블릿,빈)인거만 신경쓰면됨(예전에 쓰레드만든다고 머리터졌는데 세상좋아졌다)
	
	html에서는 was가 정적리소스를 뱉거나,아니면 동적으로 html을 생성해서 전달하거나,api 세가지 방식이 있음
	이때 api는
		http js에서 호출
		모바일 클라이언트에서 호출
		다른 서버에서 호출
	이 3가지경우에서 사용됨
	api는 주로 json형식으로 통신
	
	서버사이드렌더링은,html 최종결과를 서버에서 생성해서 웹브라우저에 전달,
	정적화면에 사용,타임리프같은걸 사용
	
	클라이언트사이드렌더링은,html결과를 js를 사용해 웹브라우저에서 동적으로 생성해서 적용
	주로 동적화면에 사용하고,필요한부분만 리랜더링해서 갱신하는거(내가 나무실시간에서 한거)

	뷰템플릿은,html을 편하게 생성하는 뷰기능
	jsp->타임리프로 넘어옴

2.서블릿
	스프링부트는 서블릿을 등록할수있게 @ServletComponentScan을 지원함(쓸일은없을듯)
	서블릿 등록은 
		@WebServlet(name = "helloServlet",urlPatterns = "/hello")
		컨트롤o의 서비스(자물쇠잠긴거)등록후 내부에구현
	붙이면됨
	
	request.getParameter("abc")로 쿼리파라미터 조회가능
	res추가시엔
	    response.setContentType("text/plain");
        response.setCharacterEncoding("utf-8");
        response.getWriter().write("hello"+abc);
	이렇게 컨텐츠타입 정하고,텍스트면 인코딩정하고,저렇게 바디에 적으면됨

	main/resources/application.properties에서
		logging.level.org.apache.coyote.http11=debug
	넣어주면 로그를 디버그레벨로 올려서,http요청메시지볼수있음
	물론 운영서버는 저렇게하면안되고,개발환경에서만
	
	그리고 content-length같은건 was가 알아서 넣어줌
	
	서블릿은,http요청메시지를 파싱해서 httpservletRequest객체에 넣어서 제공해줌
	그리고 추가적으로,해당 http요청이 시작하고,끝날때까지 유지되는 임시저장소로 사용할수도 있음
		request.setAttribute(name,value)
		request.getAttribute(name)
	이렇게 저장,조회하는거,이렇게 지역변수가 할일을 싱글톤상태에서 사용할수있음
	세션관리기능도 있음
		request.getSession(create:true)
	그리고 httpservletRequest,httpservletResponse 둘 다 http요청,응답메시지를 기반으로 어댑팅된거니까 요청응답메시지를 알아야함

	req읽어올땐
		req.getMethod()
		req.getRequestURI()
		
	이런식으로 들고오면됨
	헤더전체읽을땐
		req.getHeaderNames().asIterator().
			forEachRemaining(headerName -> System.out.println("h = " + headerName));
	이렇게 이터레이터써서 읽으면됨
	그리고 값 가져오는건
		req.getServerName()
		req.getServerPort()
	로 호스트를 파싱해서 꺼낼수있고,
		req.getLocale()
	로 최우선적으로 원하는 언어(accept-Language)를 꺼낼수있음
	전부다꺼내려면
		req.getLocales().asIterator().
			forEachRemaining(headerName -> System.out.println("h = " + headerName));
	이렇게 getLocales를 사용하면 다 꺼낼수있음
	
	쿠키조회는
		Cookie cookie:req.getCookies()
	로 꺼내고
		cookie.getName()
		cookie.getValue()
	로 이름과 값을 읽을수있음
	쿠키는 getCookies() s붙었으니까 여러개가 들어오니까,여기서 자기가만든거 골라쓰면됨
	
	컨텐츠정보는
		req.getContentType()
		req.GetContentLength()
		req.getCharaterEncoding()
	로 받아올수있음

	물론 그냥
		req.getHeader("host")
	이렇게 getHeader로 꺼내는게 젤편하긴할듯


	req데이터에서 정보전달방식은
		get-쿼리파라미터
			/url?키1=값1&키2=값2
			검색,필터,페이징등에서 사용
		post-html form
			content-type:application/x-www-form-urlencodded
			메시지바디에 쿼리파라미터(키1=값1&키2=값2) 형식으로 전달
			회원가입,상품주문등에서 html form으로 사용
		http message body에 직접 데이터를 담아서 요청
			http api에서 주로 사용,json,xml,text
			데이터형식은 주로 json 사용
			post,put,patch


	쿼리파라미터는 URL에 ?를 시작으로 보내고,추가파라미터는 &로 구분하면됨
	쿼리파라미터를 전부꺼내려면
		req.getParameterNames()
	하면되고
	
	전체출력할땐
		parameterNames.asIterator().
			forEachRemaining(h -> System.out.println(h + "=" + req.getParameter(h)));
	이렇게 하면됨
		req.getParameter(h)
	로 해당파라미터이름을 꺼낼수있음


	그리고 ?username=hello&age=20&username=hello2
	이렇게 같은 이름으로 2개를 넣을수도있음
	이걸 뽑을땐
		req.getParameterValues("username")[1]
	이걸써서 이렇게 배열로뽑을수있음
	근데  이렇게 쓰면 헷갈리는데 이렇게쓰진않을거같다
	일단 이렇게됐을때 getParameter를 쓰면,처음넣은걸 반환하는듯

	html form이랑 쿼리파라미터랑은 서로 호환이 돼서,form도
		req.getParameter
	로 다꺼내면됨
	
	즉,클라입장에선 둘이 다른데,서버입장에선 둘다 똑같이 처리할수있음
	이 둘을 구분해야하면,content-type이 있나없나로 구분하면됨
	get은 바디가 없으니 content-type이 없고,form은 바디에 넣으니 content-type이 'application/x-www-form-urlencodded'임

	요청메시지바디에 데이터 담아서보낼땐,보통 json사용
	post,put,patch에서 주로 사용됨()
	
	바디에서 단순텍스트를 받고,이걸 꺼낼땐
	    ServletInputStream inputStream = req.getInputStream();
        String messageBody = StreamUtils.copyToString(inputStream, StandardCharsets.UTF_8);
	이렇게 getInputStream으로 받아서,StreamUtils.copyToString로 스트링으로 바꿔주면됨
	
	json을 받고,꺼낼땐,
	보통 json은 데이터클래스를 만들어서(도메인 클래스)사용함
	일단 텍스트로 그냥 받고꺼낼땐
	    ServletInputStream inputStream = req.getInputStream();
        String messageBody = StreamUtils.copyToString(inputStream, StandardCharsets.UTF_8);
	이렇게 똑같이꺼내면되고(어짜피 텍스트니까)

	데이터클래스로 꺼낼땐
		private ObjectMapper objectMapper = new ObjectMapper();
		HelloData helloData = objectMapper.readValue(messagebody, HelloData.class);
	이런식으로 꺼낼수있음(readValue의 2번째 매개변수에 클래스를넣으면,거기맞는 게터세터형식으로 넣어서 나옴)		


	httpservletResponse객체는
		응답메시지를 생성해주고(응답코드지정,헤더생성,바디생성)
		편의기능(content-type,쿠키,리다이렉트)
	등을 쉽게 지정할수있음
	
	응답코드지정은
		resp.setStatus(200);
		resp.setStatus(HttpServletResponse.SC_OK); //200상수
	이런식으로 넣을수있음
	컨텐츠타입은
		resp.setContentType("text/plain");
		resp.setCharacterEncoding("UTF-8");
	그외 각종 헤더입력은
		resp.setHeader("Cache-Control", "no-cache,no-store,must-revalidate");
		resp.setHeader("헤더명", "헤더값");
	사용자 지정 헤더도
		resp.setHeader("abcd123", "ttt123");
	이렇게 넣으면됨
	
	쿠키는
		Cookie cookie=new Cookie("mycookie","good")
		cookie.setMaxAge(600);
		resp.addCookie(cookie)
	이렇게 넣을수있음
	
	리다이렉트(location헤더+302상태코드)는
		resp.sendRedirect("/basic/hello-form.html");
	로 넣을수있음
	
	메시지바디에 뭐 적을땐
		resp.getWriter().println("ㅎㅇ요");
	이렇게 적으면됨
	
	
	html 응답메시지도
		단순텍스트응답(resp.getWriter().println(""))
		HTML응답
		HTTP API-messageBody json 응답
	이렇게 있음
	
	html보낼땐
		resp.setContentType("text/html"); //컨텐츠타입 html로
        resp.setCharacterEncoding("UTF-8");//인코딩정하고

        PrintWriter writer = resp.getWriter();
        writer.println("<html>");
		... html작성
	이렇게 보내면됨
	
	json으로 보낼땐
        resp.setContentType("application/json");
        resp.setCharacterEncoding("UTF-8");

        HelloData helloData = new HelloData();
        helloData.setUsername("afa");
        helloData.setAge(30);

        String result = objectMapper.writeValueAsString(helloData);
        resp.getWriter().write(result);	
	이렇게 객체생성하고,오브젝트매퍼로 스트링으로바꿔서 적으면됨(이러면 변수명을 getter콜해서 키값으로 만들어서 json형식으로 만듬)



3.서블릿,jsp,mvc패턴
	이렇게하면
		public List<Member> findAll() {
			return new ArrayList<>(store.values());
		}
	저걸 조작해도 스토어엔 영향을 안줌(DTO)
	
	배열안에 있는 멤버들 검증할땐
		List<Member> result = memberRepository.findAll();
		Assertions.assertThat(result).contains(member1, member2);

	서블릿에서 html보내는건 진짜불편하다->템플릿엔진의 등장
		템플릿엔진=html에 코드넣기
		서블릿은 코드에 html넣기
	대표적 템플릿엔진에 jsp,타임리프등이 있음
	
	jsp는
		<%@ page contentType="text/html;charset=UTF-8" language="java" %>
	가 맨위에 꼭 있어야함
	jsp에서 코드실행시킬땐 <% %>사이에 넣으면되고
	코드를 출력할땐
		<%= %>
	사이에 넣으면됨
	임포트는 맨위에 
		<%@ page import="hello.servlet.domain.member.Member" %>
	그리고 jsp에서는 request,response가 이 단어 그대로 문법상으로 지원이 됨
	out도 예약어
		out.write(<head>)

	jsp는 서블릿보다 나아지긴했는데,일단 html이랑 코드랑 붙어있는게 불편하고(관심사의 분리가 안됨)
	컨트롤러와 뷰가 붙어있어야하는거도 불편함
	
	이래서 나온게 mvc패턴
	하나의 서블릿이나 jsp만 가지고 처리하던걸,컨트롤러와 뷰로 나눈걸 말함
	
	나눈 이유는,일단 한곳에 코드가 너무많이 몰려있기도 하고,중요한건 변경주기가 서로 다르기때문임
	ui를 변경하는것과 비즈니스로직을 수정하는일은 빈도수가 다르고,서로에게 영향을 주지 않기때문
	
	컨트롤러는 http요청을 받아서 파라미터를 검증하고,비즈니스로직을 실행함,그리고 뷰에 전달할 결과 데이터를 조회해서 모델에 담음(서블릿)
	모델은 뷰에 출력할 데이터를 담아둠,뷰가 필요한 데이터를 모두 모델에 담아서 전달해줘서,뷰는 비즈니스로직이나 데이터접근을 몰라도되고,렌더링만 하면됨(req)
	뷰는 모델에 담겨있는 데이터를 사용해서 화면을 그리는일만 함(jsp)
	
	즉,원시적인 mvc는
		사용자가 http로 컨트롤러를 호출
		컨트롤러는 모델에 데이터를 담음
		컨트롤러는 뷰 로직을 실행함
		뷰 로직은 모델에서 데이터를 가져가서 화면을 그림(보통 매개변수로 모델을 던져줌)
	뷰에서 필요한 모든 데이터는 모델에서 꺼내가야하고,뷰가 외부일을 알면 안됨
	
	여기서 컨트롤러가 하는일이 너무 많다고,분리한게 컨트롤러,서비스,레포지토리임
		컨트롤러는 웹쪽의 입력을 받아서 서비스를 호출해서 결과값을 모델에 넣고 뷰를 호출하는 책임만 받고(말그대로 컨트롤하는일만 담당함),
		서비스가 비즈니스로직을 수행하는 책임
		레포지토리가 데이터 접근을 수행하는 책임
	을 맡음
	
	req에 값을 넣고뽑을땐 
		req.setAttribute()
		req.getAttribute()
	로 쓸수있음(모델로 쓸때)
	
	컨트롤러에서 뷰로 이동할때
		 RequestDispatcher dispatcher = req.getRequestDispatcher(viewPath);
		 dispatcher.forward(req,resp);
	로 이동가능(다른서블릿이나 jsp로 이동하는기능,서버내부에서 다시 호출이 발생함,즉 리다이렉트가 아님)
	
	리다이렉트는 클라이언트로 다시 갔다가 다시올라오는것,클라이언트가 인지할수있음,
	forward는 서버내부에서 콜하는것,클라에는 영향을안줌,즉 상단의 url이 안바뀜
	
	html에서 action=''이 절대경로가 아닌 상대경로면(/members/save는 절대경로,save는 상대경로),
	현재 url을 기준으로 /save를 붙여서 찾음
	즉
		mvc/members/new-form ->상대경로save호출 ->mvc/members/save
	일반적으론 절대경로사용함
	
	/WEB-INF경로안에 jsp가 있으면,이건 외부에서 직접 호출할수없고,
	서버내부에서 컨트롤러를 통해서만 접근할수있음(이 경로안에 있는 모든 리소스가 직접호출불가)

	jsp에서
		${}
		${member.id}
	이렇게하면,req안에 있는 해당 애트리뷰트를 접근할수있음(해당 애트리뷰트의 getter를 호출),이걸 프로퍼티접근이라고함

	jsp내에서 foreach돌려서 안에꺼 꺼내야할때
		<%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>
	위에 선언하고
		<c:forEach var="item" items="${members}">
			<tr>
				<td>${item.id}</td>
				<td>${item.username}</td>
				<td>${item.age}</td>
			</tr>
		</c:forEach>	
	이렇게 forEach를 돌릴수있음
	
	
	이렇게 서블릿과 jsp를 사용해서 mvc를 적용하면,컨트롤러단과 뷰단을 완전히 분리할수 있음
		근데 컨트롤러단에서의 중복(forward같은)과,
		viewPath의 중복(프리픽스와 서픽스),
		템플릿엔진변경시 코드를 다 갈아야한다는점,
		req와 res를 사용하지않을때(특히 res),
		테스트코드작성이 어려움
		공통처리가 어려움(제일 큰 단점,반드시 콜해야하는걸 까먹고 하지않았을때)
	단점이 있고
	가장 큰 문제는 공통처리임
	그래서 나온게,컨트롤러 호출 전에 공통기능을 처리하는,프론트 컨트롤러 기능임
	즉,api게이트웨이같은 컨트롤러를 두고,걔가 공통기능들을 다 처리하고 나서 뒤에 진짜컨트롤러들을 url에 맞게 호출하는식
	이게 스프링mvc의 핵심임
	
	
4.mvc 프레임워크 만들기	
	
	
	
	
	
	
