1.타임리프-기본기능
	타임리프의 특징은
		서버사이드렌더링(html동적렌더링)
		네츄럴 템플릿
		스프링통합지원
	같은 특징이 있음
	
	타임리프 쓸땐
		<hthml xmlns:th="http://www.thymeleaf.org">
	를 맨위에 넣어주고,th를 불러가며 사용하면됨
		th:onclick= ...
	이렇게
	
	타임리프에서 텍스트속성정의할땐
		th:text="${data}"
	하면됨
	그리고 태그의 속성이 아니라,콘텐츠영역안에서 하고싶으면
		[[$(data)}]]
	이렇게하면됨
		<li>th:text사용<span th:text="${data}"></span></li>
		<li>컨텐츠안에서 직접출력 =[[${data}]]</li>	
	이런식으로
	html에서 뷰템플릿으로 생성할땐,특수문자를 주의해야함
	기본적으로 뷰템플릿속에선 <b>이런 태그가 먹지않음(타임리프가 자동으로 바꿔줌)
	이걸 이스케이프라고 함
	
	이걸 사용하고싶지않으면 th:utext를 사용하거나,태그텍스트부분에선 [(${data})] 이렇게 사용하면됨		
	기본적으로는,이스케이프를 써야하고,정 안될때만 언이스케이프같은거 써야함
	
	타임리프에서 변수는,${...}이렇게 사용하고,스프링에서 지원하는springEL을 사용할수있음
	스프링el은,헤더에있는(모델에 담으면 헤더에적히니)값들을 불러올때
	오브젝트
		${user.username}
		${user['username']}
		${user.getUsername()}
	리스트
		${users[0].username}
		${users[0]['username']}
		${users[0].getUsername()}
	맵
		${userMap['userB'].username}
		${userMap['userA']['age']}
		${userMap['userA'].getUsername()}
	이런식으로 받을수있음
	즉,해당 헤더 안에 뭐가 들어있으면(1차원이 아닌 2차원이상으로),거기서 그냥 프로퍼티접근으로 꺼낼수있다는거임
	
	그리고 타임리프에서 지역변수는
		th:with="abc=bcd"		
	저기에 값을 넣고,
		th:text="${abc}"
	이렇게 꺼내면됨
	당연히 객체도 들어가고
		th:with="first=${user[0]}"
		th:text="${first.username}"
	다됨
	그리고 이 지역변수는,선언한 태그 안에서만(<div>같은거면 그 안에서만)사용할수있음,그 스코프밖으로 퍼지진않음
	
	스프링부트 3.0부터는
		${#request}
		${#response}
		${#session}
		${#sevletContext}
	를 지원하지않고,남은건
		${#locate}
	만 남음
	그래서 3.0부터는 직접 모델에 넣어줘서 거기서꺼내든가해야함
	저거외에 편의기능은
		${param.paramData} //쿼리파라미터읽기
		${session.sessionData} //세션데이터읽기
		${@helloBean.hello('Spring!')} //스프링빈호출,${@빈이름.호출메소드(매개변수)}
	이 있음
	
	타임리프의 유틸리티객체는
		#message:메시지,국제화처리
		#urls:url이스케이프 지원
		#dates:java.util.Date 서식 지원
		#calenders:java.util.Calendar서식지원
		#temporals:자바8날짜서식지원
		#numbers:숫자서식지원
		#strings:문자관련편의기능
		#objects:객체관련기능제공
		#bools:bool관련기능제공
		#arrays:배열관련기능제공
		#lists,#sets,#maps:각각 컬렉션기능제공
		#ids:아이디처리관련기능제공
	등등 있음,생각했던거에서 대충 범주들어가는거 공식도큐찾아보면 잇음

	타임리프에서 자바8날짜인 LocalDate류,Instant등을 사용하려면 추가라이브러리가 필요함
	스프링부트 타임리프를 사용하면,해당 라이브러리가 자동으로 추가되고 통합됨
	사용방법은
		th:text"${#temporals.format(받을헤더명,'yyyy-MM-dd HH:mm:ss')}
	#temporals이 날짜서식을 지원하는 유틸객체임	
	
	
	타임리프에서 url생성할땐 @{}를 사용하면됨
		th:href="@{/hello}
	쿼리파라미터추가하고싶으면 괄호만()
		th:href="@{/hello(param1=${param1}, param2=${param2})}"
	패스배리어블쓰고싶으면(쿼리파라미터말고 경로에 변수넣고싶으면)
		th:href="@{/hello/{param1}/{param2}(param1=${param1}, param2=${param2})}"
	둘다쓰고싶으면
		th:href="@{/hello/{param1}(param1=${param1}, param2=${param2})}"
	즉,앞에 변수가있으면 그거부터 들어가고,만약 겹치는게없으면 쿼리파라미터로 들어감
	
	
	리터럴은,소스 코드상에서 고정된 값임
	타임리프에서 문자리터럴은 항상 ''로 감싸야함,근데 문자중간에 스페이스나 특수문자가 없으면 하나의 토큰으로 인정해서 리터럴로 만들어줌
	이때 -,_,.들은 들어가도됨
	스페이스를 넣어야하면
		th:text="'hello world!'"
	이렇게 넣어야함
	근데 그냥 ||사이에 넣는게 젤편함(리터럴 대체문법)
		th:text="|abcd 123 qqq ${data}|"
		
	타임리프에서 연산은 자바랑 별로 다를건없는데,귀찮은건 http엔티티를 사용해야하는게 귀찮음(<나 >)
	그래서 <,>이 있는건 gt,lt로 대체해서써야함
		> = gt
		< = lt
		>= = ge
		<= = le
		! = not
		== = eq
		!= = ne
	이렇게 써야함(! == !=는 그냥써도됨)
	
	
	그리고 조건문은
		(조건)? true값:false값
	elvis연산은(null체크,조건식의 편의버전)
		${data}?: '문자' = 데이터있을때출력:널일때출력
	no-Operation은 널이면(조건을 만족하지않으면) 타임리프태그를 아예 수행하지않는거,이러면 그냥 html원본그대로 나옴
		${data}?: _ = <span th:text="${data}?: _">데이터없음</span>
	이러면 데이터없음이 출력됨(타임리프무시되니까)
	
	
	타임리프는,th:뒤에 뭘 넣는식으로 동작함
	이때 해당하는속성이 있으면 대체,없으면 생성함
	그리고 덮기싫고 추가하고싶을때는
		th:attrappend = 속성값의 앞에 값을 추가,이거로추가할땐 스페이스바 안들어가니까 주의
		th:attrprepend= 속성값의 뒤에 값을 추가,이거로추가할땐 스페이스바 안들어가니까 주의
		th:classappend= class속성앞에 자연스럽게 추가,이거로 추가하면 스페이스바 들어감
		
		th:attrappend = "abc='abcd'" //이렇게쓰면됨
	
	html은 checked="false"라도 checked라는 속성이 존재하면 checked가 돼버림
	그래서 타임리프에서
		th:checked
	를 사용하면 값이 false일경우 checked속성자체를 제거해서 false를 리턴하게 해줌(체크표시를 풀어줌)


	타임리프에서 반복은 th:each를 사용함
		th:each="컬렉션에서꺼낸변수:${컬렉션}"
	컬렉션은 list,array,map등을 지원함
	그리고 반복의 상태확인은
		th:each="컬렉션에서꺼낸변수,상태확인변수명:${컬렉션}"
	인데,기본값이 컬렉션꺼낸변수+Stat임,즉 지정안해도 저렇게꺼내서확인할수있음
	
	이 Stat의 상태값은
		index:0부터 시작하는값
		count:1부터 시작하는값
		size:전체 사이즈
		even,odd:홀수짝수(tf) //두줄마다 색칠해줄때같을떄사용,가독성
		first,last:처음,마지막(tf)
		current:현재객체
	속성이 있음
	
	
	타임리프에서의 if는,해당값이 f이면 태그 자체를 랜더링하지않음(지워버림)
	사용법은
		<span th:text="'미성년자'" th:if"${user.age lt 20}:></span>
	이러면 age가 20보다 크면 태그자체가 없어져버림
	반대되는 unless도 있는데,그냥 tf만 반대로받고 똑같음
	스위치문도 있는데
		<td th:switch="${user.age}">
			<span th:case="10">10살</span>
			<span th:case="20">20살</span>
			<span th:case="*">몰루</span>
	*은 와일드카드,디폴트임	


	타임리프에서 주석은,html주석과 타임리프주석이 있음
	html주석은,기본적인 주석 소스보기로 보임
		<!--  ㅁㄹㅇㄴㄹㄴㄹ -->
	타임리프 파서주석은,이 사이에 있는걸,출력할때 그내용을 지워줌(소스보기로 못봄)
		<!--/* ㄹㄴㄹㄴㄹㄴ */--> //한줄
		<!--/*-->            //여러줄 시작
			<span>fsfs</span>
		<!--*/-->            //여러줄 끝
	이렇게 저거로 싸두면 저거도 없어짐
	
	타임리프 프로토타입주석은,타임리프로 랜더링 되면 실제 태그가 적힘(주석이아님),그냥 경로로 html불러오면 주석처리됨,안쓸거같음ㅋㅋ
		<!--/*/ ㄹㄴㅇㄹㄴ /*/-->
	
	
	타임리프에서 유일하게 태그를 추가하는게 <th:block>임
	이건 안에서 두개이상div에서 루프를 돌리거나 하고싶을때 사용됨(div2개이상을 묶고싶을때)
	얘는 랜더링될떄 사라짐,즉 each만으로 해결하기 어려울때 사용됨(태그하나에 속성변경으로 처리하기 애매할경우에)
	
	js인라인은 js에서 타임리프를 사용할때 좀더 편리해짐
		<script th:inline="javascript">
	이걸 사용하면 문자타입일경우 ""를 싸서주고,문제될만한 문자가 있으면 이스케이프처리도 해줌("->\")
	그냥 <script>사용할땐 무지성으로 붙여도될듯
	
	그리고 html파일을 그대로 열어도되는 내추럴템플릿에서,이걸사용해서 주석을 활용해서 이기능을 사용할수있음(js도 내추럴템플릿을 사용할수있음)
		var username2 =/*[[${user.username}]]*/"test username";
	이렇게 변수부분을 주석처리해두면,타임리프로 열면 뒤에를 지우고 주석을벗기고,직접열면 저게 주석이니까 무시돼서 내추럴로 동작할수있게해줌
	
	객체를 넣으면,json으로 바꿔줌
		var user =[[${user}]];
	이렇게 넣으면
		var user ={"username":"userA","age":10};
	이렇게 나옴
	
	그리고 이안에서도 each를 사용할수있음
		[# th:each="user,stat :${users}]
		var user[[${stat.count}]]=[[${user}]]
		[/]
	이렇게 사용할수있음
	이러면
		var user1 ={"username":"userA","age":10};
		var user2 ={"username":"userB","age":20};
		var user3 ={"username":"userC","age":30};
	이렇게 나옴

	타임리프는 웹페이지의 공통영역을 템플릿조각기능과 레이아웃기능으로 가져다쓸수있게 제공해줌
	가져다 쓰는 대상(함수역할)html에서
		<footer th:fragment="abcd">푸터자리입니다.</footer>
	이런식으로 th:fragment="abcd"이렇게 선언해두고
	메인에서
		<div th:insert="~{template/fragment/footer :: abcd}"></div>
	이렇게 insert를 하던가(th:insert="~{경로::이름}")
		<div th:replace="~{template/fragment/footer :: abcd}"></div>
	replace하던가
		<div th:replace="template/fragment/footer :: abcd"></div>
	이렇게하면 단순표현식(~{}를 빼도 단순하면 동작하는거,위랑 다른거없음)
	
	인서트는 현재 태그 내부에 해당 태그를 삽입함(div속성에 넣으면 div안에 추가함,<div><footer>)
	리플레이스는 현재 태그를 해당 태그로 변경함(div속성에 넣으면 div를 제거하고 해당속성으로 변경 <div> -> <footer>)
	
	파라미터도 넣을수있음
	함수html에서
		<footer th:fragment="copyParam (param1, param2)"><p>파라미터자리입니다.</p>
			<p th:text="${param1}"></p>
			<p th:text="${param2}"></p></footer>
	이렇게넣고
		<div th:replace="~{template/fragment/footer :: abcd("1번파라미터",2번파라미터)}"></div>
	이렇게 함수처럼 불러다쓸수있음
	
	이렇게 함수처럼 부르는거말고,코드조각을 레이아웃에 넘겨서 사용할수도 있음,이게 템플릿 레이아웃임
	즉 헤더부분이나 푸터를 만들어두고,그걸 가져다가 쓰면서 뭘 좀 추가하거나 하고싶을때 사용
	이건 th:replace를 헤드같은 엄청 html에서 큰덩어리에서 사용하는식으로 처리하면됨
	거기서
	위에서 공통부분을 처리한후에
		<html xmlns:th="http://www.thymeleaf.org">
		<head th:fragment="common_header(title,links)"><title th:replace="${title}">레이아웃타이틀</title>
			<!-- 공통 -->
			<link rel="stylesheet" type="text/css" media="all" th:href="@{/css/awesomeapp.css}">
			<link rel="shortcut icon" th:href="@{/images/favicon.ico}">
			<script type="text/javascript" th:src="@{/sh/scripts/codebase.js}"></script>
			<!-- 추가 -->
			<th:block th:replace="${links}"/>
		</head>
	밑에 블록을 넣어서
		<head th:replace="template/layout/base :: common_header(~{::title},~{::link})"><title>메인타이틀</title>
			<link rel="stylesheet" th:href="@{/css/bootstrap.min.css}">
			<link rel="stylesheet" th:href="@{/themes/smoothness/jquery-ui.css}">
		</head>
	이렇게 해당 이름의 태그들을 파라미터로 넘겨서 추가할수있음
	즉 템플릿조각이랑 비슷한데(템플릿조각에서 파라미터에 스트링 다박아버려도 똑같긴할듯),
	그냥 저걸 텍스트로 넘기기 너무기니까,태그로 서치해서 넘긴다고 생각하면될듯
	
	그리고 이걸 head같은정도에만 하는게 아니라,html태그에(전체에) 적용할수도있음
	이거도 위랑 똑같은데,그냥 전체를 만들어두고,약간약간 바꿔가면서 쓸때 사용함
		<html th:fragment="layout (title, content)" xmlns:th="http://www.thymeleaf.org">
		<head><title th:replace="${title}">레이아웃타이틀</title></head>
		<footer>레이아웃푸터</footer>
	이렇게 필요한부분만 replace하면서(리플레이스안시킨데는 그대로 나옴,공통부분)
		<html th:replace="~{template/layoutExtend/layoutFile :: layout(~{::title}, ~{::section})}"
		<head><title>메인페이지타이틀</title></head>
		<body>
		<section><p>메인페이지컨텐츠</p>
			<div>메인페이지포함내용</div>
	이렇게 넣고 바꾸는거임,위랑똑같음
	사실상 상속이랑 똑같아보여서 레이아웃 상속이라고 하는듯
	상속처럼 막 비슷한페이지 100개 만들고 이럴때 사용하기편한듯


2.타임리프와 스프링통합과 폼
	타임리프는 타임리프기본도큐먼트와,스프링통합도큐먼트 두개를 제공함
	이렇게 스프링통합을 하면 기능추가가 몇개되고,편해지는게 좀 있음
	
	예로
		${@myBean.doSomething()} //스프링빈호출
	폼관리를 위한 추가속성
		th:object
		th:field ,th:error,th:errorclass
	폼컨포넌트기능
		체크박스
		라디오버튼
		리스트
	스프링 메시지,국제화기능 통합
	스프링검증,오류처리 통합
	스프링변환서비스 통합
	
	이렇게 통합하려면 타임리프템플릿엔진을 스프링빈에 등록하고 뭐 어쩌고해야하는데,스프링부트쓰면 알아서해줌(그 starter.thymeleaf 추가되면)
	
	
	타임리프를 사용하면 폼처리가 많이 편해짐
	타임리프로 폼을 쓰려면,무조건 모델을 생성하고,모델에 빈 객체이라도 만들어서 뭐라도 하나 넣어둬야함(변수생성이라고보면됨)
		model.addAttribute("item", new Item());
	그리고
		<form action="item.html" th:action th:object="${item}" method="post">
	이렇게 키를 받아서 커맨드객체에 넣고(저걸 커맨드객체라고 부름,쟤로 조종하니까)
	값입력(input태그)에서
		<input type="text" id="itemName" name="itemName" th:field="*{itemName}" class="form-control"
                   placeholder="이름을 입력하세요">
	이렇게	
		th:field="*{itemName}"
	*은 위에서 th:object를 줄인거(item. 을 생략,즉 위에 오브젝트에 속한거라는거)
	이렇게 th:field가 있으면
		<input type="text" th:field="*{itemName}" class="form-control"
                   placeholder="이름을 입력하세요">
	이렇게 id와 name도 생략하면,필드명으로 들어감(itemName)
	
	즉 th.field는,id,name,value를 합친거고
	*{}는,앞에 위에서의 오브젝트의 객체를 붙이는거
	그리고 th:field의 값이 없으면,예외를 던짐(item.itemNamexx가 없다거나)
	
	이게 좋은건 검증할때 엄청 편해짐
	
	
	타임리프에서 체크박스,라디오버튼,셀렉트박스를 추가하는건

	자바 enum은
		public enum ItemType {
			BOOK("도서"), FOOD("음식"), ETC("기타");

			private final String description;

			ItemType(String description) {
				this.description = description;
			}
		}
	그냥 이렇게만들면됨(description은 설명)

	
	만약 html만 가지고 체크박스를 만들면,체크를 했을땐 true를 리턴하는데(정확히는 on이 넘어가는데 스프링이 이걸 true로 바꿔줌),
	체크를 안했을때 null이 반환됨(체크하지않으면 그 필드자체가 전송되지않음)
	생성은 뭐 안들어왔네 하면되는데,수정의경우 문제가 될수있음
	그래서 깡스프링에서는 앞에 타입히든에 언더바를 붙이는식으로 히든필드를 만들어서
		<input type="checkbox" id="open" name="open" class="form-check-input">
		<input type="hidden" name="_open" value="on"/> //다 고정이고,name만 체크박스와 통일하고 앞에 _붙이기
	이렇게 그 체크박스가 있다는걸 확인하고(체크박스와 이름이같은 히든타입),
	스프링이 false를 출력하는식으로 꼼수로 false를 받을수는 있는데,너무 귀찮음
	
	
	그래서 타임리프를 사용하면 알아서 해줌
		<input type="checkbox" id="open" th:field="*{open}" name="open" class="form-check-input">
	그냥 이렇게 th:field넣으면됨(이거도 똑같이 히든필드로 동작하는데,이걸 타임리프가 대행해주는거)

	그리고 스프링에서
		@ModelAttribute("regions")
		public Map<String, String> regions() {
			Map<String, String> regions = new LinkedHashMap<>();
			regions.put("SEOUL", "서울");
			regions.put("BUSAN", "부산");
			regions.put("JEJU", "제주");
			return regions;
		}
	이렇게 선언하면,그 컨트롤러를 호출할때에는 무조건 저 regions에 저값이 디폴트로 들어가있게됨
	물론 성능최적화관점에선 static로 할수있으면 그렇게하는게 낫긴할듯
	
	멀티체크박스는
	    <div>
            <div>등록지역</div>
            <div th:each="region : ${regions}" class="form-check form-check-inline">
                <input type="checkbox"
                       th:field="*{regions}"
                       th:value="${region.key}"
                       class="form-check-input">
                <label th:for="${#ids.prev('regions')}" th:text="${region.value}"
                       class="form-check-label">서울</label>
            </div>
        </div>
	이렇게 돌리면됨(th:each의 regions는 모델애트리뷰트에서 받은거,th:field="*{regions}"는 item의 region값)
	대충 value에 값이있으면 체크,없으면 비워두는걸 타임리프가 자동으로해줌
	th:for="${#ids.prev('regions')}"은,텍스트를 클릭해도 체크가 되게하려면,
	체크박스의 아이디를 라벨에서 알아야해서,for문의 직전의 id값을 받을수있음(어짜피 이거도 타임리프가 만드니까,id는 유니크해야하니)
		${#ids.prev('regions')}
	
	자바에서 enum의 값을 전부 리턴하는건
		ItemType.values()
	하면 값을 전부리턴함(배열로 리턴)
	
	타임리프에서 라디오버튼은 위랑 똑같은데(셀렉트박스랑)
		<input type="radio"
	이거만 바뀜
	그리고 얘는 체크를 안하면 null이 반환됨
	
	그리고 타임리프에서 enum을 직접접근할수있긴한데,컴파일오류를 못잡아서 추천하진않는대
	

	타임리프에서 셀렉트박스는
		<select th:field="*{deliveryCode}" class="form-select">
			<option value="">==배송방식선택==</option>
			<option th:each="deliveryCode : ${deliveryCodes}" 
					th:value="${deliveryCode.code}" th:text="${deliveryCode.displayName}">FAST
			</option>
		</select>
	이런식으로 셀렉트박스를 만들고,옵션을 each돌리면됨


3.메시지-국제화
	텍스트같은걸 한군데다 모아두면,수정하기가 편함,이게 메시지 기능임(파일에서 변수 불러다쓰는느낌)
	이걸 사용해서 언어별로 만드는식으로(파일을 2개만들어서)언어별로 다른값을 내보내는게 국제화
	accept-language같은거로 체크해서 다른걸 부르면됨
	
	그리고 스프링에서는 기본적으로 이런 메시지관리기능을 제공하고,타임리프도 이걸 통합해서 편하게쓸수있음
	이걸 사용하려면,MessageSource를 스프링빈으로 등록하면되는데,이건 인터페이스임
	그래서 ResourceBundleMessageSource를 스프링빈으로 등록하면됨
	그리고 그 메시지소스에
		messageSource.setBasenames("messages","errors")
		messageSource.setDefaultEncoding("utf-8")
	이렇게 디폴트이름을 정해주면,알아서
		messages_ko.properties
		messages_en.properties
	이렇게 바꿔가면서읽음
	파일의 위치는
		/resources/messages.properties
	에 두면되고,setBasenames에는 여러 파일을 한번에(지금도 메시지랑 에러 두개저장한거처럼)넣을수있음
	
	근데 스프링부트쓰면 자동으로 이걸 해줌
	그래서 application.properties에
		spring.messages.basename=messages //디폴트는 messages
	이렇게 넣기만하면됨
	디폴트값이 messages니까
		messages_en.properties
		messages_ko.properties
		messages.properties
	같은건 자동으로 인식함(모든언어지원안하면 messages.properties동작)

	
	@SpringBootTest
	이거붙이면 테스트실행할때 의존성주입해주니까,필드로 주입받아서 테스트돌리면됨
	    @Autowired
		MessageSource messageSource;

	메시지 받을땐
		ms.getMessage("hello", null, null);
		ms.getMessage(해당변수명, args, 국가값);
	이렇게 받으면됨
	그리고 해당 변수가 없어서 메시지를 못찾으면 NoSuchMessageException이 발생
		Assertions.assertThatThrownBy(() -> ms.getMessage("no_code", null, null))
		.isInstanceOf(NoSuchMessageException.class);
	저상황에서 기본값을 받고싶으면
		ms.getMessage("no_code", null, "기본메시지", null);
	이렇게 3번째에넣으면됨
	args사용시엔
		hello.name=gd{0} //메시지.프로퍼티파일
		
		ms.getMessage("hello.name", new Object[]{"Spring"}, null);
	이렇게 넣으면 gdSpring가 출력됨
	
	나라선택은
		ms.getMessage("hello", null, Locale.ENGLISH)
	이렇게 할수있음
	
	이 메시지를 타임리프에서 사용할땐
		#{}
		#{hello.name}
	이런식으로 바로 접근할수있음
	파라미터는
		#{hello.name(${item.itemName})}
		#{hello.name(1234)}
	이렇게 괄호치고 바로넣으면됨
	국제화는 그냥,_en,_ko같이 베이스네임에서 맞춰주기만하면 스프링이 알아서 accept-language같은거보고 호출함
	이 선택을 직접한다던가식으로 바꾸고싶으면,구현체를 변경해주면됨
	인터페이스는 LocaleResolver고
	기본적으론 AcceptHeaderLocaleResolver을 사용하는데,쿠키나 세션기반으로 구현체를 변경해주면됨
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	

