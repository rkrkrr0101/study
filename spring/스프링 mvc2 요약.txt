1.타임리프-기본기능
	타임리프의 특징은
		서버사이드렌더링(html동적렌더링)
		네츄럴 템플릿
		스프링통합지원
	같은 특징이 있음
	
	타임리프 쓸땐
		<hthml xmlns:th="http://www.thymeleaf.org">
	를 맨위에 넣어주고,th를 불러가며 사용하면됨
		th:onclick= ...
	이렇게
	
	타임리프에서 텍스트속성정의할땐
		th:text="${data}"
	하면됨
	그리고 태그의 속성이 아니라,콘텐츠영역안에서 하고싶으면
		[[$(data)}]]
	이렇게하면됨
		<li>th:text사용<span th:text="${data}"></span></li>
		<li>컨텐츠안에서 직접출력 =[[${data}]]</li>	
	이런식으로
	html에서 뷰템플릿으로 생성할땐,특수문자를 주의해야함
	기본적으로 뷰템플릿속에선 <b>이런 태그가 먹지않음(타임리프가 자동으로 바꿔줌)
	이걸 이스케이프라고 함
	
	이걸 사용하고싶지않으면 th:utext를 사용하거나,태그텍스트부분에선 [(${data})] 이렇게 사용하면됨		
	기본적으로는,이스케이프를 써야하고,정 안될때만 언이스케이프같은거 써야함
	
	타임리프에서 변수는,${...}이렇게 사용하고,스프링에서 지원하는springEL을 사용할수있음
	스프링el은,헤더에있는(모델에 담으면 헤더에적히니)값들을 불러올때
	오브젝트
		${user.username}
		${user['username']}
		${user.getUsername()}
	리스트
		${users[0].username}
		${users[0]['username']}
		${users[0].getUsername()}
	맵
		${userMap['userB'].username}
		${userMap['userA']['age']}
		${userMap['userA'].getUsername()}
	이런식으로 받을수있음
	즉,해당 헤더 안에 뭐가 들어있으면(1차원이 아닌 2차원이상으로),거기서 그냥 프로퍼티접근으로 꺼낼수있다는거임
	
	그리고 타임리프에서 지역변수는
		th:with="abc=bcd"		
	저기에 값을 넣고,
		th:text="${abc}"
	이렇게 꺼내면됨
	당연히 객체도 들어가고
		th:with="first=${user[0]}"
		th:text="${first.username}"
	다됨
	그리고 이 지역변수는,선언한 태그 안에서만(<div>같은거면 그 안에서만)사용할수있음,그 스코프밖으로 퍼지진않음
	
	스프링부트 3.0부터는
		${#request}
		${#response}
		${#session}
		${#sevletContext}
	를 지원하지않고,남은건
		${#locate}
	만 남음
	그래서 3.0부터는 직접 모델에 넣어줘서 거기서꺼내든가해야함
	저거외에 편의기능은
		${param.paramData} //쿼리파라미터읽기
		${session.sessionData} //세션데이터읽기
		${@helloBean.hello('Spring!')} //스프링빈호출,${@빈이름.호출메소드(매개변수)}
	이 있음
	
	타임리프의 유틸리티객체는
		#message:메시지,국제화처리
		#urls:url이스케이프 지원
		#dates:java.util.Date 서식 지원
		#calenders:java.util.Calendar서식지원
		#temporals:자바8날짜서식지원
		#numbers:숫자서식지원
		#strings:문자관련편의기능
		#objects:객체관련기능제공
		#bools:bool관련기능제공
		#arrays:배열관련기능제공
		#lists,#sets,#maps:각각 컬렉션기능제공
		#ids:아이디처리관련기능제공
	등등 있음,생각했던거에서 대충 범주들어가는거 공식도큐찾아보면 잇음

	타임리프에서 자바8날짜인 LocalDate류,Instant등을 사용하려면 추가라이브러리가 필요함
	스프링부트 타임리프를 사용하면,해당 라이브러리가 자동으로 추가되고 통합됨
	사용방법은
		th:text"${#temporals.format(받을헤더명,'yyyy-MM-dd HH:mm:ss')}
	#temporals이 날짜서식을 지원하는 유틸객체임	
	
	
	타임리프에서 url생성할땐 @{}를 사용하면됨
		th:href="@{/hello}
	쿼리파라미터추가하고싶으면 괄호만()
		th:href="@{/hello(param1=${param1}, param2=${param2})}"
	패스배리어블쓰고싶으면(쿼리파라미터말고 경로에 변수넣고싶으면)
		th:href="@{/hello/{param1}/{param2}(param1=${param1}, param2=${param2})}"
	둘다쓰고싶으면
		th:href="@{/hello/{param1}(param1=${param1}, param2=${param2})}"
	즉,앞에 변수가있으면 그거부터 들어가고,만약 겹치는게없으면 쿼리파라미터로 들어감
	
	
	리터럴은,소스 코드상에서 고정된 값임
	타임리프에서 문자리터럴은 항상 ''로 감싸야함,근데 문자중간에 스페이스나 특수문자가 없으면 하나의 토큰으로 인정해서 리터럴로 만들어줌
	이때 -,_,.들은 들어가도됨
	스페이스를 넣어야하면
		th:text="'hello world!'"
	이렇게 넣어야함
	근데 그냥 ||사이에 넣는게 젤편함(리터럴 대체문법)
		th:text="|abcd 123 qqq ${data}|"
		
	타임리프에서 연산은 자바랑 별로 다를건없는데,귀찮은건 http엔티티를 사용해야하는게 귀찮음(<나 >)
	그래서 <,>이 있는건 gt,lt로 대체해서써야함
		> = gt
		< = lt
		>= = ge
		<= = le
		! = not
		== = eq
		!= = ne
	이렇게 써야함(! == !=는 그냥써도됨)
	
	
	그리고 조건문은
		(조건)? true값:false값
	elvis연산은(null체크,조건식의 편의버전)
		${data}?: '문자' = 데이터있을때출력:널일때출력
	no-Operation은 널이면(조건을 만족하지않으면) 타임리프태그를 아예 수행하지않는거,이러면 그냥 html원본그대로 나옴
		${data}?: _ = <span th:text="${data}?: _">데이터없음</span>
	이러면 데이터없음이 출력됨(타임리프무시되니까)
	
	
	타임리프는,th:뒤에 뭘 넣는식으로 동작함
	이때 해당하는속성이 있으면 대체,없으면 생성함
	그리고 덮기싫고 추가하고싶을때는
		th:attrappend = 속성값의 앞에 값을 추가,이거로추가할땐 스페이스바 안들어가니까 주의
		th:attrprepend= 속성값의 뒤에 값을 추가,이거로추가할땐 스페이스바 안들어가니까 주의
		th:classappend= class속성앞에 자연스럽게 추가,이거로 추가하면 스페이스바 들어감
		
		th:attrappend = "abc='abcd'" //이렇게쓰면됨
	
	html은 checked="false"라도 checked라는 속성이 존재하면 checked가 돼버림
	그래서 타임리프에서
		th:checked
	를 사용하면 값이 false일경우 checked속성자체를 제거해서 false를 리턴하게 해줌(체크표시를 풀어줌)


	타임리프에서 반복은 th:each를 사용함
		th:each="컬렉션에서꺼낸변수:${컬렉션}"
	컬렉션은 list,array,map등을 지원함
	그리고 반복의 상태확인은
		th:each="컬렉션에서꺼낸변수,상태확인변수명:${컬렉션}"
	인데,기본값이 컬렉션꺼낸변수+Stat임,즉 지정안해도 저렇게꺼내서확인할수있음
	
	이 Stat의 상태값은
		index:0부터 시작하는값
		count:1부터 시작하는값
		size:전체 사이즈
		even,odd:홀수짝수(tf) //두줄마다 색칠해줄때같을떄사용,가독성
		first,last:처음,마지막(tf)
		current:현재객체
	속성이 있음
	
	
	타임리프에서의 if는,해당값이 f이면 태그 자체를 랜더링하지않음(지워버림)
	사용법은
		<span th:text="'미성년자'" th:if"${user.age lt 20}:></span>
	이러면 age가 20보다 크면 태그자체가 없어져버림
	반대되는 unless도 있는데,그냥 tf만 반대로받고 똑같음
	스위치문도 있는데
		<td th:switch="${user.age}">
			<span th:case="10">10살</span>
			<span th:case="20">20살</span>
			<span th:case="*">몰루</span>
	*은 와일드카드,디폴트임	


	타임리프에서 주석은,html주석과 타임리프주석이 있음
	html주석은,기본적인 주석 소스보기로 보임
		<!--  ㅁㄹㅇㄴㄹㄴㄹ -->
	타임리프 파서주석은,이 사이에 있는걸,출력할때 그내용을 지워줌(소스보기로 못봄)
		<!--/* ㄹㄴㄹㄴㄹㄴ */--> //한줄
		<!--/*-->            //여러줄 시작
			<span>fsfs</span>
		<!--*/-->            //여러줄 끝
	이렇게 저거로 싸두면 저거도 없어짐
	
	타임리프 프로토타입주석은,타임리프로 랜더링 되면 실제 태그가 적힘(주석이아님),그냥 경로로 html불러오면 주석처리됨,안쓸거같음ㅋㅋ
		<!--/*/ ㄹㄴㅇㄹㄴ /*/-->
	
	
	타임리프에서 유일하게 태그를 추가하는게 <th:block>임
	이건 안에서 두개이상div에서 루프를 돌리거나 하고싶을때 사용됨(div2개이상을 묶고싶을때)
	얘는 랜더링될떄 사라짐,즉 each만으로 해결하기 어려울때 사용됨(태그하나에 속성변경으로 처리하기 애매할경우에)
	
	js인라인은 js에서 타임리프를 사용할때 좀더 편리해짐
		<script th:inline="javascript">
	이걸 사용하면 문자타입일경우 ""를 싸서주고,문제될만한 문자가 있으면 이스케이프처리도 해줌("->\")
	그냥 <script>사용할땐 무지성으로 붙여도될듯
	
	그리고 html파일을 그대로 열어도되는 내추럴템플릿에서,이걸사용해서 주석을 활용해서 이기능을 사용할수있음(js도 내추럴템플릿을 사용할수있음)
		var username2 =/*[[${user.username}]]*/"test username";
	이렇게 변수부분을 주석처리해두면,타임리프로 열면 뒤에를 지우고 주석을벗기고,직접열면 저게 주석이니까 무시돼서 내추럴로 동작할수있게해줌
	
	객체를 넣으면,json으로 바꿔줌
		var user =[[${user}]];
	이렇게 넣으면
		var user ={"username":"userA","age":10};
	이렇게 나옴
	
	그리고 이안에서도 each를 사용할수있음
		[# th:each="user,stat :${users}]
		var user[[${stat.count}]]=[[${user}]]
		[/]
	이렇게 사용할수있음
	이러면
		var user1 ={"username":"userA","age":10};
		var user2 ={"username":"userB","age":20};
		var user3 ={"username":"userC","age":30};
	이렇게 나옴

	타임리프는 웹페이지의 공통영역을 템플릿조각기능과 레이아웃기능으로 가져다쓸수있게 제공해줌
	가져다 쓰는 대상(함수역할)html에서
		<footer th:fragment="abcd">푸터자리입니다.</footer>
	이런식으로 th:fragment="abcd"이렇게 선언해두고
	메인에서
		<div th:insert="~{template/fragment/footer :: abcd}"></div>
	이렇게 insert를 하던가(th:insert="~{경로::이름}")
		<div th:replace="~{template/fragment/footer :: abcd}"></div>
	replace하던가
		<div th:replace="template/fragment/footer :: abcd"></div>
	이렇게하면 단순표현식(~{}를 빼도 단순하면 동작하는거,위랑 다른거없음)
	
	인서트는 현재 태그 내부에 해당 태그를 삽입함(div속성에 넣으면 div안에 추가함,<div><footer>)
	리플레이스는 현재 태그를 해당 태그로 변경함(div속성에 넣으면 div를 제거하고 해당속성으로 변경 <div> -> <footer>)
	
	파라미터도 넣을수있음
	함수html에서
		<footer th:fragment="copyParam (param1, param2)"><p>파라미터자리입니다.</p>
			<p th:text="${param1}"></p>
			<p th:text="${param2}"></p></footer>
	이렇게넣고
		<div th:replace="~{template/fragment/footer :: abcd("1번파라미터",2번파라미터)}"></div>
	이렇게 함수처럼 불러다쓸수있음
	
	이렇게 함수처럼 부르는거말고,코드조각을 레이아웃에 넘겨서 사용할수도 있음,이게 템플릿 레이아웃임
	즉 헤더부분이나 푸터를 만들어두고,그걸 가져다가 쓰면서 뭘 좀 추가하거나 하고싶을때 사용
	이건 th:replace를 헤드같은 엄청 html에서 큰덩어리에서 사용하는식으로 처리하면됨
	거기서
	위에서 공통부분을 처리한후에
		<html xmlns:th="http://www.thymeleaf.org">
		<head th:fragment="common_header(title,links)"><title th:replace="${title}">레이아웃타이틀</title>
			<!-- 공통 -->
			<link rel="stylesheet" type="text/css" media="all" th:href="@{/css/awesomeapp.css}">
			<link rel="shortcut icon" th:href="@{/images/favicon.ico}">
			<script type="text/javascript" th:src="@{/sh/scripts/codebase.js}"></script>
			<!-- 추가 -->
			<th:block th:replace="${links}"/>
		</head>
	밑에 블록을 넣어서
		<head th:replace="template/layout/base :: common_header(~{::title},~{::link})"><title>메인타이틀</title>
			<link rel="stylesheet" th:href="@{/css/bootstrap.min.css}">
			<link rel="stylesheet" th:href="@{/themes/smoothness/jquery-ui.css}">
		</head>
	이렇게 해당 이름의 태그들을 파라미터로 넘겨서 추가할수있음
	즉 템플릿조각이랑 비슷한데(템플릿조각에서 파라미터에 스트링 다박아버려도 똑같긴할듯),
	그냥 저걸 텍스트로 넘기기 너무기니까,태그로 서치해서 넘긴다고 생각하면될듯
	
	그리고 이걸 head같은정도에만 하는게 아니라,html태그에(전체에) 적용할수도있음
	이거도 위랑 똑같은데,그냥 전체를 만들어두고,약간약간 바꿔가면서 쓸때 사용함
		<html th:fragment="layout (title, content)" xmlns:th="http://www.thymeleaf.org">
		<head><title th:replace="${title}">레이아웃타이틀</title></head>
		<footer>레이아웃푸터</footer>
	이렇게 필요한부분만 replace하면서(리플레이스안시킨데는 그대로 나옴,공통부분)
		<html th:replace="~{template/layoutExtend/layoutFile :: layout(~{::title}, ~{::section})}"
		<head><title>메인페이지타이틀</title></head>
		<body>
		<section><p>메인페이지컨텐츠</p>
			<div>메인페이지포함내용</div>
	이렇게 넣고 바꾸는거임,위랑똑같음
	사실상 상속이랑 똑같아보여서 레이아웃 상속이라고 하는듯
	상속처럼 막 비슷한페이지 100개 만들고 이럴때 사용하기편한듯


2.타임리프와 스프링통합과 폼
	타임리프는 타임리프기본도큐먼트와,스프링통합도큐먼트 두개를 제공함
	이렇게 스프링통합을 하면 기능추가가 몇개되고,편해지는게 좀 있음
	
	예로
		${@myBean.doSomething()} //스프링빈호출
	폼관리를 위한 추가속성
		th:object
		th:field ,th:error,th:errorclass
	폼컨포넌트기능
		체크박스
		라디오버튼
		리스트
	스프링 메시지,국제화기능 통합
	스프링검증,오류처리 통합
	스프링변환서비스 통합
	
	이렇게 통합하려면 타임리프템플릿엔진을 스프링빈에 등록하고 뭐 어쩌고해야하는데,스프링부트쓰면 알아서해줌(그 starter.thymeleaf 추가되면)
	
	
	타임리프를 사용하면 폼처리가 많이 편해짐
	타임리프로 폼을 쓰려면,무조건 모델을 생성하고,모델에 빈 객체이라도 만들어서 뭐라도 하나 넣어둬야함(변수생성이라고보면됨)
		model.addAttribute("item", new Item());
	그리고
		<form action="item.html" th:action th:object="${item}" method="post">
	이렇게 키를 받아서 커맨드객체에 넣고(저걸 커맨드객체라고 부름,쟤로 조종하니까)
	값입력(input태그)에서
		<input type="text" id="itemName" name="itemName" th:field="*{itemName}" class="form-control"
                   placeholder="이름을 입력하세요">
	이렇게	
		th:field="*{itemName}"
	*은 위에서 th:object를 줄인거(item. 을 생략,즉 위에 오브젝트에 속한거라는거)
	이렇게 th:field가 있으면
		<input type="text" th:field="*{itemName}" class="form-control"
                   placeholder="이름을 입력하세요">
	이렇게 id와 name도 생략하면,필드명으로 들어감(itemName)
	
	즉 th.field는,id,name,value를 합친거고
	*{}는,앞에 위에서의 오브젝트의 객체를 붙이는거
	그리고 th:field의 값이 없으면,예외를 던짐(item.itemNamexx가 없다거나)
	
	이게 좋은건 검증할때 엄청 편해짐
	
	
	타임리프에서 체크박스,라디오버튼,셀렉트박스를 추가하는건

	자바 enum은
		public enum ItemType {
			BOOK("도서"), FOOD("음식"), ETC("기타");

			private final String description;

			ItemType(String description) {
				this.description = description;
			}
		}
	그냥 이렇게만들면됨(description은 설명)

	
	만약 html만 가지고 체크박스를 만들면,체크를 했을땐 true를 리턴하는데(정확히는 on이 넘어가는데 스프링이 이걸 true로 바꿔줌),
	체크를 안했을때 null이 반환됨(체크하지않으면 그 필드자체가 전송되지않음)
	생성은 뭐 안들어왔네 하면되는데,수정의경우 문제가 될수있음
	그래서 깡스프링에서는 앞에 타입히든에 언더바를 붙이는식으로 히든필드를 만들어서
		<input type="checkbox" id="open" name="open" class="form-check-input">
		<input type="hidden" name="_open" value="on"/> //다 고정이고,name만 체크박스와 통일하고 앞에 _붙이기
	이렇게 그 체크박스가 있다는걸 확인하고(체크박스와 이름이같은 히든타입),
	스프링이 false를 출력하는식으로 꼼수로 false를 받을수는 있는데,너무 귀찮음
	
	
	그래서 타임리프를 사용하면 알아서 해줌
		<input type="checkbox" id="open" th:field="*{open}" name="open" class="form-check-input">
	그냥 이렇게 th:field넣으면됨(이거도 똑같이 히든필드로 동작하는데,이걸 타임리프가 대행해주는거)

	그리고 스프링에서
		@ModelAttribute("regions")
		public Map<String, String> regions() {
			Map<String, String> regions = new LinkedHashMap<>();
			regions.put("SEOUL", "서울");
			regions.put("BUSAN", "부산");
			regions.put("JEJU", "제주");
			return regions;
		}
	이렇게 선언하면,그 컨트롤러를 호출할때에는 무조건 저 regions에 저값이 디폴트로 들어가있게됨
	물론 성능최적화관점에선 static로 할수있으면 그렇게하는게 낫긴할듯
	
	멀티체크박스는
	    <div>
            <div>등록지역</div>
            <div th:each="region : ${regions}" class="form-check form-check-inline">
                <input type="checkbox"
                       th:field="*{regions}"
                       th:value="${region.key}"
                       class="form-check-input">
                <label th:for="${#ids.prev('regions')}" th:text="${region.value}"
                       class="form-check-label">서울</label>
            </div>
        </div>
	이렇게 돌리면됨(th:each의 regions는 모델애트리뷰트에서 받은거,th:field="*{regions}"는 item의 region값)
	대충 value에 값이있으면 체크,없으면 비워두는걸 타임리프가 자동으로해줌
	th:for="${#ids.prev('regions')}"은,텍스트를 클릭해도 체크가 되게하려면,
	체크박스의 아이디를 라벨에서 알아야해서,for문의 직전의 id값을 받을수있음(어짜피 이거도 타임리프가 만드니까,id는 유니크해야하니)
		${#ids.prev('regions')}
	
	자바에서 enum의 값을 전부 리턴하는건
		ItemType.values()
	하면 값을 전부리턴함(배열로 리턴)
	
	타임리프에서 라디오버튼은 위랑 똑같은데(셀렉트박스랑)
		<input type="radio"
	이거만 바뀜
	그리고 얘는 체크를 안하면 null이 반환됨
	
	그리고 타임리프에서 enum을 직접접근할수있긴한데,컴파일오류를 못잡아서 추천하진않는대
	

	타임리프에서 셀렉트박스는
		<select th:field="*{deliveryCode}" class="form-select">
			<option value="">==배송방식선택==</option>
			<option th:each="deliveryCode : ${deliveryCodes}" 
					th:value="${deliveryCode.code}" th:text="${deliveryCode.displayName}">FAST
			</option>
		</select>
	이런식으로 셀렉트박스를 만들고,옵션을 each돌리면됨


3.메시지-국제화
	텍스트같은걸 한군데다 모아두면,수정하기가 편함,이게 메시지 기능임(파일에서 변수 불러다쓰는느낌)
	이걸 사용해서 언어별로 만드는식으로(파일을 2개만들어서)언어별로 다른값을 내보내는게 국제화
	accept-language같은거로 체크해서 다른걸 부르면됨
	
	그리고 스프링에서는 기본적으로 이런 메시지관리기능을 제공하고,타임리프도 이걸 통합해서 편하게쓸수있음
	이걸 사용하려면,MessageSource를 스프링빈으로 등록하면되는데,이건 인터페이스임
	그래서 ResourceBundleMessageSource를 스프링빈으로 등록하면됨
	그리고 그 메시지소스에
		messageSource.setBasenames("messages","errors")
		messageSource.setDefaultEncoding("utf-8")
	이렇게 디폴트이름을 정해주면,알아서
		messages_ko.properties
		messages_en.properties
	이렇게 바꿔가면서읽음
	파일의 위치는
		/resources/messages.properties
	에 두면되고,setBasenames에는 여러 파일을 한번에(지금도 메시지랑 에러 두개저장한거처럼)넣을수있음
	
	근데 스프링부트쓰면 자동으로 이걸 해줌
	그래서 application.properties에
		spring.messages.basename=messages //디폴트는 messages
	이렇게 넣기만하면됨
	디폴트값이 messages니까
		messages_en.properties
		messages_ko.properties
		messages.properties
	같은건 자동으로 인식함(모든언어지원안하면 messages.properties동작)

	
	@SpringBootTest
	이거붙이면 테스트실행할때 의존성주입해주니까,필드로 주입받아서 테스트돌리면됨
	    @Autowired
		MessageSource messageSource;

	메시지 받을땐
		ms.getMessage("hello", null, null);
		ms.getMessage(해당변수명, args, 국가값);
	이렇게 받으면됨
	그리고 해당 변수가 없어서 메시지를 못찾으면 NoSuchMessageException이 발생
		Assertions.assertThatThrownBy(() -> ms.getMessage("no_code", null, null))
		.isInstanceOf(NoSuchMessageException.class);
	저상황에서 기본값을 받고싶으면
		ms.getMessage("no_code", null, "기본메시지", null);
	이렇게 3번째에넣으면됨
	args사용시엔
		hello.name=gd{0} //메시지.프로퍼티파일
		
		ms.getMessage("hello.name", new Object[]{"Spring"}, null);
	이렇게 넣으면 gdSpring가 출력됨
	
	나라선택은
		ms.getMessage("hello", null, Locale.ENGLISH)
	이렇게 할수있음
	
	이 메시지를 타임리프에서 사용할땐
		#{}
		#{hello.name}
	이런식으로 바로 접근할수있음
	파라미터는
		#{hello.name(${item.itemName})}
		#{hello.name(1234)}
	이렇게 괄호치고 바로넣으면됨
	국제화는 그냥,_en,_ko같이 베이스네임에서 맞춰주기만하면 스프링이 알아서 accept-language같은거보고 호출함
	이 선택을 직접한다던가식으로 바꾸고싶으면,구현체를 변경해주면됨
	인터페이스는 LocaleResolver고
	기본적으론 AcceptHeaderLocaleResolver을 사용하는데,쿠키나 세션기반으로 구현체를 변경해주면됨
	

4.검증-밸리데이션
	컨트롤러의 중요역할중 하나는,http요청이 정상인지 검증하는것
	일반적으로 prg에서 p를 하다 검증실패하면,
	현재 값들을 모델에 담아 다시 리턴해서 원래url로 돌려주는게좋음(어짜피 값은 모델에 들어있을테니 에러만 모델에 넣어서 리턴해주면됨)
	그래서 빈값을 리턴해서 타임리프가 읽게한거
	
	부정의 부정은 읽기어려우니까(!errors.isEmpty()),이걸 메서드로 싸서 hasError같은거로 바꾸는게 가독성에서좋음
	
	그리고 타임리프에선
		<div th:if="${errors?.containsKey('globalError')}">
			<p class="field-error" th:text="${errors['globalError']}">전체오류메시지</p>
		</div>
	이렇게 출력하면됨
	여기서
		errors?
	는 만약 null이면 nullpointerexception이 발생하는대신,null을 반환하는 문법(스프링el문법,코틀린에도 있었던거같음)
	
	인텔리제이에서 폴더를 클릭하고 그 아래있는걸 컨트롤쉬프트r로 일괄수정할수있음
	
	
	
	스프링에서의 검증오류처리방법은 BindingResult임
		public String addItem(@ModelAttribute Item item, BindingResult bindingResult, 
								RedirectAttributes redirectAttributes, Model model) {
		}
	이렇게 담으면,저 BindingResult에 에러를 담으면됨
	그리고 주의할건,BindingResult파라미터는 무조건 검증할대상 바로 뒤, @ModelAttribute 바로 뒤에 와야함,
	앞에있는 어트리뷰트에 바인딩되는매커니즘이기때문
	
		bindingResult.addError(new FieldError("item","itemName","상품이름은 필수"));
		bindingResult.addError(new FieldError(오브젝트명,필드명,메시지));
	오브젝트명은 모델에트리뷰트에 담기는 이름,필드명은 오브젝트안의 필드명,메시지는 출력메시지
	만약 여러필드에 겹치거나,필드랑 상관없는에러면
		bindingResult.addError(new ObjectError("item","갯수x가격은 10000이상이어야함"+resPrice));
		bindingResult.addError(new ObjectError(오브젝트명,메시지));
		
	컨트롤p,현재 메서드의 매개변수,오버로드 출력
	
	그리고 검증할땐
		if (bindingResult.hasErrors()){
			return "원래주소"
		}
	로 넣고,모델애트리뷰트에 에러는 안넣어도됨,자동으로 모델에 담겨서 넘어감
	
	타임리프에서 렌더링할때 글로벌에러는
        <div th:if="${#fields.hasGlobalErrors()}">
            <p class="field-error" th:each="err:${#fields.globalErrors()}"
 			   th:text="${err}">전체오류메시지</p>
        </div>
	이렇게
		th:if="${#fields.hasGlobalErrors()} //글로벌에러가 있으면
		th:each="err:${#fields.globalErrors()}" //모든글로벌에러 foreach로 받아서
		th:text="${err['globalError']} //해당에러 출력
	그리고 필드에러는
		<div class="field-error" th:errors="*{itemName}">
			상품명오류
		</div>
	이렇게만 하면됨(해당오브젝트의 필드네임을 명시하면 에러있으면 출력하고(텍스트는 그 에러에 있는 텍스트를 출력))
	그리고
		th:errorclass="field-error"
	이건 에러가 있으면 저 클래스를 추가해줌(에러검색은 th:field에 있는 값에 에러가 매핑돼있으면 가져옴,즉 저기 에러는 저기 바인딩됨)
	
	
	bindingResult가 있으면,모델애트리뷰트에 데이터바인딩실패해도(인트에 스트링넣는다거나) 400이 뜨지않고,
	오류정보를 bindingResult에 담아서 컨트롤러를 정상호출함
	만약 저게없으면 그냥 400에러가 떠버리고 모델은 증발해버림(컨트롤러가 호출되지않음)
	
	이때 필드에러면,스프링이 직접 필드에러를 만들어서 우리가 담는거랑 똑같이 담음
	
	즉, 진짜 값을 넣는데 실패한오류와 값이 틀린(검증로직에서 탈락한) 오류로 구분할수있음
	
	
	그리고 만약 현재 값을 유지한채 에러메세지를 띄우고싶으면,FieldError에서 다른오버로드를 타면됨
		bindingResult.addError(new FieldError("item","itemName",item.getItemName(),
			false,null,null,"상품이름은 필수"));
		bindingResult.addError(new FieldError(오브젝트명,필드명,해당필드값,
				바인딩이 실패햇는지 여부,코드,아규먼트,오류메시지));		
	이 오버로드를 타면,해당 필드값을 그대로 넣어줄수있음
	
	즉,기본적으로 사용하는건 값을 유지하지않고 간단히 넣는거(api같은데서 사용할때),값 유지하는건 빡빡하게 넣는거
	
	그리고 모델애트리뷰트에 바인딩되는 시점에 오류가 발생하면,즉 바인딩이 실패하면(int에 string를 넣으면 컨트롤러단에서 처리할방법이없으니),
	저 바인딩리절트에러가 그 값을 오브젝트로 가지고있으면서,그걸 돌려줌
	이떄는 바인딩이 실패했으니 바인딩실패여부를 true로 줘야함
	
	그리고 타임리프가,정상상황에선 모델객체의 값을 사용하지만,오류가 발생하면 FieldError의 값을 출력함(그래서 모델에 못넣는값을 저장할수있는거)
	이거는 th:field가 이걸 담당함
	
	
	그리고 이렇게 오류메시지를 디폴트로 출력하면,스프링이 오류메시지를 적어둠(우리가 적었던 error의 마지막매개변수)
	저걸 어디 한군데다가 모아두고 사용할수있음(메시지처럼)
	이건 매개변수중 코드와 아규먼트로 해당값을 찾아서 있으면 그거출력,없으면 디폴트메시지를 출력하는식
	
	이건 그 메시지설정에 추가하고(message.properties밑에 추가하거나,같은식으로 추가)
		application.properties밑에
			spring.messages.basename=messages,errors
	그리고 코드에서
		bindingResult.addError(new FieldError("item","price",item.getPrice(),
			false,new String[]{"range.item.price"},new Object[]{1000,1000000},"가격은 1000~1000000사이"));
	이런식으로 코드에 해당하는 이름을 스트링배열로 넘기고(앞에서부터 찾아가는식,앞에없으면 두번째꺼,다없으면 디폴트출력),
	매개변수는 뒤에 오브젝트배열로 넘김
	에러메시지
		range.item.price=가격은 {0} ~ {1} 까지허용합니다.
	그리고 해당 메시지도 못찾고 디폴트도 없으면 그냥 에러페이지가 나옴
	
	즉 그냥 메시지소스걸쳐서 가는거
	이거도 너무 코드가 기니까 좀 줄일수있음
	
	컨트롤러에서 bindingResult는 검증객체를 이미 알고있음(자기앞에있는게 검증객체)
	그래서 오브젝트명같은걸 생략할수있음
	보통
	rejectValue()나 reject()를 사용함
		bindingResult.rejectValue("itemName","required");
		bindingResult.rejectValue("필드명","메시지의 맨앞단어 보통 제약을 적음");
	이렇게 하면
		required.item.itemName
		제약.오브젝트명.필드명
	으로 자동으로 찾아감
	아규먼트가 있을땐
		bindingResult.rejectValue("quantity","max",new Object[]{9999},null);
		bindingResult.rejectValue(필드명,제약,아규먼트의 오브젝트배열,디폴트메시지);
	이렇게 넣어주면됨
		
	오브젝트에러의경우엔
		bindingResult.reject("totalPriceMin");
		bindingResult.reject("에러코드");
	이렇게 전체를 다 적어줘야함
	
	그리고 제약메시지에서
		required=필수값입니다
		range=범위는 {0} ~{1}까지 허용
		max=최대 {0}까지 허용
	이렇게만 적고
		bindingResult.rejectValue("itemName","required");
	이걸 하면,디테일이 더 높은게 우선순위로 잡힘(required<required.item<required.item.itemName)
	그러니까 해당분류의 디테일을 조정하는것으로 디폴트메시지를 사용할수있다는거임
	
	이걸 단순하게만들면 범용성이좋고,세밀성이 떨어짐,대신 너무 자세하게 만들면 범용성이 떨어짐
	그래서 베스트는,범용성으로 사용하다가,세밀하게 사용해야할때만 세밀하게 적는것(유저랑 직접닿는부분)
	
	이걸 스프링은 messageCodesResolver을 사용해서 지원함
	얘는 에러코드를 넣으면,스트링배열로 해당하는걸 세밀한거부터 포함되는 모든걸 리턴해줌(앞에서부터우선순위)
	즉,rejectValue는 자기안에서 저걸불러서 받아오고, 제일앞에있는거 읽어서 그거 리턴하는거임
	이때 우선순위는
		제약.오브젝트명.필드명
		제약.필드명
		제약.타입(스트링같은,즉 해당타입별로 오류를 만들어둘수있음)
		제약
	이렇게 우선순위가잡힘
	
	이 messageCodesResolver는 기본적으로 DefaultMessageCodesResolver를 사용하는데
	얘의 기본메시지생성규칙은
	객체오류
		code+"."+오브젝트이름
		code
	여기서 코드는 required나 max같은거
	필드오류는
		코드+"."+오브젝트네임+"."+필드
		코드+"."+필드
		코드+"."+필드타입 (typeMismatch.int,typeMismatch.String)
		코드
	이렇게 됨,여기맞춰서 에러메시지를 적어주면됨
	
	이렇게 쓰면,적당히 퉁쳐서 쓸수있어서 편하고,필요한부분만 상세히 적을수있음


	그리고 bindingResult를 감싸는 if문을 없애는건
		ValidationUtils.rejectIfEmptyOrWhitespace(bindingResult,"itemName","required");
	이렇게 해당필드값이 비어있으면 작동하는식의 유틸도 있음

	
	그리고 스프링이 직접 만드는 검증오류(보통 타입정보)도 해당 오류에(타입의경우 typeMismatch)메시지를 적으면,해당메시지가 출력됨
	방식자체는 같으니까 직접 넣어주면됨
		typeMismatch=타입에러
	이렇게
	
	
	그리고 컨트롤러에서 검증로직이 차지하는 영역이 너무 크니까,이러면 이걸 별도의 클래스로 분리하는게 좋음
	그리고 이런 검증로직을 재사용할수있음
	
	그리고 스프링이 제공하는 인터페이스중 Validator 가 있음
		public class ItemValidator implements Validator {
	이렇게
	얘는 supports와 validate를 가지고있는데,supports는
		public boolean supports(Class<?> clazz) {
			return Item.class.isAssignableFrom(clazz);
		}
	이렇게 현재 검증할 클래스와 클래스호환이 되냐를 체크(item==clazz),물론 자식클래스도 호환(subItem==Item)
	그리고 검증로직은 validate에 넣으면됨
	    public void validate(Object target, Errors errors) {
			Item item=(Item) target;
			
			if (item.getPrice()==null || item.getPrice()<1000 || item.getPrice()>1000000){
				errors.rejectValue("price","range",
						new Object[]{1000,1000000},null);

			}
		}
	이때 타겟이 오브젝트로 넘어오니까 캐스팅해줘야함
		Item item=(Item) target;
	그리고 errors는 자식이 bindingResult니까 저기에 bindingResult를 넣을수있음
		errors.rejectValue("price","range",
				new Object[]{1000,1000000},null);
	그리고 저걸 @Component붙이고,private final ItemValidator itemValidator로 선언해주면 스프링이 주입해줌
	
	그리고 컨트롤러에는
	    if( itemValidator.supports(item.getClass())){
           itemValidator.validate(item,bindingResult);
        }
	이렇게 콜하면됨
	
	근데 Validator는 스프링에서 제공하니,이렇게 직접 부르지않고 스프링이 대신 실행시키게 할수있음
	이건 webDataBinder을 사용하면됨
		@InitBinder
		public void init(WebDataBinder dataBinder){
			dataBinder.addValidators(itemValidator);
			dataBinder.addValidators(orderValidator);
		}
	
	이걸 넣어주고,해당 객체에 어노테이션을 붙이면(@Validated @ModelAttribute Item item)
		public String addItemV6(@Validated @ModelAttribute Item item, BindingResult bindingResult, 
						RedirectAttributes redirectAttributes, Model model) {
	
	
	
	
	이 컨트롤러가 호출되면 그 요청에서 @Validated가 있으면 그 객체에 대해 밸리데이터가 동작하게됨(결과는 bindingResult에 담겨있음)
	@Validated는 검증기를 실행하라는 어노테이션인데,만약 검증기가 여러개라면 supports 루프돌려서 거기서 true뜨면 호출하는식임

	글로벌설정도 할수있는데,이건 필요해지면보자 있다는거만 알아두고(이거도 그냥 전체검증기에 디폴트값을 추가하는느낌일듯)
	이거하면 beanValidator이 동작하지않아서 보통 사용하진않음

5.검증2-빈 밸리데이션
	빈밸리데이션은,해당 엔티티필드(객체의 필드)에 어노테이션을 달아서,값을 자동으로 검증하는거
	이 빈 벨리데이션은 스프링이 아닌 자바표준이고(인터페이스),구현체로는 보통 하이버네이트 밸리데이터를 사용함
		@NotBlank  //빈값,공백만 있는걸 허용하지않음
		@NotNull   //널 허용안함
		@Range(min=10,max=100)//범위안의 값이어야함
		@Max(9999)  //최대 저정도값이어야함
	이런식의 어노테이션이 있음
		@NotNull
		@Range(min=10,max=100)		
		private Integer price;
	이런식으로 작성
	
	그리고 @Validated를 해당 엔티티에 붙여주면됨
	스프링부트는 자동으로 어노테이션을 글로벌 밸리데이터로 등록해버려서,이 밸리데이터를 보고 검증을 수행함
	즉,도메인에서 @NotNull같은거 붙이고 컨트롤러에서 해당도메인엔티티에 @Validated붙이면됨
	
	이때 검증순서는
		1.@ModelAttribute 각각의 필드에 타입변환시도
			성공하면 다음으로
			실패하면 typeMismatch로 fielderror추가
		2.Validator 적용
	이 순서로 됨
	즉 바인딩이 성공해야 밸리데이터가 동작함,즉 바인딩에 성공한 필드만 밸리데이션이 동작
	
	그리고 이 어노테이션들의 에러코드는
		@NotBlank  ->NotBlank.객체명.필드명 이런식
		@NotNull   ->NotNull.객체명.필드명  이런식
		@Range(min=10,max=100) ->Range.객체명.필드명  이런식
		@Max(9999)  ->Max.객체명.필드명  이런식
	이거도 타입미스매치랑 똑같이 
		Max.객체명.필드명
		Max.필드명
		Max.타입
		Max
	이런식으로 해당 어노테이션명을 제약으로잡고 그대로적음
	그래서 에러메시지프로퍼티에 저걸적는식으로 할수있음
	
	이건 필드에러들이고,여러 필드에 걸친 오브젝트에러도 처리가 가능하긴한데
		@Data
		@ScriptAssert(lang="javascript",script="_this.price * _this.quantity >= 10000",message="메시지")
		public class Item {
	이렇게 해당 클래스위에 붙여서 처리할수는있는데
	이건 잘 사용하지않음
	왜냐면
		제약이 많고,
		해당 객체의 범위를 벗어나는 검증이 불가능함
	그래서 그냥 자바코드(컨트롤러안에 직접 적거나 메소드로 뺴서 메소드실행)로 적는게 좋음 오브젝트에러는
	
	
	그리고 이렇게 빈밸리데이션을 적용할떄의 문제는,모든 이 도메인을 쓰는곳에 같은검증이 들어간다는것
	만약 추가할때와 수정할때의 요구사항이 달라도,하나로밖에 검증할수없음
	그래서 나온게 groups임(근데 form전송객체분리(dto)가 더 발전돼서 이걸더많이쓰긴함)
	이건 그냥 제약에 그룹을 정해두고,그 그룹별 검증을 넣어두는거
	
	이건 빈 인터페이스를 만들어두고,객체의 제약에 표시
		@NotNull(groups = UpdateCheck.class)
		@NotBlank(groups = {SaveCheck.class, UpdateCheck.class}) //여러개에 공통으로 포함될때
	이런식으로 넣어두고
	제약을 적용하는데서
		@Validated(SaveCheck.class) @ModelAttribute Item item,
	이렇게 넣으면됨
	
	근데 이건 복잡도가 올라가서 잘안쓰고,실무에선 dto를 사용함 보통
	그 이유는,보통 등록시 폼에서 전달하는데이터와 도메인객체가 딱 맞지 않기때문
	헬로월드수준이면 맞겠지만,좀 복잡해지기시작하면 약관정보등 별별 부가데이터들이 다 같이 넘어옴
	그래서 도메인객체를 직접 받는게 아닌,복잡한 폼데이터를 컨트롤러까지 전달할 별도의 객체를 만들어서 전달(dto)
	이런 폼을 전달받는 전용객체를 만들어서 이걸 ModelAttribute로 사용함
	즉
		form->itemSaveForm->Controller->item->Repository
	순서임
	
	그리고 입력만 받는게 아닌,생성에 필요한 추가데이터를 db에서 찾아오거나 해야할수도 있어서,조금만 복잡해져도 dto가 필요해짐
		@Validated @ModelAttribute("item") ItemSaveForm form
	이런식으로 쓰면되는데,뷰템플릿을 쓰면 클래스명으로 모델애트리뷰트에 기본으로 박히니,
	만약 사용하던 이름이 있으면 모델애트리뷰트에 명시해줘야 그이름으로 박아줌
	그리고 성공로직까지 가서 레포지토리에 담을때,도메인으로 변경해서 넣어주면됨(이부분에서만 도메인을 사용)
	
	이 빈 밸리데이션은 api에서도 사용할수있음
	그리고 @ModelAttribute는 쿼리파라미터,폼데이터용이고 @RequestBody는 req body를 객체로 변환할떄 사용
	
	근데 api로 보낼때 바인딩실패하면 컨트롤러로 안들어가고 튕겨냄(객체를 생성하는게 실패했을때)
	즉 api로 보낼땐,3가지 경우가 있음
		성공요청
		실패요청(객체생성을 실패해서 컨트롤러호출자체가 안됨)
		검증실패(객체생성은 성공했는데 검증에서 탈락)
	그리고 실제로 검증실패 로그찍을땐,전체반환이 아닌,거기서 필요한값들만 빼서 객체를 만든뒤 그 객체를 반환하는식으로 해야함
	
	모델애트리뷰트는 각 필드단위로 세밀하게 동작해서,한 필드가 오류발생해도 다른필드들은 처리가 가능했었음
	근데 리퀘스트바디(HttpMessageConverter)는 전체 객체단위를 하나로 잡아서 동작해서,객체단위로 성공해야 Validated가 동작함
	그래서 HttpMessageConverter에서 실패해버리면 예외가 발생해버림




6.로그인 처리1-쿠키,세션
	도메인=시스템이 구성해야하는 핵심 비즈니스업무
	web관련이 바뀌어도 도메인은 그대로 유지할수있어야함(웹은 도메인을 의존할수있지만,도메인은 웹을 의존하면안됨)
	그리고 dto같은거도 웹에 있음(이건 좀 논란있던거아닌가 dto의 변환위치)
	
	Optional<int> 널을 반환할수있는 변수타입
	함수.stream().filter(람다식) //컬렉션을 스트림으로 바꿔서,필터람다식을 거쳐서 맞는거만 다음거로 넘기고,findFirst()같은거로 사용
	회원가입도
		Optional<Member> byLoginId = memberRepository.findByLoginId(loginId);
        return byLoginId.filter(m -> m.getPassword().equals(password))
                .orElse(null);

	이런식으로 이퀄로 매칭해서 확인하면됨
	
	로그인 상태유지는 일단 세션이든 토큰이든 쿠키기반으로 동작함
	그렇다고 진짜 쿠키만쓰면,보안상 너무안좋으니까(쿠키에 아이디비번을 넣어두면 가로채기도쉽고 로컬에서도 빼갈수있으니),세션같은걸 사용하는거
	
	서버가 클라로 쿠키를 전달해주면,클라에선 쿠키저장소에 넣어둠
	쿠키는 쿠키저장소에 들어있으면,해당 url에 뭘 날릴때에 무조건 따라붙음 
	
	여기서 쿠키는 영속쿠키와 세션쿠키가 있음,영속쿠키는 지정된 날짜까지 유효,세션쿠키는 브라우저를 닫기전까지 유효
	날짜를 0으로 던지면 세션쿠키로 동작함
        Cookie idCookie = new Cookie("memberId", String.valueOf(loginMember.getId()));
        res.addCookie(idCookie);
	여기서 쿠키에 시간정보를 안주면  세션쿠키가됨
	
	크롬 개발자도구의 애플리케이션-스토리지-쿠키에서 쿠키볼수있음
	쿠키를 받을때는
		public String homeLogin(@CookieValue(name = "memberId", required = false) Long memberId){}
	이렇게 받을수있음(req헤더로 받아도되는데,그걸 간편하게해준거)

	로그아웃은 그냥 쿠키를 날리면됨
        Cookie cookie = new Cookie("memberId", null);
        cookie.setMaxAge(0);
        res.addCookie((cookie));
        return "redirect:/";
	이렇게 해당헤더명의 빈쿠키를 만들고,age를 0으로만들어서 던져주면됨

	
	이렇게 쿠키만 가지고 로그인유지를 하면,보안문제가 많음
		쿠키는 임의로 변경할수있음(브라우저에서 f12로 쿠키id를 변경한다던지)
		쿠키에 보관된값은 훔쳐갈수있음(네트워크에서 재킹하던가,로컬에서 훔쳐가던가)
		한번 훔쳐가면 평생 그값을 사용할수있음(id값이 고정이니까)
	이런 문제들이 있음
	
	그래서 쿠키엔 중요한값은 보관하지않고,사용자 별 해쉬값토큰을 노출하고,이 토큰과 사용자id를 매핑해서(레디스) 인식해야함
	토큰은 해커가 임의의값을 넣어도 찾을수없게 복잡한해쉬여야함
	해커가 토큰을 훔쳐가도 시간이지나면 사용할수없게 해당 토큰의 만료시간을 짧게 유지해야함,
	그리고 해킹의심되면 서버에서 해당토큰을 강제제거하면됨(이건선택)
	
	세션을 만들떈 uuid를 만들고 그걸 키값으로 쓰고,밸류에 id를 넣어두고 쿠키에 그 uuid를 넣어서 클라에 주면됨
	그리고 받은 uuid를 매칭해보고 있으면 그값을 사용하면됨
	즉 회원과 관련된 정보는 절대 클라에 주지않는다는거
	그리고 이 세션의 만료시간을 30분정도로 잡아버리면됨
	
	맵을써야하는데 동시성이슈가 있을때
		private Map<String, Object> sessionStore = new ConcurrentHashMap<>();
	uuid생성
		 String sessionId = UUID.randomUUID().toString();
	
	컨트롤알트c 상수로 변경
	
	세션을 직접 만들려면
	    public void createSession(Object value, HttpServletResponse res) {
			String sessionId = UUID.randomUUID().toString();
			sessionStore.put(sessionId, value);

			Cookie mySessionCookie = new Cookie("mySessionId", sessionId);
			res.addCookie(mySessionCookie);
		}
	이런식으로 만들면됨,uuid생성하고 그거랑 들어온 밸류로 세션스토어에 밀어넣고,uuid로 쿠키만들어서 res에 담기

	찾을떄는
	    public Cookie findCookie(HttpServletRequest req, String cookieName) {
			Cookie[] cookies = req.getCookies();
			if (cookies == null) {
				return null;
			}
			return Arrays.stream(cookies)
					.filter(cookie->cookie.getName().equals(cookieName))
					.findFirst()
					.orElse(null);

		}
	이렇게 찾아서 
		public Object getSession(HttpServletRequest req) {
			Cookie sessionCookie = findCookie(req, SESSION_COOKIE_NAME);
			if (sessionCookie == null) {
				return null;
			}
			return sessionStore.get(sessionCookie.getValue());

		}
	스토어로 검색돌려서 리턴해주면됨 밸류를
	세션만료는
	    public void expire(HttpServletRequest req){
			Cookie sessionCookie = findCookie(req, SESSION_COOKIE_NAME);
			if(sessionCookie!=null){
				sessionStore.remove(sessionCookie.getValue());
			}
		}
	이렇게 찾아서 날려주면됨
	테스트할때 res나 req는
		MockHttpServletResponse res = new MockHttpServletResponse();
	이렇게 모킹하고,이걸 HttpServletResponse대신쓸수있음
	req도 같음
	
	테스트에서 결과값 널일때
		Assertions.assertThat(expiredResult).isNull();

	이런 세션은 서블릿에서도 지원하니까 그냥 그거쓰면됨
	동작은 똑같고,추가로 세션을 일정기간 사용안하면 자동으로 삭제하는기능이 추가됨
	
	서블릿은 httpSession으로 지원함
	이거로 만들면 JSESSIONID로 쿠키를 만듬
	사용법은
	    HttpSession session = req.getSession();
        session.setAttribute("loginMember",loginMember);
	이렇게 로그인할때 현재 세션키값을 가져온뒤에(req.getSession은 만약 있으면 그걸 가져오고,없으면 생성함),
	거기에 현재 로그인 회원정보값을 밸류에 덮어주면됨
	그리고
		req.getSession(true)//기본값,세션이 있으면 기존세션반환,없으면 새세션반환
		req.getSession(false)//세션이 있으면 기존세션반환,없으면 null반환
	그리고 세션에 데이터를 보관할떄,한 세션에 여러값을 저장할수있음 
	
	세션을 삭제할땐
	    HttpSession session = req.getSession(false);
        if (session != null) {
            session.invalidate();
        }
	이렇게 삭제할수있음
	그리고 컨트롤러에서 세션을 받을땐,
		HttpSession session = req.getSession(false);
	로 받아야함
	저게 true면 세션을 만들어버려서 세션이 있는지없는지 체크가 안되기때문
	그리고
	    if (session == null) {
            return "home";
        }
	세션이 존재하는지 체크하고
        Member loginMember = (Member) session.getAttribute("loginMember");
        if (loginMember == null) {
            return "home";
        }
	세션에 해당값이 있는지 체크하면됨
	그리고 있으면
	    model.addAttribute("member", loginMember);
        return "loginHome";
	모델에 담아서 리턴하면됨
	
	그리고 당연히 스프링이 어노테이션으로 이걸 지원해줌
	세션을 받을때
		@SessionAttribute(name = SessionConst.LOGIN_MEMBER, required = false) Member loginMember
	이걸 사용하면됨
		@GetMapping("/")
		public String homeLoginV3Spring(@SessionAttribute(name = SessionConst.LOGIN_MEMBER, required = false) 
										Member loginMember,
										Model model) {
	그러면 세션이 있는지 체크하고 있으면 해당값을 담아서(없으면 null)던져줌
	이 기능은 세션을 생성하지않아서,로그인이 아닌(세션생성부분이 아닌),홈화면같은데서 체크할때 사용하면됨

	그리고 완전히 로그인 처음하면 url에 세션id가 적히는데,이건 웹브라우저가 쿠키를 지원하지않을까봐 url을 통해 유지하는거임,한번돌아서 쿠키사용하면 없어짐
	이걸 끄려면 application.properties에
		server.servlet.session.tracking-modes=cookie
	로 넣어주면됨
        session.getAttributeNames().asIterator()
                .forEachRemaining(name -> ...));
	이건 해당 컬렉션으로 forEach돌리는거
	
	그리고 세션의 정보들은
		session.getMaxInactiveInterval() //세션의 지속시간
		session.getCreationTime()  //세션이 만들어진시간
		session.getLastAccessedTime()//마지막 세션 접근시간
		session.isNew()           //세션이 방금만들어졌는지
	등이 있음
	그래서 마지막세션접근시간과 세션의 지속시간을 가지고,저게 넘으면 세션을 삭제하는거(처음만들어진시간으로하면 귀찮으니까)
	그리고 뭐 세션만들어지고 한달지나면 지워버리는정도로
	이때 기본값은 30분이고,설정은 application.properties에서
		server.servlet.session.timeout=1800
	저거 원하는값으로 넣으면됨(분단위로 넣어야함)
	그리고 특정 세션에서 다르게쓰고싶으면
		session.setMaxInactiveInterval(1800)
	넣어주면됨

	그리고 세션에는 최소한의 데이터만 보관해야함,그래야 메모리사용량이 줄어듬
	그리고 세션의 시간도 적당히 잡아야함
	그리고 장기로그인은 리프레시토큰으로 유지됨

7.로그인처리2-필터,인터셉터
	서블릿필터는,공통관심사를 한번에 처리할수있는 기능임
	즉 모든 요청이 들어가기전에,로깅을하거나 로그인체크를 한다던가 이런 작업들이 필요할때 사용함
	이건 스프링의 aop와 같은영역이긴한데,웹과 관련된 공통관심사는 서블릿필터나 스프링인터셉터를 사용하는게 좋음
	이유는 얘들은 http헤더나 url정보를 읽을수있는(특정url만 체크하고 아니면 패스한다던가) HttpServletRequest를 제공하기때문
	
	기본적으로 필터를 다 거치고,필터가 다 성공해야 디스페처서블릿으로 들어가게됨

	서블릿필터의 요청흐름은(여기서 서블릿은 디스패처서블릿)
		요청시작->was->필터->서블릿->컨트롤러
	정상루틴은 이렇고
	필터에서 아니다싶으면 끊을수있음
		요청시작->was->필터
	그래서 로그인체크하기 좋음
	그리고 필터가 필터를 콜할수있음
		요청시작->was->필터1->필터2->필터3->서블릿->컨트롤러
	그 익스프레스에서의 미들웨어라고 생각해도될듯
	
	필터는 Filter(서블릿꺼 임포트)인터페이스를 구현하고 등록하면,이걸 싱글톤객체로 생성해서 관리함
	이떄 메소드는
		init()//필터초기화메서드,서블릿컨테이너가 생성될때 호출됨
		doFilter()//고객의 요청이 올때마다 해당메서드호출,필터로직을 구현하면됨,즉 메인메서드
		destroy()//필터종료메서드,서블릿컨테이너가 종료될떄 호출됨
	가 있음
	여기서 doFilter만 구현해주면됨(init랑 destroy는 default 메서드라서 구현안해도됨)

	그리고 doFilter에선 ServletRequest로 매개변수를 받는데,저건 기능별로없어서 불편하니
		HttpServletRequest HttpReq = (HttpServletRequest) request;
	이렇게 다운캐스팅해주는게좋음(저게 HttpServletRequest의 부모임)
	
	그리고 doFilter내에서
		chain.doFilter(request,response);
	를 하면 다음필터나 필터가없으면 디스패처서블릿이 호출되고
	저걸 안하면 저기서끝남
	
	그리고 이 필터를 등록해야하는데
	그냥 클래스 하나만들어서 빈을 등록해주면됨
		@Configuration
		public class WebConfig {
			@Bean
			public FilterRegistrationBean logFilter() {
				FilterRegistrationBean<Filter> filterRegistrationBean = new FilterRegistrationBean<>();
				filterRegistrationBean.setFilter(new LogFilter());
				filterRegistrationBean.setOrder(1);
				filterRegistrationBean.addUrlPatterns("/*");

				return filterRegistrationBean;
			}
		}
	이때
		filterRegistrationBean.setFilter(new LogFilter());//해당 필터를 등록
		filterRegistrationBean.setOrder(1);//해당필터의 체인순서 정해주기
		filterRegistrationBean.addUrlPatterns("/*");//해당필터가 동작할 url패턴
	이렇게 넣어주면됨
	
	그리고 doFilter내에서
        try {
            log.info("Req{}:{}", uuid, requestURI);
            chain.doFilter(request, response);
        } catch (Exception e) {
            throw e;
        } finally {
            log.info("res{}:{}", uuid, requestURI);
        }
	이런식으로 하면,doFilter전에 처리할거 다하고 doFilter호출하고나서 모든 요청이 끝나면finally가 동작해서 마지막동작까지 할수있음
	즉 시작전과 종료후에 작업을 칠수있음(요청과 응답 둘다 볼수있다는거)
	그래서 요청이 얼마나 걸렸나에 대한시간체크같은거도 가능함
	
	그리고 같은 요청의 로그에 모두 같은 식별자를 남기는건 logback mdc를 사용할수있음(검색)
	
	로그인체크는 화이트리스트를 만들고
		private static final String[] whitelist = {"/", "/members/add", "/login", "/logout", "/css/*"};
	여기서 홈,회원가입,로그인,로그아웃,css는 접근할수있어야함! 
	해당 스트링과 url이 일치하는지 확인하는 메서드만들어서
		private boolean isLoginCheckPath(String reqURI) {
			return !PatternMatchUtils.simpleMatch(whitelist, reqURI);
		}	
	이걸 필터에서 받아서 if문돌리면됨(즉 필터빈에서 한번 거를수있고,여기서 한번거를수있고 두번 거를수있음)
		try {
			log.info("인증체크필터시작", requestURI);
			if (isLoginCheckPath(requestURI)) {
					log.info("인증체크로직실행 {}", requestURI);
					HttpSession session = httpReq.getSession(false);
					if (session == null || session.getAttribute(SessionConst.LOGIN_MEMBER) == null) {
						log.info("미인증사용자요청{}", requestURI);
						httpRes.sendRedirect("/login?redirectURL=" + requestURI);
						return;
					}
				}
			chain.doFilter(request, response);
        } catch (Exception e) {
            throw e; //여기서 로깅할수있는데,일단 던지긴해야함
        } finally {

        }
	이런식으로 아니다싶으면 필터선에서 컷해버리면됨
	여기서 
		httpRes.sendRedirect("/login?redirectURL=" + requestURI);
	sendRedirect로 해당 url로 던져버릴수있는데,저기서 ?redirectURL=를 주면 저기의 행동이 끝나고나서 다시 원래요청페이지로 돌려달라는거
	해당 컨트롤러에서 있는지없는지보고 if문걸어서 리다이렉트해주면됨
		@RequestParam(defaultValue = "/") String redirectURL //로그인 매개변수받는곳에 추가하고
		return "redirect:"+redirectURL; //저걸 리다이렉트에 더해주면됨,디폴트가 /니까 없으면 저기로 가는거고
	이렇게 해주면됨
	
	
	스프링의 인터셉터는 서블릿필터처럼 공통관심사를 처리함
	얘는 서블릿필터와 적용되는 순서와 범위,사용방법이 다름
	
	스프링 인터셉터는 스프링기반이기때문에,무조건 디스패처서블릿을 거쳐야함
		요청->was->필터->디스패처서블릿->인터셉터->컨트롤러
	즉 잘못된요청으로 막아도,컨트롤러로 들어가는거만 막을수있음(스프링mvc의 시작이 디스패처서블릿이니까)
		요청->was->필터->디스패처서블릿->인터셉터
	그리고 인터셉터의 url패턴은 매우 정밀하게 설정할수있음
	
	즉 서블릿필터 강화판이라고 보면됨
	
	스프링 인터셉터는 HandlerInterceptor인터페이스를 구현하고,얘는
		preHandle() //컨트롤러호출전
		postHandle()//컨트롤러호출후
		afterCompletion()//요정완료이후
	메서드가 있음(전부 default라서 구현하고싶은거만 구현해도됨)
	그래서 try catch finally로 트릭써서할필요가없음
	이건 리턴값이 tf로 있는데,리턴값이 true면 다음으로 진행,false면 거기서 멈춤
	
	그리고 인터셉터는 어떤 컨트롤러(핸들러)가 호출되는지에 대한 정보와,어떤 modelandview가 반환됐는지 정보도 받을수있음
	afterCompletion은 뷰가 렌더링된이후에 호출됨
	그리고 afterCompletion은 예외가 뜨던말든 무조건 호출됨(그래서 예외출력도 가능함,예외뜨면 예외가 넘어옴)
	    if (ex != null) {
            log.error("after error", ex);
        }
	postHandle은 컨트롤러에서 예외가 발생하면 호출되지않음
	그래서 종료처리는 afterCompletion에 하는게좋을듯
	
	그리고 preHandle에서 afterCompletion으로 데이터를 넘겨야하거나 그러면 그냥 req에 setAttribute로 넘기면됨
	그리고 handler에는 호출할 컨트롤러메서드의 모든 정보가 포함돼있음
	
	그리고 등록은
		public class WebConfig implements WebMvcConfigurer {
	저거 받아서
		@Override
		public void addInterceptors(InterceptorRegistry registry) {
			registry.addInterceptor(new LogInterceptor())   //해당 인터셉터 생성후 등록
					.order(1)       //순서
					.addPathPatterns("/**")  //적용할 패턴
					.excludePathPatterns("/css/**","/*.ico","/error"); //그중에서 제외할 패턴
		}
	이걸 구현해주면됨,이렇게 패턴적용이 정밀하게 할수있어서 편함(정규표현식)
	로그인체크인터셉터는
		@Override
		public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
			String requestURI = request.getRequestURI();
			log.info("인증체크인터셉터 실행{}", requestURI);

			HttpSession session = request.getSession();
			if (session == null || session.getAttribute(SessionConst.LOGIN_MEMBER)==null){
				log.info("미인증사용자{}");
				response.sendRedirect("/login?redirectURL="+requestURI);
				return false;
			}
				return true;
		}
	이렇게 하면됨,화이트리스트같은거도 인터셉터등록에서 처리하니,진짜로 인증검사만 하면됨
		public void addInterceptors(InterceptorRegistry registry) {
			registry.addInterceptor(new LogInterceptor())
					.order(1)
					.addPathPatterns("/**")
					.excludePathPatterns("/css/**", "/*.ico", "/error");
			registry.addInterceptor(new LoginCheckInterceptor())
					.order(2)
					.addPathPatterns("/**")
					.excludePathPatterns("/css/**","/login","/");
		}


	
	argumentResolver는, 매개변수를 합쳐서 객체로 만들던가 dto로 만들던가 하는식으로,받는거임
		public String homeLoginV4Spring(@Login Member loginMember,  //@Login은 커스텀 어노테이션임
										Model model) {
	req를 접근할수있으니까,req를 받아서 가공을 해서 리턴해주는식으로 동작됨							
	이건 근데 어노테이션생성하고 귀찮은게 좀있어서,나중에 필요하면보자



8.예외처리와 오류페이지	
	서블릿에서 예외처리는
		exception
		response.sendError(http상태코드,오류메시지)
	이렇게 두가지 방식으로 처리함
	
	일반적으로 자바의 메인메서드를 직접실행하면 main이라는 쓰레드가 실행되고,
	main을 넘어서 예외가 던져지면 예외정보를 남기고 해당 쓰레드는 종료됨
	
	근데 웹 어플리케이션은 사용자 요청별로 쓰레드가 할당되고,서블릿컨테이너 안에서 실행됨
	근데 예외를 못잡고 서블릿 밖으로 예외가 전달되면,결국 was까지 가게됨
	그렇게되면 was가 자기의 예외페이지를 500으로(그 예전에 많이보이던 예외페이지)를 띄워버림
	
	이건 예외고,res에 sendError로 오류가 발생했다는걸 알릴수있음
	이걸쓰면 저 에러코드를 맘대로 수정하고,오류메시지도 추가할수있음
		response.sendError(http상태코드,오류메시지)
	이건 비정상종료는 아닌,사전에 설정한 루틴이니,정상적으로 리턴되다가 was가 마지막에 res를 까보고 여기에 error이 있으면 오류페이지를 띄우는식임
	
	이 기본화면은 보기불편하기때문에,페이지를 바꿀수있음(오류화면을 등록할수있음)
	이렇게 만들고
		@Component
		public class WebServerCustomizer implements WebServerFactoryCustomizer<ConfigurableWebServerFactory> {
			@Override
			public void customize(ConfigurableWebServerFactory factory) {
				ErrorPage errorPage404 = new ErrorPage(HttpStatus.NOT_FOUND, "/error-page/400");
				ErrorPage errorPage500 = new ErrorPage(HttpStatus.INTERNAL_SERVER_ERROR, "/error-page/500");
				ErrorPage errorPageEx = new ErrorPage(RuntimeException.class, "/error-page/500");
				
				factory.addErrorPages(errorPage404,errorPage500,errorPageEx);				
			}
		}
	이렇게 등록하면됨
	그럼 저 예외나 에러코드가 뜨면 저 페이지로 보냄(다시 저 페이지를 호출한다고 생각하면될듯)
	그래서 필터 인터셉터들도 다시 호출됨(서버내에서 다시 http요청을 넣은거니까,설정값에 따라 다를순있음)
	그리고 저 오류를 처리해줄 컨트롤러에서 해당 뷰를 호출해주면됨
		@RequestMapping("/error-page/400")
		public String errorPage404(HttpServletRequest req, HttpServletResponse res) {
			return "error-page/404";
		}
	그리고 각종 정보들을 받을수있는데
		예외타입
		메시지
		그 url
		예외띄운 서블릿명
		상태코드
		디스패쳐타입
	들을 받아볼수있음
	
	그리고 예외가 발생했을때 필터와 인터셉터를 다시 호출하는건 비효율적임
	그래서 클라이언트쪽의 요청인지,오류페이지표시를 위한 내부요청인지를 구분할수있어야하는데,그래서 사용되는게 DispatcherType임
	기본적으로 클라가 요청을 하면 dispatcherType는 Request임
	그리고 오류가 났을때의 dispatcherType는 Error임
	
	필터는 이거로 구분해서 error일경우엔 동작하지않음(디폴트값)
	여긴 값이 여러개있는데
		forward //서블릿에서 다른서블릿을 호출할때
		request //클라에서 요청들어올때
		error   //에러요청일때
	등이 있음
	
	그리고 필터의 DispatcherType설정에서 이걸 사용할 디스패처타입을 지정해주면됨
		filterFilterRegistrationBean.setDispatcherTypes(DispatcherType.REQUEST, DispatcherType.ERROR);
	기본값은 DispatcherType.REQUEST만 허용
	
	인터셉터는 DispatcherType같은게 없으니,해당 url패턴에서 막아버리면됨(.excludePathPatterns("/error-page/**"))


	근데 그냥 스프링부트쓰면,예외처리용컨트롤러같은거도 기본적으로 제공해주기때문에(BasicErrorController),
	정해진 이름으로 html만 만들어두면 그걸 알아서 호출함
		resources/templates/error/404.html  //뷰템플릿
		resoutces/static/error/4xx.html //정적 리소스
		resources/templates/error.html //대상이없을떄의 기본값
	우선순위는
		뷰템플릿-정적리소스-디폴트값
	같은 순위내에선 자세한거(404>4xx)가 더 우선순위가 높음
	즉 서블릿밖으로 예외가 나가거나,setError이 호출되면,모든 오류는 해당 /error에서 찾아가게됨(상태값없거나 예외면 500이 기본)
	
	이 BasicErrorController는 여러 값들을 모델에 담아서 전달해줌
	그래서 이거로 로그를 찍어두거나 뷰템플릿에서 랜더링할수있음
	값들은
		timestamp:시간
		status:에러코드
		error:에러명
		exception:예외명
		trace:예외난곳
		message:에러메시지
		errors:바인딩리절트
		path:클라이언트 요청 경로
	들이 있음
	그리고 기본값으로 exception,message,trace,errors는 null로 줌(보안상)
	그래서 application.properties에서
		server.error.include-exception=True
		server.error.include-message=always
		server.error.include-xxx:True
	이거 추가해주면 저기에 추가됨(true아니면 always임)
	always에는 on_param을 넣으면 파라미터가 있으면 표시됨(?message=&errors=)
	근데 보통 저런거 보여줄일없을듯
	
	그리고 server.error.path로 오류경로를 지정할수있음




9.api 예외처리
	html페이지는 그냥 예외코드랑 페이지만 있으면 처리가 되는데,api의 경우엔 각 오류상황에 맞는 오류 응답 스펙을 정하고,json으로 던져줘야함
	
	서블릿에서 api예외처리를 할때,그냥페이지랑 api랑 동시에 있을경우
		@RequestMapping(value = "error-page/500",produces = MediaType.APPLICATION_JSON_VALUE)
	accecpt를 기준으로 분류해서 컨트롤러를 2개만드는식으로 해결할수있음(자세한거부터 우선순위잡히니)
		@RequestMapping(value = "error-page/500", produces = MediaType.APPLICATION_JSON_VALUE)
		public ResponseEntity<Map<String, Object>> errorPage500Api(HttpServletRequest req,
																   HttpServletResponse res) {
			log.info("api 500");
			Map<String, Object> result = new HashMap<>();
			Exception ex = (Exception) req.getAttribute(ERROR_EXCEPTION);
			result.put("status", req.getAttribute(ERROR_STATUS_CODE));
			result.put("message", ex.getMessage());
			Integer statusCode =(Integer) req.getAttribute(ERROR_STATUS_CODE);
			
			return new ResponseEntity<>(result, HttpStatus.valueOf(statusCode));
		}
	이런식으로 json을 만들어서 리턴해주면됨(맵보단 객체가 낫긴할듯)
	
	api예외처리도 스프링부트가 제공하는 기본오류처리방식을 사용할수있음(BasicErrorController)
	즉 아무것도 등록하지않고 예외가 뜨면
		{
			"timestamp": "2023-02-27T04:00:25.936+00:00",
			"status": 500,
			"error": "Internal Server Error",
			"exception": "java.lang.RuntimeException",
			"message": "잘못된사용자",
			"path": "/api/members/ex"
		}
	이런식으로 리턴해줌
	얘도 accecpt를 기반으로 구분해서 던져줌(html을 먹을수있는 accecpt이면 그게우선,아니면 나머지 전부는 json)
	
	여기서도 그 server.error.include-message같은거 먹히니까 조심
	그래서 에러로그를 사용하자
	
	
	그리고 보통 @ExceptionHandler를 사용함
	오류페이지 표시에서는 BasicErrorController를 사용하지만,보통은 api마다 결과값을 다르게 출력해줘야하는경우가 많아서 api는 저걸 잘 안씀

	handlerExceptionResolver는 서블릿에서 예외에따른 상태코드의 변화(기본적으론 500으로 다 들어가니)와,
	오류메시지,형식들을 api마다 다르게 쓰고싶어서 생긴 기술임
	보통 줄여서 ExceptionResolver이라고 함
	얘는 postHandle위치에서 동작하게됨(핸들러 다음,당연히 postHandle은 호출되지않음)
	
	이 handlerExceptionResolver 인터페이스를 구현하면됨

		@Override
		public ModelAndView resolveException(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) {
			try {
				if (ex instanceof IllegalArgumentException) {
					log.info("일리걸이면 400으로바꿈");
					response.sendError(HttpServletResponse.SC_BAD_REQUEST, ex.getMessage());
					return new ModelAndView();
				}
			} catch (IOException e) {
				log.error(e);
			}

			return null;
		}
	이렇게 예외로 if걸어서 에러코드 생성해주고 새로운 빈 모델앤뷰 던져주면됨(예외를 먹고 상태코드로 바꿧다고 생각해도될듯)
	즉 이렇게되면 예외가 사라지고 http상태코드가 생김
	그리고 null로 반환하면 아무일없고 그냥 지나가게됨
	이때 반환값에 따른 동작방식은
		빈 모델앤뷰:뷰를 렌더링하지않고,정상흐름으로 서블릿리턴
		들어있는 모델앤뷰:해당 뷰를 렌더링(그래서 뷰를 렌더링해서 줄수도있고)
		null:다음 ExceptionResolver를 찾아서 전달(미들웨어처럼),없으면 그냥 서블릿밖으로 예외를 던짐
	그리고 res.getWriter().printLn("abcd") 이렇게 응답바디에 직접 데이터를 넣어서 줄수도 있음,
	즉 여기에 json넣어서 api응답처리할수있음
	그리고 webconfig에서
	    @Override
		public void extendHandlerExceptionResolvers(List<HandlerExceptionResolver> resolvers) {
			resolvers.add(new MyHandlerExceptionResolver());
		}
	등록해주면됨
	
	이렇게 여기서 모든 예외를 커버쳐주는게 좋음
	
	
	그리고 이 ExceptionResolver를 스프링이 래핑해둬서 날로먹을수있음
	
	스프링부트가 기본으로 제공하는 ExceptionResolver는
		ExceptionHandlerExceptionResolver //@ExceptionHandler를 처리
		ResponseStatusExceptionResolver //http상태코드를 지정,@ResponseStatus(value=HttpStatus.NOT_FOUND)
		DefaultHandlerExceptionResolver//스프링 내부 기본 예외를 처리
	위에서부터 우선순위고,처리되면 밑으로 안내려감(null반환해야 다음으로),
	우리가 써야할건 ExceptionHandlerExceptionResolver이거로 보통 예외처리를함

	ResponseStatusExceptionResolver는 그냥 자동으로 500을 지정한 상태코드로 바꿔주는거
	얘는
		@ResponseStatus
		ResponseStatusException
	두개를 처리함
	이건 해당 내가 만든 예외에 @ResponseStatus를 달면됨
	얘도 그냥 예외받아서 상태코드로바꾸고 빈 모델앤뷰 던지는,우리가 만드는거랑 똑같은방식임
	
	그리고 예외 메시지를 http오류메시지로 바꿔줌(설정있으면 출력됨)
	그리고 예외 메시지를 error.bad같이,그 국제화에서 썻던거처럼 세팅하고
	messages.properties에 error.bad=abcd 넣어두면 abcd를 출력해줌
	
	그리고 우리가 만들지않는 예외엔 @ResponseStatus를 붙일수없으니
		throw new ResponseStatusException(HttpStatus.NOT_FOUND,"error.bad",new NullPointerException());
	이런식으로 해당예외를 싸서 주면 저거보고 http상태코드랑 메시지붙이고,래핑벗기고 저 예외 다시 던져줌(try catch에서 e잡고 넣어주면될듯)


	DefaultHandlerExceptionResolver는,스프링내부에서의 스프링예외를 처리함
	대표적으로 파라미터바인딩 실패(int에 string에 들어온다던지)같은것들을 처리해줌
	이건 스프링이 만든 예외들만 명시해서 받아서,해당하는방식으로 처리함
	파라미터바인딩실패같은건 400으로 보낸다던지..


	일반적으로 api 오류를 처리할땐 @ExceptionHandler를 사용하게되고,모델앤뷰도 필요없고 정밀한 제어를 해서 json을 만들어 내려보내줘야함
	@ExceptionHandler를 사용하면 어노테이션으로 처리할수있음

	사용법은
		@ExceptionHandler(IllegalArgumentException.class)
		public ErrorResult illegalExHandler(IllegalArgumentException e){
			log.error("[exception]ex",e);
			return new ErrorResult("Bad",e.getMessage());
		}
	저기서 ErrorResult는 내가 만든 에러코드dto라고보면됨
	이렇게 컨트롤러에 선언을 하면,여기 컨트롤러내에서 저 예외가 터졌을경우,저걸 받게됨
	즉,여기서 IllegalArgumentException이 터지면,저 ErrorResult를 변환한 json을 받게된다는거
	이경우,예외가 내부에서 처리되니,완전히 정상로직이라서 http상태코드가 200이 되버리니(그래도 postHandle는 당연히 동작안함,핸들러는 예외떳으니)
		@ResponseStatus(HttpStatus.BAD_GATEWAY)
		@ExceptionHandler(IllegalArgumentException.class)
	위에 상태코드 넣는거도 보통 세트로 따라옴
	그리고 매개변수로 받으니 @ExceptionHandler옆에 명시안해도 되긴함
		@ResponseStatus(HttpStatus.BAD_REQUEST)
		@ExceptionHandler
		public ResponseEntity<ErrorResult> userExHandler(UserException e) {
			log.error("[exception]ex", e);
			ErrorResult errorResult = new ErrorResult("user-ex", e.getMessage());
			return new ResponseEntity<>(errorResult, HttpStatus.BAD_REQUEST);
		}
	이런식으로 그냥 해당 예외를 url로 처럼 받는 컨트롤러라고 생각해도될거같음,리턴값은 진짜 뭐 컨트롤러가 줄수있는건 다줄수있음(뷰템플릿같은거도 당연히가능)
		@ResponseStatus(HttpStatus.INTERNAL_SERVER_ERROR)
		@ExceptionHandler
		public ErrorResult exHandler(Exception e) {
			log.error("[exception]ex", e);
			return new ErrorResult("Bad", e.getMessage());
		}
	이런식으로 설정하면,모든 예외를 받을수도있음,당연히 여기도 기본적으로 자세한거부터 우선순위를 가짐
	그리고 예외는,부모클래스를 잡으면 해당클래스의 자식클래스까지 다 잡을수있음(그래서 Exception잡으면 다잡히는거)
	물론 자세한거부터 우선순위잡히고
	
	이게 좋긴한데,예외처리랑 정상동작이랑 같은공간에 있는게 불편하거나,여러군데서 같은거쓰고싶으면,@ControllerAdvice로 외부로 뺼수있음
	이건
		@ControllerAdvice
		@RestControllerAdvice //ControllerAdvice에 ResponseBody붙은거
	두개가 있음
		@Slf4j
		@RestControllerAdvice
		public class ExControllerAdvice {
		
		}
	이렇게 사용하면됨
	이쪽에서 컨트롤러를 지정할수있음(aop를 컨트롤러대상으로 사용하는느낌)
		@RestControllerAdvice(annotations = RestController.class)//저 어노테이션이 컨트롤러레벨에 붙어있는 컨트롤러
		@RestControllerAdvice("org.example.controllers")//해당 패키지 하위에 있는 컨트롤러들
		@RestControllerAdvice(assignableTypes = {ControllerInterface.class,
								AbstractController.class})//구현체나,인터페이스를 직접 지정,즉 클래스를 지정,부모면 자식도포함
	생략하면 전체컨트롤러에 적용됨(기본값으로 작동)
		
		
10.타입컨버터
	타입을 중간에 변경할때는 보통 타입컨버팅을 거쳐야하는데,스프링은 명시하면 알아서 바꿔줌
		@RequestParam Integer data
	이걸쓰면 스프링이 스트링을 알아서 인트로 타입변환해서 넣어주는거
	모델애트리뷰트같은거도 다 같은방식
	
	이 타입컨버터는 당연히 기본적으로 주는 타입은 다 변환이 되는데,내가 새로운 타입을 만들었으면,컨버터 인터페이스를 구현하면 됨
	만약 스트링 true가 오면 bool로 변환하고싶으면,string->bool 컨버터를 만들어서 등록하면되는거

	타입컨버터는 Converter를 구현하면됨(org.springframework.core.convert.converter.Converter)

	@EqualsAndHashCode 해쉬코드가 같으면 같은객체
	
	스프링은 이런 컨버터를 등록해두면 모델애트리뷰트나 RequestParam같은걸 자동으로 바꿔주는데,이건 컨버전서비스가 알아서 바꿔줌
	
	이 컨버전서비스는,컨버팅이 가능한지 확인하는기능과 컨버팅기능으로 된 인터페이스로 구현됨
	    DefaultConversionService conversionService = new DefaultConversionService();
        conversionService.addConverter(new StringToIntegerConverter());
        conversionService.addConverter(new IntegerToStringConverter());
	이런식으로 등록해서
		Integer res = conversionService.convert("10", Integer.class);
		Integer res = conversionService.convert(입력값, 출력클래스);
	이렇게 사용함

	스프링에서 컨버터를 사용할땐,webconfig에서 컨버터를 등록해주면됨
		@Configuration
		public class WebConfig implements WebMvcConfigurer{
		    @Override
			public void addFormatters(FormatterRegistry registry) {
				registry.addConverter(new StringToIntegerConverter());
				registry.addConverter(new IntegerToStringConverter());
			}
		}
	이렇게 등록해주면됨
	그리고 기본객체들은 전부 컨버터가 있어서 추가할필요없고,내가만든객체변환시에만 넣으면됨
	그리고 내가 넣은 컨버터가 우선순위를 가짐

	그리고 타임리프에서
		${number} //컨버터적용안함,단순변수표현식
		${{number}} //컨버터적용
	임
	그리고 tf:field에서는 컨버터가 자동으로 적용됨,싫으면 th:value써야함
	
	컨버터가 입력과 출력타입에 제한이 없는,범용 타입변환을 제공하는데,보통 그런거보다 string숫자를 int로,바꾸는식의 포맷변경이 일반적임
	거기에 추가로 숫자중간에 쉼표넣거나,쉼표들어있는걸 숫자로 바꾸는식
	이런걸 할땐 컨버터보다 포맷터를 사용하는게 편함
	포맷터는 컨버터의 특별한버전이라고 생각하면됨
	
	포맷터는 문자+현지화에 특화된 버전임
	이걸 구현할땐,프린터와 파서 인터페이스를 상속받아서 둘다 구현하면되는데,formatter안에 둘다 들어있으니 이거받으면됨
		public class MyNumberFormatter implements Formatter<Number> {}
	
	그리고 parse에 실제 변환을 구현하면됨
	    NumberFormat format = NumberFormat.getInstance(locale);
        return format.parse(text);
	이건 쉼표를없애는거
	parse는 문자를 숫자로,print는 오브젝트를 문자로 변환해줌
	
	이 포맷터들을 컨버전서비스에 등록하려면,일반 컨버전서비스가 아닌,포맷터를 지원하는 컨버전서비스를 사용해야함
	얘는 어댑터로 포맷터를 컨버터처럼 동작하게함
	이건 DefaultFormattingConversionService를 사용하면됨
		DefaultFormattingConversionService conversionService = new DefaultFormattingConversionService();
	    conversionService.addConverter(new IpPortToStringConverter());
        conversionService.addFormatter(new MyNumberFormatter());
	이렇게 쓰면됨
	사용시엔 그냥 컨버터 포맷터 구분없이
		conversionService.convert
	사용하면됨
	
	그리고 스프링의 WebMvcConfigurer엔 저게 들어있어서 그냥 저거쓰고 addFormatter쓰면됨
		registry.addFormatter(new MyNumberFormatter());
	그리고 컨버터와 포맷터중에선 컨버터가 우선순위가 더 높음
	
	그리고 스프링은 기본적으로 포맷터들도 엄청 많이 제공함
	근데 포맷터는 기본형식이 지정돼있어서,객체의 각 필드마다 다른형식으로 쓰긴어려움
	그래서 어노테이션으로 원하는 형식을 지정할수있는 포맷터들이 있음
		@NumberFormat(pattern="###,###")
		@DateTimeFormat(pattern="yyyy-MM-dd HH:mm:ss")
	이런식으로 패턴을 적으면됨
	사용법은
		@NumberFormat(pattern="###,###")
		private Integer number;

	
	그리고 HttpMessageConverter에서는 컨버전서비스가 적용되지않음
	이건 단순히 메시지바디내용을 객체로 변환하거나 객체를 메시지바디에 넣는거뿐임
	여기서 형식을 지정하고싶으면,라이브러리 설정을 통해 포맷을 지정해야함
	
	즉 컨버전서비스는 @RequestParam,@ModelAttribute,@PathVariable,뷰템플릿 등에서만 적용됨


11.파일 업로드
	파일업로드는 enctype=multipart/form-data를 사용해서 바이너리로 파일을 던짐(이러면 컨텐츠타입이 멀티파트가 됨)
	이걸 사용하면,각 인풋타입마다 타입헤더(컨텐츠타입)를 지정하고 부분을 나눠서 데이터를 던짐


	서블릿에서 받을땐
		Collection<Part> parts = req.getParts();
	이렇게 받으면됨
	
	그리고 이 멀티파트 사용에서 업로드크기제한은
		spring.servlet.multipart.max-file-size=1MB //한파일의 크기제한
		spring.servlet.multipart.max-request-size  //한리퀘스트에서의 총합크기제한
	으로 할수있음
	그리고
		@Value("${file.dir}")
		private String fileDir;
	이렇게 하면 application.properties에서 file.dir을 미리 선언해뒀으면 그값을 가져올수있음


	그리고 멀티파트에서 content-disposition을 보면,파일명과 헤더명이 다 명시되어있음
		part.getSubmittedFileName()
	이렇게 뽑을수있음(멀티파트를 분해하고,그안의 메소드에있음)
	사이즈도 받을수있고
		part.getSize()
	헤더말고 파일을 받을땐(메시지바디에 있는 바이너리)
		InputStream inputStream = part.getInputStream();
		String body =StreamUtils.copyToString(inputStream, StandardCharsets.UTF_8);
	이렇게 받음
	파일 저장은
		if (StringUtils.hasText(part.getSubmittedFileName())){
			String fullpath = fileDir + part.getSubmittedFileName();
			part.write(fullpath);
		}
	이렇게 하면됨
	
	
	스프링에서는 MultipartFile로 멀티파트파일을 업로드할수있음
		 public String saveFile(@RequestParam String itemName, @RequestParam MultipartFile file){}
	이렇게 그냥 받고
	    if (!file.isEmpty()) {
            String fullPath = fileDir + file.getOriginalFilename();
            file.transferTo(new File(fullPath));
        }
	이렇게 그냥 써서 던지면됨



		

