1.타임리프-기본기능
	타임리프의 특징은
		서버사이드렌더링(html동적렌더링)
		네츄럴 템플릿
		스프링통합지원
	같은 특징이 있음
	
	타임리프 쓸땐
		<hthml xmlns:th="http://www.thymeleaf.org">
	를 맨위에 넣어주고,th를 불러가며 사용하면됨
		th:onclick= ...
	이렇게
	
	타임리프에서 텍스트속성정의할땐
		th:text="${data}"
	하면됨
	그리고 태그의 속성이 아니라,콘텐츠영역안에서 하고싶으면
		[[$(data)}]]
	이렇게하면됨
		<li>th:text사용<span th:text="${data}"></span></li>
		<li>컨텐츠안에서 직접출력 =[[${data}]]</li>	
	이런식으로
	html에서 뷰템플릿으로 생성할땐,특수문자를 주의해야함
	기본적으로 뷰템플릿속에선 <b>이런 태그가 먹지않음(타임리프가 자동으로 바꿔줌)
	이걸 이스케이프라고 함
	
	이걸 사용하고싶지않으면 th:utext를 사용하거나,태그텍스트부분에선 [(${data})] 이렇게 사용하면됨		
	기본적으로는,이스케이프를 써야하고,정 안될때만 언이스케이프같은거 써야함
	
	타임리프에서 변수는,${...}이렇게 사용하고,스프링에서 지원하는springEL을 사용할수있음
	스프링el은,헤더에있는(모델에 담으면 헤더에적히니)값들을 불러올때
	오브젝트
		${user.username}
		${user['username']}
		${user.getUsername()}
	리스트
		${users[0].username}
		${users[0]['username']}
		${users[0].getUsername()}
	맵
		${userMap['userB'].username}
		${userMap['userA']['age']}
		${userMap['userA'].getUsername()}
	이런식으로 받을수있음
	즉,해당 헤더 안에 뭐가 들어있으면(1차원이 아닌 2차원이상으로),거기서 그냥 프로퍼티접근으로 꺼낼수있다는거임
	
	그리고 타임리프에서 지역변수는
		th:with="abc=bcd"		
	저기에 값을 넣고,
		th:text="${abc}"
	이렇게 꺼내면됨
	당연히 객체도 들어가고
		th:with="first=${user[0]}"
		th:text="${first.username}"
	다됨
	그리고 이 지역변수는,선언한 태그 안에서만(<div>같은거면 그 안에서만)사용할수있음,그 스코프밖으로 퍼지진않음
	
	스프링부트 3.0부터는
		${#request}
		${#response}
		${#session}
		${#sevletContext}
	를 지원하지않고,남은건
		${#locate}
	만 남음
	그래서 3.0부터는 직접 모델에 넣어줘서 거기서꺼내든가해야함
	저거외에 편의기능은
		${param.paramData} //쿼리파라미터읽기
		${session.sessionData} //세션데이터읽기
		${@helloBean.hello('Spring!')} //스프링빈호출,${@빈이름.호출메소드(매개변수)}
	이 있음
	
	타임리프의 유틸리티객체는
		#message:메시지,국제화처리
		#urls:url이스케이프 지원
		#dates:java.util.Date 서식 지원
		#calenders:java.util.Calendar서식지원
		#temporals:자바8날짜서식지원
		#numbers:숫자서식지원
		#strings:문자관련편의기능
		#objects:객체관련기능제공
		#bools:bool관련기능제공
		#arrays:배열관련기능제공
		#lists,#sets,#maps:각각 컬렉션기능제공
		#ids:아이디처리관련기능제공
	등등 있음,생각했던거에서 대충 범주들어가는거 공식도큐찾아보면 잇음

	타임리프에서 자바8날짜인 LocalDate류,Instant등을 사용하려면 추가라이브러리가 필요함
	스프링부트 타임리프를 사용하면,해당 라이브러리가 자동으로 추가되고 통합됨
	사용방법은
		th:text"${#temporals.format(받을헤더명,'yyyy-MM-dd HH:mm:ss')}
	#temporals이 날짜서식을 지원하는 유틸객체임	
	
	
	타임리프에서 url생성할땐 @{}를 사용하면됨
		th:href="@{/hello}
	쿼리파라미터추가하고싶으면 괄호만()
		th:href="@{/hello(param1=${param1}, param2=${param2})}"
	패스배리어블쓰고싶으면(쿼리파라미터말고 경로에 변수넣고싶으면)
		th:href="@{/hello/{param1}/{param2}(param1=${param1}, param2=${param2})}"
	둘다쓰고싶으면
		th:href="@{/hello/{param1}(param1=${param1}, param2=${param2})}"
	즉,앞에 변수가있으면 그거부터 들어가고,만약 겹치는게없으면 쿼리파라미터로 들어감
	
	
	리터럴은,소스 코드상에서 고정된 값임
	타임리프에서 문자리터럴은 항상 ''로 감싸야함,근데 문자중간에 스페이스나 특수문자가 없으면 하나의 토큰으로 인정해서 리터럴로 만들어줌
	이때 -,_,.들은 들어가도됨
	스페이스를 넣어야하면
		th:text="'hello world!'"
	이렇게 넣어야함
	근데 그냥 ||사이에 넣는게 젤편함(리터럴 대체문법)
		th:text="|abcd 123 qqq ${data}|"
		
	타임리프에서 연산은 자바랑 별로 다를건없는데,귀찮은건 http엔티티를 사용해야하는게 귀찮음(<나 >)
	그래서 <,>이 있는건 gt,lt로 대체해서써야함
		> = gt
		< = lt
		>= = ge
		<= = le
		! = not
		== = eq
		!= = ne
	이렇게 써야함(! == !=는 그냥써도됨)
	
	
	그리고 조건문은
		(조건)? true값:false값
	elvis연산은(null체크,조건식의 편의버전)
		${data}?: '문자' = 데이터있을때출력:널일때출력
	no-Operation은 널이면(조건을 만족하지않으면) 타임리프태그를 아예 수행하지않는거,이러면 그냥 html원본그대로 나옴
		${data}?: _ = <span th:text="${data}?: _">데이터없음</span>
	이러면 데이터없음이 출력됨(타임리프무시되니까)
	
	
	타임리프는,th:뒤에 뭘 넣는식으로 동작함
	이때 해당하는속성이 있으면 대체,없으면 생성함
	그리고 덮기싫고 추가하고싶을때는
		th:attrappend = 속성값의 앞에 값을 추가,이거로추가할땐 스페이스바 안들어가니까 주의
		th:attrprepend= 속성값의 뒤에 값을 추가,이거로추가할땐 스페이스바 안들어가니까 주의
		th:classappend= class속성앞에 자연스럽게 추가,이거로 추가하면 스페이스바 들어감
		
		th:attrappend = "abc='abcd'" //이렇게쓰면됨
	
	html은 checked="false"라도 checked라는 속성이 존재하면 checked가 돼버림
	그래서 타임리프에서
		th:checked
	를 사용하면 값이 false일경우 checked속성자체를 제거해서 false를 리턴하게 해줌(체크표시를 풀어줌)


	타임리프에서 반복은 th:each를 사용함
		th:each="컬렉션에서꺼낸변수:${컬렉션}"
	컬렉션은 list,array,map등을 지원함
	그리고 반복의 상태확인은
		th:each="컬렉션에서꺼낸변수,상태확인변수명:${컬렉션}"
	인데,기본값이 컬렉션꺼낸변수+Stat임,즉 지정안해도 저렇게꺼내서확인할수있음
	
	이 Stat의 상태값은
		index:0부터 시작하는값
		count:1부터 시작하는값
		size:전체 사이즈
		even,odd:홀수짝수(tf) //두줄마다 색칠해줄때같을떄사용,가독성
		first,last:처음,마지막(tf)
		current:현재객체
	속성이 있음
	
	
	타임리프에서의 if는,해당값이 f이면 태그 자체를 랜더링하지않음(지워버림)
	사용법은
		<span th:text="'미성년자'" th:if"${user.age lt 20}:></span>
	이러면 age가 20보다 크면 태그자체가 없어져버림
	반대되는 unless도 있는데,그냥 tf만 반대로받고 똑같음
	스위치문도 있는데
		<td th:switch="${user.age}">
			<span th:case="10">10살</span>
			<span th:case="20">20살</span>
			<span th:case="*">몰루</span>
	*은 와일드카드,디폴트임	


	타임리프에서 주석은,html주석과 타임리프주석이 있음
	html주석은,기본적인 주석 소스보기로 보임
		<!--  ㅁㄹㅇㄴㄹㄴㄹ -->
	타임리프 파서주석은,이 사이에 있는걸,출력할때 그내용을 지워줌(소스보기로 못봄)
		<!--/* ㄹㄴㄹㄴㄹㄴ */--> //한줄
		<!--/*-->            //여러줄 시작
			<span>fsfs</span>
		<!--*/-->            //여러줄 끝
	이렇게 저거로 싸두면 저거도 없어짐
	
	타임리프 프로토타입주석은,타임리프로 랜더링 되면 실제 태그가 적힘(주석이아님),그냥 경로로 html불러오면 주석처리됨,안쓸거같음ㅋㅋ
		<!--/*/ ㄹㄴㅇㄹㄴ /*/-->
	
	
	타임리프에서 유일하게 태그를 추가하는게 <th:block>임
	이건 안에서 두개이상div에서 루프를 돌리거나 하고싶을때 사용됨(div2개이상을 묶고싶을때)
	얘는 랜더링될떄 사라짐,즉 each만으로 해결하기 어려울때 사용됨(태그하나에 속성변경으로 처리하기 애매할경우에)
	
	js인라인은 js에서 타임리프를 사용할때 좀더 편리해짐
		<script th:inline="javascript">
	이걸 사용하면 문자타입일경우 ""를 싸서주고,문제될만한 문자가 있으면 이스케이프처리도 해줌("->\")
	그냥 <script>사용할땐 무지성으로 붙여도될듯
	
	그리고 html파일을 그대로 열어도되는 내추럴템플릿에서,이걸사용해서 주석을 활용해서 이기능을 사용할수있음(js도 내추럴템플릿을 사용할수있음)
		var username2 =/*[[${user.username}]]*/"test username";
	이렇게 변수부분을 주석처리해두면,타임리프로 열면 뒤에를 지우고 주석을벗기고,직접열면 저게 주석이니까 무시돼서 내추럴로 동작할수있게해줌
	
	객체를 넣으면,json으로 바꿔줌
		var user =[[${user}]];
	이렇게 넣으면
		var user ={"username":"userA","age":10};
	이렇게 나옴
	
	그리고 이안에서도 each를 사용할수있음
		[# th:each="user,stat :${users}]
		var user[[${stat.count}]]=[[${user}]]
		[/]
	이렇게 사용할수있음
	이러면
		var user1 ={"username":"userA","age":10};
		var user2 ={"username":"userB","age":20};
		var user3 ={"username":"userC","age":30};
	이렇게 나옴

	타임리프는 웹페이지의 공통영역을 템플릿조각기능과 레이아웃기능으로 가져다쓸수있게 제공해줌
	가져다 쓰는 대상(함수역할)html에서
		<footer th:fragment="abcd">푸터자리입니다.</footer>
	이런식으로 th:fragment="abcd"이렇게 선언해두고
	메인에서
		<div th:insert="~{template/fragment/footer :: abcd}"></div>
	이렇게 insert를 하던가(th:insert="~{경로::이름}")
		<div th:replace="~{template/fragment/footer :: abcd}"></div>
	replace하던가
		<div th:replace="template/fragment/footer :: abcd"></div>
	이렇게하면 단순표현식(~{}를 빼도 단순하면 동작하는거,위랑 다른거없음)
	
	인서트는 현재 태그 내부에 해당 태그를 삽입함(div속성에 넣으면 div안에 추가함,<div><footer>)
	리플레이스는 현재 태그를 해당 태그로 변경함(div속성에 넣으면 div를 제거하고 해당속성으로 변경 <div> -> <footer>)
	
	파라미터도 넣을수있음
	함수html에서
		<footer th:fragment="copyParam (param1, param2)"><p>파라미터자리입니다.</p>
			<p th:text="${param1}"></p>
			<p th:text="${param2}"></p></footer>
	이렇게넣고
		<div th:replace="~{template/fragment/footer :: abcd("1번파라미터",2번파라미터)}"></div>
	이렇게 함수처럼 불러다쓸수있음
	
	이렇게 함수처럼 부르는거말고,코드조각을 레이아웃에 넘겨서 사용할수도 있음,이게 템플릿 레이아웃임
	즉 헤더부분이나 푸터를 만들어두고,그걸 가져다가 쓰면서 뭘 좀 추가하거나 하고싶을때 사용
	이건 th:replace를 헤드같은 엄청 html에서 큰덩어리에서 사용하는식으로 처리하면됨
	거기서
	위에서 공통부분을 처리한후에
		<html xmlns:th="http://www.thymeleaf.org">
		<head th:fragment="common_header(title,links)"><title th:replace="${title}">레이아웃타이틀</title>
			<!-- 공통 -->
			<link rel="stylesheet" type="text/css" media="all" th:href="@{/css/awesomeapp.css}">
			<link rel="shortcut icon" th:href="@{/images/favicon.ico}">
			<script type="text/javascript" th:src="@{/sh/scripts/codebase.js}"></script>
			<!-- 추가 -->
			<th:block th:replace="${links}"/>
		</head>
	밑에 블록을 넣어서
		<head th:replace="template/layout/base :: common_header(~{::title},~{::link})"><title>메인타이틀</title>
			<link rel="stylesheet" th:href="@{/css/bootstrap.min.css}">
			<link rel="stylesheet" th:href="@{/themes/smoothness/jquery-ui.css}">
		</head>
	이렇게 해당 이름의 태그들을 파라미터로 넘겨서 추가할수있음
	즉 템플릿조각이랑 비슷한데(템플릿조각에서 파라미터에 스트링 다박아버려도 똑같긴할듯),
	그냥 저걸 텍스트로 넘기기 너무기니까,태그로 서치해서 넘긴다고 생각하면될듯
	
	그리고 이걸 head같은정도에만 하는게 아니라,html태그에(전체에) 적용할수도있음
	이거도 위랑 똑같은데,그냥 전체를 만들어두고,약간약간 바꿔가면서 쓸때 사용함
		<html th:fragment="layout (title, content)" xmlns:th="http://www.thymeleaf.org">
		<head><title th:replace="${title}">레이아웃타이틀</title></head>
		<footer>레이아웃푸터</footer>
	이렇게 필요한부분만 replace하면서(리플레이스안시킨데는 그대로 나옴,공통부분)
		<html th:replace="~{template/layoutExtend/layoutFile :: layout(~{::title}, ~{::section})}"
		<head><title>메인페이지타이틀</title></head>
		<body>
		<section><p>메인페이지컨텐츠</p>
			<div>메인페이지포함내용</div>
	이렇게 넣고 바꾸는거임,위랑똑같음
	사실상 상속이랑 똑같아보여서 레이아웃 상속이라고 하는듯
	상속처럼 막 비슷한페이지 100개 만들고 이럴때 사용하기편한듯


2.타임리프와 스프링통합과 폼
	타임리프는 타임리프기본도큐먼트와,스프링통합도큐먼트 두개를 제공함
	이렇게 스프링통합을 하면 기능추가가 몇개되고,편해지는게 좀 있음
	
	예로
		${@myBean.doSomething()} //스프링빈호출
	폼관리를 위한 추가속성
		th:object
		th:field ,th:error,th:errorclass
	폼컨포넌트기능
		체크박스
		라디오버튼
		리스트
	스프링 메시지,국제화기능 통합
	스프링검증,오류처리 통합
	스프링변환서비스 통합
	
	이렇게 통합하려면 타임리프템플릿엔진을 스프링빈에 등록하고 뭐 어쩌고해야하는데,스프링부트쓰면 알아서해줌(그 starter.thymeleaf 추가되면)
	
	
	타임리프를 사용하면 폼처리가 많이 편해짐
	타임리프로 폼을 쓰려면,무조건 모델을 생성하고,모델에 빈 객체이라도 만들어서 뭐라도 하나 넣어둬야함(변수생성이라고보면됨)
		model.addAttribute("item", new Item());
	그리고
		<form action="item.html" th:action th:object="${item}" method="post">
	이렇게 키를 받아서 커맨드객체에 넣고(저걸 커맨드객체라고 부름,쟤로 조종하니까)
	값입력(input태그)에서
		<input type="text" id="itemName" name="itemName" th:field="*{itemName}" class="form-control"
                   placeholder="이름을 입력하세요">
	이렇게	
		th:field="*{itemName}"
	*은 위에서 th:object를 줄인거(item. 을 생략,즉 위에 오브젝트에 속한거라는거)
	이렇게 th:field가 있으면
		<input type="text" th:field="*{itemName}" class="form-control"
                   placeholder="이름을 입력하세요">
	이렇게 id와 name도 생략하면,필드명으로 들어감(itemName)
	
	즉 th.field는,id,name,value를 합친거고
	*{}는,앞에 위에서의 오브젝트의 객체를 붙이는거
	그리고 th:field의 값이 없으면,예외를 던짐(item.itemNamexx가 없다거나)
	
	이게 좋은건 검증할때 엄청 편해짐
	
	
	타임리프에서 체크박스,라디오버튼,셀렉트박스를 추가하는건

	자바 enum은
		public enum ItemType {
			BOOK("도서"), FOOD("음식"), ETC("기타");

			private final String description;

			ItemType(String description) {
				this.description = description;
			}
		}
	그냥 이렇게만들면됨(description은 설명)

	
	만약 html만 가지고 체크박스를 만들면,체크를 했을땐 true를 리턴하는데(정확히는 on이 넘어가는데 스프링이 이걸 true로 바꿔줌),
	체크를 안했을때 null이 반환됨(체크하지않으면 그 필드자체가 전송되지않음)
	생성은 뭐 안들어왔네 하면되는데,수정의경우 문제가 될수있음
	그래서 깡스프링에서는 앞에 타입히든에 언더바를 붙이는식으로 히든필드를 만들어서
		<input type="checkbox" id="open" name="open" class="form-check-input">
		<input type="hidden" name="_open" value="on"/> //다 고정이고,name만 체크박스와 통일하고 앞에 _붙이기
	이렇게 그 체크박스가 있다는걸 확인하고(체크박스와 이름이같은 히든타입),
	스프링이 false를 출력하는식으로 꼼수로 false를 받을수는 있는데,너무 귀찮음
	
	
	그래서 타임리프를 사용하면 알아서 해줌
		<input type="checkbox" id="open" th:field="*{open}" name="open" class="form-check-input">
	그냥 이렇게 th:field넣으면됨(이거도 똑같이 히든필드로 동작하는데,이걸 타임리프가 대행해주는거)

	그리고 스프링에서
		@ModelAttribute("regions")
		public Map<String, String> regions() {
			Map<String, String> regions = new LinkedHashMap<>();
			regions.put("SEOUL", "서울");
			regions.put("BUSAN", "부산");
			regions.put("JEJU", "제주");
			return regions;
		}
	이렇게 선언하면,그 컨트롤러를 호출할때에는 무조건 저 regions에 저값이 디폴트로 들어가있게됨
	물론 성능최적화관점에선 static로 할수있으면 그렇게하는게 낫긴할듯
	
	멀티체크박스는
	    <div>
            <div>등록지역</div>
            <div th:each="region : ${regions}" class="form-check form-check-inline">
                <input type="checkbox"
                       th:field="*{regions}"
                       th:value="${region.key}"
                       class="form-check-input">
                <label th:for="${#ids.prev('regions')}" th:text="${region.value}"
                       class="form-check-label">서울</label>
            </div>
        </div>
	이렇게 돌리면됨(th:each의 regions는 모델애트리뷰트에서 받은거,th:field="*{regions}"는 item의 region값)
	대충 value에 값이있으면 체크,없으면 비워두는걸 타임리프가 자동으로해줌
	th:for="${#ids.prev('regions')}"은,텍스트를 클릭해도 체크가 되게하려면,
	체크박스의 아이디를 라벨에서 알아야해서,for문의 직전의 id값을 받을수있음(어짜피 이거도 타임리프가 만드니까,id는 유니크해야하니)
		${#ids.prev('regions')}
	
	자바에서 enum의 값을 전부 리턴하는건
		ItemType.values()
	하면 값을 전부리턴함(배열로 리턴)
	
	타임리프에서 라디오버튼은 위랑 똑같은데(셀렉트박스랑)
		<input type="radio"
	이거만 바뀜
	그리고 얘는 체크를 안하면 null이 반환됨
	
	그리고 타임리프에서 enum을 직접접근할수있긴한데,컴파일오류를 못잡아서 추천하진않는대
	

	타임리프에서 셀렉트박스는
		<select th:field="*{deliveryCode}" class="form-select">
			<option value="">==배송방식선택==</option>
			<option th:each="deliveryCode : ${deliveryCodes}" 
					th:value="${deliveryCode.code}" th:text="${deliveryCode.displayName}">FAST
			</option>
		</select>
	이런식으로 셀렉트박스를 만들고,옵션을 each돌리면됨


3.메시지-국제화
	텍스트같은걸 한군데다 모아두면,수정하기가 편함,이게 메시지 기능임(파일에서 변수 불러다쓰는느낌)
	이걸 사용해서 언어별로 만드는식으로(파일을 2개만들어서)언어별로 다른값을 내보내는게 국제화
	accept-language같은거로 체크해서 다른걸 부르면됨
	
	그리고 스프링에서는 기본적으로 이런 메시지관리기능을 제공하고,타임리프도 이걸 통합해서 편하게쓸수있음
	이걸 사용하려면,MessageSource를 스프링빈으로 등록하면되는데,이건 인터페이스임
	그래서 ResourceBundleMessageSource를 스프링빈으로 등록하면됨
	그리고 그 메시지소스에
		messageSource.setBasenames("messages","errors")
		messageSource.setDefaultEncoding("utf-8")
	이렇게 디폴트이름을 정해주면,알아서
		messages_ko.properties
		messages_en.properties
	이렇게 바꿔가면서읽음
	파일의 위치는
		/resources/messages.properties
	에 두면되고,setBasenames에는 여러 파일을 한번에(지금도 메시지랑 에러 두개저장한거처럼)넣을수있음
	
	근데 스프링부트쓰면 자동으로 이걸 해줌
	그래서 application.properties에
		spring.messages.basename=messages //디폴트는 messages
	이렇게 넣기만하면됨
	디폴트값이 messages니까
		messages_en.properties
		messages_ko.properties
		messages.properties
	같은건 자동으로 인식함(모든언어지원안하면 messages.properties동작)

	
	@SpringBootTest
	이거붙이면 테스트실행할때 의존성주입해주니까,필드로 주입받아서 테스트돌리면됨
	    @Autowired
		MessageSource messageSource;

	메시지 받을땐
		ms.getMessage("hello", null, null);
		ms.getMessage(해당변수명, args, 국가값);
	이렇게 받으면됨
	그리고 해당 변수가 없어서 메시지를 못찾으면 NoSuchMessageException이 발생
		Assertions.assertThatThrownBy(() -> ms.getMessage("no_code", null, null))
		.isInstanceOf(NoSuchMessageException.class);
	저상황에서 기본값을 받고싶으면
		ms.getMessage("no_code", null, "기본메시지", null);
	이렇게 3번째에넣으면됨
	args사용시엔
		hello.name=gd{0} //메시지.프로퍼티파일
		
		ms.getMessage("hello.name", new Object[]{"Spring"}, null);
	이렇게 넣으면 gdSpring가 출력됨
	
	나라선택은
		ms.getMessage("hello", null, Locale.ENGLISH)
	이렇게 할수있음
	
	이 메시지를 타임리프에서 사용할땐
		#{}
		#{hello.name}
	이런식으로 바로 접근할수있음
	파라미터는
		#{hello.name(${item.itemName})}
		#{hello.name(1234)}
	이렇게 괄호치고 바로넣으면됨
	국제화는 그냥,_en,_ko같이 베이스네임에서 맞춰주기만하면 스프링이 알아서 accept-language같은거보고 호출함
	이 선택을 직접한다던가식으로 바꾸고싶으면,구현체를 변경해주면됨
	인터페이스는 LocaleResolver고
	기본적으론 AcceptHeaderLocaleResolver을 사용하는데,쿠키나 세션기반으로 구현체를 변경해주면됨
	

4.검증-밸리데이션
	컨트롤러의 중요역할중 하나는,http요청이 정상인지 검증하는것
	일반적으로 prg에서 p를 하다 검증실패하면,
	현재 값들을 모델에 담아 다시 리턴해서 원래url로 돌려주는게좋음(어짜피 값은 모델에 들어있을테니 에러만 모델에 넣어서 리턴해주면됨)
	그래서 빈값을 리턴해서 타임리프가 읽게한거
	
	부정의 부정은 읽기어려우니까(!errors.isEmpty()),이걸 메서드로 싸서 hasError같은거로 바꾸는게 가독성에서좋음
	
	그리고 타임리프에선
		<div th:if="${errors?.containsKey('globalError')}">
			<p class="field-error" th:text="${errors['globalError']}">전체오류메시지</p>
		</div>
	이렇게 출력하면됨
	여기서
		errors?
	는 만약 null이면 nullpointerexception이 발생하는대신,null을 반환하는 문법(스프링el문법,코틀린에도 있었던거같음)
	
	인텔리제이에서 폴더를 클릭하고 그 아래있는걸 컨트롤쉬프트r로 일괄수정할수있음
	
	
	
	스프링에서의 검증오류처리방법은 BindingResult임
		public String addItem(@ModelAttribute Item item, BindingResult bindingResult, 
								RedirectAttributes redirectAttributes, Model model) {
		}
	이렇게 담으면,저 BindingResult에 에러를 담으면됨
	그리고 주의할건,BindingResult파라미터는 무조건 검증할대상 바로 뒤, @ModelAttribute 바로 뒤에 와야함,
	앞에있는 어트리뷰트에 바인딩되는매커니즘이기때문
	
		bindingResult.addError(new FieldError("item","itemName","상품이름은 필수"));
		bindingResult.addError(new FieldError(오브젝트명,필드명,메시지));
	오브젝트명은 모델에트리뷰트에 담기는 이름,필드명은 오브젝트안의 필드명,메시지는 출력메시지
	만약 여러필드에 겹치거나,필드랑 상관없는에러면
		bindingResult.addError(new ObjectError("item","갯수x가격은 10000이상이어야함"+resPrice));
		bindingResult.addError(new ObjectError(오브젝트명,메시지));
		
	컨트롤p,현재 메서드의 매개변수,오버로드 출력
	
	그리고 검증할땐
		if (bindingResult.hasErrors()){
			return "원래주소"
		}
	로 넣고,모델애트리뷰트에 에러는 안넣어도됨,자동으로 모델에 담겨서 넘어감
	
	타임리프에서 렌더링할때 글로벌에러는
        <div th:if="${#fields.hasGlobalErrors()}">
            <p class="field-error" th:each="err:${#fields.globalErrors()}"
 			   th:text="${err}">전체오류메시지</p>
        </div>
	이렇게
		th:if="${#fields.hasGlobalErrors()} //글로벌에러가 있으면
		th:each="err:${#fields.globalErrors()}" //모든글로벌에러 foreach로 받아서
		th:text="${err['globalError']} //해당에러 출력
	그리고 필드에러는
		<div class="field-error" th:errors="*{itemName}">
			상품명오류
		</div>
	이렇게만 하면됨(해당오브젝트의 필드네임을 명시하면 에러있으면 출력하고(텍스트는 그 에러에 있는 텍스트를 출력))
	그리고
		th:errorclass="field-error"
	이건 에러가 있으면 저 클래스를 추가해줌(에러검색은 th:field에 있는 값에 에러가 매핑돼있으면 가져옴,즉 저기 에러는 저기 바인딩됨)
	
	
	bindingResult가 있으면,모델애트리뷰트에 데이터바인딩실패해도(인트에 스트링넣는다거나) 400이 뜨지않고,
	오류정보를 bindingResult에 담아서 컨트롤러를 정상호출함
	만약 저게없으면 그냥 400에러가 떠버리고 모델은 증발해버림(컨트롤러가 호출되지않음)
	
	이때 필드에러면,스프링이 직접 필드에러를 만들어서 우리가 담는거랑 똑같이 담음
	
	즉, 진짜 값을 넣는데 실패한오류와 값이 틀린(검증로직에서 탈락한) 오류로 구분할수있음
	
	
	그리고 만약 현재 값을 유지한채 에러메세지를 띄우고싶으면,FieldError에서 다른오버로드를 타면됨
		bindingResult.addError(new FieldError("item","itemName",item.getItemName(),
			false,null,null,"상품이름은 필수"));
		bindingResult.addError(new FieldError(오브젝트명,필드명,해당필드값,
				바인딩이 실패햇는지 여부,코드,아규먼트,오류메시지));		
	이 오버로드를 타면,해당 필드값을 그대로 넣어줄수있음
	
	즉,기본적으로 사용하는건 값을 유지하지않고 간단히 넣는거(api같은데서 사용할때),값 유지하는건 빡빡하게 넣는거
	
	그리고 모델애트리뷰트에 바인딩되는 시점에 오류가 발생하면,즉 바인딩이 실패하면(int에 string를 넣으면 컨트롤러단에서 처리할방법이없으니),
	저 바인딩리절트에러가 그 값을 오브젝트로 가지고있으면서,그걸 돌려줌
	이떄는 바인딩이 실패했으니 바인딩실패여부를 true로 줘야함
	
	그리고 타임리프가,정상상황에선 모델객체의 값을 사용하지만,오류가 발생하면 FieldError의 값을 출력함(그래서 모델에 못넣는값을 저장할수있는거)
	이거는 th:field가 이걸 담당함
	
	
	그리고 이렇게 오류메시지를 디폴트로 출력하면,스프링이 오류메시지를 적어둠(우리가 적었던 error의 마지막매개변수)
	저걸 어디 한군데다가 모아두고 사용할수있음(메시지처럼)
	이건 매개변수중 코드와 아규먼트로 해당값을 찾아서 있으면 그거출력,없으면 디폴트메시지를 출력하는식
	
	이건 그 메시지설정에 추가하고(message.properties밑에 추가하거나,같은식으로 추가)
		application.properties밑에
			spring.messages.basename=messages,errors
	그리고 코드에서
		bindingResult.addError(new FieldError("item","price",item.getPrice(),
			false,new String[]{"range.item.price"},new Object[]{1000,1000000},"가격은 1000~1000000사이"));
	이런식으로 코드에 해당하는 이름을 스트링배열로 넘기고(앞에서부터 찾아가는식,앞에없으면 두번째꺼,다없으면 디폴트출력),
	매개변수는 뒤에 오브젝트배열로 넘김
	에러메시지
		range.item.price=가격은 {0} ~ {1} 까지허용합니다.
	그리고 해당 메시지도 못찾고 디폴트도 없으면 그냥 에러페이지가 나옴
	
	즉 그냥 메시지소스걸쳐서 가는거
	이거도 너무 코드가 기니까 좀 줄일수있음
	
	컨트롤러에서 bindingResult는 검증객체를 이미 알고있음(자기앞에있는게 검증객체)
	그래서 오브젝트명같은걸 생략할수있음
	보통
	rejectValue()나 reject()를 사용함
		bindingResult.rejectValue("itemName","required");
		bindingResult.rejectValue("필드명","메시지의 맨앞단어 보통 제약을 적음");
	이렇게 하면
		required.item.itemName
		제약.오브젝트명.필드명
	으로 자동으로 찾아감
	아규먼트가 있을땐
		bindingResult.rejectValue("quantity","max",new Object[]{9999},null);
		bindingResult.rejectValue(필드명,제약,아규먼트의 오브젝트배열,디폴트메시지);
	이렇게 넣어주면됨
		
	오브젝트에러의경우엔
		bindingResult.reject("totalPriceMin");
		bindingResult.reject("에러코드");
	이렇게 전체를 다 적어줘야함
	
	그리고 제약메시지에서
		required=필수값입니다
		range=범위는 {0} ~{1}까지 허용
		max=최대 {0}까지 허용
	이렇게만 적고
		bindingResult.rejectValue("itemName","required");
	이걸 하면,디테일이 더 높은게 우선순위로 잡힘(required<required.item<required.item.itemName)
	그러니까 해당분류의 디테일을 조정하는것으로 디폴트메시지를 사용할수있다는거임
	
	이걸 단순하게만들면 범용성이좋고,세밀성이 떨어짐,대신 너무 자세하게 만들면 범용성이 떨어짐
	그래서 베스트는,범용성으로 사용하다가,세밀하게 사용해야할때만 세밀하게 적는것(유저랑 직접닿는부분)
	
	이걸 스프링은 messageCodesResolver을 사용해서 지원함
	얘는 에러코드를 넣으면,스트링배열로 해당하는걸 세밀한거부터 포함되는 모든걸 리턴해줌(앞에서부터우선순위)
	즉,rejectValue는 자기안에서 저걸불러서 받아오고, 제일앞에있는거 읽어서 그거 리턴하는거임
	이때 우선순위는
		제약.오브젝트명.필드명
		제약.필드명
		제약.타입(스트링같은,즉 해당타입별로 오류를 만들어둘수있음)
		제약
	이렇게 우선순위가잡힘
	
	이 messageCodesResolver는 기본적으로 DefaultMessageCodesResolver를 사용하는데
	얘의 기본메시지생성규칙은
	객체오류
		code+"."+오브젝트이름
		code
	여기서 코드는 required나 max같은거
	필드오류는
		코드+"."+오브젝트네임+"."+필드
		코드+"."+필드
		코드+"."+필드타입 (typeMismatch.int,typeMismatch.String)
		코드
	이렇게 됨,여기맞춰서 에러메시지를 적어주면됨
	
	이렇게 쓰면,적당히 퉁쳐서 쓸수있어서 편하고,필요한부분만 상세히 적을수있음


	그리고 bindingResult를 감싸는 if문을 없애는건
		ValidationUtils.rejectIfEmptyOrWhitespace(bindingResult,"itemName","required");
	이렇게 해당필드값이 비어있으면 작동하는식의 유틸도 있음

	
	그리고 스프링이 직접 만드는 검증오류(보통 타입정보)도 해당 오류에(타입의경우 typeMismatch)메시지를 적으면,해당메시지가 출력됨
	방식자체는 같으니까 직접 넣어주면됨
		typeMismatch=타입에러
	이렇게
	
	
	그리고 컨트롤러에서 검증로직이 차지하는 영역이 너무 크니까,이러면 이걸 별도의 클래스로 분리하는게 좋음
	그리고 이런 검증로직을 재사용할수있음
	
	그리고 스프링이 제공하는 인터페이스중 Validator 가 있음
		public class ItemValidator implements Validator {
	이렇게
	얘는 supports와 validate를 가지고있는데,supports는
		public boolean supports(Class<?> clazz) {
			return Item.class.isAssignableFrom(clazz);
		}
	이렇게 현재 검증할 클래스와 클래스호환이 되냐를 체크(item==clazz),물론 자식클래스도 호환(subItem==Item)
	그리고 검증로직은 validate에 넣으면됨
	    public void validate(Object target, Errors errors) {
			Item item=(Item) target;
			
			if (item.getPrice()==null || item.getPrice()<1000 || item.getPrice()>1000000){
				errors.rejectValue("price","range",
						new Object[]{1000,1000000},null);

			}
		}
	이때 타겟이 오브젝트로 넘어오니까 캐스팅해줘야함
		Item item=(Item) target;
	그리고 errors는 자식이 bindingResult니까 저기에 bindingResult를 넣을수있음
		errors.rejectValue("price","range",
				new Object[]{1000,1000000},null);
	그리고 저걸 @Component붙이고,private final ItemValidator itemValidator로 선언해주면 스프링이 주입해줌
	
	그리고 컨트롤러에는
	    if( itemValidator.supports(item.getClass())){
           itemValidator.validate(item,bindingResult);
        }
	이렇게 콜하면됨
	
	근데 Validator는 스프링에서 제공하니,이렇게 직접 부르지않고 스프링이 대신 실행시키게 할수있음
	이건 webDataBinder을 사용하면됨
		@InitBinder
		public void init(WebDataBinder dataBinder){
			dataBinder.addValidators(itemValidator);
			dataBinder.addValidators(orderValidator);
		}
	
	이걸 넣어주고,해당 객체에 어노테이션을 붙이면(@Validated @ModelAttribute Item item)
		public String addItemV6(@Validated @ModelAttribute Item item, BindingResult bindingResult, 
						RedirectAttributes redirectAttributes, Model model) {
	
	
	
	
	이 컨트롤러가 호출되면 그 요청에서 @Validated가 있으면 그 객체에 대해 밸리데이터가 동작하게됨(결과는 bindingResult에 담겨있음)
	@Validated는 검증기를 실행하라는 어노테이션인데,만약 검증기가 여러개라면 supports 루프돌려서 거기서 true뜨면 호출하는식임

	글로벌설정도 할수있는데,이건 필요해지면보자 있다는거만 알아두고(이거도 그냥 전체검증기에 디폴트값을 추가하는느낌일듯)
	이거하면 beanValidator이 동작하지않아서 보통 사용하진않음

5.검증2-빈 밸리데이션
	빈밸리데이션은,해당 엔티티필드(객체의 필드)에 어노테이션을 달아서,값을 자동으로 검증하는거
	이 빈 벨리데이션은 스프링이 아닌 자바표준이고(인터페이스),구현체로는 보통 하이버네이트 밸리데이터를 사용함
		@NotBlank  //빈값,공백만 있는걸 허용하지않음
		@NotNull   //널 허용안함
		@Range(min=10,max=100)//범위안의 값이어야함
		@Max(9999)  //최대 저정도값이어야함
	이런식의 어노테이션이 있음
		@NotNull
		@Range(min=10,max=100)		
		private Integer price;
	이런식으로 작성
	
	그리고 @Validated를 해당 엔티티에 붙여주면됨
	스프링부트는 자동으로 어노테이션을 글로벌 밸리데이터로 등록해버려서,이 밸리데이터를 보고 검증을 수행함
	즉,도메인에서 @NotNull같은거 붙이고 컨트롤러에서 해당도메인엔티티에 @Validated붙이면됨
	
	이때 검증순서는
		1.@ModelAttribute 각각의 필드에 타입변환시도
			성공하면 다음으로
			실패하면 typeMismatch로 fielderror추가
		2.Validator 적용
	이 순서로 됨
	즉 바인딩이 성공해야 밸리데이터가 동작함,즉 바인딩에 성공한 필드만 밸리데이션이 동작
	
	그리고 이 어노테이션들의 에러코드는
		@NotBlank  ->NotBlank.객체명.필드명 이런식
		@NotNull   ->NotNull.객체명.필드명  이런식
		@Range(min=10,max=100) ->Range.객체명.필드명  이런식
		@Max(9999)  ->Max.객체명.필드명  이런식
	이거도 타입미스매치랑 똑같이 
		Max.객체명.필드명
		Max.필드명
		Max.타입
		Max
	이런식으로 해당 어노테이션명을 제약으로잡고 그대로적음
	그래서 에러메시지프로퍼티에 저걸적는식으로 할수있음
	
	이건 필드에러들이고,여러 필드에 걸친 오브젝트에러도 처리가 가능하긴한데
		@Data
		@ScriptAssert(lang="javascript",script="_this.price * _this.quantity >= 10000",message="메시지")
		public class Item {
	이렇게 해당 클래스위에 붙여서 처리할수는있는데
	이건 잘 사용하지않음
	왜냐면
		제약이 많고,
		해당 객체의 범위를 벗어나는 검증이 불가능함
	그래서 그냥 자바코드(컨트롤러안에 직접 적거나 메소드로 뺴서 메소드실행)로 적는게 좋음 오브젝트에러는
	
	
	그리고 이렇게 빈밸리데이션을 적용할떄의 문제는,모든 이 도메인을 쓰는곳에 같은검증이 들어간다는것
	만약 추가할때와 수정할때의 요구사항이 달라도,하나로밖에 검증할수없음
	그래서 나온게 groups임(근데 form전송객체분리(dto)가 더 발전돼서 이걸더많이쓰긴함)
	이건 그냥 제약에 그룹을 정해두고,그 그룹별 검증을 넣어두는거
	
	이건 빈 인터페이스를 만들어두고,객체의 제약에 표시
		@NotNull(groups = UpdateCheck.class)
		@NotBlank(groups = {SaveCheck.class, UpdateCheck.class}) //여러개에 공통으로 포함될때
	이런식으로 넣어두고
	제약을 적용하는데서
		@Validated(SaveCheck.class) @ModelAttribute Item item,
	이렇게 넣으면됨
	
	근데 이건 복잡도가 올라가서 잘안쓰고,실무에선 dto를 사용함 보통
	그 이유는,보통 등록시 폼에서 전달하는데이터와 도메인객체가 딱 맞지 않기때문
	헬로월드수준이면 맞겠지만,좀 복잡해지기시작하면 약관정보등 별별 부가데이터들이 다 같이 넘어옴
	그래서 도메인객체를 직접 받는게 아닌,복잡한 폼데이터를 컨트롤러까지 전달할 별도의 객체를 만들어서 전달(dto)
	이런 폼을 전달받는 전용객체를 만들어서 이걸 ModelAttribute로 사용함
	즉
		form->itemSaveForm->Controller->item->Repository
	순서임
	
	그리고 입력만 받는게 아닌,생성에 필요한 추가데이터를 db에서 찾아오거나 해야할수도 있어서,조금만 복잡해져도 dto가 필요해짐
		@Validated @ModelAttribute("item") ItemSaveForm form
	이런식으로 쓰면되는데,뷰템플릿을 쓰면 클래스명으로 모델애트리뷰트에 기본으로 박히니,
	만약 사용하던 이름이 있으면 모델애트리뷰트에 명시해줘야 그이름으로 박아줌
	그리고 성공로직까지 가서 레포지토리에 담을때,도메인으로 변경해서 넣어주면됨(이부분에서만 도메인을 사용)
	
	이 빈 밸리데이션은 api에서도 사용할수있음
	그리고 @ModelAttribute는 쿼리파라미터,폼데이터용이고 @RequestBody는 req body를 객체로 변환할떄 사용
	
	근데 api로 보낼때 바인딩실패하면 컨트롤러로 안들어가고 튕겨냄(객체를 생성하는게 실패했을때)
	즉 api로 보낼땐,3가지 경우가 있음
		성공요청
		실패요청(객체생성을 실패해서 컨트롤러호출자체가 안됨)
		검증실패(객체생성은 성공했는데 검증에서 탈락)
	그리고 실제로 검증실패 로그찍을땐,전체반환이 아닌,거기서 필요한값들만 빼서 객체를 만든뒤 그 객체를 반환하는식으로 해야함
	
	모델애트리뷰트는 각 필드단위로 세밀하게 동작해서,한 필드가 오류발생해도 다른필드들은 처리가 가능했었음
	근데 리퀘스트바디(HttpMessageConverter)는 전체 객체단위를 하나로 잡아서 동작해서,객체단위로 성공해야 Validated가 동작함
	그래서 HttpMessageConverter에서 실패해버리면 예외가 발생해버림




6.로그인 처리1-쿠키,세션
	도메인=시스템이 구성해야하는 핵심 비즈니스업무
	web관련이 바뀌어도 도메인은 그대로 유지할수있어야함(웹은 도메인을 의존할수있지만,도메인은 웹을 의존하면안됨)
	그리고 dto같은거도 웹에 있음(이건 좀 논란있던거아닌가 dto의 변환위치)
	
	Optional<int> 널을 반환할수있는 변수타입
	함수.stream().filter(람다식) //컬렉션을 스트림으로 바꿔서,필터람다식을 거쳐서 맞는거만 다음거로 넘기고,findFirst()같은거로 사용
	회원가입도
		Optional<Member> byLoginId = memberRepository.findByLoginId(loginId);
        return byLoginId.filter(m -> m.getPassword().equals(password))
                .orElse(null);

	이런식으로 이퀄로 매칭해서 확인하면됨
	
	로그인 상태유지는 일단 세션이든 토큰이든 쿠키기반으로 동작함
	그렇다고 진짜 쿠키만쓰면,보안상 너무안좋으니까(쿠키에 아이디비번을 넣어두면 가로채기도쉽고 로컬에서도 빼갈수있으니),세션같은걸 사용하는거
	
	서버가 클라로 쿠키를 전달해주면,클라에선 쿠키저장소에 넣어둠
	쿠키는 쿠키저장소에 들어있으면,해당 url에 뭘 날릴때에 무조건 따라붙음 
	
	여기서 쿠키는 영속쿠키와 세션쿠키가 있음,영속쿠키는 지정된 날짜까지 유효,세션쿠키는 브라우저를 닫기전까지 유효
	날짜를 0으로 던지면 세션쿠키로 동작함
        Cookie idCookie = new Cookie("memberId", String.valueOf(loginMember.getId()));
        res.addCookie(idCookie);
	여기서 쿠키에 시간정보를 안주면  세션쿠키가됨
	
	크롬 개발자도구의 애플리케이션-스토리지-쿠키에서 쿠키볼수있음
	쿠키를 받을때는
		public String homeLogin(@CookieValue(name = "memberId", required = false) Long memberId){}
	이렇게 받을수있음(req헤더로 받아도되는데,그걸 간편하게해준거)

	로그아웃은 그냥 쿠키를 날리면됨
        Cookie cookie = new Cookie("memberId", null);
        cookie.setMaxAge(0);
        res.addCookie((cookie));
        return "redirect:/";
	이렇게 해당헤더명의 빈쿠키를 만들고,age를 0으로만들어서 던져주면됨

	
	이렇게 쿠키만 가지고 로그인유지를 하면,보안문제가 많음
		쿠키는 임의로 변경할수있음(브라우저에서 f12로 쿠키id를 변경한다던지)
		쿠키에 보관된값은 훔쳐갈수있음(네트워크에서 재킹하던가,로컬에서 훔쳐가던가)
		한번 훔쳐가면 평생 그값을 사용할수있음(id값이 고정이니까)
	이런 문제들이 있음
	
	그래서 쿠키엔 중요한값은 보관하지않고,사용자 별 해쉬값토큰을 노출하고,이 토큰과 사용자id를 매핑해서(레디스) 인식해야함
	토큰은 해커가 임의의값을 넣어도 찾을수없게 복잡한해쉬여야함
	해커가 토큰을 훔쳐가도 시간이지나면 사용할수없게 해당 토큰의 만료시간을 짧게 유지해야함,
	그리고 해킹의심되면 서버에서 해당토큰을 강제제거하면됨(이건선택)
	
	세션을 만들떈 uuid를 만들고 그걸 키값으로 쓰고,밸류에 id를 넣어두고 쿠키에 그 uuid를 넣어서 클라에 주면됨
	그리고 받은 uuid를 매칭해보고 있으면 그값을 사용하면됨
	즉 회원과 관련된 정보는 절대 클라에 주지않는다는거
	그리고 이 세션의 만료시간을 30분정도로 잡아버리면됨
	
	맵을써야하는데 동시성이슈가 있을때
		private Map<String, Object> sessionStore = new ConcurrentHashMap<>();
	uuid생성
		 String sessionId = UUID.randomUUID().toString();
	
	컨트롤알트c 상수로 변경
	
	세션을 직접 만들려면
	    public void createSession(Object value, HttpServletResponse res) {
			String sessionId = UUID.randomUUID().toString();
			sessionStore.put(sessionId, value);

			Cookie mySessionCookie = new Cookie("mySessionId", sessionId);
			res.addCookie(mySessionCookie);
		}
	이런식으로 만들면됨,uuid생성하고 그거랑 들어온 밸류로 세션스토어에 밀어넣고,uuid로 쿠키만들어서 res에 담기

	찾을떄는
	    public Cookie findCookie(HttpServletRequest req, String cookieName) {
			Cookie[] cookies = req.getCookies();
			if (cookies == null) {
				return null;
			}
			return Arrays.stream(cookies)
					.filter(cookie->cookie.getName().equals(cookieName))
					.findFirst()
					.orElse(null);

		}
	이렇게 찾아서 
		public Object getSession(HttpServletRequest req) {
			Cookie sessionCookie = findCookie(req, SESSION_COOKIE_NAME);
			if (sessionCookie == null) {
				return null;
			}
			return sessionStore.get(sessionCookie.getValue());

		}
	스토어로 검색돌려서 리턴해주면됨 밸류를
	세션만료는
	    public void expire(HttpServletRequest req){
			Cookie sessionCookie = findCookie(req, SESSION_COOKIE_NAME);
			if(sessionCookie!=null){
				sessionStore.remove(sessionCookie.getValue());
			}
		}
	이렇게 찾아서 날려주면됨
	테스트할때 res나 req는
		MockHttpServletResponse res = new MockHttpServletResponse();
	이렇게 모킹하고,이걸 HttpServletResponse대신쓸수있음
	req도 같음
	
	테스트에서 결과값 널일때
		Assertions.assertThat(expiredResult).isNull();

	이런 세션은 서블릿에서도 지원하니까 그냥 그거쓰면됨
	동작은 똑같고,추가로 세션을 일정기간 사용안하면 자동으로 삭제하는기능이 추가됨
	
	서블릿은 httpSession으로 지원함
	이거로 만들면 JSESSIONID로 쿠키를 만듬
	사용법은
	    HttpSession session = req.getSession();
        session.setAttribute("loginMember",loginMember);
	이렇게 로그인할때 현재 세션키값을 가져온뒤에(req.getSession은 만약 있으면 그걸 가져오고,없으면 생성함),
	거기에 현재 로그인 회원정보값을 밸류에 덮어주면됨
	그리고
		req.getSession(true)//기본값,세션이 있으면 기존세션반환,없으면 새세션반환
		req.getSession(false)//세션이 있으면 기존세션반환,없으면 null반환
	그리고 세션에 데이터를 보관할떄,한 세션에 여러값을 저장할수있음 
	
	세션을 삭제할땐
	    HttpSession session = req.getSession(false);
        if (session != null) {
            session.invalidate();
        }
	이렇게 삭제할수있음
	그리고 컨트롤러에서 세션을 받을땐,
		HttpSession session = req.getSession(false);
	로 받아야함
	저게 true면 세션을 만들어버려서 세션이 있는지없는지 체크가 안되기때문
	그리고
	    if (session == null) {
            return "home";
        }
	세션이 존재하는지 체크하고
        Member loginMember = (Member) session.getAttribute("loginMember");
        if (loginMember == null) {
            return "home";
        }
	세션에 해당값이 있는지 체크하면됨
	그리고 있으면
	    model.addAttribute("member", loginMember);
        return "loginHome";
	모델에 담아서 리턴하면됨
	
	그리고 당연히 스프링이 어노테이션으로 이걸 지원해줌
	세션을 받을때
		@SessionAttribute(name = SessionConst.LOGIN_MEMBER, required = false) Member loginMember
	이걸 사용하면됨
		@GetMapping("/")
		public String homeLoginV3Spring(@SessionAttribute(name = SessionConst.LOGIN_MEMBER, required = false) 
										Member loginMember,
										Model model) {
	그러면 세션이 있는지 체크하고 있으면 해당값을 담아서(없으면 null)던져줌
	이 기능은 세션을 생성하지않아서,로그인이 아닌(세션생성부분이 아닌),홈화면같은데서 체크할때 사용하면됨

	그리고 완전히 로그인 처음하면 url에 세션id가 적히는데,이건 웹브라우저가 쿠키를 지원하지않을까봐 url을 통해 유지하는거임,한번돌아서 쿠키사용하면 없어짐
	이걸 끄려면 application.properties에
		server.servlet.session.tracking-modes=cookie
	로 넣어주면됨
        session.getAttributeNames().asIterator()
                .forEachRemaining(name -> ...));
	이건 해당 컬렉션으로 forEach돌리는거
	
	그리고 세션의 정보들은
		session.getMaxInactiveInterval() //세션의 지속시간
		session.getCreationTime()  //세션이 만들어진시간
		session.getLastAccessedTime()//마지막 세션 접근시간
		session.isNew()           //세션이 방금만들어졌는지
	등이 있음
	그래서 마지막세션접근시간과 세션의 지속시간을 가지고,저게 넘으면 세션을 삭제하는거(처음만들어진시간으로하면 귀찮으니까)
	그리고 뭐 세션만들어지고 한달지나면 지워버리는정도로
	이때 기본값은 30분이고,설정은 application.properties에서
		server.servlet.session.timeout=1800
	저거 원하는값으로 넣으면됨(분단위로 넣어야함)
	그리고 특정 세션에서 다르게쓰고싶으면
		session.setMaxInactiveInterval(1800)
	넣어주면됨

	그리고 세션에는 최소한의 데이터만 보관해야함,그래야 메모리사용량이 줄어듬
	그리고 세션의 시간도 적당히 잡아야함
	그리고 장기로그인은 리프레시토큰으로 유지됨
















