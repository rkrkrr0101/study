1.스프링 배치 종결의 서막
*1.서문
스킵
*2.배치처리란
  배치는 일일정산,데이터마이그레이션,리포트생성,데이터정제,데이터통합등 다양한 용도로 사용됨
  배치에서 중요한건 정확성과 완결성임,처리에 시간이 걸려도 완벽하게 처리하는게 목표
  웹에서는 실패시 에러를 반환하고 끝냈지만,배치는 복구를 시도해볼수있음
  
  또한 트랜잭션도 체크포인트 기반으로 할수도있고,처리할 데이터양과 특성에 따라 범위조절도 가능함
  
  그리고 청크지향이라 데이터를 나눠서 순차처리할수있고,병렬처리도 가능함

*3.사전점검
  job은 하나의 완전한 배치 처리를 의미함(일일매출집계,정기결제등)
  step은 job을 구성하는 실행단위로,하나의 job은 하나이상의 step으로 구성됨
  즉 일일매출집계 job은
    매출집계step
	  전일주문데이터 read
	  결제완료된것만 필터링 process
	  상품별로 집계후 저장 write
	알림발송step
	  집계요약정보생성후 관리자에게 전달
	캐시갱신 step
	  집계된 데이터로 캐시정보 업데이트
  이런식으로 구성됨
  
  스프링배치는 배치잡을 만들기위해 필요한 거의 모든걸 제공함
  우리는 이 뼈대위에 스프링배치가 제공하는 컴포넌트들을 @configuration으로 구성만 하면됨
  즉 스프링배치를 스프링배치가 제공하는영역과 개발자가 제어하는 영역으로 나눠보는게 쉬움
  보통 잡과 스탭,잡런처,잡레포,ItemReader구현체,writer구현체등이 스프링 배치가 제공하는 영역임
  우리는 Job과 Step의 구성을 해야하고(configuration),기본적으로 제공되지않는 영역의 로직을 만들어야함(보통 processor은 제공하지않음)
  
  추가적으로 배치에선 시스템 시작의 결과를
    SpringApplication.run(abcApplication.class, args);
  이게 아닌
    System.exit(SpringApplication.exit(SpringApplication.run(abcApplication.class, args)));
  이런식으로 exit로 처리하는게 권장됨
  이러면 배치작업의 성공실패를 exit코드로 외부에 전달할수있어서 배치모니터링과 제어에 필수적임
  
  잡은 잡빌더를 통해 생성되는데,이때 잡의 이름과 잡레포지토리가 파라미터로 들어감
  또한 잡레포지토리와 트랜잭션매니저또한 자동으로 주입받을수있음
  잡이 스탭을 실행시키면,스탭은 순서대로 실행되고,이전스탭이 성공해야지만 실행됨
  
2.스프링 배치 시작
*1.스탭의 두가지 유형
  스탭은 크게 청크지향처리와 태스크릿 지향처리 두가지로 나눠짐
  1.태스크릿
	태스크릿은 가장 기본적인 처리방식으로,복잡하지않은 단순작업을 실행할때 사용함
	즉 대량데이터처리가 아닌,단순히 실행에 초점을 맞춘 오래된로그삭제,이동,알림발송등을 할때 사용됨
	즉 함수호출 하나로 끝날만한걸 할때 사용하면됨
	이걸 쓸떈 그냥 execute()에 원하는로직을 구현하고,구현체를 배치에 넘기기만 하면됨

	또한 RepeatStatus를 사용해서 반복을 할수있음(FINISHED, CONTINUABLE)
	FINISHED는 스탭이 종료됐다는거고,CONTINUABLE는 아직 더 진행해야한다는것
	물론 내부에서 반복문을 쓸수도있지만,이렇게 처리하는 이유는 짧은 트랜잭션을 사용해서 안전하게 배치처리를 하기위해서 이런식으로 처리함
	이러면 실패해도 한번에 처리하는양만큼만 실패하지,전체를 다시할필요는없음

	태스크릿을 구현했다면,이걸 스텝에 테스크릿으로 등록하면됨
	이건 @configuration파일에서 태스크릿과 스탭 빈을 만들고,이걸 잡 빈에 넣으면됨
	이떄 트랜잭션매니저와 잡레포지토리가 필요한데,만약 태스크릿작업이 트랜잭션이 필요없다면 ResourcelessTransactionManager을 사용할수있음
	이건 그냥 해당 클래스를 직접 new로 생성해서 스탭의 태스크릿넣는곳에 같이 넣어주면됨

	ResourcelessTransactionManager를 빈으로 만들고싶을땐 주의가 필요함
	이걸 빈으로 만들어버리면 메타데이터관리 트랜잭션에서도 저걸써버리기때문에 별도의 트랜잭션매니저구성을 해야함

	태스크릿을 사용할때,간단한작업이라면 그냥 스탭에서 람다식으로 정의해도되고,좀 복잡하다싶으면 별도클래스로 빼는게 나음
	보통 태스크릿작업을 할땐 태스크릿에서 생성자di로 처리할때 사용할 파라미터(레포지토리나 파일경로등)을 받아서 처리하는경우가 많은듯
	그리고 포인터같은걸 둬서 일정단위로 밀어내면서 처리하고,빈거만나면 끝내고 이런식
	
	즉 태스크릿은 단순하고 명확한 작업을 수행할때 사용되는 step이고
	  단순작업에 적합(알림발송,파일복사,오래된데이터삭제등)
	  Tasklet 인터페이스 구현후 이를 StepBuilder.tasklet()에 전달
	  RepeatStatus로 실행제어
	  트랜잭션지원(execute단위로 트랜잭션이 걸림)
	이런 특징들이 있음
  2.청크
    일반적으로 배치를 처리할때 사용하는 읽기-처리-쓰기를 할땐 청크지향 처리를 사용하면됨
	청크랑 데이터를 일정단위로 쪼갠 덩어리를 말함(백만데이터를 백개단위로 쪼개서 처리 이런느낌)
	이렇게 처리해야 메모리관리,가벼운 트랜잭션(작은실패)등이 가능해짐
	
	배치에서 읽기-처리-쓰기 패턴은 딱 3가지로 나뉘어짐
	이게 ItemReader,ItemProcessor,ItemWriter임
	
	1.ItemReader
	  이건 한번에 하나씩(db 한 row씩) 읽어서 반환하고,읽을데이터가 없다면 null을 반환함
	  이 null을 반환하는게 청크지향처리스탭의 종료시점임
	  
	  또한 이미 아이템리더의 경우 표준구현체들이 많이있음(FlatFileItemReader,JdbcCursorItemReader등)
	2.ItemProcessor
	  이건 데이터를 원하는 형태로 깎아내는,즉 실제 로직을 처리함
	  이것도 리더처럼 데이터 하나하나씩 입력받아서 반환함
	  얘는 보통
	    데이터가공(입력데이터를 출력데이터의 형태로 변환함)
		필터링(null을 반환해서 해당데이터를 처리흐름에서 제외시킴)
		데이터검증(입력데이터의 유효성을 검사,조건에 맞지않는 데이터를 만나면 예외를 발생시켜 잡을 중단시킴)
	  이런 작업을 처리하고,꼭 프로세서가 있을필요는없음,즉 스탭에서 직접 데이터를 읽고바로쓰게할수도있음
	
	3.ItemWriter
	  이건 프로세서의 결과물을 받아서 원하는방식으로 최종저장/출력함
	  이건 청크단위로 한번에 데이터를 쓰고,이단위로 트랜잭션에 묶임
	  이것도 다양한 구현체들이 이미 만들어져있음(FlatFileItemWriter,JdbcCursorItemWriter 등)
	
	이런식으로 크게 3개단위로 분리해서 처리되는게 기본패턴인데,이걸통해
	  완벽한 책임분리
	  재사용성극대화
	  높은 유연성(데이터소스가 바뀌면 리더만,데이터형식이 바뀌면 프로세서만 변경하면됨)
	  대용량처리의 표준
	를 얻을수있음
	
	이 청크지향스탭을 조립할때도 StepBuilder를 사용하면됨
	이때 
	  return new StepBulder("스탭명",jobRepository)
	    .<리더의반환타입,프로세서의반환타입>chunk(청크사이즈,트랜잭션메니저)
		.reader(itemReader())
        .processor(itemProcessor()) 
        .writer(itemWriter())
		.build()
	이런식으로 하면됨
	이떄 스탭의 동작방식은,
	  청크갯수만큼 리더가 읽어서 청크를 구성하고(단일호출로 n개의 데이터를 가져와 하나의 청크를 생성)
	  구성된 청크의 내용물을 하나하나 프로세서가 처리해서 처리완료된 청크로 만들고(단일처리는 맞음,즉 청크크기가 10이면 한 청크를 처리할때 10번호출)
	  처리완료된 청크를 라이터가 저장(이건 청크 전체를 한번에 처리함)
	이런 방식으로 진행됨
	이걸 더이상 읽을데이터가 없을때(read가 null을 반환할때)까지 반복함
	즉 청크크기만큼 read하고,청크크기만큼 process한다음 한번 write해서 저장하는게 한 청크처리임
	
	청크지향처리에서 트랜잭션관리는 각 청크단위로 진행됨
	즉 실패시 해당 청크만 롤백된다는것
	이떄 청크사이즈는 트레이드오프와 업무요구사항,데이터양을 고려해서 적절히 골라야함
	이때 트레이드오프는
	  청크사이즈가 클때
	    메모리에 많은데이터를 한번에 로드함
		트랜잭션범위가 커져서 롤백데이터양이 많아짐
	  청크사이즈가 작을때
	    롤백데이터가 최소화됨
		읽기쓰기io가 자주발생하게됨
	이런 문제가 있음
  
*2.JobParamater
  1.잡파라미터란?
    잡파라미터는 처리대상과 조건등 배치작업에 전달되는 입력값임 
	이걸 사용해서 같은 잡을 입력값만 바꿔서 유연하게 실행할수있음
	물론 -D로 프로퍼티전달을 할순있지만,목적이 서로 다름
	
  2.프로퍼티와 잡파라미터의 결정적 차이
    1.입력값 동적 변경
	  단순한경우 프로퍼티로 충분하지만,웹요청에 전달된값을 Job의 매개변수로 주입하려는등은 프로퍼티로 해결하기힘듬(배치 프로그램을 띄워두고 잡을 실행시키는형태일떄)
	  프로퍼티는 앱 시작시 한번 주입되고 끝이기때문
	
	2.메타데이터
	  스프링 배치는 잡파라미터의 모든값을 메타데이터 저장소에 저장하고,이걸통해
	    Job인스턴스 식별 및 재시작 처리
		Job 실행이력추적
	  등을 할수있음
	  
	  이때 메타데이터는 JobRepository를 통해 Job과 Step의 실행이력을 저장소에 저장하고,
	  여기엔 잡과 스탭의 시작/종료시간,실행상태,처리레코드수 등이 포함됨
	  
	  반면 프로퍼티는 메타데이터로 저장되지않아서 관리가 불가능해,배치운영과 제어를 제한하게됨
	  즉 재시작이나 처리이력관리등이 안되게됨
  3.JobParameters 전달하기
    1.커맨드라인(CLI)
	  커맨드라인에선
	    ./gradlew bootRun --args='--spring.batch.job.name=dataProcessingJob inputFilePath=/data/input/users.csv,java.lang.String'
	  이런식으로 
		 --spring.batch.job.name=실행잡이름 파라미터1이름=값1,파라미터타입 파라미터2이름=값2,파라미터타입
      이렇게 전달하면됨
	  
	  이때 파라미터타입은 DefaultJobParametersConverter를 통해 적절한 타입으로 변환되는데,
	  기본적인 타입과 LocalDateTime등 시간관련타입등 다양한 타입을 지원함
	2.프로그래밍방식
	  이경우엔 JobParametersBuilder컴포넌트를 사용해서 잡 파라미터를 만들고,이걸 JobLauncher에 넣어서 잡을 실행시킬수있음
	  이때 addJobParameter()의 체이닝을 통해 잡파라미터를 추가하고,toJobParameters()로 빌드를 할수있음
	  이것도 
	    addJobParameter(파라미터명,파라미터값,타입)
	  즉
		JobParameters jobParameters = new JobParametersBuilder()
          .addJobParameter("inputFilePath", "/data/input/users.csv", String.class)
          .toJobParameters();
	  이렇게 넣으면됨
	  
	  여기서 JobLauncher는 잡을 실행하는데 사용되는 핵심도구로,잡파라미터를 입력받아 잡의 실행컨텍스트를 생성하고,잡이 성공적으로 실행되게 관리하는역할을 함
	3.잡파라미터 직접 접근
	  잡파라미터에 직접 접근하려면,어디서 잡파라미터가 관리되는지를 알아야함
	  스프링배치에선 JobExecution이 잡의 실행정보를 쥐고있음,즉 잡파라미터도 이안에있음
	  스탭에서 잡파라미터를 찾으려면 이 JobExecution을 통해서 찾아야함
	  테스크릿에서 잡 파라미터를 찾을땐 
	     public RepeatStatus execute(StepContribution contribution, ChunkContext chunkContext) {
         JobParameters jobParameters = chunkContext.getStepContext()																			            
            .getStepExecution()																				      
            .getJobParameters();
	  이런식으로 컨텍스트에서 익스큐션을 찾고,거기에 잡파라미터를 찾아야함
	  이때 잡익스큐션이 아닌 스텝익스큐션을 사용하는데,스텝익스큐션안에 부모잡의 잡익스큐션을 참조하고있어서 이렇게 찾는거
	  
  4.다양한 타입의 잡파라미터
    1.기본데이터타입
      기본적으로 잡파라미터를 받아서 사용할땐 di로 하게되는데
	     @Bean
         @StepScope //@Value로 잡파라미터를 전달받을떈 @StepScope등을 선언해줘야함
	       public Tasklet terminatorTasklet(
	  	     @Value("#{jobParameters['terminatorId']}") String terminatorId, 
	  	     @Value("#{jobParameters['targetCount']}") Integer targetCount
	       ) { 
	  이런식으로 di받으면됨
	  그리고
	    ./gradlew bootRun --args='--spring.batch.job.name=processTerminatorJob terminatorId=KILL-9,java.lang.String targetCount=5,java.lang.Integer'
      이런식으로 넣으면되는거
	2.날짜와 시간 타입
	  또한 날짜의 경우도 같은방식으로 di받고 
	    executionDate=2024-01-01,java.time.LocalDate startTime=2024-01-01T14:30:00,java.time.LocalDateTime
	  이런식으로 받으면됨
	  이떄 주의점은 LocalDate는 ISO_LOCAL_DATE,LocalDateTime은 ISO_LOCAL_DATE_TIME형식으로 전달해야한다는점
	  다른것도 마찬가지임 java.util.Date는 ISO_INSTANT 형식으로, java.time.LocalTime은 ISO_LOCAL_TIME형식으로 전달해야함
	  
    3.Enum타입
	  enum의 경우엔 받을땐 똑같이
	    @Value("#{jobParameters['questDifficulty']}") QuestDifficulty questDifficulty
	  이렇게하면되고,줄떈
	    questDifficulty=HARD,com.system.batch.killbatchsystem.TerminatorConfig$QuestDifficulty
	  이렇게하면되는데,이때 $는 중첩클래스일땐 저렇게 표시해야함,만약 중첩클래스가 아니라면 그냥 똑같이 경로설정해주면됨
	
	4.POJO를 활용한 잡파라미터주입
	  만약 여러 Job파라미터를 효율적으로 관리해야한다면,별도의 클래스를 만들어 파라미터를 관리하면 구조화와 재사용성이 높아짐
	  즉 잡파라미터 관리용 컴포넌트를 만들고,여기에 StepScope를 붙인다음 여기서 잡파라미터를 다 주입받은다음에 이걸 가져다가 쓰는거
	  어짜피 싱글톤으로 실행되니까
	
	5.기본파라미터 표기법의 한계
	  문제는,기본파라미터에서 쉼표(,)가 파라미터값에 포함되게되면 문제가 발생함 
	  그래서 사용되는게 Json기반의 파라미터표기임
	6.Json기반 표기법
	  기본적으론
	    implementation 'org.springframework.boot:spring-boot-starter-json'
	  이 의존성이 필요함
	  그리고나서 JsonJobParametersConverter빈을 직접 등록해줘야함
	  그리고나서 잡파라미터로
	    ./gradlew bootRun --args="--spring.batch.job.name=terminatorJob infiltrationTargets='{\"value\":\"판교서버실,안산데이터센터\",\"type\":\"java.lang.String\"}'"
	  이렇게 json을 넘겨주면됨
	  받는건 똑같이
	    @Value("#{jobParameters['infiltrationTargets']}") String infiltrationTargets
	  이렇게받으면됨(파라미터명으로)
    7.커맨드라인 파라미터는 어떻게 실제 Job으로 전달될까?
	  배치를 스프링부트3이랑 쓰면,앱이 시작될떄 JobLauncherApplicationRunner라는 컴포넌트가 자동으로 동작함
	  이건 스프링부트가 제공하는 어플리케이션러너중 한 종류로,얘는 커맨드라인으로 전달된 잡파라미터를 해석하고 이걸바탕으로 실제 잡을 실행하는 역할을 맡음
	  얘는
	    잡목록준비:등록된 모든 잡타입 빈을 자동주입받음
		유효성검증:잡타입빈이 여러개인데 잡네임이 없을경우 검증실패,만약 하나라면 생략가능
		명령어해석:커맨드라인으로 전달된 값(잡파라미터)들을 파싱함,
		  여기서 DefaultJobParametersConverter나 JsonJobParametersConverter을 사용해 문자열을 적절한 잡파라미터로 변환함
		Job실행:첫단계의 잡리스트에서 해당이름의 잡을 찾고,해당잡을 잡파라미터를 넣어서 실행시킴,이과정에서 JobLauncher라는 잡실행컴포넌트가 사용됨
	  이런식으로 동작함

  5.JobParametersValidator
    이건 말그대로 잡파라미터 밸리데이터,즉 검증도구임
	이 인터페이스는 단순하게 하나의 검증메서드만 있음 
		public interface JobParametersValidator {
			void validate(@Nullable JobParameters parameters) throws JobParametersInvalidException;
		}	
    말그대로 잡파라미터를 받아서 검증한후 아니다싶으면 예외를 던지면됨
	이건 잡을 등록할때 JobBuilder에서 validator로 등록해주면됨,이러면 잡실행시점에 호출되어 파라미터검증을 진행함
	
	물론 매번 만들긴 귀찮으니까  DefaultJobParametersValidator를 사용할수도 있는데
	이건 그냥 파라미터의 존재여부만 확인해줌
	이건
	  DefaultJobParametersValidator([필수파라미터명],[선택파라미터명])
	이렇게 넣어두면 검증해줌
	그리고 만약 선택파라미터에 값이 있다면,모든 잡파라미터들은 필수나 선택중 한군데에 들어가야함,만약 저기에없는 파라미터가 들어오면실패함
	선택파라미터에 값이 없다면,그냥 자유롭게 허용함
	
*3.배치 Scope  
  1.Job과 Step의 Scope 이해하기
    배치의 스코프는 스프링의 기본 스코프인 싱글톤과 다른 특별한 스코프를 제공함
	JobScope와 StepScope임
	
	얘들이 선언된 빈은 어플리케이션 구동시점에는 프록시로만 존재하다가,잡이나 스탭이 실행된후에 프록시객체에 접근하면 그때 실제빈이 생성됨
	이러면 이점이 뭐냐면,런타임에서 잡파라미터가 결정되어서 실행시점에 정확하게 주입받을수있고,
	동시에 여러잡이 실행되더라도 각각 독립적인 빈을 사용하게되어 동시성문제도 해결됨
	또한 잡이나 스탭의 실행이 끝나면 해당빈도 같이 제거되므로 메모리적으로도 효율적임
  
  2.@JobScope
    잡스코프는 잡이 실행될때 실제 빈이 생성되고 잡이 종료될떄 함께 제거되는 스코프임
	즉 JobExecution과 생명주기를 같이함
	
	이게 붙은 빈은 구동시점에는 프록시만 생성됨
	그래서 어플리케이션 실행중에 잡파라미터가 변경되거나,잡을 실행 직전에 잡파라미터를 만들어서 잡을 실행시키는등의 일이 가능해짐
	또한 잡이 실행될때 실제 빈이 생성되니까 병렬처리도 가능해짐
  
  3.@StepScope
    스텝스코프는 잡스코프와 유사하지만 스텝레벨에서 동작하는 스코프임
	이건 스텝의 실행범위에서 빈을 관리함
	즉 각각 스텝의 실행마다 새로운 빈이 생성되고,스텝이 종료될때 함께 제거됨
	그래서 동시성이슈가 터지지않음

  4.JobScope와 StepScope사용시 주의사항
    1.프록시대상의 타입이 클래스라면,반드시 상속가능한클래스여야함
	  cglib기반의 프록시생성이기떄문에 상속가능해야함
	2.Step빈에는 @StepScope와 @JobScope를 사용하지말라
	  스텝에 StepScope를 달면 스텝빈생성과 스코프활성화시점이 맞지않아 오류가발생함
	  배치는 스텝실행전 메타데이터관리를 위해 스텝빈에 접근해야하는데,이시점엔 스텝이 실행되지않아 스텝스코프가 활성화되지않은상태임
	  그래서 스코프없이 프록시에 접근하니까 안되는거
	  
	  마찬가지로 @JobScope도 스텝에 선언하면안됨
	  단순한 배치에선 문제가 없지만,복잡한 상황에선 예상치못한 문제가 발생함
	    JobOperator을 통한 Step실행제어
		Spring Integration(Remote Partitioning)을 활용한 배치확장기능등
	  이런거
	  
	  그런데 스텝에서 잡파라미터를 쓸땐 스코프가 필요함
	  이럴땐 스텝단위로 스코프를 받는게 아닌,Tasklet에서 스코프를 달아서 파라미터를 받으면됨
	  또 생기는 문제는 잡빌더에서 컴파일시점에 없는값을 참조할때 생기는 문제임
	  스텝에서 받는 잡파라미터는 컴파일시점엔 값이 존재하지않음
	  가장 깔끔한 방법은 스텝을 빈으로 등록하고 이걸 생성자주입받는것
	  
	  그런데 만약 직접 스탭을 호출해야한다면,해당자리에 null을 넣으면 알아서 잡이 실행될때 입력받은 잡파라미터값으로 교체함(지연바인딩)
	  
  5.ExecutionContext
    잡익스큐션과 스텝익스큐션은 시작시간,종료시간,실행상태등의 메타데이터를 관리하는데,이런 기본적인 정보만으로는 시스템을 완벽하게 제어하기 부족할때가 있음
	비즈니스로직 처리중 발생하는 커스텀데이터를 관리할 방법이 필요한데,이때 사용하는게 ExecutionContext라는 데이터컨테이너임
	
	얘를 쓰면 커스텀컬렉션의 마지막처리인덱스같은 데이터를 저장할수있고,이건 잡이 중단된후 재시작할떄 특히 유용함
	배치가 재시작할때 이걸 자동으로 복원하기때문(이것도 메타데이터저장소에서 관리함)
	
	JobScope와 StepScope에서 ExecutionContext에 접근할때도 @Value로 접근할수있음
	  @Value("#{jobExecutionContext['previousSystemState']}") String prevState
	  @Value("#{stepExecutionContext['targetSystemStatus']}") String targetStatus
	이런식
	단 jobExecutionContext와 stepExecutionContext는 서로 다른 범위를 가지는데,
	jobExecutionContext는 해당 잡에 속한 모든 컴포넌트에서 접근할수있지만,stepExecutionContext는 해당 스텝에 속한 컴포넌트에서만 접근할수있음
	
	즉 스텝의 ExecutionContext에 저장된 데이터는 jobExecutionContext로 가져올수없고,다른 스탭의 stepExecutionContext데이터를 가져올수없음
	이렇게 스텝간 데이터 독립성이 완벽하게 보장됨
	만약 이전스텝의 처리결과를 다음스텝에서 활용해야한다면 jobExecutionContext에 담아서 사용해야함
	즉 jobExecutionContext는 job재시작시 복원과 step간 데이터공유수단으로도 사용됨
  
	
*4.Spring Batch Listener
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  