1.스프링 배치 종결의 서막
*1.서문
스킵
*2.배치처리란
  배치는 일일정산,데이터마이그레이션,리포트생성,데이터정제,데이터통합등 다양한 용도로 사용됨
  배치에서 중요한건 정확성과 완결성임,처리에 시간이 걸려도 완벽하게 처리하는게 목표
  웹에서는 실패시 에러를 반환하고 끝냈지만,배치는 복구를 시도해볼수있음
  
  또한 트랜잭션도 체크포인트 기반으로 할수도있고,처리할 데이터양과 특성에 따라 범위조절도 가능함
  
  그리고 청크지향이라 데이터를 나눠서 순차처리할수있고,병렬처리도 가능함

*3.사전점검
  job은 하나의 완전한 배치 처리를 의미함(일일매출집계,정기결제등)
  step은 job을 구성하는 실행단위로,하나의 job은 하나이상의 step으로 구성됨
  즉 일일매출집계 job은
    매출집계step
	  전일주문데이터 read
	  결제완료된것만 필터링 process
	  상품별로 집계후 저장 write
	알림발송step
	  집계요약정보생성후 관리자에게 전달
	캐시갱신 step
	  집계된 데이터로 캐시정보 업데이트
  이런식으로 구성됨
  
  스프링배치는 배치잡을 만들기위해 필요한 거의 모든걸 제공함
  우리는 이 뼈대위에 스프링배치가 제공하는 컴포넌트들을 @configuration으로 구성만 하면됨
  즉 스프링배치를 스프링배치가 제공하는영역과 개발자가 제어하는 영역으로 나눠보는게 쉬움
  보통 잡과 스탭,잡런처,잡레포,ItemReader구현체,writer구현체등이 스프링 배치가 제공하는 영역임
  우리는 Job과 Step의 구성을 해야하고(configuration),기본적으로 제공되지않는 영역의 로직을 만들어야함(보통 processor은 제공하지않음)
  
  추가적으로 배치에선 시스템 시작의 결과를
    SpringApplication.run(abcApplication.class, args);
  이게 아닌
    System.exit(SpringApplication.exit(SpringApplication.run(abcApplication.class, args)));
  이런식으로 exit로 처리하는게 권장됨
  이러면 배치작업의 성공실패를 exit코드로 외부에 전달할수있어서 배치모니터링과 제어에 필수적임
  
  잡은 잡빌더를 통해 생성되는데,이때 잡의 이름과 잡레포지토리가 파라미터로 들어감
  또한 잡레포지토리와 트랜잭션매니저또한 자동으로 주입받을수있음
  잡이 스탭을 실행시키면,스탭은 순서대로 실행되고,이전스탭이 성공해야지만 실행됨
  
2.스프링 배치 시작
*1.스탭의 두가지 유형
  스탭은 크게 청크지향처리와 태스크릿 지향처리 두가지로 나눠짐
  1.태스크릿
	태스크릿은 가장 기본적인 처리방식으로,복잡하지않은 단순작업을 실행할때 사용함
	즉 대량데이터처리가 아닌,단순히 실행에 초점을 맞춘 오래된로그삭제,이동,알림발송등을 할때 사용됨
	즉 함수호출 하나로 끝날만한걸 할때 사용하면됨
	이걸 쓸떈 그냥 execute()에 원하는로직을 구현하고,구현체를 배치에 넘기기만 하면됨

	또한 RepeatStatus를 사용해서 반복을 할수있음(FINISHED, CONTINUABLE)
	FINISHED는 스탭이 종료됐다는거고,CONTINUABLE는 아직 더 진행해야한다는것
	물론 내부에서 반복문을 쓸수도있지만,이렇게 처리하는 이유는 짧은 트랜잭션을 사용해서 안전하게 배치처리를 하기위해서 이런식으로 처리함
	이러면 실패해도 한번에 처리하는양만큼만 실패하지,전체를 다시할필요는없음

	태스크릿을 구현했다면,이걸 스텝에 테스크릿으로 등록하면됨
	이건 @configuration파일에서 태스크릿과 스탭 빈을 만들고,이걸 잡 빈에 넣으면됨
	이떄 트랜잭션매니저와 잡레포지토리가 필요한데,만약 태스크릿작업이 트랜잭션이 필요없다면 ResourcelessTransactionManager을 사용할수있음
	이건 그냥 해당 클래스를 직접 new로 생성해서 스탭의 태스크릿넣는곳에 같이 넣어주면됨

	ResourcelessTransactionManager를 빈으로 만들고싶을땐 주의가 필요함
	이걸 빈으로 만들어버리면 메타데이터관리 트랜잭션에서도 저걸써버리기때문에 별도의 트랜잭션매니저구성을 해야함

	태스크릿을 사용할때,간단한작업이라면 그냥 스탭에서 람다식으로 정의해도되고,좀 복잡하다싶으면 별도클래스로 빼는게 나음
	보통 태스크릿작업을 할땐 태스크릿에서 생성자di로 처리할때 사용할 파라미터(레포지토리나 파일경로등)을 받아서 처리하는경우가 많은듯
	그리고 포인터같은걸 둬서 일정단위로 밀어내면서 처리하고,빈거만나면 끝내고 이런식
	
	즉 태스크릿은 단순하고 명확한 작업을 수행할때 사용되는 step이고
	  단순작업에 적합(알림발송,파일복사,오래된데이터삭제등)
	  Tasklet 인터페이스 구현후 이를 StepBuilder.tasklet()에 전달
	  RepeatStatus로 실행제어
	  트랜잭션지원(execute단위로 트랜잭션이 걸림)
	이런 특징들이 있음
  2.청크
    일반적으로 배치를 처리할때 사용하는 읽기-처리-쓰기를 할땐 청크지향 처리를 사용하면됨
	청크랑 데이터를 일정단위로 쪼갠 덩어리를 말함(백만데이터를 백개단위로 쪼개서 처리 이런느낌)
	이렇게 처리해야 메모리관리,가벼운 트랜잭션(작은실패)등이 가능해짐
	
	배치에서 읽기-처리-쓰기 패턴은 딱 3가지로 나뉘어짐
	이게 ItemReader,ItemProcessor,ItemWriter임
	
	1.ItemReader
	  이건 한번에 하나씩(db 한 row씩) 읽어서 반환하고,읽을데이터가 없다면 null을 반환함
	  이 null을 반환하는게 청크지향처리스탭의 종료시점임
	  
	  또한 이미 아이템리더의 경우 표준구현체들이 많이있음(FlatFileItemReader,JdbcCursorItemReader등)
	2.ItemProcessor
	  이건 데이터를 원하는 형태로 깎아내는,즉 실제 로직을 처리함
	  이것도 리더처럼 데이터 하나하나씩 입력받아서 반환함
	  얘는 보통
	    데이터가공(입력데이터를 출력데이터의 형태로 변환함)
		필터링(null을 반환해서 해당데이터를 처리흐름에서 제외시킴)
		데이터검증(입력데이터의 유효성을 검사,조건에 맞지않는 데이터를 만나면 예외를 발생시켜 잡을 중단시킴)
	  이런 작업을 처리하고,꼭 프로세서가 있을필요는없음,즉 스탭에서 직접 데이터를 읽고바로쓰게할수도있음
	
	3.ItemWriter
	  이건 프로세서의 결과물을 받아서 원하는방식으로 최종저장/출력함
	  이건 청크단위로 한번에 데이터를 쓰고,이단위로 트랜잭션에 묶임
	  이것도 다양한 구현체들이 이미 만들어져있음(FlatFileItemWriter,JdbcCursorItemWriter 등)
	
	이런식으로 크게 3개단위로 분리해서 처리되는게 기본패턴인데,이걸통해
	  완벽한 책임분리
	  재사용성극대화
	  높은 유연성(데이터소스가 바뀌면 리더만,데이터형식이 바뀌면 프로세서만 변경하면됨)
	  대용량처리의 표준
	를 얻을수있음
	
	이 청크지향스탭을 조립할때도 StepBuilder를 사용하면됨
	이때 
	  return new StepBulder("스탭명",jobRepository)
	    .<리더의반환타입,프로세서의반환타입>chunk(청크사이즈,트랜잭션메니저)
		.reader(itemReader())
        .processor(itemProcessor()) 
        .writer(itemWriter())
		.build()
	이런식으로 하면됨
	이떄 스탭의 동작방식은,
	  청크갯수만큼 리더가 읽어서 청크를 구성하고(단일호출로 n개의 데이터를 가져와 하나의 청크를 생성)
	  구성된 청크의 내용물을 하나하나 프로세서가 처리해서 처리완료된 청크로 만들고(단일처리는 맞음,즉 청크크기가 10이면 한 청크를 처리할때 10번호출)
	  처리완료된 청크를 라이터가 저장(이건 청크 전체를 한번에 처리함)
	이런 방식으로 진행됨
	이걸 더이상 읽을데이터가 없을때(read가 null을 반환할때)까지 반복함
	즉 청크크기만큼 read하고,청크크기만큼 process한다음 한번 write해서 저장하는게 한 청크처리임
	
	청크지향처리에서 트랜잭션관리는 각 청크단위로 진행됨
	즉 실패시 해당 청크만 롤백된다는것
	이떄 청크사이즈는 트레이드오프와 업무요구사항,데이터양을 고려해서 적절히 골라야함
	이때 트레이드오프는
	  청크사이즈가 클때
	    메모리에 많은데이터를 한번에 로드함
		트랜잭션범위가 커져서 롤백데이터양이 많아짐
	  청크사이즈가 작을때
	    롤백데이터가 최소화됨
		읽기쓰기io가 자주발생하게됨
	이런 문제가 있음
  
*2.JobParamater와 배치 Scope 
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  