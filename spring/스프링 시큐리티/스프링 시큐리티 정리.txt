1.보안 기본
	api보안을 하지않으면
		컨텐츠가 공개되어있어 정보를 보는사람을 통제할수없음
		컨텐츠는 익명이라 누가요청했는지 알수없음
		컨텐츠는 보호되지않아,악의적인 유저가 브라우저기반취약점을 이용할수있음
	같은 문제가 있음	
	
	컨텐츠는 공개되어서 그 ip에 접근할수있는 모두가 api를 열수있고 데이터를 볼수있음,
	이건 네트워크보안을 통해 완화할순있지만,보통은 퍼블릭으로 여는편이라 도움이 안됨
	퍼블릭망에 공개하지않았더라도,ssrf로 인해 열어두고싶어도 열면안됨
	
	컨텐츠가 익명이면,사용자가 누구인지,신뢰할수있는지,권한이 있는지를 알수없어서,해당 사용자의 특정컨텐츠를 표시하는게 더 까다로워짐
	이걸 인증을 요구해서 완화할수있음
		
	그리고 컨텐츠가 보호되지않아서,이게 브라우저에 노출될경우 추가개입없이 앱전체가 csrf,mitm,xss등의 공격에 취약해질수있음
	
	404낫파운드를 그냥 뜨게 두는거도 디렉토리 탐색을 할수있게되는등의 취약점이 발생할수있음
	
	즉 rest api는 기본적으로 공개되고,익명 및 보호가 되지않아서,
	다른 외부툴같은거로 인증,권한부여 방어메커니즘을 추가해야하는데 스프링에선 스프링시큐리티가 젤나음
		
		
	스프링 시큐리티가 클래스경로에 있으면,스프링부트는 rest api에 대해
		모든 요청에 인증필요
		모든 요청에 보안헤더로 응답
		부작용이 있는 모든 요청에 대해 csrf완화가 필요
		기본사용자로 http기본인증을 허용
		보안실패에 restful하게 대응
		앱방화벽으로부터 악의적인 요청으로부터 보호
	를 기본값으로 사용하여 어플리케이션을 구성함
	
	모든 요청에 인증필요는,엔드포인트가 뭐든간에 관계없이 모든 디스패치의 모든요청에는 인증이 필요함
	엔드포인트의 성격과 관계없이 시큐리티는 모든 요청을 검사하고 요청이 인증되지않으면 거부하는 서블릿필터를 적용함
	즉 디스패처서블릿의 앞단에 요청검사하는 필터를 둬서,아니다싶으면 튕겨내는거
	즉 그래서 엔드포인트가 뭐든 신경안쓰고 먼저 가로채니,404가 뜰수가 없어짐(권한없음이 먼저뜨고 권한이 있어야 디스패처서블릿가서 404띄우니까)
	그래서 최소권한원칙이 적용됨
	
	모든 요청에 보안헤더로 응답은,시큐리티는 요청이 인증되든 아니든 특정 헤더로 응답하는데,이떄의 기본값이 가장 안전한값임
	이떄 헤더로는
		캐시제어헤더:브라우저에 응답기록 캐싱하는걸 캐시하지못하게함
		엄격한 전송보안헤더:이건 브라우저가 지정된기간동안 요청을 https로 보내는걸 강제함
		컨텐츠유형옵션헤더(X-Content-Type-Options):브라우저가 응답의 컨텐츠 유형을 추측하지말라고 지시함,
			이걸통해 추측을통한 스크립트 실행을 방지할수있음
	가 있음

	부작용이 있는 모든 요청에 대해 csrf완화가 필요는,타사웹사이트가 동의없이 내 서버에 요청할수있음
	즉 이미 로그인을 했으면 해당 쿠키를 다른웹사이트에서 우리서버로 던져서 값을 훔쳐갈수있음,
	이걸 막기위해 후속요청에 사용해야하는 특수토큰을 클라로 던지는데,이게없으면 post,put,delete를 실행시키지않음
	이건 제 3자가 볼수없는 방식으로 전송되고,이 토큰이 반환되면 해당 클라는 합법이라고 간주함
		
	기본사용자로 http기본인증을 허용은,기본적으로 따로 뭘 안하면 시큐리티는 user라는 기본계정을 만드는데,이때 비밀번호는 시작할떄마다 생성됨(uuid)
	그래서 기본값으로 프로덕션에 배포할때 기본값id패스워드를 사용해서 난리치는걸 막음
		
	보안실패에 restful하게 대응은,요청에 자격증명이 잘못되었거나 누락되면 401을 날리는데,이건 요청이 인증되지않았다는것
	자격은 정상이지만 권한이 없으면 403을 날림,이건 요청이 승인되지않았다는것
		
	앱방화벽으로부터 악의적인 요청으로부터 보호는,이상한짓을 하는(줄바꿈이나 이중인코딩,캐리지리턴(아스키13)등이 포함된)요청들은 그냥 거부함
	이런 방확벽을 추가해서 취약성을 완화함
		
		
	스프링 시큐리티를 사용하려면,빌드.그래들에서 	
		dependencies {
		  ...
		  implementation 'org.springframework.boot:spring-boot-starter-security'
		  testImplementation 'org.springframework.security:spring-security-test'
		  ...
		}
	를 추가하기만 하면됨
	이때 시큐리티만 추가해서 테스트를 돌리면 테스트실패가 나는데,이건 모든 api요청에대해 인증을 필요로하기때문,그래서 테스트쪽은 따로 빼줘야함
	테스트코드의 클래스에 @WithMockUser 어노테이션을 추가하면됨(@SpringBootTest 밑에)
	그리고 post나 put,delete테스트는 csrf토큰을 추가해야하는데
		String location = this.mvc.perform(post("/cashcards")
							.with(csrf())
							...
	이런식으로 csrf를 모킹해서 사용하면됨(import static org.springframework.security.test.web.servlet.request.SecurityMockMvcRequestPostProcessors.csrf;)
		
	시큐리티를 사용하고 평범하게 서버에 api요청을 던지면 401이 나옴,404가 뜰곳도 다 401이 나옴(권한없음)
	그리고 헤더를 보면
		Cache-Control: no-cache, no-store, max-age=0, must-revalidate
		X-Content-Type-Options: nosniff
		X-Frame-Options: DENY
	가 붙은걸 볼수있음
	
	시큐리티를 기본값으로 실행시키면,아이디는 user이고 패스워드는 터미널에
		Using generated security password: 6cc833e4-8be5-44a6-b005-54e19c8e3201
	이런식으로 표시됨
	이걸가지고 api요청을 날릴때
		http -a 유저명:패스워드 ip:포트/상세주소
		http -a user:3ce23782-39af-4759-a221-4c08681daca9 127.0.0.1:8080/cashcards
	이렇게 날려야함
	이렇게 권한이 있는상태에서 404뜰곳에 날리면,404가 나옴
	
	이떄도 post를 날리면 401이 뜨는데,이건 csrf토큰이 없어서그럼,
	써드파티는 이 토큰을 볼수없기때문에,이게있으면 신뢰할수있는 출처에서 왔다고 믿을수있음
	
	그리고 스프링은,url에 이상한거 섞으면 기본적으로 튕겨냄,%2F같은거 들어가면 400에러를 띄움

	
	즉 스프링시큐리티는,모든엔드포인트에 대해 인증을 요구하고,
	부수적작업을 위해 csrf를 요구하며,
	시작시 기본패스워드를 다시 생성하고,
	응답에 보안헤더를 작성하고,
	여러 유형의 악성요청을 차단함


2.인증











	
		