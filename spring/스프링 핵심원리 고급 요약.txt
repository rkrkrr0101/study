1.예제생성
	로그에서 시작시간을 알면 종료시간도 알수있음(둘뺴면되니까)
	
	쌩으로 로그찍을때는,하단에서 예외가 터지면,그대로 뒤에꺼가 다 무시되니 트라이캐치로 싸서 파이널리에 넣어두거나 트라이랑 캐치 각각넣어둬야함
	그리고 로그가 어플리케이션의 흐름을 바꾸면안되니,캐치에선 무조건 다시 같은예외를 던져야함
	
	필요없는건 다스킵

2.쓰레드로컬
	기본적으로 빈등록하면 따로 뭐 안해주면 싱글톤빈임
	그래서 만약 빈 내부에 뭐 값을 가지고있다면 바로 동시성문제터짐
	싱글톤은 여러쓰레드에서 공유하기때문에..
	이런 동시성문제는
		싱글톤의 인스턴스필드
		static의 필드
	등에 접근할때 발생(물론 모든곳에서 접근만하면(final이면) 상관없음)
	그래서 이런건,보통 스프링은 같은로직의 실행은 한쓰레드로 몰아주기때문에,쓰레드에 값을 저장하는식으로 해결할수있는데,이걸 쓰레드로컬이라고 함
	쓰레드로컬은,해당쓰레드만 접근할수있는 저장소임
	즉 싱글톤에서 쓰레드로컬을 사용하면,하나의 인스턴스라도 각 쓰레드별로 같은이름으로 다른 변수를 사용할수있는것
	이건 java.lang.ThreadLocal에 있음
	사용은
		private ThreadLocal< String> nameStore=new ThreadLocal<>();
		nameStore.set(name);
		nameStore.get();
	이렇게 쓰면됨
	그리고 주의해야할건,무조건 이걸썼으면 마지막에
		nameStore.remove()
	로 지워줘야함(보통 필터나 인터셉터에서 지워버리면되는듯)
	쓰레드는 생성비용이 비싸서,한번생성해서 돌려쓰는데,이미 반납한거 안에 안비워두면 다른애가 그거 그대로쓰면 바로 문제터짐


3.템플릿메서드와 콜백패턴(전략패턴포함)
	템플릿메서드패턴은, 메인로직을 제외한부분을 미리 메서드로 만들어두고,중간부분에 추상메소드를 박음
	이때 해당부분을 오버라이드해야하는 추상메서드로 뽑은다음,
	템플릿메서드에서 그걸 콜하고,실제 로직에서 추상메서드를 구현하는식으로 디자인하는 패턴임
	즉
		템플릿로직
		실제로직(추상메서드)
		템플릿로직
	이런식의 메서드를 가진 추상클래스를 생성해서,실제로직에선 추상클래스의 메서드를 구현하는식임
	즉 이런식으로 공통적인 부가기능이 있다면(트랜잭션,로그등)이렇게 뽑아낼수있음(변하는것과 변하지않는것을 분리해서 모듈화)
	즉 추상클래스안에 변하는부분과 변하지않는부분을 나눠서 메서드를 만들고,그걸 상속받아서 변하는부분만 구현하는식임
	실제로 사용할땐
	    AbstractTemplate template1=new SubClassLogic1();
        template1.execute();
	이런식으로 템플릿부분만 실행하면되고(변하는부분은 상속받아서 구현해뒀을테니)
	바꿀때도 묶어서 변경할수있음(케이스따라 오히려 강결합이라고 느껴질때도 잇긴하겟지만)
	
	이 템플릿메서드패턴의 단점은,클래스를 계속 만들어야한다는것,이건 익명내부클래스로 보완할수있음
	익명내부클래스를 사용하면,객체인스턴스를 생성하면서 동시에 생성할 클래스를 상속받은 자식클래스를 정의할수있음(한마디로 new쓰면서 만드는거)
        AbstractTemplate template2=new AbstractTemplate() {
            @Override
            protected void call() {
                log.info("익명내부2번");
            }
        };
	그거맞음 2학년떄본거
	
	좋은설계는,변경이 일어났을때 자연스럽게 보이게됨,이런식으로 템플릿메서드를 사용해서 단일책임원칙을 지키게 할수있어진거
	그래서 하나의변경으로 모든코드에서 수정이 가능해지게됨
	
	템플릿메서드는,추상클래스로 알고리즘의 골격을 정의하고,일부단계를 하위(상속받는)단계로 연기해서,알고리즘의 구조를 바꾸지않고 특정부분을 재정의할수있어짐
	즉 상속과 다형성으로 문제를 해결하는것
	단,상속을 사용하기때문에 상속의 단점을 그대로 들고감(강결합,사용하든말든 컴파일시점에 자식클래스에 부모클래스의 모든 코드가 적히는것)
	특히 자식클래스는 부모클래스의 기능을 전혀 사용하지않는데,단지 패턴을위해 부모클래스를 상속받아야함
	
	그래서 이런 비슷한역할을 하면서,상속의 단점을 제거하는게 스트레티지(전략)패턴임(상속보다 위임)




















