1.예제생성
	로그에서 시작시간을 알면 종료시간도 알수있음(둘뺴면되니까)
	
	쌩으로 로그찍을때는,하단에서 예외가 터지면,그대로 뒤에꺼가 다 무시되니 트라이캐치로 싸서 파이널리에 넣어두거나 트라이랑 캐치 각각넣어둬야함
	그리고 로그가 어플리케이션의 흐름을 바꾸면안되니,캐치에선 무조건 다시 같은예외를 던져야함
	
	필요없는건 다스킵

2.쓰레드로컬
	기본적으로 빈등록하면 따로 뭐 안해주면 싱글톤빈임
	그래서 만약 빈 내부에 뭐 값을 가지고있다면 바로 동시성문제터짐
	싱글톤은 여러쓰레드에서 공유하기때문에..
	이런 동시성문제는
		싱글톤의 인스턴스필드
		static의 필드
	등에 접근할때 발생(물론 모든곳에서 접근만하면(final이면) 상관없음)
	그래서 이런건,보통 스프링은 같은로직의 실행은 한쓰레드로 몰아주기때문에,쓰레드에 값을 저장하는식으로 해결할수있는데,이걸 쓰레드로컬이라고 함
	쓰레드로컬은,해당쓰레드만 접근할수있는 저장소임
	즉 싱글톤에서 쓰레드로컬을 사용하면,하나의 인스턴스라도 각 쓰레드별로 같은이름으로 다른 변수를 사용할수있는것
	이건 java.lang.ThreadLocal에 있음
	사용은
		private ThreadLocal< String> nameStore=new ThreadLocal<>();
		nameStore.set(name);
		nameStore.get();
	이렇게 쓰면됨
	그리고 주의해야할건,무조건 이걸썼으면 마지막에
		nameStore.remove()
	로 지워줘야함(보통 필터나 인터셉터에서 지워버리면되는듯)
	쓰레드는 생성비용이 비싸서,한번생성해서 돌려쓰는데,이미 반납한거 안에 안비워두면 다른애가 그거 그대로쓰면 바로 문제터짐


3.템플릿메서드와 콜백패턴(전략패턴포함)
	템플릿메서드패턴은, 메인로직을 제외한부분을 미리 메서드로 만들어두고,중간부분에 추상메소드를 박음
	이때 해당부분을 오버라이드해야하는 추상메서드로 뽑은다음,
	템플릿메서드에서 그걸 콜하고,실제 로직에서 추상메서드를 구현하는식으로 디자인하는 패턴임
	즉
		템플릿로직
		실제로직(추상메서드)
		템플릿로직
	이런식의 메서드를 가진 추상클래스를 생성해서,실제로직에선 추상클래스의 메서드를 구현하는식임
	즉 이런식으로 공통적인 부가기능이 있다면(트랜잭션,로그등)이렇게 뽑아낼수있음(변하는것과 변하지않는것을 분리해서 모듈화)
	즉 추상클래스안에 변하는부분과 변하지않는부분을 나눠서 메서드를 만들고,그걸 상속받아서 변하는부분만 구현하는식임
	실제로 사용할땐
	    AbstractTemplate template1=new SubClassLogic1();
        template1.execute();
	이런식으로 템플릿부분만 실행하면되고(변하는부분은 상속받아서 구현해뒀을테니)
	바꿀때도 묶어서 변경할수있음(케이스따라 오히려 강결합이라고 느껴질때도 잇긴하겟지만)
	
	이 템플릿메서드패턴의 단점은,클래스를 계속 만들어야한다는것,이건 익명내부클래스로 보완할수있음
	익명내부클래스를 사용하면,객체인스턴스를 생성하면서 동시에 생성할 클래스를 상속받은 자식클래스를 정의할수있음(한마디로 new쓰면서 만드는거)
        AbstractTemplate template2=new AbstractTemplate() {
            @Override
            protected void call() {
                log.info("익명내부2번");
            }
        };
	그거맞음 2학년떄본거
	
	좋은설계는,변경이 일어났을때 자연스럽게 보이게됨,이런식으로 템플릿메서드를 사용해서 단일책임원칙을 지키게 할수있어진거
	그래서 하나의변경으로 모든코드에서 수정이 가능해지게됨
	
	템플릿메서드는,추상클래스로 알고리즘의 골격을 정의하고,일부단계를 하위(상속받는)단계로 연기해서,알고리즘의 구조를 바꾸지않고 특정부분을 재정의할수있어짐
	즉 상속과 다형성으로 문제를 해결하는것
	단,상속을 사용하기때문에 상속의 단점을 그대로 들고감(강결합,사용하든말든 컴파일시점에 자식클래스에 부모클래스의 모든 코드가 적히는것)
	특히 자식클래스는 부모클래스의 기능을 전혀 사용하지않는데,단지 패턴을위해 부모클래스를 상속받아야함
	
	그래서 이런 비슷한역할을 하면서,상속의 단점을 제거하는게 스트레티지(전략)패턴임(상속보다 위임)
	전략패턴은,변하지않는부분을 컨텍스트에 두고,변하는부분을 인터페이스를 만들고,해당인터페이스를 구현하게해서 문제를 해결함
	즉 상속이 아닌,위임으로 문제를 해결하는것
	즉,context가 템플릿역할,인터페이스가 call같은 변하는 알고리즘역할을 함(사실상 템플릿메서드랑 거의똑같음)
	
	이건,그냥 인터페이스를 만들고,그 인터페이스를 컨텍스트클래스에서 di받아와서,
	템플릿부분에 그 인터페이스의 call을 호출하면됨(사실 상속안쓴다는거말곤 똑같은느낌)
	이 전략패턴의 핵심은,컨텍스트(템플릿)는 strategy인터페이스에만 의존한다는것,
	그래서 구현체를 변경하거나 새로만들어도 컨텍스트에선 영향을 받지않고,구현체도 인터페이스에 변경만 없으면 컨텍스트의 영향을 받지않음
	
	스프링에서 di에 사용하는 방식이 이 전략패턴임
	
	전략패턴도 익명내부클래스를 사용할수있음
        Strategy strategyLogic1 = new Strategy() {
            @Override
            public void call() {
                log.info("비즈니스로직1 실행");
            }
        };
        ContextV1 context1 = new ContextV1(strategyLogic1);
        context1.execute();
	그냥똑같음(인터페이스를 인코드로 구현하는거니까)
	아예 람다식으로 박아도됨(구현해야할 대상메서드가 하나일경우,따로표시안해도 알아서 거기에 박음)
	    ContextV1 context1 = new ContextV1(() -> log.info("비즈니스로직1 실행"));
        context1.execute();
	이렇게
	
	이런식으로 하는게 선조립 후실행(컨텍스트의 내부필드에 인터페이스를 두고 di받는)방식임
	실행하기전에 미리 조립(di받는거)해두고,그 뒤에 사용하는것(어플리케이션 로딩시점에 다 끝내놓고 사용만하는느낌)
	그래서 실행이 편하다는게 장점임(그냥 execute만 실행하면되니까)
	이거의 단점은,한번 조립한 후에는 전략의 변경(인터페이스구현체의 변경)이 번거로움
	세터를 사용해서 변경해도되지만,싱글톤으로 사용하면 동시성이슈등 고려해야할게 많아짐(변경하고있는데 이미사용하고있거나)
	
	그래서 아예,필드에 넣고 di받는게 아닌,파라미터로 전략을 받아서 실행시키는,
	즉 한번실행할때마다 실행자가 직접 전략을 가져오는 방식으로 쓸수도있음
		public void execute(Strategy strategy){...}
	이렇게 걍 파라미터로 받는거임,즉 실행이 좀 더 귀찮아진 대신 변경이 편해짐(그냥 옆그레이드라고 보면됨 상황따라고르는)
        ContextV2 context = new ContextV2();
        context.execute(new StrategyLogic1());
	이렇게 실행하면됨(아예 람다식으로 넣어도될거고)
        ContextV2 context = new ContextV2();
        context.execute(()->log.info("abc"));
	이렇게
	이렇게하면 컨텍스트를 실행할때마다 전략을 인수로 받음
	그래서 좀 더 유연하게 원하는전략을 변경할수있음
	단점으론 쓸때마다 전략을 계속 지정해줘야한다는거(실행이 귀찮아짐)
	
	그래서,그냥 템플릿을 쓰고싶으면(로그넣는다던가) 실행시에 전략넣는게좋고,여러개중 하나를 끝까지쓸거면 di받는게 나음(일단 이게 정석이긴함)
	디자인패턴에서 중요한건,의도임
	의도만 구현하면 다 같은패턴임
	
	이렇게 파라미터로 전략을 넘기는패턴을,스프링에선 템플릿콜백패턴이라고 부름(gof패턴은 아님)
	그래서 xxxTemplate라는게 있으면 다 템플릿콜백으로 만들어졌다고봐도됨
	콜백은 다른코드로 넘기는 실행가능한 코드조각을 말함
	
	즉,콜백은 코드가 콜은 되는데,넘겨준곳의 뒤(백)에서 실행된다고 보면됨
	자바에서 실행가능한 코드를 인수로 넘길땐 객체가 필요하고,자바8부터는 람다를 사용할수있음
	이렇게 콜백쓸땐 람다쓰는게 편하고,만약 여러곳에서 똑같이 쓰는거있으면 별도의 클래스로 뽑아도되고


4.프록시패턴과 데코레이터 패턴
	스프링에선 @Controller이나 @RestController이 어노테이션이 있어야 해당 클래스를 컨트롤러로 인식하고,그래야 http url매핑이 동작함
	그래서 인터페이스에 이걸 박아둬야함(인터페이스를 사용할거면)
	그리고 인터페이스에선 @RequestParam을 넣어줘야 정상적으로 파라미터매핑해줌
	
	객체에서 요청하는객체는 클라,요청을 처리하는객체는 서버가 됨
	이때,클라가 서버를 직접 호출하고,결과를 직접 받으면 이건 직접호출임
	근데,클라가 요청을 다른 대리자를 통해서 간접적으로 요청할수있는데,이걸 프록시라고 함
	이때 프록시를 사용하면,여러 추가적인 일을 할수있음
		접근제어,캐싱(이미있는거는 바로반납)
		부가기능추가(로깅추가)
		프록시체인(프록시를 체인타고 갈수있음,이건 그렇게안중요함)
	이런 이점이 있음
	근데 객체에서는,중요한게 같은 인터페이스를 사용해야(프록시와 실제객체가),클라가 프록시에 요청했는지 서버에게 요청했는지 까지 감출수있음
	그래서,서버와 프록시는,서버를 프록시로 바꿔도  클라코드를 변경하지않고 동작할수있어야하고(di로),그러니 같은인터페이스를 사용해야함
	즉 클라는 인터페이스에만 의존함,그러니 di를 통해 대체할수있음
	
	이때 프록시는 의도에 따라 2가지 패턴으로 분류됨(프록시랑 프록시패턴은 다름)
		접근제어(프록시패턴)
			캐싱
			권한에따른 접근차단
			지연로딩(jpa그 콜해야 호출하는 그런거)
		부가기능추가(데코레이터패턴)
			원래서버기능에 더해 부가기능수행(로그추가,응답값변형)
	이렇게 나눠짐
	이렇게 둘다 프록시를 사용하지만,의도에따라 구분됨(생긴거도 거의똑같음)
	그리고 프록시라는 개념은,클라와 서버라는 개념이 있는 모든곳(객체,서버등)에서 같은느낌으로 구현할수있음 규모차이만 있을뿐
	
	보통 프록시패턴을 사용하면,클라는 프록시를 의존하고(인터페이스로 di받으니 좀 틀리긴하지만),프록시는 실제객체를 의존하는 그림이 나옴
	그래서 프록시패턴의 핵심은,구현체와 클라이언트코드를 전혀 변경하지않고,di만을 활용해서 접근제어를 하는거임









