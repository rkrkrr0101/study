1.예제생성
	로그에서 시작시간을 알면 종료시간도 알수있음(둘뺴면되니까)
	
	쌩으로 로그찍을때는,하단에서 예외가 터지면,그대로 뒤에꺼가 다 무시되니 트라이캐치로 싸서 파이널리에 넣어두거나 트라이랑 캐치 각각넣어둬야함
	그리고 로그가 어플리케이션의 흐름을 바꾸면안되니,캐치에선 무조건 다시 같은예외를 던져야함
	
	필요없는건 다스킵

2.쓰레드로컬
	기본적으로 빈등록하면 따로 뭐 안해주면 싱글톤빈임
	그래서 만약 빈 내부에 뭐 값을 가지고있다면 바로 동시성문제터짐
	싱글톤은 여러쓰레드에서 공유하기때문에..
	이런 동시성문제는
		싱글톤의 인스턴스필드
		static의 필드
	등에 접근할때 발생(물론 모든곳에서 접근만하면(final이면) 상관없음)
	그래서 이런건,보통 스프링은 같은로직의 실행은 한쓰레드로 몰아주기때문에,쓰레드에 값을 저장하는식으로 해결할수있는데,이걸 쓰레드로컬이라고 함
	쓰레드로컬은,해당쓰레드만 접근할수있는 저장소임
	즉 싱글톤에서 쓰레드로컬을 사용하면,하나의 인스턴스라도 각 쓰레드별로 같은이름으로 다른 변수를 사용할수있는것
	이건 java.lang.ThreadLocal에 있음
	사용은
		private ThreadLocal< String> nameStore=new ThreadLocal<>();
		nameStore.set(name);
		nameStore.get();
	이렇게 쓰면됨
	그리고 주의해야할건,무조건 이걸썼으면 마지막에
		nameStore.remove()
	로 지워줘야함(보통 필터나 인터셉터에서 지워버리면되는듯)
	쓰레드는 생성비용이 비싸서,한번생성해서 돌려쓰는데,이미 반납한거 안에 안비워두면 다른애가 그거 그대로쓰면 바로 문제터짐


3.템플릿메서드와 콜백패턴(전략패턴포함)
	템플릿메서드패턴은, 메인로직을 제외한부분을 미리 메서드로 만들어두고,중간부분에 추상메소드를 박음
	이때 해당부분을 오버라이드해야하는 추상메서드로 뽑은다음,
	템플릿메서드에서 그걸 콜하고,실제 로직에서 추상메서드를 구현하는식으로 디자인하는 패턴임
	즉
		템플릿로직
		실제로직(추상메서드)
		템플릿로직
	이런식의 메서드를 가진 추상클래스를 생성해서,실제로직에선 추상클래스의 메서드를 구현하는식임
	즉 이런식으로 공통적인 부가기능이 있다면(트랜잭션,로그등)이렇게 뽑아낼수있음(변하는것과 변하지않는것을 분리해서 모듈화)
	즉 추상클래스안에 변하는부분과 변하지않는부분을 나눠서 메서드를 만들고,그걸 상속받아서 변하는부분만 구현하는식임
	실제로 사용할땐
	    AbstractTemplate template1=new SubClassLogic1();
        template1.execute();
	이런식으로 템플릿부분만 실행하면되고(변하는부분은 상속받아서 구현해뒀을테니)
	바꿀때도 묶어서 변경할수있음(케이스따라 오히려 강결합이라고 느껴질때도 잇긴하겟지만)
	
	이 템플릿메서드패턴의 단점은,클래스를 계속 만들어야한다는것,이건 익명내부클래스로 보완할수있음
	익명내부클래스를 사용하면,객체인스턴스를 생성하면서 동시에 생성할 클래스를 상속받은 자식클래스를 정의할수있음(한마디로 new쓰면서 만드는거)
        AbstractTemplate template2=new AbstractTemplate() {
            @Override
            protected void call() {
                log.info("익명내부2번");
            }
        };
	그거맞음 2학년떄본거
	
	좋은설계는,변경이 일어났을때 자연스럽게 보이게됨,이런식으로 템플릿메서드를 사용해서 단일책임원칙을 지키게 할수있어진거
	그래서 하나의변경으로 모든코드에서 수정이 가능해지게됨
	
	템플릿메서드는,추상클래스로 알고리즘의 골격을 정의하고,일부단계를 하위(상속받는)단계로 연기해서,알고리즘의 구조를 바꾸지않고 특정부분을 재정의할수있어짐
	즉 상속과 다형성으로 문제를 해결하는것
	단,상속을 사용하기때문에 상속의 단점을 그대로 들고감(강결합,사용하든말든 컴파일시점에 자식클래스에 부모클래스의 모든 코드가 적히는것)
	특히 자식클래스는 부모클래스의 기능을 전혀 사용하지않는데,단지 패턴을위해 부모클래스를 상속받아야함
	
	그래서 이런 비슷한역할을 하면서,상속의 단점을 제거하는게 스트레티지(전략)패턴임(상속보다 위임)
	전략패턴은,변하지않는부분을 컨텍스트에 두고,변하는부분을 인터페이스를 만들고,해당인터페이스를 구현하게해서 문제를 해결함
	즉 상속이 아닌,위임으로 문제를 해결하는것
	즉,context가 템플릿역할,인터페이스가 call같은 변하는 알고리즘역할을 함(사실상 템플릿메서드랑 거의똑같음)
	
	이건,그냥 인터페이스를 만들고,그 인터페이스를 컨텍스트클래스에서 di받아와서,
	템플릿부분에 그 인터페이스의 call을 호출하면됨(사실 상속안쓴다는거말곤 똑같은느낌)
	이 전략패턴의 핵심은,컨텍스트(템플릿)는 strategy인터페이스에만 의존한다는것,
	그래서 구현체를 변경하거나 새로만들어도 컨텍스트에선 영향을 받지않고,구현체도 인터페이스에 변경만 없으면 컨텍스트의 영향을 받지않음
	
	스프링에서 di에 사용하는 방식이 이 전략패턴임
	
	전략패턴도 익명내부클래스를 사용할수있음
        Strategy strategyLogic1 = new Strategy() {
            @Override
            public void call() {
                log.info("비즈니스로직1 실행");
            }
        };
        ContextV1 context1 = new ContextV1(strategyLogic1);
        context1.execute();
	그냥똑같음(인터페이스를 인코드로 구현하는거니까)
	아예 람다식으로 박아도됨(구현해야할 대상메서드가 하나일경우,따로표시안해도 알아서 거기에 박음)
	    ContextV1 context1 = new ContextV1(() -> log.info("비즈니스로직1 실행"));
        context1.execute();
	이렇게
	
	이런식으로 하는게 선조립 후실행(컨텍스트의 내부필드에 인터페이스를 두고 di받는)방식임
	실행하기전에 미리 조립(di받는거)해두고,그 뒤에 사용하는것(어플리케이션 로딩시점에 다 끝내놓고 사용만하는느낌)
	그래서 실행이 편하다는게 장점임(그냥 execute만 실행하면되니까)
	이거의 단점은,한번 조립한 후에는 전략의 변경(인터페이스구현체의 변경)이 번거로움
	세터를 사용해서 변경해도되지만,싱글톤으로 사용하면 동시성이슈등 고려해야할게 많아짐(변경하고있는데 이미사용하고있거나)
	
	그래서 아예,필드에 넣고 di받는게 아닌,파라미터로 전략을 받아서 실행시키는,
	즉 한번실행할때마다 실행자가 직접 전략을 가져오는 방식으로 쓸수도있음
		public void execute(Strategy strategy){...}
	이렇게 걍 파라미터로 받는거임,즉 실행이 좀 더 귀찮아진 대신 변경이 편해짐(그냥 옆그레이드라고 보면됨 상황따라고르는)
        ContextV2 context = new ContextV2();
        context.execute(new StrategyLogic1());
	이렇게 실행하면됨(아예 람다식으로 넣어도될거고)
        ContextV2 context = new ContextV2();
        context.execute(()->log.info("abc"));
	이렇게
	이렇게하면 컨텍스트를 실행할때마다 전략을 인수로 받음
	그래서 좀 더 유연하게 원하는전략을 변경할수있음
	단점으론 쓸때마다 전략을 계속 지정해줘야한다는거(실행이 귀찮아짐)
	
	그래서,그냥 템플릿을 쓰고싶으면(로그넣는다던가) 실행시에 전략넣는게좋고,여러개중 하나를 끝까지쓸거면 di받는게 나음(일단 이게 정석이긴함)
	디자인패턴에서 중요한건,의도임
	의도만 구현하면 다 같은패턴임
	
	이렇게 파라미터로 전략을 넘기는패턴을,스프링에선 템플릿콜백패턴이라고 부름(gof패턴은 아님)
	그래서 xxxTemplate라는게 있으면 다 템플릿콜백으로 만들어졌다고봐도됨
	콜백은 다른코드로 넘기는 실행가능한 코드조각을 말함
	
	즉,콜백은 코드가 콜은 되는데,넘겨준곳의 뒤(백)에서 실행된다고 보면됨
	자바에서 실행가능한 코드를 인수로 넘길땐 객체가 필요하고,자바8부터는 람다를 사용할수있음
	이렇게 콜백쓸땐 람다쓰는게 편하고,만약 여러곳에서 똑같이 쓰는거있으면 별도의 클래스로 뽑아도되고


4.프록시패턴과 데코레이터 패턴
	스프링에선 @Controller이나 @RestController이 어노테이션이 있어야 해당 클래스를 컨트롤러로 인식하고,그래야 http url매핑이 동작함
	그래서 인터페이스에 이걸 박아둬야함(인터페이스를 사용할거면)
	그리고 인터페이스에선 @RequestParam을 넣어줘야 정상적으로 파라미터매핑해줌
	
	객체에서 요청하는객체는 클라,요청을 처리하는객체는 서버가 됨
	이때,클라가 서버를 직접 호출하고,결과를 직접 받으면 이건 직접호출임
	근데,클라가 요청을 다른 대리자를 통해서 간접적으로 요청할수있는데,이걸 프록시라고 함
	이때 프록시를 사용하면,여러 추가적인 일을 할수있음
		접근제어,캐싱(이미있는거는 바로반납)
		부가기능추가(로깅추가)
		프록시체인(프록시를 체인타고 갈수있음,이건 그렇게안중요함)
	이런 이점이 있음
	근데 객체에서는,중요한게 같은 인터페이스를 사용해야(프록시와 실제객체가),클라가 프록시에 요청했는지 서버에게 요청했는지 까지 감출수있음
	그래서,서버와 프록시는,서버를 프록시로 바꿔도  클라코드를 변경하지않고 동작할수있어야하고(di로),그러니 같은인터페이스를 사용해야함
	즉 클라는 인터페이스에만 의존함,그러니 di를 통해 대체할수있음
	
	이때 프록시는 의도에 따라 2가지 패턴으로 분류됨(프록시랑 프록시패턴은 다름)
		접근제어(프록시패턴)
			캐싱
			권한에따른 접근차단
			지연로딩(jpa그 콜해야 호출하는 그런거)
		부가기능추가(데코레이터패턴)
			원래서버기능에 더해 부가기능수행(로그추가,응답값변형)
	이렇게 나눠짐
	이렇게 둘다 프록시를 사용하지만,의도에따라 구분됨(생긴거도 거의똑같음)
	그리고 프록시라는 개념은,클라와 서버라는 개념이 있는 모든곳(객체,서버등)에서 같은느낌으로 구현할수있음 규모차이만 있을뿐
	
	보통 프록시패턴을 사용하면,클라는 프록시를 의존하고(인터페이스로 di받으니 좀 틀리긴하지만),프록시는 실제객체를 의존하는 그림이 나옴
	그래서 프록시패턴의 핵심은,구현체와 클라이언트코드를 전혀 변경하지않고,di만을 활용해서 접근제어를 하는거임
	
	데코레이터패턴은,프록시를 사용해서 부가기능을 추가하는 패턴임
	즉 이거도 프록시패턴이랑 생긴건똑같은데,하는일만 좀 다름
	데코레이터는 계속 체인을 탈수있는데,이러면 계속 부가기능을 추가하는것(각 데코레이터 하나마다 기능하나씩넣는게 단일책임원칙에 좋으니)
	
	여기서 데코레이터에서 실제객체를 받을 필드를 만들고,생성자를 받는거에 계속 중복이 일어나기도 하고,실제객체랑 데코레이터를 구분하기위해 사용되는게
	데코레이터용 추상클래스임(실제객체를 받을 필드를 속성으로 가지고있는)
	이거까지 있는게 gof에서의 데코레이터임
	
	이렇게 인터페이스가 있으면 편하게 넣을수있음
	스프링에서도 인터페이스가 있으면,그냥 인터페이스 구현하고,매개변수로 그걸 집어넣은 프록시를 메인빈으로 설정한 설정파일을 넣으면됨
	이때 중요한건,di받을때 무조건 프록시를 호출해야함
		@Bean
		public OrderServiceV1 orderService(LogTrace logTrace){
			OrderServiceV1Impl serviceImpl=new OrderServiceV1Impl(orderRepository(logTrace));
			return new OrderServiceInterfaceProxy(serviceImpl,logTrace);
		}
		@Bean
		public OrderRepositoryV1 orderRepository(LogTrace logTrace) {
			OrderRepositoryV1Impl repoImpl=new OrderRepositoryV1Impl();
			return new OrderRepositoryInterfaceProxy( repoImpl,logTrace);
		}
	이렇게 등록된 프록시를 호출해야함
	즉 프록시만 등록하고,실제객체는 등록하면 안됨
	어짜피 이래도 싱글톤이니까 실제객체도 하나만 생성돼서(정확히는 생성을 한번만 거쳐서)상관없음
	이렇게되면 실제객체는 스프링이 관리하지않지만,어짜피 프록시를 통해서만 접근할거니까 상관없어지는거
	
	그리고 인터페이스가 없는,구체클래스만 있는곳에 프록시를 적용할때는 클래스기반 프록시를 적용할수있음
	자바는 인터페이스를 구현하든,클래스를 상속하든 상위타입만 맞으면되니까(다형성),구현클래스를 상속받아서 프록시를 만들겠다는것
		public class TimeProxy extends ConcreteLogic{}
	이렇게 상속받고 실제클래스 di받아서 해당메서드 오버라이드한다음
		프록시에서할일
		String result = concreteLogic.operation();
		프록시에서할일
		return result;
	이런식으로 똑같이 하면됨,구현대신 오버라이드하는것
	그리고 똑같이
	    ConcreteLogic concreteLogic = new ConcreteLogic();
        TimeProxy timeProxy=new TimeProxy(concreteLogic);
        ConcreteClient client = new ConcreteClient(timeProxy);
	이렇게 집어넣어버리면됨(어짜피 상속받았으니 부모자리에 대신들어갈수있으니까)
	
	그리고 이때 해당부모클래스가 생성자가 있어서, 부모클래스를 호출해야하면(super()),어짜피 프록시에선 아무것도 안할거니까
		super(null)
	하면됨
	이렇게 클래스기반프록시는 이런 귀찮은게 좀있음
		super(null)을 쓰거나 부모클래스에서 기본생성자가 있어야함
		클래스에 final이 붙으면 상속이 불가능
		메서드에 final이 붙으면 오버라이딩이 불가능
	그래서 인터페이스가 사용하기 더 편한데,인터페이스의 단점은 인터페이스를 일단 만들어야한다는것(캐스팅관련해서도 문제가 하나 더 있긴함)
	
	실무에선 이 두상황이 둘다 사용되기때문에,둘다 알고있어야함
	
	근데 이렇게만들면,기존코드를 안건드려도되긴하는데,어짜피 하는일은 똑같은데,대상클래스마다 하나씩 프록시 클래스를 만들어야함(클래스100개면 100개)
	이걸 클래스 하나로 다 땜빵치는게 동적프록시임




5.동적프록시
	자바에서 기본으로 제공하는 jdk동적프록시나,cglib같은 프록시생성 오픈소스(바이트코드변경)를 사용해서 프록시 객체를 동적으로 찍어낼수있음
	근데 기본적으로 코드짤땐 불안정성이 높아서 잘 사용되지않고,다른사람들이 프레임워크같은거로 만들어둔걸 가져다쓰게되지만,어떻게 동작하는지 알고는 있어야함
	
	이 jdk동적프록시를 이해하려면,자바의 리플렉션을 이해해야함
	기본적으로 다똑같고 중간에 호출하는 메서드가 다르면 밖으로 뽑기 빡센데,이부분을 동적으로 처리하는게 리플렉션임(람다로 처리할수있긴함)
	이건 클래스나 메서드의 메타정보를 사용해서 동적으로 호출하는것
        Class classHello = Class.forName("hello.proxy.jdkdynamic.ReflectionTest$Hello");

        Hello target=new Hello();
        Method methodCallA = classHello.getMethod("callA");
        Object res1 = methodCallA.invoke(target);
        log.info("res1={}",res1);
	이런식으로 무슨메서드를 호출할지를 스트링으로 받아서 호출하는거임,이러면 걍 텍스트 파라미터로 받을수있으니 동적지정이 가능해짐(한번 추상화가 된느낌)
	즉
	    private void dynamicCall(Method method,Object target) throws Exception {
			log.info("start");
			Object res1 = method.invoke(target);
			log.info("result={}",res1);
		}
	이런식으로 해당클래스와 호출할메서드를 받아서 돌리면되는거
	즉 클래스나 메서드를 추상화해서 메타정보 바꿔치기로 공통화하는거임
	단,이건 런타임에 동작해서(스트링쓰니까) 컴파일오류가 나지않고,무조건 실행시켜서 에러를 찾아야해서(런타임오류),가급적이면 사용하지않는게 좋음
	보통 프레임워크만들때나,매우 일반적인 공통처리가 필요할떄,부분적으로 주의해서 사용해야함(막 프록시클래스를 1000개만들어야한다 이러면 사용할수있긴함)
	
	동적프록시를 사용하면,런타임에 개발자대신 프록시객체를 만들어주고,원하는 실행 로직을 지정할수 있음
	그리고 jdk동적프록시는,인터페이스 기반이라서 인터페이스가 필수임
	이건 InvodationHandler인터페이스를 구현해서 작성하면되는데,제공되는 파라미터는
		Object proxy  프록시 자신
		Method method 호출한 메서드
		Object[] args 메서드 호출할때 전달한 인수
	이 3개를 받을수있음
	그리고 invoke를
		private final Object target; //생성자로 해당클래스 받는용도
		@Override
		public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
			log.info("타임프록시 실행");
			long startTime = System.currentTimeMillis();
			
			Object invoke = method.invoke(target, args);
			
			long endTime = System.currentTimeMillis();
			long resTime=endTime-startTime;
			log.info("resTime={}",resTime);
			return invoke;
		}
	이런식으로 구현하면됨
	사용은
	    AInterface targe1t=new AImpl();
        TimeInvocationHandler handler1 = new TimeInvocationHandler(target1);
        AInterface proxy1 =(AInterface) Proxy.newProxyInstance(AInterface.class.getClassLoader(),
                new Class[]{AInterface.class}, handler1);
        proxy1.call();
		
		BInterface target2=new BImpl();
		TimeInvocationHandler handler2 = new TimeInvocationHandler(target2);
        BInterface proxy2 =(BInterface) Proxy.newProxyInstance(BInterface.class.getClassLoader(),
                new Class[]{BInterface.class}, handler2);
        proxy2.call();
	이런식으로 핸들러를 만들어서 구현체를 넣고,인터페이스기반으로 프록시를 생성함
	이렇게 TimeInvocationHandler라는 핸들러 하나만 가지고,저안에 있는 로직을 각 구현체마다 바로 적용하고,걔는 또 그대로 할일하는거
	
	좀더 자세하게는,수동으로 프록시클래스 만드는거랑 런타임에서 만들어진 클래스 결과는 똑같은데,
	어짜피 각 프록시클래스마다 구현체메서드콜을 제외한 나머지가 다 똑같으니,
	그걸 한군데다 모으고 클래스레벨이 아닌 코드레벨에서 프록기기반코드(핸들러)를 기반으로 즉석에서 동적으로 프록시클래스를 만들어서 사용하겠다!라는 컨셉인거임
	
	즉 이렇게 즉석으로 인터페이스기반 동적프록시를 생성하고,그 결과를 반환할수있음
	이렇게하면 프록시를 여러개안만들어도되고,부가기능로직도 한군데에 몰아서 단일책임원칙도 지킬수있게됨
	
	그리고 method에서는
		String message = method.getDeclaringClass().getSimpleName() + "." + method.getName() + "()";
	이렇게 클래스이름과 호출한메서드이름도 받을수있음
	그리고 빈등록은
		@Bean
		public OrderRepositoryV1 orderRepositoryV1(LogTrace logTrace){
			OrderRepositoryV1 orderRepository = new OrderRepositoryV1Impl();

			return (OrderRepositoryV1) Proxy.newProxyInstance(OrderRepositoryV1.class.getClassLoader(),
					new Class[]{OrderRepositoryV1.class},
					new LogTraceBasicHandler(orderRepository,logTrace));
		}
	이렇게 등록하면됨(프록시로 실제객체 싸서)
	
	근데 이렇게하면,문제는 클래스단위로 전체를 싸버리기때문에,
	특정메서드는 적용하기싫을경우라도 전부 적용이 되는데,
	이것도 필터써서 특정메서드는 지나가게하거나 특정메서드만 로직타게하거나 할수있음
	이건
		private final String[] patterns;
	이렇게 패턴 생성자로 받고
	    String methodName = method.getName();
        if(!PatternMatchUtils.simpleMatch(patterns,methodName)){
            return method.invoke(target,args);
        }
	invoke 최상위에 패턴에걸리면 그냥 위임하고 지나가게하면됨(PatternMatchUtils.simpleMatch()를 쓰면,쌍방향*로,*ab*==abc 이렇게 들어감)
	
	이 jdk동적프록시의 한계는,인터페이스가 꼭 있어야함
	그래서 클래스만 있는경우에 동적프록시를 적용할땐,일반적방법으론 어렵고,
	cglib(코드제너레이터라이브러리)라는 바이트코드를 조작하는 특별한 라이브러리를 써야함
	
	cglib는 외부라이브러리지만,스프링쓰면 스프링에서쓰기때문에 포함되어있음
	그리고 일반적으로 cglib를 직접 사용하는일은 거의없으니(보통 프록시펙토리사용)그냥 개념만 알고가자
	
	이건 MethodInterceptor를 구현하면됨
	여기서 받는 매개변수는
		obj cglib를 적용할 객체
		method 호출된 메서드
		args 메서드를 호출하면서 전달된 인수
		proxy 메서드호출에 사용
	이거도 동적프록시랑 코드는똑같음
	    @Override
		public Object intercept(Object obj, Method method, Object[] args, MethodProxy methodProxy) throws Throwable {
			앞로직
			Object invoke = methodProxy.invoke(target, args);
			뒷로직
			return invoke;
		}
	이렇게 똑같이쓰는데,아마 Object[]가 objects가 기본이름일텐데 저게 args라서 이름바꿨음
	그리고 method로 호출해도되는데,methodProxy쓰면 더 빠르대
	사용은
	    ConcreteService target=new ConcreteService();

        Enhancer enhancer=new Enhancer();
        enhancer.setSuperclass(target.getClass());
        enhancer.setCallback(new TimeMethodInterceptor(target));
        ConcreteService proxy =(ConcreteService) enhancer.create();
        proxy.call();
	이렇게 인헨서만들고,
	뭘로만들건지 구체클래스를 클래스타입지정해주고(상속으로 처리함),
	콜백뭐쓸건지 지정해주고(아까만든 인터셉터넣어주면됨),
	생성한다음 그거로 메서드부르면됨
	
	그리고 cglib는,클래스기반프록시라 상속을 쓰기때문에 제약이 있음
		부모클래스에서 기본생성자가 있어야함(자식클래스를 동적으로생성해야해서)
		클래스에 final이 붙으면 상속이 불가능해서 예외발생
		메서드에 final이 붙으면 오버라이딩이 불가능해서 프록시로직이 동작하지않음(예외는안뜸)
	이런것들을 처리해줘야함
	
	그래서,인터페이스가 있을땐 동적프록시를 쓰고,그렇지않으면 cglib를 적용하려고 하거나,
	아니면 둘다쓸건데 둘다만들어야하는상황이 싫거나(중복),
	특정 조건이 맞을때 프록시로직을 적용하고싶으면
	프록시팩토리를 사용하면됨
	
6.스프링이 지원하는 프록시
	프록시팩토리는,인터페이스가 있을땐 jdk동적프록시,없으면 cglib를 자동으로 선택해주고(그러니 코드는 한번만만들어도되고,설정변경가능 무조건cglib같은),
	필터기능도 지원해주는 스프링의 기능임
	맨날 스프링이 하던,추상화해서 싸주는거임
	
	이걸 사용할땐,advice(MethodInterceptor,얘가 어드바이스를 상속받고있음)를 구현하면 알아서 스프링이 조건맞춰서 선택해주고,
	필터는 pointcut으로 일관성있게 해결할수있음
	
	즉 프록시생성은 프록시팩토리로 알아서해주고,우리는 어드바이스만 구현하면 알아서 인터페이스 깡클래스 상관없이 알아서 선택하고,
	포인트컷으로 필터를 적용할수있음
	
	MethodInterceptor안에 MethodInvocation이 있는데,여기안에 현재프록시객체,args,메서드정보등이 전부 다 들어있음
	그래서 따로 타겟받을필요도없음,이미 프록시팩토리만들때 타겟을 넘겨야하고,그걸 저안에 넣어뒀기때문
	이때 org.aopalliance.intercept.MethodInterceptor를 받아서
		앞로직
		Object invoke = invocation.proceed();
		뒷로직
		return invoke;
	이렇게 실행시키면됨(그냥 args랑 타겟이랑 메서드명이랑 다 invocation이 가지고있으니까 그거 바로실행시키는메서드임)
	
	사용은
	    ServiceInterface target=new ServiceImpl();
        ProxyFactory proxyFactory = new ProxyFactory(target);
        proxyFactory.addAdvice(new TimeAdvice());
        ServiceInterface proxy =(ServiceInterface) proxyFactory.getProxy();
        proxy.save(); //클래스나 인터페이스의 메서드 그대로 호출하면됨
	이렇게 프록시팩토리에 타겟넣고,어드바이스(내가 추가할로직)넣고 프록시를 생성한후에 메서드호출하면됨(원래객체쓰는거랑 똑같이쓰면됨)
	그리고 프록시팩토리를쓰면,
		AopUtils.isAopProxy(proxy)
	이렇게 프록시가 적용됐는지도 확인할수있고,
		AopUtils.isJdkDynamicProxy(proxy)
		AopUtils.isCglibProxy(proxy)
	jdk동적프록시인지 cglib프록시인지도 알수있음(이 3개는,프록시팩토리를 써서 생성했어야만 알수있음)
	그리고 무조건 cglib로 만들고싶으면
		proxyFactory.setProxyTargetClass(true);
	추가해서 프록시생성하면됨(나름 쓸일이 있다고함,특히 aop쓰면 스프링이 무조건 이거 켜두고 만들어서,무조건 cglib기반임)
	
	포인트컷은 어디에 부가기능을 적용할지 적용하지않을지 판단하는 필터링 로직임,클래스와 메서드이름으로 필터링함
	어드바이스는 프록시가 호출하는 부가기능,단순하게 프록시로직이라고 생각하면됨
	어드바이저는 하나의 포인트컷과 하나의 어드바이스를 합쳐둔거
	
	즉 포인트컷으로 어디적용할지를 선택하고,어드바이스가 적용할 로직,어드바이저는 이 둘을 합쳐둔거
	이렇게 필터와 로직을 분리해서,단일책임원칙을 지킬수있음
	
	작동로직은,일던 포인트컷을 들러서 여기가 맞나 if문으로 체크하고,맞으면 어드바이스실행후 타겟로직실행,아니면 그냥 바로 타겟로직실행하는식
		메서드호출-프록시.포인트컷에서 대상확인-대상이면 어드바이스,아니면 타겟인스턴스호출
	이 어드바이저는
        DefaultPointcutAdvisor advisor = new DefaultPointcutAdvisor(Pointcut.TRUE, new TimeAdvice());
        proxyFactory.addAdvisor(advisor);
	이렇게 만들어서 넣으면됨(Pointcut.TRUE는 항상 참인,즉 모든곳에 어드바이스를 적용하는거)
	프록시팩토리에 어드바이저는 필수인데,만약 addAdvice로 넣어도,안에서 포인트컷 true로 해서 어드바이저를 생성해서 넣음

	포인트컷은,기본적으로 스프링이 만들어주는걸 보통 사용하는데,직접 만들수도 있긴함
	직접구현할땐 classFilter과 MethodMatcher을 둘 다 구현하고,pointcut으로 싸면됨
	이게 둘다 true를 반환해야 어드바이스를 적용하는거
	어짜피 만들일없는데 대충보고넘어가자
	
	스프링에서는 포인트컷을 대부분 제공함
	 가장 쉬운건 NameMatchMethodPointCut임,이름그대로 이름매칭으로 적용하는거
	    NameMatchMethodPointcut pointcut = new NameMatchMethodPointcut();
        pointcut.setMappedNames("save");
        DefaultPointcutAdvisor advisor = new DefaultPointcutAdvisor(pointcut, new TimeAdvice());
	이런식으로 사용하면됨
	보통 많이쓰는건 AspectJExpressionPointCut임,이건 aspectJ표현식으로 사용하게됨,이거만 사용한다고보면됨
	이건 나중에 나올예정
	
	그리고 하나의 타겟에 여러 어드바이스를 적용하려면,
	가장쉬운방법은 프록시를 여러개만들어서 프록시체인을 거는건데,이건 프록시를 여러번 생성해야하는문제가 있음(각 어드바이저마다 하나의프록시)
	이건 걍 프록시팩토리 2개만들고,처음은 타겟,두번째는 프록시1을 넣는거,이러면 프록시체인이 걸리니까
	
	그래서 스프링에선 하나의프록시에 여러 어드바이저를 넣을수있음
        DefaultPointcutAdvisor advisor1 = new DefaultPointcutAdvisor(Pointcut.TRUE, new Advice1());
        DefaultPointcutAdvisor advisor2 = new DefaultPointcutAdvisor(Pointcut.TRUE, new Advice2());
        proxyFactory1.addAdvisors(advisor1,advisor2);
        ServiceInterface proxy1 = (ServiceInterface)proxyFactory1.getProxy();	
	이렇게 addAdvisors넣으면됨,각 어드바이저는 각각 자기가 적용할거만 적용됨,즉 123이 있을떄 2번만 적용되거나 하는게 가능
	단,순서대로 동작하니까(프록시체인이 이순서대로걸리니까)이건 조심해서 순서맞춰야함(2번,1번,타겟,1번후,2번후 순서)
	즉 뒤에서부터 먼저 동작함 스택생각하면됨
	즉 이렇게하면 프록시는 하나만만들고 어드바이저만 여러개만들어서 하나의 프록시에 여러 어드바이저가 적용됨
	
	스프링 aop도,aop적용수만큼 프록시가 생성되는게 아닌,프록시는 하나만 만들고 거기에 여러 어드바이저를 적용함
	
	이렇게하면 일단 프록시 생성하고,어떤 부가기능을 어디에 적용할지 명확히 지정할수있게됐는데,설정이 매우귀찮고 컴포넌트스캔을 사용못한다는 단점이 있음
	이걸 해결하는게 빈 후처리기임
	
7.빈 후처리기
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	


