1.객체지향설계와 스프링
	객체지향은 유연하고 변경이 용이해야함,
	확장엔 열려있고 변경엔 닫혀있어야함
	그리고 상위객체는 하위 인터페이스에 의존해야지,하위 구현체에 의존하면안됨(의존성역전)
	이렇게 설계하면 클라이언트가 하위단의 수정에 맞춰서 수정해야하는일이 일어나지않음
	
	근데 그래봐야 인터페이스의 변경이 일어나게되면(엄청 큰 변경이 있으면) 다 뜯어고쳐야하는건 맞지만..
	그래서 설계를 잘해야한다...
	
	solid
		단일책임원칙
			변경이있을때 파급효과가 작아야함
		개방폐쇄원칙(ocp)
			확장엔 열려있고 변경엔 닫혀있어야함
			다형성을 활용해야함(인터페이스나 오버로드,오버라이드를 활용해야함)
			인터페이스를 구현한 구현체를 새로 하나 더 만드는건 ocp를 위반한게 아님
			단,클라이언트가 구현클래스를 직접 선택하는건 ocp를 위반하게됨,
			그래서 객체를 생성하고 연관관계를 맺어주는 별도의 조립,설정자가 필요하게됨(스프링이 해줌)
		리스코프치환원칙
			인터페이스를 구현한 구현체들은 인풋아웃풋을 다 지켜야함,즉 서로 바꿔치기를 해도 상관없어야함
		인터페이스 분리 원칙
			인터페이스는 큰거하나보단 잘 쪼개는게 좋다
			ex)자동차 인터페이스보단,운전,정비 인터페이스로 분리
			이러면 재사용가능성이 올라가고,다른곳에 영향을 주지않을확률이 올라가고,대체가능성이 올라가고,인터페이스가 명확해짐
		의존관계 변경 원칙(dip)
			상위객체는 하위인터페이스에 의존해야지 하위 구현체에 의존하면안된다
			이거도 클라이언트가 구현클래스를 선택하는건,
				ex)memberrepo m=new memorymemberrepo();
			dip 위반임(인터페이스와 구현체에 동시에 의존함)
			이거도 스프링이 di를 하게해서 해결할수있음
			
	다형성만으로는 ocp와 dip를 지킬수가없음
	그래서 스프링은 di를 사용해서(의존성주입),클라이언트 코드의 변경없이 기능을 확장할수있게 해줌
	그리고 이상적으로는,모든 구현체에 인터페이스가 있는게 맞음
	근데 기능을 확장할 가능성이 없으면,그냥 구현체써도되고 나중에 필요할때 인터페이스를 덮으면됨
	근데 확장할거같으면 그냥 인터페이스쓰는게 좋음
		
		
		
2.스프링 핵심원리 이해-예제만들기
	start.spring.io에서 만들고,
	설정에서 빌드-빌드도구-gradle에서 빌드,테스트 실행 인텔리제이로 변경
	이러면 빌드가 좀 더 빨라짐
	
	설계할땐,도메인 협력관계,클래스 다이어그램,객체 다이어그램을 그려두면 좀더 이해가편함
	도메인협력관계는 비개발자도 이해가편하고,클래스다이어그램은 실제 구상도라 그런거필요할때 편하고,
	객체다이어그램은 진짜 단순히 동작방향볼때편함,즉 동적으로 변하는(구현체는 바뀔수있으니)걸 전부 제거한상태
		
	컨트롤 알트 v=해당 메서드의 리턴값 받는 변수생성
	org.assertj.core.api로 Assertions 써서 테스트하면됨
		Assertions.assertThat(member).isEqualTo(findmember);
		
		
	알트insert에서 생성할때,tostring생성하면,현재 객체값전체를 리턴하는게 자동으로 나옴
		
		
3.스프링 핵심원리 이해	2-객체지향원리적용
	컨트롤 쉬프트 t = 해당메서드 테스트자동생성(껍질만 생성해줌)
	테스트에서
		@Test
		@DisplayName("vip10퍼할인")
	이렇게하면,실행시 테스트에 표시되는이름을 저거로 표시할수있음
	
	di를 사용하지않으면 구현클래스에 의존할수밖에없음(ocp,dip위반)
	순수 자바로도,외부에서 생성자를 통해 주입하는 클래스를 만들고 걔를통해서만 생성하는식으로 해결할수있긴함
		
	테스트에서 
		@BeforeEach
	테스트전에 실행
	appconfig같은거 여기다가 넣어서 di하면됨
	
	컨피그같은곳에선 역할과 역할에 따른 구현이 한눈에 보여야함
	그래서 여기서는 각 구현 하나당 하나씩 생성메서드를 만들어두고,그거 조합해서 쓰는식으로 해야함
	자기자신을 제외한 다른 new가 메서드내에 있으면안됨
	
	컨트롤 알트 m하면 해당 new 구현체를 외부 메서드로 추출할수있음
	
	di를 사용하면 구현클래스를 의존하지않으니,새로운 구현클래스를 생성해도 실행영역에서의 변경은 일어나지않음,
	appconfig같은 구성영역에서의 변경만 일어나게됨
	
	이런걸 프레임워크단에 전부 맡겨버리는걸(appconfig같은 생성영역이나 제어영역을)ioc(제어의역전)라고 하고,
	보통 이렇게 하는게많은걸 프레임워크라고 함
	즉 내가 만든 객체들은,로직을 실행하는 역할만 담당하고,다른 모든것(객체생성같은)들은 내가 안하고 다른애한테 요청함
		
	의존관계에는 정적인 클래스 의존관계와 동적인 객체 의존관계를 분리해서 생각해야함
	정적 클래스 의존관계는,실제 인터페이스를 의존하는걸 말하고
	동적 객체 의존관계는 실제 실행시점에서 실제로 생성된 객체를 의존하는 관계를 말함
	
	정적 클래스 의존관계에선 실제로 어떤 인터페이스를 구현한 객체가 실행될지 알수없음
	
	이렇게 외부에서 di를 해주는걸 ioc컨테이너,혹은 di컨테이너라고 함
	이렇게 di를 사용하면,정적 클래스 의존관계를 전혀 건드리지않고,동적 객체 의존관계를 변경할수있음(ocp,dip)
		
	appconfig의 클래스에
		@Configuration
	추가하고
	각 생성메서드마다
		@Bean
	추가
	이러면 각 생성메서드들이 스프링컨테이너에 등록되고,
	스프링을 시작할땐 퍼블릭스태틱보이드메인에서
		ApplicationContext applicationContext=new AnnotationConfigApplicationContext(AppConfig.class);
		MemberService memberService=applicationContext.getBean("memberService",MemberService.class);
	추가하면,저 안에 있는 설정정보를 가지고 di컨테이너를 만들고,해당 스트링에 맞는 메서드를 실행해서 넣어줌
		applicationContext.getBean("메서드명",메서드리턴값.class)
	그러니까 appconfig처럼 applicationContext.getBean를 통해서만 생성시키면됨 앞으로는
	그리고 일반적으로 디폴트값은 싱글톤이라,어디서해도 같은값을 줌 기본값은
	
	
	ApplicationContext가 스프링 컨테이너고,얘는 @Configuration이 붙은걸 설정정보로 사용함
	@Configuration안에서 @Bean이 붙은걸 전부 호출해서 미리 객체를 만들어두고,
	만약 getBean이 오면 그 객체의 포인터값을 리턴해줌(그래서 싱글톤이됨)
	일단 기본적으로는 이렇고,보통 @autowired 생성자로 di했던거같음
		


4.스프링 컨테이너와 스프링 빈
	빈의 이름은 기본적으로 메서드이름인데
		@Bean(name="abc2")
	이렇게 명명할수도 있음
	단,이경우엔 모든 빈 이름이 하나도 겹치는게 있어선안됨
	그래서 그냥 기본값(메소드명)으로 두고쓰는게좋음..
	
	그리고 각 메소드끼리의 의존관계가 있을경우 알아서 밑단부터 생성해서 연결함
	정확히는 일단 다 생성을 하고나서 의존관계를 엮어서 주입함(물론 자바코드로 생성하면 메서드실행시켜야하니까 바로 생성하면서 엮이긴함)
	모든빈이름 출력할땐
		String[] beanDefinitionNames = ac.getBeanDefinitionNames();
	그리고 foreach로 
	iter하고 엔터치면 foreach자동으로 생성됨
	그리고 object로 getBean받아서 출력해보면됨
	사실 쓸일많진않을듯? 
	
	만약 내가 등록한거만 보고싶으면(시스템적으로 등록한거빼고)
        String[] beanDefinitionNames = ac.getBeanDefinitionNames();
        for (String beanDefinitionName : beanDefinitionNames) {
            BeanDefinition beanDefinition=ac.getBeanDefinition(beanDefinitionName);
            if(beanDefinition.getRole()==BeanDefinition.ROLE_APPLICATION){
				...출력코드
            }

	이런식으로 if문돌리면됨
	BeanDefinition.ROLE_APPLICATION이 내가만든거,BeanDefinition.ROLE_INFRASTRUCTURE가 스프링이 자체적으로 만든거

	보통은 이렇게 다 출력할일은 없고,조회를 하게됨(getBean같은)
	만약 getbean을 했을때 대상이 없으면,NoSuchBeanDefinitionException이 나게됨
	
	그리고 getBean에서 이름없이 타입으로만 조회할수도있음
		MemberService memberService = ac.getBean( MemberService.class);
	이경우 같은타입이 여러개일땐 오류가 발생함(NoUniqueBeanDefinitionException),이경우엔 이름을 넣어줘야함
	이떄 ac.getBeansOfType으로 해당타입의 모든 이름을 리턴받아볼수있음
		Map<String, MemberRepository> beansOfType = ac.getBeansOfType(MemberRepository.class);
	그리고 인터페이스를 받아올수도있고,구체클래스를 받아올수도있음
		MemberService memberService = ac.getBean("memberService", MemberServiceImpl.class);
	같은거일경우 결과가 같음
	기본적으로 실제반환타입을 보고 조회를 하기때문에,인터페이스나 구현체나 둘다 되는거(물론 구현체적는건 의존성생기니까 당연히 안좋음)
	
	테스트코드에서 예외테스트할땐 org.junit.jupiter.api의 Assertions.assertThrows를 쓰면됨
		org.junit.jupiter.api.Assertions.assertThrows(NoSuchBeanDefinitionException.class,
		()->ac.getBean("xxxx", MemberService.class));
	이렇게 해당예외클래스와 람다식으로 해당예외를 만드는 코드를 던져주면됨

	클래스에 static를 붙인다는건,내부클래스일때 스코프를 그 안에서만 사용하겠다는소리임

	그리고 스프링빈을 조회할때,만약 상속관계인 타입이 있으면,부모타입으로 조회할경우 자식타입도 함께 조회함
	그래서 object로 조회하면 모든 빈을 조회함
	그래서 만약 자식타입이 두개이상있으면(인터페이스의 자식관계도 포함)중복예외가 발생하게됨
	그래서 이름을 붙여야함
	물론 하위타입으로 조회할수도있지만,안좋은방법임(인터페이스만 의존해야하니까)







		
		