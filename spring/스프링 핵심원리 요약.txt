1.객체지향설계와 스프링
	객체지향은 유연하고 변경이 용이해야함,
	확장엔 열려있고 변경엔 닫혀있어야함
	그리고 상위객체는 하위 인터페이스에 의존해야지,하위 구현체에 의존하면안됨(의존성역전)
	이렇게 설계하면 클라이언트가 하위단의 수정에 맞춰서 수정해야하는일이 일어나지않음
	
	근데 그래봐야 인터페이스의 변경이 일어나게되면(엄청 큰 변경이 있으면) 다 뜯어고쳐야하는건 맞지만..
	그래서 설계를 잘해야한다...
	
	solid
		단일책임원칙
			변경이있을때 파급효과가 작아야함
		개방폐쇄원칙(ocp)
			확장엔 열려있고 변경엔 닫혀있어야함
			다형성을 활용해야함(인터페이스나 오버로드,오버라이드를 활용해야함)
			인터페이스를 구현한 구현체를 새로 하나 더 만드는건 ocp를 위반한게 아님
			단,클라이언트가 구현클래스를 직접 선택하는건 ocp를 위반하게됨,
			그래서 객체를 생성하고 연관관계를 맺어주는 별도의 조립,설정자가 필요하게됨(스프링이 해줌)
		리스코프치환원칙
			인터페이스를 구현한 구현체들은 인풋아웃풋을 다 지켜야함,즉 서로 바꿔치기를 해도 상관없어야함
		인터페이스 분리 원칙
			인터페이스는 큰거하나보단 잘 쪼개는게 좋다
			ex)자동차 인터페이스보단,운전,정비 인터페이스로 분리
			이러면 재사용가능성이 올라가고,다른곳에 영향을 주지않을확률이 올라가고,대체가능성이 올라가고,인터페이스가 명확해짐
		의존관계 변경 원칙(dip)
			상위객체는 하위인터페이스에 의존해야지 하위 구현체에 의존하면안된다
			이거도 클라이언트가 구현클래스를 선택하는건,
				ex)memberrepo m=new memorymemberrepo();
			dip 위반임(인터페이스와 구현체에 동시에 의존함)
			이거도 스프링이 di를 하게해서 해결할수있음
			
	다형성만으로는 ocp와 dip를 지킬수가없음
	그래서 스프링은 di를 사용해서(의존성주입),클라이언트 코드의 변경없이 기능을 확장할수있게 해줌
	그리고 이상적으로는,모든 구현체에 인터페이스가 있는게 맞음
	근데 기능을 확장할 가능성이 없으면,그냥 구현체써도되고 나중에 필요할때 인터페이스를 덮으면됨
	근데 확장할거같으면 그냥 인터페이스쓰는게 좋음
		
		
		
2.스프링 핵심원리 이해-예제만들기
	start.spring.io에서 만들고,
	설정에서 빌드-빌드도구-gradle에서 빌드,테스트 실행 인텔리제이로 변경
	이러면 빌드가 좀 더 빨라짐
	
	설계할땐,도메인 협력관계,클래스 다이어그램,객체 다이어그램을 그려두면 좀더 이해가편함
	도메인협력관계는 비개발자도 이해가편하고,클래스다이어그램은 실제 구상도라 그런거필요할때 편하고,
	객체다이어그램은 진짜 단순히 동작방향볼때편함,즉 동적으로 변하는(구현체는 바뀔수있으니)걸 전부 제거한상태
		
	컨트롤 알트 v=해당 메서드의 리턴값 받는 변수생성
	org.assertj.core.api로 Assertions 써서 테스트하면됨
		Assertions.assertThat(member).isEqualTo(findmember);
		
		
	알트insert에서 생성할때,tostring생성하면,현재 객체값전체를 리턴하는게 자동으로 나옴
		
		
3.스프링 핵심원리 이해	2-객체지향원리적용
	컨트롤 쉬프트 t = 해당메서드 테스트자동생성(껍질만 생성해줌)
	테스트에서
		@Test
		@DisplayName("vip10퍼할인")
	이렇게하면,실행시 테스트에 표시되는이름을 저거로 표시할수있음
	
	di를 사용하지않으면 구현클래스에 의존할수밖에없음(ocp,dip위반)
	순수 자바로도,외부에서 생성자를 통해 주입하는 클래스를 만들고 걔를통해서만 생성하는식으로 해결할수있긴함
		
	테스트에서 
		@BeforeEach
	테스트전에 실행
	appconfig같은거 여기다가 넣어서 di하면됨
	
	컨피그같은곳에선 역할과 역할에 따른 구현이 한눈에 보여야함
	그래서 여기서는 각 구현 하나당 하나씩 생성메서드를 만들어두고,그거 조합해서 쓰는식으로 해야함
	자기자신을 제외한 다른 new가 메서드내에 있으면안됨
	
	컨트롤 알트 m하면 해당 new 구현체를 외부 메서드로 추출할수있음
	
	di를 사용하면 구현클래스를 의존하지않으니,새로운 구현클래스를 생성해도 실행영역에서의 변경은 일어나지않음,
	appconfig같은 구성영역에서의 변경만 일어나게됨
	
	이런걸 프레임워크단에 전부 맡겨버리는걸(appconfig같은 생성영역이나 제어영역을)ioc(제어의역전)라고 하고,
	보통 이렇게 하는게많은걸 프레임워크라고 함
	즉 내가 만든 객체들은,로직을 실행하는 역할만 담당하고,다른 모든것(객체생성같은)들은 내가 안하고 다른애한테 요청함
		
	의존관계에는 정적인 클래스 의존관계와 동적인 객체 의존관계를 분리해서 생각해야함
	정적 클래스 의존관계는,실제 인터페이스를 의존하는걸 말하고
	동적 객체 의존관계는 실제 실행시점에서 실제로 생성된 객체를 의존하는 관계를 말함
	
	정적 클래스 의존관계에선 실제로 어떤 인터페이스를 구현한 객체가 실행될지 알수없음
	
	이렇게 외부에서 di를 해주는걸 ioc컨테이너,혹은 di컨테이너라고 함
	이렇게 di를 사용하면,정적 클래스 의존관계를 전혀 건드리지않고,동적 객체 의존관계를 변경할수있음(ocp,dip)
		
	appconfig의 클래스에
		@Configuration
	추가하고
	각 생성메서드마다
		@Bean
	추가
	이러면 각 생성메서드들이 스프링컨테이너에 등록되고,
	스프링을 시작할땐 퍼블릭스태틱보이드메인에서
		ApplicationContext applicationContext=new AnnotationConfigApplicationContext(AppConfig.class);
		MemberService memberService=applicationContext.getBean("memberService",MemberService.class);
	추가하면,저 안에 있는 설정정보를 가지고 di컨테이너를 만들고,해당 스트링에 맞는 메서드를 실행해서 넣어줌
		applicationContext.getBean("메서드명",메서드리턴값.class)
	그러니까 appconfig처럼 applicationContext.getBean를 통해서만 생성시키면됨 앞으로는
	그리고 일반적으로 디폴트값은 싱글톤이라,어디서해도 같은값을 줌 기본값은
	
	
	ApplicationContext가 스프링 컨테이너고,얘는 @Configuration이 붙은걸 설정정보로 사용함
	@Configuration안에서 @Bean이 붙은걸 전부 호출해서 미리 객체를 만들어두고,
	만약 getBean이 오면 그 객체의 포인터값을 리턴해줌(그래서 싱글톤이됨)
	일단 기본적으로는 이렇고,보통 @autowired 생성자로 di했던거같음
		


4.스프링 컨테이너와 스프링 빈
	빈의 이름은 기본적으로 메서드이름인데
		@Bean(name="abc2")
	이렇게 명명할수도 있음
	단,이경우엔 모든 빈 이름이 하나도 겹치는게 있어선안됨
	그래서 그냥 기본값(메소드명)으로 두고쓰는게좋음..
	
	그리고 각 메소드끼리의 의존관계가 있을경우 알아서 밑단부터 생성해서 연결함
	정확히는 일단 다 생성을 하고나서 의존관계를 엮어서 주입함(물론 자바코드로 생성하면 메서드실행시켜야하니까 바로 생성하면서 엮이긴함)
	모든빈이름 출력할땐
		String[] beanDefinitionNames = ac.getBeanDefinitionNames();
	그리고 foreach로 
	iter하고 엔터치면 foreach자동으로 생성됨
	그리고 object로 getBean받아서 출력해보면됨
	사실 쓸일많진않을듯? 
	
	만약 내가 등록한거만 보고싶으면(시스템적으로 등록한거빼고)
        String[] beanDefinitionNames = ac.getBeanDefinitionNames();
        for (String beanDefinitionName : beanDefinitionNames) {
            BeanDefinition beanDefinition=ac.getBeanDefinition(beanDefinitionName);
            if(beanDefinition.getRole()==BeanDefinition.ROLE_APPLICATION){
				...출력코드
            }

	이런식으로 if문돌리면됨
	BeanDefinition.ROLE_APPLICATION이 내가만든거,BeanDefinition.ROLE_INFRASTRUCTURE가 스프링이 자체적으로 만든거

	보통은 이렇게 다 출력할일은 없고,조회를 하게됨(getBean같은)
	만약 getbean을 했을때 대상이 없으면,NoSuchBeanDefinitionException이 나게됨
	
	그리고 getBean에서 이름없이 타입으로만 조회할수도있음
		MemberService memberService = ac.getBean( MemberService.class);
	이경우 같은타입이 여러개일땐 오류가 발생함(NoUniqueBeanDefinitionException),이경우엔 이름을 넣어줘야함
	이떄 ac.getBeansOfType으로 해당타입의 모든 이름을 리턴받아볼수있음
		Map<String, MemberRepository> beansOfType = ac.getBeansOfType(MemberRepository.class);
	그리고 인터페이스를 받아올수도있고,구체클래스를 받아올수도있음
		MemberService memberService = ac.getBean("memberService", MemberServiceImpl.class);
	같은거일경우 결과가 같음
	기본적으로 실제반환타입을 보고 조회를 하기때문에,인터페이스나 구현체나 둘다 되는거(물론 구현체적는건 의존성생기니까 당연히 안좋음)
	
	테스트코드에서 예외테스트할땐 org.junit.jupiter.api의 Assertions.assertThrows를 쓰면됨
		org.junit.jupiter.api.Assertions.assertThrows(NoSuchBeanDefinitionException.class,
		()->ac.getBean("xxxx", MemberService.class));
	이렇게 해당예외클래스와 람다식으로 해당예외를 만드는 코드를 던져주면됨

	클래스에 static를 붙인다는건,내부클래스일때 스코프를 그 안에서만 사용하겠다는소리임

	그리고 스프링빈을 조회할때,만약 상속관계인 타입이 있으면,부모타입으로 조회할경우 자식타입도 함께 조회함
	그래서 object로 조회하면 모든 빈을 조회함
	그래서 만약 자식타입이 두개이상있으면(인터페이스의 자식관계도 포함)중복예외가 발생하게됨
	그래서 이름을 붙여야함
	물론 하위타입으로 조회할수도있지만,안좋은방법임(인터페이스만 의존해야하니까)



	스프링 컨테이너의 상속구조는
		BeanFactory
		ApplicationContext
		AnnotationConfigApplicationContext
	순으로 상속되어있음
	BeanFactory와ApplicationContext는 인터페이스임
	ApplicationContext는 여러가지 인터페이스를 상속받고있는데,
		BeanFactory->빈 관리조회
		MessageSource->메시지위치에 따라 국제화(언어변경)기능,파일을 분리해서 처리하는식
		EnvironmentCapable->환경변수
		ApplicationEventPublisher->이벤트를 발행하고 구독하는 모델 지원
		ResourceLoader->리소스를 편리하게 조회
	등을 받고있음
	
	보통 BeanFactory를 직접사용할일은 없고,ApplicationContext를 사용하게됨
	
	그리고 ApplicationContext는 인터페이스니까,이걸 구현하는게 여러개로 나눠지는데,
	이건 보통 해당 설정정보를 어떻게 받아올거냐(AppConfig.class,xml파일 등)으로 나눠지게됨
	근데 보통 요즘은 보통 어노테이션 기반만 사용하고,xml같은거는 안씀,레거시에서나 사용함

	
	
	이렇게 xml이든 자바코드이든,스프링은 BeanDefinition이라는 인터페이스로,
	각각 구현체들이 xml이든뭐든 읽어서 같은 출력을 내게 만들어둔거임

	beanDefinition의 메타정보들이 있긴한데,뭐 중요하진않은듯
	이걸 뽑아서쓸일도 없음 ㅋㅋ



5.싱글톤 컨테이너
	기본적으로 스프링을 거치지않고 di를 하게되면 싱글톤으로 나오지않고,매번 새 객체를 생성시킴
	
	테스트시 같지않다 확인
		Assertions.assertThat(memberService1).isNotSameAs(memberService2);

	그래서 싱글톤을 적용해서(서비스나 레포지터리 구현체에서 적용하면됨,di랑은 상관없음)
	di할때는 new를 안하고 getInstance하면되는거
		private SingletonService(){

		}
	이런식으로 프라이빗으로 생성자를 만들어두면,외부에서의 접근을 막을수있음(안에 코드안넣고 프라이빗만 적용하는거)
	
	isEqualTo와 isSameAs의 차이는,same는 ==이고 equal은 =임,즉 싱글톤확인할땐 same를 써야함
	
	Assertions.assertThat(instance1).isSameAs(instance2)
	Assertions.assertThat(instance1).isSameAs(instance2)
	
	싱글톤의 문제는
		코드가 늘어남
		dip를 위반함(구체클래스의존)
		클라이언트가 구체클래스를 의존해서 ocp위반가능성이 높음
		테스트하기어려움
		자식클래스만들기 어려움
		유연성이 떨어짐
	
	그런데 스프링을 사용하면 기본적으로 싱글톤 컨테이너로 관리해줌(바꿀수도있음,근데 보통은 싱글톤씀 99퍼는)
	이러면 dip,ocp,테스트등이 자유로워짐

	★싱글톤쓸때 주의점은(패턴이든 컨테이너든),무조건 스테이트리스로 설계해야함
	당연히 객체가 유지되니까 거기에 뭘 남기면 안됨
	그래서 db커넥션같은걸 주로 싱글톤으로 썼던거
	그래서
		특정 클라이언트에 의존적인 필드가 있으면안됨
		특정 클라이언트가 값을 바꿀수있는 필드가 있으면안됨
		어지간하면 읽기만 가능해야함
		필드대신 자바에서 공유되지않는 지역변수,파라미터등을 사용해야함


	그리고 @Configuration으로 AppConfig내에서 new를 여러개해도 모두 하나의객체임(여러객체에서 같은걸 생성해도 하나만생성됨)
	무조건 싱글톤식으로 하나만 생성해서 그거 di하는식으로 동작함
	@Configuration을 사용하면,스프링이 진짜 바이트코드를 치환해서 호출하는식으로 변경하는것(cglib라이브러리 사용함)
	그 레지한 싱글톤 방식(코틀린에서 했던방식)으로 생성-호출방식으로 동작하는걸로 추정
	
	그래서 @Configuration을 사용하지않고 @Bean만 사용하면 싱글톤으로 동작하지않음
	그리고 생성된애들도 스프링에서 관리하지않기때문에,그냥 bean취급도 받지않음(스프링컨테이너가 관리하지않음)
	사실 안쓸이유도 없음
	모든 설정정보는 @Configuration넣으면됨
	






















		
		