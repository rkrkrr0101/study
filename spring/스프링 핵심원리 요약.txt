1.객체지향설계와 스프링
	객체지향은 유연하고 변경이 용이해야함,
	확장엔 열려있고 변경엔 닫혀있어야함
	그리고 상위객체는 하위 인터페이스에 의존해야지,하위 구현체에 의존하면안됨(의존성역전)
	이렇게 설계하면 클라이언트가 하위단의 수정에 맞춰서 수정해야하는일이 일어나지않음
	
	근데 그래봐야 인터페이스의 변경이 일어나게되면(엄청 큰 변경이 있으면) 다 뜯어고쳐야하는건 맞지만..
	그래서 설계를 잘해야한다...
	
	solid
		단일책임원칙
			변경이있을때 파급효과가 작아야함
		개방폐쇄원칙
			확장엔 열려있고 변경엔 닫혀있어야함
			다형성을 활용해야함(인터페이스나 오버로드,오버라이드를 활용해야함)
			인터페이스를 구현한 구현체를 새로 하나 더 만드는건 ocp를 위반한게 아님
			단,클라이언트가 구현클래스를 직접 선택하는건 ocp를 위반하게됨,
			그래서 객체를 생성하고 연관관계를 맺어주는 별도의 조립,설정자가 필요하게됨(스프링이 해줌)
		리스코프치환원칙
			인터페이스를 구현한 구현체들은 인풋아웃풋을 다 지켜야함,즉 서로 바꿔치기를 해도 상관없어야함
		인터페이스 분리 원칙
			인터페이스는 큰거하나보단 잘 쪼개는게 좋다
			ex)자동차 인터페이스보단,운전,정비 인터페이스로 분리
			이러면 재사용가능성이 올라가고,다른곳에 영향을 주지않을확률이 올라가고,대체가능성이 올라가고,인터페이스가 명확해짐
		의존관계 변경 원칙
			상위객체는 하위인터페이스에 의존해야지 하위 구현체에 의존하면안된다
			이거도 클라이언트가 구현클래스를 선택하는건,
				ex)memberrepo m=new memorymemberrepo();
			dip 위반임(인터페이스와 구현체에 동시에 의존함)
			이거도 스프링이 di를 하게해서 해결할수있음
			
	다형성만으로는 ocp와 dip를 지킬수가없음
	그래서 스프링은 di를 사용해서(의존성주입),클라이언트 코드의 변경없이 기능을 확장할수있게 해줌
	그리고 이상적으로는,모든 구현체에 인터페이스가 있는게 맞음
	근데 기능을 확장할 가능성이 없으면,그냥 구현체써도되고 나중에 필요할때 인터페이스를 덮으면됨
	근데 확장할거같으면 그냥 인터페이스쓰는게 좋음
		
		
		
2.스프링 핵심원리 이해-예제만들기
	start.spring.io에서 만들고,
	설정에서 빌드-빌드도구-gradle에서 빌드,테스트 실행 인텔리제이로 변경
	이러면 빌드가 좀 더 빨라짐
	
	설계할땐,도메인 협력관계,클래스 다이어그램,객체 다이어그램을 그려두면 좀더 이해가편함
	도메인협력관계는 비개발자도 이해가편하고,클래스다이어그램은 실제 구상도라 그런거필요할때 편하고,
	객체다이어그램은 진짜 단순히 동작방향볼때편함,즉 동적으로 변하는(구현체는 바뀔수있으니)걸 전부 제거한상태
		
	컨트롤 알트 v=해당 메서드의 리턴값 받는 변수생성
	org.assertj.core.api로 Assertions 써서 테스트하면됨
		Assertions.assertThat(member).isEqualTo(findmember);
		
		
	알트insert에서 생성할때,tostring생성하면,현재 객체값전체를 리턴하는게 자동으로 나옴
		
		
		
		
		
		
		
		
		
		
		
		
		
		