1.객체지향설계와 스프링
	객체지향은 유연하고 변경이 용이해야함,
	확장엔 열려있고 변경엔 닫혀있어야함
	그리고 상위객체는 하위 인터페이스에 의존해야지,하위 구현체에 의존하면안됨(의존성역전)
	이렇게 설계하면 클라이언트가 하위단의 수정에 맞춰서 수정해야하는일이 일어나지않음
	
	근데 그래봐야 인터페이스의 변경이 일어나게되면(엄청 큰 변경이 있으면) 다 뜯어고쳐야하는건 맞지만..
	그래서 설계를 잘해야한다...
	
	solid
		단일책임원칙
			변경이있을때 파급효과가 작아야함
		개방폐쇄원칙
			확장엔 열려있고 변경엔 닫혀있어야함
			다형성을 활용해야함(인터페이스나 오버로드,오버라이드를 활용해야함)
			인터페이스를 구현한 구현체를 새로 하나 더 만드는건 ocp를 위반한게 아님
			단,클라이언트가 구현클래스를 직접 선택하는건 ocp를 위반하게됨,
			그래서 객체를 생성하고 연관관계를 맺어주는 별도의 조립,설정자가 필요하게됨(스프링이 해줌)
		리스코프치환원칙
			인터페이스를 구현한 구현체들은 인풋아웃풋을 다 지켜야함,즉 서로 바꿔치기를 해도 상관없어야함
		인터페이스 분리 원칙
			인터페이스는 큰거하나보단 잘 쪼개는게 좋다
			ex)자동차 인터페이스보단,운전,정비 인터페이스로 분리
			이러면 재사용가능성이 올라가고,다른곳에 영향을 주지않을확률이 올라가고,대체가능성이 올라가고,인터페이스가 명확해짐
		의존관계 변경 원칙
			상위객체는 하위인터페이스에 의존해야지 하위 구현체에 의존하면안된다
			이거도 클라이언트가 구현클래스를 선택하는건,
				ex)memberrepo m=new memorymemberrepo();
			dip 위반임(인터페이스와 구현체에 동시에 의존함)
			이거도 스프링이 di를 하게해서 해결할수있음
			
	다형성만으로는 ocp와 dip를 지킬수가없음
	그래서 스프링은 di를 사용해서(의존성주입),클라이언트 코드의 변경없이 기능을 확장할수있게 해줌
	그리고 이상적으로는,모든 구현체에 인터페이스가 있는게 맞음
	근데 기능을 확장할 가능성이 없으면,그냥 구현체써도되고 나중에 필요할때 인터페이스를 덮으면됨
	근데 확장할거같으면 그냥 인터페이스쓰는게 좋음
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		