1.스프링개발 시작하기
	개발할땐
		빠르게 완성해서 가장 간단한 방법 찾기
		작성한코드가 동작하는지 확인하는 방법 찾기
		조금씩 기능을 추가하고 다시 검증
		코드를 한눈에 이해하기 힘들다면 코멘트달기(안다는게 낫지만 이해하기힘든데 없는거보단 있는게 나음)
	그래서 각 요구사항을 작은 스탭으로 쪼개고,각 스탭단위로 만들고,테스트하고,개선하고 완성을 하고 다음스탭을 진행
	
	코틀린에선 최상위함수를 만들면 인텔리제이로 해당파일을 실행시킬때 해당함수를 실행시킴
	
	https://open.er-api.com/v6/latest/USD 여기서 환율정보등을 받을수있음
	
	리눅스에서 http -v url을 하면 내가 보내는 정보도 표시를해줌
	
	구시대 api호출처리
		val url = URL("https://open.er-api.com/v6/latest/$currency")		
        val connection = url.openConnection() as HttpURLConnection
        val br = BufferedReader(InputStreamReader(connection.inputStream))
        val response = br.lines().collect(Collectors.joining())
        br.close()
	url열고 버퍼로 받아서 바이트합성후 스트림닫기
	어짜피 요즘은 잭슨쓰고 그러겠지
	
	잭슨매퍼쓸때 코틀린에서는 그냥 ObjectMapper쓰는게 아니라
		implementation("com.fasterxml.jackson.module:jackson-module-kotlin")//의존성
		val mapper = jacksonObjectMapper()
		val data = mapper.readValue(response, ExRateData::class.java)
	jacksonObjectMapper를 써야함,그냥 ObjectMapper는 자바용이라 안되는게있음
	
	이때 json의 최상위키와 현재필드중 같은이름을 매핑해줌
	
	인텔리제이에서 카멜케이스로 대문자인거만 치면 인텔리센스로 찾아줌
	
2.오브젝트와 의존관계
  1.오브젝트와 의존관계
	스프링의 핵심은 객체(오브젝트)와 의존관계임
	클래스와 객체의 차이는,클래스는 객체를 만들기 위해 필요한거임
	즉 클래스는 설계도고 객체는 찍어져나온물체임
	인스턴스는 그냥 찍어져나온걸 말하는거고,객체보다 조금 큰 표현이라고 보면됨
	클래스의 인스턴스는 객체임(또한 배열도 자바에서는 객체로 취급됨)
	
	의존관계는 클래스사이의 의존관계(코드레벨의 의존관계)와 객체(인스턴스)사이의 의존관계(런타임레벨의 의존관계)가 있음
	코드레벨의 의존관계는 실제로 의존대상의 코드가 바뀌면 즉시 피의존대상은 영향을 받고(메서드이름변경등),
	런타임레벨의 의존관계는 의존성역전이 일어나기때문에,인터페이스의 변경과 구현의 변경을 다르게 취급할수있음
  
  2.관심사의 분리
	코드개선은 기능을 낫게만드는것과,동작은 건드리지않고 코드구조를 개선하는 리팩터링 두가지가 있음
	코드를 읽을때 코드자체로 설명이 되는 주석은 제거
	
	서로 관심사가 다른 내용들은 같은 메서드(혹은 클래스레벨까지)내에 있으면 안됨,그런경우 서로를 분리시켜주는게 좋음
	또한 기술적인내용(로우레벨)과 비즈니스로직(하이레벨)은 분리시켜주는게 좋음(메서드추출)
	또한 한 메서드(혹은 클래스)내에는 변경의 이유와 시점은 하나만 둬야함

  3.상속을 통한 확장
	클래스레벨에서도 관심사는 서로 분리되어야함
	일단 재사용성에서 관심사분리가 되어있지않으면 재사용이 힘들어짐
	즉 변경가능한 로우레벨(구현)과 변경할필요가 덜한 하이레벨(메서드 api)은 구분되어야함
	
	이걸 위해 상속을 사용할수있음
	팩토리메서드패턴이나 템플릿메서드패턴등이 이 상속을 사용해서 확장가능하게 만드는 패턴
	상속은 구현을 상속하는게 아닌 메서드api(인터페이스)를 상속하는게 목적이어야함
	
	이를위해 사용되는게 인터페이스와 추상클래스임
	공통구현이 필요하면 추상클래스,다 다르게 구현해야하면 인터페이스 사용
	
	근데 단점은,메서드가 추가될경우 n*n개의 조합이 생기는 문제가있음(변동확률,고정확률 * vip,일반),추가적으로 이름도 엄청길어짐

  4.클래스의 분리
	상속은 슈퍼클래스와 서브클래스간에 강결합이 일어나고,상속은 단일상속밖에 할수없음
	그래서 사용하는게 합성임
  
  5.인터페이스 도입
	합성을 하려면 해당 구현들의 api를 통일시켜주는 인터페이스가 필요하고,구현체들은 인터페이스를 구현해야 변경하지않고 사용할수있음
	즉 구현과 api를 분리할수있음

  6.관계설정책임의 분리
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
		