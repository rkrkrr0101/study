1.스프링개발 시작하기
	개발할땐
		빠르게 완성해서 가장 간단한 방법 찾기
		작성한코드가 동작하는지 확인하는 방법 찾기
		조금씩 기능을 추가하고 다시 검증
		코드를 한눈에 이해하기 힘들다면 코멘트달기(안다는게 낫지만 이해하기힘든데 없는거보단 있는게 나음)
	그래서 각 요구사항을 작은 스탭으로 쪼개고,각 스탭단위로 만들고,테스트하고,개선하고 완성을 하고 다음스탭을 진행
	
	코틀린에선 최상위함수를 만들면 인텔리제이로 해당파일을 실행시킬때 해당함수를 실행시킴
	
	https://open.er-api.com/v6/latest/USD 여기서 환율정보등을 받을수있음
	
	리눅스에서 http -v url을 하면 내가 보내는 정보도 표시를해줌
	
	구시대 api호출처리
		val url = URL("https://open.er-api.com/v6/latest/$currency")		
        val connection = url.openConnection() as HttpURLConnection
        val br = BufferedReader(InputStreamReader(connection.inputStream))
        val response = br.lines().collect(Collectors.joining())
        br.close()
	url열고 버퍼로 받아서 바이트합성후 스트림닫기
	어짜피 요즘은 잭슨쓰고 그러겠지
	
	잭슨매퍼쓸때 코틀린에서는 그냥 ObjectMapper쓰는게 아니라
		implementation("com.fasterxml.jackson.module:jackson-module-kotlin")//의존성
		val mapper = jacksonObjectMapper()
		val data = mapper.readValue(response, ExRateData::class.java)
	jacksonObjectMapper를 써야함,그냥 ObjectMapper는 자바용이라 안되는게있음
	
	이때 json의 최상위키와 현재필드중 같은이름을 매핑해줌
	
	인텔리제이에서 카멜케이스로 대문자인거만 치면 인텔리센스로 찾아줌
	
	인텔리제이의 설정중,에디터-라이브템플릿에서 특정문장을 약어로 쓸수있음
	이건 AssertJ의 org.assertj.core.api.Assertions.assertThat()이런거 약어로 꺼낼때 편함
	쓸땐
		설정에서 해당탭가서 자기가쓸 언어 클릭
		약어적기
		템플릿문장적고 입력후 커서가 갈곳에 $END$적기//org.assertj.core.api.Assertions.assertThat($END$)
		밑에 정의(define)에서 언어선택후 구문(statement)선택
	하면됨
	
	코틀린에서 try catch finally로 뭐 자원 다쓰고 닫아야할땐 use를 사용하면됨
	이때 람다내의 마지막값을 리턴하니,대상이 아닌 출력물을 바로 담으면됨 
		val response =
		BufferedReader(InputStreamReader(connection.inputStream)).use {
			it.lines().collect(Collectors.joining())
		}
	
2.오브젝트와 의존관계
  1.오브젝트와 의존관계
	스프링의 핵심은 객체(오브젝트)와 의존관계임
	클래스와 객체의 차이는,클래스는 객체를 만들기 위해 필요한거임
	즉 클래스는 설계도고 객체는 찍어져나온물체임
	인스턴스는 그냥 찍어져나온걸 말하는거고,객체보다 조금 큰 표현이라고 보면됨
	클래스의 인스턴스는 객체임(또한 배열도 자바에서는 객체로 취급됨)
	
	의존관계는 클래스사이의 의존관계(코드레벨의 의존관계)와 객체(인스턴스)사이의 의존관계(런타임레벨의 의존관계)가 있음
	코드레벨의 의존관계는 실제로 의존대상의 코드가 바뀌면 즉시 피의존대상은 영향을 받고(메서드이름변경등),
	런타임레벨의 의존관계는 의존성역전이 일어나기때문에,인터페이스의 변경과 구현의 변경을 다르게 취급할수있음
  
  2.관심사의 분리
	코드개선은 기능을 낫게만드는것과,동작은 건드리지않고 코드구조를 개선하는 리팩터링 두가지가 있음
	코드를 읽을때 코드자체로 설명이 되는 주석은 제거
	
	서로 관심사가 다른 내용들은 같은 메서드(혹은 클래스레벨까지)내에 있으면 안됨,그런경우 서로를 분리시켜주는게 좋음
	또한 기술적인내용(로우레벨)과 비즈니스로직(하이레벨)은 분리시켜주는게 좋음(메서드추출)
	또한 한 메서드(혹은 클래스)내에는 변경의 이유와 시점은 하나만 둬야함

  3.상속을 통한 확장
	클래스레벨에서도 관심사는 서로 분리되어야함
	일단 재사용성에서 관심사분리가 되어있지않으면 재사용이 힘들어짐
	즉 변경가능한 로우레벨(구현)과 변경할필요가 덜한 하이레벨(메서드 api)은 구분되어야함
	
	이걸 위해 상속을 사용할수있음
	팩토리메서드패턴이나 템플릿메서드패턴등이 이 상속을 사용해서 확장가능하게 만드는 패턴
	상속은 구현을 상속하는게 아닌 메서드api(인터페이스)를 상속하는게 목적이어야함
	
	이를위해 사용되는게 인터페이스와 추상클래스임
	공통구현이 필요하면 추상클래스,다 다르게 구현해야하면 인터페이스 사용
	
	근데 단점은,메서드가 추가될경우 n*n개의 조합이 생기는 문제가있음(변동확률,고정확률 * vip,일반),추가적으로 이름도 엄청길어짐

  4.클래스의 분리
	상속은 슈퍼클래스와 서브클래스간에 강결합이 일어나고,상속은 단일상속밖에 할수없음
	그래서 사용하는게 합성임
  
  5.인터페이스 도입
	합성을 하려면 해당 구현들의 api를 통일시켜주는 인터페이스가 필요하고,구현체들은 인터페이스를 구현해야 변경하지않고 사용할수있음
	즉 구현과 api를 분리할수있음

  6.관계설정책임의 분리
	인터페이스를 사용하게 만들고 이걸 구현한 구현체들을 확장해 나가는게 핵심임
	인터페이스는 구현체보다 더 안정적이고 변화가 적음,그래서 인터페이스를 의존하면 변경에 강해짐
	
	그런데 어쨌든 클래스 내부에서 구현체를 생성하면(관계설정),어쩔수없이 강의존이 생길수밖에 없음	
	그래서 사용되는게 해당 인터페이스를 매개변수로 주입을 받으면(di),외부에서 동적으로 구현클래스를 변경할수있음
	이게 관계설정책임을 클래스를 사용하는쪽으로 책임을 넘기는거임(관계설정책임의 분리)
	이걸 자동으로 처리해주는게 di프레임워크임(수동으로 하려면 보통 메인이나 오브젝트팩토리에서 처리)
	
  7.오브젝트 팩토리
	di프레임워크 없이 할때는 오브젝트들의 의존관계들을 설정해주는 용도의 클래스를 만드는게 좋음
	이게 오브젝트 팩토리임
	그리고 생성할때는 이 오브젝트 팩토리를 통해서만 생성하는거임(서로간에 의존성세팅도 여기서 서로간에 메서드호출하면서 처리)

  8.원칙과 패턴
	개방폐쇄원칙(ocp)를 인터페이스를 사용해서 포트어댑터(dip)를 사용하면 확장에는 열려있고 변경에는 닫혀있게 만들수있음
	즉 클래스의 기능을 확장할때,그 클래스의 코드는 변경되면 안된다 임
	즉 확장될부분은 인터페이스로 떼어낸다음 그부분을 동적으로 확장할수있게 해야함(외부에서 di받으면서)	
	전략패턴이 이걸 제일 잘 사용하는 패턴임
	
	
	높은 응집도와 낮은 결합도는,모든 모듈이나 클래스는 하나의 관심사에 집중되어있어야하고,서로간에 결합도는 약결합인게 바람직함
	
	높은 응집도는 변화가 일어날때 해당 모듈에서만 변경이 크게 일어나고,다른모듈에선 전혀 변화가 없는게 이상적,이러면 비용이 낮아짐
	외부api호출하던 클래스를 db호출하는 클래스로 바꾸는 이런느낌임,해당클래스내에서는 매우 변화가 크지만,외부로는 전혀 영향을 주지않음
	
	낮은 결합도는 서로간에 직접적으로 구현을 의존하는게 아닌,인터페이스같은 껍질을 의존하는식으로 약의존해야한다는것
	결합도가 낮으면 서로간에 수정을 할때 서로 영향을 덜받아서 수정이 덜힘들어짐	
	즉 책임과 관심사가 같은 모듈끼리는 결합도가 높아도 되는데(사실상 한모듈이라고 봐도되니),관심사가 다른 모듈끼리는 결합도가 낮은게 좋음
	
	전략패턴은 자신의 변경이 필요한 알고리즘을 통째로 외부로 분리시키고,이를 구현한 클래스를 필요에따라 바꿔서 사용할수있게하는 디자인패턴임
	즉 di가 이 전략패턴을 사용하는방식임(전략패턴의 변형,런타임에는 안바뀌니까 정확히 전략패턴은 아님)
	sort가 이런식으로 구현되어있음,해당 컬렉션의 종류(타입)에 따라 알고리즘을 바꿔가며 선택하는식임(또한 직접 구현해서 넣어도되고)
	
	
	제어의 역전은 제어권(선택권한)이 피사용대상에서 있는게 아닌,사용대상으로 가는게 제어의 역전임

  9.스프링 컨테이너와 의존관계 주입
	스프링의 핵심은 스프링 컨테이너임
	스프링 컨테이너는 ioc와 di를 제공함,즉 의존관계주입과 제어의 역전을 제공함
	즉 의존관계주입을 편하게 할수있게 해줌
	
	여기서 실제로 생성되는 구현체클래스들을 빈이라고 부르고,
	서로간에 의존관계를 설정하는 클래스(빈팩토리)를 만들거나(@Configration),하나뿐이면 자동으로해줌
	즉 빈의 클래스들과 의존관계가 들어있는게 빈팩토리임
	
	configration클래스를 직접만들땐 @Configration를 클래스레벨에 붙이고,
	각 생성메서드마다 생성할인터페이스와 이름을 같게한다음
	해당 메서드에 @Bean을 붙여주면됨
	
	즉 생성의 책임(관계설정책임)은 configration클래스가 모두 가져가게됨
	
	스프링은 시작할때 모든 빈들을 미리 생성하고(싱글톤),해당 빈들을 요청하면 가지고있는걸 넘겨줌,그걸 담아두는게 컨테이너임
	
  10.구성정보를 가져오는 다른 방법
	스프링은 해당 인터페이스의 구현체가 하나밖에 없으면 자동으로 주입해줌(@Component나 @Service같은거로)
	이때 @Configration이 붙은 클래스가 있다면 @ComponentScan을 붙여줘야함

  11.싱글톤 레지스트리
	스프링 컨테이너는 pojo(내가만든 클래스들)와 설정값(어노테이션등)이 합쳐져서 런타임에 사용하는 시스템객체들이 됨
	또한 스프링컨테이너는 기본적으로 싱글톤으로 빈을 생성함
	그래서 빈들은 상태가 있으면 안됨(val은 상관없지만 var은 안됨)
	즉 프로그램이 시작되면 빈들을 생성하고,다음에 빈을 요청하면 만든빈을 계속 주는거임
	
	또한 @Configration을 붙은 빈을 생성해서 수동으로 객체를 생성해도 같은객체가 리턴됨(싱글톤으로 리턴됨)
	configration클래스들에는 스프링이 프록시를 붙여서 절대 생성을 못하게 해둠
	그래서 configration클래스안의 생성메서드에서 각 클래스 생성할때 매개변수로 다른 클래스를 받을때도 싱글톤으로 들어가는거(프록시를 써서)
	
  12.di와 디자인 패턴
	디자인패턴은 목적과 스코프(상속과 합성)으로 2가지로 구분할수있음
	스코프기반으로는 보통 상속보다는 합성이 더 권장됨
	합성을 사용할땐 di를 사용해야하고,이때는 스프링을 쓸땐 스프링을 이용하면됨
	
	메인클래스를 두고,중요한 알고리즘등을 di받아서 교체해가며 생성할수있게하는건 전략패턴
	어떤 객체에 부가적인 기능/책임을 코드를 건드리지않고 추가하는건 데코레이터패턴
	데코레이터패턴은 자기자신의 인터페이스(상위인터페이스)를 매개변수로 받아서,
	다른 형제클래스를 받아서 해당코드를 실행하며 추가적으로 자기거도 처리하는 패턴임,즉 위임친구임
	
	데코레이터 패턴을 사용하면 기존코드를 건드리지않고 확장하는게 가능해짐
	이런식으로 하는게 스프링다운 개발

  13.의존성 역전 원칙(DIP)
	이건 포트어댑터패턴,즉 상위패키지는 하위패키지에 의존하면 안된다,둘모두 추상화에 의존해야한다 는 원칙임
	또한 추상화는 구체적인사항에 의존해서는 안된다,구체적인사항은 추상화에 의존해야한다 도 같은말임
	
	즉 상위가 자기가 필요한 모듈의 인터페이스의 소유권을 가지고있고,하위는 그걸 구현하는식으로 상위에 있는 인터페이스에 의존해야 한다는것
	만약 이렇지않고 직접 연결되면,하위에서 개미눈꼽만큼 변경이 일어나도 상위도 그대로 다 수정해야하는데(getChoco를 getCocolet로 변경),
	이게 인터페이스를 상위가 가지고,하위가 그걸 구현하는식이면 하위에서 변경이 일어나도 상위는 신경쓰지않음
	또한 인터페이스가 지정한 포멧(매개변수,리턴값)과 구현하고자하는것들을 어떻게 구현하든 마지막에 결과값만 주면 된다는게 구체는 추상에 의존해야한다는것임
	
	중요한건 패키지를 나눌때,인터페이스는 하위가 아닌 상위쪽이 들고있어야함,그래야 dip를 지킬수있음
	이걸 인터페이스 소유권의 역전이라고 부름
	즉 인터페이스는 자기를 구현한 클래스쪽이 아닌,자기를 사용하는쪽에 있는게 자연스러운 경우가 많음
	이래야 진짜로 하위패키지의 변경에 상위패키지가 완전히 영향을 받지않을순없음
	이건 각 모듈들을 따로 컴파일해서 던질수있어짐
	
	
3.테스트
  1.자동으로 수행되는 테스트	
	스프링의 제일 좋은점은 테스트만들기가 쉽다는거
	또한 테스트는 사람이 일일히 확인하는게 아닌,테스트키를 누르면 자동으로 테스트가 되고 성공실패가 나와야함
	또한 ui같은게 없이 객체 하나로 즉시 테스트를 할수있어야함
	그래서 사용되는게 junit같은 테스트프레임워크
	
	테스트는 작은크기의 자동수행되는테스트가 좋음,그래서 좋은게 유닛테스트

  2.junit 테스트 작성(+페이먼트서비스 테스트 작성)
	스킵

  3.테스트의 구성요소
	테스트는 제어할수없는 외부시스템에 관여가 되면 테스트가 깨지기쉬움
	그래서 외부요소들을 스텁으로 만들어서 사용하는게 좋음(협력자)
	여기엔 외부api,시간등이 들어감

  4.테스트와 di
	이떄 스텁을 바꿔가며 넣기위해,외부시스템을 접근하는부분을 합성하는식으로 만들어야(di를 사용할수있게해야) 테스트단에서 동적으로 바꿀수있음
	그리고 테스트는 가능한 작은영역을 테스트하는게 좋고,
	
	그리고 한 테스트 내부에서 수치를 바꿔가며 여러번 계산하고싶을땐,함수내에서 함수를 뽑아서 사용할수있음
	이렇게 만들어두면 나중에 문제생겼을때 문제찾기도 쉬움
	
	추가로 BigDecimal은 isEqualTo를 사용하면 위험할수있음,그래서 BigDecimal은 isEqualByComparingTo를 사용해야함
	isEqualTo는 소수점자리갯수때문에 위험함
	
	만약 다른 오브젝트들과 협력해서 해야할경우엔 스프링을 띄워서 테스트할수도있음(@Autowired사용)
	이때 configration이 필요할경우(의존관계가 복잡할경우),테스트에서 configration클래스를 만들고,그걸 지정해서 사용할수있음
	이걸 좀 더 편하게 쓰는게 @ContextConfigration임
	이걸 사용하면 빈팩토리객체를 생성하지않고 바로 가져올수있음
		@ContextConfiguration(classes = [TestObjectFactory::class])
		@ExtendWith(SpringExtension::class)//이렇게쓸때 필수
	이후에 di는
		@Autowired 
		lateinit var paymentService: PaymentService
	이렇게 받으면됨
	
	이거의 장점은,이거도 생성책임이 분리가 돼서,스텁을 다른거로 나중에 바꿀일이 생겨도 테스트코드에서 바꾸지않아도됨
	또한 테스트에서는 인터페이스로 생성하는게 아닌,구현체를 선택해서 di받을수도 있음(인텔리제이 빨간줄떠도 에러안남),
	
	근데 스프링을 쓰는거(스프링컨테이너를 쓰는것)보다 그냥 유닛테스트돌리는게 훨씬 빨라서,그게 가능하면 더 좋음
	
  5.학습테스트
	학습테스트는 내가 만들지않는 코드를 테스트하는것
	즉 이건 내가 만들지않은 코드의 동작방식을 테스트하면서 익혀가는것임(100퍼센트 확신할수없는 코드를 테스트하는것)
	
	즉 빈템플릿띄워서 printf로 확인하던거를,어짜피 해야하는걸 가지고 테스트를 만들면,
	해당 라이브러리의 버전이 올라갔을때도 동일하게 동작하는지를 확인할수있고,다른사람들도 안만들고 확인할수있음(그래서 해당프로젝트테스트에 같이두기도함)
	
  6.clock를 이용한 시간 테스트
	시간같은거도 di를 사용해서 빈으로 만들어서 외부에서 합성시키면 테스트할때 편함
	즉 우리가 컨트롤할수없는걸 인터페이스와 구현체로 만들어서,테스트에서 구현체를 갈아끼는방식을 사용할수있음
	또한 시간의경우(localdatetime),Clock라는 클래스가 이런용도로 사용하는걸 이미 만들어둔게 있긴함
	
  7.도메인 오브젝트 테스트
	도메인로직(비즈니스로직)을 어디둘거냐에 따라
		트랜잭션스크립트->서비스의 메서드에 둠
		도메인모델->도메인모델 객체에 둠
	도메인모델로 만들면 테스트를 만들기가 매우쉬워짐
	
	트랜잭션스크립트는 도메인이 데이터홀더로만 사용되고,서비스가 매우 비대해짐,단 개발이 쉬워서 짧게칠땐 괜찮음
	도메인모델로 만들면 서비스가 얇아지고,로직들이 응집도있게 뭉치게됨,또한 pojo로 로직들이 뭉치게돼서 테스트만들기가 매우쉬움
	
	도메인객체를 생성할땐 생성자와 팩토리메서드를 사용하는 두가지 방법이 있음
	팩토리메서드가 메서드명을 통한 정보전달이 돼서+의미있는처리를 추가가 가능해서 선호되는듯
	팩토리메서드는 스태틱(컴패니언 오브젝트)로 만들어져야함
	
	도메인객체안의 메서드들을 만들때 생각해야할건,자기가 모든 정보를 가지고있으면 자기가 메서드로 만들어서 처리하는게 나음
	즉 자기안에서 뭐가 유효한지,이런거를 체크하는 로직을 도메인 자기자신이 가지고있는게 편함
	
	
	
4.템플릿
  1.스프링과 jdk 업그레이드
	스프링을 최신거로 업그레이드할땐,빈 스프링부트 프로젝트를 하나 만들고 그걸가지고 라이브러리버전들을 똑같이 맞추는게 편함

  2.다시보는 개방폐쇄원칙
	코드들은 변하지않으려는 성질이 있는부분과,계속 다양해지고 확장하려는 성질이 있는부분이 혼재돼있음
	
	코드에서 ocp를 지키게 하려면,di를 통한 생성책임의 분리를 해야함
	이걸 템플릿이라고 부름
	
	템플릿은 코드중에서 변경이 거의 일어나지않고,일정한 패턴으로 유지되는 특성을 가진부분을,
	자유롭게 변경되는성질을 가진 부분으로부터 독립시켜 효과적으로 활용하게하는 방법
	을 말함
	또한 변경이 잘되는,자유롭게 변경될필요가 있는 부분을 콜백이라고 부름
	템플릿과 콜백은 항상 같이 나타나고,그래서 템플릿콜백패턴이라고도 부름

  3.WebApiExRateProvider 리팩터링
	리팩터링은 기능을 변경하지않고 구조만 개선하는작업
	이를통해 이해하기쉽고 변경하기좋은 코드로 만드는것
	그래서 리팩터링을 하려면 테스트가 있어야함(기능이 변경되지않았다는걸 알수있음)
	
	예외중 우리가 복구할수없는,진짜 예외적인상황의경우엔 예외를 밖으로 던져야하는건 맞음
	근데 자바에서는 인터페이스를 구현한 구현체가 네트워크익셉션을 던진다던가 하면 바깥은 해당예외와 결합되게됨(구현체와 결합)
	체크드 익셉션의 경우엔 반드시 메서드에 예외를 표시해야하는데,이걸 언체크익셉션으로 바꿔서 던지는게 좋음(이러면 표시안해도되니까)
	코틀린의경우 다 언체크니까 신경안써도되고,예외를 변경하고싶을때만 하면됨

  4.변하는 코드 분리하기
	변하는 부분과 변하지않는 부분을 분리할때는 제일 먼저 할건 메서드추출임
	이때 일단 각 부분(하는일이 하나인 부분)별로 분리하고나서 변하는코드인지 변하지않는 코드인지를 판별하면됨
	또한 이러면 예외던지기도 편해짐
	그리고 변하는부분과 변하지않는부분 코드가 섞여있을때도,분리하기쉬움,한 관심사 내부라도 변하는부분과 변하지않는부분을 따로 분리해서 두는게 좋음
	
	즉 변하는부분을 메서드추출하면 생기는 메서드의 api부분은 변하지않는부분이 된다는걸 이용하는거임
	
	또한 메서드의 이름은 동작방식이 아닌 목적을 표현할수있는 이름을 쓰는게 좋음

  5.변하지않는 코드 분리하기
	변하지않는 코드를 템플릿이라고 부름(api호출만을 담당하는부분)
	템플릿은 고정된 틀안에 바꿀수있는 부분을 넣어 사용할수있게(di로)하는 코드를 말함
	여기서 di로 넣어지는부분이 콜백임
	
	비슷한거로 템플릿메서드 패턴이 있는데,이거도 고정된 틀을 슈퍼클래스에 둔다음,바뀌는부분을 서브클래스의 메서드에 두는 구조로 이뤄짐
	
	이렇게 템플릿을 만들어서 고정된부분과 변하는부분을 분리하면,재사용성이 높아짐(di로 받을경우에)
	또한 문제가 생겼을때 변하는부분을 바꿔가면서 의존도를 낮출수도있음

  6.인터페이스 도입과 클래스 분리
	메서드를 분리했으면,서로간에 다른 관심사인 부분은 다른 클래스로 분리하는게 좋음
	또한 이때 결합도를 낮추기위해 인터페이스를 도입해서 di받으면 약의존을 할수있음

  7.콜백과 메서드주입
	콜백은 메서드주입(메서드 인젝션)과 같이 나오는 단어임
	콜백은 실행되는걸 목적으로 다른오브젝트의 메서드에 전달되는 오브젝트임
	즉 값을 참조하는게 목적이 아닌,해당콜백을 실행하는게 목적이 되는경우를 말함
	
	자바에서는 콜백에서는 하나의메서드를 가진 인터페이스타입(sam)의 오브젝트나 람다를 던짐
	즉 핵심은 하나의메서드만(람다도 무명의 메서드라고 보면되니)던지는게 핵심이고 이걸 콜백이라고 부름
	
	템플릿콜백패턴은 전략패턴의 특별한 케이스임(컨텍스트가 있고 거기에 바뀌는 알고리즘을 삽입해서 실행하니까)
	템플릿은 전략패턴의 컨텍스트고,콜백은 전략패턴의 전략임
	여기서 전략패턴과 다른거는,전략은 메서드 여러개를 가질수있지만 콜백은 메서드가 하나임
	
	또한 콜백이 템플릿의 메서드로 전달되는거를 메서드 주입이라고 이야기하고,di와 비슷함(di의 한종류)
	일반di랑 비교해서 특이한건,di는 오브젝트가 컨테이너가 만들어질때 이미 결정되어있지만,이건 런타임에 결정되기때문에 런타임에서 바꿀수있음
	
	즉 오브젝트 시그니처에서 di받는게 아닌,메서드 시그니처에서 di받으면 메서드주입임
	이때 해당 메서드를 사용하는(즉 주입하는)메서드는,강의존으로 해당클래스를 생성해서 던져주면됨
	즉 이부분만 바꿔서 나중에 클래스를 바꿀수있게 하는게 목적임(결국 콜백이라는게 한번은 강의존을 해야하니까,최대한 책임이 있는 윗단으로 올려서 처리하는것)
	
	또한 이런식으로 구현클래스대신 람다를 쓰거나,익명클래스 코드내에서 만들어서 넣는방식으로 사용하기도함(보통 sam의경우 람다를 더 많이 사용함)
	람다는 구현메서드가 하나인것이면 다 람다로 바꿀수있으니(sam은 람다로 바꿀수있음),람다를 보통 사용함
	
	
	즉 변하는 속성을 가진 코드는 콜백으로 만들어서 템플릿에 메소드파라미터 형태로 전달해주는 방법이 있음
	이때 콜백을 만들어서 템플릿을 호출하는 대상을 클라이언트라고 부름(콜백을 직접만들든 가져오든)

  8.콜백
	클라이언트의 책임은,콜백을 생성하고 템플릿안에 있는 메소드를 호출하는 책임을 가짐
	이때 순서는
		1.클라가 콜백을 생성
		2.클라가 템플릿을 콜백을 담아서 호출
		3.템플릿 워크플로 시작
		4.참조정보생성(콜백이 사용할)
		5.콜백에 참조정보를 담아서 호출
		6.콜백은 클라이언트의 final(val)을 참조(클라 내부클래스이기때문,람다의경우)->그래서 콜백을 클라에서 직접 만들경우,생성자로 값들을 넣을필요없음
		7.클라이언트의 val과 참조정보를 사용해 작업을 수행
		8.콜백 작업 결과 리턴
		9.템플릿 워크플로 진행
		10.템플릿워크플로 종료
		11.템플릿 작업결과 리턴
	이 순서로 진행됨
	
	람다로 콜백을 던지는건,딱 거기서만 한번쓰고 말거라면 편하고,여러번 쓸때는 해당 람다를 분리해서 클래스화시키면됨
	근데 보통 상위레벨코드들이 있는데 기술적인게 있으면 관심사가 안맞기때문에 분리하는경우가 많은듯

  9.템플릿 분리
	콜백말고 템플릿도 별개의 클래스로 분리하는게 좋음
	템플릿은 여러개의 콜백을 동시에 받을수있음(다를수도 같을수도있음,같을경우 배열로)
	이렇게 템플릿클래스가 되면 재사용성이 올라감
	
	템플릿은 잘 변하지 않기때문에,템플릿은 굳이 인터페이스를 만들지않아도됨(필요하면 만들어도되긴함)
	어짜피 템플릿은 메서드시그니처의 정보만을 담고있는경우가 많아서,변경할일이 별로없기때문

  10.디폴트 콜백과 템플릿 빈
	템플릿도 스프링컨테이너에 들어가는 빈이 될수있음(상태가 없으니까)
	또한 그렇기때문에 템플릿클래스에 콜백을 di를 해서 콜백을 프로젝트시작시점에 고정생성하는 방식도 가능함
	이때 완전히 고정이 아닌,디폴트값을 넣어주는방법도 가능함(그냥 클래스 생성자에 기본값을 넣어두면됨)
	그리고 오버로드로 템플릿실행을 디폴트값을 실행하는 메서드를 따로두는것(생성자에 디폴트값,메서드 오버로드로 디폴트콜백실행)
	
	템플릿을 여러군데서 재사용하려고하면 빈으로 올려서 사용할수있음
	이러면 디폴트값을 빼버리고 그냥 컨피그클래스에서 등록하거나,템플릿에 컴포넌트를 붙이고 해당 콜백도 컴포넌트로 등록할수있음
	
	
  11.스프링이 제공하는 템플릿
	스프링은 템플릿콜백패턴을 사용하기 적합한 경우가 많고,스프링은 이미 제공하는 템플릿들이 있음
	jdbcTemplate,restTemplate등등
	
	restTemplate은 http client라이브러리 확장과 메시지바디컴버터(json,xml등등)를 전략으로 가지는 템플릿임
	기본적으로 변하지않는 부분을 다 넣어두고,콜백부분만 사용자보고 구현하라고 하는것(확장여부를 열어줌)
	
	restTemplate를 기본생성자로 생성하면,http호출부분과 메시지바디컴버터가 기본적으로 가지고있는 클래스를 사용함
	이때 생성자에 해당 콜백을 만들어 넣어주면,해당콜백으로 동작시키는거도 가능함
	해당종류의 ClientHttpRequestFactory를 restTemplate의 생성자에 넣어주면 변경할수있음
	
5.예외
  1.예외를 다루는 방법
	예외는 반드시 예외적인 상황에서만 사용해야함,예외를 사용해 뭘 컨트롤하려고하면 안됨
	
	예외가 발생하면
		예외상황을 복구해서 정상흐름으로 전환할수있는가?
			1.재시도(외부에 의존하는경우 n번정도 다시시도해보는거)
			2.대안(api의경우 비슷한 api로 연결되게 만듬)
		버그인가?
			1.우리가 만든 코드에서 생긴 버그인가? ->수정
			2.클라이언트(우리서비스를 사용하는쪽)의 버그인가?->그쪽에 적절하게 통보,즉 친절한 에러메시지
		제어할수없는 예외상황인가(코드를 건드려서 해결할수없는상황,db문제등)
	이 3개중 뭔지를 확인해야함
	
	예외를 잘못다루는 코드중에는
		예외를 무시하는 코드(catch에서 아무것도 안함)
			catch에서는 예외를 복구하거나 예외를 밖으로 다시 던지거나 둘중 하나를 반드시 해야함
		(자바의경우)체크예외를 언체크로 변경하지않고 메서드에 throws 예외를 아무의미없이 계속 담,
			즉 언체크와 체크를 상황에 맞게 선택해야함,예외상황에서는 언체크예외를 던져야하고,체크예외는 복구할수없으면 언체크로 바꿔서 던져야함
	가 있음

	사용기술에 따라 같은문제에 대해 다른종류의 예외가 발생함
	그래서 필요한게 예외의 추상화임

  2.jpa를 이용한 order 저장
	jpa내용은 다스킵		

  3.Order레포지토리와 예외
	결국 세이브나 조회나 그런 메서드들이 다 템플릿과 콜백으로 이뤄짐
	트랜잭션과 엔티티매니저를 닫는 그런부분들은 다 템플릿으로 반드시 일어나야하는거고,중간의 실행하는 메서드만 콜백으로 변하는것

  4.dataAccessException과 예외추상화
	
  
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
		