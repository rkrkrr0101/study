1.스프링개발 시작하기
	개발할땐
		빠르게 완성해서 가장 간단한 방법 찾기
		작성한코드가 동작하는지 확인하는 방법 찾기
		조금씩 기능을 추가하고 다시 검증
		코드를 한눈에 이해하기 힘들다면 코멘트달기(안다는게 낫지만 이해하기힘든데 없는거보단 있는게 나음)
	그래서 각 요구사항을 작은 스탭으로 쪼개고,각 스탭단위로 만들고,테스트하고,개선하고 완성을 하고 다음스탭을 진행
	
	코틀린에선 최상위함수를 만들면 인텔리제이로 해당파일을 실행시킬때 해당함수를 실행시킴
	
	https://open.er-api.com/v6/latest/USD 여기서 환율정보등을 받을수있음
	
	리눅스에서 http -v url을 하면 내가 보내는 정보도 표시를해줌
	
	구시대 api호출처리
		val url = URL("https://open.er-api.com/v6/latest/$currency")		
        val connection = url.openConnection() as HttpURLConnection
        val br = BufferedReader(InputStreamReader(connection.inputStream))
        val response = br.lines().collect(Collectors.joining())
        br.close()
	url열고 버퍼로 받아서 바이트합성후 스트림닫기
	어짜피 요즘은 잭슨쓰고 그러겠지
	
	잭슨매퍼쓸때 코틀린에서는 그냥 ObjectMapper쓰는게 아니라
		implementation("com.fasterxml.jackson.module:jackson-module-kotlin")//의존성
		val mapper = jacksonObjectMapper()
		val data = mapper.readValue(response, ExRateData::class.java)
	jacksonObjectMapper를 써야함,그냥 ObjectMapper는 자바용이라 안되는게있음
	
	이때 json의 최상위키와 현재필드중 같은이름을 매핑해줌
	
	인텔리제이에서 카멜케이스로 대문자인거만 치면 인텔리센스로 찾아줌
	
2.오브젝트와 의존관계
  1.오브젝트와 의존관계
	스프링의 핵심은 객체(오브젝트)와 의존관계임
	클래스와 객체의 차이는,클래스는 객체를 만들기 위해 필요한거임
	즉 클래스는 설계도고 객체는 찍어져나온물체임
	인스턴스는 그냥 찍어져나온걸 말하는거고,객체보다 조금 큰 표현이라고 보면됨
	클래스의 인스턴스는 객체임(또한 배열도 자바에서는 객체로 취급됨)
	
	의존관계는 클래스사이의 의존관계(코드레벨의 의존관계)와 객체(인스턴스)사이의 의존관계(런타임레벨의 의존관계)가 있음
	코드레벨의 의존관계는 실제로 의존대상의 코드가 바뀌면 즉시 피의존대상은 영향을 받고(메서드이름변경등),
	런타임레벨의 의존관계는 의존성역전이 일어나기때문에,인터페이스의 변경과 구현의 변경을 다르게 취급할수있음
  
  2.관심사의 분리
	코드개선은 기능을 낫게만드는것과,동작은 건드리지않고 코드구조를 개선하는 리팩터링 두가지가 있음
	코드를 읽을때 코드자체로 설명이 되는 주석은 제거
	
	서로 관심사가 다른 내용들은 같은 메서드(혹은 클래스레벨까지)내에 있으면 안됨,그런경우 서로를 분리시켜주는게 좋음
	또한 기술적인내용(로우레벨)과 비즈니스로직(하이레벨)은 분리시켜주는게 좋음(메서드추출)
	또한 한 메서드(혹은 클래스)내에는 변경의 이유와 시점은 하나만 둬야함

  3.상속을 통한 확장
	클래스레벨에서도 관심사는 서로 분리되어야함
	일단 재사용성에서 관심사분리가 되어있지않으면 재사용이 힘들어짐
	즉 변경가능한 로우레벨(구현)과 변경할필요가 덜한 하이레벨(메서드 api)은 구분되어야함
	
	이걸 위해 상속을 사용할수있음
	팩토리메서드패턴이나 템플릿메서드패턴등이 이 상속을 사용해서 확장가능하게 만드는 패턴
	상속은 구현을 상속하는게 아닌 메서드api(인터페이스)를 상속하는게 목적이어야함
	
	이를위해 사용되는게 인터페이스와 추상클래스임
	공통구현이 필요하면 추상클래스,다 다르게 구현해야하면 인터페이스 사용
	
	근데 단점은,메서드가 추가될경우 n*n개의 조합이 생기는 문제가있음(변동확률,고정확률 * vip,일반),추가적으로 이름도 엄청길어짐

  4.클래스의 분리
	상속은 슈퍼클래스와 서브클래스간에 강결합이 일어나고,상속은 단일상속밖에 할수없음
	그래서 사용하는게 합성임
  
  5.인터페이스 도입
	합성을 하려면 해당 구현들의 api를 통일시켜주는 인터페이스가 필요하고,구현체들은 인터페이스를 구현해야 변경하지않고 사용할수있음
	즉 구현과 api를 분리할수있음

  6.관계설정책임의 분리
	인터페이스를 사용하게 만들고 이걸 구현한 구현체들을 확장해 나가는게 핵심임
	인터페이스는 구현체보다 더 안정적이고 변화가 적음,그래서 인터페이스를 의존하면 변경에 강해짐
	
	그런데 어쨌든 클래스 내부에서 구현체를 생성하면(관계설정),어쩔수없이 강의존이 생길수밖에 없음	
	그래서 사용되는게 해당 인터페이스를 매개변수로 주입을 받으면(di),외부에서 동적으로 구현클래스를 변경할수있음
	이게 관계설정책임을 클래스를 사용하는쪽으로 책임을 넘기는거임(관계설정책임의 분리)
	이걸 자동으로 처리해주는게 di프레임워크임(수동으로 하려면 보통 메인이나 오브젝트팩토리에서 처리)
	
  7.오브젝트 팩토리
	di프레임워크 없이 할때는 오브젝트들의 의존관계들을 설정해주는 용도의 클래스를 만드는게 좋음
	이게 오브젝트 팩토리임
	그리고 생성할때는 이 오브젝트 팩토리를 통해서만 생성하는거임(서로간에 의존성세팅도 여기서 서로간에 메서드호출하면서 처리)

  8.원칙과 패턴
	개방폐쇄원칙(ocp)를 인터페이스를 사용해서 포트어댑터(dip)를 사용하면 확장에는 열려있고 변경에는 닫혀있게 만들수있음
	즉 클래스의 기능을 확장할때,그 클래스의 코드는 변경되면 안된다 임
	즉 확장될부분은 인터페이스로 떼어낸다음 그부분을 동적으로 확장할수있게 해야함(외부에서 di받으면서)	
	전략패턴이 이걸 제일 잘 사용하는 패턴임
	
	
	높은 응집도와 낮은 결합도는,모든 모듈이나 클래스는 하나의 관심사에 집중되어있어야하고,서로간에 결합도는 약결합인게 바람직함
	
	높은 응집도는 변화가 일어날때 해당 모듈에서만 변경이 크게 일어나고,다른모듈에선 전혀 변화가 없는게 이상적,이러면 비용이 낮아짐
	외부api호출하던 클래스를 db호출하는 클래스로 바꾸는 이런느낌임,해당클래스내에서는 매우 변화가 크지만,외부로는 전혀 영향을 주지않음
	
	낮은 결합도는 서로간에 직접적으로 구현을 의존하는게 아닌,인터페이스같은 껍질을 의존하는식으로 약의존해야한다는것
	결합도가 낮으면 서로간에 수정을 할때 서로 영향을 덜받아서 수정이 덜힘들어짐	
	즉 책임과 관심사가 같은 모듈끼리는 결합도가 높아도 되는데(사실상 한모듈이라고 봐도되니),관심사가 다른 모듈끼리는 결합도가 낮은게 좋음
	
	전략패턴은 자신의 변경이 필요한 알고리즘을 통째로 외부로 분리시키고,이를 구현한 클래스를 필요에따라 바꿔서 사용할수있게하는 디자인패턴임
	즉 di가 이 전략패턴을 사용하는방식임(전략패턴의 변형,런타임에는 안바뀌니까 정확히 전략패턴은 아님)
	sort가 이런식으로 구현되어있음,해당 컬렉션의 종류(타입)에 따라 알고리즘을 바꿔가며 선택하는식임(또한 직접 구현해서 넣어도되고)
	
	
	제어의 역전은 제어권(선택권한)이 피사용대상에서 있는게 아닌,사용대상으로 가는게 제어의 역전임

  9.스프링 컨테이너와 의존관계 주입
	스프링의 핵심은 스프링 컨테이너임
	스프링 컨테이너는 ioc와 di를 제공함,즉 의존관계주입과 제어의 역전을 제공함
	즉 의존관계주입을 편하게 할수있게 해줌
	
	여기서 실제로 생성되는 구현체클래스들을 빈이라고 부르고,
	서로간에 의존관계를 설정하는 클래스(빈팩토리)를 만들거나(@Configration),하나뿐이면 자동으로해줌
	즉 빈의 클래스들과 의존관계가 들어있는게 빈팩토리임
	
	configration클래스를 직접만들땐 @Configration를 클래스레벨에 붙이고,
	각 생성메서드마다 생성할인터페이스와 이름을 같게한다음
	해당 메서드에 @Bean을 붙여주면됨
	
	즉 생성의 책임(관계설정책임)은 configration클래스가 모두 가져가게됨
	
	스프링은 시작할때 모든 빈들을 미리 생성하고(싱글톤),해당 빈들을 요청하면 가지고있는걸 넘겨줌,그걸 담아두는게 컨테이너임
	
  10.구성정보를 가져오는 다른 방법
	스프링은 해당 인터페이스의 구현체가 하나밖에 없으면 자동으로 주입해줌(@Component나 @Service같은거로)
	이때 @Configration이 붙은 클래스가 있다면 @ComponentScan을 붙여줘야함

  11.싱글톤 레지스트리
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
		