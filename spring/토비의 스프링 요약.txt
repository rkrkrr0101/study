1.스프링개발 시작하기
	개발할땐
		빠르게 완성해서 가장 간단한 방법 찾기
		작성한코드가 동작하는지 확인하는 방법 찾기
		조금씩 기능을 추가하고 다시 검증
		코드를 한눈에 이해하기 힘들다면 코멘트달기(안다는게 낫지만 이해하기힘든데 없는거보단 있는게 나음)
	그래서 각 요구사항을 작은 스탭으로 쪼개고,각 스탭단위로 만들고,테스트하고,개선하고 완성을 하고 다음스탭을 진행
	
	코틀린에선 최상위함수를 만들면 인텔리제이로 해당파일을 실행시킬때 해당함수를 실행시킴
	
	https://open.er-api.com/v6/latest/USD 여기서 환율정보등을 받을수있음
	
	리눅스에서 http -v url을 하면 내가 보내는 정보도 표시를해줌
	
	구시대 api호출처리
		val url = URL("https://open.er-api.com/v6/latest/$currency")		
        val connection = url.openConnection() as HttpURLConnection
        val br = BufferedReader(InputStreamReader(connection.inputStream))
        val response = br.lines().collect(Collectors.joining())
        br.close()
	url열고 버퍼로 받아서 바이트합성후 스트림닫기
	어짜피 요즘은 잭슨쓰고 그러겠지
	
	잭슨매퍼쓸때 코틀린에서는 그냥 ObjectMapper쓰는게 아니라
		implementation("com.fasterxml.jackson.module:jackson-module-kotlin")//의존성
		val mapper = jacksonObjectMapper()
		val data = mapper.readValue(response, ExRateData::class.java)
	jacksonObjectMapper를 써야함,그냥 ObjectMapper는 자바용이라 안되는게있음
	
	이때 json의 최상위키와 현재필드중 같은이름을 매핑해줌
	
	인텔리제이에서 카멜케이스로 대문자인거만 치면 인텔리센스로 찾아줌
	
	인텔리제이의 설정중,에디터-라이브템플릿에서 특정문장을 약어로 쓸수있음
	이건 AssertJ의 org.assertj.core.api.Assertions.assertThat()이런거 약어로 꺼낼때 편함
	쓸땐
		설정에서 해당탭가서 자기가쓸 언어 클릭
		약어적기
		템플릿문장적고 입력후 커서가 갈곳에 $END$적기//org.assertj.core.api.Assertions.assertThat($END$)
		밑에 정의(define)에서 언어선택후 구문(statement)선택
	하면됨
	
2.오브젝트와 의존관계
  1.오브젝트와 의존관계
	스프링의 핵심은 객체(오브젝트)와 의존관계임
	클래스와 객체의 차이는,클래스는 객체를 만들기 위해 필요한거임
	즉 클래스는 설계도고 객체는 찍어져나온물체임
	인스턴스는 그냥 찍어져나온걸 말하는거고,객체보다 조금 큰 표현이라고 보면됨
	클래스의 인스턴스는 객체임(또한 배열도 자바에서는 객체로 취급됨)
	
	의존관계는 클래스사이의 의존관계(코드레벨의 의존관계)와 객체(인스턴스)사이의 의존관계(런타임레벨의 의존관계)가 있음
	코드레벨의 의존관계는 실제로 의존대상의 코드가 바뀌면 즉시 피의존대상은 영향을 받고(메서드이름변경등),
	런타임레벨의 의존관계는 의존성역전이 일어나기때문에,인터페이스의 변경과 구현의 변경을 다르게 취급할수있음
  
  2.관심사의 분리
	코드개선은 기능을 낫게만드는것과,동작은 건드리지않고 코드구조를 개선하는 리팩터링 두가지가 있음
	코드를 읽을때 코드자체로 설명이 되는 주석은 제거
	
	서로 관심사가 다른 내용들은 같은 메서드(혹은 클래스레벨까지)내에 있으면 안됨,그런경우 서로를 분리시켜주는게 좋음
	또한 기술적인내용(로우레벨)과 비즈니스로직(하이레벨)은 분리시켜주는게 좋음(메서드추출)
	또한 한 메서드(혹은 클래스)내에는 변경의 이유와 시점은 하나만 둬야함

  3.상속을 통한 확장
	클래스레벨에서도 관심사는 서로 분리되어야함
	일단 재사용성에서 관심사분리가 되어있지않으면 재사용이 힘들어짐
	즉 변경가능한 로우레벨(구현)과 변경할필요가 덜한 하이레벨(메서드 api)은 구분되어야함
	
	이걸 위해 상속을 사용할수있음
	팩토리메서드패턴이나 템플릿메서드패턴등이 이 상속을 사용해서 확장가능하게 만드는 패턴
	상속은 구현을 상속하는게 아닌 메서드api(인터페이스)를 상속하는게 목적이어야함
	
	이를위해 사용되는게 인터페이스와 추상클래스임
	공통구현이 필요하면 추상클래스,다 다르게 구현해야하면 인터페이스 사용
	
	근데 단점은,메서드가 추가될경우 n*n개의 조합이 생기는 문제가있음(변동확률,고정확률 * vip,일반),추가적으로 이름도 엄청길어짐

  4.클래스의 분리
	상속은 슈퍼클래스와 서브클래스간에 강결합이 일어나고,상속은 단일상속밖에 할수없음
	그래서 사용하는게 합성임
  
  5.인터페이스 도입
	합성을 하려면 해당 구현들의 api를 통일시켜주는 인터페이스가 필요하고,구현체들은 인터페이스를 구현해야 변경하지않고 사용할수있음
	즉 구현과 api를 분리할수있음

  6.관계설정책임의 분리
	인터페이스를 사용하게 만들고 이걸 구현한 구현체들을 확장해 나가는게 핵심임
	인터페이스는 구현체보다 더 안정적이고 변화가 적음,그래서 인터페이스를 의존하면 변경에 강해짐
	
	그런데 어쨌든 클래스 내부에서 구현체를 생성하면(관계설정),어쩔수없이 강의존이 생길수밖에 없음	
	그래서 사용되는게 해당 인터페이스를 매개변수로 주입을 받으면(di),외부에서 동적으로 구현클래스를 변경할수있음
	이게 관계설정책임을 클래스를 사용하는쪽으로 책임을 넘기는거임(관계설정책임의 분리)
	이걸 자동으로 처리해주는게 di프레임워크임(수동으로 하려면 보통 메인이나 오브젝트팩토리에서 처리)
	
  7.오브젝트 팩토리
	di프레임워크 없이 할때는 오브젝트들의 의존관계들을 설정해주는 용도의 클래스를 만드는게 좋음
	이게 오브젝트 팩토리임
	그리고 생성할때는 이 오브젝트 팩토리를 통해서만 생성하는거임(서로간에 의존성세팅도 여기서 서로간에 메서드호출하면서 처리)

  8.원칙과 패턴
	개방폐쇄원칙(ocp)를 인터페이스를 사용해서 포트어댑터(dip)를 사용하면 확장에는 열려있고 변경에는 닫혀있게 만들수있음
	즉 클래스의 기능을 확장할때,그 클래스의 코드는 변경되면 안된다 임
	즉 확장될부분은 인터페이스로 떼어낸다음 그부분을 동적으로 확장할수있게 해야함(외부에서 di받으면서)	
	전략패턴이 이걸 제일 잘 사용하는 패턴임
	
	
	높은 응집도와 낮은 결합도는,모든 모듈이나 클래스는 하나의 관심사에 집중되어있어야하고,서로간에 결합도는 약결합인게 바람직함
	
	높은 응집도는 변화가 일어날때 해당 모듈에서만 변경이 크게 일어나고,다른모듈에선 전혀 변화가 없는게 이상적,이러면 비용이 낮아짐
	외부api호출하던 클래스를 db호출하는 클래스로 바꾸는 이런느낌임,해당클래스내에서는 매우 변화가 크지만,외부로는 전혀 영향을 주지않음
	
	낮은 결합도는 서로간에 직접적으로 구현을 의존하는게 아닌,인터페이스같은 껍질을 의존하는식으로 약의존해야한다는것
	결합도가 낮으면 서로간에 수정을 할때 서로 영향을 덜받아서 수정이 덜힘들어짐	
	즉 책임과 관심사가 같은 모듈끼리는 결합도가 높아도 되는데(사실상 한모듈이라고 봐도되니),관심사가 다른 모듈끼리는 결합도가 낮은게 좋음
	
	전략패턴은 자신의 변경이 필요한 알고리즘을 통째로 외부로 분리시키고,이를 구현한 클래스를 필요에따라 바꿔서 사용할수있게하는 디자인패턴임
	즉 di가 이 전략패턴을 사용하는방식임(전략패턴의 변형,런타임에는 안바뀌니까 정확히 전략패턴은 아님)
	sort가 이런식으로 구현되어있음,해당 컬렉션의 종류(타입)에 따라 알고리즘을 바꿔가며 선택하는식임(또한 직접 구현해서 넣어도되고)
	
	
	제어의 역전은 제어권(선택권한)이 피사용대상에서 있는게 아닌,사용대상으로 가는게 제어의 역전임

  9.스프링 컨테이너와 의존관계 주입
	스프링의 핵심은 스프링 컨테이너임
	스프링 컨테이너는 ioc와 di를 제공함,즉 의존관계주입과 제어의 역전을 제공함
	즉 의존관계주입을 편하게 할수있게 해줌
	
	여기서 실제로 생성되는 구현체클래스들을 빈이라고 부르고,
	서로간에 의존관계를 설정하는 클래스(빈팩토리)를 만들거나(@Configration),하나뿐이면 자동으로해줌
	즉 빈의 클래스들과 의존관계가 들어있는게 빈팩토리임
	
	configration클래스를 직접만들땐 @Configration를 클래스레벨에 붙이고,
	각 생성메서드마다 생성할인터페이스와 이름을 같게한다음
	해당 메서드에 @Bean을 붙여주면됨
	
	즉 생성의 책임(관계설정책임)은 configration클래스가 모두 가져가게됨
	
	스프링은 시작할때 모든 빈들을 미리 생성하고(싱글톤),해당 빈들을 요청하면 가지고있는걸 넘겨줌,그걸 담아두는게 컨테이너임
	
  10.구성정보를 가져오는 다른 방법
	스프링은 해당 인터페이스의 구현체가 하나밖에 없으면 자동으로 주입해줌(@Component나 @Service같은거로)
	이때 @Configration이 붙은 클래스가 있다면 @ComponentScan을 붙여줘야함

  11.싱글톤 레지스트리
	스프링 컨테이너는 pojo(내가만든 클래스들)와 설정값(어노테이션등)이 합쳐져서 런타임에 사용하는 시스템객체들이 됨
	또한 스프링컨테이너는 기본적으로 싱글톤으로 빈을 생성함
	그래서 빈들은 상태가 있으면 안됨(val은 상관없지만 var은 안됨)
	즉 프로그램이 시작되면 빈들을 생성하고,다음에 빈을 요청하면 만든빈을 계속 주는거임
	
	또한 @Configration을 붙은 빈을 생성해서 수동으로 객체를 생성해도 같은객체가 리턴됨(싱글톤으로 리턴됨)
	configration클래스들에는 스프링이 프록시를 붙여서 절대 생성을 못하게 해둠
	그래서 configration클래스안의 생성메서드에서 각 클래스 생성할때 매개변수로 다른 클래스를 받을때도 싱글톤으로 들어가는거(프록시를 써서)
	
  12.di와 디자인 패턴
	디자인패턴은 목적과 스코프(상속과 합성)으로 2가지로 구분할수있음
	스코프기반으로는 보통 상속보다는 합성이 더 권장됨
	합성을 사용할땐 di를 사용해야하고,이때는 스프링을 쓸땐 스프링을 이용하면됨
	
	메인클래스를 두고,중요한 알고리즘등을 di받아서 교체해가며 생성할수있게하는건 전략패턴
	어떤 객체에 부가적인 기능/책임을 코드를 건드리지않고 추가하는건 데코레이터패턴
	데코레이터패턴은 자기자신의 인터페이스(상위인터페이스)를 매개변수로 받아서,
	다른 형제클래스를 받아서 해당코드를 실행하며 추가적으로 자기거도 처리하는 패턴임,즉 위임친구임
	
	데코레이터 패턴을 사용하면 기존코드를 건드리지않고 확장하는게 가능해짐
	이런식으로 하는게 스프링다운 개발

  13.의존성 역전 원칙(DIP)
	이건 포트어댑터패턴,즉 상위패키지는 하위패키지에 의존하면 안된다,둘모두 추상화에 의존해야한다 는 원칙임
	또한 추상화는 구체적인사항에 의존해서는 안된다,구체적인사항은 추상화에 의존해야한다 도 같은말임
	
	즉 상위가 자기가 필요한 모듈의 인터페이스의 소유권을 가지고있고,하위는 그걸 구현하는식으로 상위에 있는 인터페이스에 의존해야 한다는것
	만약 이렇지않고 직접 연결되면,하위에서 개미눈꼽만큼 변경이 일어나도 상위도 그대로 다 수정해야하는데(getChoco를 getCocolet로 변경),
	이게 인터페이스를 상위가 가지고,하위가 그걸 구현하는식이면 하위에서 변경이 일어나도 상위는 신경쓰지않음
	또한 인터페이스가 지정한 포멧(매개변수,리턴값)과 구현하고자하는것들을 어떻게 구현하든 마지막에 결과값만 주면 된다는게 구체는 추상에 의존해야한다는것임
	
	중요한건 패키지를 나눌때,인터페이스는 하위가 아닌 상위쪽이 들고있어야함,그래야 dip를 지킬수있음
	이걸 인터페이스 소유권의 역전이라고 부름
	즉 인터페이스는 자기를 구현한 클래스쪽이 아닌,자기를 사용하는쪽에 있는게 자연스러운 경우가 많음
	이래야 진짜로 하위패키지의 변경에 상위패키지가 완전히 영향을 받지않을순없음
	이건 각 모듈들을 따로 컴파일해서 던질수있어짐
	
	
3.테스트
  1.자동으로 수행되는 테스트	
	스프링의 제일 좋은점은 테스트만들기가 쉽다는거
	또한 테스트는 사람이 일일히 확인하는게 아닌,테스트키를 누르면 자동으로 테스트가 되고 성공실패가 나와야함
	또한 ui같은게 없이 객체 하나로 즉시 테스트를 할수있어야함
	그래서 사용되는게 junit같은 테스트프레임워크
	
	테스트는 작은크기의 자동수행되는테스트가 좋음,그래서 좋은게 유닛테스트

  2.junit 테스트 작성(+페이먼트서비스 테스트 작성)
	스킵

  3.테스트의 구성요소
	테스트는 제어할수없는 외부시스템에 관여가 되면 테스트가 깨지기쉬움
	그래서 외부요소들을 스텁으로 만들어서 사용하는게 좋음(협력자)
	여기엔 외부api,시간등이 들어감

  4.테스트와 di
	이떄 스텁을 바꿔가며 넣기위해,외부시스템을 접근하는부분을 합성하는식으로 만들어야(di를 사용할수있게해야) 테스트단에서 동적으로 바꿀수있음
	그리고 테스트는 가능한 작은영역을 테스트하는게 좋고,
	
	그리고 한 테스트 내부에서 수치를 바꿔가며 여러번 계산하고싶을땐,함수내에서 함수를 뽑아서 사용할수있음
	이렇게 만들어두면 나중에 문제생겼을때 문제찾기도 쉬움
	
	추가로 BigDecimal은 isEqualTo를 사용하면 위험할수있음,그래서 BigDecimal은 isEqualByComparingTo를 사용해야함
	isEqualTo는 소수점자리갯수때문에 위험함
	
	만약 다른 오브젝트들과 협력해서 해야할경우엔 스프링을 띄워서 테스트할수도있음(@Autowired사용)
	이때 configration이 필요할경우(의존관계가 복잡할경우),테스트에서 configration클래스를 만들고,그걸 지정해서 사용할수있음
	이걸 좀 더 편하게 쓰는게 @ContextConfigration임
	이걸 사용하면 빈팩토리객체를 생성하지않고 바로 가져올수있음
		@ContextConfiguration(classes = [TestObjectFactory::class])
		@ExtendWith(SpringExtension::class)//이렇게쓸때 필수
	이후에 di는
		@Autowired 
		lateinit var paymentService: PaymentService
	이렇게 받으면됨
	
	이거의 장점은,이거도 생성책임이 분리가 돼서,스텁을 다른거로 나중에 바꿀일이 생겨도 테스트코드에서 바꾸지않아도됨
	또한 테스트에서는 인터페이스로 생성하는게 아닌,구현체를 선택해서 di받을수도 있음(인텔리제이 빨간줄떠도 에러안남),
	
	근데 스프링을 쓰는거(스프링컨테이너를 쓰는것)보다 그냥 유닛테스트돌리는게 훨씬 빨라서,그게 가능하면 더 좋음
	
  5.학습테스트
	학습테스트는 내가 만들지않는 코드를 테스트하는것
	즉 이건 내가 만들지않은 코드의 동작방식을 테스트하면서 익혀가는것임(100퍼센트 확신할수없는 코드를 테스트하는것)
	
	즉 빈템플릿띄워서 printf로 확인하던거를,어짜피 해야하는걸 가지고 테스트를 만들면,
	해당 라이브러리의 버전이 올라갔을때도 동일하게 동작하는지를 확인할수있고,다른사람들도 안만들고 확인할수있음(그래서 해당프로젝트테스트에 같이두기도함)
	
  6.clock를 이용한 시간 테스트
	시간같은거도 di를 사용해서 빈으로 만들어서 외부에서 합성시키면 테스트할때 편함
	즉 우리가 컨트롤할수없는걸 인터페이스와 구현체로 만들어서,테스트에서 구현체를 갈아끼는방식을 사용할수있음
	또한 시간의경우(localdatetime),Clock라는 클래스가 이런용도로 사용하는걸 이미 만들어둔게 있긴함
	
  7.도메인 오브젝트 테스트
	도메인로직(비즈니스로직)을 어디둘거냐에 따라
		트랜잭션스크립트->서비스의 메서드에 둠
		도메인모델->도메인모델 객체에 둠
	도메인모델로 만들면 테스트를 만들기가 매우쉬워짐
	
	트랜잭션스크립트는 도메인이 데이터홀더로만 사용되고,서비스가 매우 비대해짐,단 개발이 쉬워서 짧게칠땐 괜찮음
	도메인모델로 만들면 서비스가 얇아지고,로직들이 응집도있게 뭉치게됨,또한 pojo로 로직들이 뭉치게돼서 테스트만들기가 매우쉬움
	
	도메인객체를 생성할땐 생성자와 팩토리메서드를 사용하는 두가지 방법이 있음
	팩토리메서드가 메서드명을 통한 정보전달이 돼서+의미있는처리를 추가가 가능해서 선호되는듯
	팩토리메서드는 스태틱(컴패니언 오브젝트)로 만들어져야함
	
	도메인객체안의 메서드들을 만들때 생각해야할건,자기가 모든 정보를 가지고있으면 자기가 메서드로 만들어서 처리하는게 나음
	즉 자기안에서 뭐가 유효한지,이런거를 체크하는 로직을 도메인 자기자신이 가지고있는게 편함
	
	
	
4.템플릿	
	
	
	
	
	
	
	
	
	
  
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
		