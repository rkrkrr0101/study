1.강좌소개
	orm(jpa)는,그냥 컬렉션에 데이터를 담고 빼고 하는걸 데이터베이스와 매핑시키는거
2.jpa소개
	기본적으로 데이터를 저장한다는건,객체를 db에 저장한다는것과 같음
	근데 이때 sql이 들어가면,번역이 들어가서 코스트가 추가로 들어가게됨(넣을때랑 뺄때 둘다(insert와 select))
	
	sql중심적인 개발의 문제는,이 코스트낭비에 있음
	이건 유지보수(컬럼을 추가한다던가)할때 너무너무머리가 아프고,결국 sql에 의존적인 개발이 돼버림
	
	문제는 객체와 rdb는 패러다임이 다름
	크게
		상속
		연관관계
		데이터타입
		데이터 식별방법
	객체는 상속을 받을수있는데,rdb에선 슈퍼타입서브타입으로 풀순있는데,이건 너무복잡해져서 사용하지못할수준임
	객체는 연관관계할때 참조(객체의 주소값)를 사용하고,테이블은 외래키를 사용해서 조인을 해야함(복잡하기도하고,객체가 아닌 객체의id를 사용하게됨 테이블에선) 
	
	즉 객체처럼 모델링하면할수록 sql매퍼에선 매핑작업만 늘어남
	그래서 나온게 orm임
	
	즉 객체를 컬렉션에 저장하고 조회하듯 날로먹을수있음
		em.persist(객체) //저장
		Member member =em.find(memberId) //조회
		memeber.setName("바꿀이름") //수정(트랜잭션안에서 더티체킹으로 해야하긴함 )
		em.remove(객체)  //삭제
	상속받은객체도,그냥 가져오면 알아서 조인해서 가져다줌,연관관계도 알아서해줌(n+1은 조심해야하지만 기본적으론 레지로딩으로 처리하면됨)
	
	그리고 같은 트랜잭션안에선 항상 같은엔티티를 반환해줌(캐시를 사용해서 3번조회를해도 한번만sql날리고 그걸 던져줌)
	그리고 인서트쿼리같은거도 커밋을 하는순간 모아서보내서 통신코스트가 줄어듬(어짜피 트랜잭션커밋전에만 보내면되니)
		
3.jpa시작
	application.properties에 h2사용할때
		spring.datasource.url=jdbc:h2:tcp://localhost/~/test
		spring.datasource.driver-class-name=org.h2.Driver
		spring.datasource.username=sa
		spring.jpa.database-platform=org.hibernate.dialect.H2Dialect //h2방언선택,mysql은 org.hibernate.dialect.MySQL5InnoDBDialect
		spring.jpa.hibernate.ddl-auto=create-drop //현재 등록된 엔티티 스키마 생성 어케할거냐,운영환경에선 validate
	넣고
	빌드 그래들에
		implementation 'org.springframework.boot:spring-boot-starter-jdbc'
		runtimeOnly 'com.h2database:h2'
	추가
	
	@Entity를 붙이면 이건 jpa가 관리하는 객체라는거고,그안에서 @Id는 프라이머리키임
	모든 작업은 트랜잭션 내에서 일어나야함
	
	그리고
		생성=em.persist(객체)
		조회=em.find(객체클래스.class,객체)
		조건조회=em.createQuery("jpql내용",객체클래스.class).getResultList()
		삭제=em.remove(객체)
		수정=em.find(객체)->객체 변형(setter이나 그런거로),persist안해도됨
	조회를 제외한 모든건 트랜잭션안에서 일어나야하고,같은 트랜잭션내에선 조회의 결과값은 항상 같음 
	
	jpql은 테이블이 아닌 객체를 대상으로 쿼리를 짠다고 생각해야함
	이거의 장점은 페이징(setFirstResults,setMaxResults)같은게 쉽고,db의 변경도 쉬움
		
	jpa에서 생성자만들땐 기본생성자를 하나 꼭 넣어줘야함
		protected Member(){}
	이렇게 빈 생성자를 꼭 넣어줘야됨
	
4.영속성 관리
	jpa에서 가장 중요한건,객체와 rdb매핑과 영속성컨텍스트임
	
	깡jpa만 사용한다고 생각해보면,엔티티매니저팩토리로 요청이 오면 엔티티매니저를 만들어서 커넥션풀을 물려서 db를 사용함
	여기서 영속성컨텍스트는 엔티티를 영구저장하는 환경이라는것(em.persist(entity)가,정확히는 db에 저장하는게 아닌,엔티티를 영속화한다,
	영속성컨텍스트에 집어넣는다는것)
	
	여기서 영속성컨텍스트는 논리적개념으로,엔티티매니저를 통해서 영속성컨텍스트에 접근하게됨
	즉 @PersistenceContext를 붙이면,영속성컨텍스트를 생성하고,엔티티매니저에 그걸 di한다고 생각해도됨(그래서 n(em):1(PC)로 동작)
	
	엔티티의 생명주기는,
		비영속:영속성 컨텍스트랑 상관없는 새로운상태(Persist하기전)
		영속:영속성컨텍스트에 의해 관리되는상태(Persist나 더티체킹하고나서)
		준영속:영속성컨텍스트에 의해 관리되다 분리된상태(detach로 영속성컨텍스트에서 빼거나)
		삭제:객체와 db데이터가 같이 삭제된 상태(remove사용)
	순서임
	
	비영속상태는 그냥 객체를 막 생성한 상태임,퍼시스턴트해서 넣기전이라 jpa랑 관계없는상태
	영속상태는 비영속상태인걸 퍼시스트를 해서 영속성 컨텍스트에 넣은상태,즉 영속성컨텍스트에 들어있으면 영속이니까,find해서 찾아도(더티체킹) 영속상태임
	영속상태일때 변화가 있으면,트랜잭션이 끝날때 커밋(플러시)되면서 업데이트가 됨(쿼리가 날아감)
	
	여기서 영속성 컨텍스트의 이점은
		1차캐시:조회할때도 영속에 넣고 거기서 찾는거라,방금 영속에 넣고 커밋하기전에도 조회할수있어짐(쿼리도 안날려도되고)즉 중복쿼리가 줄어듬,중요하진않음
		동일성보장:영속엔티티끼리의 동일성을 애플리케이션레벨에서 보장해줌(member1==member2)
		트랜잭션을 지원하는 쓰기지연:영속객체에 변경이 있을때마다 쿼리를 안날리고, 커밋했을때 최종변경본만 가지고 쿼리를 날릴수있음(버퍼링)
		변경감지(더티체킹):영속컨텍스트 안에있는 엔티티에 변경이 일어나면,따로 뭘 안해도 자동으로 업데이트됨(persist가 그냥 영속컨텍스트에 올리는거니..)
		지연로딩:연관관계매핑이 된 엔티티를 조회할때,프록시를 날려서 진짜로 필요할떄 조회쿼리를 날릴수있고,범위제한같은걸 할필요없이 객체처럼 쓸수있음
	이 있음
	
	더티체킹을 할때 내부적으로 체크하는로직은,트랜잭션시작시의 스냅샷을떠두고,그거랑 비교하는거
		
	플러시는 영속성컨텍스트의 변경내용을 데이터베이스에 반영하는걸 말함(따로 영속성컨텍스트를 건드리진않고,sql저장소를 db에 밀어넣는거만 함)
	플러시가 발생하면
		변경감지
		수정된 엔티티를 쓰기지연sql저장소에 등록
		쓰기지연sql저장소의 쿼리를 데이터베이스에 전송(등록,삭제,수정쿼리)
	순서로 작동함
	
	플러시는,
		em.flush를 직접 호출하거나(쓸일없는데 테스트할때는 가끔사용),
		트랜잭션 커밋이 일어나거나,
		jpql쿼리를 실행하거나(id값으로 서치하는게 아니라 다른값으로 찾기때문에 어쩔수없이 플러시가 일어나게됨)
	하면 일어남
	
	플러시는
		영속성 컨텍스트를 비우지않고
		영속성 컨텍스트를 데이터베이스에 동기화
	임
	트랜잭션이라는 작업단위를 바탕으로->커밋직전에만 동기화하면되니 기본족으로 그때 플러시를 함
		
	
	준영속상태는 영속상태엔티티가 영속컨텍스트에서 분리된 상태
	그래서 이상태에선 변경이 일어나도 db에 적용되지않음
	준영속이 되는 이유는,일반적으로 영속성컨텍스트가 초기화되거나 했을때 일어남,
	em.find하면 영속컨텍스트로 들어가니까 이런식으로 영속으로 처리하면됨
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
	