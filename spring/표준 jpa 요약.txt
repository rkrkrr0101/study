1.강좌소개
	orm(jpa)는,그냥 컬렉션에 데이터를 담고 빼고 하는걸 데이터베이스와 매핑시키는거
2.jpa소개
	기본적으로 데이터를 저장한다는건,객체를 db에 저장한다는것과 같음
	근데 이때 sql이 들어가면,번역이 들어가서 코스트가 추가로 들어가게됨(넣을때랑 뺄때 둘다(insert와 select))
	
	sql중심적인 개발의 문제는,이 코스트낭비에 있음
	이건 유지보수(컬럼을 추가한다던가)할때 너무너무머리가 아프고,결국 sql에 의존적인 개발이 돼버림
	
	문제는 객체와 rdb는 패러다임이 다름
	크게
		상속
		연관관계
		데이터타입
		데이터 식별방법
	객체는 상속을 받을수있는데,rdb에선 슈퍼타입서브타입으로 풀순있는데,이건 너무복잡해져서 사용하지못할수준임
	객체는 연관관계할때 참조(객체의 주소값)를 사용하고,테이블은 외래키를 사용해서 조인을 해야함(복잡하기도하고,객체가 아닌 객체의id를 사용하게됨 테이블에선) 
	
	즉 객체처럼 모델링하면할수록 sql매퍼에선 매핑작업만 늘어남
	그래서 나온게 orm임
	
	즉 객체를 컬렉션에 저장하고 조회하듯 날로먹을수있음
		em.persist(객체) //저장
		Member member =em.find(memberId) //조회
		memeber.setName("바꿀이름") //수정(트랜잭션안에서 더티체킹으로 해야하긴함 )
		em.remove(객체)  //삭제
	상속받은객체도,그냥 가져오면 알아서 조인해서 가져다줌,연관관계도 알아서해줌(n+1은 조심해야하지만 기본적으론 레지로딩으로 처리하면됨)
	
	그리고 같은 트랜잭션안에선 항상 같은엔티티를 반환해줌(캐시를 사용해서 3번조회를해도 한번만sql날리고 그걸 던져줌)
	그리고 인서트쿼리같은거도 커밋을 하는순간 모아서보내서 통신코스트가 줄어듬(어짜피 트랜잭션커밋전에만 보내면되니)
		
3.jpa시작
	application.properties에 h2사용할때
		spring.datasource.url=jdbc:h2:tcp://localhost/~/test
		spring.datasource.driver-class-name=org.h2.Driver
		spring.datasource.username=sa
		spring.jpa.database-platform=org.hibernate.dialect.H2Dialect //h2방언선택,mysql은 org.hibernate.dialect.MySQL5InnoDBDialect
		spring.jpa.hibernate.ddl-auto=create-drop //현재 등록된 엔티티 스키마 생성 어케할거냐,운영환경에선 validate
	넣고
	빌드 그래들에
		implementation 'org.springframework.boot:spring-boot-starter-jdbc'
		runtimeOnly 'com.h2database:h2'
	추가
	
	@Entity를 붙이면 이건 jpa가 관리하는 객체라는거고,그안에서 @Id는 프라이머리키임
	모든 작업은 트랜잭션 내에서 일어나야함
	
	그리고
		생성=em.persist(객체)
		조회=em.find(객체클래스.class,객체)
		조건조회=em.createQuery("jpql내용",객체클래스.class).getResultList()
		삭제=em.remove(객체)
		수정=em.find(객체)->객체 변형(setter이나 그런거로),persist안해도됨
	조회를 제외한 모든건 트랜잭션안에서 일어나야하고,같은 트랜잭션내에선 조회의 결과값은 항상 같음 
	
	jpql은 테이블이 아닌 객체를 대상으로 쿼리를 짠다고 생각해야함
	이거의 장점은 페이징(setFirstResults,setMaxResults)같은게 쉽고,db의 변경도 쉬움
		
	jpa에서 생성자만들땐 기본생성자를 하나 꼭 넣어줘야함
		protected Member(){}
	이렇게 빈 생성자를 꼭 넣어줘야됨
	
4.영속성 관리
	jpa에서 가장 중요한건,객체와 rdb매핑과 영속성컨텍스트임
	
	깡jpa만 사용한다고 생각해보면,엔티티매니저팩토리로 요청이 오면 엔티티매니저를 만들어서 커넥션풀을 물려서 db를 사용함
	여기서 영속성컨텍스트는 엔티티를 영구저장하는 환경이라는것(em.persist(entity)가,정확히는 db에 저장하는게 아닌,엔티티를 영속화한다,
	영속성컨텍스트에 집어넣는다는것)
	
	여기서 영속성컨텍스트는 논리적개념으로,엔티티매니저를 통해서 영속성컨텍스트에 접근하게됨
	즉 @PersistenceContext를 붙이면,영속성컨텍스트를 생성하고,엔티티매니저에 그걸 di한다고 생각해도됨(그래서 n(em):1(PC)로 동작)
	
	엔티티의 생명주기는,
		비영속:영속성 컨텍스트랑 상관없는 새로운상태(Persist하기전)
		영속:영속성컨텍스트에 의해 관리되는상태(Persist나 더티체킹하고나서)
		준영속:영속성컨텍스트에 의해 관리되다 분리된상태(detach로 영속성컨텍스트에서 빼거나)
		삭제:객체와 db데이터가 같이 삭제된 상태(remove사용)
	순서임
	
	비영속상태는 그냥 객체를 막 생성한 상태임,퍼시스턴트해서 넣기전이라 jpa랑 관계없는상태
	영속상태는 비영속상태인걸 퍼시스트를 해서 영속성 컨텍스트에 넣은상태,즉 영속성컨텍스트에 들어있으면 영속이니까,find해서 찾아도(더티체킹) 영속상태임
	영속상태일때 변화가 있으면,트랜잭션이 끝날때 커밋(플러시)되면서 업데이트가 됨(쿼리가 날아감)
	
	여기서 영속성 컨텍스트의 이점은
		1차캐시:조회할때도 영속에 넣고 거기서 찾는거라,방금 영속에 넣고 커밋하기전에도 조회할수있어짐(쿼리도 안날려도되고)즉 중복쿼리가 줄어듬,중요하진않음
		동일성보장:영속엔티티끼리의 동일성을 애플리케이션레벨에서 보장해줌(member1==member2)
		트랜잭션을 지원하는 쓰기지연:영속객체에 변경이 있을때마다 쿼리를 안날리고, 커밋했을때 최종변경본만 가지고 쿼리를 날릴수있음(버퍼링)
		변경감지(더티체킹):영속컨텍스트 안에있는 엔티티에 변경이 일어나면,따로 뭘 안해도 자동으로 업데이트됨(persist가 그냥 영속컨텍스트에 올리는거니..)
		지연로딩:연관관계매핑이 된 엔티티를 조회할때,프록시를 날려서 진짜로 필요할떄 조회쿼리를 날릴수있고,범위제한같은걸 할필요없이 객체처럼 쓸수있음
	이 있음
	
	더티체킹을 할때 내부적으로 체크하는로직은,트랜잭션시작시의 스냅샷을떠두고,그거랑 비교하는거
		
	플러시는 영속성컨텍스트의 변경내용을 데이터베이스에 반영하는걸 말함(따로 영속성컨텍스트를 건드리진않고,sql저장소를 db에 밀어넣는거만 함)
	플러시가 발생하면
		변경감지
		수정된 엔티티를 쓰기지연sql저장소에 등록
		쓰기지연sql저장소의 쿼리를 데이터베이스에 전송(등록,삭제,수정쿼리)
	순서로 작동함
	
	플러시는,
		em.flush를 직접 호출하거나(쓸일없는데 테스트할때는 가끔사용),
		트랜잭션 커밋이 일어나거나,
		jpql쿼리를 실행하거나(id값으로 서치하는게 아니라 다른값으로 찾기때문에 어쩔수없이 플러시가 일어나게됨)
	하면 일어남
	
	플러시는
		영속성 컨텍스트를 비우지않고
		영속성 컨텍스트를 데이터베이스에 동기화
	임
	트랜잭션이라는 작업단위를 바탕으로->커밋직전에만 동기화하면되니 기본족으로 그때 플러시를 함
		
	
	준영속상태는 영속상태엔티티가 영속컨텍스트에서 분리된 상태
	그래서 이상태에선 변경이 일어나도 db에 적용되지않음
	준영속이 되는 이유는,일반적으로 영속성컨텍스트가 초기화되거나 했을때 일어남,
	em.find하면 영속컨텍스트로 들어가니까 이런식으로 영속으로 처리하면됨
		
		
5.엔티티 매핑
	객체와 테이블매핑
		@Entity
		@Table
	필드와 컬럼매핑
		@Column
	기본키매핑
		@Id
	연관관계매핑
		@ManyToOne
		@OneToMany
		@JoinColumn
		
	@Entity가 붙은 클래스는 jpa가 관리하고,이걸 엔티티라고 함
	jpa를 사용해서 테이블과 매핑할 클래스는 @Entity가 필수임
	이때 지켜야할조건은
		기본생성자는 필수이고(파라미터가없는 public나 protected생성자),
		final이나 enum,인터페이스,inner클래스를 사용할수없고,
		저장할필드에 final을 사용할수없음
	가 있음
	@Entity에서 name으로 jpa에서 사용할 엔티티명을 정할수있는데,안넣으면 클래스명을 그대로사용하고,이렇게쓰는게좋음
	@Table에서 name으로 매핑할 테이블이름을 정할수있고,기본값은 역시 엔티티이름(@Table(name="abc") )
	@Table에서 indexes=@Index()로 인덱스를 넣을수있음
	@Column에서 name으로 매핑할 컬럼명을 정할수있고,기본값은 현재 필드이름
	@Column에서 unique나 length,nullable등으로 컬럼의 설정을 추가할수있음(ddl생성기능)
	@Column에서 insertalbe,updateable로 등록 변경 가능여부를 설정할수있음,즉 한번생성하면 변경못하게할수있는거(기본값 true)
	@Column에서 columnDefinition으로 수동으로 설정값(default같은)을 넣을수있음
	@Enumerated(EnumType.STRING)으로 enum을 사용할수있음(이떄 그냥 STRING쓰는게 좋음..Ordinal쓰레기임)
	@Temporal(TemporalType.TIMESTAMP)으로 날짜타입사용시 붙이면됨(요즘은 안씀,LocalDateTime에선 자동으로 지원하기때문)
	@Lob으로 큰 데이터를 넣을수있음(html을 통으로넣는다거나),문자면 clob,나머지는 blob로 매핑됨
	@Transient로 db에 안올리는걸 표시할수있음(객체메모리에서만 가지고있음)
	
	ddl을 사용하면 애플리케이션 생성시점에 스키마를 자동생성하고,꺼질때 자동삭제 할수있음
	이건 개발서버에서만 사용해야함 당연히,이걸가지고 좀 수정해서 개발에 임포트하면됨
	종류별로
		개발에선 create나 update(변경점만 바꿈,삭제는 안됨)
		테스트코드는 create-drop  
		테스트서버는 update나 validate
		운영이나 스테이징은 validate나 none
	이렇게쓰면됨
	ddl생성기능은 ddl을 생성할때만 사용되고,실제 jpa동작엔 영향을주지않음(notnull이나 length정도는 체크해준다고함),
	그래서 엔티티 컬럼에서 조건걸어도 jpa내부에서 체크하지않고,영속에 넣어서 db에 던져봐야 알수있음
	
	기본키매핑은 @Id로 매핑하고,@GeneratedValue로 오토인크리즈하면됨
	이때 GeneratedValue에서 strategy로 어떤식으로 생성할건지 선택할수있는데(@GeneratedValue(strategy=GeneratedType.AUTO))
		IDENTITY:db에 위임,mysql에서의 오토인크리즈먼트 mysql,코끼리db등등에서 사용됨,
			이때 db에 인서트를 날려야 id값을 알수있기때문에,이걸쓰면,persist시점에 즉시 인서트를 날리고 식별자를 받아옴
		SEQUENCE:오라클용,따로 테이블을 만들어서 최신값을 가지고있고,인서트하면 그걸넣고 +1한다고생각하면됨
		TABLE:키생성용 테이블사용,시퀸스를 모든db에서 사용하려고 만든건데 성능이슈로 잘안쓰는듯?,모든db에서 사용가능
		AUTO:니가 알아서해줘,기본값
	이렇게있음,그냥 오토쓰면됨(기본값쓰면됨)
	
	식별자의 전략은
		키는 Long로 잡고 bigint로 무지성으로 박는게좋음
		not null,유니크(프라이머리키 제약)
		업데이트불가
	자연키로는 어지간하면 안되니까 그냥 만들어쓰자(오토인크리즈나 uuid)
	
	엔티티설계할때 객체자체가 아닌 객체id를 가져오는거의 문제점(테이블이랑 같은구조,테이블의 외래키를 객체에 그대로가져옴,데이터중심설계)은		
		객체그래프의 탐색이 불가능함(그냥 객체자체로 쓰고싶은데 다시 조회를 날려야함)
	
		
6.연관관계 매핑 기초
		
		
		
		
		
		
	