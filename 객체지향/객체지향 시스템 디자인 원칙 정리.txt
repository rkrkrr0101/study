1.모든게 복잡도 관리다
*1.객체지향디자인과 시간이 주는 시련
  객체지향 디자인을 짤땐
    이 구현이 충분히 단순한가?아니면 추상화를 추가해야하나?
	이 클래스는 생명주기상 여러 상태를 거치는데,어떻게 일관된 인스턴스상태를 유지하게할까?
	이 클래스가 다른 클래스에 의존해도되나?이런 커플링이 나쁜가?
  등을 신경써야함
  
  단순한 객체지향 디자인은 항상 유지보수가 더 쉽지만,계속 단순한 디자인을 유지해나가는건 어려움

*2.단순한 객체지향 시스템 디자인
   복잡성을 줄이거나 그대로 유지하기위한 작업을 수행하지않으면 시스템은 항상 시간이 지남에 따라 복잡성이 증가함
   유지보수성이랑 비즈니스로직수정,기능추가,버그확인,시스템패치등 작업을 완료하기 위해 투입하는 노력을 말하고,
   여기에 영향을 미치는 요소는 지나치게 복잡한 코드,의존성관리,잘못된 추상화,모듈화의 부족등 다양함
   시간은 추가로 소모하더라도 복잡성증가를 꾸준히 억제하는게 중요함
   
   단순한 객체지향 디자인의 원칙은
     단순한 코드
	 일관성있는 객체
	 적절한 의존성관리
	 좋은 추상화
	 외부 의존성과 인프라를 적절히 다룸
	 잘 모듈화된 구조
   를 만족시켜야함
   
   단순한 코드는,중첩if문등으로 이해가 힘든 코드면 버그도 생기기쉽고 테스트케이스찾기도 어려움
   그래서 명확한 변수명등을 사용하고,메서드를 작게 유지하는게 좋고,클래스도 작게 유지하는게 좋음
   
   객체가 항상 일관된 상태를 유지하고,일관성을 깨뜨리기 어렵다는 믿음이 있다면,시스템작업이 훨씬 쉬워짐
   디자인을 할떄 일관성을 고려하지않으면 객체가 유효하지않은 상태를 가지게될수있어서 버그와 유지보수문제가 생길수있음
   즉 세터를 열지말고 메서드를 만들어라,검증을 해라 이쪽임
   
   의존성관리는 매우 중요함,결합도가 높고 어떤 클래스가 다른클래스와 결합된걸 신경쓰지않으면 하나의 수정이 큰 사이드이펙트를 불러일으킬수있음
   단순한 객체지향 디자인 원칙은,클래스간 의존성을 최소화하는걸 목표로 함
   클래스는 서로 덜 알수록,덜 의존할수록 더 좋음
   또한 좋은 의존성관리는 클래스가 변경가능성이 적은 안정적인 컴포넌트에 최대한 의존하게함으로(기본라이브러리등),연쇄적인 변경가능성을 줄일수있음
   
   단순한 코드는 항상 더 낫지만,확장성측면에서 부족할수있음
   이땐 좋은 추상화를 통해 복잡성을 통제하고 시스템을 발전시킬수있음(ocp)
   
   외부의존성이 도메인코드에 침투하면 인프라변경이 어려워짐
   그래서 이부분은 분리하고 의존성역전을 해야함
   
   시스템이 커지면 모든걸 한 컴포넌트나 모듈에 맞추기는 힘들어짐
   이러면 서로 상호작용하는 독립적인 컴포넌트로 나눠지는데,이러면 유지보수와 이해가 쉬워짐
   이떄 막 섞어두면 이해가 매우 어려우니까,각 모듈별로 분리해두는게 좋음(애그리거트)
  
3.일상적인 활동으로서의 단순한 디자인
  단순한 디자인을 만드는거 자체는 그리 힘들지않지만,시스템을 진화시키면서 디자인을 단순하게 유지하는건 어려움
  
  복잡성을 줄이는건 양치질과 비슷함,재밌는건 아니지만 안하면 나중에 문제가 생김
  또한 복잡성이 필요할순있지만,더 단순한 해결책을 발견했다면 리팩터링을 해야함
  
  복잡성을 정기적으로 해결하면 시간과 비용을 합리적인 수준으로 유지할수있음
  이걸 미루면 훨씬 더 많은 비용이  발생하고,리팩터링이 더 어려워짐(기술부채)
  최악은 어떤부분이 매우 복잡하고 유지보수가 어렵다는걸 알지만,아무도 리팩터링을 시도하지않는것
  
  또한 고품질코드가 있으면 코드품질이 계속 유지될 가능성이 높음(깨진유리창)
  그리고 복잡성을 통제 불가능할정도로 커지지않게 막는거의 핵심은,가능한 빨리 인식하고 일찍 해결하는것
  
  그렇다고 처음부터 복잡한 추상화를 사용하면 문제를 예방할순있지만,시스템의 복잡성이 늘어남
  
  어떤 문제에 가장 적합한 디자인에 도달하려면 세번은 다시작성해야함
  처음부터 완벽한거보단 이정도면 충분한 디자인을 만드는게 더 실용적이고,
  단순함만으로 부족한 시점을 알아차리는게 핵심임
  
4.정보시스템의 아키텍처
  컨트롤러는 사용자요청을 수신해서 비즈니스규칙을 알고있는 도메인모델에 대한 일련의 커맨드로 변환하는게 목적
  도메인모델은
    엔티티:비즈니스개념을 모델링(청구서,회원등)
	서비스:하나이상의 엔티티를 포함하는 복잡한 비즈니스로직을 캡슐화
	리포지터리:정보를 검색하고 영속화하는 db통신객체
	dto:다른계층사이에서 정보를 저장해 전달하는 클래스
	유틸리티:프레임워크가 제공하지않는 유틸리티메서드를 제공하는 클래스
  로 대략 구성됨
  
  백엔드가 일정부분 제어할수없는 모든걸 인프라라고 부름

2.코드를 작게 유지하기
*1.코드단위를 작게 만들라
  코드를 아무리 잘짜도 분량이 많으면 이해가 어려움
  이런메서드는 너무 많은일을 처리하기때문에 이해가 어려운거임
  이런 코드들은 작은단위로 나누는게 좋은 접근법임
  
  클래스나 코드가 작으면 개발자가 읽어야할 코드량이 줄어들게되고,
  작은 코드단위는 처음부터 확장가능성을 제공함(큰 코드에서 확장가능성을 찾는거보단 작은코드들의 모임에서 찾는게 더 쉬움)
  또한 테스트가능성이 좋아짐
  
  1.복잡한 메서드를 프라이빗메서드로 나눠라
    큰메서드 안에서 논리적으로 나눠지는부분을 프라이빗메서드로 뽑아내는건 쉽고 효율적인방법임
	이때 새로운 프라이빗메서드를 도입하는게 적합한지를 판단할땐
	  이름을 붙일수있는지
	  응집력있고 작으며,퍼블릭메서드가 쉽게 사용할수있는 동작을 수행하는지
	  많은 파라미터나 클래스의 의존성에 의존하는지,새 메서드의 요구사항을 빠르게 이해할수있는지
	  구현을 살펴보지않아도 이름만 봐도 기능을 충분히 설명할수있는지
	  이게 정적메서드로써 동작할수있는지(그 자체만으로 동작할수있는지) 
	가 있음
	
  2.복잡한 코드단위를 다른클래스로 옮겨라
    프라이빗메서드가 추출한 코드를 두기에 이상적인 장소가 아닐수도있음
	보통 코드가 큰단위의 해당클래스의 주요목표와 관련이 없을때 주로 그럼
	  이코드조각이 클래스의 나머지부분과 다른 작업을 하는가?
	  이코드가 도메인안에서 별도의 이름과 클래스가 필요할정도로 중요한일을 하는가?
	  이코드조각을 독립적으로 테스트하고싶은가?
	  이코드조각이 해당 클래스의 다른코드가 의존하기를 원하지않는 클래스에 의존하는가?
	  이코드크기가 너무 커서 이를 여러 프라이빗메서드로 분리하면 한 클래스안에 프라이빗메서드가 너무 많아지지않는가?
	이럴때 고려해볼수있음
	만약 새클래스가 어디있어야하고,이름이 명확히 떠오른다면 새클래스로 옮기는게 좋음(구체화될수준이라면 분리하는게맞음)

  3.코드를 작은단위로 나누지말아야할때
    코드를 굳이 나누지말아야할때도있음
      둘이상의 퍼즐조각이 독립적으로 존재할수없을때
	  퍼즐조각이 교체될가능성이 낮을때
	  해당조각만 완전히 따로떼어 테스트할만한 가치가 없을때 
	  퍼즐고각갯수가 몇개없을때
	이럴땐 나눌필요가 없음
	
  4.리팩터링하기전에 전체적으로 살펴보라
    복잡한 리팩터링에선 리팩터링이 끝난 최종코드가 어떤모습일지 상상해보는게 도움이됨
	  리팩터링후의 클래스모습은 어떤모습이고,서로 어떻게 연관되는가?
	  미래모습이 마음에 드는가?
	  디자인문제점이 보이는가?
	이정도를 해볼수있음
	  
*2.코드를 읽기쉽게 만들고 문서화하라 
  코드를 읽는데 소모하는 시간이 60%인데,이걸 줄일수록 생산성이 높아짐
  그러므로 목적은 다른사람이 쉽게 이해할수있는 코드를 만드는것
  1.좋은이름을 계속 찾아라
    변수명,메서드명등의 이름을 처음부터 완벽한 이름을 짓는건 쉽지않음
	즉 적절한 이름을 찾아낼때까지 지속적으로 고민하고 리팩터링해야함
	
	처음엔 어렴풋한 느낌만으로 만들수밖에 없는데,나중에 더 구체적인 코드가 나오게되면 이름짓는게 더 쉬워지니까 그때 찾는게 더 좋음
	이름을 붙일땐
	  클래스이름이 개념과 잘 들어맞고 개념을 대표할만한가?
	  속성이름이 클래스이름과 결이 맞으면서 속성에 저장된 정보를 잘 나타내는가?
	  메서드이름이 메서드의 기능과 메서드가 예상하는상황과 반환하는값을 잘 표현하는가?
	  인터페이스 이름이 구체적인 구현이 수행할 동작을 나타내는가?
	  서비스이름이 서비스가 수행하는 동작을 제대로 지정하는가?
	이런것들을 고려하면됨
  2.의사결정을 문서화하라
    의사결정을 명확히 하기위해 할수있는 방법들은
      복잡한 if문을 더 잘설명할수있게 코드에 변수를 추가로 도입하기
	  복잡한 의사결정 프로세스를 더 작은단계로 나누고 각 단계가 더 작은부분을 처리하게 하기
	  또한 의사결정을 설명하는 주석 작성
	가 있음
	뭘 선택하든 코드가 내릴수있는 의사결정을 명확히하는게 매우 중요함
	의사결정을 이해하면 유지보수와 디버깅이 더 쉬워지기때문

  3.코드에 주석을 추가하라
    주석은 코드에 비해 낡기쉬워서 선호되진않지만,구현을 설명하는 주석이 아닌 왜 필요한지를 설명하는거는 괜찮은 방법이고,
	왜 이방식을 선택했는지등을 설명하긴좋음
	
	물론 주석을 계속 갱신해야함
  

*3.새로운 복잡성을 기존클래스에서 분리하라
  메서드와 클래스가 무한히 성장하면 결국 유지보수가 불가능해짐
  즉 ocp를 지켜서 확장이 일어나야함
  
  1.복잡한 비즈니스로직을 자체클래스로 분리하라
    새로운 복잡한 비즈니스로직은,기존클래스가 아닌 전용 클래스로 분리하는게 좋음
	이러면 의존성측면에서도 좋고,여러군데로 응집도도 높게 가져갈수있고,기능재사용도 쉬워짐
	또한 테스트도 쉬워짐

  2.큰 비즈니스 흐름을 분해하라
    길고 복잡한 메서드는 여러단계로 이루어진 큰 비즈니스흐름을 제어할때 존재하기도함
	이런 흐름을 모델링할 추상화가 없으면 각 메서드가 흐름의 단계를 표현하는 큰 클래스가 만들어질수있음
	
	이런 큰규모의 복잡한 비즈니스 흐름은,간단하고 응집력있는 작은 코드단위로 나눠야함
	그리고 효과적인 디자인 메커니즘을 사용하여 전체흐름을 만들면됨
	
	이런경우 책임연쇄패턴이나,데코레이터,옵저버 패턴등이 유용하고,도메인이벤트도 생각해볼만함
	
	또 다른 방법으로는 이벤트기반 시스템 구축도 있긴함,단 이건 매우복잡할때 유용성이있음
  
3.객체의 일관성 유지하기
  잘 디자인된 클래스는 데이터를 캡슐화하고 데이터에 접근하거나 데이터를 조작할수있는 연산을 제공함
  oop의 가장 중요한 장점은 객체가 항상 일관된 상태를 유지하게 보장할수있다는점임
  
  코드가 적절히 캡슐화되지않으면 개발자는 어딜 수정해야할지 감을 잡을수없고 버그를 한번에 완전히 해결하기 어렵다고 느끼게됨
  즉 여러군데를 수정해야하고 관련부분을 계속찾아야함
  
  캡슐화란 데이터를 객체 안에 저장하고,객체의 연산을 통해서만 이를 조작할수있게 하는 개념으로,oop의 토대임
  이걸로 다른부분에 영향을 주지않고 클래스 내부의 세부사항을 변경할수있다
  
*1.항상 일관성을 유지하라
  객체가 일관성을 유지하면 내부상태가 요구사항이나 기대에 잘 맞춰 조화를 이루게됨
  이러면 객체가 올바르게 동작하고 정확한 결과를 제공해서 신뢰할수있는 소프트웨어를 만들수있음
  
  일관성을 테스트하는 규칙으로 이런 질문을 쓸수있음
  클래스가 객체를 일관된 상태로 만들기위해 별도의작업이 필요한가?여기서 필요하다면 클래스에 문제가 있는것
  일관된 상태를 유지하는 작업은 클라이언트의 입장에선 최소한의 노력(이상적으로는 전혀 없어야함)으로 이뤄져야함
  
  1.클래스가 스스로 일관성을 책임지게 하라
    일관성검사는 반드시 클래스내부에 구현되어야함
	어떤 클래스가 데이터일관성을 책임져야할지 확신이 서지않는다면 데이터를 포함하는 클래스가 일관성을 보장하는게 기본규칙임
	
	보통 엔티티는 데이터를 포함하는 클래스를 말하게됨
	이때 엔티티의 상태변경이 일어났을때,그거로인한 사이드이펙트처리등도 자동으로 클래스내에서 일어나야함
	
	하지만 모든 일관성로직을 클래스내부에 넣을순없음

  2.전체작업과 복잡한 일관성 검사를 캡슐화하라
    만약 객체내부의 정보만으로는 특정 일관성검사가 불가능할수있음(중복등)
	이런작업들은 엔티티내부가 아닌 응용서비스로직에서 처리되어야함
	다만 그래도 가능한 범위내에서는 최대한의 일관성을 자체적으로 유지해야함
	
	여기서 해당 엔티티에 접근하려면 서비스를 반드시 거쳐야한다는걸 말해주기좋은게 주석임
  
*2.효과적인 데이터 유효성 검사 메커니즘을 디자인하라
  시스템전반에서 데이터유효성을 검증하는건 지루하지만 상응하는 보상이 따름
  데이터유효성을 검사하는 방법엔 두가지가 있음
    메서드에서의 사전조건과 사후조건을 명시적으로 정의
	비즈니스관점에서 입력데이터 검증
  이렇게
  
  1.사전조건을 명시적으로 정의하라
    많은 버그는 메서드가 잘못된방식으로 호출될때 발생함
	이건 사용법을 모르거나 이전코드계층에서 입력한 데이터가 사전검증없이 전달되어 넘어오는등의 이유로 발생함
	
	이 사전검증없이 넘어오는건 코드에서 발견이 어려움
	그래서 사전,사후조건을 명시적으로 정의하고 문서화해야함
	
	사전조건은 메서드의 시작부분에서 각 입력의 유효성을 확인하고 범위를 벗어나면 예외를 던지는것
	이거의 장점은 좀 더 명확한 동작이 가능해진다는거고,단점은 코드가 늘어난다는것(책임도 약간 더생기고)
	
	그래도 보통 여기서 처리하는게 기본룰이긴함
	이건 이코드가 유지보수하기 쉽다 보다 이코드는 작동한다 라는 측면의 품질에 더 초점을 맞추는 드문경우긴하지만,보통 잘작동하면 유지보수도 더 쉬움
	코드가 실패하지않게 디자인할수만 있다면 유지보수에 더 유리하기때문

  2.유효성 검증 컴포넌트를 만들어라
    큰곳에선 메서드사전조건만으로 충분하지않을수있음
	단순히 내부정보만으로 처리할수없는,외부 db정보등이 필요한,즉 비즈니스로직에 가까운 사전조건이 필요할때가 있음
	이건 그 자체로는 사전조건이라고 하긴 어렵지만,요청이 이런 조건을 만족해야함
	
	이런경우엔 검증 컴포넌트를 만들어서 서비스단에서 도움을 받을수도있음
	단 이때도 엔티티는 자기가 할수있는 수준의 최대한 모든 일관성검사를 수행해야함
	
	추가적으로 같은 검증규칙을 다른 유스케이스나 서비스에서 재사용해야한다면,이걸 다른곳에서 재사용가능하게 디자인해야함
	이건 명세패턴등을 고려할수있음
	단,보통은 특정기능이나 서비스에 특화된경우가 많으니 과도하게 디자인하지않는게 좋음
	
	엔티티내부에서 검증컴포넌트를 호출하는건 많은경우에서 좋지않음
	엔티티가 외부의존성을 요구하지않는게 쓰기편함
	
	사용자가 제공한 데이터로부터 올바른 일관성검사를 수행하는 엔티티를 직접 인스턴스화하려고하면 즉각적으로 사전조건위반이 발생할수있음
	그래서 검증없이 사용자의 데이터를 저장하는 중간클래스를 도입할수있음

  3.null은 신중하게 사용하고 피할수있다면 피해라
    클래스가 null을 반환할 가능성이 있으면 클라가 모든곳에서 널검사를 수행해야함
	만약 이런경우엔 optional로 명시적으로 널을 반환하는게 좋고,가급적이면 null을 사용하지않아야함
	
	핵심은 클라가 예상치못하게 놀라는일을 막아야함
	
*3.상태확인을 캡슐화하라
  클라는 종종 결정을 내릴때 객체 상태를 알아야함
  그런데 비즈니스로직은 잘 캡슐화하지만,상태확인도 캡슐화해야함
  
  즉 get으로 직접 접근하는거보단,해당 검증로직을 캡슐화해서 거기서 값을 받아오는게 좋음
  이러면 변경에 대해 한단계 캡슐화가 됨으로써 산탄총수술을 막을수있음
  
  즉 클라는 객체내부의 구현세부사항에 대해 알필요가 없어야하고,상태를 get할땐 직접 가져오는게 아닌 캡슐화된 메서드를 통해 가져와야함
  
  클래스가 복잡해질수록 이건 더 중요해짐
  
  1.명령하라,질문하지 마라
    클라가 객체에게 정보를 물어보고 직접 일을 하지말고,객체에게 일을 시키는형태로 만들어지는게 유지보수에 좋음
	해당 객체가 그 일을 처리할수있는 모든 정보가 있다면,해당 객체에게 시키는게 메서드 내부만 수정하면돼서 여러군데를 수정하지않아도됨

*4.필요한 게터와 세터만 제공하라
  클래스가 속성을 자유롭게 변경할수있다면 일관성보장이 힘듬
  그렇다고 클라가 속성에 상호작용할수없으면 프로그램이 돌아가지않음
  
  1.상태를 변경하지않고 클라이언트에 너무 많은정보를 노출하지않는게터
    게터는 절대 상태를 변경하면안됨,필수임
	메서드는 명령 혹은 쿼리 둘중 하나여야함

  2.세터는 객체를 설명하는 속성에만 사용한다
    일관성검사가 필요한속성엔 세터가 있으면 안되고,안전하게 작업을 수행할수있는 캡슐화된 메서드를 대신 제공해야함
	세터를 사용할때 안전한 기준은,해당 가변속성이 주로 객체를 설명하는거면 괜찮음(description,name같은거)
	이런건 문제를 일으킬확률이 적음,그러나 다른것들은 어지간하면 막는게 좋음


*5.객체집단의 불변조건을 보장하도록 애그리거트를 모델링하라
  애그리거트 루트는 외부에서 단일객체로 간주되는 객체들의 집단임
  루트는 전체 객체트리에 대해 일관성을 보장하고,클라는 루트에만 접근할수있음
  
  이렇게 애그리거트 루트를 모델링하는건 디자인과정에서 명시적으로 이뤄져야함
  루트안의 객체를 식별하고,이를 루트를 통해서만 접근하게 보장하는건 중요한 디자인작업이고,유지보수단계에서 그 비용을 돌려받기쉬움
  이렇게 모든작업이 루트를 통해 이뤄지면 일관성유지가 쉬움
  
  루트는 시스템안에서 여기저기 전달할 단위임
  객체를 db에 저장할떄도 특정 내부객체가 아닌 루트 전체를 전달해야함
  즉 루트별로 리포지터리를 가져야함
  
  1.애그리거트 루트의 규칙을 깨지마라
    하위객체를 직접 조작하고 싶은 유혹이 있을수있음
	  일부 프레임워크나 라이브러리가 요구할때(엔티티별로 리포지터리생성등)
	  직접 접근하는게 성능상 나을때
	  깊은객체집단을 포함하는 루트의경우,작은변경에도 지나치게 많은 보일러플레이트가 필요
	물론 트레이드오프니까 가능하긴함
	단,일관성과 유지보수성을 다른 이점과 교환하는거고,이 이득과 손실을 명확히 알고 선택해야함
	이때 사용할만한 체크리스트론
	  애그리거트 규칙을 깨는 이점이 유지보수비용을 낮추고 불변성을 항상 최신상태유지하는 비용보다 큰가?
	  루트를 거치지않고 일부를 직접 변경하고싶다면,해당객체가 정말 애그리거트의 일부분인가?
	  유지해야할 불변규칙이 있는경우,여전히 루트를 깨고 두 애그리거트의 최종일관성을 받아들여야하는가?도메인이벤트로 변경통지받는건 안되나?
	정도가 있음

4.의존성 관리하기
*1.고수준코드와 저수준코드를 분리하라
  대부분의 비즈니스기능은 고수준과 저수준 두가지 관점에서 볼수있음
  고수준은 기능이 뭘하는지를 기술하고,저수준은 작업을 어떻게 수행할지를 기술함
  
  이렇게 나누면 유지보수에 좋고,복잡한기능과 비즈니스로직이 있을때 더 효과적임
  이 패턴을 따르면 
    코드를 유지보수할때 고수준부터 시작하면 기능이해가 쉬움(고수준만 이해하면됨),세부사항을 숨겨서 중요한부분에 집중할수있어짐
	고수준코드와 저수준코드를 분리하면 각각 따로 변경하고 발전시킬수있음(dip)
	고수준은 일반적으로 더 추상적이고,결과적으로 더 안정적임,즉 고수준에만 의존하면 변경으로 인한 영향을 덜받을수있음
  세부사항이 아니라 추상화에 의존하면(dip),이런 이점들을 챙길수있음
  고수준과 저수준을 분리하는건 불필요한 추상화를 만드는것보다 더 중요함
  
  1.안정적인 코드를 디자인하라
    보통 고수준코드를 작성할땐 대부분 안정적인 코드가 나오게됨(인터페이스처럼)
  2.인터페이스 발견
    모든 고수준 코드를 먼저 작성하고 세부구현은 나중에 처리하는 프로그래밍 스타일은,고수준과 저수준을 명확히 분리할수있고 작업진행이 막히는것도 방지할수있음
  3.고수준과 저수준을 분리하지않아도 되는경우
    간단한 코드에선 고수준기술과 구현을섞는게 허용됨
	물론 복잡성이 증가하면 리팩터링해야함
	
	절대 섞으면 안되는건 인프라코드와 비즈니스로직임
	즉 db와 웹같은것과 비즈니스로직은 섞이면안됨
  
*2.불필요한 세부사항이나 요소에 의존하는걸 피하라
  좋은 의존성관리의 첫규칙은 다른 클래스나 구성요소의 세부사항에 의존하지않는것
  이걸 달성하는 가장 좋은방법은 클래스가 처음부터 자신의 세부사항을 노출하지않는것
  
  즉 캡슐화등을 통해 정보은닉을 달성해야함
  이러려면 변경가능성이 높은것과 그렇지않은걸 분리해서 어떤 요소를 변경해도 다른게 변경될필요가 적게 만드는게 핵심아이디어임
  
  모든클래스의 세부사항을 숨길순없지만,뭘 노출하고 뭘 감출지는 명시적으로 디자인할수있음
  이때
    이 클래스의 내부구현을 리팩터링하면 클라가 영향을 받나?
	이 코드를 자주 변경해야하나?그러면 인터페이스로 감출순없나?
	이 정보가 클라가 알아야할 최소정보인가?
	불필요하게 구현세부사항을 노출하진않나?
  등을 신경써야함
  1.내가 소유한 클래스만 요구하거나 반환하라
    즉 서드파티나 프레임워크의 클래스만 파라미터로 받거나,리턴하는게 좋음
	즉 내가 완전히 통제할수있는거만 메시지로 사용하는것(최소한 래퍼라도 사용)
	
	이 패턴은 코드를 다른모듈과 통합할때 드러남
	이러면 강결합이 줄어들어,기존 모듈에서 다른모듈로 바꾸거나 추가할때 변경해야하는게 줄어듬(캡슐화)
	
	결합을 완전히 피할순없지만,코드가 어떤것에 결합될지는 통제할수있음
	단 이때 과도한 간접계층이나 불필요하게 복잡한 코드가 생기지않게 주의해야함
	떄론 서드파티클래스가 반드시 필요한것일수도 있음
	
	그리고 리턴값으로는 내 클래스를 반환하는게 가장 합리적임
	그러나 모든프레임워크의 모든클래스를 래핑할 필요는 없음
	스프링부트처럼 프로젝트의 핵심이라면 그냥 써도됨
	이게 도메인에 퍼지지는 않게해야겠지만,그 외에서는 그냥쓰면됨
	프레임워크 독립적이지않더라도 큰문제가 되지않기때문

  2.클라에게 필요한것 이상을 제공하지마라
    값을 리턴해줄때도 클라가 요청한것까지만 리턴하고,그이상의 정보는 주지않는게 좋음
	즉 기존클래스를 재사용하지말라는것
	
	그렇지않으면 엔티티의 모든 변경사항이 클라에 전파되고,이로인해 보안문제도 있을수있음
	가장 큰 이유는 사이드이펙트의 통제가 힘들어진다는것
	일단 엔티티와 리턴값을 분리하는게 가장 좋음(읽기전용 클래스로 정보추상화)

*3.너무많은 클래스에 의존하는 클래스를 분리하라
  코드는 모든차원에서 작아야하고,여기는 의존성도 포함됨
  한 클래스가 10개의 다른클래스에 의존한다면 이건 디자인에 문제가 있는거고,리팩토링대상임
  
  기능이 복잡해지면 의존성수가 증가함
  기존기능에 새기능을 추가할땐,
    현재의 코드에 추가(의존성증가 x,복잡성 증가 o)
    새 클래스를 생성해 기존클래스와 연결(의존성증가 o,복잡성 증가 x)
  이렇게 두가지 방법이 있음
  
  한클래스가 너무 많은 다른클래스에 의존하고,각 클래스가 커지기 시작하면 순환을 끊어야함
  즉 중간클래스를 두고,해당클래스가 하위클래스를 의존하게 묶는식으로 의존성갯수를 컨트롤할수있음
  원래클래스는 좀 더 고수준으로 올라간다는느낌(간접결합)

*4.의존성을 주입하라
  실행시점에 클래스에 서로다른 구현을 전달할수있으면 유연성이 높아짐
  그래서 사용되는게 의존성주입임
  또한 의존성주입을 사용하면 테스트가능성도 향상됨(목객체 넣기가 편함)
  
  의존성주입의 가장 좋은점은 구현이 쉽다는것
  의존성을 직접 인스턴스화할필요 없고,그냥 생성자만 만들면됨
  
  1.상태변경에 정적메서드를 사용하지마라
    정적메서드는 런타임에 교체할수없어서 디자인이 유연하지않고 테스트가 어려움
	어떤 작업이 정적메서드가 될수있는지 여부는,그 작업이 순수함수면 가능함
	이런경우 프로덕션이나 테스트중에 교체할일이 없기때문
	그런데 보통 서비스메서드같이 시스템상태를 변경하거나,입력이 같은데 다른출력을 낼수있는경우엔 정적메서드로 만들지않는게 좋음

  2.항상 협력자를 주입하라:그외에는 맘대로해라
    협력자는 항상 주입되어야함,여기서 협력자란 해당 클래스가 메서드를 제공하기위해 도움을 받는 클래스들을 말함
	보통 생성자로 받는 애들은 보통 협력자임(그래서 어지간한 언어에서는 없으면 안만들어짐)
	
	그러나 모든 의존성(import)가 협력자는 아님,보통 엔티티같은건 그냥 의존은 하지만 협력하진않음,그냥구조체로 사용되기도함

  3.클래스와 의존성을 함께 생성하는 전략
    보통 프레임워크쓰면 알아서 의존성을 주입해서 만들어줌
	간단한경우는 직접 만들거나 팩토리클래스를 사용해도 되긴함


5.추상화 잘 디자인하기
  좋은추상화는 기존코드를 자주 변경하지않고도 기능을 추가할수있게 해줌
  쿠폰,할인정책등이 대표적
  추상화란
    추상화는 개념,기능,프로세스를 설명하되,클라가 내부메커니즘을 알지못해도 이해할수있는방식으로 설명함
	추상화는 본질적인 특성에 집중하고,비본질적인 특성은 무시함
	추상화는 구체적인 구현에 신경쓰지않음
  추상화는 확장지점에서 잘 작동하고,확장지점은 개발자가 시스템의 기능을 확장하거나 수정할수있게 해줌
  추상화는 모호해지는게 아닌,새로운 의미수준을 만드는것(저수준 고수준 이런느낌)
  
*1.추상화와 확장지점을 디자인하라
  1.추상화의 필요성 식별하기
    추상화는
	  다양한 변경이 필요한 기능
	  조합성면에서 유연함이 필요한기능,기능에 변형이 많고 클라마다 다른조합을 구성해야할때
	  향후 변경이 예상되는부분
	  시스템의 나머지부분에서 숨기고싶은 코드(인프라)
	이런 부분이 있을때 주로 추상화를 도입할수있음(다른이유도 많음)

  2.확장지점 디자인하기
    때론 클라가 구현체가 아닌 추상화(인터페이스)를 사용하는것만으로 충분할때가 있음
    클라가 구현이 아닌 추상화에 의존하면 세부사항과 분리됨
	이러면 클라를 수정하지않아도 구현을 다른걸로 교체할수있음
	
	또한 추상화를 디자인해 기능에 유연성과 변화를 제공하기도함
	
	확장지점을 디자인할지말지는 추상이 어떻게 사용될지에 달려있음
	추상화를 만드는데 그치지말고,이를 사용할사람들의 입장에서도 생각해봐야함
	
	이런 확장지점은 오픈소스라이브러리에서 자주볼수있음
	보통 커스텀머시기가 붙으면 이런 확장지점임

  3.좋은 추상화의 속성
    좋은 추상화는 무엇과 어떻게를 분리함
	즉 무엇을 해야하는데 초점을 맞추고,그걸 어떻게할건진 신경쓰지않음
	즉 좋은 추상화는 계약을 정의함(사전조건,사후조건,불변식)
	
	추상화가 적절히 이뤄졌다면 다양한 구체적 구현을 쉽게 작성할수있어야함
	좋은추상화는 문서화가 잘되어있고,다른사람에게 물어보지않아도 모든걸 배울수있어야함
	
	또한 클라가 사용하기좋아야함
	몇줄의 코드만으로 추상화의 대부분을 만족시킬수있어야함
	즉 직관적이고 단순해야함
	
	자신이 변경되거나 발전되더라도 확장지점을 꼭 변경할필요가 없어야함
	좋은추상화는 안정적이고 자주바뀌지않음
	그래서 추상화에 의존하는게 더 불안한 구체구현에 의존할때보다 문제가 적음
	
	또한 추상화 자체의 코드를 변경하지않아고 구체적인 구현을 플러그인처럼 추가하거나 제거할수있어야함

  4.추상화에서 배워라
    추상화와 확장지점은 실제용례를 기반으로 계속 개선되어야함
	요구사항이 변화한다면,그걸 충족시키기위해 지속적으로 개선되어야함
	
	물론 안정적이어야하는 추상화가 계속 변경되면 문제가 될수있음,즉 트레이드오프임
	
	추상화에 대해 더 알고싶다면,디자인패턴을 보는게 도움이 많이됨

  5.추상화와 결합
    의존성관리와 좋은 추상화디자인은 서로 보완관계임
	좋은 추상화는 보통 안정적이고,추상화에 경합되는건 그래서 보통 문제가 되지않음
  
2.더 중요한 비즈니스로직을 일반화하라
  같은 비즈니스로직을 서로 다른 맥락에서 약간씩 다른 구체적인 값으로 적용해야할때,추상화가 없다면 코드를 복사해서써야함(if문떡칠이나)
  이러면 유지보구가 매우힘듬
  
  그래서 일반적인 비즈니스로직을 식별하고,이를 추상화한후 구체구현은 각각 하위클래스에 맡겨야함
  
  1.일반화된 비즈니스로직과 구체데이터를 분리하라
    보통 비즈니스로직일반화의 주된 어려움은 데이터에 관련됨
	데이터는 보통 db에서 나오고,데이터조회와 로직이 섞이면 머리아파짐
	
	코드에 데이터검색과 로직을 섞지말고,서로 분리해둬야 유연성을 챙길수있음
	비즈니스로직은 특정데이터에 종속되면안되고,일반적인값에 의존해야함

*3.단순한 추상화를 선호하라
  추상화는 코드에 복잡성을 더함
  추상화는 최소한의 동작만을 나타내야하고,나머지는 구체적인 구현에 위임해 가능한 단순하게 유지해야함
  
  1.경험적 규칙
    최적의 디자인을 선택하는건 까다로움
	확장지점과 추상화를 사용하면 유연성이 올라가지만,복잡성도 올라감
	즉 트레이드오프임
	이때 도움이 되는 규칙은
	  추상화가 정말 필요한가?
	  추상화의 필요성을 보여주는 명확한 증거가있나?
	  좋은 추상화가 필요하게 되리라는 사실을 알고있나?
	이 3가지를 생각해볼수있음

  2.단순한것이 항상 더 낫다
    코드를 단순하게 유지하는게 항상 최선의 선택임
	코드를 추상화할 명확한 이유가 없다면 추상화를 하지않는게 좋음
	인덱스랑 비슷하게,확실하게 손해가 나고,조건에 따라 이득을 볼수있는 형태임
	
	그렇다고 추상화를 해야하는데 하지않으면 안됨
	잘못된 추상화보단 중복이 저렴하지만,중복은 잘된 추상화보다 비용이 더 많이듬

  3.이쯤되면 추상화를 고려해야한다
    두번째 중복까진 그냥 중복으로 넘어갈수있지만,세번째중복으로 if문이 길어지거나 한다면 이지점부터 추상화도입을 생각해볼수있음
	추상화가 필요한지 판단할때 고려할사항은
	  같은클래스를 계속 반복적으로 수정하고있는가?
	  클래스가 계속 커지고있는가?
	  변화를 구현하기위해 if문을 계속 사용하는가?
	  기존 비즈니스규칙을 시스템의 다른부분에 결합시키는 과정이 어거지로 붙이는거같은가?
	이런것들을 생각해볼수있음
	
	근데 경험상 좀 추상화를 약간 오버하는느낌으로 하는게,나중에 리팩터링하는거보다 비용이 싸긴했음

  4.처음부터 추상화를 모델링하는것을 두려워하지마라
	만약 처음부터 유연성이 필요하다는 확신이 드는 지점이 있다면,구현이 한두개뿐이더라도 처음부터 추상화를 만들어도됨
	이런경우 단순한코드로 시작하는게,피할수없는문제를 뒤로 미루는,비용이 더 비싼 문제일수있음

6.외부의존성과 인프라 다루기
  외부의 세부사항은 테스트를 방해해서 도메인로직을 독립적으로 테스트하기 힘들게함
  또한 캡슐화를 하지않으면 코드가 서드파티api의 데이터구조 및 추상화에 강결합을 함
  보통 라이브러리들은 안정적이지않아서,거기의존하는건 위험함
  마지막으로,인프라는 저수준코드를 포함하고,캡슐화없이 변경이 어려움
  
  처음엔 인프라를 추상화하는 인터페이스를 추가하는걸로도 충분하지만,좀 더 나아가면 여러 생각해볼만한게 있음
  잘 디자인된 추상화는 인프라의 세부사항을 감춰 나머지부분이 이에 영향을 받지않게함
  그런데 여기서 트레이드오프가 있는데,특정 db에만 있는 기능이 있다면,이것도 세부사항이기때문에(모든db에 있지않으니까) 이걸 사용할 방법이 없어짐
  즉 어려운건 기저인프라의 이점을 사용하면서 그런 세부사항에 오염되지않게하는게 어려움
 
*1.도메인코드와 인프라를 분리하라
  비즈니스로직이 포함된 클래스안에서 인프라를 다루면 안됨
  이건 반드시지켜야할 규칙이고,따르기도 쉽고 빠르게 효과를 볼수있는 당연한규칙임
  
  대신 어플리케이션과 외부시스템간의 통신을 나타내는데 전적으로 사용되는 클래스에서 인프라처리코드를 작성하는게 좋음
  
  보통 db접근의 경우 일반적으로 비즈니스로직과 분리시키지만,이것만으로 끝나는게 아니고 외부api,파일접근등도 추상화시키는게좋음
  
  1.인터페이스가 필요한가?
    인프라와 도메인코드를 명시적으로 분리하는 인터페이스를 사용하는건 좋은 아이디어임
	이건 인프라의 구현을 변경하는것도 용이해지지만,가장 주된 이유는 인프라에 직접 의존하지않는 코드를 작성하기위해서 사용됨
	인터페이스는 인프라에 대해 기대하는 메서드집합만 정의할수있고,그이상의 정의는 불가능함
	
	보통 클린아키텍처분류들이 사용하는방식이 이런방식임
	도메인언어를 사용하는 인터페이스를 두고,구현세부사항이 누출되지않게하는것
	근데 도메인언어를 사용하고,구현세부사항을 누출하지않으면 클래스하나도 될때가 있음
	  같은 인프라에 대해 여러 구현이 있을걸로 예상되면 즉시 인터페이스 생성
	  특정인프라 세부사항에 대한 지식이 제한적이라면 인터페이스 생성
	  해당 인프라를 여러곳에서 사용할거면 인터페이스에 의존하는게 좀 더 나음
	  기저인프라가 복잡하면 단일클래스로 세부사항이 누출되지않게하는게 더 어려움,또한 인터페이스를 사용하면 처음부터 디자인을 신중히 해야함
	인터페이스 유무와 상관없이 코드는 잘 캡슐화되고 구현세부사항이 코드에 대해서는 숨겨지되 개발자에겐 숨겨지지않아야함

  2.코드에서는 세부사항을 숨기고,개발자에게는 숨기지마라
    구현변경의 영향을 최소화하기위해 세부사항을 숨기는거임
	굳이 개발자에겐 숨길필요가 없음
	내부동작을 이해해야 최적화되고 효율적인 코드를 작성할수 있는경우가 많기때문
	
	물론 인프라를 어느수준까지 추상화할진 트레이드오프임
	인프라를 단순한 세부사항으로 취급하냐,인프라는 정보시스템과 통합된 일부로 취급하냐임
	적당히 중간에 잡는게 인프라관련코드는 최대한 격리하고 개발자가 이해는 하는것임

  3.인프라 변경하기:괜한걱정일까 실제로 일어날까?
    인프라를 완전히 교체하는일은 드물지만,인프라는 시간이 지남에 따라 지속적으로 진화함
	나머지 시스템을 깨뜨리지않으면서 구현하고싶은 인프라 진화가 있는 경우가 좀 있음
	  캐싱이 필요해졌는데,코드전체를 수정하지않고 특정쿼리를 캐싱하고싶을떄
	  읽기복제본을 도입하고싶은데,인프라추상화가 이를 처리하게하고싶을때
	  웹서비스를 호출할때 사용하는 인증매커니즘의 변경으로,호출코드를 변경해야할때
	  온프레미스 디스크에서 s3로 전환할때
	이런식으로 조금씩 바뀌는데,이럴때 추상화가 있으면 변화가 쉬움

*2.인프라를 최대한 활용하라
  1.디자인을 망가뜨리지않게 최선을 다하라
    모든 선택은 트레이드오프임
	만약 과거의 선택을 우회해서 뭘 하고싶다면,그게 반드시 필요한것인지,아니면 아예 과거의 선택을 리팩터링해야할지를 검토하는게 좋음
	디자인을 깨뜨리는건 최후의 선택이고,가능한 피해야함

*3.자신이 소유한것에만 의존하라
  외부라이브러리와 시스템코드를 도입할땐,이 여파가 코드 전역에 퍼지지않게 계층을 설정하는게 중요함
  이런 래퍼가 특정부분에만 외부라이브러리가 영향을 끼치게 막아줌
  이 래퍼의 핵심은,데이터구조를 완전히 우리가 제어할수있고,그변경사항을 관리할수있다는것
  라이브러리가 변경되더라도 래퍼만 변경하면됨
  
  1.프레임워크와 싸우지마라
    모든 의존성과 분리하는것도 불가능한 목표임
	만약 스프링을 사용한다면,가급적 도메인에서 스프링기능을 사용하는건 피하지만,컨트롤러나 서비스에선 그냥 사용하는게 나음
	또한 영속성프레임워크로 하이버네이트를 선택하고,db로 mysql을 선택했다면,이 둘의 의존성을 분리하는것도 의미가 없음
	단지 코어와 분리하는게 주요목적이 되어야함

  2.간접 누출에 주의하라
    인터페이스는 외부로부터 구현세부사항을 감추기 좋음
	그런데 이렇게 감춘 세부사항도 코드에 누출될수있음(간접적으로)
	
	이런 동작이 바람직한지 아닌지,디자인을 얼마나 보호해야하는진 직접 결정해야함
	만약 바람직하지않다면,중간에 추가계층을 두는방법도있음


*4.저수준 인프라 오류를 고수준 도메인 오류로 캡슐화하라
  인프라계층에서 나는 예외들중,직접 복구가 가능한건 직접 복구하고,복구할수없다면 저수준 오류를 고수준의 도메인관련 오류로 변환해서 내보는게 좋음
  이때 로그로는 남겨야함
  프레임워크의 예외클래스가 코드기반 전체에 퍼지지않게하는게 좋음

7.모듈화 달성하기

































 
  
  
  
  