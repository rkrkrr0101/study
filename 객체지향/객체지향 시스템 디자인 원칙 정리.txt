1.모든게 복잡도 관리다
*1.객체지향디자인과 시간이 주는 시련
  객체지향 디자인을 짤땐
    이 구현이 충분히 단순한가?아니면 추상화를 추가해야하나?
	이 클래스는 생명주기상 여러 상태를 거치는데,어떻게 일관된 인스턴스상태를 유지하게할까?
	이 클래스가 다른 클래스에 의존해도되나?이런 커플링이 나쁜가?
  등을 신경써야함
  
  단순한 객체지향 디자인은 항상 유지보수가 더 쉽지만,계속 단순한 디자인을 유지해나가는건 어려움

*2.단순한 객체지향 시스템 디자인
   복잡성을 줄이거나 그대로 유지하기위한 작업을 수행하지않으면 시스템은 항상 시간이 지남에 따라 복잡성이 증가함
   유지보수성이랑 비즈니스로직수정,기능추가,버그확인,시스템패치등 작업을 완료하기 위해 투입하는 노력을 말하고,
   여기에 영향을 미치는 요소는 지나치게 복잡한 코드,의존성관리,잘못된 추상화,모듈화의 부족등 다양함
   시간은 추가로 소모하더라도 복잡성증가를 꾸준히 억제하는게 중요함
   
   단순한 객체지향 디자인의 원칙은
     단순한 코드
	 일관성있는 객체
	 적절한 의존성관리
	 좋은 추상화
	 외부 의존성과 인프라를 적절히 다룸
	 잘 모듈화된 구조
   를 만족시켜야함
   
   단순한 코드는,중첩if문등으로 이해가 힘든 코드면 버그도 생기기쉽고 테스트케이스찾기도 어려움
   그래서 명확한 변수명등을 사용하고,메서드를 작게 유지하는게 좋고,클래스도 작게 유지하는게 좋음
   
   객체가 항상 일관된 상태를 유지하고,일관성을 깨뜨리기 어렵다는 믿음이 있다면,시스템작업이 훨씬 쉬워짐
   디자인을 할떄 일관성을 고려하지않으면 객체가 유효하지않은 상태를 가지게될수있어서 버그와 유지보수문제가 생길수있음
   즉 세터를 열지말고 메서드를 만들어라,검증을 해라 이쪽임
   
   의존성관리는 매우 중요함,결합도가 높고 어떤 클래스가 다른클래스와 결합된걸 신경쓰지않으면 하나의 수정이 큰 사이드이펙트를 불러일으킬수있음
   단순한 객체지향 디자인 원칙은,클래스간 의존성을 최소화하는걸 목표로 함
   클래스는 서로 덜 알수록,덜 의존할수록 더 좋음
   또한 좋은 의존성관리는 클래스가 변경가능성이 적은 안정적인 컴포넌트에 최대한 의존하게함으로(기본라이브러리등),연쇄적인 변경가능성을 줄일수있음
   
   단순한 코드는 항상 더 낫지만,확장성측면에서 부족할수있음
   이땐 좋은 추상화를 통해 복잡성을 통제하고 시스템을 발전시킬수있음(ocp)
   
   외부의존성이 도메인코드에 침투하면 인프라변경이 어려워짐
   그래서 이부분은 분리하고 의존성역전을 해야함
   
   시스템이 커지면 모든걸 한 컴포넌트나 모듈에 맞추기는 힘들어짐
   이러면 서로 상호작용하는 독립적인 컴포넌트로 나눠지는데,이러면 유지보수와 이해가 쉬워짐
   이떄 막 섞어두면 이해가 매우 어려우니까,각 모듈별로 분리해두는게 좋음(애그리거트)
  
3.일상적인 활동으로서의 단순한 디자인
  단순한 디자인을 만드는거 자체는 그리 힘들지않지만,시스템을 진화시키면서 디자인을 단순하게 유지하는건 어려움
  
  복잡성을 줄이는건 양치질과 비슷함,재밌는건 아니지만 안하면 나중에 문제가 생김
  또한 복잡성이 필요할순있지만,더 단순한 해결책을 발견했다면 리팩터링을 해야함
  
  복잡성을 정기적으로 해결하면 시간과 비용을 합리적인 수준으로 유지할수있음
  이걸 미루면 훨씬 더 많은 비용이  발생하고,리팩터링이 더 어려워짐(기술부채)
  최악은 어떤부분이 매우 복잡하고 유지보수가 어렵다는걸 알지만,아무도 리팩터링을 시도하지않는것
  
  또한 고품질코드가 있으면 코드품질이 계속 유지될 가능성이 높음(깨진유리창)
  그리고 복잡성을 통제 불가능할정도로 커지지않게 막는거의 핵심은,가능한 빨리 인식하고 일찍 해결하는것
  
  그렇다고 처음부터 복잡한 추상화를 사용하면 문제를 예방할순있지만,시스템의 복잡성이 늘어남
  
  어떤 문제에 가장 적합한 디자인에 도달하려면 세번은 다시작성해야함
  처음부터 완벽한거보단 이정도면 충분한 디자인을 만드는게 더 실용적이고,
  단순함만으로 부족한 시점을 알아차리는게 핵심임
  
4.정보시스템의 아키텍처
  컨트롤러는 사용자요청을 수신해서 비즈니스규칙을 알고있는 도메인모델에 대한 일련의 커맨드로 변환하는게 목적
  도메인모델은
    엔티티:비즈니스개념을 모델링(청구서,회원등)
	서비스:하나이상의 엔티티를 포함하는 복잡한 비즈니스로직을 캡슐화
	리포지터리:정보를 검색하고 영속화하는 db통신객체
	dto:다른계층사이에서 정보를 저장해 전달하는 클래스
	유틸리티:프레임워크가 제공하지않는 유틸리티메서드를 제공하는 클래스
  로 대략 구성됨
  
  백엔드가 일정부분 제어할수없는 모든걸 인프라라고 부름

2.코드를 작게 유지하기
*1.코드단위를 작게 만들라
  코드를 아무리 잘짜도 분량이 많으면 이해가 어려움
  이런메서드는 너무 많은일을 처리하기때문에 이해가 어려운거임
  이런 코드들은 작은단위로 나누는게 좋은 접근법임
  
  클래스나 코드가 작으면 개발자가 읽어야할 코드량이 줄어들게되고,
  작은 코드단위는 처음부터 확장가능성을 제공함(큰 코드에서 확장가능성을 찾는거보단 작은코드들의 모임에서 찾는게 더 쉬움)
  또한 테스트가능성이 좋아짐
  
  1.복잡한 메서드를 프라이빗메서드로 나눠라
    큰메서드 안에서 논리적으로 나눠지는부분을 프라이빗메서드로 뽑아내는건 쉽고 효율적인방법임
	이때 새로운 프라이빗메서드를 도입하는게 적합한지를 판단할땐
	  이름을 붙일수있는지
	  응집력있고 작으며,퍼블릭메서드가 쉽게 사용할수있는 동작을 수행하는지
	  많은 파라미터나 클래스의 의존성에 의존하는지,새 메서드의 요구사항을 빠르게 이해할수있는지
	  구현을 살펴보지않아도 이름만 봐도 기능을 충분히 설명할수있는지
	  이게 정적메서드로써 동작할수있는지(그 자체만으로 동작할수있는지) 
	가 있음
	
  2.복잡한 코드단위를 다른클래스로 옮겨라
    프라이빗메서드가 추출한 코드를 두기에 이상적인 장소가 아닐수도있음
	보통 코드가 큰단위의 해당클래스의 주요목표와 관련이 없을때 주로 그럼
	  이코드조각이 클래스의 나머지부분과 다른 작업을 하는가?
	  이코드가 도메인안에서 별도의 이름과 클래스가 필요할정도로 중요한일을 하는가?
	  이코드조각을 독립적으로 테스트하고싶은가?
	  이코드조각이 해당 클래스의 다른코드가 의존하기를 원하지않는 클래스에 의존하는가?
	  이코드크기가 너무 커서 이를 여러 프라이빗메서드로 분리하면 한 클래스안에 프라이빗메서드가 너무 많아지지않는가?
	이럴때 고려해볼수있음
	만약 새클래스가 어디있어야하고,이름이 명확히 떠오른다면 새클래스로 옮기는게 좋음(구체화될수준이라면 분리하는게맞음)

  3.코드를 작은단위로 나누지말아야할때
    코드를 굳이 나누지말아야할때도있음
      둘이상의 퍼즐조각이 독립적으로 존재할수없을때
	  퍼즐조각이 교체될가능성이 낮을때
	  해당조각만 완전히 따로떼어 테스트할만한 가치가 없을때 
	  퍼즐고각갯수가 몇개없을때
	이럴땐 나눌필요가 없음
	
  4.리팩터링하기전에 전체적으로 살펴보라
    복잡한 리팩터링에선 리팩터링이 끝난 최종코드가 어떤모습일지 상상해보는게 도움이됨
	  리팩터링후의 클래스모습은 어떤모습이고,서로 어떻게 연관되는가?
	  미래모습이 마음에 드는가?
	  디자인문제점이 보이는가?
	이정도를 해볼수있음
	  
*2.코드를 읽기쉽게 만들고 문서화하라 
  코드를 읽는데 소모하는 시간이 60%인데,이걸 줄일수록 생산성이 높아짐
  그러므로 목적은 다른사람이 쉽게 이해할수있는 코드를 만드는것
  1.좋은이름을 계속 찾아라
    변수명,메서드명등의 이름을 처음부터 완벽한 이름을 짓는건 쉽지않음
	즉 적절한 이름을 찾아낼때까지 지속적으로 고민하고 리팩터링해야함
	
	처음엔 어렴풋한 느낌만으로 만들수밖에 없는데,나중에 더 구체적인 코드가 나오게되면 이름짓는게 더 쉬워지니까 그때 찾는게 더 좋음
	이름을 붙일땐
	  클래스이름이 개념과 잘 들어맞고 개념을 대표할만한가?
	  속성이름이 클래스이름과 결이 맞으면서 속성에 저장된 정보를 잘 나타내는가?
	  메서드이름이 메서드의 기능과 메서드가 예상하는상황과 반환하는값을 잘 표현하는가?
	  인터페이스 이름이 구체적인 구현이 수행할 동작을 나타내는가?
	  서비스이름이 서비스가 수행하는 동작을 제대로 지정하는가?
	이런것들을 고려하면됨
  2.의사결정을 문서화하라
    의사결정을 명확히 하기위해 할수있는 방법들은
      복잡한 if문을 더 잘설명할수있게 코드에 변수를 추가로 도입하기
	  복잡한 의사결정 프로세스를 더 작은단계로 나누고 각 단계가 더 작은부분을 처리하게 하기
	  또한 의사결정을 설명하는 주석 작성
	가 있음
	뭘 선택하든 코드가 내릴수있는 의사결정을 명확히하는게 매우 중요함
	의사결정을 이해하면 유지보수와 디버깅이 더 쉬워지기때문

  3.코드에 주석을 추가하라
    주석은 코드에 비해 낡기쉬워서 선호되진않지만,구현을 설명하는 주석이 아닌 왜 필요한지를 설명하는거는 괜찮은 방법이고,
	왜 이방식을 선택했는지등을 설명하긴좋음
	
	물론 주석을 계속 갱신해야함
  

*3.새로운 복잡성을 기존클래스에서 분리하라
  메서드와 클래스가 무한히 성장하면 결국 유지보수가 불가능해짐
  즉 ocp를 지켜서 확장이 일어나야함
  
  1.복잡한 비즈니스로직을 자체클래스로 분리하라
    새로운 복잡한 비즈니스로직은,기존클래스가 아닌 전용 클래스로 분리하는게 좋음
	이러면 의존성측면에서도 좋고,여러군데로 응집도도 높게 가져갈수있고,기능재사용도 쉬워짐
	또한 테스트도 쉬워짐

  2.큰 비즈니스 흐름을 분해하라
    길고 복잡한 메서드는 여러단계로 이루어진 큰 비즈니스흐름을 제어할때 존재하기도함
	이런 흐름을 모델링할 추상화가 없으면 각 메서드가 흐름의 단계를 표현하는 큰 클래스가 만들어질수있음
	
	이런 큰규모의 복잡한 비즈니스 흐름은,간단하고 응집력있는 작은 코드단위로 나눠야함
	그리고 효과적인 디자인 메커니즘을 사용하여 전체흐름을 만들면됨
	
	이런경우 책임연쇄패턴이나,데코레이터,옵저버 패턴등이 유용하고,도메인이벤트도 생각해볼만함
	
	또 다른 방법으로는 이벤트기반 시스템 구축도 있긴함,단 이건 매우복잡할때 유용성이있음
  
3.객체의 일관성 유지하기
  잘 디자인된 클래스는 데이터를 캡슐화하고 데이터에 접근하거나 데이터를 조작할수있는 연산을 제공함
  oop의 가장 중요한 장점은 객체가 항상 일관된 상태를 유지하게 보장할수있다는점임
  
  코드가 적절히 캡슐화되지않으면 개발자는 어딜 수정해야할지 감을 잡을수없고 버그를 한번에 완전히 해결하기 어렵다고 느끼게됨
  즉 여러군데를 수정해야하고 관련부분을 계속찾아야함
  
  캡슐화란 데이터를 객체 안에 저장하고,객체의 연산을 통해서만 이를 조작할수있게 하는 개념으로,oop의 토대임
  이걸로 다른부분에 영향을 주지않고 클래스 내부의 세부사항을 변경할수있다
  
*1.항상 일관성을 유지하라
  객체가 일관성을 유지하면 내부상태가 요구사항이나 기대에 잘 맞춰 조화를 이루게됨
  이러면 객체가 올바르게 동작하고 정확한 결과를 제공해서 신뢰할수있는 소프트웨어를 만들수있음
  
  일관성을 테스트하는 규칙으로 이런 질문을 쓸수있음
  클래스가 객체를 일관된 상태로 만들기위해 별도의작업이 필요한가?여기서 필요하다면 클래스에 문제가 있는것
  일관된 상태를 유지하는 작업은 클라이언트의 입장에선 최소한의 노력(이상적으로는 전혀 없어야함)으로 이뤄져야함
  
  1.클래스가 스스로 일관성을 책임지게 하라
    일관성검사는 반드시 클래스내부에 구현되어야함
	어떤 클래스가 데이터일관성을 책임져야할지 확신이 서지않는다면 데이터를 포함하는 클래스가 일관성을 보장하는게 기본규칙임
	
	보통 엔티티는 데이터를 포함하는 클래스를 말하게됨
	이때 엔티티의 상태변경이 일어났을때,그거로인한 사이드이펙트처리등도 자동으로 클래스내에서 일어나야함
	
	하지만 모든 일관성로직을 클래스내부에 넣을순없음

  2.전체작업과 복잡한 일관성 검사를 캡슐화하라
    만약 객체내부의 정보만으로는 특정 일관성검사가 불가능할수있음(중복등)
	이런작업들은 엔티티내부가 아닌 응용서비스로직에서 처리되어야함
	다만 그래도 가능한 범위내에서는 최대한의 일관성을 자체적으로 유지해야함
	
	여기서 해당 엔티티에 접근하려면 서비스를 반드시 거쳐야한다는걸 말해주기좋은게 주석임
  
*2.효과적인 데이터 유효성 검사 메커니즘을 디자인하라
  시스템전반에서 데이터유효성을 검증하는건 지루하지만 상응하는 보상이 따름
  데이터유효성을 검사하는 방법엔 두가지가 있음
    메서드에서의 사전조건과 사후조건을 명시적으로 정의
	비즈니스관점에서 입력데이터 검증
  이렇게
  
  1.사전조건을 명시적으로 정의하라
    많은 버그는 메서드가 잘못된방식으로 호출될때 발생함
	이건 사용법을 모르거나 이전코드계층에서 입력한 데이터가 사전검증없이 전달되어 넘어오는등의 이유로 발생함
	
	이 사전검증없이 넘어오는건 코드에서 발견이 어려움
	그래서 사전,사후조건을 명시적으로 정의하고 문서화해야함
	
	사전조건은 메서드의 시작부분에서 각 입력의 유효성을 확인하고 범위를 벗어나면 예외를 던지는것
	이거의 장점은 좀 더 명확한 동작이 가능해진다는거고,단점은 코드가 늘어난다는것(책임도 약간 더생기고)
	
	그래도 보통 여기서 처리하는게 기본룰이긴함
	이건 이코드가 유지보수하기 쉽다 보다 이코드는 작동한다 라는 측면의 품질에 더 초점을 맞추는 드문경우긴하지만,보통 잘작동하면 유지보수도 더 쉬움
	코드가 실패하지않게 디자인할수만 있다면 유지보수에 더 유리하기때문

  2.유효성 검증 컴포넌트를 만들어라
    큰곳에선 메서드사전조건만으로 충분하지않을수있음
	단순히 내부정보만으로 처리할수없는,외부 db정보등이 필요한,즉 비즈니스로직에 가까운 사전조건이 필요할때가 있음
	이건 그 자체로는 사전조건이라고 하긴 어렵지만,요청이 이런 조건을 만족해야함
	
	이런경우엔 검증 컴포넌트를 만들어서 서비스단에서 도움을 받을수도있음
	단 이때도 엔티티는 자기가 할수있는 수준의 최대한 모든 일관성검사를 수행해야함
	
	추가적으로 같은 검증규칙을 다른 유스케이스나 서비스에서 재사용해야한다면,이걸 다른곳에서 재사용가능하게 디자인해야함
	이건 명세패턴등을 고려할수있음
	단,보통은 특정기능이나 서비스에 특화된경우가 많으니 과도하게 디자인하지않는게 좋음
	
	엔티티내부에서 검증컴포넌트를 호출하는건 많은경우에서 좋지않음
	엔티티가 외부의존성을 요구하지않는게 쓰기편함
	
	사용자가 제공한 데이터로부터 올바른 일관성검사를 수행하는 엔티티를 직접 인스턴스화하려고하면 즉각적으로 사전조건위반이 발생할수있음
	그래서 검증없이 사용자의 데이터를 저장하는 중간클래스를 도입할수있음

  3.null은 신중하게 사용하고 피할수있다면 피해라
    클래스가 null을 반환할 가능성이 있으면 클라가 모든곳에서 널검사를 수행해야함
	만약 이런경우엔 optional로 명시적으로 널을 반환하는게 좋고,가급적이면 null을 사용하지않아야함
	
	핵심은 클라가 예상치못하게 놀라는일을 막아야함
	
*3.상태확인을 캡슐화하라



























































 
  
  
  
  