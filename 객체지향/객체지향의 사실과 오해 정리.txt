1.협력하는 객체들의 공동체
	객체지향을 설명할때,현실에 빗대서 설명하는건,특정 딱 한요소만 설명할수있고 나머지는 동시에 설명할수없음
	하지만 그게 각 요소에 대해서 이해하긴 편하기때문에 자주사용함
	
	객체지향에서 가장 중요한건,역할,책임,협력임
	객체들은 자신이 할수없는 일을 만나면,이걸 해결해주길 요청(리퀘스트)함,그리고 요청받은객체도 다시 요청을 할수있으니,요청은 연쇄적으로 발생함
	그리고 요청에 대해 응답하는것도,요청의 연쇄와 반대방향으로 연쇄적으로 전달됨
	
	역할은 어떤 협력에 참여하는 특정사람이 그 안에서 차지하는 책임,의무임
	어떤 역할을 맡았으면,그 역할을 수행할 책임이 생김,즉 역할음 책임을 암시함
	여기서 중요한점은
		여러사람이 동일한 역할을 수행할수 있음:요청자입장에선 누가하든 결과만 나오면됨
		역할은 대체가능성을 의미함:어떤객체든 같은역할을 수행가능하면 신경쓸필요가없음
		책임수행방법은 알아서해도됨:결과만 나오면,수행방법은 캡슐속에있음
		한객체가 동시에 여러역할을 수행할수있음:단,원칙상으로 권장되진않음
	객체지향 설계라는건,적절한 객체에게 적절한 책임을 할당하는것부터 시작됨
	
	역할은 객체의 페르소나고,관련성높은 책임의 집합임
	
	객체의 덕목은
		객체는 충분히 협력적이어야함,외부의 도움을 무시하고 모든걸 스스로처리하려고하면 내부복잡도가 너무올라가서 자멸함
		그리고 이건 객체가 다른객체의 명령에 따라 행동하는 수동적인 존재라는게 아니라,단순히 다른 요청에 응답할뿐임,
		그리고 요청을 수행할지말지도 요청받은객체가 스스로 결정함
		
		객체는 충분히 자율적이어야함,즉 자기스스로의 원칙에 따라 자신의 행동을 스스로 결정하고 책임져야함,즉 결과물만 리턴하는 책임을 가지고,
		그 결과물을 어떻게만들진 지시받지않고 자기가 스스로결정함
		
	
	객체는 상태와 행동을 같이 지닌 실체임
	이말은 객체가 협력에 참여하기위해 어떤 행동을 해야하면,그 행동을 하는데 필요한 상태도 같이 가지고있어야 한다는걸 의미함
	객체의 자율성은,객체의 내부와 외부를 명확히 구분하는것으로 부터 나옴
	객체의 사적인 부분은 객체 스스로 관리하고 외부에서 간섭할수없게 차단해야하고,객체의 외부에선 접근이 허락된수단을 통해서만 객체와 의사소통해야함
	객체는 다른 객체가 무엇을 수행하는진 알수있지만,어떻게 수행하는진 알수없음
	즉 객체는,상태와 행위를 하나의 단위로 묶는 자율적인 존재임
	
	즉 데이터와 프로세스를 객체라는 하나의 틀안에 함께 묶어서 객체의 자율성을 보장하는게 절차지향과 객체지향의 가장 핵심적인 차이임
	
	객체끼리 서로 의사소통을 하는 방법은 메시지임,메시지를 보내는애를 샌더,받는애를 리시버라고 부름
	
	객체가 메시지를 받았으면,이해할수있는지 여부를 판단한후 정해진 자신의 방법에 따라 메시지를 처리함,이 방법을 메서드라고 함
	객체지향에서 메서드는,클래스 안에 포함된 함수나 프로시저를 통해 구현됨,따라서 어떤 객체에 메시지를 전송하면,
	결과적으로 메시지에 대응되는 특정메서드가 실행됨
	
	이 메시지와 메서드의 분리는,객체의 협력에 참여하는 객체들간의 자율성을 증진시킴
	이건 캡슐화와도 깊이 관련되어있음
	
	즉 객체지향이란
		시스템을 상호작용하는 자율적인 객체들의 공동체로 바라보고,객체를 이용해 시스템을 분할하는 방법
		자율적인 객체란 상태와 행위를 함께지니며,스스로를 책임지는 객체
		객체는 시스템의 행위를 구현하기위해 다른객체와 협력함,각 객체는 협력내에서 정해진 역할을 수행하고,역할은 관련책임의 집합
		객체는 다른 객체와 협력하기위해 메시지를 전송하고,메시지수신객체는 메시지를 처리하는데 적합한 메서드를 자율선택함
		
	객체지향에서의 클래스는,중요한 구성요소인건 맞지만,객체지향의 핵심을 이루는 중심개념이라고 하긴어려움
	클래스가 없는 프로토타입계열 언어에서도 객체지향이 가능하고,거긴 상속없이 위임을 기반으로 동작하니까
	
		
2.이상한 나라의 객체		
	객체는 객체의 행동에따라 자신의 상태를 변경시키고,상태에따라 행동의 결과가 바뀜
	즉 상태를 결정하는건 행동이지만,행동의 결과를 결정하는건 상태임
	예를들면 상태에 따른 분기나,현재상태에서 +-하는게 있는데,이건 현재 상태에 행동이 의존적임(현재 상태를 가져와야 더하든빼든 할수있음)	
	이건 행동간의 순서가 중요하다는것도 의미함
	
	객체는 상태,행동,식별자를 지닌 실체로 볼수있음
	
	객체의 상태는,객체가 행동에 어떻게 반응하는가는 그시점까지 일어난 행동들에 좌우되는데,이걸 하나하나 로그로 남기는거보단(이벤트ms방식),
	현재 상태값을 만들고 그값기준으로 돌리는게 쉬워서 이렇게 사용하는거
	
	그리고 이런 단순한 상태값들은 객체가 아님,즉 이런것들은 그 자체로 독립적인 의미를 가지지못하고,다른 객체의 특성을 표현하는데 사용되기때문
	단 단순한 값이 아닌,객체를 사용해서 다른 객체의 상태를 표현할수도 있음(디자인패턴에서 내부에 인터페이스가 있는 객체를 가지고있는 객체들)
	
	결론적으로 모든 객체의 상태는,단순한값과 객체의 조합으로 표현할수있고,이 객체의 상태를 구성하는 모든 특징들을 통틀어 객체의 프로퍼티라고 함
	일반적으로 프로퍼티는 변경되지않아서 정적이고,프로퍼티값은 계속 바뀌니까 동적임
	
	객체와 객체사이의 의미있는 연결을 링크라고하고,객체끼리는 이 링크를 통해서만 요청을 보내고받을수있음(내부에 객체가 들어있는거)
	
	객체는 외부의 객체가 직접적으로 상태를 변경하거나 할수없어서, 간접적으로 행동을 통해서 상태를 변경하거나 조회할 방법이 필요함
	
	객체의 상태는 무조건 행동을 통해서만 바꿀수있음
	객체가 취하는 행동은 객체 자신의 상태를 변경시킴,이소리는 행동이 사이드이펙트를 초래한다는걸 의미함
	사람이 케이크를 먹으면 몸무게가 늘고 케이크가 줄어드는,2가지이상의 효과가 나타날수 있음
	
	이것처럼 객체의 행동은 객체의 상태를 변경시키지만,행동의 결과는 객체의 상태에 의존적임
	이건
		상호작용이 현재상태에 어떤방식으로 의존하는지
		상호작용이 어떻게 현재상태를 변경시키는지
	를 보면 간단히 볼수있음
	
	
	그리고 모든 객체는 섬이 아니라,다른 객체를 이용하고,다른객체에 서비스를 제공함
	객체가 다른객체와 협력하는 유일한방법은 다른 객체에 요청을 보내는것
	요청을 수신한 객체는 그 요청을 처리하기위해 적절한 방법에 따라 행동함
	
	객체는 협력에 참여하는 과정에서,자기자신의 상태뿐아니라 다른객체의 상태변경을 유발할수도 있음
	즉 직접적으로 수정은 못하니,객체의 행동은
		자신의 상태변경
		행동내에서 협력하는 다른 객체에 대한 메시지 전송
	으로 이루어지게됨
		
	객체지향에서의 객체는,모든 객체가 자신의 상태를 스스로 관리할수있음,즉 음료객체가 자신의 용량을 줄이거나 늘일수있고,얘만 그걸할수있어야함
	사람은 단지 저기에 먹었다는 메시지를 던질뿐임,걔가 무슨일을 할진 모름
	이게 캡슐화가 의미하는것임,객체는 상태를 캡슐안에 감춰두고 밖으로 노출하지않음,객체가 노출하는건 행동뿐이고,접근방법도 행동뿐임
	이렇게 상태를 노출하지않고,행동을 경계로 캡슐화하는건,결과적으로 객체의 자율성을 높여서,협력을 유연하고 간결하게 만듬
	
	객체가 식별가능하다는건,객체를 서로 구별할수있는 특정 프로퍼티가 객체안에 존재한다는것,이걸 식별자라고 부름
	모든 객체가 식별자를 가진다는건,단순값은 식별자를 가지지않는다는것
	값은 숫자,문자,날짜등 변하지 않는 양을 모델링함,값의경우 두 인스턴스의 상태가 같다면,두 인스턴스를 같은것으로 판단함
	이거의 여부는 상태가 같은지를 이용해 판단함
	
	객체는 시간에 따라 변경되는 상태를 포함하고,행동으로 상태를 변경함,즉 가변상태를 가짐
	그래서 같은타입의 두 객체의 상태가 완전히 같더라도,두 객체는 독립적인 객체로 다뤄져야함
	그래서 객체를 구분할수있는 값이 필요한데,그게 식별자고 이 식별자를 통해 객체가 같은지를 판단할수있는 성질을 동일성이라고 함
	
	객체의 행동에서 객체의 상태를 조회하는걸 쿼리라고 하고,객체의 상태를 변경하는걸 커맨드라고 함
	객체의 행동은 대부분 이 두개로 구성됨
	
	
	객체지향에선,상태를 중심으로 객체를 바라보는게 아닌,행동을 중심으로 객체를 바라봐야함
	즉 행동을 먼저 정하고,거기에 필요한 상태를 추가하는 방식으로 하는게 좋음
	거꾸로하면
		상태를 먼저결정하면 캡슐화가 저해됨,상태가 객체외부에 노출될확률이 늘어남
		객체를 협력자가 아닌 고립된섬으로 만듬
		객체의 재사용성이 저하됨
	라는 문제가 생길수 있음
		
	
	현실의 객체와 객체지향의 객체와 가장 큰 차이점은,객체지향의 객체는 의인화가 되어서,스스로 뭔가를 할수있다는것
		
		
		
		
		
		
3.타입과 추상화		
	추상화는 필요없는 정보를 제거하고,필요한 목적에 맞춰서 꼭 필요한 사실만 정확히 표현하는것
	이땐,목적에 맞게 모델을 설계하는게 중요함
	즉 추상화란,현실에서 출발하되,불필요한 부분을 도려내가면서 사물의 본질을 드러내게하는 과정
	이걸통해서 복잡도를 줄일수있음
	
	추상화는
		구체적인 사물간의 공통점은 취하고 차이점은 버리는 일반화를 통해 단순하게만드는것
		중요한부분을 강조하기위해 불필요한 세부사항을 버리는것
	이 두가지를 통해,복잡도를 끌어내림
	
	객체지향 패러다임의 중심엔 구체적이고 실제적인 객체가 존재하지만,그걸 다 인식할순없어서 객체를 여러그룹으로 묶어 가짓수를 줄임
	이처럼 공통점을 기반으로 객체들을 묶기위한 그릇을 개념이라고 함
	개념을 사용하면 객체를 여러 그룹으로 분류할수있음,그리고 그 그룹의 일원이 된 애를 그 개념의 인스턴스 라고 함
	
	객체의 분류장치로써의 개념을 말할떈
		심볼:개념을 가리키는 간략한 이름
		내연:개념의 완전한 정의,이걸통해 객체가 여기속하는지 알수있음
		외연:개념에 속하는 모든 객체의 집합
	으로 구분됨
	
	객체지향에서 제일 유명한게 클래스인걸보면,분류(클래시피케이션)가 얼마나 중요한지를 알수있음
	
	분류란 객체에 특정한 개념을 적용하는작업,이걸 하게되면 그 객체는 특정한 집합의 멤버로 분류하는것
	
	분류는 객체지향의 가장 중요한 개념임,어떤 객체를 어떤 개념으로 분류할지가,객체지향의 품질을 결정함
	이걸 잘해야,유지보수가  쉽고,변화에 대처가 쉬워짐
	
	그리고 분류는 추상화를 위한 도구임,즉 분류를 하면 추상화가 일어남(일반화)
	
	타입은 개념과 완전히 동일함,공통점을 기반으로 객체를 묶기위한 틀
	
	단 컴퓨터로 들어오면서 좀 기계적으로 바뀌는데,
	기본적으로 모든 데이터는 0,1인 바이너리임
	근데 그렇게만 보면 알아보기가 너무힘드니까,그 메모리 조각을 잘라다가,제약을 붙여서 사용하는게 데이터타입임
	즉,데이터에 다른데이터를 사칙연산할수있으면 숫자형,데이터가 여러문자로 구성되면 문자열형같은,
	
	이걸로,데이터의 타입을 결정하는건,어떤 데이터에 어떤 연산자를 적용할수 있냐가 그 데이터의 타입을 결정한다는걸 알수있음
	그리고 타입에 속한 데이터를 메모리에 어떻게 표현하는진,캡슐화가 되어서 몰라도된다는걸 알수있음
	
	실제로 객체지향에서 객체는 일종의 데이터를 포함하고,데이터타입과 객체지향의 타입엔 연관성이 있음
	객체를 타입에 따라 분류하고,그 타입에 이름을 붙이는거
	
	객체는 행위에따라 변하는 상태를 가지고있고,그래서 객체를 모두모으면 애플리케이션 전체데이터를 알수있게됨
	그렇다고 객체가 데이터는 아님,객체에서 중요한건 객체의 행동이고,상태는 그 행동으로 초래된 사이드이펙트를 쉽게 표현하기위해 도입됐을뿐임
	객체를 만들때 가장 중요한건,객체가 다른객체와 협력하기위해 어떤행동을 해야할지 결정하는것
	즉 객체가 협력을 위해 어떤 책임을 지녀야하는지 결정하는게 핵심임
		
	그래서 객체지향에서의 객체의 타입은
		어떤 객체가 어떤 타입에 속하는지 결정하는건 객체의 메서드임,같은메서드를 가지고 있다면 같은타입(같은인터페이스)
		객체의 내부표현은 외부로부터 철저하게 감춰짐(캡슐화)
	를 기반으로 볼수있음
	
	객체가 어떤 행동을 하냐에 따라 객체의 타입이 결정되고,객체의 타입은 객체의 내부표현과는 아무상관이 없다는걸로,
	객체들이 같은 메서드명을 공유하고 있으면,같은 타입이라고 볼수있음 
	객체의 상태가 뭘 가지고있는지등은 아무영향을 주지못함
	
	그래서 같은타입에 속한 객체는 행동만 동일하면 서로 다른 데이터를 가질수 있음
	여기서 동일한 행동이란,동일한 책임을 의미하고,동일한 책임이란 동일한 메시지수신을 의미함(인터페이스에서의 메서드)
	즉,같은 타입에 속한 객체는 같은 메시지를 수신하고 이를 처리할수있다(결과는 다를수있지만 일단 들어가긴함)
	
	이건 다형성에 의미를 부여함,다형성이란 같은 요청에 대해 서로 다른 방식으로 응답할수 있는 능력을 뜻함
	동일한 메시지를 서로 다른 방식으로 처리하기위해선,객체들은 같은메시지를 수신할수있어야 하기 때문에,
	결과적으로 다형적인 객체들은 같은타입에 속하게됨
	
	데이터의 내부표현과 무관하게 행동만이 고려대상이라는건,외부에 데이터를 감춰야한다는것
	즉,행동만을 제공하고 데이터는 행동뒤로 감춰야함,이걸 캡슐화하고 함
	
	행동에 따라 객체를 분류하기위해선 객체의 데이터가 아닌 객체가 외부에 제공해야하는 행동을 먼저 생각해야함
	이를위해서 객체가 외부에 제공해야하는 책임을 먼저 결정하고,그 책임을 수행하는데 필요한 데이터를 나중에 결정한 후,
	데이터를 책임을 수행하는데 필요한 외부인터페이스 뒤로 캡슐화해야함
	이게 책임주도설계(RDD)임
	
	타입객체는 상위인터페이스와 하위인터페이스가 있을수있음,이걸 일반화/특수화 라고 부름
	하위에 속하는애는 자동적으로 상위에도 속하게됨
	이때 상위와 하위의 구분은 상위에서 추가적으로 행동이 추가되었을때를 말함
	
	그리고 당연히 상위의 집합보단 하위의 집합이 더 수가 적고,상위의 행동갯수보다 하위의 행동갯수가 더 수가 많음
	
	이때 상위인터페이스를 슈퍼타입,하위인터페이스를 서브타입 이라고 함
	그리고 서브타입은 슈퍼타입을 대체할수있어야함
	
	일반화는 추상화를 위한 도구임,즉 하위인터페이스가 필요없을경우 추상화해서 상위인터페이스에 몰아넣을수도있음
	
		
	타입을 사용하는 이유는,인지능력상 동적으로 변하는 객체의 복잡성을 극복하기가 어렵기때문
	즉,상태를 배제하고 객체의 상태가 변할수있다는것만 생각해서 상황을 단순하게 만들수있음
	
	즉 타입은 시간에 따라 동적으로 변하는 상태를 시간과 무관한 정적인 모습으로 다룰수있게해줌
	그래서 결국 타입은 추상화임
	
	기본적으로 설계시점에선 정적으로 보고,실행시점에선 동적으로 보는식으로 잘 흘러가게됨
	
	객체지향에서 정적인모델은 클래스를 이용해서 구현됨,따라서 타입을 구현하는 보편적방법은 클래스를 이용하는것
	타입이랑 클래스는 같은게 아니고,클래스는 단지 타입을 구현할수있는 여러 매커니즘에 하나임
	이 둘을 구분하는게 설계를 유연하게하는데 도움이됨
	
	즉 클래스는,타입+코드재사용 용도임
		
		
4.역할,책임,협력	
	객체지향에서 제일 중요한건 협력임
	중요한건 개별객체가 아니라 객체들 사이에서 이뤄지는 협력임,
	객체지향 설계의 전체품질을 결정하는건 개별객체의 품질이 아니라 여러 객체들이 모여 이뤄내는 협력의 품질임
	좋은 앱은,객체들간의 요청과 응답속에서 창발하는 협력에 초점을 맞춰서 설계됨
	협력이 자리를 잡으면 객체의 행동이 드러나고 뒤이어 적절한 객체의 상태가 결정됨
	
	협력은 한객체가 다른객체에게 도움을 요청할때 시작됨
	자신에게 할당된일이나 업무를 처리하는중에 스스로 해결하기어려운일에 부딫치게되면 다른객체에 도움을 요청하고,걔도 다시 다른객체에 도움을 요청할수있게되면서
	연쇄적으로 요청과 응답이 일어남
	
	그리고 특정 요청을 받아들일수 있는 이유는,그 요청에 대해 적절한 방식으로 응답하는데 필요한 지식과 행동방식을 가지고있기때문이고,
	요청과 응답은 협력에 참여하는 객체가 수행할 책임을 정의함
	
	객체지향에서 제일 중요한건,책임을 어떻게 할당하느냐가 제일 중요하고,책임을 어떻게 구현할것인가는 다 정해지고 나서 고려해도 상관없음
	객체와 책임이 막 흔들릴때,성급하게 구현하는건 변경에 취약하고 다양한 협력에 참여할수없는 비자율적인 객체를 낳게됨
	
	책임은 객체가 알아야하는 정보와 객체가 수행할수있는 행위에 대해 개략적으로 서술한것
	즉 객체의 책임은,객체가 무엇을 알고있는가 와 객체가 무엇을 할수있는가 로 구성됨
	즉,하는것과 아는것
	하는것엔
		객체를 생성하거나 계산을 하는등의 스스로하는것
		다른 객체의 활동을 시작시키는것
		다른 객체의 활동을 제어하고 조절하는것
	아는것엔
		개인적인 정보에 대해 아는것
		관련된 객체에 대해 아는것
		자신이 유도하거나 계산할수있는것에 대해 아는것
	이 있음
	
	객체의 책임을 말할땐,일반적으로 외부에서 접근가능한 공용서비스의 관점에서 이야기함
	즉 책임은 객체의 외부에 제공해줄수 있는 정보와,외부에 제공해줄수 있는 서비스의ㅣ 목록임
	따라서 책임은 공용인터페이스를 구성함,이건 캡슐화와 이어짐
	
	협력안에서 객체는,다른객체로부터 요청이 전송되었을때만 책임을 수행함
	이처럼 객체가 다른객체에 주어진 책임을 수행하도록 요청을 보내는것을 메시지전송이라고 함
	즉 두 객체간 협력은 메시지를 통해 이뤄지고,메시지를 보내는애는 송신자,받는애는 수신자 라고 함
	
	책임이 협력이라는 문맥속에 요청을 받는쪽의 관점에서 뭘할수있는지를 나열하는거라면,메시지는 두 객체사이관계를 강조한것임
	즉 메시지를 보내는쪽은 받는쪽이 이해할수 있는 메시지를 전송할수있고,받는쪽은 받은메시지에 대해 적절한 책임을 수행할수 있음
	
	주의점은 책임과 메시지의 수준이 같지않다는것,책임은 객체가 협력에 참여하기위해 수행할행위를 개략적으로 서술한거고,
	하나의 책임을 정제하면서 메시지로 변환할때는 여러 메시지로 분할되는게 일반적임
	
	설계초반엔 어떤객체가 어떤책임을 가지고 어떻게 협력하는지에 대한 개요만 알면되고,
	어떤 클래스가 필요하고 어떤 메서드를 포함해야하는진 설계끝나고 결정해도됨
	
	
	책임의 집합은 역할이고,역할은 재사용 가능하고,유연한 객체지향설계를 낳음
	즉 같은 역할을 가진 객체면,대체가능하고,그러면 하나의 루틴으로 추상화해서 객체만 선택해가면서 바꿔가며 돌릴수있음
	즉 같은 인터페이스를 상속받았으면,그 인터페이스를 필요로하는 모든곳에 들어갈수있음
	
	역할을 사용하면,단순성,유연성,재사용성을 올릴수있음
	그리고 가장 큰 가치는,하나의 협력안에 여러종류의 객체가 참여할수있게되면서,협력을 추상화할수있다는것
	
	역할은 협력안에서 구체적인 객체로 대체될수있는 추상적인 협력자임,
	즉 본질적으로 역할은 다른객체에 의해 대체가능함을 의미함
	
	객체가 역할을 대체하기위해선 행동이 호환되어야함,어떤 객체가 증인이라는 역할을 대체할수있는 이유는,그 객체가 증인석에 입장할수있고,증언할수있기때문
	결국 객체는 협력안에서 역할이 수행하는 행동을 그대로 수행할수있어야함
	단,역할에 있는 책임 이외에도 다른 책임을 수행하는건 상관없음,즉 두개이상의 역할을 가져도 상관없음
	즉 일반화/특수화관계가 성립하는게 일반적임
	
	
	객체는 시스템에 필요한 데이터를 저장하기위해 객체가 있는게 아니라,그건 단지 행위를 수행할때 필요한 재료일뿐이고,
	객체는 행위를 수행하며 협력에 참여하기 위해서 존재함,따라서 실제로 중요한건 객체의 행동,즉 책임임
	
	그리고 객체지향은 클래스와 클래스간의 관계를 표현하는 시스템의 정적인측면에 중점을 두는게 아닌,
	클래스는 시스템에 필요한 객체를 표현하고 생성하기위한 도구일뿐이고,정적인 클래스가 아닌 동적인 객체가 중요하고,
	얘들이 협력안에서 어떤책임과 역할을 수행할것인가가 중요함
	
	올바른 객체를 설계하기위해선 견고하고 깔끔한 협력을 먼저 설계해야함
	이건 설계에 참여하는 객체들이 주고받을 요청과 응답흐름을 결정한다는걸 의미함
	이렇게 결정된 요청응답흐름은 객체가 협력에 참여하기위해 수행될 책임이 됨
	그리고 객체가 협력에 참여하기위해 필요한 데이터와 행동이 어느정도 결정된 후에 클래스구현방법을 결정하면됨
	즉,클래스와 데이터는 협력과 책임집합이 결정된 후에야 등장함
	
	객체지향이 올바른객체에 올바른책임을 할당하는것과 관련된 모든것이라면,협력이라는 문맥안에서 객체를 생각하는건,
	올바른 객체지향앱을 구현하는것과 관련된 모든것임
	협력이라는 견고한문맥이 갖춰지면,우리의 초점은 협력을 위해 필요한 책임의 흐름으로 옮겨짐,그리고 협력에 필요한 책임을 결정하고,
	객체에게 책임을 할당하는과정을 얼마나 합리적이고 적절하게 수행했는지가 객체지향설계품질을 담당함
	
	객체의 행위에 초점을 맞추기위해선,협력이라는 문맥내에서 책임을 분배해야함
	각 객체가 가질 상태와 행위에 대해 고민하기전에,그 객체가 참여할 문맥인 협력을 정의하면됨
	즉 객체를 충분히 협력적으로 만든후에 그안에서 자율적으로 만들어야함
	
	
	책임주도설계는 객체의 책임을 중심으로 시스템을 구축하는 설계방법임
	시스템의 기능은 더 작은 규모의 책임으로 분할되고,각 책임은 책임을 수행할 적절한 객체에 할당됨
	객체가 책임을 수행하는도중에 스스로 처리할수없는 정보나 기능이 필요하면,적절한 객체를 찾아 필요한작업을 요청함
	요청된 작업을 수행하는일은 작업을 위임받은 객체의 책임으로 변환됨
	이렇게 객체가 다른객체에 작업을 요청하는 행위를 통해 협력관계가 만들어지고,책임을 여러객체가 수행할수있으면 협력자는 객체가 아닌 추상적인역할로 대체됨
	
	이렇게 책임주도설계에선 시스템의 책임을 객체의 책임으로 변환하고,각 객체가 책임을 수행할때 필요한 정보나 서비스를 제공할 협력자를 찾아,
	해당 협력자에게 책임을 할당하는 순차적방식으로 객체의 협력공동체를 구축함
	책임주도설계는 개별객체상태가 아니라 객체의 책임과 상호작용에 집중함
	결과적으로 시스템은,스스로 자신을 책임질수있을정도로 자율적이면서,다른객체들과 협력할수있는 객체들로 이뤄지게됨
	이때 설계순서는
		시스템이 사용자에게 제공해야하는 기능인 시스템책임을 파악
		시스템책임을 더 작은책임으로 분할
		분할된 책임을 수행할수있는 적절한 객체또는 역할을 찾아 책임을 할당
		객체가 책임을 수행하는중에 다른객체의 도움이 필요하면,이를 책임질 적절한 객체또는 역할을 찾음
		해당객체나 역할에 책임을 할당해서 두객체를 협력시킴
	이순서임
	
	디자인패턴은 책임주도설계가 이뤄진 결과물의 템플릿임
	패턴은 해결할문제가 무엇있지 정확히 서술하고,패턴을 적용할수있는상황과 아닌상황을 함께설명함
	여기서 중요한건 패턴의 세부구조가 아니라,협력에 참여하는 역할과 책임임
	
	테스트주도개발은,실패하는 테스트를 작성하고,그 테스트를 통과하는 간단한코드를 작성한후,리팩토링으로 중복을 제거하는것
	이걸 하면 작동하는 깔끔한코드를 얻을수있음
	테스트주도개발을 할땐,객체가 이미 존재한다고 가정하고,객체에게 어떤메시지를 전송할것인지에 관해 먼저 생각해야함
	즉 테스트를 작성하는게 메인이 아닌,책임을 수행할 객체가 기대하는객체의 역할이 메시지를 수신할때 어떤 결과를 반환하고,
	그과정에서 어떤 객체와 협력할것인지에 대한 기대를 코드형태로 작성하는것
	
	테스트주도개발을 하는이유는,테스트를 얻기위함이 아니라,책임주도설계보다 쉽고 안전하게 설계하기위한 방식일뿐임
	테스트는 덤으로 나오는거고
	
	
5.책임과 메시지
	객체지향의 기본단위는 자율적인 객체임
	여기서 중요한건 자율성인데,자율적인 객체란 스스로 정한 원칙에 따라 판단하고,스스로의 의지를 기반으로 행동하는객체임
	
	객체가 어떤 행동을 하는 유일한 이유는,다른 객체로부터 요청을 수신했기때문,여기서 요청을 처리하기위해 객체가 수행하는 행동을 책임이라고 함
	따라서 자율적인 객체란 스스로의 의지와 판단에 따라 각자 맡은책임을 수행하는 객체임
	
	객체가 책임을 자율적으로 수행하기 위해선,객체에 할당되는 책임이 자율적이어야함
	만약 책임이 자율적이지않고 뭘할지를 다 정해준다면,서로간에 결합성도 늘어나고,거기에 없는방식으로 처리하는게 더 효율적이어도 그렇게하지 못하게됨
	그리고 자율성도 떨어지게됨
	
	그렇다고 항상 포괄적이고 추상적책임을 선택한다고해서 좋은건 또아님
	책임이 너무 구체적인것도 문제지만,협력의 의도를 명확히 표현못할정도로 추상적인거도 또 문제임
	
	즉,추상화될수록 재사용성과 유연성이 올라가지만,너무 추상화되면 그자체로는 사용이 힘들어짐(평타한대칠거 평타두대쳐야함,즉 공격력과 공속의 트레이드오프)
	그래서 상황에 맞게 적절히 추상화를 해야함
	
	자율적인 책임의 특징은,어떻게가 아니라 무엇을 해야하는지를 설명하는것
	즉 뭘할지만 정해주고,어떻게할지는 객체내에서 알아서 정하는식임
	
	그리고 객체는 메시지를 수신할때만 어떤 행동을 시작함,따라서 객체가 자신의 책임을 수행하게 만드는건,외부에서 전달되는 요청임
	그리고 객체가 다른객체에 접근할수있는 유일한 방법은 요청을 전송하는것뿐임,이게 메시지임
	
	하나의 객체는 메시지를 전송함으로써 다른객체에 접근함,여기서 메시지는
	수신자명(객체명),메시지명(메소드명),인자(아규멘트)로 구성됨
		
	메시지를 수신받은 객체는,우선 그걸 자신이 처리할수있는지(그런메소드가 있고,인자구성이 맞는지)를 확인하고,
	맞으면 내부루틴으로 넘어가서동작한뒤에 리턴을넘김
	여기서 송신자는,메시지가 바뀌지않으면 내부루틴이 바뀌더라도 그 사실을 알수없음,즉 객체의 외부와 내부가 메시지를 기준으로 분리된다는걸 의미함
	
	객체지향에서 메서드는,클래스안에 포함된 함수나 프로시저를 통해 구현됨,
	따라서 어떤 객체에 메시지를 전송하면 결과적으로 메시지에 대응되는 특정 메서드가 실행됨
	메시지는 어떻게 수행될지는 명시하지않고,무엇이 실행되기를 바라는지만 명시하고,어떤 메서드를 선택할지는 수신자에게 달려있음
	
	이 메시지를 수신한 객체가 실행시간에 메서드를 선택할수있다는사실은,절차지향(컴파일시간에 결정)과의 가장 큰 차이점임
	
	이 메시지와 메서드의 차이와 관계를 알면(메시지만 보내고 메서드는 수신자가 선택),다형성이해가 쉬워짐
	다형성이란 서로 다른 유형의 객체가 동일한 메시지에 대해 서로 다르게 반응하는걸 의미함
	좀 더 구체적으론 서로 다른 타입에 속하는 객체들이,같은메시지를 수신할경우 서로 다른 메서드를 이용해 메시지를 처리하는 메커니즘
	
	메시지는 무엇이 실행될지는 명시하지만,어떻게 실행할지는 수신자가 결정할수있음,메시지엔 처리방법과 관련된 어떤 제약도 없으므로,같은메시지라고 해도
	서로 다른 방식의 메서드를 이용해 처리할수있음
	즉 다형성을 하나의 메시지와 하나이상의 메서드사이의 관계로 볼수있음
	
	다형성은 역할,책임,협력과 깊은 관련이 있음
	서로 다른 객체들이 다형성을 만족시킨다는건,객체들이 같은책임을 공유한다는것
	다형성에서 중요한건 송신자의 관점임
	수신자들이 같은오퍼레이션을 다른방식으로 처리하더라도,이 객체들은 같은책임을 수행하는것
	즉 송신자의 관점에서 다형적인 수신자들을 구별할 필요가 없으며,자신의 요청을 수행할 책임을 지닌다는점에서 모두 동일함
	
	기본적으로 다형성은 같은 역할을 수행할수 있는 객체들 사이의 대체가능성을 의미함
	다형성은 객체들의 대체가능성을 이용해서 설계를 유연하고 재사용가능하게 만듬,다형성을 사용하면,송신자가 수신자의 종류를 몰라도 메시지를 전송할수있음
	즉 다형성은 수신자의 종류를 캡슐화함
	
	그리고 다형성은,송신자와 수신자간의 객체타입에 대한 결합도를,메시지에 대한 결합도를 낮춤으로써 달성함
	
	송신자는,수신자가 메시지를 이해할수있다는 사실만 알고있는 상태에서 협력에 참여함,
	이건 설계품질에 큰 영향을 미침
		협력이 유연해짐,송신자는 수신자가 메시지를 이해하기만하면 누구든 상관없음,이걸 대체해도 송신자는 관심없으니 쉽게쉽게 변경가능
		협력의 수행방식을 확장할수있음,송신자에게 아무영향을 안주고 수신자를 교체할수있기때문에 협력의 세부수행방식을 쉽게수정할수있음
		협력수행방식을 재사용할수있음,협력에 영향을 안주고 다른객체들이 수신자를 대체할수있어서 재사용이쉬움
	
	이 모든건 메시지가 다형성을 지탱하고있기때문
	메시지는 송수신자사이의 결합도를 낮춰서 설계를 유연하고 확장가능하고 재사용가능하게 만듬
	송신자는 오직 메시지만 바라보고,수신자의 정확한 타입을 몰라도 상관없음
	그래서 설계의 품질을 높이려면,훌륭한 메시지를 선택해야함
	
	객체지향의 중심사상은 연쇄적으로 메시지를 전송하고 수신하는 객체들 사이의 협력관계를 기반으로 사용자에게 유용한 기능을 제공하는것
	
	객체지향에서 클래스도 중요하지만,그것보다 중요한건 객체들이 주고받는 메시지임
	객체지향앱은 클래스로 만들지만,메시지를 통해 정의됨
	클래스는 단지 동적인 객체들의 특성과 행위를 정적인 텍스트로 표현하기위해 사용할수있는 추상화 도구일뿐임
	그래서 클래스를 정의하는것보다,객체들의 속성과 행위를 식별하는게 먼저임
	클래스는 그 객체의 속성과 행위를 담는 틀일 뿐임
	
	그리고 객체의 행위와 속성보다 중요한건,객체사이의 협력임
	이걸 먼저 생각하고,거기에 객체의 행위와 속성을 끼워맞춰야함
	객체를 이용하는 중요한이유는,객체가 다른객체가 필요로하는 행위를 제공하기때문
	
	객체가 자신에게 할당된 책임을 수행할떈,다른객체와 협력해야함
	객체지향설계는 적절한 책임을 적절한객체에게 할당하면서,메시지를 기반으로 협력하는 객체들의 관계를 발견하는 과정임
	이런방식을 책임주도설계라고 함
	
	책임주도설계에서 역할,책임,협력을 식별하는건,앱이 수행하는 기능을 시스템의 책임으로 보는것부터 시작됨
	그리고 그걸 구현하기위해 협력관계를 시작할 적절한 객체를 찾아 시스템의 책임을 객체의 책임으로 할당하고,
	객체가 책임완수를위해 다른객체의 도움이 필요하다고 판단되면,도움요청을 위해 어떤 메시지가 필요한지 결정함
	메시지를 결정한 후엔 메시지를 수신하기에 적합한 객체를 선택함
	수신자는 송신자가 메시지를 보내면서 기대한바를 충족시켜야함
	
	결과적으로 메시지가 수신자의 책임을 결정함
	
	책임주도설계의 핵심은,어떤 행위가 필요한지를 먼저 결정한 후에 이 행위를 수행할 객체를 결정하는것
	이걸 what/who 사이클이라고 함
	
	객체의 행위를 결정하는건,객체의 속성이 아님,어떤 속성이 있다고해서 반드시 그와 관련된 행위를 수행할거라고 가정하면안됨
	먼저 책임이 오고 객체가 책임을 따르고,행위가 생성됨
	그리고 먼저 메시지가 결정된후에 그 메시지가 어디로갈지 객체중에서 후보를뽑음
	
	메시지를 먼저 결정하고 객체가 메시지를 따르게하는방식은,객체가 외부에 제공하는 인터페이스가 독특한 스타일을 따르게함
	이걸 데메테르법칙이라고 함
	
	책임주도설계는 객체가 아니라,메시지에 초점을 맞춰서 장점을 극대화함
	메시지를 결정하는 시점에선 어떤 객체가 메시지를 수신할지를 알수없기때문에,당연히 메시지송신자는 메시지를 수신할 객체의 내부상태를 볼수없음
	그래서 메시지중심의 설계는 수신자의 캡슐화를 증진시키고,둘은 느슨하게 결합됨
	
	그리고 메시지를 결정한시점에선 누구한테 갈지모르니 꼬치꼬치캐물을수없고,잘 처리해주길 기도할수밖에 없음
	
	객체는 다른객체의 상태를 묻지말아야함,객체가 다른객체의 상태를 묻는다는건,객체가 가질상태에 관해 너무 고민이 많다는것,
	고민을 연기하고,보내고나서 받는애가 그걸 스스로 처리할지말지 선택하게 해야함
	
	즉 객체가 자신이 수신할 메시지를 결정하게하지말고,메시지가 협력에 필요한 객체를 발견해야함
	
	인터페이스란 어떤 두 사물이 마주치는 경계에서,서로를 상호작용할수있게 이어주는 방식이나 장치임
	인터페이스의 특징은
		인터페이스의 사용법만 익히면 내부를 몰라도 사용가능해야함
		인터페이스자체는 변경하지않고,내부구성이나 작동방식을 변경하는건 사용자에게 영향을미치면안됨
		대상이 변경되더라도 같은인터페이스를 제공하기만하면 아무문제없이 상호작용할수있어야함
		
	객체가 다른객체와 상호작용할수있는 유일한 방법은 메시지전송임,따라서 객체의 인터페이스는 객체가 수신할수있는 메시지의 목록으로 구성되며,
	객체가 어떤 메시지를 수신할수있는지가 객체가 제공하는 인터페이스모양을 빚음
	
	그리고 객체가 자기자신과 상호작용할때도 메시지를 보내야하니까,공용인터페이스와 사설인터페이스(프라이빗)으로 나눠지게됨
	둘다 메시지전송을 통해서만 접근할수있음
		
	
	객체지향을 이해하려면
		좀더 추상적인 인터페이스
		최소 인터페이스
		인터페이스와 구현간의 차이에 대해 인식
	을 알아야함
	
	좀더 추상적인 인터페이스는,앞에서처럼 뭘할지 정하지말고 뭐가필요한지를 정하라는거고
	최소인터페이스는 외부에서 사용할필요가 없는 인터페이스는 최대한 노출하지말라는것
	
	구현은 내부구조와 작동방식을 가리킴
	즉 객체를 구성하지만 공용인터페이스에 포함되지 않는 모든것이 구현에 포함됨
	
	객체는 상태를 가지고,상태는 어떤식으로든 객체에 포함되겠지만,외부에 노출되는 공용인터페이스는 아님
	그래서 상태는 객체의 구현에 해당됨
	
	객체는 행동을 가짐,행동을 가짐,행동은 메시지를 수신했을때만 실행되는 메시지처리방법이고,이걸 메서드라고 부름
	메서드내의 코드자체는 객체외부에 노출되는 공용인터페이스는 아니기때문에 객체의 구현임
	
	객체의 외부와 내부를 분리하라는건,객체의 공용인터페이스와 구현을 명확하게 분리하라는말과 같음
	
	좋은객체는 구현을 모른채 인터페이스만 알면 쉽게 상호작용할수있는 객체를 의미함
	이건 객체를 설계할때,객체인터페이스와 내부구현을 명확히 분리해서 고려해야한다는걸 의미함
	이걸 인터페이스와 구현분리원칙이라고 함
	
	이걸 제대로하면,어떤 객체에서 수정하면 외부에 영향을미치는 영역과 아닌영역을 구분해서 볼수있게됨
	중요한건,객체의 상태와 메서드구현을 수정해도,객체 외부에 영향을 미쳐서는 안됨
	이걸 수행하기위한 객체설계방법이 캡슐화임

	캡슐화는 상태와 행위의 캡슐화,사적인비밀의 캡슐화 두가지관점이 있음
	
	객체는 상태와 행위의 조합이고,스스로 상태를 관리하며 상태를 변화시키는 행동을 내부에 함께 보관함,객체는 상태와 행동을 하나의 단위로 묶는 자율적인실체임
	
	객체는 상태와 행위를 한데묶은후,외부에서 반드시접근해야하는 행위만 골라 공용인터페이스에 노출함,
	따라서 데이터캡슐화는 인터페이스와 구현을 분리하기위한 전제조건이고,
	객체가 자율적이기위해선 자기자신의 상태를 스스로 관리할수있어야해서 자율적인객체를 만들기위한 전제조건이기도 함
	
	객체는 외부의 객체가 자신의 내부상태를 직접관찰하거나 제어할수없도록,의사소통가능한 특별한경로만 외부에 노출함
	이걸 공용인터페이스라고 하고,캡슐화를 통해 변경이 일어나는 불안정한 비밀을 안정적 인터페이스 뒤로 숨길수있음
	일반적으로 불안정한비밀은 구현과 관련된 세부사항을 의미함
	
	객체의 공용인터페이스는 외부에서 전송가능한 메시지의 집합임,외부객체는 오직 공용인터페이스만을 접근할수있으니,
	외부에 제공할필요가 있는 메시지를 객체의 공용 인터페이스에 포함시키고,개인적비밀은 그 뒤에감춰서 자율성을 보장받을수있음
	여기서 자율성이란,자기자신의 사적부분을 외부간섭없이 변경할수있음을 의미함
	
		
	협력의 종류는 사람수만큼있지만, 더 나은 방식의 협력이 존재함,협력의 품질은
		자율적인책임은 협력을 단순하게 만듬,세부사항을 무시하고 의도만 드러내는방식을 사용해야함
		자율적인책임은 외부와 내부를 명확하게 분리함,외부가 몰라도되는부분은 캡슐화되어야함
		책임이 자율적일경우,책임을 수행하는 내부방법을 변경해도 외부에 영향을 미치지않음
		자율적인책임은 협력대상을 다양하게 선택할수있는 유연성을 제공함
		객체가 수행하는 책임들이 자율적일수록 객체역할을 이해하기가 쉬워짐,즉 응집도가 오름
		
		
		
		
		
6.객체 지도	
	문제를 해결할떈,현재의 요구만을 만족시키는게 아닌,다양한 목적으로 재사용될수있게,구조적이고 문제지향적으로 해결하는게 재사용성면에서 좋음
	그리고 이땐,기능이 아닌 구조적으로 해결해야하는데,이유는 기능보다 구조가 더 안정적이기 때문임
	지도를 보면 시간이 지나도 그렇게 크게바뀌는게 없는것처럼 변경점이 적은걸 기준으로잡고 뻗어나가야함
	
	즉 기능을 중심으로 구조를 종속시키면,범용적이지않고 변경에 취약한데,구조를 중심으로 기능을 종속시키면,범용적이고 재사용가능하고 변경에 유연함
	
	일단 소프트웨어 설계에서 가장 중요한건 기능임,구조가 아무리좋아도 기능이없으면 안씀
	단 구조가 좋으면 변경이나 추가가 매우쉬워짐
	
	물론 요구사항이 생기지않고,변경되지않는다면 그냥 기능기반으로 대충짜서 만들고 박제해두는게 효율성높긴한데,
	보통은 요구사항이 생기니까 구조기반이 좋은거
	
	그렇다고 미래의 변경을 예측할순없음,단 미래의 변경을 대비할순있음
	그래서 뭐가 바뀔지 미리 예측해두는게 아니라,뭐가 바뀌어도 변경이 가능하게 선택의 여지를 설계에 마련해둬야함
	설계의 목적은,나중에 설계하는걸 허용하는것이며,설계의 일차적목표는 변경에 소요되는 비용을 낮추는것
	
	여기서 변경의 여지를 남겨두는 가장 좋은방법이 구조기반설계임
	
	구조기반설계를 할땐,자주변경되지않는 안정적인 객체구조를 바탕으로,시스템기능을 객체간의 책임으로 분배함
	객체지향은 객체의 구조에 집중하고,기능이 객체의 구조를 따르게만듬
	시스템기능은 더 작은책임으로 분할되고,객체에 분배돼서,기능이 변경돼도 객체간의 구조는 그대로유지됨
	
	객체지향세계를 구축하기위해선 기능과 구조가 필요한데,
	구조는 도메인에 대해 생각하는 개념과 개념들사이의 관계로 표현하고
	기능은 사용자의 목표를 만족시키기위해 책임을 수행하는 시스템의 행위로 표현함
	
	일반적으로 기능을 수집하고 표현하기위한 기법을 유스케이스 모델링이라고하고,구조를 수집하고 표현하기위한 기법을 도메인모델링이라고 함
	
	도메인은,사용자가 프로그램을 사용하는 대상분야를 말함
	도메인모델에서 모델이란 대상을 단순화해서 표현한것,모델은 지식을 선택적으로 단순화하고,의식적으로 구조화한 형태
	즉 모델은 대상을 추상화하고 단순화한것으로,모델을 사용하면 현재문제관련은 추상화하고,그밖의 세부사항은 무시할수있음,즉 복잡도관리도구임
	
	도메인과 모델을 정의하면,둘을 연결하면 도메인모델이 나옴
	도메인모델이란 사용자가 프로그램을 사용하는 대상영역에 관한 지식을,선택적으로 단순화하고 의식적으로 구조화한 형태임
	도메인모델은 소프트웨어 개발과 관련된 이해관계자들이 도메인에 대해 생각하는 관점임
	
	도메인모델은 단순한 다이어그램이 아니라,이해관계자들이 바라보는 멘탈모델임
	이게 중요한건,사용자들은 자신의 멘탈모델과 유사하게 제품이 반응하고 움직일거라고 기대하기때문
	즉 도메인모델은,사용자가 도메인을 바라보는 관점이고,설계자가 시스템의 구조를 바라보는 관점이며,소프트웨어 안의 코드 그자체임
	
	그리고 객체지향을 사용하면,사용자가 이해하는 도메인의 구조와 최대한 유사하게 코드를 구조화할수있음
	객체지향은 사람들이 만지고 느끼고 볼수있는 실체를 시스템안의 객체로 재창조해주고,
	동적인 객체의 복잡성극복을 위해 정적인 타입으로 단순화할수있고,
	클래스로 타입을 코드안으로 옮길수있음
	
	결과적으로 객체지향을 이용하면,도메인에 대한 사용자모델,디자인모델,시스템이미지 모두가 유사한모습을 유지하도록 만드는게 가능함,
	이런특징을 연결완전성이라고 함
	
	기본적으로 객체는 현실객체의 추상화가 아니지만,둘 사이에 왜곡이 존재한다고 해도,현실객체의 특성을 토대로 소프트웨어 객체는 구축됨
	이 사이의 의미적 거리를 표현적차이라고 부르는데,이걸 은유를통해 최대한 줄여야함
	물론 대부분의 소프트웨어 도메인은,현실에 존재하지않는걸 대상으로 함,그럴때 은유해야하는건 사용자가 도메인에 대해 생각하는 개념들임
	즉 은유의 대상은 도메인모델임
	
	이 표현적차이가 중요한이유는,소프트웨어를 이해하기쉬워지고,수정하기 쉬워지기때문
	코드의 구조가 도메인의 구조를 반영하기때문에,도메인을 이해하면 코드이해가 쉬워짐
	
	그리고 도메인모델이 제공하는 구조는 상대적으로 안정적이기때문에,변경이 잘 일어나지않음
	그래서 이 구조를 기반으로 기능을 배치해서 기능변경에대해 안정적으로 소프트웨어를 구현할수있음
	
	그래도 실제 사용자에게 중요한건 도메인모델이 아닌 기능이니,기능을 기술하기위해 사용하는게 유스케이스임
	사용자는 자신의 목표를 달성하기위해 시스템과의 상호작용을 시작함,
	사용자가 시스템에게 작업을 요청하면,시스템은 요청을 처리한후 사용자에게 원하는 결과를 제공함
	사용자는 시스템응답을 기반으로 또 다른 작업을 요청하고,시스템은 요청을 다시 처리한후 사용자에게 응답함
	이 상호작용은 목표를 만족시키거나,에러가 뜰때까지 반복됨
	
	이처럼 사용자의 목표를 달성하기위해 사용자와 시스템간에 이뤄지는 상호작용의 흐름을 텍스트로 정리한게 유스케이스임
	여기서 일차액터는,유스케이스를 시작하는 액터를 의미함
	
	유스케이스가 좋은건,사용자들의 목표를 중심으로,시스템의 기능적 요구사항들을 이야기형식으로 묶을수있다는것
	산발적으로 흩어진 기능에 사용자목표라는 문맥을 제공해서 각 기능이 유기적인 관계를 지닌 체계를 이룰수있게함
	
	유스케이스는 다이어그램이 아닌 텍스트임(내가 맨날 프로그램짜기전에 적던 그걸 좀더 체계적으로 적은거임)
	그리고 유스케이스는 하나의 시나리오가 아닌,여러 시나리오들의 집합임
	유스케이스는 단순한 기능목록과도 다름,기능목록은 기능을 단순하게 나열한것
	유스케이스는 기능들을 묶어서 상호작용흐름속에서 진행방식을 보여줘서,서로 연관되는 기능들을 묶을수있다는게 장점임
	유스케이스는 사용자인터페이스와 관련된 세부정보를 포함하면안됨,단순 사용자관점에서 시스템의 행위에 초점을 맞춰야함
	유스케이스는 내부설계와 관련된 정보를 포함하면안됨
	
	유스케이스는 단순하게 시스템의 외부관점만을 표현하고,내부구조나 실행메커니즘에 관한 어떤정보도 제공하지않음
	단지 사용자가 시스템을통해 무엇을 얻을수있고,어떻게 상호작용할수있냐에 관한 정보만 기술됨
	
	유스케이스는 시스템이 외부에 제공해야하는 행위만 포함해서,거기서 내부구조를 유추할방법은 존재하지않아야하고,사실 객체지향과도 관계없음
	
	즉 유스케이스를 객체로 변환하는건 그냥 꼬라박아봐야함
	
	도메인모델은 안정적구조를 개념화하기위해,유스케이스는 불안정한 기능을 서술하기위해 일반적으로 사용되는 도구임
	변경에 유연한 소프트웨어를 만들기위해선,유스케이스에 정리된 시스템기능을 도메인모델을 기반으로 한 객체들의 책임으로 분배해야함
	
	시스템은 사용자와 만나는 경계에서 사용자의 목표를 만족시키기위해 사용자와 협력하는 커다란객체고,
	사용자에게 시스템이 수행하기로 약속한기능은 결국 시스템의 책임임
	사용자에게 객체는 자신이 전송한메시지를 응답하는데 필요한책임을 수행하는 일종의 객체임
	그리고 시스템안엔 더 작은규모의 객체가 포함될수있고,시스템의 책임은 이 안의 작은객체들의 협력으로 구현해야함
	
	책임주도설계는 이지점부터 적용됨
	일단 시스템의 기능을 시스템의 책임으로 바꾼후에,협력의 시작을 할수있음(일차액터)
	
	시스템에 할당된 커다란책임을 세분화할떄,어떤 객체를 선택할지에서 도메인모델이 등장하고,도메인모델에 포함된 개념을 은유하는 객체를 선택해야함
	이때 협력을 완성하는데 필요한 메시지를 식별하면서,객체들에게 책임을 할당해나감
	마지막으로 협력에 참여하는 객체를 구현하기위해,클래스를 추가하고 속성,메서드를 구현하면 시스템기능이 완성된것
	
	유스케이스는 사용자에게 제공할 기능을 시스템의 책임으로 보게해서,객체간 안정적인 구조에 책임을 분배할수있는 출발점을 제공함
	도메인모델은 기능을 수용하기위해 은유할수있는 안정적인 구조를 제공함
	책임주도설계는 유스케이스에서 첫메시지와 사용자가 달성하려는 목표를,
	도메인모델로부터 기능을 수용할수있는 안정적인 구조를 제공받아 실제로 동작하는 객체들의 협력체를 창조함
	
	책임주도설계방법은 시스템의 기능을 역할과 책임을 수행하는 객체들의 협력관계로 바라보게해서 유스케이스와 도메인모델을 통합함
	
	그리고 도메인모델에 명시된 개념들은,스스로 상태와 행위를 관리할수있음,객체는 반드시 자율적으로 변하게됨
	그리고 각 객체는 자신의 책임을 완수할때 필요한 정보나 서비스가 필요하면,이를 제공할수있는 다른객체에 책임을 요청할수있음
	따라서 시스템의 기능은,객체들의 협력으로 구현됨
	
	객체의 이름은 도메인모델에 포함된 개념으로 부터 차용하고,책임은 도메인모델에 정의한 개념의 정의에 부합하게 할당함
	
	즉 기본적으로 객체지향은,다른객체를 포함하는 재귀적합성으로 이뤄짐
	
	도메인모델을 기반으로 객체구조를 설계하는이유는,도메인모델이 안정적이기때문임
	도메인모델은 비즈니스가 없어지거나 완전히 개편되지않는한 유지되게 만들어야하고,비즈니스규칙을 기반으로 형성되어야함
	만약 이때 기능적인 요구사항이 변경될경우,책임과 객체간의 대응관계만 수정될뿐임
	즉 뭐가 세분화되면,원래있던걸 인터페이스로 삼고,밑에를 세분화해서 전략패턴을 사용하는식임
		
		
		
		
7.함께모으기		
	객체지향설계속엔 세가지 상호연관된 관점이 있음
		개념관점에서 설계는 도메인 안에 존재하는 개념과 개념들 사이의 관계임,여기선 실제도메인의 규칙과 제약을 최대한 유사하게 반영하는게 핵심
		
		명세관점에선 도메인의 관점이 아닌,객체들의 책임에 초점을 맞춰서,인터페이스를 바라봄,객체가 협력을위해 무엇을 할수있는가에 초점을 맞춰야함
		즉 인터페이스와 구현을 분리해,인터페이스 기반으로 초점을 맞춤
		
		구현관점은 객체들이 책임을 수행할떄 필요한 동작하는 코드를 작성하는,코드작성의 관점임
	
	공용인터페이스는 명세관점을 반영하고,속성,메서드는 구현관점을 암시함
	
	이걸로 클래스를 어떻게 설계하느냐에 힌트를 얻을수있는데,클래스는 세가지관점을 모두 수용할수있게 개념,인터페이스,구현을 함께 드러내야하고
	동시에 코드안에서 세가지 관점을 쉽게 식별할수있게 깔끔하게 분리해야함
	
	그리고 역할,책임,협력으로 인터페이스를 식별하고,객체가 수신할 메시지를 결정하고 메시지가 모여 인터페이스를 구성하는건 명세관점에서 객체를 바라보는것
	
	실제로 설계를 할땐,도메인을 기반으로 객체들을 먼저 만들고,객체끼리의 관계를 통해 메시지를 생성하고,메시지에 적합한 객체를 끼워넣어서 책임을 부여하면됨
	이떄 스스로 할수없는일이 생기면,다른객체에 그걸 요청해야하는데 이 요청이 외부로 전송되는 메시지를 정의함
	이렇게 모든 메시지에 대해 협력설정이 끝나고나면 나오는게 인터페이스임
	
	각 객체를 협력에서 떼어내고,수신가능한 메시지만 추려내면 그게 그 객체의 인터페이스가 됨
	
	그리고 구현을 할땐,이 인터페이스가 바뀌는게 일반적임(참조문제라던가,생각못했던 문제때문)
	참조문제를 해결하려고 매개변수로 대상객체를 받는다거나 할수있음
	
	그리고 객체간의 관계에서,어느 한쪽이 한쪽에 포함되면,포함관계,혹은 합성관계라고 함
	포함하지는 않지만 서로 알고있어야하면 연관관계임
	
	코드는 개념관점(클래스의 이름),명세관점(클래스의 인터페이스),구현관점(클래스의 메서드,상태)를 모두 제공해야함
	그리고 객체의 인터페이스는 어지간하면 변하면안됨,여긴 노출된구역이라,여기가 변하면 영향력이 너무큼
	그래서 인터페이스에서 구현에 관련된 세부사항을 노출시키면안됨
	
	구현관점에선 클래스의 내부구현을 바라보고,
	여기는 공용인터페이스의 일부가 아니라서 원칙적으로는 메서드의 구현과 속성의 변경은 외부의 객체에 영향을 주면 안됨(어쩔수없을때도 있긴함)
	
	그리고 메시지가 있을때, 그메시지를 수신할 객체를 선택하는건,가장쉬운방법은 도메인개념중에서 가장 적절한걸 고르는것
		
		
		
	기본적으로,인터페이스와 구현을 나눠두고,인터페이스 따로 구현따로 생각해야함,인터페이스는 클래스의 내부구현을 뺀 전체
		
		
		
부록.추상화기법		
	추상화는 도메인의 복잡성을 단순화하고 직관적인 멘탈모델을 만드는데 사용할수있는 기본적인 인지수단임
	기본적으로 추상화는 복잡성을 낮추기위해 사물의 특정한측면을 감춤
		분류와 인스턴스화:객체의 구체적세부사항을 숨기고 인스턴스간에 공유하는 공통적인 특성을 기반으로 범주형성
		분류의 역은 범주로부터 객체를 생성하는 인스턴스화 과정임
		
		일반화와 특수화:일반화는 범주사이의 차이를 숨기고 범주간 공통적 특성을 강조함
		일반화의 역은 특수화
		
		집합과 분해:집합은 부분과 관련된 세부사항을 숨기고 부분을 사용해서 전체를 형성하는 과정
		집합의 반대는 전체를 부분으로 분리하는 분해
		
	객체지향의 가장 큰 장점은 같은추상화기법을 프로그램의 분석,설계,구현에 거쳐 일관성있게 적용할수있다는것
1.분류와 인스턴스화	
	분류와 인스턴스화는,완전히 동일하지않지만,유사한 특성을 바탕으로 크게 묶는것(자동차,나무 등)
	이렇게 객체를 분류하고 범주로 묶는건 객체들의 특정 집합에 공통의 개념을 적용하는걸 의미함
	개념이란,속성과 행위가 유사한 객체에 공통적으로 적용되는 관념이나 아이디어임
	즉,객체들을 공통적인 특성을 기반으로 범주로 묶고,개념을 적용하는건 범주라는 렌즈로 세상을 보는것과 비슷함
	이렇게 세상에 존재하는 객체에 개념을 적용하는게 분류고,분류는 객체를 특정한 개념을 나타내는 집합의 구성요소로 포함시킴
	
	이렇게 범주로 묶어서 복잡성을 낮출수있고,분류를 통해 개별현상을 하나의 개념으로 다룰수있음
	이때 수많은 개별적현상을 객체라고하고,하나의 개념을 타입이라고 함,즉 분류는 객체를 타입과 연관시키는것
	분류의 역은 타입에 해당하는 객체를 생성하는것으로,인스턴스화 또는 예시라고 함
	
	즉 요약하면 분류는 객체와 타입간에 관계를 나타낸것,어떤 객체가 타입의 정의에 부합하면 해당타입으로 분류되고,자동으로 타입의 인스턴스가 됨
	
	그리고 타입을 객체의 분류장치로 적용하려면,심볼,내연,외연의 정의가 필요함
	타입의 외연은 타입에 속하는 객체들의 집합으로 표현됨
	집합은 외연을 가리키는 또 다른 명칭임
	
	그리고 분류엔 단일분류와 다중분류가 있음
	단일분류는 한시점에서 한 객체가 하나의 타입에만 속하는것
	다중분류는 한시점에서 한 객체가 여러타입에 속할수있는것
	
	대부분 객체지향언어들은 다 단일분류만을 지원함(한 객체가 여러클래스의 인스턴스일수없음)
	단 다중분류와 다중상속은 다른것,
	다중상속은 하나의 타입이 다수의 슈퍼타입을 가지게 허용하는것이지만,타입정의를 생략할순없음
	다중분류는 특정한 타입을 정의하지않고도 하나의 객체가 서로 다른 타입의 인스턴스가 되도록 허용함
	
	그리고 객체가 자신이 속하는 타입을 변경할수있으면 이걸 동적분류라고 하고,없으면 정적분류임
	
	일반적으로 객체지향언어에선,단일분류와 정적분류를 사용함(동적으로 클래스를 바꿀수없음)
	
	
	객체지향언어에서 타입을 구현하는 가장 보편적방법은 클래스를 이용하는것
	클래스는 객체들의 가장 본질적인 속성을 정의하고,그걸 기준으로 클래스를 생성함,같은 본질속성을 가졌으면 같은 클래스여야함
		
		
		
2.일반화와 특수화		
	일반화와 특수화는,좀 더 일반적인 타입을 이용해 세부적인 타입을 정의함으로서,타입간의 계층구조를 구축하는 방법임
	어떤 타입이 다른타입보다 일반적이라면,이걸 슈퍼타입이라고 하고,어떤 타입이 다른 타입보다 특수하면 이 타입을 서브타입이라고 함
	
	그리고 서브타입은 슈퍼타입의 속성에 추가로 자신만의 추가적인 속성을 가짐
	그래서 내연의 관점에서,슈퍼타입의 정의가 서브타입의 정의보다 더 일반적이라는걸 의미함
	
	어떤 타입이 다른타입의 서브타입이 되려면,
		100%규칙:슈퍼타입의 정의가 100% 서브타입에 적용되어야함
		is-a규칙:서브타입의 모든 인스턴스는 슈퍼타입집합에 포함되어야함
	를 만족해야함
		
	일반적으로 일반화 특수화를 구현하는 가장 쉬운방법은 상속임
	단,상속이 100% 일반화관계인건 아님
	상속을 해서 오버라이딩을 해서 메서드를 수정해버리면,일반화가 안되게됨
	이경우엔 대체가능성이 100%가 아니게됨(리스코프 치환 원칙)
	
	즉,상속엔 서브타이핑(일반화관계),서브클래싱(단순히 코드반복줄이기위한것)의 용도가 있는데,서브타이핑의 경우에만 일반화과 성립됨
	보통 서브타이핑을 인터페이스상속이라고 하고,서브클래싱을 구현상속이라고 함
	
	보통 여러클래스로 구성된 상속계층에서 수신된 메시지를 이해하는 기본적방법은 클래스간 위임을 사용하는것
	어떤 객체의 클래스가 수신된 메시지를 이해할수없으면 메시지를 클래스의 부모에 위임하고,
	부모도 메시지를 이해할수없으면 자신의 부모클래스로 다시 메시지를 위임함
	이건 최상위부모까지 반복됨
	
		
3.집합과 분해
	복잡성은 계층형태를 띄고,단순한 형태로 복잡한 형태로 변하는데 걸리는 시간은 그 사이에 존재하는 안정적인 형태의 수와 분포에 의존함
	
	안정적인 형태의 부분으로 전체를 구축하는 행위를 집합이라고 하고,전체를 부분으로 분할하는 행위를 분해라고 함
	집합의 가치는,많은수의 사물의 형상을 하나의 단위로 다뤄서,복잡성을 줄일수 있다는데 있음
	즉 불필요한 세부사항을 추상화함
	그러나 필요한시점에선 전체를 분해해서 그 안에 포함된 부분들을 새로운 전체로 다룰수있음,즉 일관적인 계층구조라서,재귀적 설계가 가능해짐
	
	집합은 전체의 내부로 세부사항을 감춰줘서,추상화인 동시에 캡슐화임
	
	집합과 분해는 한번에 다뤄야할 요소의 수를 감소시킴으로써 인지과부하를 방지함
	
	그리고 객체와 객체사이의 전체-부분 관계를 구현하기위해선 합성관계를 사용함
	합성관계는 부분을 전체안에 캡슐화함으로 인지과부하를 방지함
	주문 항목은 주문의 일부이므로,주문항목을 무시하고 주문과 상품만 존재하는거처럼 모델을 다루는식
	필요하면 주문내부로 들어가 주문항목과 관련된 세부사항을 확인하는것(분해)
	
	그리고 포함관계가 아닌,주문과 상품처럼 서로 관계만 있을경우,이걸 연관관계라고 함
	
	합성관계에서는 보통,집합이 삭제되면 내부도 같이삭제되지만,연관관계에서는 독립적으로 존재하기때문에 삭제되지않음
	
	일반적으로 이걸 많이쓰는게,라이브러리나 패키지임
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
	