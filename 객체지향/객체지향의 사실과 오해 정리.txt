1.협력하는 객체들의 공동체
	객체지향을 설명할때,현실에 빗대서 설명하는건,특정 딱 한요소만 설명할수있고 나머지는 동시에 설명할수없음
	하지만 그게 각 요소에 대해서 이해하긴 편하기때문에 자주사용함
	
	객체지향에서 가장 중요한건,역할,책임,협력임
	객체들은 자신이 할수없는 일을 만나면,이걸 해결해주길 요청(리퀘스트)함,그리고 요청받은객체도 다시 요청을 할수있으니,요청은 연쇄적으로 발생함
	그리고 요청에 대해 응답하는것도,요청의 연쇄와 반대방향으로 연쇄적으로 전달됨
	
	역할은 어떤 협력에 참여하는 특정사람이 그 안에서 차지하는 책임,의무임
	어떤 역할을 맡았으면,그 역할을 수행할 책임이 생김,즉 역할음 책임을 암시함
	여기서 중요한점은
		여러사람이 동일한 역할을 수행할수 있음:요청자입장에선 누가하든 결과만 나오면됨
		역할은 대체가능성을 의미함:어떤객체든 같은역할을 수행가능하면 신경쓸필요가없음
		책임수행방법은 알아서해도됨:결과만 나오면,수행방법은 캡슐속에있음
		한객체가 동시에 여러역할을 수행할수있음:단,원칙상으로 권장되진않음
	객체지향 설계라는건,적절한 객체에게 적절한 책임을 할당하는것부터 시작됨
	
	역할은 객체의 페르소나고,관련성높은 책임의 집합임
	
	객체의 덕목은
		객체는 충분히 협력적이어야함,외부의 도움을 무시하고 모든걸 스스로처리하려고하면 내부복잡도가 너무올라가서 자멸함
		그리고 이건 객체가 다른객체의 명령에 따라 행동하는 수동적인 존재라는게 아니라,단순히 다른 요청에 응답할뿐임,
		그리고 요청을 수행할지말지도 요청받은객체가 스스로 결정함
		
		객체는 충분히 자율적이어야함,즉 자기스스로의 원칙에 따라 자신의 행동을 스스로 결정하고 책임져야함,즉 결과물만 리턴하는 책임을 가지고,
		그 결과물을 어떻게만들진 지시받지않고 자기가 스스로결정함
		
	
	객체는 상태와 행동을 같이 지닌 실체임
	이말은 객체가 협력에 참여하기위해 어떤 행동을 해야하면,그 행동을 하는데 필요한 상태도 같이 가지고있어야 한다는걸 의미함
	객체의 자율성은,객체의 내부와 외부를 명확히 구분하는것으로 부터 나옴
	객체의 사적인 부분은 객체 스스로 관리하고 외부에서 간섭할수없게 차단해야하고,객체의 외부에선 접근이 허락된수단을 통해서만 객체와 의사소통해야함
	객체는 다른 객체가 무엇을 수행하는진 알수있지만,어떻게 수행하는진 알수없음
	즉 객체는,상태와 행위를 하나의 단위로 묶는 자율적인 존재임
	
	즉 데이터와 프로세스를 객체라는 하나의 틀안에 함께 묶어서 객체의 자율성을 보장하는게 절차지향과 객체지향의 가장 핵심적인 차이임
	
	객체끼리 서로 의사소통을 하는 방법은 메시지임,메시지를 보내는애를 샌더,받는애를 리시버라고 부름
	
	객체가 메시지를 받았으면,이해할수있는지 여부를 판단한후 정해진 자신의 방법에 따라 메시지를 처리함,이 방법을 메서드라고 함
	객체지향에서 메서드는,클래스 안에 포함된 함수나 프로시저를 통해 구현됨,따라서 어떤 객체에 메시지를 전송하면,
	결과적으로 메시지에 대응되는 특정메서드가 실행됨
	
	이 메시지와 메서드의 분리는,객체의 협력에 참여하는 객체들간의 자율성을 증진시킴
	이건 캡슐화와도 깊이 관련되어있음
	
	즉 객체지향이란
		시스템을 상호작용하는 자율적인 객체들의 공동체로 바라보고,객체를 이용해 시스템을 분할하는 방법
		자율적인 객체란 상태와 행위를 함께지니며,스스로를 책임지는 객체
		객체는 시스템의 행위를 구현하기위해 다른객체와 협력함,각 객체는 협력내에서 정해진 역할을 수행하고,역할은 관련책임의 집합
		객체는 다른 객체와 협력하기위해 메시지를 전송하고,메시지수신객체는 메시지를 처리하는데 적합한 메서드를 자율선택함
		
	객체지향에서의 클래스는,중요한 구성요소인건 맞지만,객체지향의 핵심을 이루는 중심개념이라고 하긴어려움
	클래스가 없는 프로토타입계열 언어에서도 객체지향이 가능하고,거긴 상속없이 위임을 기반으로 동작하니까
	
		
2.이상한 나라의 객체		
	객체는 객체의 행동에따라 자신의 상태를 변경시키고,상태에따라 행동의 결과가 바뀜
	즉 상태를 결정하는건 행동이지만,행동의 결과를 결정하는건 상태임
	예를들면 상태에 따른 분기나,현재상태에서 +-하는게 있는데,이건 현재 상태에 행동이 의존적임(현재 상태를 가져와야 더하든빼든 할수있음)	
	이건 행동간의 순서가 중요하다는것도 의미함
	
	객체는 상태,행동,식별자를 지닌 실체로 볼수있음
	
	객체의 상태는,객체가 행동에 어떻게 반응하는가는 그시점까지 일어난 행동들에 좌우되는데,이걸 하나하나 로그로 남기는거보단(이벤트ms방식),
	현재 상태값을 만들고 그값기준으로 돌리는게 쉬워서 이렇게 사용하는거
	
	그리고 이런 단순한 상태값들은 객체가 아님,즉 이런것들은 그 자체로 독립적인 의미를 가지지못하고,다른 객체의 특성을 표현하는데 사용되기때문
	단 단순한 값이 아닌,객체를 사용해서 다른 객체의 상태를 표현할수도 있음(디자인패턴에서 내부에 인터페이스가 있는 객체를 가지고있는 객체들)
	
	결론적으로 모든 객체의 상태는,단순한값과 객체의 조합으로 표현할수있고,이 객체의 상태를 구성하는 모든 특징들을 통틀어 객체의 프로퍼티라고 함
	일반적으로 프로퍼티는 변경되지않아서 정적이고,프로퍼티값은 계속 바뀌니까 동적임
	
	객체와 객체사이의 의미있는 연결을 링크라고하고,객체끼리는 이 링크를 통해서만 요청을 보내고받을수있음(내부에 객체가 들어있는거)
	
	객체는 외부의 객체가 직접적으로 상태를 변경하거나 할수없어서, 간접적으로 행동을 통해서 상태를 변경하거나 조회할 방법이 필요함
	
	객체의 상태는 무조건 행동을 통해서만 바꿀수있음
	객체가 취하는 행동은 객체 자신의 상태를 변경시킴,이소리는 행동이 사이드이펙트를 초래한다는걸 의미함
	사람이 케이크를 먹으면 몸무게가 늘고 케이크가 줄어드는,2가지이상의 효과가 나타날수 있음
	
	이것처럼 객체의 행동은 객체의 상태를 변경시키지만,행동의 결과는 객체의 상태에 의존적임
	이건
		상호작용이 현재상태에 어떤방식으로 의존하는지
		상호작용이 어떻게 현재상태를 변경시키는지
	를 보면 간단히 볼수있음
	
	
	그리고 모든 객체는 섬이 아니라,다른 객체를 이용하고,다른객체에 서비스를 제공함
	객체가 다른객체와 협력하는 유일한방법은 다른 객체에 요청을 보내는것
	요청을 수신한 객체는 그 요청을 처리하기위해 적절한 방법에 따라 행동함
	
	객체는 협력에 참여하는 과정에서,자기자신의 상태뿐아니라 다른객체의 상태변경을 유발할수도 있음
	즉 직접적으로 수정은 못하니,객체의 행동은
		자신의 상태변경
		행동내에서 협력하는 다른 객체에 대한 메시지 전송
	으로 이루어지게됨
		
	객체지향에서의 객체는,모든 객체가 자신의 상태를 스스로 관리할수있음,즉 음료객체가 자신의 용량을 줄이거나 늘일수있고,얘만 그걸할수있어야함
	사람은 단지 저기에 먹었다는 메시지를 던질뿐임,걔가 무슨일을 할진 모름
	이게 캡슐화가 의미하는것임,객체는 상태를 캡슐안에 감춰두고 밖으로 노출하지않음,객체가 노출하는건 행동뿐이고,접근방법도 행동뿐임
	이렇게 상태를 노출하지않고,행동을 경계로 캡슐화하는건,결과적으로 객체의 자율성을 높여서,협력을 유연하고 간결하게 만듬
	
	객체가 식별가능하다는건,객체를 서로 구별할수있는 특정 프로퍼티가 객체안에 존재한다는것,이걸 식별자라고 부름
	모든 객체가 식별자를 가진다는건,단순값은 식별자를 가지지않는다는것
	값은 숫자,문자,날짜등 변하지 않는 양을 모델링함,값의경우 두 인스턴스의 상태가 같다면,두 인스턴스를 같은것으로 판단함
	이거의 여부는 상태가 같은지를 이용해 판단함
	
	객체는 시간에 따라 변경되는 상태를 포함하고,행동으로 상태를 변경함,즉 가변상태를 가짐
	그래서 같은타입의 두 객체의 상태가 완전히 같더라도,두 객체는 독립적인 객체로 다뤄져야함
	그래서 객체를 구분할수있는 값이 필요한데,그게 식별자고 이 식별자를 통해 객체가 같은지를 판단할수있는 성질을 동일성이라고 함
	
	객체의 행동에서 객체의 상태를 조회하는걸 쿼리라고 하고,객체의 상태를 변경하는걸 커맨드라고 함
	객체의 행동은 대부분 이 두개로 구성됨
	
	
	객체지향에선,상태를 중심으로 객체를 바라보는게 아닌,행동을 중심으로 객체를 바라봐야함
	즉 행동을 먼저 정하고,거기에 필요한 상태를 추가하는 방식으로 하는게 좋음
	거꾸로하면
		상태를 먼저결정하면 캡슐화가 저해됨,상태가 객체외부에 노출될확률이 늘어남
		객체를 협력자가 아닌 고립된섬으로 만듬
		객체의 재사용성이 저하됨
	라는 문제가 생길수 있음
		
	
	현실의 객체와 객체지향의 객체와 가장 큰 차이점은,객체지향의 객체는 의인화가 되어서,스스로 뭔가를 할수있다는것
		
		
		
		
		
		
3.타입과 추상화		
	추상화는 필요없는 정보를 제거하고,필요한 목적에 맞춰서 꼭 필요한 사실만 정확히 표현하는것
	이땐,목적에 맞게 모델을 설계하는게 중요함
	즉 추상화란,현실에서 출발하되,불필요한 부분을 도려내가면서 사물의 본질을 드러내게하는 과정
	이걸통해서 복잡도를 줄일수있음
	
	추상화는
		구체적인 사물간의 공통점은 취하고 차이점은 버리는 일반화를 통해 단순하게만드는것
		중요한부분을 강조하기위해 불필요한 세부사항을 버리는것
	이 두가지를 통해,복잡도를 끌어내림
	
	객체지향 패러다임의 중심엔 구체적이고 실제적인 객체가 존재하지만,그걸 다 인식할순없어서 객체를 여러그룹으로 묶어 가짓수를 줄임
	이처럼 공통점을 기반으로 객체들을 묶기위한 그릇을 개념이라고 함
	개념을 사용하면 객체를 여러 그룹으로 분류할수있음,그리고 그 그룹의 일원이 된 애를 그 개념의 인스턴스 라고 함
	
	객체의 분류장치로써의 개념을 말할떈
		심볼:개념을 가리키는 간략한 이름
		내연:개념의 완전한 정의,이걸통해 객체가 여기속하는지 알수있음
		외연:개념에 속하는 모든 객체의 집합
	으로 구분됨
	
	객체지향에서 제일 유명한게 클래스인걸보면,분류(클래시피케이션)가 얼마나 중요한지를 알수있음
	
	분류란 객체에 특정한 개념을 적용하는작업,이걸 하게되면 그 객체는 특정한 집합의 멤버로 분류하는것
	
	분류는 객체지향의 가장 중요한 개념임,어떤 객체를 어떤 개념으로 분류할지가,객체지향의 품질을 결정함
	이걸 잘해야,유지보수가  쉽고,변화에 대처가 쉬워짐
	
	그리고 분류는 추상화를 위한 도구임,즉 분류를 하면 추상화가 일어남(일반화)
	
	타입은 개념과 완전히 동일함,공통점을 기반으로 객체를 묶기위한 틀
	
	단 컴퓨터로 들어오면서 좀 기계적으로 바뀌는데,
	기본적으로 모든 데이터는 0,1인 바이너리임
	근데 그렇게만 보면 알아보기가 너무힘드니까,그 메모리 조각을 잘라다가,제약을 붙여서 사용하는게 데이터타입임
	즉,데이터에 다른데이터를 사칙연산할수있으면 숫자형,데이터가 여러문자로 구성되면 문자열형같은,
	
	이걸로,데이터의 타입을 결정하는건,어떤 데이터에 어떤 연산자를 적용할수 있냐가 그 데이터의 타입을 결정한다는걸 알수있음
	그리고 타입에 속한 데이터를 메모리에 어떻게 표현하는진,캡슐화가 되어서 몰라도된다는걸 알수있음
	
	실제로 객체지향에서 객체는 일종의 데이터를 포함하고,데이터타입과 객체지향의 타입엔 연관성이 있음
	객체를 타입에 따라 분류하고,그 타입에 이름을 붙이는거
	
	객체는 행위에따라 변하는 상태를 가지고있고,그래서 객체를 모두모으면 애플리케이션 전체데이터를 알수있게됨
	그렇다고 객체가 데이터는 아님,객체에서 중요한건 객체의 행동이고,상태는 그 행동으로 초래된 사이드이펙트를 쉽게 표현하기위해 도입됐을뿐임
	객체를 만들때 가장 중요한건,객체가 다른객체와 협력하기위해 어떤행동을 해야할지 결정하는것
	즉 객체가 협력을 위해 어떤 책임을 지녀야하는지 결정하는게 핵심임
		
	그래서 객체지향에서의 객체의 타입은
		어떤 객체가 어떤 타입에 속하는지 결정하는건 객체의 메서드임,같은메서드를 가지고 있다면 같은타입(같은인터페이스)
		객체의 내부표현은 외부로부터 철저하게 감춰짐(캡슐화)
	를 기반으로 볼수있음
	
	객체가 어떤 행동을 하냐에 따라 객체의 타입이 결정되고,객체의 타입은 객체의 내부표현과는 아무상관이 없다는걸로,
	객체들이 같은 메서드명을 공유하고 있으면,같은 타입이라고 볼수있음 
	객체의 상태가 뭘 가지고있는지등은 아무영향을 주지못함
	
	그래서 같은타입에 속한 객체는 행동만 동일하면 서로 다른 데이터를 가질수 있음
	여기서 동일한 행동이란,동일한 책임을 의미하고,동일한 책임이란 동일한 메시지수신을 의미함(인터페이스에서의 메서드)
	즉,같은 타입에 속한 객체는 같은 메시지를 수신하고 이를 처리할수있다(결과는 다를수있지만 일단 들어가긴함)
	
	이건 다형성에 의미를 부여함,다형성이란 같은 요청에 대해 서로 다른 방식으로 응답할수 있는 능력을 뜻함
	동일한 메시지를 서로 다른 방식으로 처리하기위해선,객체들은 같은메시지를 수신할수있어야 하기 때문에,
	결과적으로 다형적인 객체들은 같은타입에 속하게됨
	
	데이터의 내부표현과 무관하게 행동만이 고려대상이라는건,외부에 데이터를 감춰야한다는것
	즉,행동만을 제공하고 데이터는 행동뒤로 감춰야함,이걸 캡슐화하고 함
	
	행동에 따라 객체를 분류하기위해선 객체의 데이터가 아닌 객체가 외부에 제공해야하는 행동을 먼저 생각해야함
	이를위해서 객체가 외부에 제공해야하는 책임을 먼저 결정하고,그 책임을 수행하는데 필요한 데이터를 나중에 결정한 후,
	데이터를 책임을 수행하는데 필요한 외부인터페이스 뒤로 캡슐화해야함
	이게 책임주도설계(RDD)임
	
	타입객체는 상위인터페이스와 하위인터페이스가 있을수있음,이걸 일반화/특수화 라고 부름
	하위에 속하는애는 자동적으로 상위에도 속하게됨
	이때 상위와 하위의 구분은 상위에서 추가적으로 행동이 추가되었을때를 말함
	
	그리고 당연히 상위의 집합보단 하위의 집합이 더 수가 적고,상위의 행동갯수보다 하위의 행동갯수가 더 수가 많음
	
	이때 상위인터페이스를 슈퍼타입,하위인터페이스를 서브타입 이라고 함
	그리고 서브타입은 슈퍼타입을 대체할수있어야함
	
	일반화는 추상화를 위한 도구임,즉 하위인터페이스가 필요없을경우 추상화해서 상위인터페이스에 몰아넣을수도있음
	
		
	타입을 사용하는 이유는,인지능력상 동적으로 변하는 객체의 복잡성을 극복하기가 어렵기때문
	즉,상태를 배제하고 객체의 상태가 변할수있다는것만 생각해서 상황을 단순하게 만들수있음
	
	즉 타입은 시간에 따라 동적으로 변하는 상태를 시간과 무관한 정적인 모습으로 다룰수있게해줌
	그래서 결국 타입은 추상화임
	
	기본적으로 설계시점에선 정적으로 보고,실행시점에선 동적으로 보는식으로 잘 흘러가게됨
	
	객체지향에서 정적인모델은 클래스를 이용해서 구현됨,따라서 타입을 구현하는 보편적방법은 클래스를 이용하는것
	타입이랑 클래스는 같은게 아니고,클래스는 단지 타입을 구현할수있는 여러 매커니즘에 하나임
	이 둘을 구분하는게 설계를 유연하게하는데 도움이됨
	
	즉 클래스는,타입+코드재사용 용도임
		
		
4.역할,책임,협력		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
	