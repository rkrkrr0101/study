1.협력하는 객체들의 공동체
	객체지향을 설명할때,현실에 빗대서 설명하는건,특정 딱 한요소만 설명할수있고 나머지는 동시에 설명할수없음
	하지만 그게 각 요소에 대해서 이해하긴 편하기때문에 자주사용함
	
	객체지향에서 가장 중요한건,역할,책임,협력임
	객체들은 자신이 할수없는 일을 만나면,이걸 해결해주길 요청(리퀘스트)함,그리고 요청받은객체도 다시 요청을 할수있으니,요청은 연쇄적으로 발생함
	그리고 요청에 대해 응답하는것도,요청의 연쇄와 반대방향으로 연쇄적으로 전달됨
	
	역할은 어떤 협력에 참여하는 특정사람이 그 안에서 차지하는 책임,의무임
	어떤 역할을 맡았으면,그 역할을 수행할 책임이 생김,즉 역할음 책임을 암시함
	여기서 중요한점은
		여러사람이 동일한 역할을 수행할수 있음:요청자입장에선 누가하든 결과만 나오면됨
		역할은 대체가능성을 의미함:어떤객체든 같은역할을 수행가능하면 신경쓸필요가없음
		책임수행방법은 알아서해도됨:결과만 나오면,수행방법은 캡슐속에있음
		한객체가 동시에 여러역할을 수행할수있음:단,원칙상으로 권장되진않음
	객체지향 설계라는건,적절한 객체에게 적절한 책임을 할당하는것부터 시작됨
	
	역할은 객체의 페르소나고,관련성높은 책임의 집합임
	
	객체의 덕목은
		객체는 충분히 협력적이어야함,외부의 도움을 무시하고 모든걸 스스로처리하려고하면 내부복잡도가 너무올라가서 자멸함
		그리고 이건 객체가 다른객체의 명령에 따라 행동하는 수동적인 존재라는게 아니라,단순히 다른 요청에 응답할뿐임,
		그리고 요청을 수행할지말지도 요청받은객체가 스스로 결정함
		
		객체는 충분히 자율적이어야함,즉 자기스스로의 원칙에 따라 자신의 행동을 스스로 결정하고 책임져야함,즉 결과물만 리턴하는 책임을 가지고,
		그 결과물을 어떻게만들진 지시받지않고 자기가 스스로결정함
		
	
	객체는 상태와 행동을 같이 지닌 실체임
	이말은 객체가 협력에 참여하기위해 어떤 행동을 해야하면,그 행동을 하는데 필요한 상태도 같이 가지고있어야 한다는걸 의미함
	객체의 자율성은,객체의 내부와 외부를 명확히 구분하는것으로 부터 나옴
	객체의 사적인 부분은 객체 스스로 관리하고 외부에서 간섭할수없게 차단해야하고,객체의 외부에선 접근이 허락된수단을 통해서만 객체와 의사소통해야함
	객체는 다른 객체가 무엇을 수행하는진 알수있지만,어떻게 수행하는진 알수없음
	즉 객체는,상태와 행위를 하나의 단위로 묶는 자율적인 존재임
	
	즉 데이터와 프로세스를 객체라는 하나의 틀안에 함께 묶어서 객체의 자율성을 보장하는게 절차지향과 객체지향의 가장 핵심적인 차이임
	
	객체끼리 서로 의사소통을 하는 방법은 메시지임,메시지를 보내는애를 샌더,받는애를 리시버라고 부름
	
	객체가 메시지를 받았으면,이해할수있는지 여부를 판단한후 정해진 자신의 방법에 따라 메시지를 처리함,이 방법을 메서드라고 함
	객체지향에서 메서드는,클래스 안에 포함된 함수나 프로시저를 통해 구현됨,따라서 어떤 객체에 메시지를 전송하면,
	결과적으로 메시지에 대응되는 특정메서드가 실행됨
	
	이 메시지와 메서드의 분리는,객체의 협력에 참여하는 객체들간의 자율성을 증진시킴
	이건 캡슐화와도 깊이 관련되어있음
	
	즉 객체지향이란
		시스템을 상호작용하는 자율적인 객체들의 공동체로 바라보고,객체를 이용해 시스템을 분할하는 방법
		자율적인 객체란 상태와 행위를 함께지니며,스스로를 책임지는 객체
		객체는 시스템의 행위를 구현하기위해 다른객체와 협력함,각 객체는 협력내에서 정해진 역할을 수행하고,역할은 관련책임의 집합
		객체는 다른 객체와 협력하기위해 메시지를 전송하고,메시지수신객체는 메시지를 처리하는데 적합한 메서드를 자율선택함
		
	객체지향에서의 클래스는,중요한 구성요소인건 맞지만,객체지향의 핵심을 이루는 중심개념이라고 하긴어려움
	클래스가 없는 프로토타입계열 언어에서도 객체지향이 가능하고,거긴 상속없이 위임을 기반으로 동작하니까
	
		
2.이상한 나라의 객체		
	객체는 객체의 행동에따라 자신의 상태를 변경시키고,상태에따라 행동의 결과가 바뀜
	즉 상태를 결정하는건 행동이지만,행동의 결과를 결정하는건 상태임
	예를들면 상태에 따른 분기나,현재상태에서 +-하는게 있는데,이건 현재 상태에 행동이 의존적임(현재 상태를 가져와야 더하든빼든 할수있음)	
	이건 행동간의 순서가 중요하다는것도 의미함
	
	객체는 상태,행동,식별자를 지닌 실체로 볼수있음
	
	객체의 상태는,객체가 행동에 어떻게 반응하는가는 그시점까지 일어난 행동들에 좌우되는데,이걸 하나하나 로그로 남기는거보단(이벤트ms방식),
	현재 상태값을 만들고 그값기준으로 돌리는게 쉬워서 이렇게 사용하는거
	
	그리고 이런 단순한 상태값들은 객체가 아님,즉 이런것들은 그 자체로 독립적인 의미를 가지지못하고,다른 객체의 특성을 표현하는데 사용되기때문
	단 단순한 값이 아닌,객체를 사용해서 다른 객체의 상태를 표현할수도 있음(디자인패턴에서 내부에 인터페이스가 있는 객체를 가지고있는 객체들)
	
	결론적으로 모든 객체의 상태는,단순한값과 객체의 조합으로 표현할수있고,이 객체의 상태를 구성하는 모든 특징들을 통틀어 객체의 프로퍼티라고 함
	일반적으로 프로퍼티는 변경되지않아서 정적이고,프로퍼티값은 계속 바뀌니까 동적임
	
	객체와 객체사이의 의미있는 연결을 링크라고하고,객체끼리는 이 링크를 통해서만 요청을 보내고받을수있음(내부에 객체가 들어있는거)
	
	객체는 외부의 객체가 직접적으로 상태를 변경하거나 할수없어서, 간접적으로 행동을 통해서 상태를 변경하거나 조회할 방법이 필요함
	
	객체의 상태는 무조건 행동을 통해서만 바꿀수있음
	객체가 취하는 행동은 객체 자신의 상태를 변경시킴,이소리는 행동이 사이드이펙트를 초래한다는걸 의미함
	사람이 케이크를 먹으면 몸무게가 늘고 케이크가 줄어드는,2가지이상의 효과가 나타날수 있음
	
	이것처럼 객체의 행동은 객체의 상태를 변경시키지만,행동의 결과는 객체의 상태에 의존적임
	이건
		상호작용이 현재상태에 어떤방식으로 의존하는지
		상호작용이 어떻게 현재상태를 변경시키는지
	를 보면 간단히 볼수있음
	
	
	그리고 모든 객체는 섬이 아니라,다른 객체를 이용하고,다른객체에 서비스를 제공함
	객체가 다른객체와 협력하는 유일한방법은 다른 객체에 요청을 보내는것
	요청을 수신한 객체는 그 요청을 처리하기위해 적절한 방법에 따라 행동함
	
	객체는 협력에 참여하는 과정에서,자기자신의 상태뿐아니라 다른객체의 상태변경을 유발할수도 있음
	즉 직접적으로 수정은 못하니,객체의 행동은
		자신의 상태변경
		행동내에서 협력하는 다른 객체에 대한 메시지 전송
	으로 이루어지게됨
		
	객체지향에서의 객체는,모든 객체가 자신의 상태를 스스로 관리할수있음,즉 음료객체가 자신의 용량을 줄이거나 늘일수있고,얘만 그걸할수있어야함
	사람은 단지 저기에 먹었다는 메시지를 던질뿐임,걔가 무슨일을 할진 모름
	이게 캡슐화가 의미하는것임,객체는 상태를 캡슐안에 감춰두고 밖으로 노출하지않음,객체가 노출하는건 행동뿐이고,접근방법도 행동뿐임
	이렇게 상태를 노출하지않고,행동을 경계로 캡슐화하는건,결과적으로 객체의 자율성을 높여서,협력을 유연하고 간결하게 만듬
	
	객체가 식별가능하다는건,객체를 서로 구별할수있는 특정 프로퍼티가 객체안에 존재한다는것,이걸 식별자라고 부름
	모든 객체가 식별자를 가진다는건,단순값은 식별자를 가지지않는다는것
	값은 숫자,문자,날짜등 변하지 않는 양을 모델링함,값의경우 두 인스턴스의 상태가 같다면,두 인스턴스를 같은것으로 판단함
	이거의 여부는 상태가 같은지를 이용해 판단함
	
	객체는 시간에 따라 변경되는 상태를 포함하고,행동으로 상태를 변경함,즉 가변상태를 가짐
	그래서 같은타입의 두 객체의 상태가 완전히 같더라도,두 객체는 독립적인 객체로 다뤄져야함
	그래서 객체를 구분할수있는 값이 필요한데,그게 식별자고 이 식별자를 통해 객체가 같은지를 판단할수있는 성질을 동일성이라고 함
	
	객체의 행동에서 객체의 상태를 조회하는걸 쿼리라고 하고,객체의 상태를 변경하는걸 커맨드라고 함
	객체의 행동은 대부분 이 두개로 구성됨
	
	
	객체지향에선,상태를 중심으로 객체를 바라보는게 아닌,행동을 중심으로 객체를 바라봐야함
	즉 행동을 먼저 정하고,거기에 필요한 상태를 추가하는 방식으로 하는게 좋음
	거꾸로하면
		상태를 먼저결정하면 캡슐화가 저해됨,상태가 객체외부에 노출될확률이 늘어남
		객체를 협력자가 아닌 고립된섬으로 만듬
		객체의 재사용성이 저하됨
	라는 문제가 생길수 있음
		
	
	현실의 객체와 객체지향의 객체와 가장 큰 차이점은,객체지향의 객체는 의인화가 되어서,스스로 뭔가를 할수있다는것
		
		
		
		
		
		
3.타입과 추상화		
	추상화는 필요없는 정보를 제거하고,필요한 목적에 맞춰서 꼭 필요한 사실만 정확히 표현하는것
	이땐,목적에 맞게 모델을 설계하는게 중요함
	즉 추상화란,현실에서 출발하되,불필요한 부분을 도려내가면서 사물의 본질을 드러내게하는 과정
	이걸통해서 복잡도를 줄일수있음
	
	추상화는
		구체적인 사물간의 공통점은 취하고 차이점은 버리는 일반화를 통해 단순하게만드는것
		중요한부분을 강조하기위해 불필요한 세부사항을 버리는것
	이 두가지를 통해,복잡도를 끌어내림
	
	객체지향 패러다임의 중심엔 구체적이고 실제적인 객체가 존재하지만,그걸 다 인식할순없어서 객체를 여러그룹으로 묶어 가짓수를 줄임
	이처럼 공통점을 기반으로 객체들을 묶기위한 그릇을 개념이라고 함
	개념을 사용하면 객체를 여러 그룹으로 분류할수있음,그리고 그 그룹의 일원이 된 애를 그 개념의 인스턴스 라고 함
	
	객체의 분류장치로써의 개념을 말할떈
		심볼:개념을 가리키는 간략한 이름
		내연:개념의 완전한 정의,이걸통해 객체가 여기속하는지 알수있음
		외연:개념에 속하는 모든 객체의 집합
	으로 구분됨
	
	객체지향에서 제일 유명한게 클래스인걸보면,분류(클래시피케이션)가 얼마나 중요한지를 알수있음
	
	분류란 객체에 특정한 개념을 적용하는작업,이걸 하게되면 그 객체는 특정한 집합의 멤버로 분류하는것
	
	분류는 객체지향의 가장 중요한 개념임,어떤 객체를 어떤 개념으로 분류할지가,객체지향의 품질을 결정함
	이걸 잘해야,유지보수가  쉽고,변화에 대처가 쉬워짐
	
	그리고 분류는 추상화를 위한 도구임,즉 분류를 하면 추상화가 일어남(일반화)
	
	타입은 개념과 완전히 동일함,공통점을 기반으로 객체를 묶기위한 틀
	
	단 컴퓨터로 들어오면서 좀 기계적으로 바뀌는데,
	기본적으로 모든 데이터는 0,1인 바이너리임
	근데 그렇게만 보면 알아보기가 너무힘드니까,그 메모리 조각을 잘라다가,제약을 붙여서 사용하는게 데이터타입임
	즉,데이터에 다른데이터를 사칙연산할수있으면 숫자형,데이터가 여러문자로 구성되면 문자열형같은,
	
	이걸로,데이터의 타입을 결정하는건,어떤 데이터에 어떤 연산자를 적용할수 있냐가 그 데이터의 타입을 결정한다는걸 알수있음
	그리고 타입에 속한 데이터를 메모리에 어떻게 표현하는진,캡슐화가 되어서 몰라도된다는걸 알수있음
	
	실제로 객체지향에서 객체는 일종의 데이터를 포함하고,데이터타입과 객체지향의 타입엔 연관성이 있음
	객체를 타입에 따라 분류하고,그 타입에 이름을 붙이는거
	
	객체는 행위에따라 변하는 상태를 가지고있고,그래서 객체를 모두모으면 애플리케이션 전체데이터를 알수있게됨
	그렇다고 객체가 데이터는 아님,객체에서 중요한건 객체의 행동이고,상태는 그 행동으로 초래된 사이드이펙트를 쉽게 표현하기위해 도입됐을뿐임
	객체를 만들때 가장 중요한건,객체가 다른객체와 협력하기위해 어떤행동을 해야할지 결정하는것
	즉 객체가 협력을 위해 어떤 책임을 지녀야하는지 결정하는게 핵심임
		
	그래서 객체지향에서의 객체의 타입은
		어떤 객체가 어떤 타입에 속하는지 결정하는건 객체의 메서드임,같은메서드를 가지고 있다면 같은타입(같은인터페이스)
		객체의 내부표현은 외부로부터 철저하게 감춰짐(캡슐화)
	를 기반으로 볼수있음
	
	객체가 어떤 행동을 하냐에 따라 객체의 타입이 결정되고,객체의 타입은 객체의 내부표현과는 아무상관이 없다는걸로,
	객체들이 같은 메서드명을 공유하고 있으면,같은 타입이라고 볼수있음 
	객체의 상태가 뭘 가지고있는지등은 아무영향을 주지못함
	
	그래서 같은타입에 속한 객체는 행동만 동일하면 서로 다른 데이터를 가질수 있음
	여기서 동일한 행동이란,동일한 책임을 의미하고,동일한 책임이란 동일한 메시지수신을 의미함(인터페이스에서의 메서드)
	즉,같은 타입에 속한 객체는 같은 메시지를 수신하고 이를 처리할수있다(결과는 다를수있지만 일단 들어가긴함)
	
	이건 다형성에 의미를 부여함,다형성이란 같은 요청에 대해 서로 다른 방식으로 응답할수 있는 능력을 뜻함
	동일한 메시지를 서로 다른 방식으로 처리하기위해선,객체들은 같은메시지를 수신할수있어야 하기 때문에,
	결과적으로 다형적인 객체들은 같은타입에 속하게됨
	
	데이터의 내부표현과 무관하게 행동만이 고려대상이라는건,외부에 데이터를 감춰야한다는것
	즉,행동만을 제공하고 데이터는 행동뒤로 감춰야함,이걸 캡슐화하고 함
	
	행동에 따라 객체를 분류하기위해선 객체의 데이터가 아닌 객체가 외부에 제공해야하는 행동을 먼저 생각해야함
	이를위해서 객체가 외부에 제공해야하는 책임을 먼저 결정하고,그 책임을 수행하는데 필요한 데이터를 나중에 결정한 후,
	데이터를 책임을 수행하는데 필요한 외부인터페이스 뒤로 캡슐화해야함
	이게 책임주도설계(RDD)임
	
	타입객체는 상위인터페이스와 하위인터페이스가 있을수있음,이걸 일반화/특수화 라고 부름
	하위에 속하는애는 자동적으로 상위에도 속하게됨
	이때 상위와 하위의 구분은 상위에서 추가적으로 행동이 추가되었을때를 말함
	
	그리고 당연히 상위의 집합보단 하위의 집합이 더 수가 적고,상위의 행동갯수보다 하위의 행동갯수가 더 수가 많음
	
	이때 상위인터페이스를 슈퍼타입,하위인터페이스를 서브타입 이라고 함
	그리고 서브타입은 슈퍼타입을 대체할수있어야함
	
	일반화는 추상화를 위한 도구임,즉 하위인터페이스가 필요없을경우 추상화해서 상위인터페이스에 몰아넣을수도있음
	
		
	타입을 사용하는 이유는,인지능력상 동적으로 변하는 객체의 복잡성을 극복하기가 어렵기때문
	즉,상태를 배제하고 객체의 상태가 변할수있다는것만 생각해서 상황을 단순하게 만들수있음
	
	즉 타입은 시간에 따라 동적으로 변하는 상태를 시간과 무관한 정적인 모습으로 다룰수있게해줌
	그래서 결국 타입은 추상화임
	
	기본적으로 설계시점에선 정적으로 보고,실행시점에선 동적으로 보는식으로 잘 흘러가게됨
	
	객체지향에서 정적인모델은 클래스를 이용해서 구현됨,따라서 타입을 구현하는 보편적방법은 클래스를 이용하는것
	타입이랑 클래스는 같은게 아니고,클래스는 단지 타입을 구현할수있는 여러 매커니즘에 하나임
	이 둘을 구분하는게 설계를 유연하게하는데 도움이됨
	
	즉 클래스는,타입+코드재사용 용도임
		
		
4.역할,책임,협력	
	객체지향에서 제일 중요한건 협력임
	중요한건 개별객체가 아니라 객체들 사이에서 이뤄지는 협력임,
	객체지향 설계의 전체품질을 결정하는건 개별객체의 품질이 아니라 여러 객체들이 모여 이뤄내는 협력의 품질임
	좋은 앱은,객체들간의 요청과 응답속에서 창발하는 협력에 초점을 맞춰서 설계됨
	협력이 자리를 잡으면 객체의 행동이 드러나고 뒤이어 적절한 객체의 상태가 결정됨
	
	협력은 한객체가 다른객체에게 도움을 요청할때 시작됨
	자신에게 할당된일이나 업무를 처리하는중에 스스로 해결하기어려운일에 부딫치게되면 다른객체에 도움을 요청하고,걔도 다시 다른객체에 도움을 요청할수있게되면서
	연쇄적으로 요청과 응답이 일어남
	
	그리고 특정 요청을 받아들일수 있는 이유는,그 요청에 대해 적절한 방식으로 응답하는데 필요한 지식과 행동방식을 가지고있기때문이고,
	요청과 응답은 협력에 참여하는 객체가 수행할 책임을 정의함
	
	객체지향에서 제일 중요한건,책임을 어떻게 할당하느냐가 제일 중요하고,책임을 어떻게 구현할것인가는 다 정해지고 나서 고려해도 상관없음
	객체와 책임이 막 흔들릴때,성급하게 구현하는건 변경에 취약하고 다양한 협력에 참여할수없는 비자율적인 객체를 낳게됨
	
	책임은 객체가 알아야하는 정보와 객체가 수행할수있는 행위에 대해 개략적으로 서술한것
	즉 객체의 책임은,객체가 무엇을 알고있는가 와 객체가 무엇을 할수있는가 로 구성됨
	즉,하는것과 아는것
	하는것엔
		객체를 생성하거나 계산을 하는등의 스스로하는것
		다른 객체의 활동을 시작시키는것
		다른 객체의 활동을 제어하고 조절하는것
	아는것엔
		개인적인 정보에 대해 아는것
		관련된 객체에 대해 아는것
		자신이 유도하거나 계산할수있는것에 대해 아는것
	이 있음
	
	객체의 책임을 말할땐,일반적으로 외부에서 접근가능한 공용서비스의 관점에서 이야기함
	즉 책임은 객체의 외부에 제공해줄수 있는 정보와,외부에 제공해줄수 있는 서비스의ㅣ 목록임
	따라서 책임은 공용인터페이스를 구성함,이건 캡슐화와 이어짐
	
	협력안에서 객체는,다른객체로부터 요청이 전송되었을때만 책임을 수행함
	이처럼 객체가 다른객체에 주어진 책임을 수행하도록 요청을 보내는것을 메시지전송이라고 함
	즉 두 객체간 협력은 메시지를 통해 이뤄지고,메시지를 보내는애는 송신자,받는애는 수신자 라고 함
	
	책임이 협력이라는 문맥속에 요청을 받는쪽의 관점에서 뭘할수있는지를 나열하는거라면,메시지는 두 객체사이관계를 강조한것임
	즉 메시지를 보내는쪽은 받는쪽이 이해할수 있는 메시지를 전송할수있고,받는쪽은 받은메시지에 대해 적절한 책임을 수행할수 있음
	
	주의점은 책임과 메시지의 수준이 같지않다는것,책임은 객체가 협력에 참여하기위해 수행할행위를 개략적으로 서술한거고,
	하나의 책임을 정제하면서 메시지로 변환할때는 여러 메시지로 분할되는게 일반적임
	
	설계초반엔 어떤객체가 어떤책임을 가지고 어떻게 협력하는지에 대한 개요만 알면되고,
	어떤 클래스가 필요하고 어떤 메서드를 포함해야하는진 설계끝나고 결정해도됨
	
	
	책임의 집합은 역할이고,역할은 재사용 가능하고,유연한 객체지향설계를 낳음
	즉 같은 역할을 가진 객체면,대체가능하고,그러면 하나의 루틴으로 추상화해서 객체만 선택해가면서 바꿔가며 돌릴수있음
	즉 같은 인터페이스를 상속받았으면,그 인터페이스를 필요로하는 모든곳에 들어갈수있음
	
	역할을 사용하면,단순성,유연성,재사용성을 올릴수있음
	그리고 가장 큰 가치는,하나의 협력안에 여러종류의 객체가 참여할수있게되면서,협력을 추상화할수있다는것
	
	역할은 협력안에서 구체적인 객체로 대체될수있는 추상적인 협력자임,
	즉 본질적으로 역할은 다른객체에 의해 대체가능함을 의미함
	
	객체가 역할을 대체하기위해선 행동이 호환되어야함,어떤 객체가 증인이라는 역할을 대체할수있는 이유는,그 객체가 증인석에 입장할수있고,증언할수있기때문
	결국 객체는 협력안에서 역할이 수행하는 행동을 그대로 수행할수있어야함
	단,역할에 있는 책임 이외에도 다른 책임을 수행하는건 상관없음,즉 두개이상의 역할을 가져도 상관없음
	즉 일반화/특수화관계가 성립하는게 일반적임
	
	
	객체는 시스템에 필요한 데이터를 저장하기위해 객체가 있는게 아니라,그건 단지 행위를 수행할때 필요한 재료일뿐이고,
	객체는 행위를 수행하며 협력에 참여하기 위해서 존재함,따라서 실제로 중요한건 객체의 행동,즉 책임임
	
	그리고 객체지향은 클래스와 클래스간의 관계를 표현하는 시스템의 정적인측면에 중점을 두는게 아닌,
	클래스는 시스템에 필요한 객체를 표현하고 생성하기위한 도구일뿐이고,정적인 클래스가 아닌 동적인 객체가 중요하고,
	얘들이 협력안에서 어떤책임과 역할을 수행할것인가가 중요함
	
	올바른 객체를 설계하기위해선 견고하고 깔끔한 협력을 먼저 설계해야함
	이건 설계에 참여하는 객체들이 주고받을 요청과 응답흐름을 결정한다는걸 의미함
	이렇게 결정된 요청응답흐름은 객체가 협력에 참여하기위해 수행될 책임이 됨
	그리고 객체가 협력에 참여하기위해 필요한 데이터와 행동이 어느정도 결정된 후에 클래스구현방법을 결정하면됨
	즉,클래스와 데이터는 협력과 책임집합이 결정된 후에야 등장함
	
	객체지향이 올바른객체에 올바른책임을 할당하는것과 관련된 모든것이라면,협력이라는 문맥안에서 객체를 생각하는건,
	올바른 객체지향앱을 구현하는것과 관련된 모든것임
	협력이라는 견고한문맥이 갖춰지면,우리의 초점은 협력을 위해 필요한 책임의 흐름으로 옮겨짐,그리고 협력에 필요한 책임을 결정하고,
	객체에게 책임을 할당하는과정을 얼마나 합리적이고 적절하게 수행했는지가 객체지향설계품질을 담당함
	
	객체의 행위에 초점을 맞추기위해선,협력이라는 문맥내에서 책임을 분배해야함
	각 객체가 가질 상태와 행위에 대해 고민하기전에,그 객체가 참여할 문맥인 협력을 정의하면됨
	즉 객체를 충분히 협력적으로 만든후에 그안에서 자율적으로 만들어야함
	
	
	책임주도설계는 객체의 책임을 중심으로 시스템을 구축하는 설계방법임
	시스템의 기능은 더 작은 규모의 책임으로 분할되고,각 책임은 책임을 수행할 적절한 객체에 할당됨
	객체가 책임을 수행하는도중에 스스로 처리할수없는 정보나 기능이 필요하면,적절한 객체를 찾아 필요한작업을 요청함
	요청된 작업을 수행하는일은 작업을 위임받은 객체의 책임으로 변환됨
	이렇게 객체가 다른객체에 작업을 요청하는 행위를 통해 협력관계가 만들어지고,책임을 여러객체가 수행할수있으면 협력자는 객체가 아닌 추상적인역할로 대체됨
	
	이렇게 책임주도설계에선 시스템의 책임을 객체의 책임으로 변환하고,각 객체가 책임을 수행할때 필요한 정보나 서비스를 제공할 협력자를 찾아,
	해당 협력자에게 책임을 할당하는 순차적방식으로 객체의 협력공동체를 구축함
	책임주도설계는 개별객체상태가 아니라 객체의 책임과 상호작용에 집중함
	결과적으로 시스템은,스스로 자신을 책임질수있을정도로 자율적이면서,다른객체들과 협력할수있는 객체들로 이뤄지게됨
	이때 설계순서는
		시스템이 사용자에게 제공해야하는 기능인 시스템책임을 파악
		시스템책임을 더 작은책임으로 분할
		분할된 책임을 수행할수있는 적절한 객체또는 역할을 찾아 책임을 할당
		객체가 책임을 수행하는중에 다른객체의 도움이 필요하면,이를 책임질 적절한 객체또는 역할을 찾음
		해당객체나 역할에 책임을 할당해서 두객체를 협력시킴
	이순서임
	
	디자인패턴은 책임주도설계가 이뤄진 결과물의 템플릿임
	패턴은 해결할문제가 무엇있지 정확히 서술하고,패턴을 적용할수있는상황과 아닌상황을 함께설명함
	여기서 중요한건 패턴의 세부구조가 아니라,협력에 참여하는 역할과 책임임
	
	테스트주도개발은,실패하는 테스트를 작성하고,그 테스트를 통과하는 간단한코드를 작성한후,리팩토링으로 중복을 제거하는것
	이걸 하면 작동하는 깔끔한코드를 얻을수있음
	테스트주도개발을 할땐,객체가 이미 존재한다고 가정하고,객체에게 어떤메시지를 전송할것인지에 관해 먼저 생각해야함
	즉 테스트를 작성하는게 메인이 아닌,책임을 수행할 객체가 기대하는객체의 역할이 메시지를 수신할때 어떤 결과를 반환하고,
	그과정에서 어떤 객체와 협력할것인지에 대한 기대를 코드형태로 작성하는것
	
	테스트주도개발을 하는이유는,테스트를 얻기위함이 아니라,책임주도설계보다 쉽고 안전하게 설계하기위한 방식일뿐임
	테스트는 덤으로 나오는거고
	
	
5.책임과 메시지
	객체지향의 기본단위는 자율적인 객체임
	여기서 중요한건 자율성인데,자율적인 객체란 스스로 정한 원칙에 따라 판단하고,스스로의 의지를 기반으로 행동하는객체임
	
	객체가 어떤 행동을 하는 유일한 이유는,다른 객체로부터 요청을 수신했기때문,여기서 요청을 처리하기위해 객체가 수행하는 행동을 책임이라고 함
	따라서 자율적인 객체란 스스로의 의지와 판단에 따라 각자 맡은책임을 수행하는 객체임
	
	객체가 책임을 자율적으로 수행하기 위해선,객체에 할당되는 책임이 자율적이어야함
	만약 책임이 자율적이지않고 뭘할지를 다 정해준다면,서로간에 결합성도 늘어나고,거기에 없는방식으로 처리하는게 더 효율적이어도 그렇게하지 못하게됨
	그리고 자율성도 떨어지게됨
	
	그렇다고 항상 포괄적이고 추상적책임을 선택한다고해서 좋은건 또아님
	책임이 너무 구체적인것도 문제지만,협력의 의도를 명확히 표현못할정도로 추상적인거도 또 문제임
	
	즉,추상화될수록 재사용성과 유연성이 올라가지만,너무 추상화되면 그자체로는 사용이 힘들어짐(평타한대칠거 평타두대쳐야함,즉 공격력과 공속의 트레이드오프)
	그래서 상황에 맞게 적절히 추상화를 해야함
	
	자율적인 책임의 특징은,어떻게가 아니라 무엇을 해야하는지를 설명하는것
	즉 뭘할지만 정해주고,어떻게할지는 객체내에서 알아서 정하는식임
	
	그리고 객체는 메시지를 수신할때만 어떤 행동을 시작함,따라서 객체가 자신의 책임을 수행하게 만드는건,외부에서 전달되는 요청임
	그리고 객체가 다른객체에 접근할수있는 유일한 방법은 요청을 전송하는것뿐임,이게 메시지임
	
	하나의 객체는 메시지를 전송함으로써 다른객체에 접근함,여기서 메시지는
	수신자명(객체명),메시지명(메소드명),인자(아규멘트)로 구성됨
		
	메시지를 수신받은 객체는,우선 그걸 자신이 처리할수있는지(그런메소드가 있고,인자구성이 맞는지)를 확인하고,
	맞으면 내부루틴으로 넘어가서동작한뒤에 리턴을넘김
	여기서 송신자는,메시지가 바뀌지않으면 내부루틴이 바뀌더라도 그 사실을 알수없음,즉 객체의 외부와 내부가 메시지를 기준으로 분리된다는걸 의미함
	
	객체지향에서 메서드는,클래스안에 포함된 함수나 프로시저를 통해 구현됨,
	따라서 어떤 객체에 메시지를 전송하면 결과적으로 메시지에 대응되는 특정 메서드가 실행됨
	메시지는 어떻게 수행될지는 명시하지않고,무엇이 실행되기를 바라는지만 명시하고,어떤 메서드를 선택할지는 수신자에게 달려있음
	
	이 메시지를 수신한 객체가 실행시간에 메서드를 선택할수있다는사실은,절차지향(컴파일시간에 결정)과의 가장 큰 차이점임
	
	이 메시지와 메서드의 차이와 관계를 알면(메시지만 보내고 메서드는 수신자가 선택),다형성이해가 쉬워짐
	다형성이란 서로 다른 유형의 객체가 동일한 메시지에 대해 서로 다르게 반응하는걸 의미함
	좀 더 구체적으론 서로 다른 타입에 속하는 객체들이,같은메시지를 수신할경우 서로 다른 메서드를 이용해 메시지를 처리하는 메커니즘
	
	메시지는 무엇이 실행될지는 명시하지만,어떻게 실행할지는 수신자가 결정할수있음,메시지엔 처리방법과 관련된 어떤 제약도 없으므로,같은메시지라고 해도
	서로 다른 방식의 메서드를 이용해 처리할수있음
	즉 다형성을 하나의 메시지와 하나이상의 메서드사이의 관계로 볼수있음
	
	다형성은 역할,책임,협력과 깊은 관련이 있음
	서로 다른 객체들이 다형성을 만족시킨다는건,객체들이 같은책임을 공유한다는것
	다형성에서 중요한건 송신자의 관점임
	수신자들이 같은오퍼레이션을 다른방식으로 처리하더라도,이 객체들은 같은책임을 수행하는것
	즉 송신자의 관점에서 다형적인 수신자들을 구별할 필요가 없으며,자신의 요청을 수행할 책임을 지닌다는점에서 모두 동일함
	
	기본적으로 다형성은 같은 역할을 수행할수 있는 객체들 사이의 대체가능성을 의미함
	다형성은 객체들의 대체가능성을 이용해서 설계를 유연하고 재사용가능하게 만듬,다형성을 사용하면,송신자가 수신자의 종류를 몰라도 메시지를 전송할수있음
	즉 다형성은 수신자의 종류를 캡슐화함
	
	그리고 다형성은,송신자와 수신자간의 객체타입에 대한 결합도를,메시지에 대한 결합도를 낮춤으로써 달성함
	
	송신자는,수신자가 메시지를 이해할수있다는 사실만 알고있는 상태에서 협력에 참여함,
	이건 설계품질에 큰 영향을 미침
		협력이 유연해짐,송신자는 수신자가 메시지를 이해하기만하면 누구든 상관없음,이걸 대체해도 송신자는 관심없으니 쉽게쉽게 변경가능
		협력의 수행방식을 확장할수있음,송신자에게 아무영향을 안주고 수신자를 교체할수있기때문에 협력의 세부수행방식을 쉽게수정할수있음
		협력수행방식을 재사용할수있음,협력에 영향을 안주고 다른객체들이 수신자를 대체할수있어서 재사용이쉬움
	
	이 모든건 메시지가 다형성을 지탱하고있기때문
	메시지는 송수신자사이의 결합도를 낮춰서 설계를 유연하고 확장가능하고 재사용가능하게 만듬
	송신자는 오직 메시지만 바라보고,수신자의 정확한 타입을 몰라도 상관없음
	그래서 설계의 품질을 높이려면,훌륭한 메시지를 선택해야함
	
	객체지향의 중심사상은 연쇄적으로 메시지를 전송하고 수신하는 객체들 사이의 협력관계를 기반으로 사용자에게 유용한 기능을 제공하는것
	
	객체지향에서 클래스도 중요하지만,그것보다 중요한건 객체들이 주고받는 메시지임
	객체지향앱은 클래스로 만들지만,메시지를 통해 정의됨
	클래스는 단지 동적인 객체들의 특성과 행위를 정적인 텍스트로 표현하기위해 사용할수있는 추상화 도구일뿐임
	그래서 클래스를 정의하는것보다,객체들의 속성과 행위를 식별하는게 먼저임
	클래스는 그 객체의 속성과 행위를 담는 틀일 뿐임
	
	그리고 객체의 행위와 속성보다 중요한건,객체사이의 협력임
	이걸 먼저 생각하고,거기에 객체의 행위와 속성을 끼워맞춰야함
	객체를 이용하는 중요한이유는,객체가 다른객체가 필요로하는 행위를 제공하기때문
	
	객체가 자신에게 할당된 책임을 수행할떈,다른객체와 협력해야함
	객체지향설계는 적절한 책임을 적절한객체에게 할당하면서,메시지를 기반으로 협력하는 객체들의 관계를 발견하는 과정임
	이런방식을 책임주도설계라고 함
	
	책임주도설계에서 역할,책임,협력을 식별하는건,앱이 수행하는 기능을 시스템의 책임으로 보는것부터 시작됨
	그리고 그걸 구현하기위해 협력관계를 시작할 적절한 객체를 찾아 시스템의 책임을 객체의 책임으로 할당하고,
	객체가 책임완수를위해 다른객체의 도움이 필요하다고 판단되면,도움요청을 위해 어떤 메시지가 필요한지 결정함
	메시지를 결정한 후엔 메시지를 수신하기에 적합한 객체를 선택함
	수신자는 송신자가 메시지를 보내면서 기대한바를 충족시켜야함
	
	결과적으로 메시지가 수신자의 책임을 결정함
	
	책임주도설계의 핵심은,어떤 행위가 필요한지를 먼저 결정한 후에 이 행위를 수행할 객체를 결정하는것
	이걸 what/who 사이클이라고 함
	
	객체의 행위를 결정하는건,객체의 속성이 아님,어떤 속성이 있다고해서 반드시 그와 관련된 행위를 수행할거라고 가정하면안됨
	먼저 책임이 오고 객체가 책임을 따르고,행위가 생성됨
	그리고 먼저 메시지가 결정된후에 그 메시지가 어디로갈지 객체중에서 후보를뽑음
	
	메시지를 먼저 결정하고 객체가 메시지를 따르게하는방식은,객체가 외부에 제공하는 인터페이스가 독특한 스타일을 따르게함
	이걸 데메테르법칙이라고 함
	
	책임주도설계는 객체가 아니라,메시지에 초점을 맞춰서 장점을 극대화함
	메시지를 결정하는 시점에선 어떤 객체가 메시지를 수신할지를 알수없기때문에,당연히 메시지송신자는 메시지를 수신할 객체의 내부상태를 볼수없음
	그래서 메시지중심의 설계는 수신자의 캡슐화를 증진시키고,둘은 느슨하게 결합됨
	
	그리고 메시지를 결정한시점에선 누구한테 갈지모르니 꼬치꼬치캐물을수없고,잘 처리해주길 기도할수밖에 없음
	
	객체는 다른객체의 상태를 묻지말아야함,객체가 다른객체의 상태를 묻는다는건,객체가 가질상태에 관해 너무 고민이 많다는것,
	고민을 연기하고,보내고나서 받는애가 그걸 스스로 처리할지말지 선택하게 해야함
	
	즉 객체가 자신이 수신할 메시지를 결정하게하지말고,메시지가 협력에 필요한 객체를 발견해야함
	
	인터페이스란 어떤 두 사물이 마주치는 경계에서,서로를 상호작용할수있게 이어주는 방식이나 장치임
	인터페이스의 특징은
		인터페이스의 사용법만 익히면 내부를 몰라도 사용가능해야함
		인터페이스자체는 변경하지않고,내부구성이나 작동방식을 변경하는건 사용자에게 영향을미치면안됨
		대상이 변경되더라도 같은인터페이스를 제공하기만하면 아무문제없이 상호작용할수있어야함
		
	객체가 다른객체와 상호작용할수있는 유일한 방법은 메시지전송임,따라서 객체의 인터페이스는 객체가 수신할수있는 메시지의 목록으로 구성되며,
	객체가 어떤 메시지를 수신할수있는지가 객체가 제공하는 인터페이스모양을 빚음
	
	그리고 객체가 자기자신과 상호작용할때도 메시지를 보내야하니까,공용인터페이스와 사설인터페이스(프라이빗)으로 나눠지게됨
	둘다 메시지전송을 통해서만 접근할수있음
		
	
	객체지향을 이해하려면
		좀더 추상적인 인터페이스
		최소 인터페이스
		인터페이스와 구현간의 차이에 대해 인식
	을 알아야함
	
	좀더 추상적인 인터페이스는,앞에서처럼 뭘할지 정하지말고 뭐가필요한지를 정하라는거고
	최소인터페이스는 외부에서 사용할필요가 없는 인터페이스는 최대한 노출하지말라는것
	
	구현은 내부구조와 작동방식을 가리킴
	즉 객체를 구성하지만 공용인터페이스에 포함되지 않는 모든것이 구현에 포함됨
	
	객체는 상태를 가지고,상태는 어떤식으로든 객체에 포함되겠지만,외부에 노출되는 공용인터페이스는 아님
	그래서 상태는 객체의 구현에 해당됨
	
	객체는 행동을 가짐,행동을 가짐,행동은 메시지를 수신했을때만 실행되는 메시지처리방법이고,이걸 메서드라고 부름
	메서드내의 코드자체는 객체외부에 노출되는 공용인터페이스는 아니기때문에 객체의 구현임
	
	객체의 외부와 내부를 분리하라는건,객체의 공용인터페이스와 구현을 명확하게 분리하라는말과 같음
	
	좋은객체는 구현을 모른채 인터페이스만 알면 쉽게 상호작용할수있는 객체를 의미함
	이건 객체를 설계할때,객체인터페이스와 내부구현을 명확히 분리해서 고려해야한다는걸 의미함
	이걸 인터페이스와 구현분리원칙이라고 함
	
	이걸 제대로하면,어떤 객체에서 수정하면 외부에 영향을미치는 영역과 아닌영역을 구분해서 볼수있게됨
	중요한건,객체의 상태와 메서드구현을 수정해도,객체 외부에 영향을 미쳐서는 안됨
	이걸 수행하기위한 객체설계방법이 캡슐화임

	캡슐화는 상태와 행위의 캡슐화,사적인비밀의 캡슐화 두가지관점이 있음
	
	객체는 상태와 행위의 조합이고,스스로 상태를 관리하며 상태를 변화시키는 행동을 내부에 함께 보관함,객체는 상태와 행동을 하나의 단위로 묶는 자율적인실체임
	
	객체는 상태와 행위를 한데묶은후,외부에서 반드시접근해야하는 행위만 골라 공용인터페이스에 노출함,
	따라서 데이터캡슐화는 인터페이스와 구현을 분리하기위한 전제조건이고,
	객체가 자율적이기위해선 자기자신의 상태를 스스로 관리할수있어야해서 자율적인객체를 만들기위한 전제조건이기도 함
	
	객체는 외부의 객체가 자신의 내부상태를 직접관찰하거나 제어할수없도록,의사소통가능한 특별한경로만 외부에 노출함
	이걸 공용인터페이스라고 하고,캡슐화를 통해 변경이 일어나는 불안정한 비밀을 안정적 인터페이스 뒤로 숨길수있음
	일반적으로 불안정한비밀은 구현과 관련된 세부사항을 의미함
	
	객체의 공용인터페이스는 외부에서 전송가능한 메시지의 집합임,외부객체는 오직 공용인터페이스만을 접근할수있으니,
	외부에 제공할필요가 있는 메시지를 객체의 공용 인터페이스에 포함시키고,개인적비밀은 그 뒤에감춰서 자율성을 보장받을수있음
	여기서 자율성이란,자기자신의 사적부분을 외부간섭없이 변경할수있음을 의미함
	
		
	협력의 종류는 사람수만큼있지만, 더 나은 방식의 협력이 존재함,협력의 품질은
		자율적인책임은 협력을 단순하게 만듬,세부사항을 무시하고 의도만 드러내는방식을 사용해야함
		자율적인책임은 외부와 내부를 명확하게 분리함,외부가 몰라도되는부분은 캡슐화되어야함
		책임이 자율적일경우,책임을 수행하는 내부방법을 변경해도 외부에 영향을 미치지않음
		자율적인책임은 협력대상을 다양하게 선택할수있는 유연성을 제공함
		객체가 수행하는 책임들이 자율적일수록 객체역할을 이해하기가 쉬워짐,즉 응집도가 오름
		
		
		
		
		
6.객체 지도		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
	