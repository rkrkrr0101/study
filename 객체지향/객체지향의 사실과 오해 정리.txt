1.협력하는 객체들의 공동체
	객체지향을 설명할때,현실에 빗대서 설명하는건,특정 딱 한요소만 설명할수있고 나머지는 동시에 설명할수없음
	하지만 그게 각 요소에 대해서 이해하긴 편하기때문에 자주사용함
	
	객체지향에서 가장 중요한건,역할,책임,협력임
	객체들은 자신이 할수없는 일을 만나면,이걸 해결해주길 요청(리퀘스트)함,그리고 요청받은객체도 다시 요청을 할수있으니,요청은 연쇄적으로 발생함
	그리고 요청에 대해 응답하는것도,요청의 연쇄와 반대방향으로 연쇄적으로 전달됨
	
	역할은 어떤 협력에 참여하는 특정사람이 그 안에서 차지하는 책임,의무임
	어떤 역할을 맡았으면,그 역할을 수행할 책임이 생김,즉 역할음 책임을 암시함
	여기서 중요한점은
		여러사람이 동일한 역할을 수행할수 있음:요청자입장에선 누가하든 결과만 나오면됨
		역할은 대체가능성을 의미함:어떤객체든 같은역할을 수행가능하면 신경쓸필요가없음
		책임수행방법은 알아서해도됨:결과만 나오면,수행방법은 캡슐속에있음
		한객체가 동시에 여러역할을 수행할수있음:단,원칙상으로 권장되진않음
	객체지향 설계라는건,적절한 객체에게 적절한 책임을 할당하는것부터 시작됨
	
	역할은 객체의 페르소나고,관련성높은 책임의 집합임
	
	객체의 덕목은
		객체는 충분히 협력적이어야함,외부의 도움을 무시하고 모든걸 스스로처리하려고하면 내부복잡도가 너무올라가서 자멸함
		그리고 이건 객체가 다른객체의 명령에 따라 행동하는 수동적인 존재라는게 아니라,단순히 다른 요청에 응답할뿐임,
		그리고 요청을 수행할지말지도 요청받은객체가 스스로 결정함
		
		객체는 충분히 자율적이어야함,즉 자기스스로의 원칙에 따라 자신의 행동을 스스로 결정하고 책임져야함,즉 결과물만 리턴하는 책임을 가지고,
		그 결과물을 어떻게만들진 지시받지않고 자기가 스스로결정함
		
	
	객체는 상태와 행동을 같이 지닌 실체임
	이말은 객체가 협력에 참여하기위해 어떤 행동을 해야하면,그 행동을 하는데 필요한 상태도 같이 가지고있어야 한다는걸 의미함
	객체의 자율성은,객체의 내부와 외부를 명확히 구분하는것으로 부터 나옴
	객체의 사적인 부분은 객체 스스로 관리하고 외부에서 간섭할수없게 차단해야하고,객체의 외부에선 접근이 허락된수단을 통해서만 객체와 의사소통해야함
	객체는 다른 객체가 무엇을 수행하는진 알수있지만,어떻게 수행하는진 알수없음
	즉 객체는,상태와 행위를 하나의 단위로 묶는 자율적인 존재임
	
	즉 데이터와 프로세스를 객체라는 하나의 틀안에 함께 묶어서 객체의 자율성을 보장하는게 절차지향과 객체지향의 가장 핵심적인 차이임
	
	객체끼리 서로 의사소통을 하는 방법은 메시지임,메시지를 보내는애를 샌더,받는애를 리시버라고 부름
	
	객체가 메시지를 받았으면,이해할수있는지 여부를 판단한후 정해진 자신의 방법에 따라 메시지를 처리함,이 방법을 메서드라고 함
	객체지향에서 메서드는,클래스 안에 포함된 함수나 프로시저를 통해 구현됨,따라서 어떤 객체에 메시지를 전송하면,
	결과적으로 메시지에 대응되는 특정메서드가 실행됨
	
	이 메시지와 메서드의 분리는,객체의 협력에 참여하는 객체들간의 자율성을 증진시킴
	이건 캡슐화와도 깊이 관련되어있음
	
	즉 객체지향이란
		시스템을 상호작용하는 자율적인 객체들의 공동체로 바라보고,객체를 이용해 시스템을 분할하는 방법
		자율적인 객체란 상태와 행위를 함께지니며,스스로를 책임지는 객체
		객체는 시스템의 행위를 구현하기위해 다른객체와 협력함,각 객체는 협력내에서 정해진 역할을 수행하고,역할은 관련책임의 집합
		객체는 다른 객체와 협력하기위해 메시지를 전송하고,메시지수신객체는 메시지를 처리하는데 적합한 메서드를 자율선택함
		
	객체지향에서의 클래스는,중요한 구성요소인건 맞지만,객체지향의 핵심을 이루는 중심개념이라고 하긴어려움
	클래스가 없는 프로토타입계열 언어에서도 객체지향이 가능하고,거긴 상속없이 위임을 기반으로 동작하니까
	
		
2.이상한 나라의 객체		
	객체는 객체의 행동에따라 자신의 상태를 변경시키고,상태에따라 행동의 결과가 바뀜
	즉 상태를 결정하는건 행동이지만,행동의 결과를 결정하는건 상태임
	예를들면 상태에 따른 분기나,현재상태에서 +-하는게 있는데,이건 현재 상태에 행동이 의존적임(현재 상태를 가져와야 더하든빼든 할수있음)	
	이건 행동간의 순서가 중요하다는것도 의미함
	
	객체는 상태,행동,식별자를 지닌 실체로 볼수있음
	
	객체의 상태는,객체가 행동에 어떻게 반응하는가는 그시점까지 일어난 행동들에 좌우되는데,이걸 하나하나 로그로 남기는거보단(이벤트ms방식),
	현재 상태값을 만들고 그값기준으로 돌리는게 쉬워서 이렇게 사용하는거
	
	그리고 이런 단순한 상태값들은 객체가 아님,즉 이런것들은 그 자체로 독립적인 의미를 가지지못하고,다른 객체의 특성을 표현하는데 사용되기때문
	단 단순한 값이 아닌,객체를 사용해서 다른 객체의 상태를 표현할수도 있음(디자인패턴에서 내부에 인터페이스가 있는 객체를 가지고있는 객체들)
	
	결론적으로 모든 객체의 상태는,단순한값과 객체의 조합으로 표현할수있고,이 객체의 상태를 구성하는 모든 특징들을 통틀어 객체의 프로퍼티라고 함
	일반적으로 프로퍼티는 변경되지않아서 정적이고,프로퍼티값은 계속 바뀌니까 동적임
	
	객체와 객체사이의 의미있는 연결을 링크라고하고,객체끼리는 이 링크를 통해서만 요청을 보내고받을수있음(내부에 객체가 들어있는거)
	
	객체는 외부의 객체가 직접적으로 상태를 변경하거나 할수없어서, 간접적으로 행동을 통해서 상태를 변경하거나 조회할 방법이 필요함
	
	객체의 상태는 무조건 행동을 통해서만 바꿀수있음
	객체가 취하는 행동은 객체 자신의 상태를 변경시킴,이소리는 행동이 사이드이펙트를 초래한다는걸 의미함
	사람이 케이크를 먹으면 몸무게가 늘고 케이크가 줄어드는,2가지이상의 효과가 나타날수 있음
	
	이것처럼 객체의 행동은 객체의 상태를 변경시키지만,행동의 결과는 객체의 상태에 의존적임
	이건
		상호작용이 현재상태에 어떤방식으로 의존하는지
		상호작용이 어떻게 현재상태를 변경시키는지
	를 보면 간단히 볼수있음
	
	
	그리고 모든 객체는 섬이 아니라,다른 객체를 이용하고,다른객체에 서비스를 제공함
	객체가 다른객체와 협력하는 유일한방법은 다른 객체에 요청을 보내는것
	요청을 수신한 객체는 그 요청을 처리하기위해 적절한 방법에 따라 행동함
	
	객체는 협력에 참여하는 과정에서,자기자신의 상태뿐아니라 다른객체의 상태변경을 유발할수도 있음
	즉 직접적으로 수정은 못하니,객체의 행동은
		자신의 상태변경
		행동내에서 협력하는 다른 객체에 대한 메시지 전송
	으로 이루어지게됨
		
	객체지향에서의 객체는,모든 객체가 자신의 상태를 스스로 관리할수있음,즉 음료객체가 자신의 용량을 줄이거나 늘일수있고,얘만 그걸할수있어야함
	사람은 단지 저기에 먹었다는 메시지를 던질뿐임,걔가 무슨일을 할진 모름
	이게 캡슐화가 의미하는것임,객체는 상태를 캡슐안에 감춰두고 밖으로 노출하지않음,객체가 노출하는건 행동뿐이고,접근방법도 행동뿐임
	이렇게 상태를 노출하지않고,행동을 경계로 캡슐화하는건,결과적으로 객체의 자율성을 높여서,협력을 유연하고 간결하게 만듬
	
	객체가 식별가능하다는건,객체를 서로 구별할수있는 특정 프로퍼티가 객체안에 존재한다는것,이걸 식별자라고 부름
	모든 객체가 식별자를 가진다는건,단순값은 식별자를 가지지않는다는것
	값은 숫자,문자,날짜등 변하지 않는 양을 모델링함,값의경우 두 인스턴스의 상태가 같다면,두 인스턴스를 같은것으로 판단함
	이거의 여부는 상태가 같은지를 이용해 판단함
	
	객체는 시간에 따라 변경되는 상태를 포함하고,행동으로 상태를 변경함,즉 가변상태를 가짐
	그래서 같은타입의 두 객체의 상태가 완전히 같더라도,두 객체는 독립적인 객체로 다뤄져야함
	그래서 객체를 구분할수있는 값이 필요한데,그게 식별자고 이 식별자를 통해 객체가 같은지를 판단할수있는 성질을 동일성이라고 함
	
	객체의 행동에서 객체의 상태를 조회하는걸 쿼리라고 하고,객체의 상태를 변경하는걸 커맨드라고 함
	객체의 행동은 대부분 이 두개로 구성됨
	
	
	객체지향에선,상태를 중심으로 객체를 바라보는게 아닌,행동을 중심으로 객체를 바라봐야함
	즉 행동을 먼저 정하고,거기에 필요한 상태를 추가하는 방식으로 하는게 좋음
	거꾸로하면
		상태를 먼저결정하면 캡슐화가 저해됨,상태가 객체외부에 노출될확률이 늘어남
		객체를 협력자가 아닌 고립된섬으로 만듬
		객체의 재사용성이 저하됨
	라는 문제가 생길수 있음
		
	
	현실의 객체와 객체지향의 객체와 가장 큰 차이점은,객체지향의 객체는 의인화가 되어서,스스로 뭔가를 할수있다는것
		
		
		
		
		
		
3.타입과 추상화		
	추상화는 필요없는 정보를 제거하고,필요한 목적에 맞춰서 꼭 필요한 사실만 정확히 표현하는것
	이땐,목적에 맞게 모델을 설계하는게 중요함
	즉 추상화란,현실에서 출발하되,불필요한 부분을 도려내가면서 사물의 본질을 드러내게하는 과정
	이걸통해서 복잡도를 줄일수있음
	
	추상화는
		구체적인 사물간의 공통점은 취하고 차이점은 버리는 일반화를 통해 단순하게만드는것
		중요한부분을 강조하기위해 불필요한 세부사항을 버리는것
	이 두가지를 통해,복잡도를 끌어내림
	
	객체지향 패러다임의 중심엔 구체적이고 실제적인 객체가 존재하지만,그걸 다 인식할순없어서 객체를 여러그룹으로 묶어 가짓수를 줄임
	이처럼 공통점을 기반으로 객체들을 묶기위한 그릇을 개념이라고 함
	개념을 사용하면 객체를 여러 그룹으로 분류할수있음,그리고 그 그룹의 일원이 된 애를 그 개념의 인스턴스 라고 함
	
	객체의 분류장치로써의 개념을 말할떈
		심볼:개념을 가리키는 간략한 이름
		내연:개념의 완전한 정의,이걸통해 객체가 여기속하는지 알수있음
		외연:개념에 속하는 모든 객체의 집합
	으로 구분됨
	
	객체지향에서 제일 유명한게 클래스인걸보면,분류(클래시피케이션)가 얼마나 중요한지를 알수있음
	
	분류란 객체에 특정한 개념을 적용하는작업,이걸 하게되면 그 객체는 특정한 집합의 멤버로 분류하는것
	
	분류는 객체지향의 가장 중요한 개념임,어떤 객체를 어떤 개념으로 분류할지가,객체지향의 품질을 결정함
	이걸 잘해야,유지보수가  쉽고,변화에 대처가 쉬워짐
	
	그리고 분류는 추상화를 위한 도구임,즉 분류를 하면 추상화가 일어남(일반화)
	
	타입은 개념과 완전히 동일함,공통점을 기반으로 객체를 묶기위한 틀
	
	단 컴퓨터로 들어오면서 좀 기계적으로 바뀌는데,
	기본적으로 모든 데이터는 0,1인 바이너리임
	근데 그렇게만 보면 알아보기가 너무힘드니까,그 메모리 조각을 잘라다가,제약을 붙여서 사용하는게 데이터타입임
	즉,데이터에 다른데이터를 사칙연산할수있으면 숫자형,데이터가 여러문자로 구성되면 문자열형같은,
	
	이걸로,데이터의 타입을 결정하는건,어떤 데이터에 어떤 연산자를 적용할수 있냐가 그 데이터의 타입을 결정한다는걸 알수있음
	그리고 타입에 속한 데이터를 메모리에 어떻게 표현하는진,캡슐화가 되어서 몰라도된다는걸 알수있음
	
	실제로 객체지향에서 객체는 일종의 데이터를 포함하고,데이터타입과 객체지향의 타입엔 연관성이 있음
	객체를 타입에 따라 분류하고,그 타입에 이름을 붙이는거
	
	객체는 행위에따라 변하는 상태를 가지고있고,그래서 객체를 모두모으면 애플리케이션 전체데이터를 알수있게됨
	그렇다고 객체가 데이터는 아님,객체에서 중요한건 객체의 행동이고,상태는 그 행동으로 초래된 사이드이펙트를 쉽게 표현하기위해 도입됐을뿐임
	객체를 만들때 가장 중요한건,객체가 다른객체와 협력하기위해 어떤행동을 해야할지 결정하는것
	즉 객체가 협력을 위해 어떤 책임을 지녀야하는지 결정하는게 핵심임
		
	그래서 객체지향에서의 객체의 타입은
		어떤 객체가 어떤 타입에 속하는지 결정하는건 객체의 메서드임,같은메서드를 가지고 있다면 같은타입(같은인터페이스)
		객체의 내부표현은 외부로부터 철저하게 감춰짐(캡슐화)
	를 기반으로 볼수있음
	
	객체가 어떤 행동을 하냐에 따라 객체의 타입이 결정되고,객체의 타입은 객체의 내부표현과는 아무상관이 없다는걸로,
	객체들이 같은 메서드명을 공유하고 있으면,같은 타입이라고 볼수있음 
	객체의 상태가 뭘 가지고있는지등은 아무영향을 주지못함
	
	그래서 같은타입에 속한 객체는 행동만 동일하면 서로 다른 데이터를 가질수 있음
	여기서 동일한 행동이란,동일한 책임을 의미하고,동일한 책임이란 동일한 메시지수신을 의미함(인터페이스에서의 메서드)
	즉,같은 타입에 속한 객체는 같은 메시지를 수신하고 이를 처리할수있다(결과는 다를수있지만 일단 들어가긴함)
	
	이건 다형성에 의미를 부여함,다형성이란 같은 요청에 대해 서로 다른 방식으로 응답할수 있는 능력을 뜻함
	동일한 메시지를 서로 다른 방식으로 처리하기위해선,객체들은 같은메시지를 수신할수있어야 하기 때문에,
	결과적으로 다형적인 객체들은 같은타입에 속하게됨
	
	데이터의 내부표현과 무관하게 행동만이 고려대상이라는건,외부에 데이터를 감춰야한다는것
	즉,행동만을 제공하고 데이터는 행동뒤로 감춰야함,이걸 캡슐화하고 함
	
	행동에 따라 객체를 분류하기위해선 객체의 데이터가 아닌 객체가 외부에 제공해야하는 행동을 먼저 생각해야함
	이를위해서 객체가 외부에 제공해야하는 책임을 먼저 결정하고,그 책임을 수행하는데 필요한 데이터를 나중에 결정한 후,
	데이터를 책임을 수행하는데 필요한 외부인터페이스 뒤로 캡슐화해야함
	이게 책임주도설계(RDD)임
	
	타입객체는 상위인터페이스와 하위인터페이스가 있을수있음,이걸 일반화/특수화 라고 부름
	하위에 속하는애는 자동적으로 상위에도 속하게됨
	이때 상위와 하위의 구분은 상위에서 추가적으로 행동이 추가되었을때를 말함
	
	그리고 당연히 상위의 집합보단 하위의 집합이 더 수가 적고,상위의 행동갯수보다 하위의 행동갯수가 더 수가 많음
	
	이때 상위인터페이스를 슈퍼타입,하위인터페이스를 서브타입 이라고 함
	그리고 서브타입은 슈퍼타입을 대체할수있어야함
	
	일반화는 추상화를 위한 도구임,즉 하위인터페이스가 필요없을경우 추상화해서 상위인터페이스에 몰아넣을수도있음
	
		
	타입을 사용하는 이유는,인지능력상 동적으로 변하는 객체의 복잡성을 극복하기가 어렵기때문
	즉,상태를 배제하고 객체의 상태가 변할수있다는것만 생각해서 상황을 단순하게 만들수있음
	
	즉 타입은 시간에 따라 동적으로 변하는 상태를 시간과 무관한 정적인 모습으로 다룰수있게해줌
	그래서 결국 타입은 추상화임
	
	기본적으로 설계시점에선 정적으로 보고,실행시점에선 동적으로 보는식으로 잘 흘러가게됨
	
	객체지향에서 정적인모델은 클래스를 이용해서 구현됨,따라서 타입을 구현하는 보편적방법은 클래스를 이용하는것
	타입이랑 클래스는 같은게 아니고,클래스는 단지 타입을 구현할수있는 여러 매커니즘에 하나임
	이 둘을 구분하는게 설계를 유연하게하는데 도움이됨
	
	즉 클래스는,타입+코드재사용 용도임
		
		
4.역할,책임,협력	
	객체지향에서 제일 중요한건 협력임
	중요한건 개별객체가 아니라 객체들 사이에서 이뤄지는 협력임,
	객체지향 설계의 전체품질을 결정하는건 개별객체의 품질이 아니라 여러 객체들이 모여 이뤄내는 협력의 품질임
	좋은 앱은,객체들간의 요청과 응답속에서 창발하는 협력에 초점을 맞춰서 설계됨
	협력이 자리를 잡으면 객체의 행동이 드러나고 뒤이어 적절한 객체의 상태가 결정됨
	
	협력은 한객체가 다른객체에게 도움을 요청할때 시작됨
	자신에게 할당된일이나 업무를 처리하는중에 스스로 해결하기어려운일에 부딫치게되면 다른객체에 도움을 요청하고,걔도 다시 다른객체에 도움을 요청할수있게되면서
	연쇄적으로 요청과 응답이 일어남
	
	그리고 특정 요청을 받아들일수 있는 이유는,그 요청에 대해 적절한 방식으로 응답하는데 필요한 지식과 행동방식을 가지고있기때문이고,
	요청과 응답은 협력에 참여하는 객체가 수행할 책임을 정의함
	
	객체지향에서 제일 중요한건,책임을 어떻게 할당하느냐가 제일 중요하고,책임을 어떻게 구현할것인가는 다 정해지고 나서 고려해도 상관없음
	객체와 책임이 막 흔들릴때,성급하게 구현하는건 변경에 취약하고 다양한 협력에 참여할수없는 비자율적인 객체를 낳게됨
	
	책임은 객체가 알아야하는 정보와 객체가 수행할수있는 행위에 대해 개략적으로 서술한것
	즉 객체의 책임은,객체가 무엇을 알고있는가 와 객체가 무엇을 할수있는가 로 구성됨
	즉,하는것과 아는것
	하는것엔
		객체를 생성하거나 계산을 하는등의 스스로하는것
		다른 객체의 활동을 시작시키는것
		다른 객체의 활동을 제어하고 조절하는것
	아는것엔
		개인적인 정보에 대해 아는것
		관련된 객체에 대해 아는것
		자신이 유도하거나 계산할수있는것에 대해 아는것
	이 있음
	
	객체의 책임을 말할땐,일반적으로 외부에서 접근가능한 공용서비스의 관점에서 이야기함
	즉 책임은 객체의 외부에 제공해줄수 있는 정보와,외부에 제공해줄수 있는 서비스의ㅣ 목록임
	따라서 책임은 공용인터페이스를 구성함,이건 캡슐화와 이어짐
	
	협력안에서 객체는,다른객체로부터 요청이 전송되었을때만 책임을 수행함
	이처럼 객체가 다른객체에 주어진 책임을 수행하도록 요청을 보내는것을 메시지전송이라고 함
	즉 두 객체간 협력은 메시지를 통해 이뤄지고,메시지를 보내는애는 송신자,받는애는 수신자 라고 함
	
	책임이 협력이라는 문맥속에 요청을 받는쪽의 관점에서 뭘할수있는지를 나열하는거라면,메시지는 두 객체사이관계를 강조한것임
	즉 메시지를 보내는쪽은 받는쪽이 이해할수 있는 메시지를 전송할수있고,받는쪽은 받은메시지에 대해 적절한 책임을 수행할수 있음
	
	주의점은 책임과 메시지의 수준이 같지않다는것,책임은 객체가 협력에 참여하기위해 수행할행위를 개략적으로 서술한거고,
	하나의 책임을 정제하면서 메시지로 변환할때는 여러 메시지로 분할되는게 일반적임
	
	설계초반엔 어떤객체가 어떤책임을 가지고 어떻게 협력하는지에 대한 개요만 알면되고,
	어떤 클래스가 필요하고 어떤 메서드를 포함해야하는진 설계끝나고 결정해도됨
	
	
	책임의 집합은 역할이고,역할은 재사용 가능하고,유연한 객체지향설계를 낳음
	즉 같은 역할을 가진 객체면,대체가능하고,그러면 하나의 루틴으로 추상화해서 객체만 선택해가면서 바꿔가며 돌릴수있음
	즉 같은 인터페이스를 상속받았으면,그 인터페이스를 필요로하는 모든곳에 들어갈수있음
	
	역할을 사용하면,단순성,유연성,재사용성을 올릴수있음
	그리고 가장 큰 가치는,하나의 협력안에 여러종류의 객체가 참여할수있게되면서,협력을 추상화할수있다는것
	
	역할은 협력안에서 구체적인 객체로 대체될수있는 추상적인 협력자임,
	즉 본질적으로 역할은 다른객체에 의해 대체가능함을 의미함
	
	객체가 역할을 대체하기위해선 행동이 호환되어야함,어떤 객체가 증인이라는 역할을 대체할수있는 이유는,그 객체가 증인석에 입장할수있고,증언할수있기때문
	결국 객체는 협력안에서 역할이 수행하는 행동을 그대로 수행할수있어야함
	단,역할에 있는 책임 이외에도 다른 책임을 수행하는건 상관없음,즉 두개이상의 역할을 가져도 상관없음
	즉 일반화/특수화관계가 성립하는게 일반적임
	
	
	객체는 시스템에 필요한 데이터를 저장하기위해 객체가 있는게 아니라,그건 단지 행위를 수행할때 필요한 재료일뿐이고,
	객체는 행위를 수행하며 협력에 참여하기 위해서 존재함,따라서 실제로 중요한건 객체의 행동,즉 책임임
	
	그리고 객체지향은 클래스와 클래스간의 관계를 표현하는 시스템의 정적인측면에 중점을 두는게 아닌,
	클래스는 시스템에 필요한 객체를 표현하고 생성하기위한 도구일뿐이고,정적인 클래스가 아닌 동적인 객체가 중요하고,
	얘들이 협력안에서 어떤책임과 역할을 수행할것인가가 중요함
	
	올바른 객체를 설계하기위해선 견고하고 깔끔한 협력을 먼저 설계해야함
	이건 설계에 참여하는 객체들이 주고받을 요청과 응답흐름을 결정한다는걸 의미함
	이렇게 결정된 요청응답흐름은 객체가 협력에 참여하기위해 수행될 책임이 됨
	그리고 객체가 협력에 참여하기위해 필요한 데이터와 행동이 어느정도 결정된 후에 클래스구현방법을 결정하면됨
	즉,클래스와 데이터는 협력과 책임집합이 결정된 후에야 등장함
	
	객체지향이 올바른객체에 올바른책임을 할당하는것과 관련된 모든것이라면,협력이라는 문맥안에서 객체를 생각하는건,
	올바른 객체지향앱을 구현하는것과 관련된 모든것임
	협력이라는 견고한문맥이 갖춰지면,우리의 초점은 협력을 위해 필요한 책임의 흐름으로 옮겨짐,그리고 협력에 필요한 책임을 결정하고,
	객체에게 책임을 할당하는과정을 얼마나 합리적이고 적절하게 수행했는지가 객체지향설계품질을 담당함
	
	객체의 행위에 초점을 맞추기위해선,협력이라는 문맥내에서 책임을 분배해야함
	각 객체가 가질 상태와 행위에 대해 고민하기전에,그 객체가 참여할 문맥인 협력을 정의하면됨
	즉 객체를 충분히 협력적으로 만든후에 그안에서 자율적으로 만들어야함
	
	
	책임주도설계는 객체의 책임을 중심으로 시스템을 구축하는 설계방법임
	시스템의 기능은 더 작은 규모의 책임으로 분할되고,각 책임은 책임을 수행할 적절한 객체에 할당됨
	객체가 책임을 수행하는도중에 스스로 처리할수없는 정보나 기능이 필요하면,적절한 객체를 찾아 필요한작업을 요청함
	요청된 작업을 수행하는일은 작업을 위임받은 객체의 책임으로 변환됨
	이렇게 객체가 다른객체에 작업을 요청하는 행위를 통해 협력관계가 만들어지고,책임을 여러객체가 수행할수있으면 협력자는 객체가 아닌 추상적인역할로 대체됨
	
	이렇게 책임주도설계에선 시스템의 책임을 객체의 책임으로 변환하고,각 객체가 책임을 수행할때 필요한 정보나 서비스를 제공할 협력자를 찾아,
	해당 협력자에게 책임을 할당하는 순차적방식으로 객체의 협력공동체를 구축함
	책임주도설계는 개별객체상태가 아니라 객체의 책임과 상호작용에 집중함
	결과적으로 시스템은,스스로 자신을 책임질수있을정도로 자율적이면서,다른객체들과 협력할수있는 객체들로 이뤄지게됨
	이때 설계순서는
		시스템이 사용자에게 제공해야하는 기능인 시스템책임을 파악
		시스템책임을 더 작은책임으로 분할
		분할된 책임을 수행할수있는 적절한 객체또는 역할을 찾아 책임을 할당
		객체가 책임을 수행하는중에 다른객체의 도움이 필요하면,이를 책임질 적절한 객체또는 역할을 찾음
		해당객체나 역할에 책임을 할당해서 두객체를 협력시킴
	이순서임
	
	디자인패턴은 책임주도설계가 이뤄진 결과물의 템플릿임
	패턴은 해결할문제가 무엇있지 정확히 서술하고,패턴을 적용할수있는상황과 아닌상황을 함께설명함
	여기서 중요한건 패턴의 세부구조가 아니라,협력에 참여하는 역할과 책임임
	
	테스트주도개발은,실패하는 테스트를 작성하고,그 테스트를 통과하는 간단한코드를 작성한후,리팩토링으로 중복을 제거하는것
	이걸 하면 작동하는 깔끔한코드를 얻을수있음
	테스트주도개발을 할땐,객체가 이미 존재한다고 가정하고,객체에게 어떤메시지를 전송할것인지에 관해 먼저 생각해야함
	즉 테스트를 작성하는게 메인이 아닌,책임을 수행할 객체가 기대하는객체의 역할이 메시지를 수신할때 어떤 결과를 반환하고,
	그과정에서 어떤 객체와 협력할것인지에 대한 기대를 코드형태로 작성하는것
	
	테스트주도개발을 하는이유는,테스트를 얻기위함이 아니라,책임주도설계보다 쉽고 안전하게 설계하기위한 방식일뿐임
	테스트는 덤으로 나오는거고
	
	
5.책임과 메시지		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
	