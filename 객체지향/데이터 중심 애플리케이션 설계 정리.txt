1.신뢰할수있고 확장가능하며 유지보수하기 쉬운 어플리케이션
  요즘 어플리케이션은 계산중심이 아니라 데이터중심적임
  그래서 병목이 데이터의 양,복잡도,변화속도에 걸림
  
  데이터 중심 어플리케이션은,공통적으로 필요로하는 기능을 제공하는 표준 구성 요소를가짐
	데이터를 다시 찾을수있게함 (db)
	읽기속도 향상을 위해 값비싼 수행결과를 기억(캐시)
	사용자가 키워드로 데이터를 검색하거나 다양한방법으로 필터링할수있게 제공(검색색인)
	비동기처리를 위해 다른 프로세스로 메시지 보내기(스트림처리)
	주기적으로 대량의 누적된 데이터를 분석(일괄처리,즉 배치)]
  이런것들이 다 추상화되어서 들어가지만,어플리케이션마다 요구사항이 달라서,db시스템또한 저마다 다양한 특성을 가지고,
  어플리케이션을 만들때 어떤 도구와 어떤 접근방식이 수행작업에 가장 적합한지를 생각해야함
  
  1.데이터 신뢰성에 대한 생각
	db와 큐 캐시등을 달라보이고,실제로 매우 다른 접근패턴을 가지지만 데이터시스템이라는 포괄적 용어로 묶을수있음
	이유는,
	  1.레디스(메시지큐 데이터스토어)나 카프카(지속성을 보장하는 메시지큐)등으로 인해 분류간 경계가 흐려짐
	  2.많은 어플리케이션이 단일도구로는 더이상 데이터처리와 저장 모두를 만족시킬수 없는 과도하고 광범위한 요구사항을 가지고있음,
		대신 작업은 단일도구에서 효율적으로 수행할수있는 태스크로 나누고,다양한 도구들은 어플리케이션 코드를 이용해 서로 연결함
	  3.서비스제공을 위해 각 도구를 결합할땐,인터페이스로 클라이언트가 세부사항을 모르게 숨김(포트),그래서 어플리케이션이 접근할땐 다 동일하게 접근할수있음
	이런 이유등이 있음
	
	데이터 시스템이나 서비스를 설계할때 가장 중요한건
		신뢰성:결함,인적오류등이 생겨도 시스템은 지속적으로 올바르게 동작(원하는성능수준에서 정확한기능을 수행)해야함
		확장성:데이터량,트래픽량,복잡도가 증가하면서 이를 처리할수있는 적절한 방법이 있어야함
		유지보수성:모든 사용자가 시스템상에서 생산적으로 작업할수있어야함
	이 3가지임

  2.신뢰성
  	  소프트웨어는
	    어플리케이션은 사용자가 기대한 기능을 수행
	    시스템은 사용자가 범한 실수나 예상치못한 소프트웨어 사용법을 허용할수있음
	    시스템 성능은 예상된 부하와 데이터양에서 필수적인 사용사례를 충분히 만족함
	    시스템은 허가되지않은 접근과 오남용을 방지함
	  보통 이정도를 기대하는데,대충 무언가 잘못되더라도 지속적으로 올바르게 동작함 이라고 생각하면됨
	
	  이떄 잘못될수있는일을 결함이라고 하고,결함을 예측하고 대처할수있는 시스템을 내결함성,또는 탄력성을 지녔다고 함
	  물론 모든종류의 결함을 견딜수는 없음(전쟁나서 서버에 폭탄터졌는데 웹서버가 그걸 버틸수는없음)
	
	  결함은 장애와 동일하지않음
	  결함은 사양에서 벗어난 시스템의 한 구성요소로 정의되지만,장애는 사용자에게 필요한 서비스를 제공하지못하고 시스템 전체가 멈춘경우임
	  결함확률을 0으로 줄이는건 불가능하고,그래서 결함으로 장애가 발생하지않게 내결함성을 챙기는게 가장좋음
	
	  이를 테스트하려고 카오스몽키같은걸 쓸수도있고,예방책이 해결책이 더 좋은경우도 있음(해킹같은거)
	  
	1.하드웨어결함
	  시스템 장애의 원인중 대표적인게 하드웨어결함이고,이건 규모가 커지면 늘상 일어남
	  보통 이걸 해결하는방법은 각 하드웨어구성요소에 중복을 추가하는것(raid같은거),아니면 클라우드로 노드를 여러개쓰는방법도 있음
	  
	2.소프트웨어 오류
	  보통 하드웨어결함은 서로간에 별로 상관관계가 없음,근데 시스템 내의 체계적오류는 예상하기 더 어렵고,노드간 상관관계때문에 시스템오류를 더욱 많이 유발함
		잘못된 특정입력이 있을때 모든 어플리케이션 서버인스턴스가 죽는 버그
		cpu,메모리,디스크공간등 공유자원을 과도하게 사용하는 일부프로세스
		시스템속도가 느려져 반응이 없거나 잘못된 응답을 반환하는 서비스
	  등이 있음
	  
	  이런 소프트웨어결함은 특정 상황에 의해 발생하기전까지 오랫동안 나타나지않음,즉 소프트웨어는 환경에 대한 일종의 가정이 있고,
	  이 가정은 대개 문제없지만 어떤이유로 문제가 생기게됨(가정이 꺠지게됨)
	  
	  이런 문제는 신속한 해결책이 없고,테스트,프로세스격리,죽은프로세스의 재시작허용,모니터링등으로 해결해야함
	  로깅을 해서 그걸 모니터링하는방법도 있음
	
	3.인적오류
	  사람은 가장 중단의 메인 원인임
	  그래서
	    오류를 최소화하는 방향으로 시스템을 설계(추상화)
		가장 많이 실수하는장소에서 실수로 장애가 발생하는 부분을 분리
		샌드박스의 제공
		단위테스트부터 통합테스트등을 철저히 테스트
		인적오류를 빠르고 쉽게 복구할수있게 하기(롤백 롤아웃가능하게)
		성능지표와 오류율등을 모니터링하기
	  등을 해야함
	
	4.신뢰성은 얼마나 중요할까?
	  버그는 생산성저하의 원인이고,어플리케이션은 사용자에 대한 책임이 있음
	  스타트업에서 비용을 줄이려고 신뢰성을 희생해야하는경우가 있지만,이때는 신뢰성을 다시 돌려놓는 지점을 잘 알아야함

  3.확장성
	시스템이 현재 안정적으로 동작한다고 미래에도 안정적으로 동작한다는 보장은 없음
	보통 부하증가로 인해 성능이 저하됨
	
	확장성은 증가한 시스템능력을  설명하는데 사용하는 용어지만,시스템에 부여하는 일차원적 표식이 아님
	이건 
	  시스템이 특정 방향으로 커지면 이를 대처하기위한 선택은 무엇인가?
	  추가부하를 다루기위해 계산자원을 어떻게 투입할까?
	같은 질문을 고려한다는 의미임
	
	1.부하기술하기
	  가장 먼저 해야하는건,시스템의 현재 부하를 간결하게 기술해야함,그래야 부하성장질문(부하가 2배커지면 어떻게하지?)를 논의할수있음
	  부하는 부하매개변수라 부르는 몇개의 숫자로 나타낼수있는데,
	  예를들어
	    웹서버의 초당 요청수
		db의 읽기 대 쓰기 비율
		대화방의 동시 활성 사용자
		캐시 적중률
	  등이 있음
	  
	  이떄 평균적인 경우가 중요할수도 있고,소수의 극단적인 경우가 병목의 원인일수도있음
	  즉 어플리케이션의 현재 상황에 맞춰서 선택해야함
	
	2.성능 기술하기
	  부하를 기술했으면,부하가 증가할때 어떤일이 일어나는지 조사할수있음
	    부하 매개변수를 증가시키고 시스템 자원은 변경하지않는다면 시스템 성능은 어떻게영향을 받을까?
		부하 매개변수를 증가시켰을때 성능이 변하지않고 유지되길 원한다면 자원을 얼마나 많이 늘려야할까?
	  둘 다 성능수치가 필요함
	  
	  하둡같은 일괄처리시스템은 처리량에 관심을 가지고,온라인시스템은 서비스응답시간을 관심을 가짐
	  
	  응답시간은 매번 값이 다르니,값의 분포로 생각을 하고 중앙값(p50)과 p95,p99정도를 봐야함
	  또한 시스템의 확장성을 테스트하려고 인위적으로 부하를 생성할땐,응답시간과 독립적으로 요청을 지속적으로 보내야함
	  클라가 다음 요청을 보내기 전에 이전 요청이 완료되길 기다리면,테스트가 왜곡됨
	
	3.부하 대응 접근 방식
	  기본적으로 스케일업은 비싸니,스케일 아웃이 가능하게해야하고,시스템은 탄력적이면 부하가 예측할수없을만큼 높으면 유용하지만,
	  수동으로하는게 예상치못한일은 더 적음
	  
	  또한 스테이트리스가 다수의장비에 배포하기 쉽고,스테이트풀을 분산설치하는건 매우 복잡도가 높음
	  
	  모든곳에 맞는 아키텍처는 없고,읽기의양,쓰기의양,저장할데이터의 양,데이터의 복잡도,응답시간요구사항,접근패턴등을 고려해서 선택해야함
	  즉 이런 가정을 바탕으로 확장성을 체크하는데,이 가정이 틀려버리면 확장을 위한 노력은 다 헛수고가 되고,역효과를 낳을수도있음
	  그래서 스타트업초기단계에선 확장보단 빠르게 반복해서 제품기능 개선하는게 나음
  
  4.유지보수성
    유지보수에서 중요한건
	  운용성:운영팀이 시스템을 원활하게 운영할수있게 쉽게 만들자
	  단순성:시스템에서 복잡도를 최대한 제거해 새 엔지니어가 시스템을 이해하기 쉽게 만들자
	  발전성:엔지니어가 시스템을 쉽게 변경할수 있게 하자
	이 3가지임
	
	신뢰성과 확장성을 달성하는 쉬운방법은 없지만,최소한 유지보수성은 챙겨가야함
	
	1.운용성:운영의 편리함 만들기
	  운영의 일부는 자동화할수있지만,이 자동화를 처음 설정하고 테스트하는건 사람의 몫임
	  
	  시스템이 지속해서 원활하게 작동하려면 운영팀이 필수고,좋은 운영팀은
		시스템상태를 모니터링하고 상태가 좋지못하면 빠르게 서비스를 복원
		시스템장애,성능저하등 문제의 원인을 추적
		보안패치를 포함해 소프트웨어와 플랫폼을 최신상태로 유지
		다른시스템이 서로 어떻게 영향을 주는지 확인해,문제가 생길수있는 변경사항을 손상을 입히기 전에 차단
		미래에 발생가능한 문제를 예측해 문제가 발생하기전에 해결
	  이런일들을 함
	  
	  또한 좋은 운영성이란 동일하게 반복되는 태스크를 쉽게 수행하게 만들어,고부가가치활동에 노력을 집중할수있게함
	
	2.단순성:복잡도관리
	  프로젝트가 커지면 시스템은 매우 복잡하고 이해하기 어려워짐
	  보통
		상태공간의 급증
		모듈간 강한 커플링
		복잡한 의존성
		일관성없는 명명과 용어
		성능문제해결을 목표로한 해킹
		임시방편으로 문제를 해결한 특수사례
	  등이 있음
	  
	  보통 복잡도가 올라가서 유지보수가 어려워지면 예산과 일정이 초과됨
	  변경이 있으면 버그가 생기기 쉽기때문
	  
	  또한 개발자가 시스템을 이해하고 추론하기 어려워지면,시스템에 숨겨진 가정과 의도치않은 결과 및 예기치 않은 상호작용을 간과하기 쉬움
	  반대로 복잡도를 줄이면 유지보수성이 크게 향상됨,즉 단순성이 시스템의 핵심목표임
	  
	  시스템을 단순하게 만든다는게 기능을 줄인다는걸 의미하진않고,우발적 복잡도를 줄이는게 목표임
	  이걸위해 추상화를 사용함
	
	3.발전성:변화를 쉽게 만들기
	  시스템의 요구사항은 계속 바뀜,이걸 민첩하게 받아들일수 있는게 발전성임
	  이때마다 쉽게 변화를 줄수있어야함,이를위해 tdd등을 사용할수있음
	  
	  이건 단순성(과 추상화)에 영향을 많이받음
  
  5.정리
    어플리케이션은 기능적 요구사항(동작해야하는 기능)과 비기능적 요구사항(유지보수성,단순성,신뢰성등)을 충족시켜야함
	
	신뢰성은 결함이 발생해도 시스템이 올바르게 동작해야한다는것
	확장성은 부하가 증가해도 좋은 성능을 유지하기 위한 전략
	유지보수성은 엔지니어와 운영팀의 삶을 개선하는데 목적이 있음(즉 변경코스트를 줄이는데 목적이 있음)
	
2.데이터모델과 질의언어
  데이터모델은 소프트웨어가 해결하려는 문제를 어떻게 생각해야하는지에 대해 지대한 영향을 미침
  
  대부분의 어플리케이션은 하나의 데이터모델을 다른 데이터모델 위에 계층을 둬서 만듬
  각 계층의 핵심문제는,다음 하위 계층 관점에서 데이터모델을 표현하는 방법임
  또한 각 계층은 명확한 데이터모델을 제공해서 자신보다 하위계층의 복잡성을 숨김(추상화)
  
  1.관계형 모델과 문서 모델
    대표적으로 나누면 rdbms와 nosql이 있음
	알디비의 근원은 비즈니스 데이터처리에 있고,이건 트랜잭션과 일괄처리가 핵심이었음
	
	1.nosql의 탄생
	  nosql은 not only sql로,이건
		높은 쓰기처리량을 쉽게 할수있는 확장성
		알디비에서 지원하지않는 특수질의
		알디비의 스키마에 대한 불만과 더 동적인 데이터모델에 대한 바램
	  으로 인해 나왔음 
	  
	2.객체 관계형 불일치
	  알디비의 문제는,객체와 스키마는 동일하지않고,이를 전환하기위해 전환계층이 필요함
	  이걸 임피던스 불일치라고 부름
	  
	  orm은 이때의 보일러플레이트를 줄여주지만,각 모델간의 차이를 완벽히 숨길수는 없음
	  이때 알디비로 각 테이블을 다 분리해서 쪼개는거보다(정규화),그냥 문서모델로 문서처럼 때려박는게 더 객체와 비슷한 표현이 되는경우가 있음
	  보통 sql쿼리는 복잡한 다중조인을 통해서 가져와야하기때문,근데 json표현에서는 해당 문서만 가져오면됨(보통 트리구조일떄 적합함)
	
	3.다대일과 다대다 관계
	  보통 정규화를 하는 이유는,
		일관된 스타일과 철자(오타방지)
		모호함 회피(같은이름 중복일때 다른id로 처리가능)
		갱신의 편의성(정규화테이블만 수정하면됨)
		현지화 지원(id값만 가져오니 거기에 추가로 필드덧대기가능)
		더 나은 검색(역방향 조회가능)
	  가 있음
	  즉 중복회피로 인한 실수방지와 갱신편의성,데이터 무결성보장,역방향조회등이 정규화의 핵심임
	  
	  중복된 데이터를 정규화하려면 다대일관계가 필요한데,이건 문서모델(nosql)에 적합하지않음
	  문서모델은 조인에 대한 지원이 약하기때문
	  어케어케 해결할수있긴하지만..
	  
	  또한 어플리케이션의 초기버전이 조인이 없는 문서모델에 적합하더라도,기능을 추가하면서 데이터는 점차 상호연결되는 경향이 있음
	
	4.문서 데이터베이스는 역사를 반복하나?
	  문서모델도 일대다에서는 잘 동작하는데,핵심은 다대다(와 다대일) 관계 표현임
	  이때 데이터를 중복할지 또다른 레코드와의 참조를 수동으로 해결할지를 결정해야함
	  
	  일단 문서모델도 문서참조(알디비의 외래키)를 사용해서 고유한 식별자로 해결하고있고,이건 조인이나 후속질의를 사용해서 읽기시점에 확인함
	
	5.관계형 db와 문서모델
	  이 두개는 내결함성과 동시성처리를 포함해 고려해야할 차이점이 많이있지만,데이터모델의 차이점에만 우선 집중하자면
	  문서모델은 스키마 유연성,지역성에 기인한 더 나은성능,특정 어플리케이션에서는 객체와 더 가깝기 때문에 선호도가 있고
	  관계형db는 조인,다대일,다대다 관계를 더 잘지원함
	  
	  어플리케이션의 데이터가 문서와 비슷한 구조(트리형태)라면 문서모델을 사용하는게 좋음
	  즉 특정 id를 가져오면 해당하는 데이터 전체가 필요한경우에 적합
	  알디비는 이런경우에 복잡한 스키마와 복잡한 어플리케이션 코드를 발생시킴
	  
	  문서모델의 미흡한 조인도,조인을 사용하지 않는 구조라면 상관없음
	  
	  단,어플리케이션에서 다대다관계가 필요하다면 문서모델은 매력이 떨어짐
	  비정규화로 어느정도 조인필요성 감소는 가능하긴하지만,이럴경우 어플리케이션의 복잡도가 올라가고,무엇보다 알디비보다 더 느림
	  
	  보통 상호연결이 많으면 문서형 모델은 별로고,관계형모델이 무난하고,그래프모델은 더 나음
	  
	6.문서모델에서의 스키마 유연성
	  보통 문서형 db와 알디비의 json은 어떤 스키마를 강요하지않음
	  그래서 스키마리스로 불리지만 정확히는 읽기스키마임,읽을때는 형식이 있지만 쓸때는 형식이 없어도됨
	  반대로 알디비는 쓰기스키마고
	  
	  이 둘은 약타입언어와 강타입언어와의 관계와 비슷함
	  
	  이렇게 읽기스키마의 장점은,데이터타입 변경이 쉽다는거고(그냥 다르게 넣으면됨,변경시에 예전걸 읽었을때의 처리만 있으면됨),
	  쓰기스키마는 이럴경우 마이그레이션을 해야함
	  
	  즉 읽기쓰키마는 컬렉션안의 항목이 어떤이유로 모두 동일한 구조가 아닐때 유리함
		다른 여러유형의 오브젝트가 있고 각 유형별 오브젝트로 자체테이블에 넣는건 실용적이지않음
		사용자가 제어할수없는 언제나 변경가능한 외부시스템에 의해 데이터구조가 결정됨
	  단,모든 레코드가 동일한구조라서 예상가능하다면 그냥 스키마 가져가는게 맘편함,이래야 문서화와 구조강제가 쉬움
	  
	7.질의를 위한 데이터 지역성
	  문서는 json으로 보통 저장됨,그래서 어플리케이션이 자주 특정 문서의 전체에 접근해야하면 이때의 지역성을 활용하면 성능이점이 있음
	  단 이건 한번에 해당 문서의 많은 부분을 필요로 할때만 적용됨
      작은 부분만 필요할떄는 전부 읽어야한다는게 낭비고,문서를 갱신할떄도 전체를 재작성해야함
	   
	  그래서 보통 이런 문서모델의 db는 문서를 아주 작게 유지하고,문서의 크기가 증가하는 쓰기를 피하려고 노력함
	  이거때문에 문서db가 유용한 상황이 많이 줄어듬
	   
	8.문서db와 관계형db의 통합
	  요즘은 관계형db도 요즘은 다 json을 지원하고,문서형db도 조인을 지원하는등 서로간에 비슷해지고있음
	
  2.데이터를 위한 질의 언어
    sql은 선언형임,즉 원하는걸 말하면 알아서 해석해서 거기에 맞는값을 돌려주지,내가 뭘 시키지않음(이건 옵티마이저가 할일)
    즉 동작이 추상화되어있어서 내부동작을 디비개발자가 알아서 수정해도 별 문제를 일으키지않음
    
    또한 sql은 기본적으로는 순서를 보장하지않아서,이부분을 활용한 성능최적화도 가능하고,특히 병렬실행도 쉬움
	1.웹에서의 선언형 질의
	  css도 이런식으로 선언형 질의라고 할수있음
	  특정 어디에 있는 뭘 바꾸라고 하는게 아닌,특정 id인걸 바꾸던가 이런식이니까
	2.맵리듀스 질의
	  맵리듀스는 많은 컴퓨터에서 대량의 데이터를 처리하기위한 프로그래밍모델이고,이건 몽고db같은 일부 nosql에서 제한된 형태로 지원함	  
	  이건 많은 문서를 대상으로 읽기전용 질의를 수행할때 사용됨
	  
	  이건 선언형과 명령형의 중간에 있음
	  선언형으로 데이터를 줄인다음,명령형으로 그 데이터를 가공하는 느낌임
	  느낌적으론 select절 서브쿼리와 from절 서브쿼리같은 느낌임,데이터를 일단 가져와서 수정하는느낌
	  
	  몽고db의 map과 reduce함수는 둘 다 순수함수여야함

  3.그래프형 데이터 모델
    데이터에서 다대다관계가 매우 일반적이라면 그래프로 데이터를 모델링하는게 더 자연스러움(페이스북)
	그래프는 두 유형의 객체로 이루어짐
	  정점(노드,엔티티라고도 부름)
	  간선(관계,호라고도 부름)
	예를들면 소셜그래프에서 정점은 사람이고 간선은 인지여부,웹그래프에서 정점은 웹페이지고 간선은 링크 이런식
	
	근데,이런 그래프형 관계에서 가장 좋은점은,동종 데이터에 국한되지 않는다는점임
	즉 사람이라는 정점에서 인지여부라는 간선을 쓰다가,사람에다가 사는위치라는 간선을 긋고 지역이라는 정점으로 연결시키는게 가능함
	
	이런 서로 다른 여러유형의 정점과 간선을 단일그래프로 유지할수있다는게 가장 좋은점임
	
	그래프의 종류에는 속성그래프와 트리플그래프등이 있음
	
	1.속성그래프
	  속성그래프 모델에서 각 정점은
	    고유식별자(id)
		유출간선집합
		유입간선집합
		속성컬렉션(키값쌍,즉 맵)
	  으로 구성됨
	  
	  또한 각 간선은
	    고유식별자(id)
		간선이 시작하는 정점(꼬리정점)
		간선이 끝나는 정점(머리정점)
		두정점간 관계 유형을 설명하는 레이블
		속성컬렉션(맵)
	  으로 구성됨
	  
	  머리와 꼬리 정점은 각 간선마다 저장되고,정점을 위한 유입간선과 유출간선의 집합이 필요하면,간선테이블에서 조회하면됨
	  이떄 핵심은
	    정점은 다른 정점과 연결하려면 간선을 사용해야함,이때 특정 유형과 관련여부를 제한하는 스키마는 없음
		정점이 있으면 정점의 유입과 유출간선을 효과적으로 찾을수있고,그래프순회가 쉬움(꼬리나 머리타고 재귀,이를위해 꼬리머리 인덱스를 만들어둬야함)
	  이걸통해 전통적인 관계형 스키마에서 표현하기 어려운 사례 몇가지를 해결할수있음
	  국가,지역구조나,
	  각각 사람이 자기가 가진 알레르기원인물질에 간선을 연결할수있게하고,이걸통해 어떤 집합에서 먹을수있는 음식을 쉽게 알아내는방식으로 질의할수있음
	
	2.사이퍼 질의 언어
	  사이퍼는 속성그래프를 위한 선언형 질의언어로,네오포제이용으로 만들어짐
	  이걸 사용하면,특정 조건의 간선들을 가진(미국에서 태어났고 한국에서 살고있는 등)정점들의 집합등을 찾기가 매우 쉬움
	  즉 특정 간선이 존재하는지,특정 간선을 끝까지 재귀했을떄의 값이 무엇인지 이 두개를 하나로 묶은 조건들의 집합을 가지고 쿼리하기 편하다는것
	  
	  이떄 값(레이블)에 대해 인덱스가 있다면 매우 효율적으로 찾을수있음(선언형이니까 저런거 선택은 옵티마이저가 하니까 날로먹을수있음)
	
	3.sql의 그래프 질의
	  관계형 db에서도 그래프 데이터를 표현할수는 있지만,재귀를 타는게 매우 복잡함(mysql의 리커시브만 생각해도 머리아픔)
	  결국 이런형태가 필요하다면 그래프db를 사용하는게 나음
	
	4.트리플 저장소와 스파클
	  이건 속성그래프모델과 거의 똑같음,그냥 용어만 다름
	  
	5.시맨틱 웹
	  솔직히 별로 관계없는토픽인데,그래프 구조를 사용해서 웹을 그래프구조로 만들자 뭐 이런 프로젝트같은거임
	  그러니까 시맨틱 웹이 그래프모델을 사용(의존)하는거지,그래프모델에서는 시맨틱웹과 의존성이 없음
	
  4.정리
    nosql은 크게 문서db랑 그래프db로 나눠짐
		문서db는 데이터가 문서 자체에 포함되어있고,하나의 문서가 다른 문서와 관계가 거의 없는 사례에 적합하고
		그래프db는 모든것이 잠재적으로 관련있다는 사용 사례를 대상으로 함
	관계형,문서,그래프 전부 다 각 모델이 어울리는곳이 있고,다른영역을 흉내낼수는있지만 결과물은 대부분 엉망이 됨
	
	문서나 그래프 db가 가진 공통점중 하나는,스키마를 강요하지않아 요구사항변경에 맞춰 어플리케이션을 쉽게 변경할수있다는것
	단 어플리케이션은 데이터가 특정 구조를 갖는다고 가정할거임(읽기스키마)
	 
	  
	  
3.저장소와 검색
  1.데이터베이스를 강력하게 만드는 데이터 구조
    가장 기본적인 데이터베이스는,단순히 파일 끝에 키-값 한줄씩을 저장하면됨
	그러니 최신값을 찾으려면 키의 마지막항목을 찾아보면됨
	이런식으로 하는게 로그방식임
	이건 쓰기성능은 매우 좋지만,읽기성능은 매우좋지않음(거의 대부분이 O(n))
	
	그래서 나오는게 색인(인덱스)임
	색인의 일반적인 개념은 어떤 부가적인 메타데이터를 사용하고,이 메타데이터는 이정표 역할을 해서 원하는 데이터의 위치를 찾는데 도움을 줌
	같은 데이터를 여러 방법으로 검색하려면,여러 색인이 필요함
	
	색인은 기본데이터에서 파생된 추가적인 구조고,그래서 색인의 추가와 삭제는 자유롭고,이때 db의 내용에 영향을 미치지않음(질의속도에만 영향을 줌)
	색인의 구조상 쓰기량이 늘어나니,색인을 사용하면 무조건 쓰기성능이 저하됨
	
	여기서 트레이드오프가 있는데,색인을 추가하면 반드시 쓰기성능이 떨어지고,색인을 잘 선택하면 읽기질의속도가 향상됨
	그래서 색인을 잘 선택해야함
	
	1.해시색인
	  보통 키값저장소는 해시맵으로 구현함,
	  그래서 가장 간단한 색인은 키를 바이트오프셋에 매핑해서 인메모리해시맵을 유지하는게 가장 간단함
	  즉 키와 그 키의 바이트위치를 저장해두면서,원래있던키의 변경이나 새 키의 생성이 들어오면 그냥 마지막에 적고,
	  찾을때는 마지막부터 처음 하나를 만날때까지 서치하는식
	  
	  이걸 단순히 파일하나에 계속 쌓으면 디스크공간이 부족해지니,특정크기의 세그먼트로 나눠가면서 적고
	  
	  물론 이대로만 하면 삭제,동시성제어든 신경써야할게 좀 더 많긴한데,원리적으로는 이런식
	  이런식으로 추가전용로그는 낭비처럼 보이지만,쓰기성능이 매우 좋고,고장복구도 매우좋음(이전값을 지우지않으니까)
	  
	  단,해시테이블은 메모리에 저장해야하므로 키가 너무많으면 문제가되고
	  범위질의에 효율적이지않음(O(n)으로 전체서치해야함)
	
	2.ss테이블과 lsm트리
	  이전 세그먼트파일(위에거)에서 키값쌍을 키로 정렬하는 추가사항을 넣으면 이게 ss테이블(정렬된 문자열 테이블)임
	  이떄의 키 중복은,가장 최근세그먼트의 값만 유지하고 오래된 세그먼트의 값은 버리는식으로 처리가능
	  
	  이런식으로 하면 메모리에 모든 키색인을 유지할필요가 없고(정렬되있으니까 대충 그위치가서 찾으면됨,적당히 일부키에 대한 위치만 알고있으면됨,이진탐색용)
	  색인검색의 특성상 디스크공간압축과 io대역폭사용도 줄일수있음
	  
	  이떄 데이터를 키로 정렬하려면,디스크상에 정렬된 구조를 유지하는거보단 메모리에 유지하는게 훨씬 쉬움
	    쓰기가 들어오면 밸런스트리(멤테이블이라고 부름)에 추가하고
	    멤테이블이 특정임계값(보통 4mb정도)보다 커지면 디스크에 기록함,이때 트리는 정렬되어있음
		읽기요청이 들어오면 멤테이블에서 찾고,그다음엔 최신세그먼트에서 찾는식으로 반복
		가끔 세그먼트파일을 합치고 덮어쓰여지거나 삭제된값을 버리는 병합과 컴팩션을 수행하면됨
		
	  이건 잘 동작하지만,컴퓨터가 꺼지면 메모리에 있던게 유실되는 단점이 있음,
	  그래서 매번 쓰기를 즉시 추가할수있게 분리된 로그를 디스크상에 유지해야함
	  이건 복원시에만 사용되기때문에 정렬이 필요없고,디스크에 저장하고나면 쌓였던건 버리면됨
	  
	  이 ss테이블을 기본 베이스로 깐 구조가 로그 구조화 병합 트리(lsm트리)임
	  
	  물론 이거만 가지곤 동작이 좋지않고,세부사항들이 있음
	  없는키조회시 O(n)을 막기위한 블룸필터(키가 있는지없는지를 알려줌)
	  ss테이블을 압축하고 병합하는 순서와 시기를 결정하는 전략들 등이 있음
	
	3.b트리
	  가장 일반적인 색인 유형은 b트리임
	  로그구조화색인이 db를 수 메가바이트의 가변크기를 가진 세그먼트로 나누고,순차적으로 세그먼트를 기록한다면
	  b트리는 4kb의 고정크기 블록이나 페이지로 나누고,한번에 하나의 페이지에 읽기 또는 쓰기를 함
	  
	  각 페이지는 주소나 위치를 통해 식별할수있고,이 방식으로 하나의 페이지가 다른 페이지를 참조할수있음
	  이걸통해 페이지트리를 만들수있음
	  대충  
		ref1 100  ref2  200 ref3 300...
	  이런식의 루트트리에서 251을 조회하면 200과 300의 사이인 ref3으로 타고 내려가는식임
	  그러다가 리프페이지를 만나면 키가 있거나 없거나를 확인할수있음
	  
	  키를 추가할때는 새 키를 포함해야하는 범위의 페이지를 찾아서 해당 페이지에 키값을 추가하고,
	  여유공간이 없으면 페이지하나를 두개로 쪼개고,상위를 갱신함
	  
	  이 알고리즘은 트리가 균형을 유지하는걸 보장함(깊이가 O(log n)임을 보장함)
	  
	  b트리의 기본쓰기동작은 새 데이터를 디스크상의 페이지에 덮어씀
	  이 동작은 덮어쓰기가 페이지위치를 변경하지않는다고 가정함,즉 페이지를 덮어쓰더라도 페이지를 가리키는 모든 참조는 그대로 남음
	  
	  페이지 분할시 같은,여러페이지를 동시에 건드려야할때,중간에 컴퓨터가 뻗으면 위험해지는데,이걸 방지하기위해 쓰기전 로그를 미리 만들어두고 실행후 제거함
	  만약 db가 켜졌을떄 쓰기전로그가 남아있다면,그걸 확인하고 다시 작업하는식임
	  
	  또한 같은자리의 페이지를 갱신할때(다중스레드),동시에 접근할수있기때문에 이런경우 래치로 보통 보호함
	
	4.b트리와  lsm트리 비교
	  b트리와 lsm트리는,보통 b트리가 읽기에서 더 빠르고,lsm트리는 쓰기에서 더 빠름
	  또한 b트리가 구현성숙도가 더 높긴함(오래돼서)
	  물론 세부사항에 따라 속도도 다 다르긴함
	  
	  b트리색인은 모든 데이터조각을 최소한 두번 기록해야함(쓰기전로그와 트리페이지)
	  또한 해당 페이지내 몇바이트만 바뀌어도 전체페이지를 기록해야하는 오버헤드도 있음 
	  
	  로그구조화색인은 반복된 컴팩션과 병합으로 인해 여러번 데이터를 다시쓰는데,이걸 쓰기증폭이라고 부름
	  ssd에선 쓰기횟수가 제한되기때문에 특별한 관심사임
	  
	  쓰기가 많은 어플리케이션에서 성능병목은 db가 디스크에 쓰는속도일수있음,이떈 쓰기증폭이 성능비용임
	  더욱이 lsm트리는 b트리보다쓰기처리량을 높이기 쉬움(순차쓰기떄문),또한 압축률이 b트리보다 좋음
	  
	  b트리는 파편화가 좀 있음
	  
	  lsm트리의 단점은 컴팩션과정이 읽기쓰기 성능에 영향을 준다는것
	  또한 컴팩션 설정을 주의깊게 하지 않으면 컴팩션이 유입쓰기속도를 못따라가서 읽기속도도 느려질수있음,이를위해 모니터링이 필요함
	  
	  b트리의 장점은 각 키가 색인의 한곳에만 정확히 존재한다는점이고,lsm트리는 다른 세그먼트에 같은키의 다중 복사본이 존재할수 있다는거임
	  그래서 강력한 트랜잭션이 필요하면 b트리가 더 매력적임
	  
	5.기타색인구조
      프라이머리키 색인이 키값색인의 가장 대표적이 예고,세컨더리 색인도 효율적인 조인을 수행할떄 도움을 줌(외래키색인)
	  
	  그리고 해당 데이터양이 적을경우나,키같은경우엔 색인에 아예 데이터를 같이 저장하는경우도 있음(두번조회비용보다 그냥 두번적는게 싸다고 생각될떄)
	  이걸 클러스터드 색인이라고 함
	  
	  mysql의 경우 프라이머리키는 클러스터드색인이고,보조색인은 이 프라이머리키 색인을 참조함
	  
	  또한 다중칼럼에 대해 질의할때는, 다중칼럼색인을 써야하는데,이거의 가장 일반적인 유형은 결합색인임
	  이건 그냥 abc,123,456,qqq이런식으로 문자열로 단순히 결합하는식
	  이건 순서에 영향을 매우 많이받아서,앞에서부터 순서대로 쓸수있는 조회에 적합함
	  
	  다차원색인은 지리공간데이터에 중요한 색인인데,이건 공간채움곡선을 사용해서 단일숫자로 위치를 변환하거나,전문공간색인을 사용하는것
	  
	  또한 정확한 키가 아닌 유사한키를 검색할땐 전문검색용으로 n그램같은걸 사용할수있음
	  
	  지금까지의 모든건 디스크한계에 대한 해결책이었고,만약 단순캐시용도로만 사용할거라면 인메모리 db를 사용할수있음
	  
2.트랜잭션 처리나 분석?	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
