1.신뢰할수있고 확장가능하며 유지보수하기 쉬운 어플리케이션
  요즘 어플리케이션은 계산중심이 아니라 데이터중심적임
  그래서 병목이 데이터의 양,복잡도,변화속도에 걸림
  
  데이터 중심 어플리케이션은,공통적으로 필요로하는 기능을 제공하는 표준 구성 요소를가짐
	데이터를 다시 찾을수있게함 (db)
	읽기속도 향상을 위해 값비싼 수행결과를 기억(캐시)
	사용자가 키워드로 데이터를 검색하거나 다양한방법으로 필터링할수있게 제공(검색색인)
	비동기처리를 위해 다른 프로세스로 메시지 보내기(스트림처리)
	주기적으로 대량의 누적된 데이터를 분석(일괄처리,즉 배치)]
  이런것들이 다 추상화되어서 들어가지만,어플리케이션마다 요구사항이 달라서,db시스템또한 저마다 다양한 특성을 가지고,
  어플리케이션을 만들때 어떤 도구와 어떤 접근방식이 수행작업에 가장 적합한지를 생각해야함
  
  1.데이터 신뢰성에 대한 생각
	db와 큐 캐시등을 달라보이고,실제로 매우 다른 접근패턴을 가지지만 데이터시스템이라는 포괄적 용어로 묶을수있음
	이유는,
	  1.레디스(메시지큐 데이터스토어)나 카프카(지속성을 보장하는 메시지큐)등으로 인해 분류간 경계가 흐려짐
	  2.많은 어플리케이션이 단일도구로는 더이상 데이터처리와 저장 모두를 만족시킬수 없는 과도하고 광범위한 요구사항을 가지고있음,
		대신 작업은 단일도구에서 효율적으로 수행할수있는 태스크로 나누고,다양한 도구들은 어플리케이션 코드를 이용해 서로 연결함
	  3.서비스제공을 위해 각 도구를 결합할땐,인터페이스로 클라이언트가 세부사항을 모르게 숨김(포트),그래서 어플리케이션이 접근할땐 다 동일하게 접근할수있음
	이런 이유등이 있음
	
	데이터 시스템이나 서비스를 설계할때 가장 중요한건
		신뢰성:결함,인적오류등이 생겨도 시스템은 지속적으로 올바르게 동작(원하는성능수준에서 정확한기능을 수행)해야함
		확장성:데이터량,트래픽량,복잡도가 증가하면서 이를 처리할수있는 적절한 방법이 있어야함
		유지보수성:모든 사용자가 시스템상에서 생산적으로 작업할수있어야함
	이 3가지임

  2.신뢰성
  	  소프트웨어는
	    어플리케이션은 사용자가 기대한 기능을 수행
	    시스템은 사용자가 범한 실수나 예상치못한 소프트웨어 사용법을 허용할수있음
	    시스템 성능은 예상된 부하와 데이터양에서 필수적인 사용사례를 충분히 만족함
	    시스템은 허가되지않은 접근과 오남용을 방지함
	  보통 이정도를 기대하는데,대충 무언가 잘못되더라도 지속적으로 올바르게 동작함 이라고 생각하면됨
	
	  이떄 잘못될수있는일을 결함이라고 하고,결함을 예측하고 대처할수있는 시스템을 내결함성,또는 탄력성을 지녔다고 함
	  물론 모든종류의 결함을 견딜수는 없음(전쟁나서 서버에 폭탄터졌는데 웹서버가 그걸 버틸수는없음)
	
	  결함은 장애와 동일하지않음
	  결함은 사양에서 벗어난 시스템의 한 구성요소로 정의되지만,장애는 사용자에게 필요한 서비스를 제공하지못하고 시스템 전체가 멈춘경우임
	  결함확률을 0으로 줄이는건 불가능하고,그래서 결함으로 장애가 발생하지않게 내결함성을 챙기는게 가장좋음
	
	  이를 테스트하려고 카오스몽키같은걸 쓸수도있고,예방책이 해결책이 더 좋은경우도 있음(해킹같은거)
	  
	1.하드웨어결함
	  시스템 장애의 원인중 대표적인게 하드웨어결함이고,이건 규모가 커지면 늘상 일어남
	  보통 이걸 해결하는방법은 각 하드웨어구성요소에 중복을 추가하는것(raid같은거),아니면 클라우드로 노드를 여러개쓰는방법도 있음
	  
	2.소프트웨어 오류
	  보통 하드웨어결함은 서로간에 별로 상관관계가 없음,근데 시스템 내의 체계적오류는 예상하기 더 어렵고,노드간 상관관계때문에 시스템오류를 더욱 많이 유발함
		잘못된 특정입력이 있을때 모든 어플리케이션 서버인스턴스가 죽는 버그
		cpu,메모리,디스크공간등 공유자원을 과도하게 사용하는 일부프로세스
		시스템속도가 느려져 반응이 없거나 잘못된 응답을 반환하는 서비스
	  등이 있음
	  
	  이런 소프트웨어결함은 특정 상황에 의해 발생하기전까지 오랫동안 나타나지않음,즉 소프트웨어는 환경에 대한 일종의 가정이 있고,
	  이 가정은 대개 문제없지만 어떤이유로 문제가 생기게됨(가정이 꺠지게됨)
	  
	  이런 문제는 신속한 해결책이 없고,테스트,프로세스격리,죽은프로세스의 재시작허용,모니터링등으로 해결해야함
	  로깅을 해서 그걸 모니터링하는방법도 있음
	
	3.인적오류
	  사람은 가장 중단의 메인 원인임
	  그래서
	    오류를 최소화하는 방향으로 시스템을 설계(추상화)
		가장 많이 실수하는장소에서 실수로 장애가 발생하는 부분을 분리
		샌드박스의 제공
		단위테스트부터 통합테스트등을 철저히 테스트
		인적오류를 빠르고 쉽게 복구할수있게 하기(롤백 롤아웃가능하게)
		성능지표와 오류율등을 모니터링하기
	  등을 해야함
	
	4.신뢰성은 얼마나 중요할까?
	  버그는 생산성저하의 원인이고,어플리케이션은 사용자에 대한 책임이 있음
	  스타트업에서 비용을 줄이려고 신뢰성을 희생해야하는경우가 있지만,이때는 신뢰성을 다시 돌려놓는 지점을 잘 알아야함

  3.확장성
	시스템이 현재 안정적으로 동작한다고 미래에도 안정적으로 동작한다는 보장은 없음
	보통 부하증가로 인해 성능이 저하됨
	
	확장성은 증가한 시스템능력을  설명하는데 사용하는 용어지만,시스템에 부여하는 일차원적 표식이 아님
	이건 
	  시스템이 특정 방향으로 커지면 이를 대처하기위한 선택은 무엇인가?
	  추가부하를 다루기위해 계산자원을 어떻게 투입할까?
	같은 질문을 고려한다는 의미임
	
	1.부하기술하기
	  가장 먼저 해야하는건,시스템의 현재 부하를 간결하게 기술해야함,그래야 부하성장질문(부하가 2배커지면 어떻게하지?)를 논의할수있음
	  부하는 부하매개변수라 부르는 몇개의 숫자로 나타낼수있는데,
	  예를들어
	    웹서버의 초당 요청수
		db의 읽기 대 쓰기 비율
		대화방의 동시 활성 사용자
		캐시 적중률
	  등이 있음
	  
	  이떄 평균적인 경우가 중요할수도 있고,소수의 극단적인 경우가 병목의 원인일수도있음
	  즉 어플리케이션의 현재 상황에 맞춰서 선택해야함
	
	2.성능 기술하기
	  부하를 기술했으면,부하가 증가할때 어떤일이 일어나는지 조사할수있음
	    부하 매개변수를 증가시키고 시스템 자원은 변경하지않는다면 시스템 성능은 어떻게영향을 받을까?
		부하 매개변수를 증가시켰을때 성능이 변하지않고 유지되길 원한다면 자원을 얼마나 많이 늘려야할까?
	  둘 다 성능수치가 필요함
	  
	  하둡같은 일괄처리시스템은 처리량에 관심을 가지고,온라인시스템은 서비스응답시간을 관심을 가짐
	  
	  응답시간은 매번 값이 다르니,값의 분포로 생각을 하고 중앙값(p50)과 p95,p99정도를 봐야함
	  또한 시스템의 확장성을 테스트하려고 인위적으로 부하를 생성할땐,응답시간과 독립적으로 요청을 지속적으로 보내야함
	  클라가 다음 요청을 보내기 전에 이전 요청이 완료되길 기다리면,테스트가 왜곡됨
	
	3.부하 대응 접근 방식
	  기본적으로 스케일업은 비싸니,스케일 아웃이 가능하게해야하고,시스템은 탄력적이면 부하가 예측할수없을만큼 높으면 유용하지만,
	  수동으로하는게 예상치못한일은 더 적음
	  
	  또한 스테이트리스가 다수의장비에 배포하기 쉽고,스테이트풀을 분산설치하는건 매우 복잡도가 높음
	  
	  모든곳에 맞는 아키텍처는 없고,읽기의양,쓰기의양,저장할데이터의 양,데이터의 복잡도,응답시간요구사항,접근패턴등을 고려해서 선택해야함
	  즉 이런 가정을 바탕으로 확장성을 체크하는데,이 가정이 틀려버리면 확장을 위한 노력은 다 헛수고가 되고,역효과를 낳을수도있음
	  그래서 스타트업초기단계에선 확장보단 빠르게 반복해서 제품기능 개선하는게 나음
  
  4.유지보수성
    유지보수에서 중요한건
	  운용성:운영팀이 시스템을 원활하게 운영할수있게 쉽게 만들자
	  단순성:시스템에서 복잡도를 최대한 제거해 새 엔지니어가 시스템을 이해하기 쉽게 만들자
	  발전성:엔지니어가 시스템을 쉽게 변경할수 있게 하자
	이 3가지임
	
	신뢰성과 확장성을 달성하는 쉬운방법은 없지만,최소한 유지보수성은 챙겨가야함
	
	1.운용성:운영의 편리함 만들기
	  운영의 일부는 자동화할수있지만,이 자동화를 처음 설정하고 테스트하는건 사람의 몫임
	  
	  시스템이 지속해서 원활하게 작동하려면 운영팀이 필수고,좋은 운영팀은
		시스템상태를 모니터링하고 상태가 좋지못하면 빠르게 서비스를 복원
		시스템장애,성능저하등 문제의 원인을 추적
		보안패치를 포함해 소프트웨어와 플랫폼을 최신상태로 유지
		다른시스템이 서로 어떻게 영향을 주는지 확인해,문제가 생길수있는 변경사항을 손상을 입히기 전에 차단
		미래에 발생가능한 문제를 예측해 문제가 발생하기전에 해결
	  이런일들을 함
	  
	  또한 좋은 운영성이란 동일하게 반복되는 태스크를 쉽게 수행하게 만들어,고부가가치활동에 노력을 집중할수있게함
	
	2.단순성:복잡도관리
	  프로젝트가 커지면 시스템은 매우 복잡하고 이해하기 어려워짐
	  보통
		상태공간의 급증
		모듈간 강한 커플링
		복잡한 의존성
		일관성없는 명명과 용어
		성능문제해결을 목표로한 해킹
		임시방편으로 문제를 해결한 특수사례
	  등이 있음
	  
	  보통 복잡도가 올라가서 유지보수가 어려워지면 예산과 일정이 초과됨
	  변경이 있으면 버그가 생기기 쉽기때문
	  
	  또한 개발자가 시스템을 이해하고 추론하기 어려워지면,시스템에 숨겨진 가정과 의도치않은 결과 및 예기치 않은 상호작용을 간과하기 쉬움
	  반대로 복잡도를 줄이면 유지보수성이 크게 향상됨,즉 단순성이 시스템의 핵심목표임
	  
	  시스템을 단순하게 만든다는게 기능을 줄인다는걸 의미하진않고,우발적 복잡도를 줄이는게 목표임
	  이걸위해 추상화를 사용함
	
	3.발전성:변화를 쉽게 만들기
	  시스템의 요구사항은 계속 바뀜,이걸 민첩하게 받아들일수 있는게 발전성임
	  이때마다 쉽게 변화를 줄수있어야함,이를위해 tdd등을 사용할수있음
	  
	  이건 단순성(과 추상화)에 영향을 많이받음
  
  5.정리
    어플리케이션은 기능적 요구사항(동작해야하는 기능)과 비기능적 요구사항(유지보수성,단순성,신뢰성등)을 충족시켜야함
	
	신뢰성은 결함이 발생해도 시스템이 올바르게 동작해야한다는것
	확장성은 부하가 증가해도 좋은 성능을 유지하기 위한 전략
	유지보수성은 엔지니어와 운영팀의 삶을 개선하는데 목적이 있음(즉 변경코스트를 줄이는데 목적이 있음)
	
2.데이터모델과 질의언어
  데이터모델은 소프트웨어가 해결하려는 문제를 어떻게 생각해야하는지에 대해 지대한 영향을 미침
  
  대부분의 어플리케이션은 하나의 데이터모델을 다른 데이터모델 위에 계층을 둬서 만듬
  각 계층의 핵심문제는,다음 하위 계층 관점에서 데이터모델을 표현하는 방법임
  또한 각 계층은 명확한 데이터모델을 제공해서 자신보다 하위계층의 복잡성을 숨김(추상화)
  
  1.관계형 모델과 문서 모델
    대표적으로 나누면 rdbms와 nosql이 있음
	알디비의 근원은 비즈니스 데이터처리에 있고,이건 트랜잭션과 일괄처리가 핵심이었음
	
	1.nosql의 탄생
	  nosql은 not only sql로,이건
		높은 쓰기처리량을 쉽게 할수있는 확장성
		알디비에서 지원하지않는 특수질의
		알디비의 스키마에 대한 불만과 더 동적인 데이터모델에 대한 바램
	  으로 인해 나왔음 
	  
	2.객체 관계형 불일치
	  알디비의 문제는,객체와 스키마는 동일하지않고,이를 전환하기위해 전환계층이 필요함
	  이걸 임피던스 불일치라고 부름
	  
	  orm은 이때의 보일러플레이트를 줄여주지만,각 모델간의 차이를 완벽히 숨길수는 없음
	  이때 알디비로 각 테이블을 다 분리해서 쪼개는거보다(정규화),그냥 문서모델로 문서처럼 때려박는게 더 객체와 비슷한 표현이 되는경우가 있음
	  보통 sql쿼리는 복잡한 다중조인을 통해서 가져와야하기때문,근데 json표현에서는 해당 문서만 가져오면됨(보통 트리구조일떄 적합함)
	
	3.다대일과 다대다 관계
	  보통 정규화를 하는 이유는,
		일관된 스타일과 철자(오타방지)
		모호함 회피(같은이름 중복일때 다른id로 처리가능)
		갱신의 편의성(정규화테이블만 수정하면됨)
		현지화 지원(id값만 가져오니 거기에 추가로 필드덧대기가능)
		더 나은 검색(역방향 조회가능)
	  가 있음
	  즉 중복회피로 인한 실수방지와 갱신편의성,데이터 무결성보장,역방향조회등이 정규화의 핵심임
	  
	  중복된 데이터를 정규화하려면 다대일관계가 필요한데,이건 문서모델(nosql)에 적합하지않음
	  문서모델은 조인에 대한 지원이 약하기때문
	  어케어케 해결할수있긴하지만..
	  
	  또한 어플리케이션의 초기버전이 조인이 없는 문서모델에 적합하더라도,기능을 추가하면서 데이터는 점차 상호연결되는 경향이 있음
	
	4.문서 데이터베이스는 역사를 반복하나?
	  문서모델도 일대다에서는 잘 동작하는데,핵심은 다대다(와 다대일) 관계 표현임
	  이때 데이터를 중복할지 또다른 레코드와의 참조를 수동으로 해결할지를 결정해야함
	  
	  일단 문서모델도 문서참조(알디비의 외래키)를 사용해서 고유한 식별자로 해결하고있고,이건 조인이나 후속질의를 사용해서 읽기시점에 확인함
	
	5.관계형 db와 문서모델
	  이 두개는 내결함성과 동시성처리를 포함해 고려해야할 차이점이 많이있지만,데이터모델의 차이점에만 우선 집중하자면
	  문서모델은 스키마 유연성,지역성에 기인한 더 나은성능,특정 어플리케이션에서는 객체와 더 가깝기 때문에 선호도가 있고
	  관계형db는 조인,다대일,다대다 관계를 더 잘지원함
	  
	  어플리케이션의 데이터가 문서와 비슷한 구조(트리형태)라면 문서모델을 사용하는게 좋음
	  즉 특정 id를 가져오면 해당하는 데이터 전체가 필요한경우에 적합
	  알디비는 이런경우에 복잡한 스키마와 복잡한 어플리케이션 코드를 발생시킴
	  
	  문서모델의 미흡한 조인도,조인을 사용하지 않는 구조라면 상관없음
	  
	  단,어플리케이션에서 다대다관계가 필요하다면 문서모델은 매력이 떨어짐
	  비정규화로 어느정도 조인필요성 감소는 가능하긴하지만,이럴경우 어플리케이션의 복잡도가 올라가고,무엇보다 알디비보다 더 느림
	  
	  보통 상호연결이 많으면 문서형 모델은 별로고,관계형모델이 무난하고,그래프모델은 더 나음
	  
	6.문서모델에서의 스키마 유연성
	  보통 문서형 db와 알디비의 json은 어떤 스키마를 강요하지않음
	  그래서 스키마리스로 불리지만 정확히는 읽기스키마임,읽을때는 형식이 있지만 쓸때는 형식이 없어도됨
	  반대로 알디비는 쓰기스키마고
	  
	  이 둘은 약타입언어와 강타입언어와의 관계와 비슷함
	  
	  이렇게 읽기스키마의 장점은,데이터타입 변경이 쉽다는거고(그냥 다르게 넣으면됨,변경시에 예전걸 읽었을때의 처리만 있으면됨),
	  쓰기스키마는 이럴경우 마이그레이션을 해야함
	  
	  즉 읽기쓰키마는 컬렉션안의 항목이 어떤이유로 모두 동일한 구조가 아닐때 유리함
		다른 여러유형의 오브젝트가 있고 각 유형별 오브젝트로 자체테이블에 넣는건 실용적이지않음
		사용자가 제어할수없는 언제나 변경가능한 외부시스템에 의해 데이터구조가 결정됨
	  단,모든 레코드가 동일한구조라서 예상가능하다면 그냥 스키마 가져가는게 맘편함,이래야 문서화와 구조강제가 쉬움
	  
	7.질의를 위한 데이터 지역성
	  문서는 json으로 보통 저장됨,그래서 어플리케이션이 자주 특정 문서의 전체에 접근해야하면 이때의 지역성을 활용하면 성능이점이 있음
	  단 이건 한번에 해당 문서의 많은 부분을 필요로 할때만 적용됨
      작은 부분만 필요할떄는 전부 읽어야한다는게 낭비고,문서를 갱신할떄도 전체를 재작성해야함
	   
	  그래서 보통 이런 문서모델의 db는 문서를 아주 작게 유지하고,문서의 크기가 증가하는 쓰기를 피하려고 노력함
	  이거때문에 문서db가 유용한 상황이 많이 줄어듬
	   
	8.문서db와 관계형db의 통합
	  요즘은 관계형db도 요즘은 다 json을 지원하고,문서형db도 조인을 지원하는등 서로간에 비슷해지고있음
	
  2.데이터를 위한 질의 언어
    sql은 선언형임,즉 원하는걸 말하면 알아서 해석해서 거기에 맞는값을 돌려주지,내가 뭘 시키지않음(이건 옵티마이저가 할일)
    즉 동작이 추상화되어있어서 내부동작을 디비개발자가 알아서 수정해도 별 문제를 일으키지않음
    
    또한 sql은 기본적으로는 순서를 보장하지않아서,이부분을 활용한 성능최적화도 가능하고,특히 병렬실행도 쉬움
	1.웹에서의 선언형 질의
	  css도 이런식으로 선언형 질의라고 할수있음
	  특정 어디에 있는 뭘 바꾸라고 하는게 아닌,특정 id인걸 바꾸던가 이런식이니까
	2.맵리듀스 질의
	  맵리듀스는 많은 컴퓨터에서 대량의 데이터를 처리하기위한 프로그래밍모델이고,이건 몽고db같은 일부 nosql에서 제한된 형태로 지원함	  
	  이건 많은 문서를 대상으로 읽기전용 질의를 수행할때 사용됨
	  
	  이건 선언형과 명령형의 중간에 있음
	  선언형으로 데이터를 줄인다음,명령형으로 그 데이터를 가공하는 느낌임
	  느낌적으론 select절 서브쿼리와 from절 서브쿼리같은 느낌임,데이터를 일단 가져와서 수정하는느낌
	  
	  몽고db의 map과 reduce함수는 둘 다 순수함수여야함

  3.그래프형 데이터 모델
    데이터에서 다대다관계가 매우 일반적이라면 그래프로 데이터를 모델링하는게 더 자연스러움(페이스북)
	그래프는 두 유형의 객체로 이루어짐
	  정점(노드,엔티티라고도 부름)
	  간선(관계,호라고도 부름)
	예를들면 소셜그래프에서 정점은 사람이고 간선은 인지여부,웹그래프에서 정점은 웹페이지고 간선은 링크 이런식
	
	근데,이런 그래프형 관계에서 가장 좋은점은,동종 데이터에 국한되지 않는다는점임
	즉 사람이라는 정점에서 인지여부라는 간선을 쓰다가,사람에다가 사는위치라는 간선을 긋고 지역이라는 정점으로 연결시키는게 가능함
	
	이런 서로 다른 여러유형의 정점과 간선을 단일그래프로 유지할수있다는게 가장 좋은점임
	
	그래프의 종류에는 속성그래프와 트리플그래프등이 있음
	
	1.속성그래프
	  속성그래프 모델에서 각 정점은
	    고유식별자(id)
		유출간선집합
		유입간선집합
		속성컬렉션(키값쌍,즉 맵)
	  으로 구성됨
	  
	  또한 각 간선은
	    고유식별자(id)
		간선이 시작하는 정점(꼬리정점)
		간선이 끝나는 정점(머리정점)
		두정점간 관계 유형을 설명하는 레이블
		속성컬렉션(맵)
	  으로 구성됨
	  
	  머리와 꼬리 정점은 각 간선마다 저장되고,정점을 위한 유입간선과 유출간선의 집합이 필요하면,간선테이블에서 조회하면됨
	  이떄 핵심은
	    정점은 다른 정점과 연결하려면 간선을 사용해야함,이때 특정 유형과 관련여부를 제한하는 스키마는 없음
		정점이 있으면 정점의 유입과 유출간선을 효과적으로 찾을수있고,그래프순회가 쉬움(꼬리나 머리타고 재귀,이를위해 꼬리머리 인덱스를 만들어둬야함)
	  이걸통해 전통적인 관계형 스키마에서 표현하기 어려운 사례 몇가지를 해결할수있음
	  국가,지역구조나,
	  각각 사람이 자기가 가진 알레르기원인물질에 간선을 연결할수있게하고,이걸통해 어떤 집합에서 먹을수있는 음식을 쉽게 알아내는방식으로 질의할수있음
	
	2.사이퍼 질의 언어
	  사이퍼는 속성그래프를 위한 선언형 질의언어로,네오포제이용으로 만들어짐
	  이걸 사용하면,특정 조건의 간선들을 가진(미국에서 태어났고 한국에서 살고있는 등)정점들의 집합등을 찾기가 매우 쉬움
	  즉 특정 간선이 존재하는지,특정 간선을 끝까지 재귀했을떄의 값이 무엇인지 이 두개를 하나로 묶은 조건들의 집합을 가지고 쿼리하기 편하다는것
	  
	  이떄 값(레이블)에 대해 인덱스가 있다면 매우 효율적으로 찾을수있음(선언형이니까 저런거 선택은 옵티마이저가 하니까 날로먹을수있음)
	
	3.sql의 그래프 질의
	  관계형 db에서도 그래프 데이터를 표현할수는 있지만,재귀를 타는게 매우 복잡함(mysql의 리커시브만 생각해도 머리아픔)
	  결국 이런형태가 필요하다면 그래프db를 사용하는게 나음
	
	4.트리플 저장소와 스파클
	  이건 속성그래프모델과 거의 똑같음,그냥 용어만 다름
	  
	5.시맨틱 웹
	  솔직히 별로 관계없는토픽인데,그래프 구조를 사용해서 웹을 그래프구조로 만들자 뭐 이런 프로젝트같은거임
	  그러니까 시맨틱 웹이 그래프모델을 사용(의존)하는거지,그래프모델에서는 시맨틱웹과 의존성이 없음
	
  4.정리
    nosql은 크게 문서db랑 그래프db로 나눠짐
		문서db는 데이터가 문서 자체에 포함되어있고,하나의 문서가 다른 문서와 관계가 거의 없는 사례에 적합하고
		그래프db는 모든것이 잠재적으로 관련있다는 사용 사례를 대상으로 함
	관계형,문서,그래프 전부 다 각 모델이 어울리는곳이 있고,다른영역을 흉내낼수는있지만 결과물은 대부분 엉망이 됨
	
	문서나 그래프 db가 가진 공통점중 하나는,스키마를 강요하지않아 요구사항변경에 맞춰 어플리케이션을 쉽게 변경할수있다는것
	단 어플리케이션은 데이터가 특정 구조를 갖는다고 가정할거임(읽기스키마)
	 
	  
	  
3.저장소와 검색
  1.데이터베이스를 강력하게 만드는 데이터 구조
    가장 기본적인 데이터베이스는,단순히 파일 끝에 키-값 한줄씩을 저장하면됨
	그러니 최신값을 찾으려면 키의 마지막항목을 찾아보면됨
	이런식으로 하는게 로그방식임
	이건 쓰기성능은 매우 좋지만,읽기성능은 매우좋지않음(거의 대부분이 O(n))
	
	그래서 나오는게 색인(인덱스)임
	색인의 일반적인 개념은 어떤 부가적인 메타데이터를 사용하고,이 메타데이터는 이정표 역할을 해서 원하는 데이터의 위치를 찾는데 도움을 줌
	같은 데이터를 여러 방법으로 검색하려면,여러 색인이 필요함
	
	색인은 기본데이터에서 파생된 추가적인 구조고,그래서 색인의 추가와 삭제는 자유롭고,이때 db의 내용에 영향을 미치지않음(질의속도에만 영향을 줌)
	색인의 구조상 쓰기량이 늘어나니,색인을 사용하면 무조건 쓰기성능이 저하됨
	
	여기서 트레이드오프가 있는데,색인을 추가하면 반드시 쓰기성능이 떨어지고,색인을 잘 선택하면 읽기질의속도가 향상됨
	그래서 색인을 잘 선택해야함
	
	1.해시색인
	  보통 키값저장소는 해시맵으로 구현함,
	  그래서 가장 간단한 색인은 키를 바이트오프셋에 매핑해서 인메모리해시맵을 유지하는게 가장 간단함
	  즉 키와 그 키의 바이트위치를 저장해두면서,원래있던키의 변경이나 새 키의 생성이 들어오면 그냥 마지막에 적고,
	  찾을때는 마지막부터 처음 하나를 만날때까지 서치하는식
	  
	  이걸 단순히 파일하나에 계속 쌓으면 디스크공간이 부족해지니,특정크기의 세그먼트로 나눠가면서 적고
	  
	  물론 이대로만 하면 삭제,동시성제어든 신경써야할게 좀 더 많긴한데,원리적으로는 이런식
	  이런식으로 추가전용로그는 낭비처럼 보이지만,쓰기성능이 매우 좋고,고장복구도 매우좋음(이전값을 지우지않으니까)
	  
	  단,해시테이블은 메모리에 저장해야하므로 키가 너무많으면 문제가되고
	  범위질의에 효율적이지않음(O(n)으로 전체서치해야함)
	
	2.ss테이블과 lsm트리
	  이전 세그먼트파일(위에거)에서 키값쌍을 키로 정렬하는 추가사항을 넣으면 이게 ss테이블(정렬된 문자열 테이블)임
	  이떄의 키 중복은,가장 최근세그먼트의 값만 유지하고 오래된 세그먼트의 값은 버리는식으로 처리가능
	  
	  이런식으로 하면 메모리에 모든 키색인을 유지할필요가 없고(정렬되있으니까 대충 그위치가서 찾으면됨,적당히 일부키에 대한 위치만 알고있으면됨,이진탐색용)
	  색인검색의 특성상 디스크공간압축과 io대역폭사용도 줄일수있음
	  
	  이떄 데이터를 키로 정렬하려면,디스크상에 정렬된 구조를 유지하는거보단 메모리에 유지하는게 훨씬 쉬움
	    쓰기가 들어오면 밸런스트리(멤테이블이라고 부름)에 추가하고
	    멤테이블이 특정임계값(보통 4mb정도)보다 커지면 디스크에 기록함,이때 트리는 정렬되어있음
		읽기요청이 들어오면 멤테이블에서 찾고,그다음엔 최신세그먼트에서 찾는식으로 반복
		가끔 세그먼트파일을 합치고 덮어쓰여지거나 삭제된값을 버리는 병합과 컴팩션을 수행하면됨
		
	  이건 잘 동작하지만,컴퓨터가 꺼지면 메모리에 있던게 유실되는 단점이 있음,
	  그래서 매번 쓰기를 즉시 추가할수있게 분리된 로그를 디스크상에 유지해야함
	  이건 복원시에만 사용되기때문에 정렬이 필요없고,디스크에 저장하고나면 쌓였던건 버리면됨
	  
	  이 ss테이블을 기본 베이스로 깐 구조가 로그 구조화 병합 트리(lsm트리)임
	  
	  물론 이거만 가지곤 동작이 좋지않고,세부사항들이 있음
	  없는키조회시 O(n)을 막기위한 블룸필터(키가 있는지없는지를 알려줌)
	  ss테이블을 압축하고 병합하는 순서와 시기를 결정하는 전략들 등이 있음
	
	3.b트리
	  가장 일반적인 색인 유형은 b트리임
	  로그구조화색인이 db를 수 메가바이트의 가변크기를 가진 세그먼트로 나누고,순차적으로 세그먼트를 기록한다면
	  b트리는 4kb의 고정크기 블록이나 페이지로 나누고,한번에 하나의 페이지에 읽기 또는 쓰기를 함
	  
	  각 페이지는 주소나 위치를 통해 식별할수있고,이 방식으로 하나의 페이지가 다른 페이지를 참조할수있음
	  이걸통해 페이지트리를 만들수있음
	  대충  
		ref1 100  ref2  200 ref3 300...
	  이런식의 루트트리에서 251을 조회하면 200과 300의 사이인 ref3으로 타고 내려가는식임
	  그러다가 리프페이지를 만나면 키가 있거나 없거나를 확인할수있음
	  
	  키를 추가할때는 새 키를 포함해야하는 범위의 페이지를 찾아서 해당 페이지에 키값을 추가하고,
	  여유공간이 없으면 페이지하나를 두개로 쪼개고,상위를 갱신함
	  
	  이 알고리즘은 트리가 균형을 유지하는걸 보장함(깊이가 O(log n)임을 보장함)
	  
	  b트리의 기본쓰기동작은 새 데이터를 디스크상의 페이지에 덮어씀
	  이 동작은 덮어쓰기가 페이지위치를 변경하지않는다고 가정함,즉 페이지를 덮어쓰더라도 페이지를 가리키는 모든 참조는 그대로 남음
	  
	  페이지 분할시 같은,여러페이지를 동시에 건드려야할때,중간에 컴퓨터가 뻗으면 위험해지는데,이걸 방지하기위해 쓰기전 로그를 미리 만들어두고 실행후 제거함
	  만약 db가 켜졌을떄 쓰기전로그가 남아있다면,그걸 확인하고 다시 작업하는식임
	  
	  또한 같은자리의 페이지를 갱신할때(다중스레드),동시에 접근할수있기때문에 이런경우 래치로 보통 보호함
	
	4.b트리와  lsm트리 비교
	  b트리와 lsm트리는,보통 b트리가 읽기에서 더 빠르고,lsm트리는 쓰기에서 더 빠름
	  또한 b트리가 구현성숙도가 더 높긴함(오래돼서)
	  물론 세부사항에 따라 속도도 다 다르긴함
	  
	  b트리색인은 모든 데이터조각을 최소한 두번 기록해야함(쓰기전로그와 트리페이지)
	  또한 해당 페이지내 몇바이트만 바뀌어도 전체페이지를 기록해야하는 오버헤드도 있음 
	  
	  로그구조화색인은 반복된 컴팩션과 병합으로 인해 여러번 데이터를 다시쓰는데,이걸 쓰기증폭이라고 부름
	  ssd에선 쓰기횟수가 제한되기때문에 특별한 관심사임
	  
	  쓰기가 많은 어플리케이션에서 성능병목은 db가 디스크에 쓰는속도일수있음,이떈 쓰기증폭이 성능비용임
	  더욱이 lsm트리는 b트리보다쓰기처리량을 높이기 쉬움(순차쓰기떄문),또한 압축률이 b트리보다 좋음
	  
	  b트리는 파편화가 좀 있음
	  
	  lsm트리의 단점은 컴팩션과정이 읽기쓰기 성능에 영향을 준다는것
	  또한 컴팩션 설정을 주의깊게 하지 않으면 컴팩션이 유입쓰기속도를 못따라가서 읽기속도도 느려질수있음,이를위해 모니터링이 필요함
	  
	  b트리의 장점은 각 키가 색인의 한곳에만 정확히 존재한다는점이고,lsm트리는 다른 세그먼트에 같은키의 다중 복사본이 존재할수 있다는거임
	  그래서 강력한 트랜잭션이 필요하면 b트리가 더 매력적임
	  
	5.기타색인구조
      프라이머리키 색인이 키값색인의 가장 대표적이 예고,세컨더리 색인도 효율적인 조인을 수행할떄 도움을 줌(외래키색인)
	  
	  그리고 해당 데이터양이 적을경우나,키같은경우엔 색인에 아예 데이터를 같이 저장하는경우도 있음(두번조회비용보다 그냥 두번적는게 싸다고 생각될떄)
	  이걸 클러스터드 색인이라고 함
	  
	  mysql의 경우 프라이머리키는 클러스터드색인이고,보조색인은 이 프라이머리키 색인을 참조함
	  
	  또한 다중칼럼에 대해 질의할때는, 다중칼럼색인을 써야하는데,이거의 가장 일반적인 유형은 결합색인임
	  이건 그냥 abc,123,456,qqq이런식으로 문자열로 단순히 결합하는식
	  이건 순서에 영향을 매우 많이받아서,앞에서부터 순서대로 쓸수있는 조회에 적합함
	  
	  다차원색인은 지리공간데이터에 중요한 색인인데,이건 공간채움곡선을 사용해서 단일숫자로 위치를 변환하거나,전문공간색인을 사용하는것
	  
	  또한 정확한 키가 아닌 유사한키를 검색할땐 전문검색용으로 n그램같은걸 사용할수있음
	  
	  지금까지의 모든건 디스크한계에 대한 해결책이었고,만약 단순캐시용도로만 사용할거라면 인메모리 db를 사용할수있음
	  
  2.트랜잭션 처리나 분석?	
    어플리케이션이 색인을 사용해 일부 키에대한 적은수의 레코드를찾고,
    레코드는 사용자입력을 기반으로 삽입되거나 갱신되는 패턴을 온라인트랜잭션처리(OLTP)라고 함
    
    근데 db를 데이터분석에도 사용하는데,이건 접근패턴이 매우 다름
    분석질의는 많은수의 레코드를 스캔해 레코드당 일부칼럼만 읽어 집계통계(카운트,합,평균등)를 계산해야함
    이걸 온라인 분석 처리(OLAP)라고 함
    
    이 두개를 한곳에서 처리해도 되지만,db가 커질수록 olap의 경우 db상태에 부담을 줌
    
    1.데이터 웨어하우징
      그래서 사용되는게 온라인디비의 읽기전용 복사본인 데이터웨어하우스임
	  데이터는 oltp 데이터베이스에서 주기적인 덤프나 갱신스트림을 통해 추출하고,
	  분석 친화적인 스키마로 변환하고 깨끗하게 정리한다음 데이터웨어하우스에 적재함
	  
	  db가 커질수록 사용하는게 좋고,작은데서는 굳이안써도됨
	  또한 색인도 oltp용이지 olap에서는 쓸데없음(어짜피 전체검색해야하니까)
	  
	  데이터웨어하우스와 관계형db 둘다 sql질의 인터페이스를 사용하지만,내부구현은 완전히 다름
	
    2.분석용 스키마:별모양 스키마
	  또한 트랜잭션처리에서의 데이터모델은 어플리케이션의 필요에따라 다양하게 사용되지만,
	  데이터 웨어하우스는 별모양스키마라는 방식으로 통일함
	  이건,중간에 팩트테이블을 둔 다음,각 칼럼의 값은 외부테이블의 외래키로 채우는것
	  즉 빡빡하게 정규화된 상태를 만듬(물론 그냥 값도 넣어도되긴함,총가격같은거)
	  
	  또한 팩트는 개별 이벤트를 담음,이래야 분석의 유연성이 극대화됨
	  이 팩트테이블의 각 로우는 이벤트를 나타내고,차원은 이벤트의 속성인,6하원칙,즉 누가 언제 어디서 무엇을 어떻게 왜 를 나타냄
	  
	  또한 날짜와 시간도 차원테이블을 사용해 표현함,이러면 공휴일같은 추가정보를 부호화할수있고,휴일과 평일의 판매차이등을 질의할수있음
  
	
  3.칼럼 지향 저장소
    팩트테이블은 칼럼이 보통 100개이상이지만,보통 질의는 한번에 4개 혹은 5개의 칼럼정도에만 접근함(select *을 하지않음)
    즉 많은수의 row에 접근하지만,적은수의 칼럼에 접근함
    
    이런 특성때문에,대부분의 oltp데이터베이스가 로우지향식으로 데이터를 배치하는거에 비해,
    칼럼지향식으로 칼럼의 모든 값을 나열한다음,순서가 동일하다는거에 의존해 서로 매칭시키는게 더 효율적이 되는경우가 있음
    그래서 나온게 칼럼지향저장소임
    1.칼럼압축
      또한 이러면 데이터압축이 편해짐(같은값이 반복해서 나타날 확률이 높아지므로),이때 압축하는방법으로 비트맵부호화등이 있음
  	  이건 n개의 고유값이 있는 칼럼을 가져와서,n개의 개별 비트맵(원핫인코딩같은식)을 만드는식
  
    2.칼럼 저장소의 순서 정렬
      칼럼저장소에서 로우가 저장되는 순서가 반드시 중요하진않음
  	  삽입된 순서로 저장하는방식이 가장 쉬움,새 로우를 삽입하는작업은 각 칼럼파일에 덧붙여 추가하는걸 의미하기때문
  	  하지만 순서를 도입해서 이를 색인으로 사용할땐,칼럼저장소는 순서에 의존하기때문에 각 칼럼파일별로 정렬할순없고,
  	  전체 테이블을 만든후 정렬한다음 다시 칼럼파일로 쪼개야함,물론 한번 한 다음에 삽입할땐,
  	  정렬키의 칼럼파일로 가서 위치찾은다음에 거기넣고,다른데도 같은순서에 넣으면됨 
  	
  	  이런식의 정렬은,키 한두개로 정렬할때 효과가 크고,이후로는 효과가 작음
  	  그래서 생각한게,같은데이터를 서로 다른 다양한 방식으로 정렬해서 저장한다면(각 쿼리별로),쿼리의 성능향상과 더불어 데이터보존효과도 얻을수있음
  
    3.칼럽지향 저장소에 쓰기
      칼럼지향저장소의 단점은,읽기가 빠르지만 쓰기가 느리다는것
  	  정렬된 테이블의 중간로우에 삽입을 원한다면 모든 칼럼파일을 재작성해야함
  	  그래서 lsm트리나,일단 쓰기를 모아둔다음 한번에 처리하는식으로 처리하는게 비용효율적임
	  
    4.집계:데이터큐브와 구체화 뷰
      데이터 웨어하우스는 매번 count,sum,avg등을 자주 사용하기때문에,매번 같은일을 하는거보단,
  	  데이터를 추가할때마다 계산해두고,그 캐시된값을 가져다쓰는게 효율적임
  	  이렇게 캐시를 만드는 방법이 구체화뷰임
  	  oltp에서는 비싸서 잘 못하지만,olap에서는 자주 사용됨
  	  
  	  이 구체화뷰의 특별사례중 데이터큐브라는게 있음
  	  이는 다양한 차원으로 그룹화한 집계테이블임
  	  즉 쓸만한거로는 다 집계해둔 테이블임,단점으로는 질의가 안된다는것(100달러이상 결제의 총합같은걸 미리 캐시해두긴 어려우니까,매번한다면 몰라도)
  
  4.정리
    저장소는 oltp와 olap로 나뉘고,둘은 데이터 처리방식이 다름	
	
4.부호화와 발전	
  어플리케이션은 필연적으로 시간이 지나면서 변하고,이때 저장하는 데이터도 같이 변화됨
  이때 rdb는 모든 데이터가 하나의 스키마를 따른다고 가정함(정확히는 현시점에 해당되는 스키마가 하나라는것)
  반면 읽기스키마 데이터베이스는 다른시점에 쓰여진 이전 데이터타입과 새 데이터타입이 섞여 포함될수있음 
  
  이렇게 데이터타입이나 스키마가 변경될떄,어플리케이션코드에 대한 변경이 종종 발생하지만 보통 대규모앱에서 코드변경은 즉시할수없고,롤링업데이트등으로 해결해야함
  즉 이말은 예전버전코드와 새버전코드,이전데이터타입과 새 데이터타입이 동시에 공존해야 할수 있다는말임
  그래서 시스템이 원활하게 유지되려면 양방향호환성이 유지되어야함(하위호환성,상위호환성)
  
  1.데이터부호화 형식
    프로그램은 두가지형태로 표현된 데이터를 사용해 동작함
	객체같은 cpu에서 효율적으로 접근할수있는 데이터와
	일련의 바이트열형태의 데이터 두가지가 있음
	이 두가지를 서로 변환하는걸 직렬화(부호화)와 역직렬화(복호화)라고 부름
	
	1.언어별 형식
	  언어별로 인메모리객체를 바이트열로 부호화하는 기능이 있긴한데,이건 다른언어에서는 호환되지않아서 잘 사용하지않음
	2.json과 xml,이진변형
	  그래서 json을 주로 사용함
	  물론 여기도 문제가 있긴함,json은 문자열과 수는 구분할수있지만,정수와 부동소숫점을 구별할수없고,정밀도를 지정하지않음
	  뭐 근데 이정도는 감당할만하니까(서로간에 합의만 되면되니)
	  
	  또한 조직내에서만 사용할거라면,json보다 더 크기가 작은걸 선택할수도있음
	  바이트팩이나 이런걸 사용할수있음
	
	3.스리프트와 프로토콜 버퍼
	  스리프트와 프로토콜 버퍼는 이진부호화 라이브러리임
	  이거 둘다 부호화할 데이터를 위한 스키마가 필요하고,이걸로 데이터팩을 만들수있음
	  보통 필드명을 생략하는걸로(필드명을 처음 헤더에만 내보내고,1번필드,2번필드 이런식으로 표기하는식) 이득을봄
	  
	  또한 필드타입과 태그숫자를 단일바이트로 줄이고,가변길이정수를 사용해서 부호화해서 더 데이터를 작게만듬
	  
	  스키마는 시간이 지나면서 변하는데,이걸 스키마발전이라고 부름
	  스리프트에서 필드의 추가는 새 태그번호를 부여하는식으로 대응하고,알지못하는 예전코드는 그걸 무시하고,예전데이터는 기본값을 가지도록하거나 옵셔널처리를 하면됨
	  필드를 삭제할땐 옵셔널만 삭제할수있고,required는 삭제할수없는식
	  
	  필드의 데이터타입을 변경하는건 가능하긴한데 값이 정확해지지않을 가능성이 생김
	
	4.아브로
	  아파치 아브로는 스리프트와 비슷한 이진부호화형식임
	  이것도 스키마를 사용하는데,차이는 얘는 스키마가 2개가 있음
	  사람이 편집하는용도의 아브로 idl과 기계가 읽기편한 json기반
	  
	  얘가 스키마발전을 할땐,쓰기스키마와 읽기스키마가 동일하지않아도,단지 호환만 되면 된다는거에서 아이디어가 나옴
	  읽기를 할때 쓰기와 읽기를 함께 살펴본다음,쓰기에서 읽기로 데이터를 변환해서 차이를 해소하는방식
	  그래서 쓰기스키마와 읽기스키마는 순서가 달라도 상관없고,읽기에는 없고 쓰기에만 있는 필드는 무시하고,
	  읽기에는 있는데 쓰기에는 없으면 읽기의 기본값으로 채움
	  
	5.스키마의 장점
	  스키마언어는 json스키마보다 더 간단하고 자세한 유효성검사규칙을 지원함
	  또한 많은 데이터시스템은 이진부호화를 독자적으로 구현해서 사용함(jdbc같은거)
	  그래서 json같은 텍스트타입 말고 스키마를 기반으로한 이진부호화도 가능한선택이긴함
	  주로 크기부분에서 이득이 있고,문서화하기도 편함(복호화할때 스키마가 필요해서 스키마가 최신상태인지 확인가능)

  2.데이터플로 모드
	데이터플로는 하나의 프로세스에서 다른 프로세스로 데이터를 전달하는것
	1.데이터베이스를 통한 데이터플로
	  데이터베이스에 기록하는 프로세스는 데이터를 부호화하고,데이터베이스에서 읽는 프로세스는 데이터를 복호화함
	  만약 단일 프로세스만 데이터베이스에 접근한다면,db에 저장하는건 미래의 자신에게 메시지를 보내는거처럼 생각할수있음
	  그러니 db에서 언제 읽을지 모르니까,하위호환성이 필요해지는거
	  
	  또한 db내 값이 새 버전으로 기록된다음,현재 수행중인 예전코드로 그 값을 읽을 가능성도 있음,그래서 상위호환성도 대개 필요함
	  어플리케이션이 db값을 모델객체로 복호화하고,이걸 다시 재부호화한다면 변환과정에서 알지못하는 필드가 유실될수있음
	  이걸 주의하긴해야함
	  
	  db는 언제나 값을 갱신할수있고,db속의 값은 5년전에 기록됐었을수도 있음
	  어플리케이션은 몇분안에 배포할수있지만,db속 내용은 그렇지않음
	  물론 마이그레이션을 통해 현재 어플리케이션에 맞게 바꿀수있지만,보통 마이그레이션비용은 비쌈
	  그래서 보통 db는 기존스키마에 추가로 null을 기본값으로 갖는 칼럼을 추가하는 스키마변경을 허용함
	  
	  백업목적이나 데이터 웨어하우스에 적재하기위해 수시로 db스냅샷을 만든다고 하면,이경우 데이터덤프는 최신스키마를 사용해 부호화됨
	
	2.서비스를 통한 데이터플로:REST,RPC
	  보통 네트워크를 통해 통신하는 프로세스들은 클라와 서버 두 역할로 배치하고,서버는 api를 공개하고 클라는 이걸로 요청을 만들어 서버에 연결함
	  이때 서버가 만든 api를 서비스라고 함
	  
	  여러가지면에서 서비스는 db와 유사하지만,차이점으로는 임의질의를 허용하지않음,이걸통해 캡슐화,즉 클라가 할수있는일과 할수없는일에 대한 제약을 걸수있음
	  
	  웹서비스를 통한 호출의 문제는,로컬함수호출은 예측이 가능하지만 네트워크요청은 예측이 어렵다는거
	  네트워크문제로 요청과 응답이 유실되거나,느려지거나,응답하지않을수 있고 이는 제어할수없음
	  그래서 네트워크문제를 함께 고려해야함(재시도라든가,타임아웃이라든가,멱등성처리라던가)
	
	3.메시지 전달 데이터플로
	  rest와 rpc가 하나의 프로세스가 네트워크로 다른 프로세스로 직접 요청을 전송하고 가능한 빠른 응답을 기대하는 방식이었고
	  db는 하나의 프로세스가 부호화한 데이터를 기록하고,다른프로세스가 언젠가 그 데이터를 다시 읽는 방식이었다면
	  
	  비동기 메시지 전달 시스템은,낮은 지연시간으로 다른 프로세스에 전달한다는건 서비스통신과 비슷하지만,
	  메시지 브로커라는 중간단계를 거쳐서 전송한다는건 db와 유사함
	  이거의 장점은
		수신자가 사용불가능하거나 과부하라면,브로커가 버퍼처럼 동작해서 시스템안정성이 향상됨
		죽었던 프로세스에 다시 메시지전달가능
		송신자가 수신자의 ip주소나 포트번호를 알필요가 없어서 수신자 추상화가능
	    하나의 메시지를 여러 수신자로 전송가능
		논리적으로 송신자와 수신자는 분리됨(생산자소비자패턴)
	  이 있음
	  
	  즉 가장 큰 특징은,송신과 수신이 비동기라는것
	  송신자는 던지고 신경끄고,수신자는 그냥 오면 처리하면됨
	  
	  메시지브로커는 보통 프로세스하나가 메시지를 이름이 지정된 큐나 토픽에 전송하고,
	  브로커는 해당 큐나 토픽을 구독하는 하나이상의 소비자나 구독자에게 메시지를 전달함
	  토픽은 단방향 데이터플로만 제공하지만,소비자 스스로 메시지를 다른토픽으로 게시할수있음
	  
	  메시지브로커는 특정 데이터모델을 강요하지않고,아무바이트열이나 쓸수있음
	  
	  주의점은 소비자가 다른 토픽으로 메시지를 재게시한다면,알지못하는 필드 보존에 대해 주의가 필요함(db에서 나온문제)
	  
	  액터모델은 단일프로세스안에서 동시성을 위한 프로그래밍 모델임
	  이건 스레드관련문제를 직접 처리하는대신 로직이 액터(클라나 엔티티를 나타냄)에 캡슐화됨
	  액터는 로컬상태를 가질수있고,비동기메시지 송수신으로 다른 액터와 통신함
	  액터는 메시지전달을 보장하지않고,각 액터 프로세스는 한번에 하나의 메시지만 처리해서 스레드관련문제를 신경쓸필요없음
	  
	  이 분산액터프레임워크에서 이런 액터모델은 여러 노드간 어플리케이션 확장에 사용됨
	  송신자와 수신자가 같은 노드에있는지를 신경쓸필요없어지고,메시지유실가능성을 가정하기때문에 위치투명성이 높음
	  
	  이 분산액터 프레임워크는 메시지브로커와 액터프로그래밍 모델을 단일프레임워크에 통합함
	  이때 롤링업데이트를 할때 상하위호환성에 여전히 주의해야함
	
5.복제
  복제란 네트워크로 연결된 여러 장비에 같은 데이터의 복사본을 유지하는것
  이걸하면
    지리적으로 사용자와 가깝게 데이터배치를 할수있어서 지연시간을 줄일수있음
	시스템의 일부에 장애가 발생해도 지속적으로 동작할수있어짐
	읽기질의용 장비의 수를 확장해 대역폭을 늘릴수있음
  이런 장점이 있음
  
  복제의 어려움은 복제된 데이터의 변경처리에 있고,이게 핵심임
  
  1.리더와 팔로워
    db의 복사본을 저장하는 각 노드를 복제서버라고함
	다중복제서버에서 모든 복제서버에 모든 데이터가 있다는 사실을 보장하는 방법중 가장 일반적인 해결책은 리더기반 복제임
	
	복제서버중 하나를 리더로 지정하고,쓰기는 거기를 통해서만 진행하는거(읽기는 레플리카도 가능)
	리더에 쓰기가 들어오면,데이터 변경을 복제로그나 변경스트림등으로 팔로워에 전송하고,
	각 팔로워가 리더로부터 로그를 받으면 리더가 처리한것과 동일한순서로 모든 쓰기를 적용해서 로컬복사본을 갱신함
	
	즉 클라는 모든 서버에 질의할수있지만,쓰기는 리더에만 허용되는것
	
	1.동기식 대 비동기식 복제
	  복제의 중요세부사항은 복제가 동기식으로 발생하는지 비동기식으로 발생하는지 여부임
	  
	  동기식은 쓰기가 들어오고 리더가 쓴 후에 리더가 팔로워들이 모두 갱신할때까지 동기식으로 기다리는것
	  즉 모든 팔로워가 성공을 해야 다음일로 진행할수있음
	  
	  비동기식은 그냥 던져놓고 알아서하겠지 하고 내할일 하는것
	  
	  동기의 장점은 리더와 일관성있게 최신 데이터 복사본을 가지는걸 보장해줌
	  단점이 근데 치명적인데,팔로워가 죽거나 네트워크문제등으로 응답이 오지않는다면,서버 전체가 뻗어버림(타임아웃날때까지)
	  
	  그래서 모든 팔로워가 동기식인건 비현실적이고,리더에 문제생기는상황을 대비해 한두개정도만 동기식으로 하고 나머지는 비동기식으로 쓰는걸 반동기식이라고 함
	  
	  보통 리더기반복제는 완전히 비동기식으로 구성함
	  이런경우 리더가 문제가 생기면 팔로워에 아직 복제되지않은 모든쓰기는 유실됨
	  즉 쓰기가 클라이언트에게 확인된 경우에도(쓰기성공이 들어왔어도) 지속성을 보장하지않는다는 의미임
	  대신 모든 팔로워가 잘못되더라도 리더가 쓰기처리를 계속할수있다는 장점이 있음
	  
	  이건 문제가 많아보이긴 하지만,팔로워가 많거나 지리적으로 분산됐다면 자주 사용하는 솔루션임
	
	2.새로운 팔로워 설정
	  팔로워를 늘릴떄 팔로워가 리더의 데이터복제본을 정확히 가지고있는지 보장하는건,
		일단 스냅샷으로 리더의 전체 데이터를 가져오고
		그걸 팔로워에 복사하고
		그사이에 벌어진 일에 대한(복제로그의 시간순서를 기반으로)데이터변경을 리더에 요청함
		이걸 전부 처리하고 리더와 백로그가 같아지면 따라잡았다고 하고 팔로워로 등록됨
	  이런순서로 진행됨
	 
	3.노드중단처리
	  유지보수등으로 인해 개별노드를 재부팅하거나해야해서 꺼야할때,고가용성을 유지하는건 여러방법이 있음
	  
	  각 팔로워가 리더로부터 수신한 데이터변경로그를 로컬디스크에 보관하고,팔로워가 죽거나 일시적으로 리더와연결이 끊긴다면,
	  마지막으로 저장된 트랜잭션 번호를 찾은뒤,리더와 다시 연결되고 그 이후로 처리된 모든걸 달라고하면됨
	  이걸 따라잡기복구라고 함(팔로워장애시 처리방법)
	  
	  리더가 장애가 생기면 좀 복잡한데,팔로워중 하나를 새 리더로 승격해야하고,
	  클라는 새 리더로 쓰기를 전송하기위해 재설정이 필요하고,
	  다른 팔로워는 새 리더로부터 데이터변경을 소비해야함,이걸 장애복구(페일오버)라고 함
	  
	  이건 수동으로 처리하고나 자동으로도 함
	  자동으로할떈
		리더가 장애인지 판단(헬스체크등으로)
		새 리더를 선택
		새 리더사용을 위해 시스템 재설정
	  이 순서를 거쳐야함
	  
	  이때 문제될게 많은데
	    비동기식복제를 사용한다면,새리더는 이전리더가 실패하기전의 일부 쓰기를 송신하지못할수있음,
		  이때 이전리더가 다시 클러스터에 추가되면 이전리더의 복제되지않은쓰기를 폐기해야하는데,이러면 내구성이 떨어짐
		쓰기를 폐기하는건 db외부의 다른 저장소시스템이 해당 db내용에 맞춰 조정돼야한다면 더 위험함(레디스같은데서 같은 키를 쓰는경우)
		특정 결함 시나리오에서 두 노드가 모두 자신이 리더라고 믿을경우 위험해짐
		리더가 죽었다고 판단가능한 타임아웃을 길게잡으면 복구에 시간이 오래걸리고,짧게잡으면 불필요한 장애복구가 있을수있음
	  이런 문제들이 많아서 수동으로하는걸 선호하기도함
	
	4.복제로그 구현
	  리더기반복제에서는 
	    구문기반복제(모든 쓰기쿼리를 복제,now()같은거떄문에 복제가 깨질수있음,그래서 저런값들을 자동으로 고정값으로 바꿔줘야함)
		쓰기전 로그 배송(모든쓰기가 로그에 저장되니,그 로그를 복사해주면됨,이거의 단점은 로그가 제일 저수준데이터라서 복제가 저장소엔진과 의존성이 높아짐,특히 버전등)
		로우기반복제(쓰기전 로그배송과 비슷하지만,저장소엔진과의 의존성을 추상화한 형태의 새로운 로그를 사용하는식,대충 로우단위로 로깅하고 그거 가져다가 그대로넣는느낌)
	  이렇게 3가지를 사용하는데,보통 로우기반복제를 사용함
	  
	  로우기반복제는 외부어플리케이션이 파싱하기도 쉽고,그래서 변경데이터캡처를 사용하기도 좋음
	  
	  이런형태의 접근말고(db에서만 처리),db를 다른종류의 db로 복제해야하거나 충돌해소로직이 필요하면,복제는 어플리케이션단에서 처리해야함
	  보통 이럴때는 트리거를 사용함(트리거 기반 복제)
	  
  2.복제 지연 문제
    복제는 내결함성때문에만 쓰는건 아니고,확장성과 지연시간떄문에 쓰기도함
	모든 쓰기는 리더를 거쳐야하지만,읽기는 어느레플리카에서나 할수있기때문
	즉 대부분이 읽기요청이고 쓰기가 아주 작은비율인(대부분의 웹패턴)에 적합함
	
	이런 읽기확장아키텍처는 간단히 팔로워를 추가하면 대역폭을 늘릴수있음,단 비동기식 복제여야함
	문제는 비동기팔로워에서 데이터를 읽을때,팔로워가 뒤쳐진다면 지난정보를 볼수도있음(시간떄문에)
	결국은 팔로워는 따라잡고 리더와 일치해지지만(최종적 일관성)
	 
	1.자신이 쓴 내용 읽기
	  대표적으로 문제가 생기는게 자신이 쓴 내용 읽기임
	  보통 쓰고나면 자기가 쓴걸 바로 보는경우가 많은데,쓰기는 리더에 쓰고 읽기는 팔로워에 하면,둘간의 시간차때문에 데이터가 표시되지않을수있음
	  이걸 쓰기 후 읽기 일관성 이라고 함
	  이건 사용자가 페이지를 재로딩했을때 항상 자신이 제출한 모든 갱신을 볼수있음을 보장하며,다른 사용자에 대해서는 보장하지않음
	  
	  이걸 구현할땐 여러방법이 있음
	    자신에 관한걸 읽을땐 리더에서 읽기
	    마지막 갱신시간이 1분이전이면 리더에서 읽고,아니면 팔로워에서읽기
	    클라에서 타임스탬프를 기억하고,팔로워가 그 타임스탬프 이전이면 갱신될때까지 계속 재요청하기
	  등이 있음
	
	   이때 마지막의 클라에서 처리하는건,여러 디바이스(모바일+pc)를 쓸때에는 또 적용안되니까 쓸수없어짐
	
	2.단조 읽기
	  또 다른 이상현상으로는 사용자가 각기 다른복제서버에서 여러읽기를 수행할때 시간이 역전되는 현상임
	  즉 처음읽은게 늦게 갱신되고,이후꺼가 빨리 갱신될경우 발생함
	  이럴경우 처음 읽었던게 두번째 읽을때는 사라지는등의 문제가 발생할수있음
	  
	  단조읽기는 이게 일어나지않음을 보장함,이걸위해서는 각 사용자의 읽기는 항상 동일한 서버에서 수행되게끔 하던가 하는식으로 할수있음
	  보통 사용자id를 해시해서 선택하거나  하는느낌
	
	3.일관된 순서로 읽기
	  또 다른 이상현상으로는 인과성의 위반이 있음
	  a와 b가 순서대로 말을했는데,a는 엄청 늦게 전달되고,b는 엄청 빨리 전달됐을경우엔 b가 먼저보이고 a가 보이는 상황이 있을수있음
	  
	  이건 샤딩된 db에서 발생하느 특징적인 문제임
	  db가 항상 같은순서로 쓰기를 적용하면,읽기는 항상 일관되기때문에 발생하지않지만,
	  보통 분산db는 서로 다른 파티션은 독립적으로 동작해서 쓰기의 전역순서가 없기때문에 발생함
	  
	  이거의 해결책으로는 서로 인과성있는 쓰기가 같은 파티션에 기록되게 하는 그런방법이 있음
	  
	4.복제 지연을 위한 해결책
	  최종적일관성으로 작업할때,복제지연이 있어도상관없다면 괜찮지만,있으면 안된다면 쓰기후읽기등 강한 보장을 제공하게 설계해야함
	  이럴땐 비동기식으로 동작하지만 동기식인척 하는게 해결방안임
	  그래서 사용되는게 트랜잭션임
	  
	  
  3.다중 리더 복제
	리더를 여러개 쓰는경우는,쓰기대역폭을 늘릴수있다는 장점이 있음
	근데 여러모로 복잡하기때문에 잘 사용되지않긴함,그리고 사용할때는 단일 데이터센터에서는 이점이 없기때문에 다중데이터센터를 운영할때 정도는 고려해볼수있음
	보통 이럴땐 각 데이터센터마다 클러스터를 만들고,자기끼리 복제하면서 리더끼리 들어온 쓰기를 복제해주는식으로 동작함
	
	이 다중 리더 복제의 큰 문제는,동일한 데이터를 다른 두개의 데이터센터에서 동시에 변경할경우에 발생하는 쓰기충돌임
	또한 설정상에서 실수를 하기쉬우니(자동증가키,트리거,무결성제약등),조심해야하고 가능하면 안쓰는게 낫지만,꼭 써야하는경우도 좀 있음
	
	이게 적절한 사례로는 오프라인작업을 하는 클라이언트(캘린더앱같은거)는 로컬 데이터베이스들이 항상 리더고,서버는 팔로워임
	근데 같은걸 여러군데서 수정하고,인터넷을 끊었다가 연결하면 뭘 우선으로 잡아서 덮어야할지 여기서 충돌이 나게됨 
	
	또한 협업편집(구글독스)에서도 한 사용자가 문서를 편집할때 변경내용을 즉시 로컬에 복제하고 같은 문서를 편집하는사람들에게 비동기로 던지는데,
	이때 편집충돌이 없음을 보장하려면 잠금을 얻어야함,근데 이러면 지연이 생기니 변경단위를 매우작게(단일키입력)해서 잠금을 피할수있음
	
	1.쓰기충돌 다루기
	  즉 가장 큰 문제는 쓰기충돌임,즉 충돌해소가 필요하다는것
	  
	  물론 이론적으로는 동기식으로 처리하면 충돌감지가 가능하지만,이러면 다중리더의 이점이 없어짐
	  가장 간단한방법은 충돌을 회피하는것(권장되는방법)
	  이건 특정 레코드의 모든 쓰기가 같은 리더를 거치게(해시등으로)하는방법임
	  이건 근데 한 데이터센터가 고장나서 다른데이터센터로 라우팅해야하거나,
	  사용자가 다른 데이터센터쪽으로 이동했을때 같으면 충돌회피가 실패해서,여기 대책도 있어야함
	  
	  또 다른방법으로는 특정 타임스탬프같은 필드를 추가하고,무조건 그거 우선으로 덮어씌우는방법도 있음,
	  이건 대중적이지만 유실위험이 있음,중간에 들어온값은 사라지니
	  
	  또 뭐 어플리케이션에 따라 알아서 만들수도 있고
	  
    2.다중리더 복제 토폴로지
	  다중리더의 연결구조는,
	    원형 토폴로지(각 리더는 받는거랑 주는거 하나씩만 알고있음)
		별모양 토폴로지(중간에 모든걸 알고있는애와만 주고받음)
		전체연결 토폴로지(모든 리더를 서로서로 알고있음)
	  이렇게 3개가 있음
	  가장 일반적인건 전체연결이고,mysql은 원형 토폴로지를 사용함
	  원형과 별모양의 단점은 중간에 하나뻗으면 네트워크전체가 뻗는다는것(원형이 좀 더 위험),즉 단일장애점이 생기고 이걸 대처해야함
	  전체연결의 단점은,일부 네트워크가 혼잡할경우,먼저 보낸 메시지보다 이후에 보낸 메시지가 추월해서 데이터무결성이 꼬일수있음
	  이건 버전벡터로 처리할수있긴함
	  
  4.리더없는 복제 
    아예 리더라는 개념없이 동작하는애들도 있음
	이거는 정족수개념으로 n개이상의 노드가 동의했을때 적용되는식으로 동작함,이걸 다이나모스타일 db라고 부름
	
	1.노드가 다운됐을때 db에 쓰기
	  리더가 없는 설정에서는 하나가 뻗었다고 장애복구가 필요하지않음,그냥 정족수를 넘겨서 성공하면 성공이고,못넘기면 실패임
	  또한 뻗었던애가 다시 복귀하면,오래된 데이터가 리턴될수있는데,그래서 읽기도 정족수만큼 던져서 그중 가장 최신값을 가져다가 씀
	  
	  이때 예전데이터가 있는애한테 클라가 너 예전데이터 있다고 알려주면,그때 다른노드들에게 값을 얻어다가 복구하거나,
	  백그라운드 프로세스를 따로 둬서 계속 감시하는식으로도 할수있음
	
	2.읽기와 쓰기를 위한 정족수
	  이때 정족수는 n개의 복제서버가 있을때 모든 쓰기는 w개의 노드에서 성공해야 쓰기가 확정되고,모든 읽기는 r개의 노드에 질의해야할때,
	  w+r>n이면 항상 최신값을 얻을수있을거로 기대할수있음
	  보통 n을 3이나 5로 잡고,w=r=(n+1)/2로 하는편
	  
	  이거의 또다른 장점은,예외처리를 빡시게 안해도 된다는것
	  어짜피 못보냈으면 문제생긴거고,왜생겼는지는 신경쓸필요없음(추상화)
	
	3.정족수 일관성의 한계
	  정족수 조건을 꼭 만족하지않아도 돌아가긴함,대신 오래된값을 읽을 확률이 더 높고,대신 낮은지연시간과 높은 가용성이 가능함
	  근데 w+r>n인경우에도 오래된값을 반환하는 엣지케이스가 있음
	    느슨한정족수
		두개의 쓰기가 동시발생
		쓰기와 읽기가 동시발생
		쓰기가 일부에선 성공했지만 일부에선 실패
	  등이 있음
	  
	  그래서 다이나모db는 최종적 일관성을 허용하는 사용사례에 맞게 최적화됐음
	  
	  운영관점에서 볼때 db가 최신값을 반환하는지 모니터링하는건 중요하고,오래된걸 던지더라도 원인을 조사할수있어야함
	  그래서 보통 리더에서 복제지연에 대한 지표를 노출해줌
	  근데 리더없는 복제시스템은 조금 어려움
	  
	4.느슨한 정족수와 암시된 핸드오프
      정족수를 빡빡하게 잡아두면 내결함성이 없음(정족수아래로 총노드갯수가 내려가면)	
	  이때 들어오는 모든 요청을 에러처리할지,일단 받고 저장할지에 따라,후자를 느슨한 정족수라고 부름
	  이때 장애상황이 해제되면 일시적으로 수용한 쓰기를 해당 홈노드로 전송함,이걸 암시된 핸드오프라고 부름
	  
	  이건 쓰기가용성을 높이는데 유용함
	  즉 이건 지속성에 대한 보장이고,암시된 핸드오프가 완료되기까지 리드했을때 해당데이터를 본다는 보장은 없음
	
	5.동시쓰기 감지
	  동시에 같은키에 값을 쓸때 문제는 네트워크지연등으로 이벤트가 다른노드에 다른순서로 도달할수있다는점
	  그래서 이걸 어플리케이션단에서 처리해야함
	  
	  가장 편한방법은 최종쓰기승리임,그냥 가장 타임스탬프기준 최신값으로 무조건 덮어쓰는것
	  또 다른방법으로는 쓰기작업에 고유키를 부여하는것
	  
	  두가지 작업이 동시에 수행됐는지 여부를 결정하는건,두 작업이 인과성이 있을때를 말함
	  서로간에 상관이 없다면 그냥 단순한 동시작업이라 상관없음
	  
	  이경우 처리하는건,해당 어플리케이션에 맞는 방법을 찾아야함(장바구니처럼)
	  
	  또한 다중복제본의 경우,모든 복제본의 버전번호를 붙이고(이걸 버전벡터라고 함),쓰기를 처리할때 이걸 증가시키고,이걸 추적하는식으로 할수있음
	
	
6.파티셔닝	
  데이터셋이 매우클때 데이터를 파티션으로 쪼개는걸 파티셔닝이라고 함,이건 샤딩이라고도 함
  파티션을 나눌때는 각 데이터단위는 하나의 파티션에 속하게됨
  
  이걸하는 주된 목적은 확장성임
  
  1.파티셔닝과 복제
    보통 복제와 파티셔닝은 함께 적용하게 되고,각 파티션의 복사본을 여러 노드에 저장하는식으로 하게됨
	각 레코드는 정확히 한 파티션에 속하더라도,여러 다른 노드에 저장해서 내결함성을 보장하는식
	
	한노드에 여러 파티션을 저장할수도 있음
	그래서 어떤 노드는 어떤파티션에서는 리더,어떤파티션에서는 팔로워인 이런 형태도 가능함

  2.키-값 데이터 파티셔닝
    1.키범위 기준 파티셔닝
      파티셔닝의 목적은 데이터와 질의부하를 노드사이에 고르게 분산시키는것
	  이때 파티셔닝이 고르게 이뤄지지않아 다른 파티션보다 데이터가 많거나 질의를 많이받는 파티션이 있다면 쏠렸다고 말함
	  이러면 파티셔닝의 효과가 매우 떨어짐
	  이렇게 불균형하게 부하가 높은 파티션을 핫스팟이라고 함
	  
	  이걸 회피하는 방법중,단순레코드 랜덤배치는 인덱스를 타기 어렵기때문에 사용하지않음
	  그래서 사용되는게 키-값 데이터 파티셔닝임
	  
	  이건 키를 가지고 연속된 범위를 파티션으로 자르는것
	  이때 범위가 반드시 동일할필요는 없고,데이터크기나 요청등을 기준으로 자르면됨
	  
	  또한 각 파티션내에서는 키를 정렬된 순서로 저장하고,이러면 범위스캔이 쉬워짐
	  문제는 이건 특정 접근패턴이 핫스팟을 유발할수있음(특히 날짜의경우)
	  그래서 키의 첫번째요소로 날짜가 아닌 다른걸 사용하는게 좋음(id같은거)
	  
	2.키의 해시값기준 파티셔닝
	  쏠림과 핫스팟의 위험때문에 보통 분산데이터스토어는 키의 파티션을 정할때 해시함수를 사용함
	  좋은 해시함수는 쏠린데이터를 입력으로 받아서 균일하게 분산되게함
	  이건 암호학적으로 강력할필요없고,단순 분산만 잘시켜주면됨,또한 어떤 언어의 해시함수는 이거에 적합하지않음(프로세스마다 다른 해시값을 줄수있음)
	  
	  이걸 일관성해싱이라고함
	  문제는 이경우에도 범위질의로 인덱스를 타는게 불가능해진다는것
	  그래서 타협하는건,복합기본키로 키의 첫부분에만 해싱을 적용하고,남은칼럼을 인덱스로 사용하는 방법이 있음
	  즉 이경우엔,첫칼럼에 고정값을 지정하면,나머지칼럼에는 범위스캔을 할수있어짐
	
	3.쏠린 작업부하와 핫스팟 완화
	  이렇게 해도 핫스팟을 완전히 없앨순없음(같은키를 읽고쓰는 상황같은)
	  보통 sns에서 유명인이 글쓸때같은걸 생각하면됨
	  이런건 어쩔수없이 어플리케이션에서 처리해야함
  
  2.파티셔닝과 보조색인
    인덱스가 연관되면 상황이 복잡해짐,그래서 사용되는게 문서기반 파티셔닝과 용어기반 파티셔닝임
    1.문서 기준 보조 색인 파티셔닝
	  이건 인덱스를 각 파티션마다 각 칼럼에 해당하는 모든 위치를 적어두는방식임
	  즉 어떤 문서에 이파티션에서는 어디서 a가 나왔다고 다 적어두는식
	  
	  이건 주의점이 읽을때 모든 파티션에 쿼리를 날려서 모든 값을 얻어서 합쳐야함
      이걸 스캐터/개더라고 부름
	  이건 당연히 비싸고,꼬리지연시간증폭이 나타나기쉬움
	
	2.용어기준 보조색인 파티셔닝
	  모든 파티션의 데이터를 담당하는 전역색인을 만들수도있음
	  이게 용어기준 파티셔닝임
	  즉 특정 단어가 어디에 나왔는지를 하나의 문서에 모아두는것
	  이걸쓰면 스케터개더를 쓸필요없이,id로 해당 값을 다 읽어오면됨
	  
	  이건 읽기가 효율적이라는 장점이 있지만,쓰기가 느리고 복잡함(단일문서를 쓸때 해당색인의 여러 파티션에 영향을 줄수있어서)
	  또한 색인은 비동기로 갱신되고,분산트랜잭션을 적용하지않으면 색인쓰기실패시가 복잡해짐
  
  3.파티션 재균형화
    시간이 지나면 db에 데이터들이 추가되면서 파티션을 더 쪼개고싶거나 할수있음
	이때 클러스터에서 한노드가 담당하던 부하를 다른 노드로 옮기는 과정을 재균형화라고 함
	
	이 재균형화가 보통 만족시킬거로 기대되는 최소요구사항은
	  재균형화 후 부하가 노드들사이에 균등하게 분배되어야함
	  재균형화 도중에도 db는 읽기쓰기요청을 받을수있어야함
	  재균형화가 빨리 실행되고 네트워크와 디스크io를 최소화할수있게 데이터가 필요이상으로 옮겨지면안됨
	이렇게 있음
	
	1.재균형화 전략
	  이 재균형화 전략은 여러방법이 있는데,가장 간단하지만 쓰면안되는 방법은 해시값에 모드연산임
	  이건 처음 생각해보면 괜찮아보이지만,노드갯수가 바뀌면 대부분의 키가 노드사이에 옮겨져야한다는 최악의 단점이 있어서 사용되지않음
	  
	  그래서 사용되는건 파티션을 노드대수보다 많이만들고,각 노드에 여러 파티션을 두는식임
	  그래서 노드가 추가되면 기존노드에서 파티션을 골고루 들고오고,나가면 다른노드들에게 주고가면됨
	  즉 파티션단위로 통째로 이동시키는방식임
	  
	  보통 이렇게할때는 파티션개수가 고정되고 이후에 변하지않음,그래서 파티션은 충분히 큰 값으로 선택해야함
	  
	  그래서 사용되는게 동적파티셔닝임
	  이건 파티션 크기가 설정된값을 넘어서면,파티션을 두개로 쪼개고,파티션데이터가 일정이하로 떨어지면 파티션을 합침
	  이거도 각 노드는 여러 파티션을 담당함
	  동적파티셔닝의 장점은 파티션갯수가 전체데이터용량에 맞춰 조정된다는점이고,단점은 데이터가 작을때는 단일노드로 돌릴수밖에없다는것
	  
	  또 다른 방법으로는 노드비례 파티셔닝이 있음
	  이건 노드당 할당되는 파티션갯수를 고정함
	
	2.운영:자동재균형화와 수동재균형화
	  재균형화는 자동으로할수도있고 수동으로 할수도 있음
	  자동으로 하면 편하지만,바빠죽겠는데 리밸런싱할 임계값이라고 돌려버리면 과부하가 터지는 문제가 있음
	  즉,노드하나가 죽었을때 안그래도 네트워크 부하 심해졌는데,거기다 노드갯수바뀌었다고 리밸런싱을 하는등의 문제임
	  
	  그래서 수동으로 보통 하는데,이건 귀찮고 알아보기 힘드니까,리밸런싱할때라고 알림 알려주는거까지만 해주는경우가 많음

  4.요청 라우팅
    이렇게 데이터베이스를 여러개로 쪼개고 나면 드는 의문은,어떤 데이터베이스로 찾아가야하지?임
	각 로우는 한군데서만 있고,그걸 찾아가는 방법이 필요함
	이런문제가 서비스찾기 문제임(k8s서비스같은 로드밸런서가 필요한문제)
	
	보통 별도의 코디네이션 서비스를 사용하거나(주키퍼),모든 db가 해당 쿼리의 위치를 알게하거나(카산드라) 같은 방법을 사용함
	
	
7.트랜잭션	
  트랜잭션은 내부의 모든연산을 전부 성공시키거나 전부 실패시키는 메커니즘임
  그런데 속도때문에 직렬화를 사용해서(서로 완전히 분리되게) 할수는 없기때문에 생기는 문제들이 있음
  1.애매모호한 트랜잭션의 개념
    1.acid의 의미
	  트랜잭션은 원자성,일관성,격리성,지속성을 지원한다고 알려져있지만,db마다 acid의 구현은 제각각임
	  특히 격리성이 좀 모호함
	  
	  원자성은 단순히 트랜잭션내부에서 모든 쓰기가 일부만 처리되지않는다는걸 보장함
	  이건 거의 모든곳에서 필수적으로 지원함
	  
	  일관성은 데이터에 관한 어떤 선언(유니크스키마 같은거),즉 불변식이 있다는것
	  이건 근데,db에서도 약간 지원하긴하지만,거의 대부분은 어플리케이션의 책임임
	  그래서 사실 c는 acid에 속하지않음
	  
	  격리성은 여러 클라이언트에서 db에 같은 부분을(다른부분은 상관없음,이건 단순한 동시작업)읽고쓸때 생기는 동시성문제가 서로에게 영향을 주지 못한다는것
	  이걸 완벽하게 지키려면 직렬화를 켜야하지만,성능하락이 너무커서 보통 약간의 모호한부분을 감수하고 사용함
	  이게 acid에서 가장 애매한부분임(이 타협이)
	  
	  지속성은,트랜잭션이 성공했다고 말했으면 그게 db에 남아있어야한다는것
	
	2.단일객체연산과 다중객체연산
	  즉 acid에서 원자성과 격리성은 클라가 한 트랜잭션내에서 여러번의 쓰기를 하면 db가 어떻게 해야하는지를 말함
	  원자성은 쓰기중 오류가 발생하면 트랜잭션은 어보트되고,지금까지했던걸 다 날려야한다는거고
	  격리성은 동시에 실행되는 트랜잭션은 서로를 방해하지말아야한다는것(즉 한트랜잭션이 여러번 쓴다면 다른트랜잭션은 전부보거나 아예못보거나 둘중하나여야한다는것)
	  
	  근데 다중객체 트랜잭션에서는 어떤 읽기연산과 쓰기연산이 동일한 트랜잭션에 속하는지 알아낼 방법이 있어야함(보통 관계형에선 커넥션으로 체크함)
	  근데 보통 비관계형에선 이런게 없는경우가 많음,그래서 어떤키에 대한 연산만 성공하고,일부는 실패하는식으로 부분만 갱신될수있음
	  
	  트랜잭션의 핵심기능은 오류가 생기면 어보트되고 안전하게 재시도할수 있다는것
	  즉 오류복구의 책임은 어플리케이션에 있음
	  단순한 재시도만 해도 훨씬 나아질수있음(물론 과부하때문일수도 있으니 지수적백오프를 사용할수있음)
	  물론 일시적인 오류에서만 해야함
  2.완화된 격리 수준
    두 트랜잭션이 같은 데이터에 접근하지않으면 서로 의존하지않으므로 안전하게 병렬실행될수있음
	동시성문제는 트랜잭션이 다른 트랜잭션에서 동시에 변경한 데이터를 읽거나 쓸때만 발생함
	
	이런 동시성문제는 재현이 어렵고 추론도 어려움,그래서 사용되는게 트랜잭션인데,이것도 모든 이슈를 막아주지는 못함
	
	1.커밋 후 읽기
	  가장 기본적인 수준의 트랜잭션격리는 리드커밋임
	  이건 두가지를 보장해줌
	    db에서 읽을땐 커밋된 데이터만 보게됨(더티리드가 없음)
		db에 쓸땐 커밋된 데이터만 덮어쓰게됨(더티라이트가 없음)
	  더티리드는 커밋되지않은 데이터를 볼수있는건데,이건 진짜 있으면 머리아프니 최소한 리드커밋은 해야함
	  또한 더티라이트는 같은객체를 동시에 갱신할때의 경쟁조건(두개이상의 테이블의 로우를 같이건드려야할떄)를 막을수있음
	  
	  이건 구현할때 db는 로우수준잠금으로 구현하는게 가장 흔함(특정객체를 변경하고싶으면 해당객체에 대한 잠금을 우선 획득하는식)
	  또한 트랜잭션이 커밋되거나 어보트될때까지 그 잠금은 안푸는식임
	  또한 커밋되기전까지는 이전값과 변경된값을 모두 기억하고있다가,읽기요청이 들어오면 이전값을 주고,커밋되면 덮어쓰는식으로 동작시킴
	
	2.스냅숏 격리와 반복읽기
	  반복읽기(리피터블 리드)는,트랜잭션 중간에 값이 바뀌는걸 막아줌(논 리피터블 리드)
	  
	  논 리피터블 리드를 해결하는 가장 흔한 해결책이 스냅숏격리임
	  각 트랜잭션은 db의 일관된 스냅숏으로부터만 읽음(그때 블로그에 썼던거 맞음)
	  즉 트랜잭션은 시작할때 db에 커밋된 상태였던 모든데이터를 보고,다른 트랜잭션에 의해 바뀌더라도 각 트랜잭션은 특정한 시점의 과거데이터를 볼뿐임
	  
	  스냅숏격리의 구현의 핵심은,읽는쪽에선 쓰는쪽을 절대 차단하지않고,쓰는쪽에서는 읽는쪽을 절대 차단하지않는다는것
	  즉 두 작업간의 잠금경쟁을 없애야한다는것
	  이거의 발전된 형태가 다중버전 동시성제어(mvcc)임
	  
	  이 스냅숏격리는 각 트랜잭션을 시작할때 그 시점에 진행중인 모든 트랜잭션목록을 만들고,이트랜잭션들이 쓴 데이터는 모두 무시하는형태로(커밋되더라도) 동작함
	  또한 트랜잭션id가 자기보다 큰 트랜잭션이 쓴 데이터는 커밋여부와 관계없이 전부 무시됨
	  
	  이때 인덱스는,각 db마다 구현이 다름
	
	3.갱신 손실 방지
	  리드커밋과 스냅숏격리는 주로 동시에 쓰기작업이 일어날때 읽기가 뭘볼수있는지에 관한거였다면,
	  두 쓰기에서의 충돌문제는 갱신손실문제임
	  
	  이걸 해결하기위해 나타난건 원자적갱신(객체에 대해 독점적인 잠금유지)과,명시적인 잠금(for update)이 일반적이고
	  이것들은둘다 읽고,변경하고,쓰고 주기가 순차적으로 되는걸 강제함
	  
	  db에 따라서는 갱신손실 자동방지하는방식을 사용할수있음
	  이건 병렬실행을 허용하고,충돌나면 어보트시키고 다시하게하는것
	  
	  Compare-and-set(충돌나면 어보트)는 트랜잭션을 제공하지않는 db에서 제공하는경우가 있음
	  이건 값을 마지막으로 읽은후에 그값과 같을때만 쓰기를 허용하는식임,다르면 실패임
	  
	  
	  근데복제가 적용된 db에서는 갱신손실을 막는건 좀 어려워짐(특히 리더없는복제나 다중리더)
	  이떄는 잠금과 Compare-and-set는 사용하기힘듬
	  그래서 보통 여러 충돌버전을 허용하고,나중에 코드에서 이 충돌을 해소하는방식을 사용할수있음
	  
	  뭐 그냥 최종쓰기승리(lww)를 사용할수도 있긴함,근데 이건 갱신손실이 발생하기쉽다는건 알아둬야함
	
	4.쓰기스큐와 팬텀
	  쓰기스큐는 if문을 통과했는데 다른 트랜잭션이 값을 바꿔서 쓰기가 동작하면 안되는데(if로 걸러졌어야하는데)동작하는거임
	  이걸 막기위해 사용할수있는게 비관적락(for update)임
	  즉 읽고나서 다른애가 쓰는걸 막아버리면됨(물론 mysql처럼 넥스트키락도 같이있어야 인서트도 막을수있음)
	  
  3.직렬성
    직렬성은 가장 강력한 격리수준이지만,트랜잭션을 말그대로 순차실행하기때문에 매우 성능이 나쁨(이것도 캐바캐긴함,레디스같이 메모리에 다올려도되면 ㄱㅊ)
    그래서 해결법으로,아예 트랜잭션하고 뭘할지에 대한 코드를 다 제출하고 db에서 돌리는 스토어드 프로시저를 사용하기도함(애초에 직렬성을 잘 안쓰긴함)
    
    또한 분산db를 하기 매우힘들어짐(매우느려짐)
    
    그래서 나온게 직렬성 스냅숏 격리임
    이건 낙관적 동시성 제어 기법으로,
    mvcc를 기준으로 질의결과가 바뀌었는지 확인하고,
    과거의 읽기에 영향을 미치는 쓰기를 감지하는식으로 동작함
	
8.분산시스템의 골칫거리
  어떤문제든 잘못될가능성이 있다면 분산시스템은 잘못된다고 가정해야함
  결국 우리의 목표는 모든게 잘못되더라도 제역할을 해내는 시스템을 구축하는것
  1.결함과 부분장애
    한컴퓨터 내에서의 프로그램은 예측가능한,즉 동작하거나 동작하지않거나 둘중 하나로 동작하게됨
	즉 결정적으로 동작함(아예 실패하거나,성공하거나)
	
	문제는 네트워크에서는 상황이 근본적으로 다름
	분산시스템에서는 시스템의 일부는 잘 동작하지만 일부는 예측할수없는 방식으로 고장나곤함
	이를 부분장애 라고 함
	부분장애는 비결정적이라서 예측이 어렵고,심지어 성공했는지 실패했는지 조차 알수 없을때도있음(네트워크지연시간등)
	
	큰규모의 시스템은 항상 어느부분은 고장나있다고 생각하고 만들어야함
	즉 신뢰성없는 구성요소를 사용해서 신뢰성있는 시스템을 구축해야함

  2.신뢰성 없는 네트워크
    분산시스템은 비공유시스템,즉 네트워크로 연결된 다수의 장비임
	네트워크는 이 장비들이 통신하는 유일한 수단이고,각 장비는 자신만의 메모리와 디스크를 갖고있으며,다른장비의 메모리나 디스크에 직접접근할수없음
	
	보통 인터넷과 데이터센터내부 거의 대부분 이더넷으로 동작하고,이런 네트워크에선 다른 노드로 메시지를 보낼수있지만,
	이 메시지가 언제 도착할지,도착하긴할지는 보장하지않음
	이때도 경우의수가 많은데
	  요청유실
	  요청이 큐에서 대기하다 나중에 전송(송신자쪽문제)
	  원격노드의 장애
	  원격노드의 과부하나 가비지컬렉션 휴지
	  원격노드가 정상처리했지만 응답유실
	  원격노드가 정상처리했지만 응답이 지연
	등등 매우 많은 종류의 경우의수가있음
	
	즉 전송측은 패킷이 전송됐는지조차 알수없고,수신측이 응답메시지를 보내는것도 손실될수있음
	즉 얻을수있는 유일한 정보는 응답을 아직 받지 못했다는것
	이런 문제를 다루는 가장 흔한방법은 타임아웃이지만,이것도 같은요청이 2번이상 처리될수있다는 문제가 있음
	
	분산시스템의 소프트웨어는,결항미 일어날수 있다고 가정하고,이걸 감안하고 오류처리가 반드시 들어있어야함
	물론 결함을 반드시 견뎌내야하는건 아니고,평상시엔 믿을만하다면 그냥 문제가 생기면 오류메시지를 보여주는것도 방법임
	그러나 소프트웨어가 문제에 어떻게 반응하는지는 알아야하고,이걸 복구할수는 있어야함
	
	1.결함감지
	  시스템은 결함있는 노드를 자동으로 감지해서
	    로드밸런서는 그 노드로 요청을 보내지않아야하고
	    단일리더복제에서 리더장애가 나면 즉시 팔로워를 리더로 승격시켜야함
	  문제는 네트워크에 관한 불확실성때문에 노드가 동작중인지 아닌지 구별하기 어렵다는거
	  
	  거기다 헬스체크를 한다고 하더라도,헬스체크를 마치고 즉시 죽을수도있음(그래서 어플리케이션이 긍정응답을 주기전까진 믿을수없음)
	  그래서 문제가 생기면 몇번 재시도를 해보고,타임아웃이 만료되기를 기다렸다가 타임아웃내에 응답을 받지 못하면 노드가 죽었다고 선언할수있음
	
	2.타임아웃과 기약없는 지연
	  타임아웃만이 결함을 감지하는 유일한 수단이라면,타임아웃의 길이가 중요해짐
	  타임아웃이 너무 길면,노드가 죽었다고 선언되기까지 기간이 길어지고,그사이에 사용자들이 오류를 볼 확률이 올라감
	  타임아웃이 너무 짧으면,결함은 빨리 발견하지만,노드가 일시적으로 느려졌을뿐인데도 죽었다고 잘못 선언할 확률이 올라감
	  
	  너무 짧을때가 문제인데,보통 일시적으로 느려졌다는건 부하가 컸다는거고,그러면 네트워크전체의 부하가 커졌을때 저걸 죽여버리면 다같이 죽는다는것임
	  또한 이미 실행중이던 동작이 두번실행될수도 있고
	  
	  그래서 차라리 좀 길게잡는게 더 합리적임
	  
	  컴퓨터 네트워크에서 패킷지연의 변동성은 대부분 큐대기때문일경우가 많음(스위치큐)
	  특히 사용률이 높은 네트워크에서 잘 일어나는데,이런환경에서는 실험적으로 타임아웃을 선택하는수밖에 없음
	  더 좋은 방법은 고정된 타임아웃대신,시스템이 지속적으로 응답시간과 변동성을 측정하고,그 분포에 맞춰서 타임아웃을 자동으로 조절하게하는것
	  이때 파이증가 장애감지기를 쓸수있음
	
  3.신뢰성없는 시계
    시계와 시간은 중요하지만,분산시스템에서는 각 컴퓨터마다 시계가있고,이게 서로 안맞는다고 생각해야함
	특히 서로간에 메시지로 통신하기때문에 생기는 오차와,시계자체의 오차도 있음
	
	1.단조시계와 일기준시계
	  일기준시계는 직관적으로 시계에 기대하는일을 함(보통 1970년 1월1일 이후로 흐른 초를 리턴)
	  이건 보통 ntp로 동기화되는데,문제는 로컬시계가 ntp서버보다 너무 앞서면 강제로 리셋된다는점
	  이런뜀은 윤초를 종종 무시한다는 사실과 더불어 일기준시간이 경과시간을 측정하는데 적합하지않게만듬
	  
	  단조시계는 타임아웃이나 서비스응답시간같은 지속시간을 재는데 적합함
	  이건 두 이벤트 사이에 흐른 시간을 알수있음(절대시간은 알수없음)
	  단,여러cpu가 있으면 각 cpu마다 독립된 타이머가 있을수도있고,그래서 값이 틀릴수있음
	  그래도 분산시스템에서 경과시간을 잴떈 단조시계를 쓰는건 일반적으로 괜찮음
	  동기화를 안해도되고,측정이 약간 틀려도 괜찮기때문
	
	2.시계동기화와 정확도
      일기준시계는 다른 외부서버출처에 맞게 설정되어야 유용함
	  그래서 기대만큼 신뢰성이 있거나 정확하지않음
	
	3.동기화된 시계에 의존하기
	  시계는 간단하고 사용하기쉬워보이지만,하루가 86400초가 아닐수도있고,일기준시계가 거꾸로갈수도있고,노드의 시간이 다른 노드와 차이가 많이날수도있음
	  견고한 소프트웨어는 잘못된 시계에 대비할필요가 있음
	  
	  문제는 시계가 잘못됐다는걸 눈치채기 어렵다는점임(즉 극적인 고장보단 조용한 데이터손실)
	  그래서 동기화된 시계가 필요한 소프트웨어라면,필수적으로 모든 장비 사이의 시계차이를 모니터링하고,너무차이나는애는 죽여야함
	  
	  또한 여러노드에 걸친 이벤트같은경우,시계에 의존하지않는게 좋음
	  최종쓰기승리같은거도,각 노드별 시간이 다르다면,실제로 최종이 아닌데 최종취급을 받을수있기때문
	  그래서 사용되는게 논리적시계임,이건 증가하는 카운트를 기반으로하고,이벤트순서화의 안전한 대안임
	  이건 이벤트의 상대적인 순서(한 이벤트가 다른이벤트의 앞이나 뒤에 일어났는지)만 측정함
	  
	  시계는 정밀하지않고,그냥 일정범위로 생각하는게 맞음
	
	4.프로세스 중단
	  프로세스가 중간에 잠시 중단되어(gc같은거로),요청을 해야하는데 늦게했다면,특히 스탑 더 월드같은거때문이라면 프로세스에선 이걸 알수없음
	  
	  그래서 gc중단을 노드가 잠시 계획적으로 중단하는걸로 간주하고,이때 클라로부터 요청을 다른노드들이 처리하게 하는식으로 처리하는방법도 있음
	
  4.지식,진실,그리고 거짓말
    네트워크에 있는 노드는 어떤것도 확실히 알지못하고,받은 메시지를 기반으로 추측할수있을뿐임
	하지만 분산시스템에서 우리는 동작에 해단 가정을 명시하고,이걸 만족시키는방식으로 시스템을 설계할수있음
	그러나 신뢰성없는 시스템모델에서 잘 동작하는 소프트웨어를 만드는게 가능하더라도,간단하진않음
	
    1.진실은 다수결로 결정된다
	  만약 노드가 자신에게 보내지는 메시지는 받을수있지만,메시지를 보낼땐 유실되거나 지연된다면,다른노드는 응답을 받을수없고 시간이 지나면 노드가 죽었다고 선언됨
	  또한 스탑더월드 gc로 인한 중단으로 인해,해당시간동안 아무요청도 처리되지못하고 아무응답도 전송되지않으면 다른노드는 죽었다고 판단하지만,
	  좀있다가 살아날수도있음
	  
	  즉 이말들은 노드가 상황에따른 자신의 판단을 반드시 믿을수있는건 아니라는것
	  분산시스템은 한 노드에 의존할수는없고,노드는 언제든 장애가 나서 잠재적으로 시스템이 멈추고 복구할수없게될수있음
	  그래서 사용하는게 정족수,즉 노드들사이에 투표에 의존함
	  
	  어떤 결정을 할땐 여러 노드로부터 어떤 최소갯수에 투표를 받아야함
	  여긴 노드가 죽었다고 선언하는것도 포함됨(그래서 어떤애들은 살아있다고 생각하지만,정족수넘기면 죽은걸로 취급됨)
	  
	  보통 정족수는 과반수를 삼는게 제일 흔함(시스템에서 과반수는 하나만 존재할수있기때문)
	  1.리더와 잠금
	    시스템이 오직 하나의 뭔가만 필요할때(단일리더쓰기등),분산시스템에서 이걸 구현할땐 주의해야함
		노드 자신이 리더라고 믿더라도,노드의 정족수도 반드시 동의하진않음(대표적으로 gc등)
		
		노드의 과반수가 어떤 노드가 죽었다고 선언해도,그 노드가 선택된것처럼 행동한다면,신중하지못한 시스템에선 문제가 될수있음(스플릿브레인)
	  2.펜싱 토큰
	    그래서 사용되는게 펜싱토큰임
		이건 잠금이나 임차권을 쓸때,자신을 선택된자라고 잘못믿고있는 노드가 나머지 시스템을 방해하지않게하기위해,
		오토인크리즈되는 토큰을 만들고,이 토큰을 기준으로 예전에 처리했던 토큰보다 이전토큰이 들어오면(죽었다살아난) 거부하는식임
	
	2.비잔틴 결함
	  펜싱토큰은 부주의에 의한 오류를 감지하고 차단할수없음
	  즉 노드들이 신뢰성은 없지만 정직하다고 가정하는것
	  
	  근데 만약 노드들이 거짓말할수도 있다면 훨씬 어려워짐,이걸 비잔틴결함(받지않는걸 받았다고 하는등의 결함)이라고 함
	  그래서 일부노드가 오작동하고,프로토콜을 준수하지않거나 악의적인 공격자가 네트워크를 방해해도 시스템이 올바로 동작한다면,비잔틴 내결함성을 가진 시스템임
	  이건 항공우주나 은행등에서 유의미함
	  
	  단 보통상황에서는 이거까진 하지않고,단순히 서버에서 입력확인,sql인젝션감지등 정도로만 함
	  비잔틴 내결함성은 분산시스템에서의 신뢰도고,저런 입력확인등은 어플리케이션에서의 신뢰도니까
	  그리고 단순히 어플리케이션에서의 신뢰도는,비잔틴결함에 도움이 되지않음(전부 똑같은 프로그램이기때문)
	  
	  1.약한형태의 거짓말
	    노드들이 일반적으로는 정직하지만,
		약한형태의 거짓말(하드웨어문제,소프트웨어버그,잘못된설정으로 인한 유효하지않은 메시지등)으로 부터 보호해주는 메커니즘을 추가하는건 가치있을수있음
		이건 완강한 적(해커등)에게는 대항할수없어서 완전한 비잔틴내결함성을 가지진못하지만,더 나은 신뢰성으로 향하는 간단하고 실용적인 발걸음임
	
	3.시스템 모델과 현실
	  알고리즘은 하드웨어와 소프트웨어설정의 세부사항에 심하게 의존하면안됨
	  그러려면 예상되는 결함의 종류들이 추상화되어야함
	  이때 알고리즘이 예상하는걸 추상화한게 시스템모델임
	  
	  타이밍가정에 의해서는
	    동기식모델:네트워크,프로세스중단,시계오차에 전부 제한이 있다고 가정하고,전부 동기식으로 처리,현실적으로 사용할수 없음
		부분동기식 모델:대부분은 동기식으로 동작하지만,때떄로 지연,중단,시계드리프트의 한계치를 초과함,현실적인모델
		비동기식 모델:알고리즘이 타이밍에 대한 어떤 가정도 할수없는모델,매우 제한적으로 사용됨(알고리즘의 한계)
	  가 있고,노드장애도 고려해야함
	    죽으면 중단하는 결함:죽으면 노드제거,다시돌아오지않음
		죽으면 복구하는 결함:노드가 죽을수있지만,시간이 지나면 다시 응답을 받음(즉 메모리는 날아가지만 db는 남아있을걸로 기대)
		비잔틴결함:노드는 다른 노드를 속이거나 기만하는등 모든일을 할수있음
	  보통 부분동기에 죽으면 복구하는게 가장 일반적인 모델임
	  
	  1.알고리즘의 정확성
	    알고리즘이 정확하다는게 어떤 의미인지 정의하기위해,알고리즘의 속성을 기술할수있음
		이런거처럼 정의하고싶은 분산시스템의 속성을 기술할수있음
		예를들어 잠금에 사용할 펜싱토큰은
		  유일성:펜싱토큰은 같은값을 반환하지않음
		  단조일련번호:이전의 요청은 더 작은 토큰을,이후의 요청은 더 큰 토큰을 반환함
		  가용성:펜싱토큰을 요청하고 죽지않은노드는 결국에 응답을 받음
		이렇게 정의할수있고,알고리즘은 시스템모델에서 발생할수있다고 가정한 모든 상황에서 그 속성들을 항상 만족시키면됨
		그러나 이걸 이해하긴 쉽지않음(모든노드가 죽으면 어떤알고리즘도 아무것도못함)
	
	  2.안전성과 활동성
	    그래서 안전성과 활동성을 구분하면 이해가 쉬움
		펜싱토큰에서 유일성과 단조일련번호는 안전성이고,가용성은 활동성임
		
		안전성은 나쁜일은 일어나지않는다 이런느낌이고,활동성은 좋은일은 결국 일어난다,결국에 xx한다 이런느낌임
		좀 더 정확하게는
		  안전성:이게 위반되면 그 속성이 깨진 특정시점을 가리킬수있고,이게 위반되면 그 위반을 취소할수없음,이미 손상됨
		  활동성:어떤 시점을 정할순없지만,결국에 먼미래에는 그 속성을 만족시킬수 있다고 희망을 가짐
		이런느낌
		
		보통 분산알고리즘은 시스템모델의 모든상황에서 안전성이 항상 만족되기를 요구하지만,활동성에서는 경고만 하는것도 허용됨
		
		하지만 현실에서는 이렇게 깔끔하진않음
		그래서 이론적으로는 어떤일이 일어나지않는다고 가정할수있지만,현실적으로는 최소한의 대응(로그남기기정도라도)을 해야함
		
9.일관성과 합의	
  분산시스템에선 많은게 잘못될수있고,이떄 가장 간단한방법은 전체 서비스가 실패되도록 두고 사용자에게 오류메시지를 보여주는것
  이게 맘에 안든다면 결함을 견뎌낼 방법을 찾아야함
  
  내결함성을 지닌 시스템을 구축하는 가장 좋은 방법은,유용한 보장을 해주는 범용 추상화를 찾아 이를 구현하고 어플리케이션이 이 보장에 의존하게하는것(트랜잭션처럼)
  예를들어 분산시스템에서 가장 중요한 추상화중 하나인 합의등이 있음(모든 노드가 어떤것에 동의하게 만드는것)
  1.일관성보장
    복제db는 대부분 최소한 최종적 일관성은 제공함(최종 수렴)
	그러나 이건 매우 약한 보장임
	언제 수렴할지는 아무도 모르고,수렴되기전엔 어케될지도 모름
	
	약한 보장만 제공하는 db를 사용할땐,그 제한을 계속 알아야하고 뜻하지않게 너무 많은걸 가정하면 안됨
	또한 대부분의 시간동안 어플리케이션은 잘 동작하고,버그는 종종 미묘하고 테스트로 발견하기어려움

  2.선형성
    최종적일관성을 지닌 db에 두 다른 복제본에 질문을 하면 답이 다를수있음
	여기서 나온게 선형성임
	이거의 기본 아이디어는 시스템에 db복사본이 하나만있고,그 데이터를 대상으로 수행하는 모든 연산은 원자적인것처럼 보이게 하는것
	이러면 현실에는 여러 복제본이 있더라도 어플리케이션은 거기에 신경쓸 필요가 없어짐
	
	선형적 시스템에서는 클라가 쓰기를 성공하자마자 그걸 읽으면 방금 쓰여진값을 볼수있어야함
	즉 선형성은 최신성보장임
	
	1.시스템에 선형성을 부여하는건 무엇인가?
	  이건 읽기와 쓰기 외에,읽기를 마치고 현재 진행중인 쓰기가 있는지를 확인하고,그거에 겹치는게 있으면 다시읽기를 하는식으로 됨
	  즉 모든 연산은 항상 시간순으로 진행되고 결코 뒤로갈순없음
	  
	  선형성과 직렬성의 차이는,
	    선형성은 개별객체에 실행하는 읽기와 쓰기에 대한 최신성보장,쓰기스큐를 막지못함
		직렬성은 모든 트랜잭션이 여러객체를 읽고쓸수있는 상황에서 트랜잭션의 격리속성임,그 순서가 트랜잭션이 실제 실행하는순서와 달라도 ㄱㅊ
	  고,둘은 다른거임
	2.선형성에 기대기
	  이걸 중요하게 사용하는곳에는 단일리더복제의 리더선출(잠금)에서 잠금은 선형적이어야함
	  또한 유일성제약을 강제할떄도 선형성이 필요함(이메일 유니크같은거,이것도 잠금과 유사함)
	  
	  또한 어떤 이미지를 s3에 올리고,메시지큐로 이 이미지를 크기를 줄이는 로직이 있을때,메시지큐와 s3간에 선형성이 었다면 경쟁이 발생해서 에러가 날수있음
	
	3.선형성 시스템 구현하기
	  단일리더복제를 사용하면 선형적으로 구현할 가능성이 있고,합의알고리즘을 사용하면 선형적일수있음(단 스플릿브레인과 복제본이 뒤쳐지는걸 막을수단이 필요)
	  
	  직관적으로 보면 다이나모스타일의 엄격한 정족수는 선형적인거처럼 보이지만,네트워크변동이 심하면 경쟁조건이 생길수있음
	  선형적으로 만들수는 있지만 성능이 떨어지는 비용이 들어감
	
	4.선형성의 비용
	  다중리더복제에서는 각 데이터센터간 연결이 끊겨도 선형적으로 정상동작할수있음
	  반면 단일리더복제에서는 리더가 데이터센터중 하나에 있어야만하고,반대편 데이터센터에 연결된 클라들은 다 중단됨(비선형적이라)
	  
	  이건 cap임
	  즉 네트워크 연결이 끊겼을때 일관성을 고르면 가용성이 떨어지고(다중리더복제),가용성을 고르면 일관성이 떨어짐(단일리더복제)
	  
	  그리고 사실 선형성은 비용이 비싸서,선형적인 시스템을 드뭄
	
  3.순서화 보장
    선형적 레지스터는 데이터복사본이 하나만 있는거처럼 동작하고,모든연산이 어느시점에 원자적으로 효과가 나타나는거처럼 보임
	이건 연산이 어떤 잘 정의된 순서대로 실행된다는걸 암시함
	
	순서화는 이때까지 계속나왔고,이건 이게 중요한 근본적 아이디어일수도 있다는것
	1.순서화와 인과성
	  순서화는 인과성을 보존하는데 도움을 줌
	  인과성은 이벤트에 순서를 부과하고,결과가 나타나기전에 원인이 발생함
	  또한 메시지를 받기전에 메시지를 보내야하는식
	  즉 한 노드가 어떤 데이터를 읽고,그 결과로 데이터를 쓰고,이런식으로 연쇄될때 무엇이 무엇보다 먼저 일어났는가를 정의함
	  
	  시스템이 인과성에 의해 부과된 순서를 지키면,그 시스템은 인과적으로 일관적이라고 함
	  
	  그렇다고 인과적순서가 전체순서는 아님
	  전체순서는 어떤 두 요소를 비교하게 해줄수있는데(자연수처럼),수학적 집합은 항상 전체순서를 정할수없음(1과 a중 뭐가큰기)
	  즉 이것들은 비교불가하고 수학적집합은 부분적으로만 순서가 정해짐
	  
	  선형적시스템에서는 연산의 전체순서를 정할수있고,
	  인과성에서 두연산중 어떤것도 다른것보다 먼저 실행되지않았으면 두 연산은 동시적이라고 함
	  즉 인과성은 전체순서가 아닌 부분순서를 정의하는것이고(즉 인과적인 관계가 있으면 순서가 있다),동시에 실행되면 비교할수없음
	  
	  동시성은 타임라인이 갈라졌다가 합쳐지는걸 의미함
	  이경우 다른가지의 연산읜 비교불가함(동시적),이건 깃과 비슷함
	  서로 다른 브랜치에 있는것들은 비교불가하지만,머지시키는 작업은 비교가 가능한것처럼
	  
	  인과적순서와 선형성사이에는,선형성은 인과성을 내포하는 관계가 있음
	  선형적이라면 인과성도 올바르게 유지하게됨
	  그렇지만 선형성은 비싸고,인과성을 유지하는덴 다른 방법도 있음(인과적 일관성만 구현)
	  보통 선형성이 필요해보이는 시스템은,인과적 일관성이 필요했을경우가 더 많음,그래서 이런경우엔 선형성보다 인과적 일관성만 구현하는게 더 좋을수있음
	  
	  인과성을 유지하기위해선 어떤 연산이 어떤 다른연산보다 먼저 실행됐는지를 알아야함,이게 부분순서임
	  동시실행되는 연산은 어떤순서로든 처리해도되지만,한연산이 다른연산보다 먼저 실행됐다면,반드시 그순서대로 처리되어야함
	  즉 모든 복제서버에서 인과적으로 앞서는 연산이 이미 처리됐다고 보장할수있어야함
	  
	2.일련번호 순서화
	  인과성은 중요하지만,모든 인과적 의존성을 실제로 추적하는건 실용성이 떨어짐
	  그래서 사용되는게 일련번호나 타임스탬프임
	  보통 논리적시계,즉 카운터를 사용함
	  
	  이러면 특히 인과성에 일관적인 전체순서대로 일련번호를 생성할수있어지고(이러면 a가 b보다 먼저실행됐다면 전체순서에서도 먼저임,즉 더 낮은 일련번호를가짐)
	  동시연산의 경우 랜덤하게 순서가 정해짐
	  이러면 팔로워는 복제로그에 나오는 순서대로 쓰기를 해버리면됨
	  이러면 리더보다 좀 더 뒤쳐질순있어도,인과성에는 일관적임
	  
	  근데 리더가 없다면,각 노드가 자신만의 일련번호집합을 생성할수있긴한데(일련번호와 노드명을담아서),각노드끼리의 비교가 불가능해짐
	  그래서 사용되는게 램포트 타임스탬프임
	  이건 일련번호와 노드명을 사용하는건 똑같지만,일련번호를 전체적으로 똑같이 가져가는거
	  일부는 일련번호가 겹칠수있지만,노드는 다르기때문에 유일성은 보장되고,이러면 전체 순서화는 만들수있음
	  
	  근데 문제는 사후에는 이러면 반드시 성공시킬수있지만,당시에는 이거로는 부족함,즉 모든 연산을 모아야 전체순서가 드러난다는게 단점임
	  즉 사용자를 입력할때 사용자명에 대한 유일성 제약조건같은게 필요할땐 이거로안됨
	  
	  그래서 사용되는게 전체순서 브로드캐스트임
	
	3.전체 순서 브로드캐스트
	  단일리더를 사용하면 일련번호만 사용해도되지만,이러면 처리량이 커졌을때가 문제임
	  전체순서 브로드캐스트는 노드사이에 메시지를 교환하는 프로토콜로,두가지 안전성 속성을 항상 만족해야함
	    어떤 메시지도 손실되지않는다,메시지가 한 노드에 전달되면 모든노드에도 전달돼야함
		메시지는 모든 노드에 같은순서로 전달됨
	  즉 노드나 네트워크에 결함이 있어도 신뢰성과 순서화 속성이 항상 만족되게 보장해야함
	  물론 끊겼으면 전달못하지만,알고리즘이 계속 재시도해서 결국 복구되면 전달할수있어야하고,이때도 올바른 순서로 전달돼야함
	  
	  이럴때 사용하는게 주키퍼나 etcd등임
	  이런 전체순서 브로드캐스트는 복제에 딱 필요한거고,
	  모든 메시지가 db에 쓰기를 나타내고 모든 복제서버가 같은쓰기연산을 같은순서로 처리하면 복제서버들은 일관성있는 상태를 유지함
	  이걸 상태기계복제 라고 함
	  
	  또한 전체순서 브로드캐스트는 직렬성 트랜잭션을 구현할때도 쓸수있음
	  결국 모든 메시지가 같은순서로 처리되면,항상 일관적이니까
	  
	  여기서 중요한점은,메시지가 전달되는시점에 그 순서가 고정된다는것
	  후속메시지가 이미 전달됐다면,노드는 그 순서의 앞에 메시지를 소급적으로 끼워넣는게 허용되지않음
	  
	  전체순서 브로드캐스트는 비동기식임
	  메시지가 고정된순서로 신뢰성있게 전달되는건 보장해주지만,언제 전달될지는 보장하지않음
	  즉 어떤 수신자는 다른것보다 뒤쳐질수있음
	  반대로 선형성은 최신성보장이고,읽기가 최근에 쓰여진값을 보는게 보장됨
	  
	  근데 전체순서브로드캐스트를 사용해서 비슷하게 선형성을 구현할수있는데,대충 쿼리날리고,확인한후에 라이트하고,다시쿼리날려서 확인하면됨
	  이러면 인과성에 의해 마지막쿼리가 내가 한 라이트랑 같다면 성공이고,다르다면 실패임
	  
	  근데 이건 선형성쓰기는 보장하지만,선형성읽기는 보장되지않음(정확히는 순차적일관성이라)
	  

  4.분산 트랜잭션과 합의
    합의는 분산컴퓨팅에서 가장 중요하고 근본적인문제임
	리더선출,원자적커밋등에 필수적으로 사용됨
	
	1.원자적커밋과 2단계커밋
	  트랜잭션원자성이란,한 트랜잭션의 결과로는 커밋 또는 어보트가 나와야한다는것
	  단일노드에서야 그냥 트랜잭션쓰면되고,순서도 그냥 디스크에 쓰여지는순서를 사용하면되지만,분산시스템에선 복잡해짐
	  
	  일단 모든걸 각자의 노드에 맡기면,원자성이 깨지고(어떤건성공 어떤건실패),그렇다고 트랜잭션을 최종적 일관성을 할순없음(커밋했다가 어보트날릴순없음,리드커밋떔에)
	  물론 분산트랜잭션이 있긴하지만,이건 어플리케이션의 관점임
	  
	  그래서 사용되는게 2단계커밋임
	  이건 코디네이터라는 별도의 노드를 사용하고,트랜잭션이 들어오고 커밋요청을 하면,
	    모든 노드에 준비요청을 보내서 커밋할지를 물어보고,
	    전부 동의가 나오면 커밋을 실행하고,한명이라도 거부하면 전부 거부함
		전부 동의가 나오면 모든 노드에 커밋요청을 날리고,무슨일이 있어도 커밋해야함
	    어떤 노드가 죽더라도,다시 살아날때까지 기다려서 커밋해야함
	  여기서 핵심은,준비요청이라는 행위를 동의하면,어보트를 할 권리가 없어진다고 생각하는것과,동의가 나온다음엔 무조건 커밋을 해야한다는것
	  이게 원자성을 보장함
	  
	  근데 준비요청을 응답하고나서 코디네이터가 죽어버리면 노드들은 영원히 대기해야함(어보트권리가 없기때문)
	  그래서 코디네이터가 복구되기를 기다릴수밖에없음
	  
	  그래서 2단계커밋은 블로킹 원자적 커밋 프로토콜인데,이걸 3단계로 바꿔서 논블로킹하게 할순있지만 현실에선 어려움
	
	2.현실의 분산 트랜잭션
	  이 2단계커밋은 평판이 좀 엇갈림
	  안전성을 보장하긴하지만,운영이 어려워지고 성능이 떨어짐
	  그래서 여러 클라우드서비스에선 보통 잘 구현하지않음
	  
	  또한 분산트랜잭션은 데이터베이스 내부 분산 트랜잭션과,이종분산트랜잭션이 있는데,이종분산트랜잭션은 훨씬 더 어려움
	  
	  노드의 db는 2단계커밋에 동의를 하고나면,해당 레코드에 대해 잠금이 걸리고,커밋되거나 어보트할때까지 해제할수없음
	  그래서 코디네이터가 살아날때까지 어떤 트랜잭션도 해당 레코드에 접근할수없음
	  
	  또한 코디네이터가 살아나면,로그로부터 그상태를 깨끗하게 복구하고 의심스러운 트랜잭션을 해소해야하지만,현실에선 쉽지않아서 결정할수없는애들이 생김
	  이러면 결국 수동으로 해결해야함
	
	3.내결함성을 지닌 합의
	  합의란 여러노드가 어떤것에 동의해야하는것
	  이건 하나 이상의 노드들이 값을 제안할수있고,합의 알고리즘이 그 값중 하나를 결정함
	  이때 합의알고리즘은
	    균일한 동의:어떤 두 노드도 다르게 결정하지않음
		무결성:어떤 노드도 두번 결정하지않음
		유효성:한노드가 값을 결정하면,v는 어떤 노드에서 제안된것
		종료:죽지않은 모든 노드는 결국 어떤 값을 결정함
	  임
	  균일한 동의와 무결성속성은 합의의 핵심이고,모두 같은 결과로 결정하고 한번 결정하면 마음을 바꿀수없음
	  유효성은 그냥 이상한짓못하게하는거고(계속 기권표던지는거방지)
	  종료는 내결함성의 아이디어를 형식화함
	  즉 그 상태에 머물러서 영원히 시간끄는걸 막고,어떻게든지 진행해야한다고 규정함
	  어떤 노드가 장애가 나도 다른노드들은 결정을 내려야함
	  
	  물론 모든노드가 죽으면 나가리지만(알고리즘들은 모두 버틸수있는 장애에 한계가 있으니까,어떤 합의알고리즘이라도 과반수는 올바르게 동작해야함)
	  즉 종료속성은 죽거나 연결할수없는 노드댓수가 절반미만이라는 가정에 종속적임
	  그리고 절반이상이 죽더라도 유효하지못한 결정을 내리는게 아닌 그냥 뻗어버려서 오염은 되지않고
	  
	  또한 단일리더복제에서도 이런 합의를 거쳐서 리더를 뽑아야,독재자시스템의 문제가 생기지않음
	  근데 리더를 뽑으려면 리더가 있어야하는 문제가 있는데,이건 에포크번호같은거로 처음이나 문제가 생겼을때 우선순위를 정하는식으로 해결함
	  즉 두 리더사이에 충돌이 있으면,노드번호가 큰애가 이기는식
	  
	  그래서 리더는 뭔가를 결정하기전에 다른 나보다 큰 에포크번호를 가진 리더가 있는지 투표하고,과반수를 먹으면 다시 결정을 투표할수있음
	  이때 중요한건 두 투표는 정족수가 겹쳐야함
	  
	  이건 2단계커밋과 비슷해보이지만,이건 전체가 아닌 과반수의 동의만 받으면되고,안전성속성이 항상 만족되게 보장해줌(정확성과 내결함성의 핵심)
	  
	  이런 합의알고리즘은 구체적 안전성속성을 가져오고 그러면서 내결함성도 유지하지만,커밋된데이터의 유실,과반수이상 장애시 네트워크붕괴등의 리스크는 가지고감
	  또한 특정 네트워크 하나가 불안정할때 계속 투표가 끊기는등 문제가 발생할수있음
	  
	4.멤버십과 코디네이션 서비스
	  주키퍼와 etcd등은 분산 키값저장소나 코디네이션과 설정서비스라고 설명됨
	  근데 얘들은 합의알고리즘을 구현하는데 엄청나게 힘을쓰는데,이게 db랑 다른점임
	  
	  이런 주키퍼는 서비스찾기등에서도(로드밸런서같은) 잘 사용됨,이땐 합의가 필요없고
	  리더를 선출할떄도 사용되는데 이땐 합의가 필요함
		
10.일괄처리
  시스템은 세가지로 분류할수있음
    서비스(온라인 시스템):restapi처럼 클라로 요청을 받아서 그걸 처리해주는 시스템,응답시간이 중요함
	일괄처리시스템(오프라인시스템):매우 큰 입력을 받아 데이터를 처리하고 결과데이터를 생산함,처리량이 중요하고 응답시간이 중요하지않음(처리시간이 기니까 의미없어서)
	스트림처리시스템(준실시간 시스템):일괄처럼 입력을 소비하고 출력을 생산하지만,입력이 들어온직후 바로 작동해야해서 지연시간이 중요함,일단 일괄처리기반의 변종임
  일괄처리는 신뢰할수있고 확장가능하며 유지보수하기 쉬운 어플리케이션을 구축하는데 매우 중요한 구성요소임
  
  1.유닉스 도구로 일괄처리하기
    유닉스의 핵심은
	  각 프로그램이 하나의 일만 하게 하고,새작업을 하려면 새 프로그램을 만들어라
	  모든 프로그램의 출력은 알려지지않은 다른 프로그램의 입력으로 쓰일수 있다고 생각해야한다
	임
	즉 모든 프로그램을 동일 인터페이스로 만들어서 파이프를 연결하는식임
	
	또한 다른특징으로는 표준입력과 표준출력을 사용한다는점이 있음
	이걸 사용해서 키보드입력을 화면에 뿌릴수도(기본동작),이전프로그램에서 입력받아서 다음프로그램으로 넘길수도있음
	이걸 ioc라고함(제어의역전,프로그램에서 입력을 제어하는게 아닌 외부에서 제어하니까)

  2.맵리듀스와 분산파일시스템
    맵리듀스도 유닉스처럼 돌아감
	대신 이건 표준입출력이 아닌 파일을 입력과 출력으로 사용함
	
	1.맵리듀스 작업 실행하기
	  맵리듀스는 분산파일시스템위에서 대용량 데이터셋을 처리하는 코드를 작성하는 프레임워크임
	  대충
	    입력파일을 읽어서 레코드로 쪼갬
		각 입력 레코드마다 매퍼함수를 호출해 키와값을 추출
		키를 기준으로 정렬
		정렬된 값 전체를 대상으로 리듀스함수를 호출
	  이런식으로 동작함
	  여기서 매퍼함수와 리듀스함수는 우리가 만들어야하는거고,레코드로 쪼개는것과 정렬은 알아서해줌
	  매퍼는 입력레코드로부터 키와 값을 추출하는작업을 콜백함수로 구현하면되고,
	  리듀스는 매퍼가 만든 키값쌍을 받아서 같은키를 가진 레코드를 모으고,해당값의 집합을 반복해 리듀스함수를 호출해서 출력레코드를 생산할수있음
	  
	  이 맵리듀스와 유닉스의 가장 큰 차이는,이게 병렬로 수행하는 코드를 직접 작성하지않고도 여러장비에서 동시처리가 가능하다는점임
	  보통 작업은 해당 데이터가 있는 노드에서 행해지고(데이터지역성에 의해 비용이 줄어서),다한다음 모아서 파티셔닝해서 정렬함
	  
	  맵리듀스 작업 하나로는 해결할수있는 문제범위가 제한적이고,그래서 여러 맵리듀스를 연결해(워크플로) 구성하는게 일반적임
	  즉 작업하나의 출력을 다른 맵리듀스작업의 입력으로 사용하는식
	
	2.리듀스 사이드 조인과 그룹화
	  여러 데이터셋에서 한 레코드가 다른레코드와 연관이 있는건 일반적임,이떄 rdb에선 외래키,문서모델에서는 문서참조,그래프에선 간선이라고 부르는데
	  이떄 양쪽 레코드 모두에 접근해야하면 조인이 필수임
	  
	  보통 rdb에서는 색인을 사용해서 관심있는레코드위치를 찾아서 효율적으로 동작할수있지만,맵리듀스에는 색인이 없음
	  즉 무조건 풀테이블스캔을 해야함
	  이건 보통 맵리듀스같은 배치작업은 전체를 대상으로 하는경우가 많기때문
	  
	  그래도 필요할땐,매퍼에서 작업레코드를 재배열하는식으로 하는경우가 있음,이게 보조정렬임
	  맵리듀스는 올바른 장비로 데이터를 모으는 물리적 네트워크통신과,받은 데이터를 처리하는 어플리케이션 로직을 분리함
	  그래서 어플리케이션단에서는 특정 장비가 죽는등의 부분실패등에 대해서 내가 고민할필요가 없음(제어의역전)
	  
	  맵리듀스에서 그룹바이처럼 같은곳으로 관련데이터를 모으는경우엔,매퍼에서 그룹화할대상을 키로삼는게 가장 간단함
	  
	  근데 키 하나에 너무 많은 데이터가 연관된다면 이런식으로 모을수없음(컴퓨터한계를 넘길경우)
	  이런걸 핫키라고 하고,이 핫키로 쏠리는현상을 핫스팟이라고함 
	  이때 핫키를 쏠린조인등으로 분산시키거나 공유조인등을 사용할수있음
	
	3.맵사이드 조인
	  이전절의 조인은 리듀스단에서의 조인이고,맵단에서의 조인도 가능함
	  리듀스 사이드 조인의 장점은,입력데이터에 대한 가정이 필요없다는거고,단점은 리듀서입력을 병합하는 비용이 크다는게 단점임
	  
	  즉 입력데이터에 대한 가정이 가능하다면,맵사이드조인을 사용해서 조인을 더 빠르게 할수있다는거임
	  이건 단순히 분산파일시스템에서 입력파일 블럭 하나를 읽어서 다시 해당 분산파일시스템에 저장하는게 전부임
	  즉 리듀서도 정렬도 안해도됨
	  
	  이건 작은 데이터셋과 매우 큰 데이터셋을 조인할때 가장 간단히 적용해볼수있음
	  이걸 브로드캐스트 해시 조인이라고 함,이떄 작은데이터셋은 매퍼메모리에 적재가능할정도로 충분히 작아야함
	  
	  같은방식으로 맵사이드조인의 입력을 파티셔닝하면,조인접근법을 각 파티션에 독립적으로 적용할수있음
	  이걸 파티션 해시조인이라고함
	  이게 제대로되면 조인할 레코드가 모두 같은파티션에 위치해서,파티션하나만 읽어도됨
	  이건 조인할 두 입력 모두를 같은키와 같은해시함수기반으로 파티셔닝해야 작동함
	  
	  또한 같은방식으로 파티셔닝되고 같은키로 정렬됐다면,맵사이드 병합조인을 쓸수있음
	  이러면 리듀서처럼 동일한 병합연산을 할수있음(양쪽을 같이읽어서 조인하는식임)
	  
	4.일괄처리 워크플로의 출력
	  이 맵리듀스를 사용하는 이유는,일반 sql질의는 전혀 아니고,분석쪽에 가깝지만 검색색인을 구축하거나,키값을 저장해서 머신러닝에 사용하거나 하는식의
	  일종의 데이터베이스를 만드는 형태로 사용하기좋음
	  
	  이 맵리듀스도 리눅스처럼 파이프라인이기때문에,부수효과가 없어서 유지보수가 쉽고 디버깅이 쉬움
	
	5.하둡과 분산데이터베이스의 비교
	  하둡(맵리듀스)은 유닉스의 분산버전과 비슷함
	  
	  db는 특정 모델에 따라 데이터를 구조화해야하지만,분산파일시스템의 파일은 어떤 데이터모델과 인코딩을 사용해서도 기록할수있는 단순 연속바이트일뿐임
      즉 어떤 데이터형태라도 상관없이 덤프할수있음
	  
	  이 세심하게 모델링하고 데이터를 가져오는것과,그냥 덤프떄려박는거는 둘다 장단점이 있는데,보통 이 용도라면 걍 때려박는게 나음
	  그리고 사용자쪽에서 알아서 파싱해서 가져다가 쓰게하는게,각 부서에 맞는 형태로 파싱해서 쓰는식의 데이터레이크로 쓰는게 효율적임
	  즉 데이터를 해석하는 책임을 사용자측으로 넘기는것(스키마 온 리드)
	  
	  맵리듀스같은 일괄처리는,일부가 실패하더라도 사용자에 큰 영향없이 다시 실행하면됨
	  또한 우선도도 높지않아서,중요한일을 각 노드들이 처리하며 남는자원으로 처리해도돼서 내결함성이 높음

  3.맵리듀스를 넘어	
    맵리듀스는 단지 분산시스템에서 가능한 여러 모델중 하나일뿐임
	단지 추상화가 잘돼서 이해하기가 쉬워서 견본으로 쓰기좋음
	그러나 맵리듀스도 완벽하진않아서,일부 유형의 처리에는 성능저하를 내지만,대신 매우 견고해서 자주 종료되는 멀티테넌트 시스템에서도 사용할수있음
	즉 속도가 느린대신 성공확률이 높음
	
	1.중간상태 구체화
	  모든 맵리듀스 작업은 다른작업과 모두 독립적임
	  그래서 첫번째 작업의 출력을 두번째 작업의 입력으로 넣는식으로 사용됨
	  이떄 첫번째작업의 출력이 조직내에 널리 공개하는 데이터셋이라면 이렇게 하면 좋지만,보통은 같은팀내에서 유지보수하는 다른특정작업의 입력으로만 사용됨
	  즉 이경우엔 분산시스템의 파일들은 단순한 중간상태일뿐임
	  
	  이 중간상태를 파일로 기록하는걸 구체화라고하고,이렇게 파일로 기록하는 대신 작은 인메모리버퍼로 출력을 입력으로 넣는게 스트리밍임
	  
	  이렇게 중간상태를 완전히 구체화하는건 여러 단점이 있음
	    모든작업이 끝나야 다음작업을 진행할수있음
		매퍼의 중복
		중간상태가 여러장비에 걸쳐 복제돼버림
	  그래서 이걸 해결하기위해 사용되는게 데이터플로엔진이고,여기에 스파크같은게 있음
	  
	  얘들의 공통점은,전체 워크플로를 독립된 하위작업으로 나누지않고 작업 하나로 처리한다는것,그래서 데이터플로엔진임
	  이거도 맵리듀스처럼 단일스레드에서 사용자정의함수를 반복호출해 한번에 레코드 하나를 처리하고,데이터플로엔진은 입력을 파티셔닝해 병렬화함
	  그리고 한 함수의 출력을 다른함수의 입력으로 사용하기위해 네트워크를 통해 복사함
	  맵리듀스와 달리 이 함수들은 맵과 리듀스를 번갈아 수행하는식의 규칙을 엄격하게 지킬필요가 없고,대신 더 유연한 방법으로 함수들을 조합할수있음
	  이런것들을 연산자라고 부름
	  
	  이렇게 하나로 취급하는거로,정렬을 건너뛰던지 할수있음
	  
	  중간상태를 모두 구체화하면 내구성이 생김,즉 내결함성이 높음
	  실패해도 다시읽어서하면되니까
	  그런데 스파크같은건 중간상태를 쓰지않기때문에 아직 유효한데이터에서 계산을 다시해서 복구해야함
	  이때 중요한건 해당연산이 결정적인지 아닌지 파악하는거(순수한지)
	  그래서 연산자가 비결정적이라면 신규데이터를 기준으로 다시수행해야하기때문에,결정적으로 만드는게좋음
	  이때 주의할건,해시쓰면 비결정적이 되고 확률통계알고리즘도 랜덤쓰니까 조심(시계도)
	  
	  데이터플로엔진은 파이프(코틀린 시퀀스)와 매우 비슷함
	  즉 한 출력을 다 보고 다음거로 넘기지않고,한 레코드씩 넘김
	  단 정렬은 전부 다 봐야 가능하기때문에,뺄수있으면 빼고 꼭 필요할떄만 넣는게 좋음
	
	2.그래프와 반복처리
	  그래프는 정점과 간선목록이 포함된 파일형태로 저장할수있지만,완료할때까지 반복이라는건 맵리듀스로 표현할수없음(데이터를 일회성으로만 처리하기때문)
	  그래서 벌크동기식 병렬모델을 사용해야하는데,보통 아파치 지라프,스파크 그래프등을 사용함
	  
	  맵리듀스가 매퍼가 특정 리듀서를 호출해 메시지를 전달한다면,이건 한정점은 다른 정점으로 메시지를 보낼수있고,이걸 반복하는식임
	  즉 정점은 새로 들어오는 메시지만 처리하면됨(메시지를 받지않은 정점은 아무것도안해도됨)
	  
	  이렇게 메시지를 사용하니 일괄처리가 가능하고,병렬실행도 가능함(어디서 실행되든 상관없고 id를통해 통신하니)
	
	3.고수준 api와 언어
	  맵리듀스 작업을 직접 작성하는건 어려워서,하이브나 테즈같은걸 사용하기좋음(스파크도 좋고)
	  이런애들은 고수준인터페이스를 지원하고 대화식사용도 지원해서 쓰기좋음
	  
	  또한 선언형 질의언어를 사용하면 알아서 옵티마이저가 최적화해줌
	  
	4.정리
	  분산일괄처리엔진은 일부러 제한적인 모델을 제공하고,그 제한을 사용해 내결함성을 구현함
	  또한 얘는 입력을 수정하지않고 입력을 읽어서,즉 처음부터 입력의 크기를 알수있고,그래서 입력 전체를 다 읽었는지를 알수있음
	  이게 스트림과의 가장 큰 차이점임
	  
	
11.스트림처리	
  일괄처리가 입력으로 파일집합을 읽어 출력으로 새로운 파일집합을 만드는데,여기서는 입력이 유한한크기로 한정된다는(시작점에서 파일크기가 고정된다는) 가정이 있음
  그래서 일괄처리는 입력을 읽는게 끝나는시점을 알수있고,조기출력이 불가능함(입력이 끝나야 출력을 생산할수있음)
  
  이런 일괄처리는 지연시간을 길게잡아도 되는거에는 맞지만,자주 처리해서 지연시간을 줄여야하는 일에는 맞지않음
  이때쓰는건 스트림처리임
  
  스트림처리는 매우 짧은 시간이나,단순히 이벤트가 하나 발생했을때마다 처리하는 방식임
  1.이벤트 스트림 전송
	일괄처리환경에서 작업은 입출력이 파일이지만,스트림에서는 이벤트임
	만약 입력이 파일(바이트의 연속)이라면,이걸 이벤트(레코드)단위로 바꾸고 동작함
	이런식으로 생산자소비자패턴으로 동작하는방식임
	
	이론적으로는 파일이나 db만 있어도 생산자소비자 연결이 가능하지만(폴링,즉 소비자가 계속 쿼리해서 새거나온지 확인),
	지연시간을 낮추고 지속처리를 할떄 이렇게하면 비용이 비쌈
	차라리 새 이벤트가 들어오면 이걸 소비자에 알려주는게 더 쌈
	근데 관계형db같은경우 이런식의 알림을 강력하게 지원하진않음,있긴한데 쓰기좀그럼
	
	1.메시징시스템
	  그래서 사용되는게 메시징 시스템임
	  이건 생산자가 이벤트를 포함한 메시지를 전송하는식임
	  이때 tcp나 이런거로 연결함
	  
	  이런 발행구독모델에서는 두개의 큰 트레이드오프지점이 있는데
	    생산자가 소비자가 메시지를 처리하는 속도보다 빠르게 메시지를 전송할때 선택방식
		  시스템은 메시지를 버림
		  큐에 메시지를 버퍼링(이때도 큐가 무한정커질순없으니 큐가 너무커지면 시스템을 멈출지 파일로 쓸지 이런거 트레이드오프가있음)
		  생산자가 더이상 메시지를못보내게 막음
		노드가 죽거나 오프라인이되면 손실되는 메시지를 허용할지
		  지속성을 갖추려면 디스크에 기록하거나 해야하는데,비용이 드니까 필요없다면 없애고 처리량과 지연시간을 이득볼수있음
	  이렇게 있음
	  센서값같은경우 잠시죽어도 상관없지만,금융시스템은 죽어서 날아가면 안되는식임
	  
	  또한 중간노드를 거치지않고 생산자소비자를 직결하는 시스템들도 많은데,이건 설계떈 괜찮지만 메시지유실가능성을 고려해서 코드를짜야함
	  또한 이거로 처리할수있는 결함은 제한적임
	  
	  그래서 중간에 메시지브로커를 두고 보내는식이 잘 사용됨(카프카)
	  생산자는 브로커에 메시지를 전송하고,소비자는 브로커에서 메시지를 읽음(이런식이라 추상화도 됨)
	  또한 지속성문제도 브로커로 갔기때문에 생산자소비자는 신경안써도됨
	  또한 큐대기를 할떄 소비자는 비동기로 처리해버리면 신경안써도되고
	  
	  메시지브로커는 2단계커밋을 하기도함,일단 db랑 비슷한점도 있기떄문
	  
	  또한 여러 소비자가 같은토픽에서 메시지를 읽을때
	    로드밸런서:소비자중 하나로 던지기
		팬아웃:모든 소비자로 던지기
	  중 선택하면됨
	  물론 둘을 섞어서 사용할수도있음(소비자패턴별로)
	  
	  소비자는 언제라도 장애가 발생할수있음,이때 메시지를 잃어버리지않기위해 메시지브로커는 확인응답을 사용함
	  메시지처리가 끝나면 브로커가 메시지를 큐에서 제거할수있게 브로커에게 명시적으로 알려야함
	  이때 알리지못하고 타임아웃되거나 죽으면,실패했다고 가정하고 다른소비자에게 전달하는데,처리는 성공했는데 응답전송만 실패했을경우를 대비해야함(원자적커밋 필요)
	  
	  메시지 브로커를  사용하면 메시지순서가 변경되기 쉬움
	  물론 서로 독립적이라면 상관없지만,인과성이 있다면 문제가 될수있음(뒤에나옴)
	2.파티셔닝된 로그
	  메시징시스템에 새 소비자를 추가하면 일반적으로는 등록이전 메시지를 복구할순없음
	  이게 필요하다면 로그 기반 메시지 브로커를 사용하면됨
	  
	  이건 메시지를 로그로 다 기록해두고,소비자는 로그를 순차적으로 읽어서 메시지를 받는식임
	  또한 로그를 파티셔닝해서 처리량을 높일수있음
	  이때 각 파티션마다 오프셋이라고 불리는 단조증가하는 순번을 부여하면 순서도 알수있음(단 이때 다른파티션간 메시지순서는 보장하지않음)
	  카프카가 이런식으로 동작함
	  
	  로그기반은 팬아웃 메시지방식을 제공함
	  각 클라는 할당된 파티션의 메시지를 모두 소비하고,소비자에 로그파티션이 할당되면 소비자는 단일스레드로 파티션에서 순차적으로 메시지를 읽음
	  단 이건 처리량이 많고 속도가 중요하고 순서가 중요하면 괜찮지만,
	  토픽하나를 소비하는 작업을 공유하는 노드수가 해당토픽로그파티션수보다 많아야 하거나,
	  특정메시지가 처리하는데 오래걸려서 뒤에가 막히면 안되거나 하면 jms/amqp방식을 사용할수있음(위에방식)
		  
	  
	  파티션 하나를 순서대로 처리하면 메시지를 어디까지 처리했는지 알기쉬움
	  소비자의 현재오프셋보다 작은건 이미 처리한거고,큰건 아직 처리하지않은것
	  그래서 브로커는 개별메시지마다 보내는 확인응답을 추적할필요가 없음(그냥 소비자오프셋 계속보면됨)
	  
	  또한 소비자노드에 장애가 발생하면,그룹내 다른노드에 장애가 발생한 소비자의 파티션을 할당하고,마지막오프셋부터 메시지를 처리하면됨 
	  근데 장애가 발생한 소비자가 처리했지만 오프셋을 기록하지못한 메시지가 있다면 두번처리되니 주의
	  
	  로그를 계속 추가하면 디스크공간을 전부 사용하게됨
	  소비자 처리속도가 느려서 메시지생산속도를 따라잡지못한다면,소비자오프셋이 이미 삭제한 조각을 가리킬수도있음(즉 메시지일부의 유실가능성)
	  즉 이떄 메시지를 버리거나,버퍼링,생산자가 못보내게 막거나 할수있음
	  이 버퍼크기를 모니터링하면 눈에 띄게 뒤쳐지는걸 막을수있음
	  또한 어떤 소비자가 너무 뒤쳐진다고,다른애들도 영향을 받진않음
	  
	  
	  로그기반 메시지브로커에서 메시지를 읽고쓰는건 파괴적연산이 아니라,읽기전용연산임
	  이 메시지처리의 사이드이펙트는 소비자 오프셋이동뿐이기때문
	  그래서 여러모로 사용하기편함(특히 데이터플로만들때)
	
  2.데이터베이스와 스트림
    로그기반 브로커는 db에서 아이디어를 얻어서 비슷한게 많음
	반대로 메시징과 스트림에서 아이디어를 얻어서 db에 적용한것도 있음
	
	이벤트는 특정시점에 발생한 사건을 기록한 레코드임
	이건 사용자활동일수도있지만 db기록일수도 있고,이건 기록했다는 사실을 캡처하고 저장해서 처리할수있다는것
	
	1.시스템 동기화 유지하기
	  모든걸 만족하는 단일시스템은 없고,다 다른기술들의 조합을 해야함
	  이때는 관련된 데이터가 여러 다른장소에서 나타나기때문에 동기화가 필수임
	  
	  이때 이중기록을 사용할수있는데(데이터가 변할때마다 코드가 명시적으로 각 시스템에  기록하고 캐시를 무효화),이건 문제가 좀 있음
	  경쟁조건이 있을때 타이밍이 안맞으면 서로간에 다른 색인값을 가진다던가,동시성감지 메커니즘이 없을때 동시쓰기발생을 알아채지못한다던가
	  
	  또,한쪽쓰기가 성공할때 다른쪽쓰기는 실패할수있고,이건 내결함성문제로 두 시스템간 불일치가 발생함(이건 원자적커밋으로 해결됨)
	  
	  물론 단일리더쓰면 괜찮지만,다중리더를 써야할때가 문제임
	
	2.변경 데이터 캡처
	  그래서 아예 db변경로그를 가져다가 소비하는식으로 사용할수있음
	  즉 변경사항캡처용 db를 리더로 잡고,나머지를 팔로워로 잡는식임
	  이때 로그기반 메시지브로커를 주로쓰고,db트리거도 쓸순있는데 쓰기힘들어서 잘안씀
	  
	  db에서 발생한 모든 변경로그가 있다면,로그를 재현해서 db의 전체상태를 재구축할수있음
	  근데 모든 이벤트를 기록하는건 공간이 너무많이 필요해서,특정시점마다 현재상태를 기록한 스냅숏을 만드는식으로(init상태를 갱신하는느낌) 처리함
	  또한 같은키에 대한 제일 마지막 기록만 가지는 로그컴팩션을 사용할수도있음
	  
	3.이벤트 소싱
	  이건 이벤트소싱과 비슷함
	  이거도 똑같이 이벤트로그를 저장하는데,다른점은 추상화레벨이 다르다는것
	  변경 데이터 캡처는 데이터베이스단에서 변경로그를 추출해서 사용하고,이벤트소싱은 어플리케이션단에서 명시적으로 구축함(이때 갱신이나 삭제는 하지않고 추가만함)
	  
	  이벤트소싱은 데이터 모델링에 쓸수있고,지속개선에 유리함(어떤 상황이 발생하고나서 상황파악이 쉬움)
	  
	  어플리케이션은 이벤트로그로 현재상태를 만들수있어야함,단 로그컴팩션은 다르게 처리되어야함(기록이 목적이기떄문에 이렇게 압축하면안됨)
	  보통 스냅숏을 사용하는편
	  
	  1.명령과 이벤트
	    이벤트소싱의 핵심은 이벤트와 명령을 구분하는것
		요청이 처음 도착하면,이건 명령이고 이건 실패할수있음(무결성위반등으로)
		일단 이게 실행가능한지 확인되고,명령이 승인되면 명령은 지속성있는 불변이벤트가 됨
		이렇게 이벤트가 된 다음에서는 수정과 삭제가 불가능해짐,이런 수정과 삭제는 추가적인 이벤트를 발행해서 결과적으로 덮어써야지,저 이벤트의 변경은 못함
		
		또한 소비자는 이벤트를 거절하지못함,이미 이벤트가 생긴시점부터 확정이고,거부는 이벤트 발행전에 했어야함
		즉 명령의 유효성은 이벤트가 되기전에 동기검증됐어야하고(예를들어 직렬트랜잭션으로 원자적으로 명령을 검증하고 이벤트를 발행)
		
		예를들어 좌석예약같은경우,요청을 이벤트 2개로 분할할수있음(가예약과 유효예약에 대한 확정)
		이런식으로 비동기 유효성검사를 할수있음
		
    4.상태와 스트림 그리고 불변성
	  db는 어플리케이션의 현재상태를 저장한다고 생각할수있음
	  상태의 핵심은 변하는거고,그래서 갱신과 삭제가 있는거
	  
	  상태가 변할때마다 해당상태는 이벤트의 마지막결과로 생각할수있음
	  상태가 어떻게 바뀌었든 항상 이런 변화를 일으킨 일련의 이벤트가 있고,사건이 발생했다 취소되더라도 이벤트가 발생한건 사실임
	  즉 어플리케이션의 상태는 시간에 따른 이벤트의 적분이고,변경스트림은 상태를 시간으로 미분한것
	  
	  즉 로그가 있다면,db는 현재상태에 대한 캐시고,로그가 진실의 근원으로 취급할수있음
	  
	  1.불변 이벤트의 장점
	    이런방식은 현재상태보다 많은 정보를 포함할수있음(장바구니에 뭘 넣었다가 뺴고 딴걸샀다던지)
		즉 같은 이벤트로그로 여러 뷰를 만들수있음(스트림이 원시데이터 서빙하는느낌)
		
		이렇게 질의와 접근을 분리하면 유연성이 생김(cqrs)
      2.동시성 제어
	    이벤트 소싱과 변경데이터캡처의 가장 큰 단점은,이벤트 소비가 대개 비동기로 이뤄진다는것
		그래서 사용자가 로그에 이벤트를 기록하고 연이어 로그에서 파생된 뷰를 읽어도 기록한 이벤트가 아직 읽기뷰에 반영되지않을수있음(자신이 쓴내용읽기)
		그래서 읽기뷰의 갱신과 로그이벤트추가를 동기식으로 수행하거나 해야함(이때 여러시스템에 걸쳐있다면 분산트랜잭션해야함)
		
		대신 이렇게 이벤트로그로 현재상태를 만들면 동시성제어가 간편해짐
		쓰기는 이벤트를 로그에 추가만 하면되니 원자적으로 만들기쉽고,로그와 상태를 같은방식으로 파티셔닝하면 쓰기용 동시성제어는 필요하지않음
		단지 단일이벤트를 한번에 하나씩 처리하면됨
	  
	  3.불변성의 한계
	    이벤트소스 모델을 사용하지않는 많은 시스템에서도 불변성에 의존함
		다양한 db는 내부적으로 시점스냅숏을 지원하기위해 불변 자료구조나 다중버전데이터를 사용함
		이런식으로 영구적으로 불변히스토리를 유지하는거의 난이도는 상황에따라 다름
		빈번한 작업이 일어나야하면 감당안되게 커지거나 할수있고,법적인 문제로 데이터를 삭제해야할수도있음(적출)
		
    3.스트림 처리
	  스트림을 처리하는 방법으로는
	    이벤트에서 데이터를 꺼내 db등에 기록하고 다른클라가 db등에 데이터를 질의하는식
		이벤트를 사용자에게 직접 보냄,즉 실시간대시보드등에 이벤트 스트리밍
		하나이상의 입력스트림을 처리해 하나이상의 출력스트림을 생산
	  여기서 3번의 스트림을 처리해 다른 파생스트림을 생산하는걸 연산자나 작업(job)이라고 부름
	  
	  이게 일괄처리와 가장 크게 다른건,끝나지않는다는것
	  1.스트림 처리의 사용
	    스트림처리는 특정상황에 발생하면 경고를 주는 모니터링목적으로 잘 사용됨
		이런종류의 어플리케이션은 상당히 복잡한 패턴매칭과 상관관계규명이 필요함
		
		또한 다른용도로는 복잡한 이벤트처리와 스트림분석,구체화 뷰 유지,스트림상에서 검색하기,메시지전달 등이 있음
		
		복잡한 이벤트처리는,이벤트 스트림 분석용으로 특정 이벤트패턴을 검색해야할때 적합함
		이건 db쿼리와는 다르게,해당 조건을 만족하는 데이터가 들어오면 스트림으로 쏴주는식임(조건을 설정하는식)
		
		스트림처리는 스트림을 집계하고 통계적 지표를 뽑는거임
		즉 특정 유형의 이벤트빈도 측정이나,특정기간의 값의 이동평균계산같은거
		이런건 고정된 시간 간격을 기준으로 계산하고,이 시간간격을 윈도우라고 함
		
		구체화뷰 유지는 파생데이터 시스템이 원본db의 최신내용을 따라잡게 하는데 사용하는것
		이벤트소싱에서의 어플리케이션 상태를 일종의 구체화뷰로 볼수있고,이런 시나리오에선 모든 이벤트가 필요함(일부로 안됨)
		
		스트림상에서 검색할때도 사용하는데,이건 스트림처리랑 좀 다르게 복잡한 기준을 기반으로 개별이벤트를 찾는것
		뭐 동작방식은 같음
		질의를 저장해두고 지금까지 했던 모든이벤트를 검색하는식
		
		메시지전달은 그냥 스트림을 메시지전달 메커니즘으로 사용하는것
		
	  2.시간에 관한 추론
	    스트림처리를 할땐 시간을 다뤄야할떄가 종종있음
		특히 분석목적일때
		
		근데 이때 조심해야할건,시간의 지점임
		즉 이벤트가 작성될때의 시간인지,현재 처리시점의 시간인지임
		이번 배치처리가 아닌 실시간처리이기때문에,이벤트작성과 처리시점의 갭이 벌어졌을때 문제가 될수있음
		또한 메시지가 지연되면 순서가 꼬일수도 있음
		
		이떄 까다로운건,특정 윈도우에서 모든이벤트가 도착했다거나,아직 계속 들어올지를 알수없다는것
		즉 37분윈도우를 처리했고 지금 39분 윈도우를 처리하고있다고해서,37분 윈도우를 종료선언할수 없다는것
		그래서 타임아웃을 설정할수있긴하지만,다른장비 어딘가에 버퍼링됐을수도있음
		그래서 윈도우를 종료한후에 도착한 낙오자 이벤트를 처리할 방법이 필요해짐
		  낙오자 이벤트를 무시하거나
		  수정값을 발행하거나
		둘중 하나를 선택해야함,또는 t보다 이른 타임스탬프를 가진 메시지는 없다고 가리키는 특별한 메시지를 발행할수있는데,이건 여러장비를 쓸땐 머리아픔
		
		또한 이벤트가 시스템의 여러지점에 버퍼링됐을때 이벤트에 타임스탬프를 할당하는건 더 어려움
		일단 사용자의 시계를 사용할수있지만,고의로 시간을 틀수도 있기때문
		그래서 
		  이벤트가 발생한시간과 이벤트를 서버로 보낸시간(장치시계)
		  서버에서 이벤트를 받은시간(서버시계)
		이렇게 전부 기록하는 방법이 있긴함,그래서 이벤트를 서버로 보낸시간과 받은시간을 기록하는것
		
		이렇게 타임스탬프를 결정했으면,윈도우기간을 어떻게 정의해야할지도 정해야함
		보통
		  고정길이(텀블링윈도우),한 이벤트는 반드시 한 윈도우에 속함
		  고정길이(홉핑윈도우),한 이벤트는 여러 윈도우에 속할수있음(중첩가능)
		  각 시간간격사이에서 발생한 모든이벤트(슬라이딩 윈도우)
		  같은 사용자가 짧은시간동안 발생시킨 모든 이벤트(세션윈도우)
		이렇게 있음
	
	  3.스트림 조인
        스트림에서도 키로 데이터셋을 조인하는등의 작업은 필요하지만,스트림상에서 새로운 이벤트는 언제든 나타날수있다는점에서 조인은 배치보다 어려움
		
		윈도우 조인(스트림-스트림 조인)은 특정 시간 내에 발생한 같은 사용자(키)의 이벤트같은걸 조인하는식임
		이런 조인을 만들려면 스트림처리자는 상태를 유지해야함
		
		스트림 테이블조인(스트림 강화)은 특정 스트림의 값을 db에 있는걸 추가로 덧대서 데이터를 늘리는것,그래서 강화임
		이떄 스트림처리자가 사용하는 db의 로컬복사본은 최신상태여야함(변경데이터캡쳐)
		얜 윈도우조인관 비슷하지만,상태유지를 안해도된다는 장점이 있음(db가하니까)
		
		테이블 테이블조인(구체화뷰 유지)은 캐시를 구체화하고 유지보수하기 위해 사용하는식임
		즉 해당 뷰를  구독하고있는 애들한테 계속 새 데이터를 던져주는식
		
		이런 조인들은 공통점이 많음,모두 스트림처리자가 하나의 조인입력을 기반으로 한 특정상태를 유지해야하고,다른조인입력에서 온 메시지에 그 상태를 질의함
		이떄 순서는 매우 중요한데,단일파티션내에서의 순서는 보존되지만 다른스트림이나 파티션에서 순서를 보장하는 방법은 없음
		그래서 비슷한시각에 다른 스트림에서 발생한 이벤트가 있을때 생기는 문제를 천천히 변하는 차원 문제 라고함
		이건 조인레코드의 특정 버전을 가리키는 유일한 식별자를 사용해서 해결함(즉 값이 바뀔때 단조되는 식별자를 넣는식)
		단 이러면 로그컴팩션이 불가능함
		
	  4.내결함성
	    배치는 쉽게 결함에 대처할수있지만,스트림은 조금 더 어려움,시간문제때문
		
		그래서 사용하는 해결책은,스트림을 작은블록으로 나누고,각 블록을 배치처리하는것
		또한 장애가 발생했을떄 정확히 한번 처리되는것처럼 보일려면 처리가 성공했을때만 모든 출력과 사이드이팩트가 발생해야함
		즉 2단계커밋처럼 해야함
		
		아예 다른방법으로는 멱등성을 챙길수도있음
		걍 여러번처리하더라도 똑같이되게하는것
		연산자체가 멱등하지않더라도,단조증가하는 오프셋을 사용해서 그값을 가지고 where해버리면 같은갱신이 되는걸 보장할수있음
		
		실패후에 상태를 재구축하는건,원격 데이터저장소에 상태를 유지하고 복제하거나,스트림처리자의 로컬에 상태를 유지하고 지속적으로 복제하는것
		근데 상태복제가 필요없다면 안해도되긴함(작은크기의 윈도우를 집계했다면 그냥 다시하면됨,또한 로그컴팩션된 스트림도 마찬가지)
		
	
12.데이터 시스템의 미래	
  1.데이터통합
    1.파생데이터에 특화된 도구의 결합
      모든 문제를 만족하는 하나의 해결책은 없지만,상황에따라 적절한 서로 다른 접근법은 많이있음
	  이때 하나의 코드경로로 견고하고 잘 동작하게 만들긴 어렵고,소프트웨어 하나로 모든걸 하려고하면 보통 구현이 빈약해짐
	  즉 여러가지 소프트웨어를 필연적으로 섞어야함
	  
	  데이터통합의 필요성은 조직 전체 데이터플로를 고려해야 명확해짐
	  
	  만약 다른 데이터 접근양식을 만족하기위해,같은 데이터 사본을 여러 저장소 시스템에 유지해야할땐 입력과 출력을 분명히 해야함
	  즉 데이터를 처음으로 어디서 기록하는지,어떤 표현형이 어떤 원본에서 파생되는지,데이터를 모두 올바른 장소로 올바른 형식으로 어떻게 넣는지등에 대해 고려해야함
	  
	  서로 다른 데이터시스템간 일관성을 유지하는 고전적인 방법은 원자적커밋과 2단계커밋의 분산트랜잭션임
	  또 요즘나오는 방법으로는 이벤트소싱등도 쓸수있음
	  
	  분산트랜잭션은 정확히 한번 나타나게 보장하고,이벤트소싱등의 로그기반은 결정적 재시도와 멱등성을 기반으로 함
	  분산트랜잭션은 어렵고,그래서 이벤트소싱등의 로그기반(카프카등)이 데이터시스템 통합에는 더 좋음
	  
	  충분히 작은 시스템에서 이벤트로그의 순서 전체를 보장하는건 가능하지만(단일리더),커지면 이게 힘들어짐
	  이러면 전체순서 브로드캐스트가 필요해짐,이건 합의와 동등함
	  
	  이벤트간 인과성이 없다면 순서가 없어도 상관없지만,있을떈 있어야함,그리고 직접적이 아닌 간접적으로 영향이 있을수도있음
	2.일괄 처리와 스트림 처리
	  일괄처리나 스트림처리나 출력은 파생데이터셋이고,둘은 많이 비슷함
	  주요 차이점은 일괄은 유한한크기의 입력이라는거고,스트림은 무한한크기의 입력이라는것
	  
	  그래서 아예 스트림을 작을크기의 배치로 생각해서 구현한애들도 있음
	  
	  일괄처리는 강력한 함수형적 특징을 가짐
	  결정적이고,순수함수일 가능성이 높음
	  스트림도 비슷하지만 연산자를 확장해 상태를 관리할수있고 내결함성을 가짐
	  
	  파생데이터를 유지할떄 배치와 스트림 모두 유용함
	  스트림은 입력변화를 빠르게 파생뷰에 반영할수있고,배치는 누적된 과거데이터를 재처리해 새 파생뷰를 만들수있음
	  이런 파생뷰를 사용하면 점진적발전이 가능함
	  즉 기존 뷰들을건드리지않고,새 뷰를 만들어서 처리하다가 옮기는식으로 할수있음
	  
	  람다 아키텍처는 이벤트소싱과 개념이 거의 같음
	  즉 입력데이터를 불변이벤트로 증가하기만하는 데이터넷에 추가하는방식으로 기록하는것,단 문제가 좀 있어서,요즘은 그냥 한 시스템내에서 일괄과 스트림을 통합함
	  
  2.데이터베이스 언번들링
    추상화수준에서는 db나 운영체제나 하둡이나 다 같은기능을 수행함
	물론 실제로는 차이가 많지만
	
	유닉스는 저수준 하드웨어 추상화를 프로그래머에게 제공하고,rdb는 고수준 하드웨어추상화를 제공함
	이건 뭘 원하냐에따라 쓸수있는게 달라진다는것
	
	여긴 사실상 지금쓰진 못하는내용이라 대부분생략
	
	1.데이터 저장소 기술 구성하기
	  색인생성과 팔로워 복제본 구축,변경데이터캡처의 예비과정은 매우 비슷함
	  셋다 스냅숏을 가지고 풀테이블 스캔해서 기록하는식
	  
	  전체 조직의 데이터플로는 거대한 db로 볼수도있음
	  이때 배치나 스트림등을 통해 데이터를 특정장소의 특정형태에서 다른장소의 다른형태로 전송하는식임
	
  3.정확성을 목표로
    상태가 없는 서비스는 문제가 생겨도 버그를 고치고 배포하면 끝임
	근데 db같은 상태저장시스템은 버그를 고쳐도 잘못된 효과가 영원히 남아있음
	
	또한 db문제가 아니라 어플리케이션이 정확하지 않은 데이터를 기록하거나 삭제한다면 트랜잭션도 이걸 해결해줄순없음
	
	연산을 정확히 한번 실행하게 만드는 가장 효과적인 방법은 멱등성을 가지게 연산을 만드는것(추가 메타데이터,즉 버전같은걸사용할수있음)
	
	1.제약조건 강제
	  유일성 제약은 합의가 필요함,그래서 가장 일반적인방법은 단일리더임
	  
	  로그는 모든 소비자가 같은순서로 메시지를 보는걸 보장함,이걸 전체순서 브로드캐스트라고 부르고 합의와 동일함
	  여기서 유일성을 강제할땐,유일성이 필요한값을 기준으로 로그를 파티셔닝하면
	  스트림처리자는 충돌이 발생한 연산중 어떤것이 처음 들어온 연산인지 분명하고 결정적으로 판결할수있음
	  
	  즉 원자적커밋같은게 없어도 단일리더같은느낌이기때문에 항상 순서가 같다는게 보장됨
	  
	2.적시성과 무결성
	  트랜잭션은 선형성이 있음
	  이게 스트림으로 연산을 언번들링하는것과는 좀 다름(이건 비동기)
	  트랜잭션은 동기식으로 동작하고(커밋성공을 반드시 기다려야함),스트림은 기다려도되고 안기다려도됨(그게 꼭 일어나지않아도 된다면 넘어가도됨)
	  
	  일관성이란 
	    적시성(사용자가 항상 최신상태를 관측가능함,이게 깨지면 최종적 일관성)
	    무결성(손상이 없음,즉 누락,모순,잘못된 데이터가 없음,이게깨지면 영구적불일치)
	  이 두가지 요구사항을 통틀어서 말함
	  대부분 무결성이 훨씬 중요하고,적시성은 좀 없어도 되는경우가 많음
	  
	  보통 acid 트랜잭션은 적시성(선형성)과 무결성(원자적커밋) 모두를 보장함
	  근데 이벤트 기반 데이터플로에선 이 둘을 분리할수있음
	  즉 이벤트스트림을 비동기로 처리하고,소비자가 반환하는 메시지를 기다리지않으면 적시성은 보장되지않지만,없어도 되는경우가 많고 이럴때 성능을 올릴수있음
	  즉 정확히 한번 처리되는거만 가져가는거
	  
	  유일성 제약을 강제하려면 합의가 필요함
	  근데 많은 어플리케이션은 훨씬 완화된 유일성을 사용해도됨(같은이름 중복일경우 둘중 한명한테 사과메시지를 보냄,즉 보상트랜잭션)
	  즉 제약조건을 일시적으로 위반하고 나중에 바로잡는건 사용가능한 방법임
	  이건 비즈니스적 결정사항임
	  
	  이렇게 되면 굳이 코디네이터없이도 데이터플로를 만들수있어짐
	  이러면 성능이 올라가고 내결함성이 나아짐
	  
	3.믿어라 하지만 확인해라
	  프로세스는 항상 죽을수있고,소프트웨어 버그나 하드웨어의 알려지지않은문제는 항상 발생할수있음
	  즉 약속은 항상 깨질수있고,손상은 반드시 발생함
	  그래서 데이터가 손상됐는지를 알수있는 방법은 있어야함(감사)
	  
	  트랜잭션로그를 캡쳐하더라도,왜 이걸 했는지는 알기 어려움
	  그래서 이벤트기반은 좀 더 나은 감사 기능을 제공함
	  또한 해시를 사용해서 이벤트저장소가 손상됐는지도 알수있음
	  
	  시스템의 모든 개별 구성요소가 절대로 손상되지않는다고 믿기 어렵다면,최소한 데이터의 무결성만이라도 주기적으로 확인해야함
	  이걸 확인하는방법은 종단간 방식이 최선임
	 
  4.옳은일하기	 
    스킵
	
	
	
	
	
	
	
	
	
	
	
	
