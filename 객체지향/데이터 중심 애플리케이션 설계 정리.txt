1.신뢰할수있고 확장가능하며 유지보수하기 쉬운 어플리케이션
  요즘 어플리케이션은 계산중심이 아니라 데이터중심적임
  그래서 병목이 데이터의 양,복잡도,변화속도에 걸림
  
  데이터 중심 어플리케이션은,공통적으로 필요로하는 기능을 제공하는 표준 구성 요소를가짐
	데이터를 다시 찾을수있게함 (db)
	읽기속도 향상을 위해 값비싼 수행결과를 기억(캐시)
	사용자가 키워드로 데이터를 검색하거나 다양한방법으로 필터링할수있게 제공(검색색인)
	비동기처리를 위해 다른 프로세스로 메시지 보내기(스트림처리)
	주기적으로 대량의 누적된 데이터를 분석(일괄처리,즉 배치)]
  이런것들이 다 추상화되어서 들어가지만,어플리케이션마다 요구사항이 달라서,db시스템또한 저마다 다양한 특성을 가지고,
  어플리케이션을 만들때 어떤 도구와 어떤 접근방식이 수행작업에 가장 적합한지를 생각해야함
  
  1.데이터 신뢰성에 대한 생각
	db와 큐 캐시등을 달라보이고,실제로 매우 다른 접근패턴을 가지지만 데이터시스템이라는 포괄적 용어로 묶을수있음
	이유는,
	  1.레디스(메시지큐 데이터스토어)나 카프카(지속성을 보장하는 메시지큐)등으로 인해 분류간 경계가 흐려짐
	  2.많은 어플리케이션이 단일도구로는 더이상 데이터처리와 저장 모두를 만족시킬수 없는 과도하고 광범위한 요구사항을 가지고있음,
		대신 작업은 단일도구에서 효율적으로 수행할수있는 태스크로 나누고,다양한 도구들은 어플리케이션 코드를 이용해 서로 연결함
	  3.서비스제공을 위해 각 도구를 결합할땐,인터페이스로 클라이언트가 세부사항을 모르게 숨김(포트),그래서 어플리케이션이 접근할땐 다 동일하게 접근할수있음
	이런 이유등이 있음
	
	데이터 시스템이나 서비스를 설계할때 가장 중요한건
		신뢰성:결함,인적오류등이 생겨도 시스템은 지속적으로 올바르게 동작(원하는성능수준에서 정확한기능을 수행)해야함
		확장성:데이터량,트래픽량,복잡도가 증가하면서 이를 처리할수있는 적절한 방법이 있어야함
		유지보수성:모든 사용자가 시스템상에서 생산적으로 작업할수있어야함
	이 3가지임

  2.신뢰성
  	  소프트웨어는
	    어플리케이션은 사용자가 기대한 기능을 수행
	    시스템은 사용자가 범한 실수나 예상치못한 소프트웨어 사용법을 허용할수있음
	    시스템 성능은 예상된 부하와 데이터양에서 필수적인 사용사례를 충분히 만족함
	    시스템은 허가되지않은 접근과 오남용을 방지함
	  보통 이정도를 기대하는데,대충 무언가 잘못되더라도 지속적으로 올바르게 동작함 이라고 생각하면됨
	
	  이떄 잘못될수있는일을 결함이라고 하고,결함을 예측하고 대처할수있는 시스템을 내결함성,또는 탄력성을 지녔다고 함
	  물론 모든종류의 결함을 견딜수는 없음(전쟁나서 서버에 폭탄터졌는데 웹서버가 그걸 버틸수는없음)
	
	  결함은 장애와 동일하지않음
	  결함은 사양에서 벗어난 시스템의 한 구성요소로 정의되지만,장애는 사용자에게 필요한 서비스를 제공하지못하고 시스템 전체가 멈춘경우임
	  결함확률을 0으로 줄이는건 불가능하고,그래서 결함으로 장애가 발생하지않게 내결함성을 챙기는게 가장좋음
	
	  이를 테스트하려고 카오스몽키같은걸 쓸수도있고,예방책이 해결책이 더 좋은경우도 있음(해킹같은거)
	  
	1.하드웨어결함
	  시스템 장애의 원인중 대표적인게 하드웨어결함이고,이건 규모가 커지면 늘상 일어남
	  보통 이걸 해결하는방법은 각 하드웨어구성요소에 중복을 추가하는것(raid같은거),아니면 클라우드로 노드를 여러개쓰는방법도 있음
	  
	2.소프트웨어 오류
	  보통 하드웨어결함은 서로간에 별로 상관관계가 없음,근데 시스템 내의 체계적오류는 예상하기 더 어렵고,노드간 상관관계때문에 시스템오류를 더욱 많이 유발함
		잘못된 특정입력이 있을때 모든 어플리케이션 서버인스턴스가 죽는 버그
		cpu,메모리,디스크공간등 공유자원을 과도하게 사용하는 일부프로세스
		시스템속도가 느려져 반응이 없거나 잘못된 응답을 반환하는 서비스
	  등이 있음
	  
	  이런 소프트웨어결함은 특정 상황에 의해 발생하기전까지 오랫동안 나타나지않음,즉 소프트웨어는 환경에 대한 일종의 가정이 있고,
	  이 가정은 대개 문제없지만 어떤이유로 문제가 생기게됨(가정이 꺠지게됨)
	  
	  이런 문제는 신속한 해결책이 없고,테스트,프로세스격리,죽은프로세스의 재시작허용,모니터링등으로 해결해야함
	  로깅을 해서 그걸 모니터링하는방법도 있음
	
	3.인적오류
	  사람은 가장 중단의 메인 원인임
	  그래서
	    오류를 최소화하는 방향으로 시스템을 설계(추상화)
		가장 많이 실수하는장소에서 실수로 장애가 발생하는 부분을 분리
		샌드박스의 제공
		단위테스트부터 통합테스트등을 철저히 테스트
		인적오류를 빠르고 쉽게 복구할수있게 하기(롤백 롤아웃가능하게)
		성능지표와 오류율등을 모니터링하기
	  등을 해야함
	
	4.신뢰성은 얼마나 중요할까?
	  버그는 생산성저하의 원인이고,어플리케이션은 사용자에 대한 책임이 있음
	  스타트업에서 비용을 줄이려고 신뢰성을 희생해야하는경우가 있지만,이때는 신뢰성을 다시 돌려놓는 지점을 잘 알아야함

  3.확장성
	시스템이 현재 안정적으로 동작한다고 미래에도 안정적으로 동작한다는 보장은 없음
	보통 부하증가로 인해 성능이 저하됨
	
	확장성은 증가한 시스템능력을  설명하는데 사용하는 용어지만,시스템에 부여하는 일차원적 표식이 아님
	이건 
	  시스템이 특정 방향으로 커지면 이를 대처하기위한 선택은 무엇인가?
	  추가부하를 다루기위해 계산자원을 어떻게 투입할까?
	같은 질문을 고려한다는 의미임
	
	1.부하기술하기
	  가장 먼저 해야하는건,시스템의 현재 부하를 간결하게 기술해야함,그래야 부하성장질문(부하가 2배커지면 어떻게하지?)를 논의할수있음
	  부하는 부하매개변수라 부르는 몇개의 숫자로 나타낼수있는데,
	  예를들어
	    웹서버의 초당 요청수
		db의 읽기 대 쓰기 비율
		대화방의 동시 활성 사용자
		캐시 적중률
	  등이 있음
	  
	  이떄 평균적인 경우가 중요할수도 있고,소수의 극단적인 경우가 병목의 원인일수도있음
	  즉 어플리케이션의 현재 상황에 맞춰서 선택해야함
	
	2.성능 기술하기
	  부하를 기술했으면,부하가 증가할때 어떤일이 일어나는지 조사할수있음
	    부하 매개변수를 증가시키고 시스템 자원은 변경하지않는다면 시스템 성능은 어떻게영향을 받을까?
		부하 매개변수를 증가시켰을때 성능이 변하지않고 유지되길 원한다면 자원을 얼마나 많이 늘려야할까?
	  둘 다 성능수치가 필요함
	  
	  하둡같은 일괄처리시스템은 처리량에 관심을 가지고,온라인시스템은 서비스응답시간을 관심을 가짐
	  
	  응답시간은 매번 값이 다르니,값의 분포로 생각을 하고 중앙값(p50)과 p95,p99정도를 봐야함
	  또한 시스템의 확장성을 테스트하려고 인위적으로 부하를 생성할땐,응답시간과 독립적으로 요청을 지속적으로 보내야함
	  클라가 다음 요청을 보내기 전에 이전 요청이 완료되길 기다리면,테스트가 왜곡됨
	
	3.부하 대응 접근 방식
	  기본적으로 스케일업은 비싸니,스케일 아웃이 가능하게해야하고,시스템은 탄력적이면 부하가 예측할수없을만큼 높으면 유용하지만,
	  수동으로하는게 예상치못한일은 더 적음
	  
	  또한 스테이트리스가 다수의장비에 배포하기 쉽고,스테이트풀을 분산설치하는건 매우 복잡도가 높음
	  
	  모든곳에 맞는 아키텍처는 없고,읽기의양,쓰기의양,저장할데이터의 양,데이터의 복잡도,응답시간요구사항,접근패턴등을 고려해서 선택해야함
	  즉 이런 가정을 바탕으로 확장성을 체크하는데,이 가정이 틀려버리면 확장을 위한 노력은 다 헛수고가 되고,역효과를 낳을수도있음
	  그래서 스타트업초기단계에선 확장보단 빠르게 반복해서 제품기능 개선하는게 나음
  
  4.유지보수성
    유지보수에서 중요한건
	  운용성:운영팀이 시스템을 원활하게 운영할수있게 쉽게 만들자
	  단순성:시스템에서 복잡도를 최대한 제거해 새 엔지니어가 시스템을 이해하기 쉽게 만들자
	  발전성:엔지니어가 시스템을 쉽게 변경할수 있게 하자
	이 3가지임
	
	신뢰성과 확장성을 달성하는 쉬운방법은 없지만,최소한 유지보수성은 챙겨가야함
	
	1.운용성:운영의 편리함 만들기
	  운영의 일부는 자동화할수있지만,이 자동화를 처음 설정하고 테스트하는건 사람의 몫임
	  
	  시스템이 지속해서 원활하게 작동하려면 운영팀이 필수고,좋은 운영팀은
		시스템상태를 모니터링하고 상태가 좋지못하면 빠르게 서비스를 복원
		시스템장애,성능저하등 문제의 원인을 추적
		보안패치를 포함해 소프트웨어와 플랫폼을 최신상태로 유지
		다른시스템이 서로 어떻게 영향을 주는지 확인해,문제가 생길수있는 변경사항을 손상을 입히기 전에 차단
		미래에 발생가능한 문제를 예측해 문제가 발생하기전에 해결
	  이런일들을 함
	  
	  또한 좋은 운영성이란 동일하게 반복되는 태스크를 쉽게 수행하게 만들어,고부가가치활동에 노력을 집중할수있게함
	
	2.단순성:복잡도관리
	  프로젝트가 커지면 시스템은 매우 복잡하고 이해하기 어려워짐
	  보통
		상태공간의 급증
		모듈간 강한 커플링
		복잡한 의존성
		일관성없는 명명과 용어
		성능문제해결을 목표로한 해킹
		임시방편으로 문제를 해결한 특수사례
	  등이 있음
	  
	  보통 복잡도가 올라가서 유지보수가 어려워지면 예산과 일정이 초과됨
	  변경이 있으면 버그가 생기기 쉽기때문
	  
	  또한 개발자가 시스템을 이해하고 추론하기 어려워지면,시스템에 숨겨진 가정과 의도치않은 결과 및 예기치 않은 상호작용을 간과하기 쉬움
	  반대로 복잡도를 줄이면 유지보수성이 크게 향상됨,즉 단순성이 시스템의 핵심목표임
	  
	  시스템을 단순하게 만든다는게 기능을 줄인다는걸 의미하진않고,우발적 복잡도를 줄이는게 목표임
	  이걸위해 추상화를 사용함
	
	3.발전성:변화를 쉽게 만들기
	  시스템의 요구사항은 계속 바뀜,이걸 민첩하게 받아들일수 있는게 발전성임
	  이때마다 쉽게 변화를 줄수있어야함,이를위해 tdd등을 사용할수있음
	  
	  이건 단순성(과 추상화)에 영향을 많이받음
  
  5.정리
    어플리케이션은 기능적 요구사항(동작해야하는 기능)과 비기능적 요구사항(유지보수성,단순성,신뢰성등)을 충족시켜야함
	
	신뢰성은 결함이 발생해도 시스템이 올바르게 동작해야한다는것
	확장성은 부하가 증가해도 좋은 성능을 유지하기 위한 전략
	유지보수성은 엔지니어와 운영팀의 삶을 개선하는데 목적이 있음(즉 변경코스트를 줄이는데 목적이 있음)
	
2.데이터모델과 질의언어
  데이터모델은 소프트웨어가 해결하려는 문제를 어떻게 생각해야하는지에 대해 지대한 영향을 미침
  
  대부분의 어플리케이션은 하나의 데이터모델을 다른 데이터모델 위에 계층을 둬서 만듬
  각 계층의 핵심문제는,다음 하위 계층 관점에서 데이터모델을 표현하는 방법임
  또한 각 계층은 명확한 데이터모델을 제공해서 자신보다 하위계층의 복잡성을 숨김(추상화)
  
  1.관계형 모델과 문서 모델
    대표적으로 나누면 rdbms와 nosql이 있음
	알디비의 근원은 비즈니스 데이터처리에 있고,이건 트랜잭션과 일괄처리가 핵심이었음
	
	1.nosql의 탄생
	  nosql은 not only sql로,이건
		높은 쓰기처리량을 쉽게 할수있는 확장성
		알디비에서 지원하지않는 특수질의
		알디비의 스키마에 대한 불만과 더 동적인 데이터모델에 대한 바램
	  으로 인해 나왔음 
	  
	2.객체 관계형 불일치
	  알디비의 문제는,객체와 스키마는 동일하지않고,이를 전환하기위해 전환계층이 필요함
	  이걸 임피던스 불일치라고 부름
	  
	  orm은 이때의 보일러플레이트를 줄여주지만,각 모델간의 차이를 완벽히 숨길수는 없음
	  이때 알디비로 각 테이블을 다 분리해서 쪼개는거보다(정규화),그냥 문서모델로 문서처럼 때려박는게 더 객체와 비슷한 표현이 되는경우가 있음
	  보통 sql쿼리는 복잡한 다중조인을 통해서 가져와야하기때문,근데 json표현에서는 해당 문서만 가져오면됨(보통 트리구조일떄 적합함)
	
	3.다대일과 다대다 관계
	  보통 정규화를 하는 이유는,
		일관된 스타일과 철자(오타방지)
		모호함 회피(같은이름 중복일때 다른id로 처리가능)
		갱신의 편의성(정규화테이블만 수정하면됨)
		현지화 지원(id값만 가져오니 거기에 추가로 필드덧대기가능)
		더 나은 검색(역방향 조회가능)
	  가 있음
	  즉 중복회피로 인한 실수방지와 갱신편의성,데이터 무결성보장,역방향조회등이 정규화의 핵심임
	  
	  중복된 데이터를 정규화하려면 다대일관계가 필요한데,이건 문서모델(nosql)에 적합하지않음
	  문서모델은 조인에 대한 지원이 약하기때문
	  어케어케 해결할수있긴하지만..
	  
	  또한 어플리케이션의 초기버전이 조인이 없는 문서모델에 적합하더라도,기능을 추가하면서 데이터는 점차 상호연결되는 경향이 있음
	
	4.문서 데이터베이스는 역사를 반복하나?
	  문서모델도 일대다에서는 잘 동작하는데,핵심은 다대다(와 다대일) 관계 표현임
	  이때 데이터를 중복할지 또다른 레코드와의 참조를 수동으로 해결할지를 결정해야함
	  
	  일단 문서모델도 문서참조(알디비의 외래키)를 사용해서 고유한 식별자로 해결하고있고,이건 조인이나 후속질의를 사용해서 읽기시점에 확인함
	
	5.관계형 db와 문서모델
	  이 두개는 내결함성과 동시성처리를 포함해 고려해야할 차이점이 많이있지만,데이터모델의 차이점에만 우선 집중하자면
	  문서모델은 스키마 유연성,지역성에 기인한 더 나은성능,특정 어플리케이션에서는 객체와 더 가깝기 때문에 선호도가 있고
	  관계형db는 조인,다대일,다대다 관계를 더 잘지원함
	  
	  어플리케이션의 데이터가 문서와 비슷한 구조(트리형태)라면 문서모델을 사용하는게 좋음
	  즉 특정 id를 가져오면 해당하는 데이터 전체가 필요한경우에 적합
	  알디비는 이런경우에 복잡한 스키마와 복잡한 어플리케이션 코드를 발생시킴
	  
	  문서모델의 미흡한 조인도,조인을 사용하지 않는 구조라면 상관없음
	  
	  단,어플리케이션에서 다대다관계가 필요하다면 문서모델은 매력이 떨어짐
	  비정규화로 어느정도 조인필요성 감소는 가능하긴하지만,이럴경우 어플리케이션의 복잡도가 올라가고,무엇보다 알디비보다 더 느림
	  
	  보통 상호연결이 많으면 문서형 모델은 별로고,관계형모델이 무난하고,그래프모델은 더 나음
	  
	6.문서모델에서의 스키마 유연성
	  보통 문서형 db와 알디비의 json은 어떤 스키마를 강요하지않음
	  그래서 스키마리스로 불리지만 정확히는 읽기스키마임,읽을때는 형식이 있지만 쓸때는 형식이 없어도됨
	  반대로 알디비는 쓰기스키마고
	  
	  이 둘은 약타입언어와 강타입언어와의 관계와 비슷함
	  
	  이렇게 읽기스키마의 장점은,데이터타입 변경이 쉽다는거고(그냥 다르게 넣으면됨,변경시에 예전걸 읽었을때의 처리만 있으면됨),
	  쓰기스키마는 이럴경우 마이그레이션을 해야함
	  
	  즉 읽기쓰키마는 컬렉션안의 항목이 어떤이유로 모두 동일한 구조가 아닐때 유리함
		다른 여러유형의 오브젝트가 있고 각 유형별 오브젝트로 자체테이블에 넣는건 실용적이지않음
		사용자가 제어할수없는 언제나 변경가능한 외부시스템에 의해 데이터구조가 결정됨
	  단,모든 레코드가 동일한구조라서 예상가능하다면 그냥 스키마 가져가는게 맘편함,이래야 문서화와 구조강제가 쉬움
	  
	7.질의를 위한 데이터 지역성
	  문서는 json으로 보통 저장됨,그래서 어플리케이션이 자주 특정 문서의 전체에 접근해야하면 이때의 지역성을 활용하면 성능이점이 있음
	  단 이건 한번에 해당 문서의 많은 부분을 필요로 할때만 적용됨
      작은 부분만 필요할떄는 전부 읽어야한다는게 낭비고,문서를 갱신할떄도 전체를 재작성해야함
	   
	  그래서 보통 이런 문서모델의 db는 문서를 아주 작게 유지하고,문서의 크기가 증가하는 쓰기를 피하려고 노력함
	  이거때문에 문서db가 유용한 상황이 많이 줄어듬
	   
	8.문서db와 관계형db의 통합
	  요즘은 관계형db도 요즘은 다 json을 지원하고,문서형db도 조인을 지원하는등 서로간에 비슷해지고있음
	
  2.데이터를 위한 질의 언어
    sql은 선언형임,즉 원하는걸 말하면 알아서 해석해서 거기에 맞는값을 돌려주지,내가 뭘 시키지않음(이건 옵티마이저가 할일)
    즉 동작이 추상화되어있어서 내부동작을 디비개발자가 알아서 수정해도 별 문제를 일으키지않음
    
    또한 sql은 기본적으로는 순서를 보장하지않아서,이부분을 활용한 성능최적화도 가능하고,특히 병렬실행도 쉬움
	1.웹에서의 선언형 질의
	  css도 이런식으로 선언형 질의라고 할수있음
	  특정 어디에 있는 뭘 바꾸라고 하는게 아닌,특정 id인걸 바꾸던가 이런식이니까
	2.맵리듀스 질의
	  맵리듀스는 많은 컴퓨터에서 대량의 데이터를 처리하기위한 프로그래밍모델이고,이건 몽고db같은 일부 nosql에서 제한된 형태로 지원함	  
	  이건 많은 문서를 대상으로 읽기전용 질의를 수행할때 사용됨
	  
	  이건 선언형과 명령형의 중간에 있음
	  선언형으로 데이터를 줄인다음,명령형으로 그 데이터를 가공하는 느낌임
	  느낌적으론 select절 서브쿼리와 from절 서브쿼리같은 느낌임,데이터를 일단 가져와서 수정하는느낌
	  
	  몽고db의 map과 reduce함수는 둘 다 순수함수여야함

  3.그래프형 데이터 모델
    데이터에서 다대다관계가 매우 일반적이라면 그래프로 데이터를 모델링하는게 더 자연스러움(페이스북)
	그래프는 두 유형의 객체로 이루어짐
	  정점(노드,엔티티라고도 부름)
	  간선(관계,호라고도 부름)
	예를들면 소셜그래프에서 정점은 사람이고 간선은 인지여부,웹그래프에서 정점은 웹페이지고 간선은 링크 이런식
	
	근데,이런 그래프형 관계에서 가장 좋은점은,동종 데이터에 국한되지 않는다는점임
	즉 사람이라는 정점에서 인지여부라는 간선을 쓰다가,사람에다가 사는위치라는 간선을 긋고 지역이라는 정점으로 연결시키는게 가능함
	
	이런 서로 다른 여러유형의 정점과 간선을 단일그래프로 유지할수있다는게 가장 좋은점임
	
	그래프의 종류에는 속성그래프와 트리플그래프등이 있음
	
	1.속성그래프
	  속성그래프 모델에서 각 정점은
	    고유식별자(id)
		유출간선집합
		유입간선집합
		속성컬렉션(키값쌍,즉 맵)
	  으로 구성됨
	  
	  또한 각 간선은
	    고유식별자(id)
		간선이 시작하는 정점(꼬리정점)
		간선이 끝나는 정점(머리정점)
		두정점간 관계 유형을 설명하는 레이블
		속성컬렉션(맵)
	  으로 구성됨
	  
	  머리와 꼬리 정점은 각 간선마다 저장되고,정점을 위한 유입간선과 유출간선의 집합이 필요하면,간선테이블에서 조회하면됨
	  이떄 핵심은
	    정점은 다른 정점과 연결하려면 간선을 사용해야함,이때 특정 유형과 관련여부를 제한하는 스키마는 없음
		정점이 있으면 정점의 유입과 유출간선을 효과적으로 찾을수있고,그래프순회가 쉬움(꼬리나 머리타고 재귀,이를위해 꼬리머리 인덱스를 만들어둬야함)
	  이걸통해 전통적인 관계형 스키마에서 표현하기 어려운 사례 몇가지를 해결할수있음
	  국가,지역구조나,
	  각각 사람이 자기가 가진 알레르기원인물질에 간선을 연결할수있게하고,이걸통해 어떤 집합에서 먹을수있는 음식을 쉽게 알아내는방식으로 질의할수있음
	
	2.사이퍼 질의 언어
	  사이퍼는 속성그래프를 위한 선언형 질의언어로,네오포제이용으로 만들어짐
	  이걸 사용하면,특정 조건의 간선들을 가진(미국에서 태어났고 한국에서 살고있는 등)정점들의 집합등을 찾기가 매우 쉬움
	  즉 특정 간선이 존재하는지,특정 간선을 끝까지 재귀했을떄의 값이 무엇인지 이 두개를 하나로 묶은 조건들의 집합을 가지고 쿼리하기 편하다는것
	  
	  이떄 값(레이블)에 대해 인덱스가 있다면 매우 효율적으로 찾을수있음(선언형이니까 저런거 선택은 옵티마이저가 하니까 날로먹을수있음)
	
	3.sql의 그래프 질의
	  관계형 db에서도 그래프 데이터를 표현할수는 있지만,재귀를 타는게 매우 복잡함(mysql의 리커시브만 생각해도 머리아픔)
	  결국 이런형태가 필요하다면 그래프db를 사용하는게 나음
	
	4.트리플 저장소와 스파클
	  이건 속성그래프모델과 거의 똑같음,그냥 용어만 다름
	  
	5.시맨틱 웹
	  솔직히 별로 관계없는토픽인데,그래프 구조를 사용해서 웹을 그래프구조로 만들자 뭐 이런 프로젝트같은거임
	  그러니까 시맨틱 웹이 그래프모델을 사용(의존)하는거지,그래프모델에서는 시맨틱웹과 의존성이 없음
	
  4.정리
    nosql은 크게 문서db랑 그래프db로 나눠짐
		문서db는 데이터가 문서 자체에 포함되어있고,하나의 문서가 다른 문서와 관계가 거의 없는 사례에 적합하고
		그래프db는 모든것이 잠재적으로 관련있다는 사용 사례를 대상으로 함
	관계형,문서,그래프 전부 다 각 모델이 어울리는곳이 있고,다른영역을 흉내낼수는있지만 결과물은 대부분 엉망이 됨
	
	문서나 그래프 db가 가진 공통점중 하나는,스키마를 강요하지않아 요구사항변경에 맞춰 어플리케이션을 쉽게 변경할수있다는것
	단 어플리케이션은 데이터가 특정 구조를 갖는다고 가정할거임(읽기스키마)
	 
	  
	  
3.저장소와 검색
  1.데이터베이스를 강력하게 만드는 데이터 구조
    가장 기본적인 데이터베이스는,단순히 파일 끝에 키-값 한줄씩을 저장하면됨
	그러니 최신값을 찾으려면 키의 마지막항목을 찾아보면됨
	이런식으로 하는게 로그방식임
	이건 쓰기성능은 매우 좋지만,읽기성능은 매우좋지않음(거의 대부분이 O(n))
	
	그래서 나오는게 색인(인덱스)임
	색인의 일반적인 개념은 어떤 부가적인 메타데이터를 사용하고,이 메타데이터는 이정표 역할을 해서 원하는 데이터의 위치를 찾는데 도움을 줌
	같은 데이터를 여러 방법으로 검색하려면,여러 색인이 필요함
	
	색인은 기본데이터에서 파생된 추가적인 구조고,그래서 색인의 추가와 삭제는 자유롭고,이때 db의 내용에 영향을 미치지않음(질의속도에만 영향을 줌)
	색인의 구조상 쓰기량이 늘어나니,색인을 사용하면 무조건 쓰기성능이 저하됨
	
	여기서 트레이드오프가 있는데,색인을 추가하면 반드시 쓰기성능이 떨어지고,색인을 잘 선택하면 읽기질의속도가 향상됨
	그래서 색인을 잘 선택해야함
	
	1.해시색인
	  보통 키값저장소는 해시맵으로 구현함,
	  그래서 가장 간단한 색인은 키를 바이트오프셋에 매핑해서 인메모리해시맵을 유지하는게 가장 간단함
	  즉 키와 그 키의 바이트위치를 저장해두면서,원래있던키의 변경이나 새 키의 생성이 들어오면 그냥 마지막에 적고,
	  찾을때는 마지막부터 처음 하나를 만날때까지 서치하는식
	  
	  이걸 단순히 파일하나에 계속 쌓으면 디스크공간이 부족해지니,특정크기의 세그먼트로 나눠가면서 적고
	  
	  물론 이대로만 하면 삭제,동시성제어든 신경써야할게 좀 더 많긴한데,원리적으로는 이런식
	  이런식으로 추가전용로그는 낭비처럼 보이지만,쓰기성능이 매우 좋고,고장복구도 매우좋음(이전값을 지우지않으니까)
	  
	  단,해시테이블은 메모리에 저장해야하므로 키가 너무많으면 문제가되고
	  범위질의에 효율적이지않음(O(n)으로 전체서치해야함)
	
	2.ss테이블과 lsm트리
	  이전 세그먼트파일(위에거)에서 키값쌍을 키로 정렬하는 추가사항을 넣으면 이게 ss테이블(정렬된 문자열 테이블)임
	  이떄의 키 중복은,가장 최근세그먼트의 값만 유지하고 오래된 세그먼트의 값은 버리는식으로 처리가능
	  
	  이런식으로 하면 메모리에 모든 키색인을 유지할필요가 없고(정렬되있으니까 대충 그위치가서 찾으면됨,적당히 일부키에 대한 위치만 알고있으면됨,이진탐색용)
	  색인검색의 특성상 디스크공간압축과 io대역폭사용도 줄일수있음
	  
	  이떄 데이터를 키로 정렬하려면,디스크상에 정렬된 구조를 유지하는거보단 메모리에 유지하는게 훨씬 쉬움
	    쓰기가 들어오면 밸런스트리(멤테이블이라고 부름)에 추가하고
	    멤테이블이 특정임계값(보통 4mb정도)보다 커지면 디스크에 기록함,이때 트리는 정렬되어있음
		읽기요청이 들어오면 멤테이블에서 찾고,그다음엔 최신세그먼트에서 찾는식으로 반복
		가끔 세그먼트파일을 합치고 덮어쓰여지거나 삭제된값을 버리는 병합과 컴팩션을 수행하면됨
		
	  이건 잘 동작하지만,컴퓨터가 꺼지면 메모리에 있던게 유실되는 단점이 있음,
	  그래서 매번 쓰기를 즉시 추가할수있게 분리된 로그를 디스크상에 유지해야함
	  이건 복원시에만 사용되기때문에 정렬이 필요없고,디스크에 저장하고나면 쌓였던건 버리면됨
	  
	  이 ss테이블을 기본 베이스로 깐 구조가 로그 구조화 병합 트리(lsm트리)임
	  
	  물론 이거만 가지곤 동작이 좋지않고,세부사항들이 있음
	  없는키조회시 O(n)을 막기위한 블룸필터(키가 있는지없는지를 알려줌)
	  ss테이블을 압축하고 병합하는 순서와 시기를 결정하는 전략들 등이 있음
	
	3.b트리
	  가장 일반적인 색인 유형은 b트리임
	  로그구조화색인이 db를 수 메가바이트의 가변크기를 가진 세그먼트로 나누고,순차적으로 세그먼트를 기록한다면
	  b트리는 4kb의 고정크기 블록이나 페이지로 나누고,한번에 하나의 페이지에 읽기 또는 쓰기를 함
	  
	  각 페이지는 주소나 위치를 통해 식별할수있고,이 방식으로 하나의 페이지가 다른 페이지를 참조할수있음
	  이걸통해 페이지트리를 만들수있음
	  대충  
		ref1 100  ref2  200 ref3 300...
	  이런식의 루트트리에서 251을 조회하면 200과 300의 사이인 ref3으로 타고 내려가는식임
	  그러다가 리프페이지를 만나면 키가 있거나 없거나를 확인할수있음
	  
	  키를 추가할때는 새 키를 포함해야하는 범위의 페이지를 찾아서 해당 페이지에 키값을 추가하고,
	  여유공간이 없으면 페이지하나를 두개로 쪼개고,상위를 갱신함
	  
	  이 알고리즘은 트리가 균형을 유지하는걸 보장함(깊이가 O(log n)임을 보장함)
	  
	  b트리의 기본쓰기동작은 새 데이터를 디스크상의 페이지에 덮어씀
	  이 동작은 덮어쓰기가 페이지위치를 변경하지않는다고 가정함,즉 페이지를 덮어쓰더라도 페이지를 가리키는 모든 참조는 그대로 남음
	  
	  페이지 분할시 같은,여러페이지를 동시에 건드려야할때,중간에 컴퓨터가 뻗으면 위험해지는데,이걸 방지하기위해 쓰기전 로그를 미리 만들어두고 실행후 제거함
	  만약 db가 켜졌을떄 쓰기전로그가 남아있다면,그걸 확인하고 다시 작업하는식임
	  
	  또한 같은자리의 페이지를 갱신할때(다중스레드),동시에 접근할수있기때문에 이런경우 래치로 보통 보호함
	
	4.b트리와  lsm트리 비교
	  b트리와 lsm트리는,보통 b트리가 읽기에서 더 빠르고,lsm트리는 쓰기에서 더 빠름
	  또한 b트리가 구현성숙도가 더 높긴함(오래돼서)
	  물론 세부사항에 따라 속도도 다 다르긴함
	  
	  b트리색인은 모든 데이터조각을 최소한 두번 기록해야함(쓰기전로그와 트리페이지)
	  또한 해당 페이지내 몇바이트만 바뀌어도 전체페이지를 기록해야하는 오버헤드도 있음 
	  
	  로그구조화색인은 반복된 컴팩션과 병합으로 인해 여러번 데이터를 다시쓰는데,이걸 쓰기증폭이라고 부름
	  ssd에선 쓰기횟수가 제한되기때문에 특별한 관심사임
	  
	  쓰기가 많은 어플리케이션에서 성능병목은 db가 디스크에 쓰는속도일수있음,이떈 쓰기증폭이 성능비용임
	  더욱이 lsm트리는 b트리보다쓰기처리량을 높이기 쉬움(순차쓰기떄문),또한 압축률이 b트리보다 좋음
	  
	  b트리는 파편화가 좀 있음
	  
	  lsm트리의 단점은 컴팩션과정이 읽기쓰기 성능에 영향을 준다는것
	  또한 컴팩션 설정을 주의깊게 하지 않으면 컴팩션이 유입쓰기속도를 못따라가서 읽기속도도 느려질수있음,이를위해 모니터링이 필요함
	  
	  b트리의 장점은 각 키가 색인의 한곳에만 정확히 존재한다는점이고,lsm트리는 다른 세그먼트에 같은키의 다중 복사본이 존재할수 있다는거임
	  그래서 강력한 트랜잭션이 필요하면 b트리가 더 매력적임
	  
	5.기타색인구조
      프라이머리키 색인이 키값색인의 가장 대표적이 예고,세컨더리 색인도 효율적인 조인을 수행할떄 도움을 줌(외래키색인)
	  
	  그리고 해당 데이터양이 적을경우나,키같은경우엔 색인에 아예 데이터를 같이 저장하는경우도 있음(두번조회비용보다 그냥 두번적는게 싸다고 생각될떄)
	  이걸 클러스터드 색인이라고 함
	  
	  mysql의 경우 프라이머리키는 클러스터드색인이고,보조색인은 이 프라이머리키 색인을 참조함
	  
	  또한 다중칼럼에 대해 질의할때는, 다중칼럼색인을 써야하는데,이거의 가장 일반적인 유형은 결합색인임
	  이건 그냥 abc,123,456,qqq이런식으로 문자열로 단순히 결합하는식
	  이건 순서에 영향을 매우 많이받아서,앞에서부터 순서대로 쓸수있는 조회에 적합함
	  
	  다차원색인은 지리공간데이터에 중요한 색인인데,이건 공간채움곡선을 사용해서 단일숫자로 위치를 변환하거나,전문공간색인을 사용하는것
	  
	  또한 정확한 키가 아닌 유사한키를 검색할땐 전문검색용으로 n그램같은걸 사용할수있음
	  
	  지금까지의 모든건 디스크한계에 대한 해결책이었고,만약 단순캐시용도로만 사용할거라면 인메모리 db를 사용할수있음
	  
  2.트랜잭션 처리나 분석?	
    어플리케이션이 색인을 사용해 일부 키에대한 적은수의 레코드를찾고,
    레코드는 사용자입력을 기반으로 삽입되거나 갱신되는 패턴을 온라인트랜잭션처리(OLTP)라고 함
    
    근데 db를 데이터분석에도 사용하는데,이건 접근패턴이 매우 다름
    분석질의는 많은수의 레코드를 스캔해 레코드당 일부칼럼만 읽어 집계통계(카운트,합,평균등)를 계산해야함
    이걸 온라인 분석 처리(OLAP)라고 함
    
    이 두개를 한곳에서 처리해도 되지만,db가 커질수록 olap의 경우 db상태에 부담을 줌
    
    1.데이터 웨어하우징
      그래서 사용되는게 온라인디비의 읽기전용 복사본인 데이터웨어하우스임
	  데이터는 oltp 데이터베이스에서 주기적인 덤프나 갱신스트림을 통해 추출하고,
	  분석 친화적인 스키마로 변환하고 깨끗하게 정리한다음 데이터웨어하우스에 적재함
	  
	  db가 커질수록 사용하는게 좋고,작은데서는 굳이안써도됨
	  또한 색인도 oltp용이지 olap에서는 쓸데없음(어짜피 전체검색해야하니까)
	  
	  데이터웨어하우스와 관계형db 둘다 sql질의 인터페이스를 사용하지만,내부구현은 완전히 다름
	
    2.분석용 스키마:별모양 스키마
	  또한 트랜잭션처리에서의 데이터모델은 어플리케이션의 필요에따라 다양하게 사용되지만,
	  데이터 웨어하우스는 별모양스키마라는 방식으로 통일함
	  이건,중간에 팩트테이블을 둔 다음,각 칼럼의 값은 외부테이블의 외래키로 채우는것
	  즉 빡빡하게 정규화된 상태를 만듬(물론 그냥 값도 넣어도되긴함,총가격같은거)
	  
	  또한 팩트는 개별 이벤트를 담음,이래야 분석의 유연성이 극대화됨
	  이 팩트테이블의 각 로우는 이벤트를 나타내고,차원은 이벤트의 속성인,6하원칙,즉 누가 언제 어디서 무엇을 어떻게 왜 를 나타냄
	  
	  또한 날짜와 시간도 차원테이블을 사용해 표현함,이러면 공휴일같은 추가정보를 부호화할수있고,휴일과 평일의 판매차이등을 질의할수있음
  
	
  3.칼럼 지향 저장소
    팩트테이블은 칼럼이 보통 100개이상이지만,보통 질의는 한번에 4개 혹은 5개의 칼럼정도에만 접근함(select *을 하지않음)
    즉 많은수의 row에 접근하지만,적은수의 칼럼에 접근함
    
    이런 특성때문에,대부분의 oltp데이터베이스가 로우지향식으로 데이터를 배치하는거에 비해,
    칼럼지향식으로 칼럼의 모든 값을 나열한다음,순서가 동일하다는거에 의존해 서로 매칭시키는게 더 효율적이 되는경우가 있음
    그래서 나온게 칼럼지향저장소임
    1.칼럼압축
      또한 이러면 데이터압축이 편해짐(같은값이 반복해서 나타날 확률이 높아지므로),이때 압축하는방법으로 비트맵부호화등이 있음
  	  이건 n개의 고유값이 있는 칼럼을 가져와서,n개의 개별 비트맵(원핫인코딩같은식)을 만드는식
  
    2.칼럼 저장소의 순서 정렬
      칼럼저장소에서 로우가 저장되는 순서가 반드시 중요하진않음
  	  삽입된 순서로 저장하는방식이 가장 쉬움,새 로우를 삽입하는작업은 각 칼럼파일에 덧붙여 추가하는걸 의미하기때문
  	  하지만 순서를 도입해서 이를 색인으로 사용할땐,칼럼저장소는 순서에 의존하기때문에 각 칼럼파일별로 정렬할순없고,
  	  전체 테이블을 만든후 정렬한다음 다시 칼럼파일로 쪼개야함,물론 한번 한 다음에 삽입할땐,
  	  정렬키의 칼럼파일로 가서 위치찾은다음에 거기넣고,다른데도 같은순서에 넣으면됨 
  	
  	  이런식의 정렬은,키 한두개로 정렬할때 효과가 크고,이후로는 효과가 작음
  	  그래서 생각한게,같은데이터를 서로 다른 다양한 방식으로 정렬해서 저장한다면(각 쿼리별로),쿼리의 성능향상과 더불어 데이터보존효과도 얻을수있음
  
    3.칼럽지향 저장소에 쓰기
      칼럼지향저장소의 단점은,읽기가 빠르지만 쓰기가 느리다는것
  	  정렬된 테이블의 중간로우에 삽입을 원한다면 모든 칼럼파일을 재작성해야함
  	  그래서 lsm트리나,일단 쓰기를 모아둔다음 한번에 처리하는식으로 처리하는게 비용효율적임
	  
    4.집계:데이터큐브와 구체화 뷰
      데이터 웨어하우스는 매번 count,sum,avg등을 자주 사용하기때문에,매번 같은일을 하는거보단,
  	  데이터를 추가할때마다 계산해두고,그 캐시된값을 가져다쓰는게 효율적임
  	  이렇게 캐시를 만드는 방법이 구체화뷰임
  	  oltp에서는 비싸서 잘 못하지만,olap에서는 자주 사용됨
  	  
  	  이 구체화뷰의 특별사례중 데이터큐브라는게 있음
  	  이는 다양한 차원으로 그룹화한 집계테이블임
  	  즉 쓸만한거로는 다 집계해둔 테이블임,단점으로는 질의가 안된다는것(100달러이상 결제의 총합같은걸 미리 캐시해두긴 어려우니까,매번한다면 몰라도)
  
  4.정리
    저장소는 oltp와 olap로 나뉘고,둘은 데이터 처리방식이 다름	
	
4.부호화와 발전	
  어플리케이션은 필연적으로 시간이 지나면서 변하고,이때 저장하는 데이터도 같이 변화됨
  이때 rdb는 모든 데이터가 하나의 스키마를 따른다고 가정함(정확히는 현시점에 해당되는 스키마가 하나라는것)
  반면 읽기스키마 데이터베이스는 다른시점에 쓰여진 이전 데이터타입과 새 데이터타입이 섞여 포함될수있음 
  
  이렇게 데이터타입이나 스키마가 변경될떄,어플리케이션코드에 대한 변경이 종종 발생하지만 보통 대규모앱에서 코드변경은 즉시할수없고,롤링업데이트등으로 해결해야함
  즉 이말은 예전버전코드와 새버전코드,이전데이터타입과 새 데이터타입이 동시에 공존해야 할수 있다는말임
  그래서 시스템이 원활하게 유지되려면 양방향호환성이 유지되어야함(하위호환성,상위호환성)
  
  1.데이터부호화 형식
    프로그램은 두가지형태로 표현된 데이터를 사용해 동작함
	객체같은 cpu에서 효율적으로 접근할수있는 데이터와
	일련의 바이트열형태의 데이터 두가지가 있음
	이 두가지를 서로 변환하는걸 직렬화(부호화)와 역직렬화(복호화)라고 부름
	
	1.언어별 형식
	  언어별로 인메모리객체를 바이트열로 부호화하는 기능이 있긴한데,이건 다른언어에서는 호환되지않아서 잘 사용하지않음
	2.json과 xml,이진변형
	  그래서 json을 주로 사용함
	  물론 여기도 문제가 있긴함,json은 문자열과 수는 구분할수있지만,정수와 부동소숫점을 구별할수없고,정밀도를 지정하지않음
	  뭐 근데 이정도는 감당할만하니까(서로간에 합의만 되면되니)
	  
	  또한 조직내에서만 사용할거라면,json보다 더 크기가 작은걸 선택할수도있음
	  바이트팩이나 이런걸 사용할수있음
	
	3.스리프트와 프로토콜 버퍼
	  스리프트와 프로토콜 버퍼는 이진부호화 라이브러리임
	  이거 둘다 부호화할 데이터를 위한 스키마가 필요하고,이걸로 데이터팩을 만들수있음
	  보통 필드명을 생략하는걸로(필드명을 처음 헤더에만 내보내고,1번필드,2번필드 이런식으로 표기하는식) 이득을봄
	  
	  또한 필드타입과 태그숫자를 단일바이트로 줄이고,가변길이정수를 사용해서 부호화해서 더 데이터를 작게만듬
	  
	  스키마는 시간이 지나면서 변하는데,이걸 스키마발전이라고 부름
	  스리프트에서 필드의 추가는 새 태그번호를 부여하는식으로 대응하고,알지못하는 예전코드는 그걸 무시하고,예전데이터는 기본값을 가지도록하거나 옵셔널처리를 하면됨
	  필드를 삭제할땐 옵셔널만 삭제할수있고,required는 삭제할수없는식
	  
	  필드의 데이터타입을 변경하는건 가능하긴한데 값이 정확해지지않을 가능성이 생김
	
	4.아브로
	  아파치 아브로는 스리프트와 비슷한 이진부호화형식임
	  이것도 스키마를 사용하는데,차이는 얘는 스키마가 2개가 있음
	  사람이 편집하는용도의 아브로 idl과 기계가 읽기편한 json기반
	  
	  얘가 스키마발전을 할땐,쓰기스키마와 읽기스키마가 동일하지않아도,단지 호환만 되면 된다는거에서 아이디어가 나옴
	  읽기를 할때 쓰기와 읽기를 함께 살펴본다음,쓰기에서 읽기로 데이터를 변환해서 차이를 해소하는방식
	  그래서 쓰기스키마와 읽기스키마는 순서가 달라도 상관없고,읽기에는 없고 쓰기에만 있는 필드는 무시하고,
	  읽기에는 있는데 쓰기에는 없으면 읽기의 기본값으로 채움
	  
	5.스키마의 장점
	  스키마언어는 json스키마보다 더 간단하고 자세한 유효성검사규칙을 지원함
	  또한 많은 데이터시스템은 이진부호화를 독자적으로 구현해서 사용함(jdbc같은거)
	  그래서 json같은 텍스트타입 말고 스키마를 기반으로한 이진부호화도 가능한선택이긴함
	  주로 크기부분에서 이득이 있고,문서화하기도 편함(복호화할때 스키마가 필요해서 스키마가 최신상태인지 확인가능)

  2.데이터플로 모드
	데이터플로는 하나의 프로세스에서 다른 프로세스로 데이터를 전달하는것
	1.데이터베이스를 통한 데이터플로
	  데이터베이스에 기록하는 프로세스는 데이터를 부호화하고,데이터베이스에서 읽는 프로세스는 데이터를 복호화함
	  만약 단일 프로세스만 데이터베이스에 접근한다면,db에 저장하는건 미래의 자신에게 메시지를 보내는거처럼 생각할수있음
	  그러니 db에서 언제 읽을지 모르니까,하위호환성이 필요해지는거
	  
	  또한 db내 값이 새 버전으로 기록된다음,현재 수행중인 예전코드로 그 값을 읽을 가능성도 있음,그래서 상위호환성도 대개 필요함
	  어플리케이션이 db값을 모델객체로 복호화하고,이걸 다시 재부호화한다면 변환과정에서 알지못하는 필드가 유실될수있음
	  이걸 주의하긴해야함
	  
	  db는 언제나 값을 갱신할수있고,db속의 값은 5년전에 기록됐었을수도 있음
	  어플리케이션은 몇분안에 배포할수있지만,db속 내용은 그렇지않음
	  물론 마이그레이션을 통해 현재 어플리케이션에 맞게 바꿀수있지만,보통 마이그레이션비용은 비쌈
	  그래서 보통 db는 기존스키마에 추가로 null을 기본값으로 갖는 칼럼을 추가하는 스키마변경을 허용함
	  
	  백업목적이나 데이터 웨어하우스에 적재하기위해 수시로 db스냅샷을 만든다고 하면,이경우 데이터덤프는 최신스키마를 사용해 부호화됨
	
	2.서비스를 통한 데이터플로:REST,RPC
	  보통 네트워크를 통해 통신하는 프로세스들은 클라와 서버 두 역할로 배치하고,서버는 api를 공개하고 클라는 이걸로 요청을 만들어 서버에 연결함
	  이때 서버가 만든 api를 서비스라고 함
	  
	  여러가지면에서 서비스는 db와 유사하지만,차이점으로는 임의질의를 허용하지않음,이걸통해 캡슐화,즉 클라가 할수있는일과 할수없는일에 대한 제약을 걸수있음
	  
	  웹서비스를 통한 호출의 문제는,로컬함수호출은 예측이 가능하지만 네트워크요청은 예측이 어렵다는거
	  네트워크문제로 요청과 응답이 유실되거나,느려지거나,응답하지않을수 있고 이는 제어할수없음
	  그래서 네트워크문제를 함께 고려해야함(재시도라든가,타임아웃이라든가,멱등성처리라던가)
	
	3.메시지 전달 데이터플로
	  rest와 rpc가 하나의 프로세스가 네트워크로 다른 프로세스로 직접 요청을 전송하고 가능한 빠른 응답을 기대하는 방식이었고
	  db는 하나의 프로세스가 부호화한 데이터를 기록하고,다른프로세스가 언젠가 그 데이터를 다시 읽는 방식이었다면
	  
	  비동기 메시지 전달 시스템은,낮은 지연시간으로 다른 프로세스에 전달한다는건 서비스통신과 비슷하지만,
	  메시지 브로커라는 중간단계를 거쳐서 전송한다는건 db와 유사함
	  이거의 장점은
		수신자가 사용불가능하거나 과부하라면,브로커가 버퍼처럼 동작해서 시스템안정성이 향상됨
		죽었던 프로세스에 다시 메시지전달가능
		송신자가 수신자의 ip주소나 포트번호를 알필요가 없어서 수신자 추상화가능
	    하나의 메시지를 여러 수신자로 전송가능
		논리적으로 송신자와 수신자는 분리됨(생산자소비자패턴)
	  이 있음
	  
	  즉 가장 큰 특징은,송신과 수신이 비동기라는것
	  송신자는 던지고 신경끄고,수신자는 그냥 오면 처리하면됨
	  
	  메시지브로커는 보통 프로세스하나가 메시지를 이름이 지정된 큐나 토픽에 전송하고,
	  브로커는 해당 큐나 토픽을 구독하는 하나이상의 소비자나 구독자에게 메시지를 전달함
	  토픽은 단방향 데이터플로만 제공하지만,소비자 스스로 메시지를 다른토픽으로 게시할수있음
	  
	  메시지브로커는 특정 데이터모델을 강요하지않고,아무바이트열이나 쓸수있음
	  
	  주의점은 소비자가 다른 토픽으로 메시지를 재게시한다면,알지못하는 필드 보존에 대해 주의가 필요함(db에서 나온문제)
	  
	  액터모델은 단일프로세스안에서 동시성을 위한 프로그래밍 모델임
	  이건 스레드관련문제를 직접 처리하는대신 로직이 액터(클라나 엔티티를 나타냄)에 캡슐화됨
	  액터는 로컬상태를 가질수있고,비동기메시지 송수신으로 다른 액터와 통신함
	  액터는 메시지전달을 보장하지않고,각 액터 프로세스는 한번에 하나의 메시지만 처리해서 스레드관련문제를 신경쓸필요없음
	  
	  이 분산액터프레임워크에서 이런 액터모델은 여러 노드간 어플리케이션 확장에 사용됨
	  송신자와 수신자가 같은 노드에있는지를 신경쓸필요없어지고,메시지유실가능성을 가정하기때문에 위치투명성이 높음
	  
	  이 분산액터 프레임워크는 메시지브로커와 액터프로그래밍 모델을 단일프레임워크에 통합함
	  이때 롤링업데이트를 할때 상하위호환성에 여전히 주의해야함
	
5.복제
  복제란 네트워크로 연결된 여러 장비에 같은 데이터의 복사본을 유지하는것
  이걸하면
    지리적으로 사용자와 가깝게 데이터배치를 할수있어서 지연시간을 줄일수있음
	시스템의 일부에 장애가 발생해도 지속적으로 동작할수있어짐
	읽기질의용 장비의 수를 확장해 대역폭을 늘릴수있음
  이런 장점이 있음
  
  복제의 어려움은 복제된 데이터의 변경처리에 있고,이게 핵심임
  
  1.리더와 팔로워
    db의 복사본을 저장하는 각 노드를 복제서버라고함
	다중복제서버에서 모든 복제서버에 모든 데이터가 있다는 사실을 보장하는 방법중 가장 일반적인 해결책은 리더기반 복제임
	
	복제서버중 하나를 리더로 지정하고,쓰기는 거기를 통해서만 진행하는거(읽기는 레플리카도 가능)
	리더에 쓰기가 들어오면,데이터 변경을 복제로그나 변경스트림등으로 팔로워에 전송하고,
	각 팔로워가 리더로부터 로그를 받으면 리더가 처리한것과 동일한순서로 모든 쓰기를 적용해서 로컬복사본을 갱신함
	
	즉 클라는 모든 서버에 질의할수있지만,쓰기는 리더에만 허용되는것
	
	1.동기식 대 비동기식 복제
	  복제의 중요세부사항은 복제가 동기식으로 발생하는지 비동기식으로 발생하는지 여부임
	  
	  동기식은 쓰기가 들어오고 리더가 쓴 후에 리더가 팔로워들이 모두 갱신할때까지 동기식으로 기다리는것
	  즉 모든 팔로워가 성공을 해야 다음일로 진행할수있음
	  
	  비동기식은 그냥 던져놓고 알아서하겠지 하고 내할일 하는것
	  
	  동기의 장점은 리더와 일관성있게 최신 데이터 복사본을 가지는걸 보장해줌
	  단점이 근데 치명적인데,팔로워가 죽거나 네트워크문제등으로 응답이 오지않는다면,서버 전체가 뻗어버림(타임아웃날때까지)
	  
	  그래서 모든 팔로워가 동기식인건 비현실적이고,리더에 문제생기는상황을 대비해 한두개정도만 동기식으로 하고 나머지는 비동기식으로 쓰는걸 반동기식이라고 함
	  
	  보통 리더기반복제는 완전히 비동기식으로 구성함
	  이런경우 리더가 문제가 생기면 팔로워에 아직 복제되지않은 모든쓰기는 유실됨
	  즉 쓰기가 클라이언트에게 확인된 경우에도(쓰기성공이 들어왔어도) 지속성을 보장하지않는다는 의미임
	  대신 모든 팔로워가 잘못되더라도 리더가 쓰기처리를 계속할수있다는 장점이 있음
	  
	  이건 문제가 많아보이긴 하지만,팔로워가 많거나 지리적으로 분산됐다면 자주 사용하는 솔루션임
	
	2.새로운 팔로워 설정
	  팔로워를 늘릴떄 팔로워가 리더의 데이터복제본을 정확히 가지고있는지 보장하는건,
		일단 스냅샷으로 리더의 전체 데이터를 가져오고
		그걸 팔로워에 복사하고
		그사이에 벌어진 일에 대한(복제로그의 시간순서를 기반으로)데이터변경을 리더에 요청함
		이걸 전부 처리하고 리더와 백로그가 같아지면 따라잡았다고 하고 팔로워로 등록됨
	  이런순서로 진행됨
	 
	3.노드중단처리
	  유지보수등으로 인해 개별노드를 재부팅하거나해야해서 꺼야할때,고가용성을 유지하는건 여러방법이 있음
	  
	  각 팔로워가 리더로부터 수신한 데이터변경로그를 로컬디스크에 보관하고,팔로워가 죽거나 일시적으로 리더와연결이 끊긴다면,
	  마지막으로 저장된 트랜잭션 번호를 찾은뒤,리더와 다시 연결되고 그 이후로 처리된 모든걸 달라고하면됨
	  이걸 따라잡기복구라고 함(팔로워장애시 처리방법)
	  
	  리더가 장애가 생기면 좀 복잡한데,팔로워중 하나를 새 리더로 승격해야하고,
	  클라는 새 리더로 쓰기를 전송하기위해 재설정이 필요하고,
	  다른 팔로워는 새 리더로부터 데이터변경을 소비해야함,이걸 장애복구(페일오버)라고 함
	  
	  이건 수동으로 처리하고나 자동으로도 함
	  자동으로할떈
		리더가 장애인지 판단(헬스체크등으로)
		새 리더를 선택
		새 리더사용을 위해 시스템 재설정
	  이 순서를 거쳐야함
	  
	  이때 문제될게 많은데
	    비동기식복제를 사용한다면,새리더는 이전리더가 실패하기전의 일부 쓰기를 송신하지못할수있음,
		  이때 이전리더가 다시 클러스터에 추가되면 이전리더의 복제되지않은쓰기를 폐기해야하는데,이러면 내구성이 떨어짐
		쓰기를 폐기하는건 db외부의 다른 저장소시스템이 해당 db내용에 맞춰 조정돼야한다면 더 위험함(레디스같은데서 같은 키를 쓰는경우)
		특정 결함 시나리오에서 두 노드가 모두 자신이 리더라고 믿을경우 위험해짐
		리더가 죽었다고 판단가능한 타임아웃을 길게잡으면 복구에 시간이 오래걸리고,짧게잡으면 불필요한 장애복구가 있을수있음
	  이런 문제들이 많아서 수동으로하는걸 선호하기도함
	
	4.복제로그 구현
	  리더기반복제에서는 
	    구문기반복제(모든 쓰기쿼리를 복제,now()같은거떄문에 복제가 깨질수있음,그래서 저런값들을 자동으로 고정값으로 바꿔줘야함)
		쓰기전 로그 배송(모든쓰기가 로그에 저장되니,그 로그를 복사해주면됨,이거의 단점은 로그가 제일 저수준데이터라서 복제가 저장소엔진과 의존성이 높아짐,특히 버전등)
		로우기반복제(쓰기전 로그배송과 비슷하지만,저장소엔진과의 의존성을 추상화한 형태의 새로운 로그를 사용하는식,대충 로우단위로 로깅하고 그거 가져다가 그대로넣는느낌)
	  이렇게 3가지를 사용하는데,보통 로우기반복제를 사용함
	  
	  로우기반복제는 외부어플리케이션이 파싱하기도 쉽고,그래서 변경데이터캡처를 사용하기도 좋음
	  
	  이런형태의 접근말고(db에서만 처리),db를 다른종류의 db로 복제해야하거나 충돌해소로직이 필요하면,복제는 어플리케이션단에서 처리해야함
	  보통 이럴때는 트리거를 사용함(트리거 기반 복제)
	  
  2.복제 지연 문제
    복제는 내결함성때문에만 쓰는건 아니고,확장성과 지연시간떄문에 쓰기도함
	모든 쓰기는 리더를 거쳐야하지만,읽기는 어느레플리카에서나 할수있기때문
	즉 대부분이 읽기요청이고 쓰기가 아주 작은비율인(대부분의 웹패턴)에 적합함
	
	이런 읽기확장아키텍처는 간단히 팔로워를 추가하면 대역폭을 늘릴수있음,단 비동기식 복제여야함
	문제는 비동기팔로워에서 데이터를 읽을때,팔로워가 뒤쳐진다면 지난정보를 볼수도있음(시간떄문에)
	결국은 팔로워는 따라잡고 리더와 일치해지지만(최종적 일관성)
	 
	1.자신이 쓴 내용 읽기
	  대표적으로 문제가 생기는게 자신이 쓴 내용 읽기임
	  보통 쓰고나면 자기가 쓴걸 바로 보는경우가 많은데,쓰기는 리더에 쓰고 읽기는 팔로워에 하면,둘간의 시간차때문에 데이터가 표시되지않을수있음
	  이걸 쓰기 후 읽기 일관성 이라고 함
	  이건 사용자가 페이지를 재로딩했을때 항상 자신이 제출한 모든 갱신을 볼수있음을 보장하며,다른 사용자에 대해서는 보장하지않음
	  
	  이걸 구현할땐 여러방법이 있음
	    자신에 관한걸 읽을땐 리더에서 읽기
	    마지막 갱신시간이 1분이전이면 리더에서 읽고,아니면 팔로워에서읽기
	    클라에서 타임스탬프를 기억하고,팔로워가 그 타임스탬프 이전이면 갱신될때까지 계속 재요청하기
	  등이 있음
	
	   이때 마지막의 클라에서 처리하는건,여러 디바이스(모바일+pc)를 쓸때에는 또 적용안되니까 쓸수없어짐
	
	2.단조 읽기
	  또 다른 이상현상으로는 사용자가 각기 다른복제서버에서 여러읽기를 수행할때 시간이 역전되는 현상임
	  즉 처음읽은게 늦게 갱신되고,이후꺼가 빨리 갱신될경우 발생함
	  이럴경우 처음 읽었던게 두번째 읽을때는 사라지는등의 문제가 발생할수있음
	  
	  단조읽기는 이게 일어나지않음을 보장함,이걸위해서는 각 사용자의 읽기는 항상 동일한 서버에서 수행되게끔 하던가 하는식으로 할수있음
	  보통 사용자id를 해시해서 선택하거나  하는느낌
	
	3.일관된 순서로 읽기
	  또 다른 이상현상으로는 인과성의 위반이 있음
	  a와 b가 순서대로 말을했는데,a는 엄청 늦게 전달되고,b는 엄청 빨리 전달됐을경우엔 b가 먼저보이고 a가 보이는 상황이 있을수있음
	  
	  이건 샤딩된 db에서 발생하느 특징적인 문제임
	  db가 항상 같은순서로 쓰기를 적용하면,읽기는 항상 일관되기때문에 발생하지않지만,
	  보통 분산db는 서로 다른 파티션은 독립적으로 동작해서 쓰기의 전역순서가 없기때문에 발생함
	  
	  이거의 해결책으로는 서로 인과성있는 쓰기가 같은 파티션에 기록되게 하는 그런방법이 있음
	  
	4.복제 지연을 위한 해결책
	  최종적일관성으로 작업할때,복제지연이 있어도상관없다면 괜찮지만,있으면 안된다면 쓰기후읽기등 강한 보장을 제공하게 설계해야함
	  이럴땐 비동기식으로 동작하지만 동기식인척 하는게 해결방안임
	  그래서 사용되는게 트랜잭션임
	  
	  
  3.다중 리더 복제
	
	
	
	
	
	
	
	
	
	
	
	
	
	
