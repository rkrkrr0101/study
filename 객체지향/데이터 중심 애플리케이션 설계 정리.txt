1.신뢰할수있고 확장가능하며 유지보수하기 쉬운 어플리케이션
  요즘 어플리케이션은 계산중심이 아니라 데이터중심적임
  그래서 병목이 데이터의 양,복잡도,변화속도에 걸림
  
  데이터 중심 어플리케이션은,공통적으로 필요로하는 기능을 제공하는 표준 구성 요소를가짐
	데이터를 다시 찾을수있게함 (db)
	읽기속도 향상을 위해 값비싼 수행결과를 기억(캐시)
	사용자가 키워드로 데이터를 검색하거나 다양한방법으로 필터링할수있게 제공(검색색인)
	비동기처리를 위해 다른 프로세스로 메시지 보내기(스트림처리)
	주기적으로 대량의 누적된 데이터를 분석(일괄처리,즉 배치)]
  이런것들이 다 추상화되어서 들어가지만,어플리케이션마다 요구사항이 달라서,db시스템또한 저마다 다양한 특성을 가지고,
  어플리케이션을 만들때 어떤 도구와 어떤 접근방식이 수행작업에 가장 적합한지를 생각해야함
  
  1.데이터 신뢰성에 대한 생각
	db와 큐 캐시등을 달라보이고,실제로 매우 다른 접근패턴을 가지지만 데이터시스템이라는 포괄적 용어로 묶을수있음
	이유는,
	  1.레디스(메시지큐 데이터스토어)나 카프카(지속성을 보장하는 메시지큐)등으로 인해 분류간 경계가 흐려짐
	  2.많은 어플리케이션이 단일도구로는 더이상 데이터처리와 저장 모두를 만족시킬수 없는 과도하고 광범위한 요구사항을 가지고있음,
		대신 작업은 단일도구에서 효율적으로 수행할수있는 태스크로 나누고,다양한 도구들은 어플리케이션 코드를 이용해 서로 연결함
	  3.서비스제공을 위해 각 도구를 결합할땐,인터페이스로 클라이언트가 세부사항을 모르게 숨김(포트),그래서 어플리케이션이 접근할땐 다 동일하게 접근할수있음
	이런 이유등이 있음
	
	데이터 시스템이나 서비스를 설계할때 가장 중요한건
		신뢰성:결함,인적오류등이 생겨도 시스템은 지속적으로 올바르게 동작(원하는성능수준에서 정확한기능을 수행)해야함
		확장성:데이터량,트래픽량,복잡도가 증가하면서 이를 처리할수있는 적절한 방법이 있어야함
		유지보수성:모든 사용자가 시스템상에서 생산적으로 작업할수있어야함
	이 3가지임

  2.신뢰성
  	  소프트웨어는
	    어플리케이션은 사용자가 기대한 기능을 수행
	    시스템은 사용자가 범한 실수나 예상치못한 소프트웨어 사용법을 허용할수있음
	    시스템 성능은 예상된 부하와 데이터양에서 필수적인 사용사례를 충분히 만족함
	    시스템은 허가되지않은 접근과 오남용을 방지함
	  보통 이정도를 기대하는데,대충 무언가 잘못되더라도 지속적으로 올바르게 동작함 이라고 생각하면됨
	
	  이떄 잘못될수있는일을 결함이라고 하고,결함을 예측하고 대처할수있는 시스템을 내결함성,또는 탄력성을 지녔다고 함
	  물론 모든종류의 결함을 견딜수는 없음(전쟁나서 서버에 폭탄터졌는데 웹서버가 그걸 버틸수는없음)
	
	  결함은 장애와 동일하지않음
	  결함은 사양에서 벗어난 시스템의 한 구성요소로 정의되지만,장애는 사용자에게 필요한 서비스를 제공하지못하고 시스템 전체가 멈춘경우임
	  결함확률을 0으로 줄이는건 불가능하고,그래서 결함으로 장애가 발생하지않게 내결함성을 챙기는게 가장좋음
	
	  이를 테스트하려고 카오스몽키같은걸 쓸수도있고,예방책이 해결책이 더 좋은경우도 있음(해킹같은거)
	  
	1.하드웨어결함
	  시스템 장애의 원인중 대표적인게 하드웨어결함이고,이건 규모가 커지면 늘상 일어남
	  보통 이걸 해결하는방법은 각 하드웨어구성요소에 중복을 추가하는것(raid같은거),아니면 클라우드로 노드를 여러개쓰는방법도 있음
	  
	2.소프트웨어 오류
	  보통 하드웨어결함은 서로간에 별로 상관관계가 없음,근데 시스템 내의 체계적오류는 예상하기 더 어렵고,노드간 상관관계때문에 시스템오류를 더욱 많이 유발함
		잘못된 특정입력이 있을때 모든 어플리케이션 서버인스턴스가 죽는 버그
		cpu,메모리,디스크공간등 공유자원을 과도하게 사용하는 일부프로세스
		시스템속도가 느려져 반응이 없거나 잘못된 응답을 반환하는 서비스
	  등이 있음
	  
	  이런 소프트웨어결함은 특정 상황에 의해 발생하기전까지 오랫동안 나타나지않음,즉 소프트웨어는 환경에 대한 일종의 가정이 있고,
	  이 가정은 대개 문제없지만 어떤이유로 문제가 생기게됨(가정이 꺠지게됨)
	  
	  이런 문제는 신속한 해결책이 없고,테스트,프로세스격리,죽은프로세스의 재시작허용,모니터링등으로 해결해야함
	  로깅을 해서 그걸 모니터링하는방법도 있음
	
	3.인적오류
	  사람은 가장 중단의 메인 원인임
	  그래서
	    오류를 최소화하는 방향으로 시스템을 설계(추상화)
		가장 많이 실수하는장소에서 실수로 장애가 발생하는 부분을 분리
		샌드박스의 제공
		단위테스트부터 통합테스트등을 철저히 테스트
		인적오류를 빠르고 쉽게 복구할수있게 하기(롤백 롤아웃가능하게)
		성능지표와 오류율등을 모니터링하기
	  등을 해야함
	
	4.신뢰성은 얼마나 중요할까?
	  버그는 생산성저하의 원인이고,어플리케이션은 사용자에 대한 책임이 있음
	  스타트업에서 비용을 줄이려고 신뢰성을 희생해야하는경우가 있지만,이때는 신뢰성을 다시 돌려놓는 지점을 잘 알아야함

  3.확장성
	시스템이 현재 안정적으로 동작한다고 미래에도 안정적으로 동작한다는 보장은 없음
	보통 부하증가로 인해 성능이 저하됨
	
	확장성은 증가한 시스템능력을  설명하는데 사용하는 용어지만,시스템에 부여하는 일차원적 표식이 아님
	이건 
	  시스템이 특정 방향으로 커지면 이를 대처하기위한 선택은 무엇인가?
	  추가부하를 다루기위해 계산자원을 어떻게 투입할까?
	같은 질문을 고려한다는 의미임
	
	1.부하기술하기
	  가장 먼저 해야하는건,시스템의 현재 부하를 간결하게 기술해야함,그래야 부하성장질문(부하가 2배커지면 어떻게하지?)를 논의할수있음
	  부하는 부하매개변수라 부르는 몇개의 숫자로 나타낼수있는데,
	  예를들어
	    웹서버의 초당 요청수
		db의 읽기 대 쓰기 비율
		대화방의 동시 활성 사용자
		캐시 적중률
	  등이 있음
	  
	  이떄 평균적인 경우가 중요할수도 있고,소수의 극단적인 경우가 병목의 원인일수도있음
	  즉 어플리케이션의 현재 상황에 맞춰서 선택해야함
	
	2.성능 기술하기
	  부하를 기술했으면,부하가 증가할때 어떤일이 일어나는지 조사할수있음
	    부하 매개변수를 증가시키고 시스템 자원은 변경하지않는다면 시스템 성능은 어떻게영향을 받을까?
		부하 매개변수를 증가시켰을때 성능이 변하지않고 유지되길 원한다면 자원을 얼마나 많이 늘려야할까?
	  둘 다 성능수치가 필요함
	  
	  하둡같은 일괄처리시스템은 처리량에 관심을 가지고,온라인시스템은 서비스응답시간을 관심을 가짐
	  
	  응답시간은 매번 값이 다르니,값의 분포로 생각을 하고 중앙값(p50)과 p95,p99정도를 봐야함
	  또한 시스템의 확장성을 테스트하려고 인위적으로 부하를 생성할땐,응답시간과 독립적으로 요청을 지속적으로 보내야함
	  클라가 다음 요청을 보내기 전에 이전 요청이 완료되길 기다리면,테스트가 왜곡됨
	
	3.부하 대응 접근 방식
	  기본적으로 스케일업은 비싸니,스케일 아웃이 가능하게해야하고,시스템은 탄력적이면 부하가 예측할수없을만큼 높으면 유용하지만,
	  수동으로하는게 예상치못한일은 더 적음
	  
	  또한 스테이트리스가 다수의장비에 배포하기 쉽고,스테이트풀을 분산설치하는건 매우 복잡도가 높음
	  
	  모든곳에 맞는 아키텍처는 없고,읽기의양,쓰기의양,저장할데이터의 양,데이터의 복잡도,응답시간요구사항,접근패턴등을 고려해서 선택해야함
	  즉 이런 가정을 바탕으로 확장성을 체크하는데,이 가정이 틀려버리면 확장을 위한 노력은 다 헛수고가 되고,역효과를 낳을수도있음
	  그래서 스타트업초기단계에선 확장보단 빠르게 반복해서 제품기능 개선하는게 나음
  
  4.유지보수성
    유지보수에서 중요한건
	  운용성:운영팀이 시스템을 원활하게 운영할수있게 쉽게 만들자
	  단순성:시스템에서 복잡도를 최대한 제거해 새 엔지니어가 시스템을 이해하기 쉽게 만들자
	  발전성:엔지니어가 시스템을 쉽게 변경할수 있게 하자
	이 3가지임
	
	신뢰성과 확장성을 달성하는 쉬운방법은 없지만,최소한 유지보수성은 챙겨가야함
	
	1.운용성:운영의 편리함 만들기
	  운영의 일부는 자동화할수있지만,이 자동화를 처음 설정하고 테스트하는건 사람의 몫임
	  
	  시스템이 지속해서 원활하게 작동하려면 운영팀이 필수고,좋은 운영팀은
		시스템상태를 모니터링하고 상태가 좋지못하면 빠르게 서비스를 복원
		시스템장애,성능저하등 문제의 원인을 추적
		보안패치를 포함해 소프트웨어와 플랫폼을 최신상태로 유지
		다른시스템이 서로 어떻게 영향을 주는지 확인해,문제가 생길수있는 변경사항을 손상을 입히기 전에 차단
		미래에 발생가능한 문제를 예측해 문제가 발생하기전에 해결
	  이런일들을 함
	  
	  또한 좋은 운영성이란 동일하게 반복되는 태스크를 쉽게 수행하게 만들어,고부가가치활동에 노력을 집중할수있게함
	
	2.단순성:복잡도관리
	  프로젝트가 커지면 시스템은 매우 복잡하고 이해하기 어려워짐
	  보통
		상태공간의 급증
		모듈간 강한 커플링
		복잡한 의존성
		일관성없는 명명과 용어
		성능문제해결을 목표로한 해킹
		임시방편으로 문제를 해결한 특수사례
	  등이 있음
	  
	  보통 복잡도가 올라가서 유지보수가 어려워지면 예산과 일정이 초과됨
	  변경이 있으면 버그가 생기기 쉽기때문
	  
	  또한 개발자가 시스템을 이해하고 추론하기 어려워지면,시스템에 숨겨진 가정과 의도치않은 결과 및 예기치 않은 상호작용을 간과하기 쉬움
	  반대로 복잡도를 줄이면 유지보수성이 크게 향상됨,즉 단순성이 시스템의 핵심목표임
	  
	  시스템을 단순하게 만든다는게 기능을 줄인다는걸 의미하진않고,우발적 복잡도를 줄이는게 목표임
	  이걸위해 추상화를 사용함
	
	3.발전성:변화를 쉽게 만들기
	  시스템의 요구사항은 계속 바뀜,이걸 민첩하게 받아들일수 있는게 발전성임
	  이때마다 쉽게 변화를 줄수있어야함,이를위해 tdd등을 사용할수있음
	  
	  이건 단순성(과 추상화)에 영향을 많이받음
  
  5.정리
    어플리케이션은 기능적 요구사항(동작해야하는 기능)과 비기능적 요구사항(유지보수성,단순성,신뢰성등)을 충족시켜야함
	
	신뢰성은 결함이 발생해도 시스템이 올바르게 동작해야한다는것
	확장성은 부하가 증가해도 좋은 성능을 유지하기 위한 전략
	유지보수성은 엔지니어와 운영팀의 삶을 개선하는데 목적이 있음(즉 변경코스트를 줄이는데 목적이 있음)
	
2.데이터모델과 질의언어
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
