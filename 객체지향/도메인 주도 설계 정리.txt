1.지식탐구
  모든 소프트웨어는 그 소프트웨어를 사용하는 사용자의 활동이나 관심사에 관련되어있고,
  사용자가 프로그램을 사용하는 대상영역이 바로 해당 프로그램의 도메인임
  보통 도메인은 컴퓨터와 거의 관련이 없음
  
  이때 개발을 하려고 하면 도메인 지식의 양에 압도되지않기위해서 사용하는게 모델임
  모델은 지식을 선택적으로 단순화하고 의식적으로 구조화한 형태임
  
  도메인모델은 특정 다이어그램이 아니라,다이어그램이 전달하고자 하는 아이디어임
  도메인모델이란 도메인 전문가의 머릿속에 존재하는 지식을 엄격하게 구성하고 선택적으로 추상화한것
  우리는 다이어그램을 이용해 모델을 표현하고 전달할수있음
  
  도메인 모델링은 가능한 한 사실적인 모델을 만드는게 아니고,단순히 필요한 결과를 내는 소프트웨어를 만드는것도 아님
  전체 도메인중 일부분만을 취합해서 만들어내는것
  
  모델의 쓰임새는
    모델과 핵심설계는 서로 영향을 주며 구체화됨,모델을 의미있게 만들고 모델이 최종산출물에 적용되게 보장하는건 모델과 구현간의 긴밀한 연결임
	  또한 유지보수에도 도움을 줌(모델을 통해 코드를 해석할수있기때문)
	모델은 모든 팀 구성원이 사용하는 언어의 중추임,모델과 구현이 서로 연결되어있으므로 개발자와 도메인전문가 모두 번역없이 이걸 사용해 대화를 나눌수있음
	모델은 지식의 정수만을 뽑아낸것,모델은 도메인지식을 조직화하고 가장 중요한 요소를 구분하는 팀의 합의된 방식임
	  모델에는 용어의 선택이유,개념의 분류,분류된 지식을 연관시킬때의 도메인에 관한 우리의 사고방식이 담겨있음
  임
  
  소프트웨어란 사용자를 위해 도메인에 관련된 문제를 해결하는데 있음
  그밖의 모든 기능도 이런 기본목적을 뒷받침하는데 있고
  도메인이 복잡하면 이같은 문제해결의 난이도는 올라가고 개발자는 도메인연구에 몰두해야하지만
  보통 개발자는 이런걸 좋아하지않음(무질서하고 도움이 안될거같기때문)
  
  그런데 여기서도 얻을수있는게 많고,즉 모델을 만드는데 사용할수있는 체계적인 사고방식과 불규칙한 소프트웨어 어플리케이션에 질서를 부여할수있는 설계기법이 있음
  
  도메인 모델을 만들땐 도메인전문가와 같이 객체 상호작용다이어그램을 그려가면서 하면 좋음
  즉 브레인스토밍과 정제를 반복해가는식
  
  이렇게 코드를 좀 작성해서 예제를 만들수있을수있을정도로 이해가 됐다고 생각하면,매우 간단한(인프라같은거 다 제외한) 예제를 만들어서 같이 돌려보는거임
  이렇게 하면 데모엔 전문가는 모델이 의미하는바와 동작하는  소프트웨어와 모델의 관계를 더 명확하게 이해할수있음
  이러면 소통이 양방향이 되고,내가 새로 알게된 지식을 모델에 통합하고 그걸 소프트웨어에 반영하는걸 도메인전문가가 보고 피드백을 줄수있음
  
  1.효과적인 모델링의 요소
    즉 모델링을 하는 방법은
	  모델과 구현의 연계:초기 프로토타입을 토대로 본질적인 연결고리를 만들고,모든 반복주기 내내 그걸 유지
	  모델을 기반으로 하는 언어 정제:프로젝트에 참여하는 모두가 모델에서 용어를 바로 끄집어내어 모델의 구조와 일관되게 문장을 만들수있게 해야함
	  풍부한 지식이 담긴 모델 개발:객체는 행위를 지니고 규칙을 이행함,또한 모델에는 다양한 지식이 포함되어있음
	  모델의 정제:모델이 점차 완전해지면서 중요한 개념이 더해지고,쓸모없거나 중요하지않다고 판명된 개념이 제거됐다는거도 중요함
	  브레인스토밍과 실험:스케치를 비롯해 결합된 언어를 바탕으로 토의를 모델에 대한 실험실로 변모시켜,수백가지 변종을 연습하고 시도하고 평가해봐야함
	이런식의 요소들이 있어야함
	
  2.지식탐구
    도메인 모델링을 수행할때도 지식을 면밀히 탐구하고,
	많은양의 정보속에서 아주 미미한 관련성을 찾아내서 전체를 이해할수있는 간결한 관점을 찾아 체계적인 아이디어를 차례로 시도해봄
	이과정에서 수많은 모델이 시도,거부,변형되고,모든 세부사항에 맞는 일련의 추상적 개념이 나타나면 성공임
	이렇게 해서 뽑아낸 정수는 가장 적절한것으로 밝혀진 특정지식을 엄밀하게 표현한것
	
	지식탐구는 혼자하는활동이 아니고,개발자와 도메인전문가로 구성된팀은 대체로 개발자가 이끄는가운데 협업함
	그들은 함께 정보를 받아들여 그걸 유용한 형태로 만듬
	원재료가 되는 지식은 도메인 전문가의 머릿속이나 기존 시스템 사용자,동일한 도메인에 관련된 레거시팀의 기술팀,다른프로젝트에서 얻은 경험에서 나옴
	이런 지식은 프로젝트나 업무에 활용할 용도로 작성된 문서의 형태를 띄고,대화의 형태로 존재할때가 훨씬 더 많음
	
	이런방식은 워터폴에서는 하기힘들었고,또한 지식의 축적또한 일어나지않음(특히 도메인전문가에게)
	또한 추상화를 하지않으면 지식을 축적하기 힘듬
	물론 결과를 도메인전문가에게 보여주고,전문가가 원하는대로만 하면 만들수는 있는데,대단한건 만들기힘듬
	
	애초에 추상화를 시작해서 더 많은 일을 해낼수있는 모델로 발전시키는게 좋고,
	이 과정은 도메인 전문가와의 협업을 통해 기술적인 측면 뿐 아니라 개념적인 측면에서도 발전되어야함
	
	즉 개발자는 기능만을 기계적으로 만들지않고,자신이 보조하는 업무의 중요원칙을 배우고,
	도메인전문가는 자신의 지식의 정수를 추출하는법을 배우고 소프트웨어에서 중요한 개념적 엄밀함을 이해하게됨
	
	이런식으로 만들어진 모델은,프로젝트 내내 흘러가는 정보들을 조직화하는 도구로 자리잡음
	모델은 요구사항 분석에 초점을 맞추고,이건 프로그래밍과 설계와 밀접한 관계를맺음
	모델은 도메인을 이해하는데 실용적이고 유용해야하고,쉽게 구현하고 이해하기에 충분할만큼 엄밀해야함

  3.지속적인 학습
    소프트웨어를 작성하기 시작할때,우리는 충분히 알지 못한 상태에서 시작함
	또한 모든 프로젝트에서는 지식이 새어나감(이직등)
	그래서 이것이상으로 의식적으로 지식을 함양해야하는데,이건 기술적인것과 도메인모델링 모두를 포함하고,해당 프로젝트의 도메인도 포함됨
	
	개발자가 필요로하는건 도메인전문가가 되는길이 아님,
	중요한건 도메인 전문가와 대화할수있고,그걸 어플리케이션에 관련되게 번역하고,내가 만든 어플리케이션이 정상동작하는지 점검할수있게되는거임

  4.풍부한 지식이 담긴 설계
    모델에 포함된 지식은 단순한 명사찾기 이상임
	도메인에 관련된 엔티티만큼 업무활동과 규칙도 도메인에 중요한데,도메인엔 다양한 범주의 개념이 존재하고,지식탐구는 이런 통찰력을 반영하는 모델을 만들어냄
	개발자는 모델의 변경에 맞춰 구현을 리팩터링해서 모델의 변경된사항을 표현하고,어플리케이션에서는 그런 지식을 활용함
	
	이땐 엔티티와 값을 너머 이런 활동들이 이뤄져야함
	이건 여러 업무규칙간 모순이 있을수있기때문(특정 화물은 10%만큼 오버부킹해도된다던가)
	도메인전문가는 보통 이런걸 무의식적으로 처리하기때문에 이걸 의식적으로 끌어내야함
	
	즉 감춰진 개념을 추출할수있어야함
	또한 이렇게 생긴 규칙을 도메인전문가가 해당부분의 코드를 보고 이해할수있게 해야함(메서드추출이나 클래스추출을 사용해서 패턴의 사용등) 
	
	즉 이런 명시적인 설계는 
	  프로그래머와 그밖의 모든이가 규칙의 특성을 불분명한 계산이 아니라 중요한 업무규칙임을 알아야하고
	  프로그래머는 도메인전문가에게 그들이 이해할수있는 수준에서의 기술적 산출물,심지어 코드까지 보여주고(안내해주면서) 피드백을 받을수있어야함
	
  5.심층 모델
    유용한 모델은 겉으로 드러나있는 경우가 거의없음
	보통 처음에 중요하게 생각했던 피상적인 모델요소를 버리거나 관점을 바꾸게됨 
	그래서 처음엔 나타나기 힘들지만 문제의 핵심을 관통하는 포착하기 힘든 추상화가 서서히 드러나게됨
	
  
2.의사소통과 언어 사용 
  1.유비쿼터스 랭귀지
    도메인 모델은 프로젝트의 공통언어의 핵심이 되어야함
    모델은 프로젝트에 참여한 사람들의 머릿속에 축적된 개념을 모아둔것으로,도메인에 대한 통찰력을 반영하는 용어와 관계로 표현됨
    이건 기술적인 개발을 할수있을만큼 충분히 정확하면서,도메인에 맞게 조정된 언어의 의미체계를 제공해야함
    이건 모델을 개발과 결부시키고 모델을 코드에 연계하는데 매우 중요한 연결고리 역할을 함
    
    이런 모델기반 의사소통은 통합모델링언어상의 다이어그램으로 한정돼서는 안됨
    모든 의사소통의 기반에 이게 들어있어야함
    
    도메인전문가는 소프트웨어개발의 전문용어를 이해하는데 한계가 있지만,자신의 전문분야의 전문용어는 다양하게 사용함
    개발자는 시스템을 서술적이고 기능적으로 이해하고 토론할순없지만 전문가의 언어에 담긴 의미는 알지못함,
    또는 설계는 하지만 도메인전문가가 이해하지못하는 방식으로 추상화할수도있음
    
    이런식으로 공통언어가 없는 프로젝트에선 서로간에 번역이 필요하고,이렇게 번역할수있는사람이 병목이되고 모델의 개념이 혼란스러워짐
    문제는 이 상태가 겉으로 드러나지않는다는것
    결국 조화가 깨진,신뢰할수없는 소프트웨어가 만들어짐
    
    즉 프로젝트내에선 언어가 통일되어야함,즉 토론에 쓰이는 언어와 코드에 녹아든 언어가 같아야함
    그래서 사용되는게 유비쿼터스 랭귀지임
    
    유비쿼터스 랭귀지엔 클래스의 주요연산 이름이 있고,여기엔 모델내에서 명시적으로 드러나는 규칙을 토론하기위한 용어가 포함됨
    여기엔 모델에 부과된 높은 수준의 구성원칙에서 비롯된 용어도 더해지고,도메인모델에 적용하는 패턴의 이름으로 풍부해짐
    
    모델기반언어는 개발자사이뿐 아니라 업무와 기능을 기술할때도 사용해야하고,도메인전문가들 끼리도 의사소통할때 사용할수있을정도여야함
    물론 초기모델은 이렇게 하기 힘들고,전문용어는 모호함과 모순을 가지고있어서 그대로 사용하진못함
    그래서 개발자가 코드에 구현한 세부사항에서 나오는 특징이 빠져있을수도있는데,
    이건 개발자가 전문용어를 모델의요소로 여기지않거나 절차지향이거나 도메인의 해당개념을 불분명하게 전달했을때 발생함
    
    이걸 계속 반복하다보면 모델의 취약점이 드러나고,실험을 토대로 부자연스러운 용어나 결합의 대안을 찾아낼수있음
    또한 공백을 찾으면 거기에 해당하는 단어를 붙이고,이런 언어의 변화는 도메인모델의 변화로 인식되고,
    이렇게 용어의 의미가 바뀌면 클래스다이어그램을 수정하고 코드상의 클래스와 메서드명도 바뀌고,심지어는 동작방식도 바뀔수있음
    
    개발자는 이렇게 구현이라는 맥락에서 이런 언어를 사용하고,의미가 부정확하거나 모순되는 사항을 지적해서 도메인 전문가가 실행가능한 대안을 생각해내게 만들어야함
    물론 도메인전문가는 더 폭넓은 맥락을 설명하거나 설정하고자 유비쿼터스 랭귀지의 범위를 넘어서서 말하겠지만,이 모델이 다루는 범위 안에서는 이걸 사용해서 말해야하고,
    이게 부자연스럽거나 불완전하거나,틀린경우에는 관심을 기울려야함
    즉 모든상황에서 모델기반언어를 사용하고,이게 자연스럽게 느껴질때까지 노력해야 간결한 요소로 복잡한 아이디어를 표현할수있는 완전하고 이해하기 쉬운 모델을 만들어낼수있음
    
    즉 모델은 언어의 근간이고,이걸 문서건 말할때건 다이어그램이건 다 똑같이 써야함
    또한 해당모델의 대안이 되는 표현을 시도해서 이상한부분을 제거하고,거기에 맞춰서 클래스메서드모듈의 이름을 다시지어서 코드를 리팩터링해야함
    즉 유비쿼터스 랭귀지의 변화는 모델의 변화임
    또한 도메인전문가는 도메인을 이해하는데 부자연스럽고 부정확한 용어나 구조에 대해 반대의사를 표명해야하고,
    개발자는 설계를 어렵게 만드는 모호함과 불일치를 찾아내야함
    
    즉 유비쿼터스 랭귀지와 모델은 단순히 설계산출물이 아닌,개발자와 도메인전문가가 같이 하는 모든 부문에서 필수불가결한 요소가 되어야함
    
    도메인 전문가와 대화를 할때는,서로간에 공통 추상화 모델을 만들어두고 거기안에서 대화를 해야지,우리쪽 전문용어가 막 나와선 안됨
    또한 그림그리면서 하는게 좋은데,이땐 로직에 대한 순서대로 그림을 그리는게 좋음(상위레벨 추상화를 그린다고 생각하면됨)
    즉 도메인레벨 객체들을 나열해두고,객체들간의 상호작용을 그리는식으로 설명하는게 좋음(즉 객체와 메서드명정도만 가지고)
  2.크게 소리내어 모델링하기
    모델을 정제할땐 모델을 구성하는 다양한 요소들을 직접 말해보면서 어색한부분을 찾으면 좋음
	이러면 어색한부분을 찾기 좋음
	즉
	  시스템에 관해 이야기할떈 모델을 사용하고
	  모델의 요소와 상호작용을 이용하고,모델이 허용하는 범위에 개념을 조합하면서 시나리오를 큰 소리로 말해보고
	  표현해야할걸 더 쉽게 말하는 방법을 찾아내고 이걸 다이어그램과 코드에 적용하기
	이런식으로 하면됨

  3.한팀 한언어
    모델의 핵심은 도메인전문가의 관심을 끌어야함
	즉 도메인전문가가 관심을 가질수있는 수준의 추상화상태여야함
	도메인 전문가도 해당모델을 이해하지 못한다면,모델이 문제가 있는것
	
	사용자가 아직 모델링되지않은 시스템의 향후 특성을 논의하는 초기단계에서야 당연히 모델이 없지만,
	사용자가 개발자와 함께 새 아이디어를 검토하기 시작하면서 공유할 모델을 찾는과정이 시작되고,처음엔 부자연스럽겠지만 정차 정제됨
	그러면서 새 언어가 발전해나감에 따라 도메인 전문가는 해당 언어를 채택하고 여전히 중요한 기존문서를 개정하는데 각별한 노력을 기울여야함
	
	도메인전문가가 개발자와 논의하거나 다른 도메인전문가와 논의할떄 이걸 사용하면 요건에 적합하지않거나 잘못된부분을 발견하기 쉬움
	또한 이걸 기반으로 유스케이스를 작성하고,인수테스트를 구체화함으로써 모델을 훨씬 더 직접적으로 다룰수있음

  4.문서와 다이어그램
    보통 uml다이어그램을 사용해서 그림을 그리면서 회의를 하면 도움이됨
	이건 객체간의 관계를 전달하는데 특히 좋고,상호작용을 보이는데도 알맞음,그러나 해당 객체의 개념적 정의를 전해주진못함
	그래서 말로 의미를 보충해야함
	
	즉 논의의 구심점 역할을 할수있고,여기서 객체간의 관계를 바라보는 관점과 중요한 객체의 이름을 공유할수있음
	문제는 uml을 통해서만 전체모델이나 설계를 전달해야한다고 느낄때 생김
	객체모델 다이어그램은 많은부분이 생략되어있어서 이런거엔 어울리지않음(즉 모든 세부사항을 넣으면 너무 복잡해짐)
	또한 행위와 제약조건 그리기는 매우힘들기도하고
	
	즉 이런 상호작용 다이어그램은 모델의 목적을 암시하는데 사용하는게 좋음
	즉 이건 브레인스토밍용 도구임,그래서 다이어그램은 최소한으로 크기를 줄여야 사용하기좋음(아예 db같은거도뺴버리는경우가 많음)
	
	즉 최상위추상화만 표현하고,세부사항은 코드에 담는것
	
	모델은 다이어그램이 아님,다이어그램은 모델을 전달하고 설명하는데 있음
	
	말은 코드의 정연함과 상세함을 의미적으로 보충할수있지만,규모가 일정이상 커지면 글이 필요해짐
	문서가 어떤 형태를 취하게되면,프로젝트 흐름에서 뒤떨어져서 연관성이 없어지곤 그럼
	그래서 문서를 평가해야하는데
	  문서는 코드와 말을 보완하는 역할을 해야함:설계문서로서의 코드엔 한계가 있고,코드의 세부사항에 압도되기쉬움,또한 행위이면의 의미는 전달하기어려움
	    문서는 코드가 이미 잘하고있는걸 해서는 안됨,즉 코드는 세부사항에 대한 문서라고 볼수있고,이쪽영역은 건드리지않으면됨
	  문서는 유효한 상태를 유지하고 최신내용을 담고있어야함:문서는 현재 사용하는 언어로 상호작용할수있어야하고,계속 수정해야함
	    이걸 못할정도로 문서가 많다면 줄여야함
	또한 문서는 최소한으로 유지하고,코드와 대화를 보완하는데 집중해야함,이래야 문서관리도 쉬움
	
	잘 작성된 코드는 의미전달에 매우 충실할수있지만,코드가 전달하는 메시지가 정확하다는 보장은 없음
	그래서 올바르게 실행되면서 올바른 의미를 전달하는 코드를 작성하는건 어려움
	단,코드는 다른 문서보다 기반역할을 감당하기쉬움
	문제가 생기면 바로 티가나니까
	

  5.설명을 위한 모델
    하나의 모델이 구현,설계,의사소통에 기초가 되어야함
	각 목적별로 다른 모델이 있는건 바람직하지않음
	
	그런데 모델은 도메인을 가르치는 도구로도 유용함,그래서 이런 용도로써의 다른 모델은 사용할수있음
	왜냐면 설계쪽 모델의 경우 해당기능을 수행하는데의 최소한의 수준으로 엄격하게 범위를 줄여야하지만,설명을 위한모델은 도메인의 여러 측면을 포함할수있기때문
	또한 특정 주제에 맞춰 더 전달력이 높은 의사소통방식을 마음껏 만들어낼수있음
	
	이런 설명모델의 경우 객체모델보다 다른방식을 사용하는게 훨씬 좋음
  
  
  
3.모델과 구현의 연계 
  모델은 설계와 코드에 통찰력을 줄수있어야하고,구현에 대한 지침을 줄수 있어야함
  1.모델 주도 설계
    코드와 그것의 기반이 되는 모델이 긴밀하게 연결되면,코드에 의미가 부여되고 모델과 코드가 서로 대응하게됨
	
	도메인모델이 전혀 없고 기능만 구현하기위해 코드를 작성하면,도메인이 복잡해지면 난관에 처할수있음
	또한 여러 복잡한 프로젝트에서 도메인 모델을 시도해도,모델과 코드를 긴밀하게 연결하진못함
	처음엔 실험용도구로 잘쓰이다가 점차 관련성이 떨어지기쉬움
	이건 모델과 코드는 엄연히 다른것이기때문
	
	이런 이유는 다양하고,특히 분석모델을 사용할때 그럼
	분석모델은 설계와 뚜렷히 구분되는,분석만을 위한 모델임
	이건 설계상의 쟁점을 염두에 두고 만들어진게 아니라서,이걸로 모델과 설계의 연결을 할수는 없음
	또한 매우 중요한문제는 관과하고,별로 중요하지않은 문제를 깊이있게 다루기쉬움
	
	설계 혹은 설계의 주된부분이 도메인모델과 대응하지않으면,그모델은 가치가없고 소프트웨어의 정확함도 의심스러워짐
	동시에 모델과 설계 기능 사이의 복잡한 대응은 이해하기힘들고,실제로 설계가 변경되면 유지보수가 불가능해짐
	또한 분석과 설계가 치명적으로 동떨어지고,그에따라 각자의 활동에서 얻은 통찰력이 서로에게 전해지지않음
	
	그래서 분석모델과 설계를 나누면 좋지않음
	이러면 기술적인 쟁점이 배제되기때문
	단,이때 기술적 고려사항때문에 분석이 심각하게 타협되면안되고,도메인아이디어는 반영하지만 소프트웨어 설계 원칙에는 위배된 서툰설계를 받아들여서도 안됨
	즉 분석과 설계 모두에서 효과적인 모델이 필요하고,모델이 구현에대해 비현실적으로 보인다면 새 모델을 찾아내야함
	모델이 도메인의 핵심개념을 충실하게 표현하지않을때도 새 모델을 찾아내야함
	
	이렇게 도메인모델을 설계에 밀접하게 연관시키면,각종 모델가운데 좀 더 유용한것을 선택하는 하나의 기준이 만들어짐
	
	소프트웨어시스템의 일부를 설계할땐 도메인모델을 있는 그대로 반영해서 설계와 모델의 대응을 분명하게하고,
	모델을 재검토해서 자연스럽게 소프트웨어로 구현될수있게 수정해야함
	이렇게 분석과 설계측면을 둘다 만족하는 하나의 모델을 만들어내야함
	
	모델에서도 설계와 기본적인 책임할당에 사용한 용어를 도출하고,
	코드를 작성할때 그 용어를 사용하면 코드가 모델을 표현한게 되고,코드의 변경이 모델의 변경으로 이어질수있음
	
	구현을 모델과 묶으려면 객체지향을 지원해야함(객체기반으로 모델이 나오니까)
	
	간혹 서로 다른 하위시스템에 대해 각기 다른 모델이 있어야할순있지만,한 코드에 대해선 한 모델만 있어야함

  2.모델링 패러다임과 도구 지원
    모델기반 디자인이 성과를 내려면 인간의 오차범위내에서 정확하게 모델과 구현이 직접적으로 대응해야함
	이러려면 객체지향 언어를 사용해야함
	절차지향의 함수만 가지곤 모델을 표현하기 어렵기때문
	
	절차지향에서는 기능을 구현하는건 가능하지만,그거에 대해 명시적으로 모델을 만들고 이름을 붙이는등의 행위는 불가능함
	이럴때 객체를 사용하면 엄청편해짐
	또한 이러면 객체단위로 나눠지니 도메인로직을  단위테스트할수있게됨
	
  3.내부 드러내기:왜 모델이 사용자에게 중요한가
    우리는 시스템에 대한 다양한 시각을 사용자에게 제공할수있음
	그러나 실제로 사용자가 바라보는것과 시스템이 일치하는게 제일 버그가 적음
	
	즉 이것도 사용자모델과 설계구현모델을 통일시켜야 한다는것

  4.실천적 모델러
    한 팀에서는 모든 팀원에게 각기 전문화역할이 있긴해도,너무 빡세게 구분하면 좋지않음
	이러면 모델의 구현과 기술상호작용에 대한 피드백이 간접적이 됨
	특히 코드를 작성하는 사람이 모델에 책임을 느끼지 못하거나,어플리케이션을 대상으로 모델이 동작하게 만드는법을 모른다면,그 모델을 소프트웨어와 무관해짐
	코드의 변경이 모델의 변경이라는 점을 개발자가 인식해야 리팩터링으로 모델을 강화시킬수있음
	
	즉 모델에 기여하는 모든 기술자는,프로젝트내에서 수행하는 역할과 관계없이 코드를 접하는데 일정시간을 투자해야하고,
	코드를 변경하는책임이 있는 모든사람은 코드를 통해 모델을 표현하는법을 반드시 배워야함
  
  
4.도메인의 격리 
  1.레이어드 아키텍처
    도메인에서 발생하는 문제를 해결하는 소프트웨어의 요소는 중요성에 어울리지않게 소프트웨어의 극히 작은부분을 구성함
    이때 여러 객체들이 혼재되어있으면 헷갈리기 쉬우니 도메인과 도메인과 관련이 적은 기능들을 분리해두는데,이게 레이어드 아키텍처임
    여기서 말하는 레이어드 아키텍처는,컨트롤러-서비스-레포지토리가 아닌 컨트롤러-서비스-도메인-레포지토리임
    
    
    매우 간단한 어플리케이션도 ui와 데이터베이스등은 다 필요함
    즉 매우 일부분만 비즈니스로직과 관련되어있음
    
    이때 비즈니스로직에 ui와 외부통신들을 다 넣는방법도 있긴하지만,이경우 만들기 쉽다는 장점 말고 유지보수측면에선 매우 힘들어짐
    ui의 변경이 비즈니스로직의 변경과 이어지기 쉽기때문
    즉 좀만 복잡해져도 관심사의 분리가 필요해짐
    
    이때 사용되는 가장 기본적인 방법이 레이어드 아키텍처임
    이건 한 계층의 의존요소는 반드시 같은계층이나 아래계층이어야한다는것
    위로 올라가는 의사소통은 간접적인 메커니즘(di)을 거쳐야함
    
    이런식으로 계층화를 하면,각 계층이 프로그램의 특정 측면만을 전문적으로 다룰수있게되고,이를통해 응집력을 올릴수있음
    여기서의 핵심은 도메인계층을 분리하는것
	
	중요한건 응용계층(서비스계층)이 아닌 도메인계층에서 비즈니스로직을 책임지고있어야함
	
	계층을 분리하면 도메인계층의 설계가 향상되지만,계층은 당연히 서로 연결되어야함
	이걸위해 각 계층은 설계의존성을 오직 한 방향으로만 둬서 느슨하게 결합함
	상위계층은 하위계층의 공개 인터페이스를 호출하고,직접사용하지않음
	또한 하위에서 상위로 소통이 필요하면,콜백이나 템플릿메서드같은 형식으로 소통해야함
	
	인프라계층에선 도메인계층에서 어떤 활동이 일어나는지 알수없고 알필요도 없어야함
	이런건 서비스의 역할
	즉 이벤트가 터져서 메일을 보낸다고 했을떄,
	서비스는 언제 보낼지 알고 어떻게 보내는지 모른다면,인프라는 어떻게 보낼진 알지만 언제 보낼진 모르는식
	
	이런 인프라들의 요구사항을 통합한 프레임워크는 종종 특수한 방식으로 구현되길 요구하는데,만약 이때 프레임워크가 설계를 방해한다면,
	그냥 그부분은 순수코드로 짜는 방법도 있음
	즉 스프링쓸때 도메인은 순수자바로 짜는거처럼 그런식으로 하는거임
	또한 한 프레임워크로 해결하지 못하는건 여러 프레임워크를 써서 해결하거나
	

  2.도메인 계층은 모델이 살아가는곳
    도메인 모델은 일련의 개념을 모아둔것
	이 층은 그런 모델과 설계요소에 직접적으로 관련된 모든것을 명시한것임
	그래서 도메인계층은 업무로직에 대한 설계와 구현으로 구성됨
	모델 기반 디자인에선 도메인계층의 소프트웨어 구성물이 모델의 개념을 반영함
	
	도메인로직이 프로그램상의 다른 관심사와 섞여있다면,이걸 달성하기 어려움,그래서 도메인주도설계의 전제조건은 도메인구현을 격리하는것

  3.스마트ui 안티패턴
    이건 ui와 서비스,도메인등을 한군데 뭉쳐둔것
	이건 간단한 프로젝트를 만들때는 사용할만하고,특히 경험이 많지않은팀에서 작은규모의 프로젝트를 할때 적합함
	대신 이건 추상화도 없어서 리팩터링도 힘들고,여러 많은 문제점들이 있음
	대신 초기개발속도가 빠름
	
	이 스마트ui와 레이어드아키텍처의 중간에 있는게 트랜잭션스크립트
	
  4.다른 종류의 격리
    도메인모델은 다른 인프라나 사용자 인터페이스의 영향을 받고,모델에 완전히 통합되지않는 기타 도메인구성요소를 다뤄야함
	갖가지 이유로 모델은 불분명해지고 모델의 효용성을 잃기 쉬움
	이걸 해결하기 위해 여러 방법들이 있음
  
  
5.소프트웨어에서 표현되는 모델
  연속성과 식별성을 지니면 엔티티고,그냥 상태일뿐이면 밸류오브젝트(vo)임
  또한 객체보단 행동이나 연산으로 명확히 표현되는건 서비스로 표현하면됨(이건 클라요청에 대해 수행되는 뭔가를 의미)
  모듈(패키지)은 높은응집도와 낮은결합도를 도메인개념에서도 적용해야함
  
  1.연관관계
    모델링과 실제구현간의 상호작용은 여러 객체간 연관관계에서 특히 까다로움
	
	모델내의 모든 탐색가능한 연관관계에 대해 그것과 같은 특성을 지닌 메커니즘은 소프트웨어에도 있는데,
	구현과 설계가 달라질수있기때문
	특히 다대다 양방향 연관관계같은경우 최대한 연관관계를 걷어내야하는데,안그러면 구현과 유지보수가 매우 복잡해지기때문
	그래서 단방향으로 만들고,한정자를 추가해서 다중성을 줄이고,중요하지않은 연관관계는 제거하는식으로 해결해야함
	
	즉 가능한 관계를 제약하는게 중요함
	양방향의 경우 양쪽객체 모두 있어야하지만,단방향의 경우 탐색이 필요없으면 없어도되기때문
	그래서 상호의존성이 줄어들고 설계가 단순해짐
	추가적으로 도메인을 이해하면 도메인 본연의 방향성이 드러나기도 하고
	
	도메인을 깊이 이해하다보면 굉장히 자주 한정적인 관계에 이름
	이건 다중성을 일대일로 줄이고,중요한규칙을 명시적으로 모델에 포함시킴
	
	도메인의 특성이 반영되게끔 연관관계를 일관되게 제약하면,연관관계의 의사전달력이 풍부해지고 구현이 단순해지며,나머지 양방향 연관관계도 의미를 가지게됨
	관계의 양방향성이 도메인의 특징이 될수있기때문(즉 양방향성이라는게 특이한점이 됨)
	물론 방향성 자체가 필요없을경우 없애버리는게 젤 좋음

  2.엔티티
    엔티티란 객체의 속성이 아닌 연속성과 식별성이 이어지는(id가 있는) 객체를 말함
	즉 속성이 아닌 식별성에 의해 정의되는 객체임
	
	엔티티는 모델링과 설계상의 특수고려사항이 포함되어있고,엔티티는 항상 연속성이 유지되어야하고 식별성이 정의되어있어야함
	특정 속성보단 정체성에 초점을 맞춰서 클래스정의와 책임등이 만들어져야함
	
	한 객체가 속성보단 식별성으로 구분되면 모델내에서 이를 해당객체의 주된 정의로 삼고,클래스정의를 단순하게 하고 이 연속성과 식별성에 집중해야함
	또한 객체의 형태나 이력에 관계없이 각 객체를 구별하는 수단을 정의해야함
    
	즉 경기장의 좌석같은건 일반석일경우 vo로 충분하지만(vo도 필요없고 필드여도됨),지정석일경우 엔티티여야함
	
	엔티티를 모델링할땐 연산과 속성 모두 중요하지만,연산이 더 중요함
	엔티티의 가장 기본적인 책임은 객체의 행위가 명확하고 예측가능해질수있게 연속성을 확립해야하기때문
	그래서 엔티티를 식별하고 탐색하며 일치하는데 널리 사용되는 특징만으로 정의하고,여기에 필요한 연산과 속성만 추가하고,나머지는 밖으로 옮기는게 좋음
	이 옮긴애들은 다른 엔티티나 vo가 됨
	
	엔티티의 식별성은 모든 상태에서 유일해야함

  3.vo(value object)
    값객체는 단순한 상태를 모아둔것
	만약 식별성이 필요없는 객체가 있다면,이건 vo임
	추가적으로 얘들은 어떤 사물(엔티티)를 서술하는 객체임
	이건 vo에 해당하는 요소가 어느것인지는 관심없고 무엇인지에만 관심이 있을때 사용하게됨
	
	예를들어 색상같은게 있음
	
	vo가 엔티티를 참조하는것도 가능함(가는길같은거),또한 dto처럼 메시지의 매개변수로도 사용되고,일시적인 용도로도 사용됨
	또한 엔티티의 속성으로도 사용됨(이름같은거)
	
	vo는 불변이어야하고,vo를 구성하는 속성은 개념적 완전성을 형성해야함(vo 그 자체로 의미가 있어야함)
	
	vo는 불변적으로 강제되어야 막쓸수있어서 편함
	다른곳에서 변경이 필요할경우 새 vo를 만들어서 갈아끼는형태
	이러면 가비지컬렉션에서도 편하게 지울수있음
	
	엔티티간 양방향 연관관계가 유지하기는 어렵지만 논리적으로는 타당하다면,vo간 양방향 연관관계는 논리적으로 성립되지않음
	vo간 양방향 연관관계는 완전히 제거해야함,만약 필요해 보인다면,그건 vo가 아닌 엔티티일수있음
	
  4.서비스
    여기서 말하는 서비스는 도메인서비스임
	특정 엔티티나 vo에 속하기 애매한애들을 억지로 넣는거보단,이거 전용으로 뽑아내는게 나음
	이런애들의 특징은
	  manager같은게 이름끝에 붙음
	  상태가 없음
	  인터페이스가 도메인 외적인 측면에서 정의됨
	이런 서비스들은 순전히 클라에 무엇을 제공할수있냐에 존재이유가 있음
	그래서 엔티티나 vo가 동사나 명사로 이름을 짓는다면,서비스는 활동으로 이름을 지음
	
	서비스는 적절히 사용되어야하고,엔티티나 vo의 모든 책임을 가져와서는 안됨
	또한 상태가 없다는 특성상 싱글톤으로 운용이 가능함
	
	즉 도메인의 중대한 프로세스나 변환과정이 엔티티나 vo의 책임이 아니라면,연산을 서비스로 선언되는 독립 인터페이스로 추가하고,
	모델의 언어라는 측면에서 인터페이스를 정의하고 연산의 이름을 유비쿼터스 랭귀지의 일부가 되게 구성해야함
	또한 서비스는 상태를 가지면 안됨
	
	도메인서비스와 응용서비스,인프라서비스를 구별하는것도 중요함
	인프라 서비스는 좀 더 하위계층과(실제 db나 이메일전송객체)친하고,
	응용서비스는 도메인과 비슷하지만 좀 더 상위계층의 일을 함,즉 컨트롤러에서 내린 명령을 직접수행하는등의 일을 함
	도메인서비스는 좀 더 하나의 작은 행위에 가까운 일을 함(계좌에서 다른계좌로 이체)
	즉 도메인레벨에서의 일을 하는데,한 도메인에서 처리하기 애매한것들이 도메인서비스에 들어감
	
	도메인 서비스는 도메인지식이 도메인에서 빠져나가지 않게하는데 유용함
	또한 도메인서비스는 도메인처럼 pojo로 구성하는게 좋음

  5.모듈(패키지)
    모듈은 인지적 과부하를 줄이기위해 사용됨
	즉 전체를 보지않고 모듈안의 내용만 보거나,모듈의 세부사항을 보지않고 모듈끼리의 상관관계만 보거나 이런식
	
	모듈간에는 결합도가 낮아야하고,모듈의 내부는 응집도가 높아야함
	모듈로 쪼개지는것은 개념이고,한번에 생각하는게 합리적인애들끼리 뭉쳐야함
	
	모듈은 객체의 초기형태를 조직화할 목적으로 사용됨
	이러면 객체는 기존 모듈이 정의한 범위안에 머무를수있게 변화함
	
	모듈을 리팩터링하는건 클래스리팩터링보다 할일이 많고,파급효과도크고 그래서 자주하긴 힘듬
	그래서 계속 지나다보면 모듈이 추상적으로 변하기쉬움
	이걸 넘기지말고 도메인을 이해하는 바가 바뀔때마다 모듈에도 반영해야,모듈안의 객체도 더 자유롭게 발전할수있음
	
	우리는 분할되는 객체의 의미에 따라 모듈을 선택해야함
	한 모듈안에 들어있는 클래스들은 그 클래스들은 하나로 묶어서 생각하니,만들때도 묶어서 생각할애들만 묶어야한다는것
	
	모듈은 모델과 같이 발전해야함
	그래서 모듈에 대한리팩터링이 모델과 코드와 같이 일어아냐함
	근데 모듈은 리팩터링하는게 매우 힘듬(범위가 넓어서)
	그래도 하긴해야함
	
	또한 프레임워크에서 원하는식으로의 패키지화는,어떤건 받아들이고 어떤건 받아들이지 않을 필요가 있음
	특히 기술적인 정교함이 주도하는 패키지화계획은,개념적객체를 구성하는 요소가 떨어지기쉬움
	
	즉 단순하게 유지하는게 가장 좋고,기술환경에 필수적이거나 실질적으로 개발에 도움이 되는 최소한의 분할규칙만 선택하는게좋음
	또한 도메인은 다른코드로부터 계층을 분리하는게 좋음
  
  6.모델링패러다임
  
  
  
  
  
  
  
  
  