1.지식탐구
  모든 소프트웨어는 그 소프트웨어를 사용하는 사용자의 활동이나 관심사에 관련되어있고,
  사용자가 프로그램을 사용하는 대상영역이 바로 해당 프로그램의 도메인임
  보통 도메인은 컴퓨터와 거의 관련이 없음
  
  이때 개발을 하려고 하면 도메인 지식의 양에 압도되지않기위해서 사용하는게 모델임
  모델은 지식을 선택적으로 단순화하고 의식적으로 구조화한 형태임
  
  도메인모델은 특정 다이어그램이 아니라,다이어그램이 전달하고자 하는 아이디어임
  도메인모델이란 도메인 전문가의 머릿속에 존재하는 지식을 엄격하게 구성하고 선택적으로 추상화한것
  우리는 다이어그램을 이용해 모델을 표현하고 전달할수있음
  
  도메인 모델링은 가능한 한 사실적인 모델을 만드는게 아니고,단순히 필요한 결과를 내는 소프트웨어를 만드는것도 아님
  전체 도메인중 일부분만을 취합해서 만들어내는것
  
  모델의 쓰임새는
    모델과 핵심설계는 서로 영향을 주며 구체화됨,모델을 의미있게 만들고 모델이 최종산출물에 적용되게 보장하는건 모델과 구현간의 긴밀한 연결임
	  또한 유지보수에도 도움을 줌(모델을 통해 코드를 해석할수있기때문)
	모델은 모든 팀 구성원이 사용하는 언어의 중추임,모델과 구현이 서로 연결되어있으므로 개발자와 도메인전문가 모두 번역없이 이걸 사용해 대화를 나눌수있음
	모델은 지식의 정수만을 뽑아낸것,모델은 도메인지식을 조직화하고 가장 중요한 요소를 구분하는 팀의 합의된 방식임
	  모델에는 용어의 선택이유,개념의 분류,분류된 지식을 연관시킬때의 도메인에 관한 우리의 사고방식이 담겨있음
  임
  
  소프트웨어란 사용자를 위해 도메인에 관련된 문제를 해결하는데 있음
  그밖의 모든 기능도 이런 기본목적을 뒷받침하는데 있고
  도메인이 복잡하면 이같은 문제해결의 난이도는 올라가고 개발자는 도메인연구에 몰두해야하지만
  보통 개발자는 이런걸 좋아하지않음(무질서하고 도움이 안될거같기때문)
  
  그런데 여기서도 얻을수있는게 많고,즉 모델을 만드는데 사용할수있는 체계적인 사고방식과 불규칙한 소프트웨어 어플리케이션에 질서를 부여할수있는 설계기법이 있음
  
  도메인 모델을 만들땐 도메인전문가와 같이 객체 상호작용다이어그램을 그려가면서 하면 좋음
  즉 브레인스토밍과 정제를 반복해가는식
  
  이렇게 코드를 좀 작성해서 예제를 만들수있을수있을정도로 이해가 됐다고 생각하면,매우 간단한(인프라같은거 다 제외한) 예제를 만들어서 같이 돌려보는거임
  이렇게 하면 데모엔 전문가는 모델이 의미하는바와 동작하는  소프트웨어와 모델의 관계를 더 명확하게 이해할수있음
  이러면 소통이 양방향이 되고,내가 새로 알게된 지식을 모델에 통합하고 그걸 소프트웨어에 반영하는걸 도메인전문가가 보고 피드백을 줄수있음
  
  1.효과적인 모델링의 요소
    즉 모델링을 하는 방법은
	  모델과 구현의 연계:초기 프로토타입을 토대로 본질적인 연결고리를 만들고,모든 반복주기 내내 그걸 유지
	  모델을 기반으로 하는 언어 정제:프로젝트에 참여하는 모두가 모델에서 용어를 바로 끄집어내어 모델의 구조와 일관되게 문장을 만들수있게 해야함
	  풍부한 지식이 담긴 모델 개발:객체는 행위를 지니고 규칙을 이행함,또한 모델에는 다양한 지식이 포함되어있음
	  모델의 정제:모델이 점차 완전해지면서 중요한 개념이 더해지고,쓸모없거나 중요하지않다고 판명된 개념이 제거됐다는거도 중요함
	  브레인스토밍과 실험:스케치를 비롯해 결합된 언어를 바탕으로 토의를 모델에 대한 실험실로 변모시켜,수백가지 변종을 연습하고 시도하고 평가해봐야함
	이런식의 요소들이 있어야함
	
  2.지식탐구
    도메인 모델링을 수행할때도 지식을 면밀히 탐구하고,
	많은양의 정보속에서 아주 미미한 관련성을 찾아내서 전체를 이해할수있는 간결한 관점을 찾아 체계적인 아이디어를 차례로 시도해봄
	이과정에서 수많은 모델이 시도,거부,변형되고,모든 세부사항에 맞는 일련의 추상적 개념이 나타나면 성공임
	이렇게 해서 뽑아낸 정수는 가장 적절한것으로 밝혀진 특정지식을 엄밀하게 표현한것
	
	지식탐구는 혼자하는활동이 아니고,개발자와 도메인전문가로 구성된팀은 대체로 개발자가 이끄는가운데 협업함
	그들은 함께 정보를 받아들여 그걸 유용한 형태로 만듬
	원재료가 되는 지식은 도메인 전문가의 머릿속이나 기존 시스템 사용자,동일한 도메인에 관련된 레거시팀의 기술팀,다른프로젝트에서 얻은 경험에서 나옴
	이런 지식은 프로젝트나 업무에 활용할 용도로 작성된 문서의 형태를 띄고,대화의 형태로 존재할때가 훨씬 더 많음
	
	이런방식은 워터폴에서는 하기힘들었고,또한 지식의 축적또한 일어나지않음(특히 도메인전문가에게)
	또한 추상화를 하지않으면 지식을 축적하기 힘듬
	물론 결과를 도메인전문가에게 보여주고,전문가가 원하는대로만 하면 만들수는 있는데,대단한건 만들기힘듬
	
	애초에 추상화를 시작해서 더 많은 일을 해낼수있는 모델로 발전시키는게 좋고,
	이 과정은 도메인 전문가와의 협업을 통해 기술적인 측면 뿐 아니라 개념적인 측면에서도 발전되어야함
	
	즉 개발자는 기능만을 기계적으로 만들지않고,자신이 보조하는 업무의 중요원칙을 배우고,
	도메인전문가는 자신의 지식의 정수를 추출하는법을 배우고 소프트웨어에서 중요한 개념적 엄밀함을 이해하게됨
	
	이런식으로 만들어진 모델은,프로젝트 내내 흘러가는 정보들을 조직화하는 도구로 자리잡음
	모델은 요구사항 분석에 초점을 맞추고,이건 프로그래밍과 설계와 밀접한 관계를맺음
	모델은 도메인을 이해하는데 실용적이고 유용해야하고,쉽게 구현하고 이해하기에 충분할만큼 엄밀해야함

  3.지속적인 학습
    소프트웨어를 작성하기 시작할때,우리는 충분히 알지 못한 상태에서 시작함
	또한 모든 프로젝트에서는 지식이 새어나감(이직등)
	그래서 이것이상으로 의식적으로 지식을 함양해야하는데,이건 기술적인것과 도메인모델링 모두를 포함하고,해당 프로젝트의 도메인도 포함됨
	
	개발자가 필요로하는건 도메인전문가가 되는길이 아님,
	중요한건 도메인 전문가와 대화할수있고,그걸 어플리케이션에 관련되게 번역하고,내가 만든 어플리케이션이 정상동작하는지 점검할수있게되는거임

  4.풍부한 지식이 담긴 설계
    모델에 포함된 지식은 단순한 명사찾기 이상임
	도메인에 관련된 엔티티만큼 업무활동과 규칙도 도메인에 중요한데,도메인엔 다양한 범주의 개념이 존재하고,지식탐구는 이런 통찰력을 반영하는 모델을 만들어냄
	개발자는 모델의 변경에 맞춰 구현을 리팩터링해서 모델의 변경된사항을 표현하고,어플리케이션에서는 그런 지식을 활용함
	
	이땐 엔티티와 값을 너머 이런 활동들이 이뤄져야함
	이건 여러 업무규칙간 모순이 있을수있기때문(특정 화물은 10%만큼 오버부킹해도된다던가)
	도메인전문가는 보통 이런걸 무의식적으로 처리하기때문에 이걸 의식적으로 끌어내야함
	
	즉 감춰진 개념을 추출할수있어야함
	또한 이렇게 생긴 규칙을 도메인전문가가 해당부분의 코드를 보고 이해할수있게 해야함(메서드추출이나 클래스추출을 사용해서 패턴의 사용등) 
	
	즉 이런 명시적인 설계는 
	  프로그래머와 그밖의 모든이가 규칙의 특성을 불분명한 계산이 아니라 중요한 업무규칙임을 알아야하고
	  프로그래머는 도메인전문가에게 그들이 이해할수있는 수준에서의 기술적 산출물,심지어 코드까지 보여주고(안내해주면서) 피드백을 받을수있어야함
	
  5.심층 모델
    유용한 모델은 겉으로 드러나있는 경우가 거의없음
	보통 처음에 중요하게 생각했던 피상적인 모델요소를 버리거나 관점을 바꾸게됨 
	그래서 처음엔 나타나기 힘들지만 문제의 핵심을 관통하는 포착하기 힘든 추상화가 서서히 드러나게됨
	
  
2.의사소통과 언어 사용 
  1.유비쿼터스 랭귀지
    도메인 모델은 프로젝트의 공통언어의 핵심이 되어야함
    모델은 프로젝트에 참여한 사람들의 머릿속에 축적된 개념을 모아둔것으로,도메인에 대한 통찰력을 반영하는 용어와 관계로 표현됨
    이건 기술적인 개발을 할수있을만큼 충분히 정확하면서,도메인에 맞게 조정된 언어의 의미체계를 제공해야함
    이건 모델을 개발과 결부시키고 모델을 코드에 연계하는데 매우 중요한 연결고리 역할을 함
    
    이런 모델기반 의사소통은 통합모델링언어상의 다이어그램으로 한정돼서는 안됨
    모든 의사소통의 기반에 이게 들어있어야함
    
    도메인전문가는 소프트웨어개발의 전문용어를 이해하는데 한계가 있지만,자신의 전문분야의 전문용어는 다양하게 사용함
    개발자는 시스템을 서술적이고 기능적으로 이해하고 토론할순없지만 전문가의 언어에 담긴 의미는 알지못함,
    또는 설계는 하지만 도메인전문가가 이해하지못하는 방식으로 추상화할수도있음
    
    이런식으로 공통언어가 없는 프로젝트에선 서로간에 번역이 필요하고,이렇게 번역할수있는사람이 병목이되고 모델의 개념이 혼란스러워짐
    문제는 이 상태가 겉으로 드러나지않는다는것
    결국 조화가 깨진,신뢰할수없는 소프트웨어가 만들어짐
    
    즉 프로젝트내에선 언어가 통일되어야함,즉 토론에 쓰이는 언어와 코드에 녹아든 언어가 같아야함
    그래서 사용되는게 유비쿼터스 랭귀지임
    
    유비쿼터스 랭귀지엔 클래스의 주요연산 이름이 있고,여기엔 모델내에서 명시적으로 드러나는 규칙을 토론하기위한 용어가 포함됨
    여기엔 모델에 부과된 높은 수준의 구성원칙에서 비롯된 용어도 더해지고,도메인모델에 적용하는 패턴의 이름으로 풍부해짐
    
    모델기반언어는 개발자사이뿐 아니라 업무와 기능을 기술할때도 사용해야하고,도메인전문가들 끼리도 의사소통할때 사용할수있을정도여야함
    물론 초기모델은 이렇게 하기 힘들고,전문용어는 모호함과 모순을 가지고있어서 그대로 사용하진못함
    그래서 개발자가 코드에 구현한 세부사항에서 나오는 특징이 빠져있을수도있는데,
    이건 개발자가 전문용어를 모델의요소로 여기지않거나 절차지향이거나 도메인의 해당개념을 불분명하게 전달했을때 발생함
    
    이걸 계속 반복하다보면 모델의 취약점이 드러나고,실험을 토대로 부자연스러운 용어나 결합의 대안을 찾아낼수있음
    또한 공백을 찾으면 거기에 해당하는 단어를 붙이고,이런 언어의 변화는 도메인모델의 변화로 인식되고,
    이렇게 용어의 의미가 바뀌면 클래스다이어그램을 수정하고 코드상의 클래스와 메서드명도 바뀌고,심지어는 동작방식도 바뀔수있음
    
    개발자는 이렇게 구현이라는 맥락에서 이런 언어를 사용하고,의미가 부정확하거나 모순되는 사항을 지적해서 도메인 전문가가 실행가능한 대안을 생각해내게 만들어야함
    물론 도메인전문가는 더 폭넓은 맥락을 설명하거나 설정하고자 유비쿼터스 랭귀지의 범위를 넘어서서 말하겠지만,이 모델이 다루는 범위 안에서는 이걸 사용해서 말해야하고,
    이게 부자연스럽거나 불완전하거나,틀린경우에는 관심을 기울려야함
    즉 모든상황에서 모델기반언어를 사용하고,이게 자연스럽게 느껴질때까지 노력해야 간결한 요소로 복잡한 아이디어를 표현할수있는 완전하고 이해하기 쉬운 모델을 만들어낼수있음
    
    즉 모델은 언어의 근간이고,이걸 문서건 말할때건 다이어그램이건 다 똑같이 써야함
    또한 해당모델의 대안이 되는 표현을 시도해서 이상한부분을 제거하고,거기에 맞춰서 클래스메서드모듈의 이름을 다시지어서 코드를 리팩터링해야함
    즉 유비쿼터스 랭귀지의 변화는 모델의 변화임
    또한 도메인전문가는 도메인을 이해하는데 부자연스럽고 부정확한 용어나 구조에 대해 반대의사를 표명해야하고,
    개발자는 설계를 어렵게 만드는 모호함과 불일치를 찾아내야함
    
    즉 유비쿼터스 랭귀지와 모델은 단순히 설계산출물이 아닌,개발자와 도메인전문가가 같이 하는 모든 부문에서 필수불가결한 요소가 되어야함
    
    도메인 전문가와 대화를 할때는,서로간에 공통 추상화 모델을 만들어두고 거기안에서 대화를 해야지,우리쪽 전문용어가 막 나와선 안됨
    또한 그림그리면서 하는게 좋은데,이땐 로직에 대한 순서대로 그림을 그리는게 좋음(상위레벨 추상화를 그린다고 생각하면됨)
    즉 도메인레벨 객체들을 나열해두고,객체들간의 상호작용을 그리는식으로 설명하는게 좋음(즉 객체와 메서드명정도만 가지고)
  2.크게 소리내어 모델링하기
    모델을 정제할땐 모델을 구성하는 다양한 요소들을 직접 말해보면서 어색한부분을 찾으면 좋음
	이러면 어색한부분을 찾기 좋음
	즉
	  시스템에 관해 이야기할떈 모델을 사용하고
	  모델의 요소와 상호작용을 이용하고,모델이 허용하는 범위에 개념을 조합하면서 시나리오를 큰 소리로 말해보고
	  표현해야할걸 더 쉽게 말하는 방법을 찾아내고 이걸 다이어그램과 코드에 적용하기
	이런식으로 하면됨

  3.한팀 한언어
    모델의 핵심은 도메인전문가의 관심을 끌어야함
	즉 도메인전문가가 관심을 가질수있는 수준의 추상화상태여야함
	도메인 전문가도 해당모델을 이해하지 못한다면,모델이 문제가 있는것
	
	사용자가 아직 모델링되지않은 시스템의 향후 특성을 논의하는 초기단계에서야 당연히 모델이 없지만,
	사용자가 개발자와 함께 새 아이디어를 검토하기 시작하면서 공유할 모델을 찾는과정이 시작되고,처음엔 부자연스럽겠지만 정차 정제됨
	그러면서 새 언어가 발전해나감에 따라 도메인 전문가는 해당 언어를 채택하고 여전히 중요한 기존문서를 개정하는데 각별한 노력을 기울여야함
	
	도메인전문가가 개발자와 논의하거나 다른 도메인전문가와 논의할떄 이걸 사용하면 요건에 적합하지않거나 잘못된부분을 발견하기 쉬움
	또한 이걸 기반으로 유스케이스를 작성하고,인수테스트를 구체화함으로써 모델을 훨씬 더 직접적으로 다룰수있음

  4.문서와 다이어그램
    보통 uml다이어그램을 사용해서 그림을 그리면서 회의를 하면 도움이됨
	이건 객체간의 관계를 전달하는데 특히 좋고,상호작용을 보이는데도 알맞음,그러나 해당 객체의 개념적 정의를 전해주진못함
	그래서 말로 의미를 보충해야함
	
	즉 논의의 구심점 역할을 할수있고,여기서 객체간의 관계를 바라보는 관점과 중요한 객체의 이름을 공유할수있음
	문제는 uml을 통해서만 전체모델이나 설계를 전달해야한다고 느낄때 생김
	객체모델 다이어그램은 많은부분이 생략되어있어서 이런거엔 어울리지않음(즉 모든 세부사항을 넣으면 너무 복잡해짐)
	또한 행위와 제약조건 그리기는 매우힘들기도하고
	
	즉 이런 상호작용 다이어그램은 모델의 목적을 암시하는데 사용하는게 좋음
	즉 이건 브레인스토밍용 도구임,그래서 다이어그램은 최소한으로 크기를 줄여야 사용하기좋음(아예 db같은거도뺴버리는경우가 많음)
	
	즉 최상위추상화만 표현하고,세부사항은 코드에 담는것
	
	모델은 다이어그램이 아님,다이어그램은 모델을 전달하고 설명하는데 있음
	
	말은 코드의 정연함과 상세함을 의미적으로 보충할수있지만,규모가 일정이상 커지면 글이 필요해짐
	문서가 어떤 형태를 취하게되면,프로젝트 흐름에서 뒤떨어져서 연관성이 없어지곤 그럼
	그래서 문서를 평가해야하는데
	  문서는 코드와 말을 보완하는 역할을 해야함:설계문서로서의 코드엔 한계가 있고,코드의 세부사항에 압도되기쉬움,또한 행위이면의 의미는 전달하기어려움
	    문서는 코드가 이미 잘하고있는걸 해서는 안됨,즉 코드는 세부사항에 대한 문서라고 볼수있고,이쪽영역은 건드리지않으면됨
	  문서는 유효한 상태를 유지하고 최신내용을 담고있어야함:문서는 현재 사용하는 언어로 상호작용할수있어야하고,계속 수정해야함
	    이걸 못할정도로 문서가 많다면 줄여야함
	또한 문서는 최소한으로 유지하고,코드와 대화를 보완하는데 집중해야함,이래야 문서관리도 쉬움
	
	잘 작성된 코드는 의미전달에 매우 충실할수있지만,코드가 전달하는 메시지가 정확하다는 보장은 없음
	그래서 올바르게 실행되면서 올바른 의미를 전달하는 코드를 작성하는건 어려움
	단,코드는 다른 문서보다 기반역할을 감당하기쉬움
	문제가 생기면 바로 티가나니까
	

  5.설명을 위한 모델
    하나의 모델이 구현,설계,의사소통에 기초가 되어야함
	각 목적별로 다른 모델이 있는건 바람직하지않음
	
	그런데 모델은 도메인을 가르치는 도구로도 유용함,그래서 이런 용도로써의 다른 모델은 사용할수있음
	왜냐면 설계쪽 모델의 경우 해당기능을 수행하는데의 최소한의 수준으로 엄격하게 범위를 줄여야하지만,설명을 위한모델은 도메인의 여러 측면을 포함할수있기때문
	또한 특정 주제에 맞춰 더 전달력이 높은 의사소통방식을 마음껏 만들어낼수있음
	
	이런 설명모델의 경우 객체모델보다 다른방식을 사용하는게 훨씬 좋음
  
  
  
3.모델과 구현의 연계 
  모델은 설계와 코드에 통찰력을 줄수있어야하고,구현에 대한 지침을 줄수 있어야함
  1.모델 주도 설계
    코드와 그것의 기반이 되는 모델이 긴밀하게 연결되면,코드에 의미가 부여되고 모델과 코드가 서로 대응하게됨
	
	도메인모델이 전혀 없고 기능만 구현하기위해 코드를 작성하면,도메인이 복잡해지면 난관에 처할수있음
	또한 여러 복잡한 프로젝트에서 도메인 모델을 시도해도,모델과 코드를 긴밀하게 연결하진못함
	처음엔 실험용도구로 잘쓰이다가 점차 관련성이 떨어지기쉬움
	이건 모델과 코드는 엄연히 다른것이기때문
	
	이런 이유는 다양하고,특히 분석모델을 사용할때 그럼
	분석모델은 설계와 뚜렷히 구분되는,분석만을 위한 모델임
	이건 설계상의 쟁점을 염두에 두고 만들어진게 아니라서,이걸로 모델과 설계의 연결을 할수는 없음
	또한 매우 중요한문제는 관과하고,별로 중요하지않은 문제를 깊이있게 다루기쉬움
	
	설계 혹은 설계의 주된부분이 도메인모델과 대응하지않으면,그모델은 가치가없고 소프트웨어의 정확함도 의심스러워짐
	동시에 모델과 설계 기능 사이의 복잡한 대응은 이해하기힘들고,실제로 설계가 변경되면 유지보수가 불가능해짐
	또한 분석과 설계가 치명적으로 동떨어지고,그에따라 각자의 활동에서 얻은 통찰력이 서로에게 전해지지않음
	
	그래서 분석모델과 설계를 나누면 좋지않음
	이러면 기술적인 쟁점이 배제되기때문
	단,이때 기술적 고려사항때문에 분석이 심각하게 타협되면안되고,도메인아이디어는 반영하지만 소프트웨어 설계 원칙에는 위배된 서툰설계를 받아들여서도 안됨
	즉 분석과 설계 모두에서 효과적인 모델이 필요하고,모델이 구현에대해 비현실적으로 보인다면 새 모델을 찾아내야함
	모델이 도메인의 핵심개념을 충실하게 표현하지않을때도 새 모델을 찾아내야함
	
	이렇게 도메인모델을 설계에 밀접하게 연관시키면,각종 모델가운데 좀 더 유용한것을 선택하는 하나의 기준이 만들어짐
	
	소프트웨어시스템의 일부를 설계할땐 도메인모델을 있는 그대로 반영해서 설계와 모델의 대응을 분명하게하고,
	모델을 재검토해서 자연스럽게 소프트웨어로 구현될수있게 수정해야함
	이렇게 분석과 설계측면을 둘다 만족하는 하나의 모델을 만들어내야함
	
	모델에서도 설계와 기본적인 책임할당에 사용한 용어를 도출하고,
	코드를 작성할때 그 용어를 사용하면 코드가 모델을 표현한게 되고,코드의 변경이 모델의 변경으로 이어질수있음
	
	구현을 모델과 묶으려면 객체지향을 지원해야함(객체기반으로 모델이 나오니까)
	
	간혹 서로 다른 하위시스템에 대해 각기 다른 모델이 있어야할순있지만,한 코드에 대해선 한 모델만 있어야함

  2.모델링 패러다임과 도구 지원
    모델기반 디자인이 성과를 내려면 인간의 오차범위내에서 정확하게 모델과 구현이 직접적으로 대응해야함
	이러려면 객체지향 언어를 사용해야함
	절차지향의 함수만 가지곤 모델을 표현하기 어렵기때문
	
	절차지향에서는 기능을 구현하는건 가능하지만,그거에 대해 명시적으로 모델을 만들고 이름을 붙이는등의 행위는 불가능함
	이럴때 객체를 사용하면 엄청편해짐
	또한 이러면 객체단위로 나눠지니 도메인로직을  단위테스트할수있게됨
	
  3.내부 드러내기:왜 모델이 사용자에게 중요한가
    우리는 시스템에 대한 다양한 시각을 사용자에게 제공할수있음
	그러나 실제로 사용자가 바라보는것과 시스템이 일치하는게 제일 버그가 적음
	
	즉 이것도 사용자모델과 설계구현모델을 통일시켜야 한다는것

  4.실천적 모델러
    한 팀에서는 모든 팀원에게 각기 전문화역할이 있긴해도,너무 빡세게 구분하면 좋지않음
	이러면 모델의 구현과 기술상호작용에 대한 피드백이 간접적이 됨
	특히 코드를 작성하는 사람이 모델에 책임을 느끼지 못하거나,어플리케이션을 대상으로 모델이 동작하게 만드는법을 모른다면,그 모델을 소프트웨어와 무관해짐
	코드의 변경이 모델의 변경이라는 점을 개발자가 인식해야 리팩터링으로 모델을 강화시킬수있음
	
	즉 모델에 기여하는 모든 기술자는,프로젝트내에서 수행하는 역할과 관계없이 코드를 접하는데 일정시간을 투자해야하고,
	코드를 변경하는책임이 있는 모든사람은 코드를 통해 모델을 표현하는법을 반드시 배워야함
  
  
4.도메인의 격리 
  1.레이어드 아키텍처
    도메인에서 발생하는 문제를 해결하는 소프트웨어의 요소는 중요성에 어울리지않게 소프트웨어의 극히 작은부분을 구성함
    이때 여러 객체들이 혼재되어있으면 헷갈리기 쉬우니 도메인과 도메인과 관련이 적은 기능들을 분리해두는데,이게 레이어드 아키텍처임
    여기서 말하는 레이어드 아키텍처는,컨트롤러-서비스-레포지토리가 아닌 컨트롤러-서비스-도메인-레포지토리임
    
    
    매우 간단한 어플리케이션도 ui와 데이터베이스등은 다 필요함
    즉 매우 일부분만 비즈니스로직과 관련되어있음
    
    이때 비즈니스로직에 ui와 외부통신들을 다 넣는방법도 있긴하지만,이경우 만들기 쉽다는 장점 말고 유지보수측면에선 매우 힘들어짐
    ui의 변경이 비즈니스로직의 변경과 이어지기 쉽기때문
    즉 좀만 복잡해져도 관심사의 분리가 필요해짐
    
    이때 사용되는 가장 기본적인 방법이 레이어드 아키텍처임
    이건 한 계층의 의존요소는 반드시 같은계층이나 아래계층이어야한다는것
    위로 올라가는 의사소통은 간접적인 메커니즘(di)을 거쳐야함
    
    이런식으로 계층화를 하면,각 계층이 프로그램의 특정 측면만을 전문적으로 다룰수있게되고,이를통해 응집력을 올릴수있음
    여기서의 핵심은 도메인계층을 분리하는것
	
	중요한건 응용계층(서비스계층)이 아닌 도메인계층에서 비즈니스로직을 책임지고있어야함
	
	계층을 분리하면 도메인계층의 설계가 향상되지만,계층은 당연히 서로 연결되어야함
	이걸위해 각 계층은 설계의존성을 오직 한 방향으로만 둬서 느슨하게 결합함
	상위계층은 하위계층의 공개 인터페이스를 호출하고,직접사용하지않음
	또한 하위에서 상위로 소통이 필요하면,콜백이나 템플릿메서드같은 형식으로 소통해야함
	
	인프라계층에선 도메인계층에서 어떤 활동이 일어나는지 알수없고 알필요도 없어야함
	이런건 서비스의 역할
	즉 이벤트가 터져서 메일을 보낸다고 했을떄,
	서비스는 언제 보낼지 알고 어떻게 보내는지 모른다면,인프라는 어떻게 보낼진 알지만 언제 보낼진 모르는식
	
	이런 인프라들의 요구사항을 통합한 프레임워크는 종종 특수한 방식으로 구현되길 요구하는데,만약 이때 프레임워크가 설계를 방해한다면,
	그냥 그부분은 순수코드로 짜는 방법도 있음
	즉 스프링쓸때 도메인은 순수자바로 짜는거처럼 그런식으로 하는거임
	또한 한 프레임워크로 해결하지 못하는건 여러 프레임워크를 써서 해결하거나
	

  2.도메인 계층은 모델이 살아가는곳
    도메인 모델은 일련의 개념을 모아둔것
	이 층은 그런 모델과 설계요소에 직접적으로 관련된 모든것을 명시한것임
	그래서 도메인계층은 업무로직에 대한 설계와 구현으로 구성됨
	모델 기반 디자인에선 도메인계층의 소프트웨어 구성물이 모델의 개념을 반영함
	
	도메인로직이 프로그램상의 다른 관심사와 섞여있다면,이걸 달성하기 어려움,그래서 도메인주도설계의 전제조건은 도메인구현을 격리하는것

  3.스마트ui 안티패턴
    이건 ui와 서비스,도메인등을 한군데 뭉쳐둔것
	이건 간단한 프로젝트를 만들때는 사용할만하고,특히 경험이 많지않은팀에서 작은규모의 프로젝트를 할때 적합함
	대신 이건 추상화도 없어서 리팩터링도 힘들고,여러 많은 문제점들이 있음
	대신 초기개발속도가 빠름
	
	이 스마트ui와 레이어드아키텍처의 중간에 있는게 트랜잭션스크립트
	
  4.다른 종류의 격리
    도메인모델은 다른 인프라나 사용자 인터페이스의 영향을 받고,모델에 완전히 통합되지않는 기타 도메인구성요소를 다뤄야함
	갖가지 이유로 모델은 불분명해지고 모델의 효용성을 잃기 쉬움
	이걸 해결하기 위해 여러 방법들이 있음
  
  
5.소프트웨어에서 표현되는 모델
  연속성과 식별성을 지니면 엔티티고,그냥 상태일뿐이면 밸류오브젝트(vo)임
  또한 객체보단 행동이나 연산으로 명확히 표현되는건 서비스로 표현하면됨(이건 클라요청에 대해 수행되는 뭔가를 의미)
  모듈(패키지)은 높은응집도와 낮은결합도를 도메인개념에서도 적용해야함
  
  1.연관관계
    모델링과 실제구현간의 상호작용은 여러 객체간 연관관계에서 특히 까다로움
	
	모델내의 모든 탐색가능한 연관관계에 대해 그것과 같은 특성을 지닌 메커니즘은 소프트웨어에도 있는데,
	구현과 설계가 달라질수있기때문
	특히 다대다 양방향 연관관계같은경우 최대한 연관관계를 걷어내야하는데,안그러면 구현과 유지보수가 매우 복잡해지기때문
	그래서 단방향으로 만들고,한정자를 추가해서 다중성을 줄이고,중요하지않은 연관관계는 제거하는식으로 해결해야함
	
	즉 가능한 관계를 제약하는게 중요함
	양방향의 경우 양쪽객체 모두 있어야하지만,단방향의 경우 탐색이 필요없으면 없어도되기때문
	그래서 상호의존성이 줄어들고 설계가 단순해짐
	추가적으로 도메인을 이해하면 도메인 본연의 방향성이 드러나기도 하고
	
	도메인을 깊이 이해하다보면 굉장히 자주 한정적인 관계에 이름
	이건 다중성을 일대일로 줄이고,중요한규칙을 명시적으로 모델에 포함시킴
	
	도메인의 특성이 반영되게끔 연관관계를 일관되게 제약하면,연관관계의 의사전달력이 풍부해지고 구현이 단순해지며,나머지 양방향 연관관계도 의미를 가지게됨
	관계의 양방향성이 도메인의 특징이 될수있기때문(즉 양방향성이라는게 특이한점이 됨)
	물론 방향성 자체가 필요없을경우 없애버리는게 젤 좋음

  2.엔티티
    엔티티란 객체의 속성이 아닌 연속성과 식별성이 이어지는(id가 있는) 객체를 말함
	즉 속성이 아닌 식별성에 의해 정의되는 객체임
	
	엔티티는 모델링과 설계상의 특수고려사항이 포함되어있고,엔티티는 항상 연속성이 유지되어야하고 식별성이 정의되어있어야함
	특정 속성보단 정체성에 초점을 맞춰서 클래스정의와 책임등이 만들어져야함
	
	한 객체가 속성보단 식별성으로 구분되면 모델내에서 이를 해당객체의 주된 정의로 삼고,클래스정의를 단순하게 하고 이 연속성과 식별성에 집중해야함
	또한 객체의 형태나 이력에 관계없이 각 객체를 구별하는 수단을 정의해야함
    
	즉 경기장의 좌석같은건 일반석일경우 vo로 충분하지만(vo도 필요없고 필드여도됨),지정석일경우 엔티티여야함
	
	엔티티를 모델링할땐 연산과 속성 모두 중요하지만,연산이 더 중요함
	엔티티의 가장 기본적인 책임은 객체의 행위가 명확하고 예측가능해질수있게 연속성을 확립해야하기때문
	그래서 엔티티를 식별하고 탐색하며 일치하는데 널리 사용되는 특징만으로 정의하고,여기에 필요한 연산과 속성만 추가하고,나머지는 밖으로 옮기는게 좋음
	이 옮긴애들은 다른 엔티티나 vo가 됨
	
	엔티티의 식별성은 모든 상태에서 유일해야함

  3.vo(value object)
    값객체는 단순한 상태를 모아둔것
	만약 식별성이 필요없는 객체가 있다면,이건 vo임
	추가적으로 얘들은 어떤 사물(엔티티)를 서술하는 객체임
	이건 vo에 해당하는 요소가 어느것인지는 관심없고 무엇인지에만 관심이 있을때 사용하게됨
	
	예를들어 색상같은게 있음
	
	vo가 엔티티를 참조하는것도 가능함(가는길같은거),또한 dto처럼 메시지의 매개변수로도 사용되고,일시적인 용도로도 사용됨
	또한 엔티티의 속성으로도 사용됨(이름같은거)
	
	vo는 불변이어야하고,vo를 구성하는 속성은 개념적 완전성을 형성해야함(vo 그 자체로 의미가 있어야함)
	
	vo는 불변적으로 강제되어야 막쓸수있어서 편함
	다른곳에서 변경이 필요할경우 새 vo를 만들어서 갈아끼는형태
	이러면 가비지컬렉션에서도 편하게 지울수있음
	
	엔티티간 양방향 연관관계가 유지하기는 어렵지만 논리적으로는 타당하다면,vo간 양방향 연관관계는 논리적으로 성립되지않음
	vo간 양방향 연관관계는 완전히 제거해야함,만약 필요해 보인다면,그건 vo가 아닌 엔티티일수있음
	
  4.서비스
    여기서 말하는 서비스는 도메인서비스임
	특정 엔티티나 vo에 속하기 애매한애들을 억지로 넣는거보단,이거 전용으로 뽑아내는게 나음
	이런애들의 특징은
	  manager같은게 이름끝에 붙음
	  상태가 없음
	  인터페이스가 도메인 외적인 측면에서 정의됨
	이런 서비스들은 순전히 클라에 무엇을 제공할수있냐에 존재이유가 있음
	그래서 엔티티나 vo가 동사나 명사로 이름을 짓는다면,서비스는 활동으로 이름을 지음
	
	서비스는 적절히 사용되어야하고,엔티티나 vo의 모든 책임을 가져와서는 안됨
	또한 상태가 없다는 특성상 싱글톤으로 운용이 가능함
	
	즉 도메인의 중대한 프로세스나 변환과정이 엔티티나 vo의 책임이 아니라면,연산을 서비스로 선언되는 독립 인터페이스로 추가하고,
	모델의 언어라는 측면에서 인터페이스를 정의하고 연산의 이름을 유비쿼터스 랭귀지의 일부가 되게 구성해야함
	또한 서비스는 상태를 가지면 안됨
	
	도메인서비스와 응용서비스,인프라서비스를 구별하는것도 중요함
	인프라 서비스는 좀 더 하위계층과(실제 db나 이메일전송객체)친하고,
	응용서비스는 도메인과 비슷하지만 좀 더 상위계층의 일을 함,즉 컨트롤러에서 내린 명령을 직접수행하는등의 일을 함
	도메인서비스는 좀 더 하나의 작은 행위에 가까운 일을 함(계좌에서 다른계좌로 이체)
	즉 도메인레벨에서의 일을 하는데,한 도메인에서 처리하기 애매한것들이 도메인서비스에 들어감
	
	도메인 서비스는 도메인지식이 도메인에서 빠져나가지 않게하는데 유용함
	또한 도메인서비스는 도메인처럼 pojo로 구성하는게 좋음

  5.모듈(패키지)
    모듈은 인지적 과부하를 줄이기위해 사용됨
	즉 전체를 보지않고 모듈안의 내용만 보거나,모듈의 세부사항을 보지않고 모듈끼리의 상관관계만 보거나 이런식
	
	모듈간에는 결합도가 낮아야하고,모듈의 내부는 응집도가 높아야함
	모듈로 쪼개지는것은 개념이고,한번에 생각하는게 합리적인애들끼리 뭉쳐야함
	
	모듈은 객체의 초기형태를 조직화할 목적으로 사용됨
	이러면 객체는 기존 모듈이 정의한 범위안에 머무를수있게 변화함
	
	모듈을 리팩터링하는건 클래스리팩터링보다 할일이 많고,파급효과도크고 그래서 자주하긴 힘듬
	그래서 계속 지나다보면 모듈이 추상적으로 변하기쉬움
	이걸 넘기지말고 도메인을 이해하는 바가 바뀔때마다 모듈에도 반영해야,모듈안의 객체도 더 자유롭게 발전할수있음
	
	우리는 분할되는 객체의 의미에 따라 모듈을 선택해야함
	한 모듈안에 들어있는 클래스들은 그 클래스들은 하나로 묶어서 생각하니,만들때도 묶어서 생각할애들만 묶어야한다는것
	
	모듈은 모델과 같이 발전해야함
	그래서 모듈에 대한리팩터링이 모델과 코드와 같이 일어아냐함
	근데 모듈은 리팩터링하는게 매우 힘듬(범위가 넓어서)
	그래도 하긴해야함
	
	또한 프레임워크에서 원하는식으로의 패키지화는,어떤건 받아들이고 어떤건 받아들이지 않을 필요가 있음
	특히 기술적인 정교함이 주도하는 패키지화계획은,개념적객체를 구성하는 요소가 떨어지기쉬움
	
	즉 단순하게 유지하는게 가장 좋고,기술환경에 필수적이거나 실질적으로 개발에 도움이 되는 최소한의 분할규칙만 선택하는게좋음
	또한 도메인은 다른코드로부터 계층을 분리하는게 좋음
  
  6.모델링패러다임
    보통은 객체지향을 모델 기반 디자인에 사용함
	이유는 일단 가장 널리쓰이고있고,객체로도 모델을 표현하기에 부족함이 없기때문
	
	그러나 반드시 도메인모델이 객체모델이어야 하는건 아님
	모델은 논리적인 규칙과 사실로(프롤로그) 구성될수도있고,여러 다른 방법으로 구성될수있음
	그리고 모델마다 객체보다 더 잘어울리는 패러다임이 있을수있는데,이럴떈 그쪽거를 조금 가져오면됨
	
	단 이때도 항상 같은 모델의 관점으로 사고를 지속해야함
	즉 두가지 패러다임 모두에서 작용할수있는 단 하나의 모델을 찾아야함
	
	모델기반디자인은 객체지향일 필요는 없지만,표현력이 풍부한 모델 구성물(객체,규칙,워크플로등)에는 분명히 의존함
	즉 이용가능한 도구가 그같은 표현력을 촉진하지못한다면,다른 도구를 찾아야함
  
  
6.도메인 객체의 생명주기  
  모든 객체에는 생명주기가 있음
  물론 대부분은 특정연산에서 사용하고 gc하지만,일부는 오래 지속되고,다른 객체와 복잡한 상호의존성을 맺음
  또한 메모리 밖으로 나가기도함(db)
  이런 객체들을 관리해야 모델기반 디자인을 할수있음
  
  도메인 객체의 관리와 관련된 문제는
    생명주기동안의 무결성 유지
	생명주기관리의 복잡성으로 모델이 난해해지는거 방지
  이 두가지 범주임
  이걸위해 
    애그리거트로 소유권과 경계를 명확히 정의하고
    팩토리로 복잡한 객체와 애그리거트를 생성하고
    리포지토리로 영속객체를 찾는식으로
  할수있음
  얘들이 도메인에서 나오는건 아니지만(팩토리와 리포지토리),도메인설계에서 중요한 역할을 담당함
  
  즉 애그리거트를 모델링하고,설계에 팩토리와 레포지토리를 추가하면 모델 객체의 생명주기동안 그것들을 체계적이고 의미있는 단위로 조작할수있음
  애그리거트는 생명주기 전단계에서 불변식이 유지되어야 할 범위를 표시해주고,팩토리와 레포지토리는 애그리거트를 대상으로 연산을 수행하고,
  특정 생명주기로 옮겨가는데 따른 복잡성을 캡슐화해줌
  
  1.애그리거트
    대부분의 업무도메인은 상호연관의 정도가 높음
	즉 사람에는 이름,생년월일,주소등이 붙어있고,사람을 삭제했을때 주소를 지우면,해당 주소를 의존하는 다른 사람에게 영향이 가고,
	아예 지우지않으면 쓰레기주소가 계속 쌓이는식임
	
	또한 동시접근시에도 문제가 될수있음
	이떄 락을 걸기위해 해당 도메인의 범위를 측정해야함(db전체를 락을거는건,즉 직렬화는 무리수니까)
	즉 모델에 경계가 정의되어야함
	
	애그리거트란 데이터변경의 단위로 다루는 연관객체의 묶음을 말함
	애그리거트엔 루트와 경계(바운더리)가 있고,경계는 애그리거트에 무엇이 포함되고 무엇이 포함되지않는지를 정의함
	루트는 단 하나만 존재하고,애그리거트에 포함된 특정 엔티티를 가리킴
	경계안의 객체끼리는 서로 참조할수있지만,경계 바깥의 객체는 루트만 참조할수있음
	즉 루트 이외의 엔티티는 지역식별성을 지님(즉 애그리거트 내부에서만 구분되면됨)
	외부에서 경계안의 루트가 아닌 다른객체를 참조하려면,루트를 거쳐서 간접적으로 접근해야함
	
	불변식은 데이터가 변경될떄마다 유지해야하는 일관성규칙을 뜻하고,여기엔 애그리거트를 구성하는 각 구성요소의 관계도 포함됨
	단 여러 애그리거트에 걸쳐 존재하는 규칙이 언제나 최신상태인건 아님
	이런 애들은 이벤트처리,배치처리등 다른 갱신 매커니즘을 토대로 특정시간내에 해결될수있음(최종적 일관성)
	단,한 애그리거트 내의 불변식은 각 트랜잭션이 완료될때 이행되어야함
	
	즉 
	  루트 엔티티는 전역식별성을 지니고,궁극적으로 불변식을 검사할 책임이 있음
	  경계안의 엔티티는 지역식별성을 지니고,이런 지역식별성은 해당 애그리거트 안에선 유일함
	  애그리거트 바깥에선 루트를 제외한 다른 엔티티를 참조할수없음
	  외부에서 루트로 참조한 내부엔티티도 일시적으로만 참조할수있고,참조를 계속 보유할순없음(즉 vo로 사용)
	  db를 통해서는 루트만 직접 획득할수있음
	  삭제를 하면 해당 애그리거트 경계 내의 모든 요소를 한번에 삭제해야함
	  애그리거트 경계안의 어떤 객체를 변경해도 전체 애그리거트 불변식을 모두 지켜져야함
	임
	이걸위해
	  엔티티와 vo를 애그리거트로 모으고,각각에 대해 경계를 정의하고
	  한 엔티티를 골라 루트로 만들고 경계 내부의 객체에 대해서는 루트를 거쳐서만 접근할수있게 하고
	  애그리거트 바깥의 객체는 루트만 참조할수있게 하자
	  내부구성요소에 대한 일시적인 참조는,단일연산에 한해서만 루트를 거쳐서 외부로 전달될수있음
	  루트를 거치지않으면 애그리거트의 내부를 변경할수없음
	를 지켜야함
	이걸 자동으로 적용되게 하기위해 프레임워크를 쓰는것도 좋음
	
	애그리거트는 생명주기의 전단계에서 불변식이 유지되어야할 범위를 표시해줌

  2.팩토리
    어떤 객체나 애그리거트를 생성하는게 매우 복잡해지거나,내부구조를 너무 많이 드러내야할땐 팩토리로 캡슐화를 할수있음
	
	객체는 그것의 존재이유와 관련이 없거나 다른 객체와 상호작용할때 필요없는것들은 전부 제거해서 정제해야함
	그런데 이런것들은 보통 전체생명주기중 중간에 해당되는게 많고,객체의 생성에 관련된 책임들은 보통 생성이 끝나면 필요없어지는경우가 많음
	이 책임을 클라로 옮기면,외부에 너무 많은 내부구현을 노출하게됨
	
	이럴때는 팩토리를 사용할수있음
	즉 어떤 객체를 생성하는게 그 자체로 주요한 연산이 될수있지만,해당 생성된 객체의 책임으로는 보통 어울리지않고,
	이걸 클라에 두면 설계가 지저분해지고 조립되는 객체나 애그리거트의 캡슐화를 위반하고 클라와 객체의 구현이 결합됨
	그래서 팩토리를 사용하는것
	
	객체의 생성과 조립은 도메인에선 아무의미없지만,구현측면에선 반드시 필요함
	그런데 이걸 해결하려면 엔티티나 vo,서비스가 아닌 구조물을 도메인설계에 추가해야함
	즉 모델 내의 어떤것에도 해당되지않는,완전히 구현만을 위한 요소를 설계에 추가해야함,이게 팩토리임
	
	팩토리는 한 객체의 인터페이스가 자신의 구현을 캡슐화해서 객체의 동작방식을 알아야할 필요 없이 클라가 해당 객체의 행위를 이용할수있게 하는거처럼,
	복잡한 객체나 애그리거트를 생성하는데 필요한 지식을 캡슐화함
	팩토리는 클라의 목적과 생성된 객체의 추상적인 관점을 반영하는 인터페이스를 제공함
	
	복잡한 객체와 애그리거트의 인스턴스를 생성하는 책임은 별도의 객체로 옮기고,
	이 객체 자체는 도메인모델에서 아무 책임도 맡지않을수있지만 도메인설계의 일부를 여전히 구성함
	모든 복잡한 객체 조립을 캡슐화하는 동시에 클라가 인스턴스화되는 객체의 구상클래스를 참조할 필요가 없는 인터페이스를 제공하고,
	전체 애그리거트를 하나의 단위로 생성해서 그것의 불변식이 이행되게 해야함
	
	팩토리설계에는 팩토리메서드,추상팩토리,빌더등 여러 방법이 있음
	팩토리를 잘 설계하기위한 두 기본요건은
	  각 생성방법은 원자적이어야하고,생성된객체나 애그리거트는 불변식을 모두 지켜야함
	  팩토리는 생성된 클래스보단 타입으로 추상화되어야함
	임
	
	팩토리의 위치는,애그리거트 루트에 위치하거나,아니면 생성전문객체에 위치할수있음(팩토리메서드)
	이건 어떤 객체의 데이터나 규칙이 해당객체를 생성할때 매우 큰 영향을 줄때 이렇게 설계할수있음
	
	팩토리는 해당 팩토리에서 만들어내는 객체와 강결합이니,자신의 생성물과 가장 밀접한 관계에 있는 객체에 있어야함
	만약 구상구현체나 생성과정의 복잡성같은걸 감춰야한다면,전용 팩토리같은걸 사용할수있음
	보통 이런경우는 전체 애그리거트를 생성해서 루트를 넘겨주는식으로 동작하고,넘겨준 애그리거트의 불변식이 지켜졌다는걸 보장해줌
	
	만약 특정 애그리거트 안의 어떤 객체가 팩토리를 필요로하는데,루트가 해당 팩토리가 있기에 적합하지않다면 독립형 팩토리를 만들수있음
	단,이때도 외부에서 애그리거트의 내부에 접근하는건 불가능해야하고,외부에서는 팩토리의 생성물을 일시적으로만 참조하게 해야함
	
	또한 생성자만으로 충분할경우엔 굳이 팩토리안써도됨
	  클래스가 계층구조의 일부가 아니거나(다형성이없을때)
	  클라가 전략패턴을 선택하는 한 방법으로 구현체에 관심이 있을때
	  클라가 객체의 속성을 모두 이용할수있을때
	  생성자가 간단할때
	  공개생성자와 팩토리가 동일한 규칙을 반드시 준수해야할때
	이럴땐 그냥 생성자써도됨
	
	생성자는 극도로 단순해야하고,생성자가 복잡해지면 팩토리써야함
	
	팩토리는 독립형이든 팩토리메서드든
	  각 연산은 원자적이어야함,즉 한번에 모든걸 받아서 만들어야하고,생성에 실패했을때도 같은 규격으로 예외가 터져야함
	  팩토리는 자신에게 전달된 인자와 결합됨,즉 의존성의 덫을 주의해야함,특히 인자에서 내용물(getXxx)을 꺼낼때 주의해야함,단순히 생성자에 박는건 ㄱㅊ
	가장 안전한 매개변수는 하위설계계층에서 나오는 매개변수고,모델내의 생성물에 밀접하게 관련된객체도 괜찮음(의존성이 추가적으로 늘어나지않으니까)
	
	또한 구상클래스가 아닌 추상타입인자를 사용하는게 좋음
	생성물의 구상클래스에도 결합되는데,굳이 구상매개변수에도 결합될필요는 없음
	
	
	팩토리의 책임은 그것이 만들어내는것의 불변식이 충족되도록 보장하는것임
	단,이때 불변식검사를 생성물에 위임할수도있음
	
	팩토리는 어짜피 자신이 만들어낼 생성물의 내부구조와 결합되어있음
	그래서 해당 생성물이 계속 불변식검사를 해야한다면 그쪽으로 넘기는거도 괜찮음
	단,해당 생성물이 생성때만 불변식 검사를 하고,이후엔 할일이 없다면 팩토리가 책임을 가져가야함(vo팩토리처럼)
	
	엔티티팩토리와 vo팩토리는
	  엔티티팩토리는 유효한 애그리거트를 만들어내는 필수속성만 받아서 만들수있음(세부사항은 나중에추가)
	  vo팩토리는 생성물에 대한 풍부한 설명을 곁들여야함(꽉채워서 내보내야함)
	라는 차이점이 있음(val과 var의 차이)
	
	팩토리와 재구성(db에 들어있던걸 객체로 살리는)팩토리는 매우 유사하고,차이점은
	  재구성에 사용된 엔티티팩토리는 새 id를 할당하지않음,즉 그래서 반드시 id가 필요함
	  객체를 재구성하는 팩토리는 불변성위반을 단순히 멈추는거로 해결할수없음(이미 db에 들어있으니까)
	가 있음
	
	팩토리는 객체의 생성과 재구성이라는 생명주기전이를 캡슐화함
	저장소에 들어갔다가 나올때 거치는 전이는 레포지토리에서 담당함

  3.레포지토리
    객체를 사용하려면 객체에 대한 참조가 있어야함
	이걸 얻는방법으로는 생성을 하거나,연관관계를 탐색해야함
	
	db는 어디서든 접근할수있고,어떤 객체에도 접근할수있게해줌
	모든객체가 상호연결될 필요는 없고,이로써 우리는 관리가능한 객체망을 유지할수있음
	탐색을 제공할지,검색에 의존할지가 설계결정이 되고,연관관계의 응집성과 검색의 분리는 상충관계에 있음
	
	기술적관점에서는 저장된 객체를 가져오는건 생성의 한부분으로 볼수있지만,개념상으로는 특정 엔티티의 생명주기의 중간에 불과함
	db에 들어갔다 나왔다고 해서 생성이 아닌,저장한걸 꺼내는거니까(id값이 바뀌지않으니까)
	
	도메인주도 설계의 목표는,기술보단 도메인모델에 집중하는것
	즉 기술적인 행위(sql을 만들어 날리고 그걸받아서 파싱해서 생성자에 넣고)를 하면 모델에 집중하기가 힘들어짐
	이러면 객체는 데이터의 컨테이너정도로만 생각되게되고,전체설계는 데이터처리방식으로 나아가게됨
	즉 클라가 모델의 개념이 아닌 기술을 다루게됨
	또한 직접 클라코드에서 db를 사용할수록,개발자는 애그리거트나 캡슐화같은걸 활용하지않고,직접 데이터를 획득해서 조작하려고 하게됨
	이러면 많은 도메인규칙들이 sql로 들어가버리거나 사라짐
	
	또한 애그리거트루트를 거치지않은,내부의 모든객체는 루트탐색을 제외한 다른방법으로 접근이 금지되어있음
	대부분의 객체는 전역검색으로 접근하면 안된다는것
	
	즉,영속객체는 해당 객체의 속성에 근거해서 검색하는식으로 전역접근하여야함
	보통 이런건 애그리거트 루트임
	이걸 제외한 나머지는 직접접근할수있으면 안됨
	
	레포지토리 패턴은 이걸(애그리거트를 어딘가에서 가져오는걸) 캡슐화해서,
	비즈니스로직에서 인프라단을 신경쓰지않고 그냥 메모리에 있는 객체를 찾는거처럼 하게 만드려는 패턴임
	이러면 클라이언트는 단순한 인터페이스로 소통할수있어짐
	
	레포지토리 패턴의 장점은
	  영속화된 객체를 획득하고 생명주기를 관리하는 단순한 모델을 클라에 제시
	  영속화기술과 db관련전략,데이터소스등을 캡슐화해 인프라단과 도메인설계를 분리
	  객체접근에 관한 설계결정을 제공해줌
	  모킹이 쉬움
	가 있음
	
	레포지토리는 보통 특정기준에 부합하는 객체를 요청하는 메서드를 제공함(find)
	이때 가장 쉬운건 구체적 매개변수를 직접 입력하는거임
	
	이렇게 영속화기술을 캡슐화하면,클라입장에서는 레포지토리구현과 완전히 분리됨
	단,클라개발자의 경우엔 레포지토리구현을 알고있어야함
	레포지토리가 아예 매우 비효율적으로 구현됐을때 그걸 가져다쓰면 안되니까..
	즉 클라입장에서는 몰라야하고,클라개발자는 알아야한다는거
	
	레포지토리는 클라에게 모든 내부구현을 감춰서,데이터가 어디 저장되든 메모리에 있든 상관없이 인터페이스에만 의지하게해야함
	이게 레포지토리의 가장 기본적인 기능임
	추가적으로
	  타입을 추상화함,즉 레포지토리의 리턴값으로 추상화된 타입을 설정해서 여러 같은계열의 클래스들을 한 레포지토리에서 반환하게 할수있음
	  클라와의 구현분리를 활용해서,캐싱,영속화전략교체등을 할수있음
	  트랜잭션제어는 클라이언트에서 처리
	등을 알아두면좋음
	또한 이런 레포지토리는,프레임워크를 적극적으로 사용하면 편함
	
	레포지토리와 팩토리는,팩토리는 객체의 초기단계를 다루고 레포지토리는 객체의 중간과 마지막(삭제)를 다루지만,
	기술적으로야 둘을 같게 볼수도 있음
	그렇지만 모델을 중심으로 사고하는게 더 유용하고,레포지토리는 클라의 입장에서는 메모리에 있는 객체를 찾아오는느낌으로 받아들일수있어지는게 좋음
	또한 이를위해 레포지토리가 팩토리로 객체생성을 위임하는 방식도 사용할수있음
	
	팩토리와 레포지토리를 결합하게 만드는 또 한가지는,find or create기능이 필요할떄임
	즉 원하는객체를 기술해서,없으면 만들고 있으면 반환하는식
	이건 사용하지않는게 좋음
	이게 필요하면 엔티티와 vo가 확연히 구분되는경우밖에 없는데,vo를 원한다면 곧장 팩토리에 vo를 생성하면됨
	새 객체와 기존객체를 구분하는건 중요하고,이걸 결합하면 상황이 엉망이 될수있음
	
  4.관계형 데이터베이스를 위한 객체 설계
    보통 객체지향시스템에서 가장 일반적인 비객체 요소는 db임
	db는 단순히 객체와 상호작용하는것만은 아니며,객체자체를 구성하는 데이터의 영속적형태를 저장함
	
	또한 데이터모델과 객체모델은 서로 갈라지면안됨,객체관계의 풍부함을 희생해서라고 관계모델에 밀접하게해야함
	객체시스템 외부프로세스는 이런 객체저장소에 접근해서는 안됨(불변식위반가능성)
	
	애그리거트에 들어있을 부가적인사항들을 비롯해,하나의 테이블행은 하나의 객체를 담고있어야함
	

7.언어의 사용(확장예제)
  프로젝트를 할땐 먼저 도메인들로 모델을 만들고,이걸 가지고 애그리거트로 묶는 형식으로 하는게 편함
  또한 도메인모델에서,이게 엔티티인지 vo인지를 구분하는게 중요함
  해당 도메인이 단일개체로 의미가 있다면 엔티티고,의미가 없다면 vo임
  
  그런데 애매한게 있을텐데(대체할수없으니 엔티티지만,자체적으론 식별성이 없는것)이런것들을 애그리거트로 묶으면됨
  
  또한 양방향 연관관계의 경우,최대한 끊어내서 단방향으로 만드는게좋음
  또한 vo는 자신의 소유자를 참조하면 안됨
  
  자체적인 식별성이 있다면 그건 애그리거트의 루트고,여기에 다른애들이 속할지 말지를 판단해야함
  보통 해당 엔티티가 없다면 존재하지않을 모든것들을 포함할수있음(보통 해당 엔티티없이 찾을이유가 없는애들)
  단,구현측면에서 이렇게하면 비효율적이 되거나 하기힘들다면 별개의 엔티티로 분리할수있음
  또한 별개의 활동으로 여겨지는 활동이 있을경우에도 분리할수있음
  
  이런식으로 애그리거트를 뽑아내면,애그리거트의 루트에만 레포지토리를 만들면됨(엔티티를 제외한 다른객체는 레포지토리를 가질수없음)
  이러면 그냥 애그리거트 내부의 값을 바꾸는 요청같은경우 루트엔티티의 vo를 갈아치우면 끝나게됨
  또한 복제같은게 필요할경우에도 애그리거트 외부에 영향을 주지않아야함
  
  이런 애그리거트를 생성할땐 팩토리를 쓰는게 편하고,여기서 필수속성이 아닐경우엔 세터를 사용하는게 좋음
  팩토리 메서드를 써도 되고
  
  그런다음 이 애그리거트단위로 패키지를 만들고 몰아넣을수있음
  
  만약 다른 시스템과의 통합이 필요하다면,부패방지계층을 사용해서 변환해가며 사용할수있음




8.도약
  리팩터링은 도메인에 대한 새 통찰력을 얻었거나,코드를 사용해서 모델이 표현하고자 하는 바를 명확하게 드러내고자 할때도 해야함
  
  리팩터링의 효과는 선형적으로 증가되지않고,중간에 점프하는곳이 있음
  특히 모델을 잘못생각하고있었거나 했을때,이걸 리팩터링했을때의 효과가 뛰어남(일단 모델부터 수정해야하지만)
  
  또한 리팩터링은 테스트코드를 기반으로 하는게 제일 효율적이고,테스트코드가 없다면 일단 테스트코드를 만들고 해야함
  그런데 테스트코드를 만들수없는상황이라면,그래도 하는게 안하는거보단 나음
  
  이런식으로 모든곳에서 동일하게 사용되는 모델을 만들어두면,확장과 유지보수가 쉬워짐

9.암시적인 개념을 명확하게
  1.개념 파헤치기
    심층모델로 향하려면 도메인의 본질적인 개념을 모델내에 표현해야함
    그리고 지식탐구와 리팩터링을 반복하면서 정제해야함
    그러나 지식탐구와 리팩터링은 중요한개념이 모델과 설계내에 명확하게 인식되고 표현되어야 본궤도에 오름
    
    즉 토의중 단서를 얻거나 설계상에 암시적으로존재하는 개념을 인지하면 도메인모델과 관련코드를 대량으로 변환하게되고,
    그후 하나이상의 객체와 객체간의 관계를 활용해 모델내에 해당개념을 명확하게 표현하게됨
    
    이렇게 암시적이었던걸 명확한개념으로 변환하는것도 심층모델로의 도약이지만,대개 도약은 여러 중요개념이 모델내에서 명확해지고나서야 나타남
    성공적인 리팩터링으로 반복적으로 개념에 할당된 책임을 조정하고,다른객체와의 관계를 변경하고,이름도 몇번씩 수정하다보면 모델이 뚜렷해짐
    그러나 이런건 일단 암시적인 개념을 임의의,정제되지않은 형태로 인식하는것부터 시작함
    
    사용자가 보고서상의 일부 항목에 대해서만 반복적으로 이야기할땐,해당 단어를 객체로 만들어야할 가능성이 있음
    그걸 깨닫고나서 그림을 그려서 도메인전문가의 반응을 보면 정확한지를 알수있음
    정확히 명사는 객체다 이런게 아니라,이런 단어가 실마리가 되어준다는것
    사용자나 도메인전문가가 설계상 어디에도 없는 단어를 사용하고있으면 경고신호임
    개발자와 도메인전문가가 설계상 어디에도 없는 단어를 사용하고있으면 더 위험한 경고임
    이런 단어들을 객체화시켜서 모델에 넣는게 좋음
    
    필요한 개념이 항상 대화나 문서로 인식할수있을만큼 드러나있진않음
    이미 존재하는 개념을 파헤치거나,새 개념을 만들어야할수있음
    이땐 설계에서 가장 어색한부분을 조사해야함(복잡한작업을 하는곳이나,새요구사항때문에 복잡성이 증가하는부분)
    
    또한 이럴땐 도메인전문가가 이런 개념을 발견할수있게 시도해볼수있음
    해당부분을 지칭하는 명사가 있는지 이런식으로 물어보면서 찾아내고,그거에대해 찾아보는것
    
    만약 도메인전문가가 없다면 책을 사용할수있음(회계면 회계입문서 이런거)
    
    이런식으로 시행착오를 거치면서 계속 모델을 발전시켜야하고,이때 적어도 한번은 기존결과를 바꾸게될거임
    그러니 설계자는 자신의 아이디어에 집착하면안됨
  2.불명확한 개념을 모델링하는방법
    또한 불명확한 개념을 모델링해야할수도 있음
    그중 하나는 명시적인 제약조건임
	
    제약조건이 복잡해지거나 복잡한 클래스에서는 별도의 메서드로 분리하는게 좋음
    이러면 제약과 모델과의 관계를 좀 더 명확하게 표현함
	
    만약 제약조건이 객체가 담당하는 기본책임을 모호하게 만들거나,제약조건이 중요한개념이라면 별도의 객체로 분리할수있음
    또한 분리하면 전략패턴같은걸 사용할수있게되기도하고
  3.specification(명세)
	모든종류의 어플리케이션에는 규칙을 검사하는 불리언 리턴 테스트메서드가 있음
	이게 간단하다면 상관없는데,복잡할때,만약 도메인계층에서 어플리케이션 계층으로 올려서 도메인과 떼어낸다면 도메인과의 연관성이 완전히 떨어지게돼버림
	즉 규칙에 대한 가독성이 낮아짐(규칙이 모델을 표현하지못함)
	이런경우엔 아예 테스트용 vo로 분해할수있어짐
	여기서 테스트용 vo가 명세에 해당함
	
	명세는 다른 객체에 대한 제약조건을 기술하고,제약조건은 존재할수도,아닐수도있음
	이거의 가장 기본적인 책임은 다른객체가 명세를 만족하는지를 검사하는것
	이러면 규칙을 도메인계층에 유지할수있고,객체를 사용해서 규칙을 표현하니,설계가 모델을 더 명확하게 반영함
	또한 팩토리같은데서 외부정보(db)를 사용해 명세를 설정할수있음(명세를 사용하는객체가 직접 다루는건 어색하니)
	
	명세는 매우 상이해보이는 앱 기능을 하나로 통합시켜준다는데서 주된 가치가 있음
	즉 검증,선택,요청구축이라는 세가지 용도가 명세의 용도인데,이것들은 개념적으로는 동일함(즉 중복제거와 캡슐화를 할수있음)
	
	검증은 가장 단순한용도로,현재 명세를 만족하는지를 알려주는것
	즉 결과를 기반으로 특정행위를 수행할때 사용됨
	
	선택은 검증과 비슷하지만,컬렉션에서 검증을 통해 필터링을 해내는것
	
	요청구축(생성)은 팩토리에서 명세를 기반으로 명세를 만족하는 객체를 생성해내는것
	이건 명세가 종류별로 여러종류일때 유용함(태그붙이는느낌),즉 존재하지않는 객체의 명세를 적어두고,이걸 맞춰서 생성하는것
	이러면 생성기의 구현을 인터페이스로부터 분리할수있음(즉 요구사항과 생성방법을 분리할수있음)
	또한 이렇게되면 테스트로 편해짐


10.유연한 설계
  너무 많은 추상계층이 존재하면 오히려 유연성에 방해가됨
  즉 명시적인 이유가 있는 추상계층이어야함
  
  1.의도를 드러내는 인터페이스
    인터페이스는 의도를 명확히 드러내야함
	즉 인터페이스 메서드만 봐도 뭘할지 직접적으로 표현되어야함(구현을 보지않아도)
	이래야 인지과부하를 줄일수있고,캡슐화를 하는 이유가 생김(즉 반대로말하면 의도를 드러내지않으면 캡슐화의 효과가 사라져버림)
	
	인터페이스는 의도만을 표현해야하고,방법에 관한건 전부 인터페이스뒤로 캡슐화되어야함
	즉 인터페이스는 관계와 규칙을 수행하는방법은 넣지말고,관계와 규칙 자체만 기술되어야함
  2.부수효과가 없는 함수
    함수를 명령과 질의로 나누고,질의를 하는데선 사이드이팩트가 없게(명령이 없게) 만들고,
	명령을 하는데선 최대한 간단하게 만들어야함
	이렇게 만들어야 예측이 쉬워짐
	
	이게 어렵다면 연산의 결과를 표현하는 vo를 생성해서 반환하는식으로 할수도있음(이 vo에서 해당 연산을 처리하고,원래꺼에선 위임하는식)

  3.단언(assertion)
    어설션을 사용하면 내부를 조사하지않고도 연산의 실행결과를 이해할수있음
	즉 무조건 이 단언은 만족한다 라고 메서드에다가 표시를 할수있는거(계약에 의한 설계의 사후조건)
	이러면 절차가 아닌 상태만 기술하니 분석이 쉬워지고,객체가 예측이 더 쉬워짐
	
	또한 언어에서 지원하지않는다면,테스트코드로 비슷한 효과를 낼수있음

  4.개념적 윤곽
    모델과 설계를 너무 크게(모놀리식처럼)잡으면 각 요소의 기능이 중복되고,인터페이스로 정보획득량이 적어짐
	그렇다고 너무 잘게 쪼개면 클라객체가 무의미하게 복잡해짐(작은부분의 협력방식을 알아야하니까)
	
	즉 도메인을 중요영역으로 나눌땐,설계요소를 응집력있는 단위로 분해하고,계속 리팩터링을 할때 계속 변경되는부분과 변경되지않는부분을 중심으로 중심축을 식별하고,
	변경을 분리하기 위해서 개념적윤곽(애그리거트의 가장자리)를 찾아서 선을 그을수있음
	
	변경이 애그리거트 내부에만 필요하고,외부에 영향을 끼치지않는다면 모델이 현재 도메인에 적합해졌다는 표시고,
	객체와 메서드를 와해시킬정도의 요구사항이 나타났다는건,도메인지식을 개선해야한다는 메시지임
  
  5.독립형 클래스
    클래스들은 최대한 꼭 필요하지않은 의존성을 제거해야함
	이래야 인지과부하를 줄일수있음
	이건 애그리거트나 모델 내부에서도 마찬가지로,의존성을 최대한 제거해야함
	
	특히 중요부분집합(비즈니스로직)에서는 의존성수를 0까지 줄이는게 좋음
	단,이때도 표준라이브러리는 써도됨

  6.연산의 닫힘
    연산이 반환타입과 인자타입이 같은경우가 제일 인터페이스를 해석하기가 쉬움
	즉 연산이 인자를 먹어서 메서드명을 해서 반환타입을 뱉을거라고 생각하게되기때문
	이렇게 최대한 통일시켜주는게좋음

  7.선언적 설계
    어설션은 우회할수있음
	예를들어 사이드이팩트를 사용하면 쉽게 우회할수있음
	
	선언적설계는 일종의 실행가능한 명세로써,프로그램 전체 혹은 일부를 작성하는걸 말함
	특성을 매우 정확하게 기술해서 프로그램을 제어하는걸 말함
	이건 리플랙션을 사용하거나,컴파일시점에 코드를 생성하는걸 이용할수있음
	이러면 개발자는 선언을 보이는 그대로 받아들일수있어짐
	
	그런데 이런 선언적접근법은 의도적이든 비의도적이든 우회하면 변질될 가능성이 있음
	
	또한 dsl도 이런형태의 방식임

  8.선언적인 형식의 설계
    일단 의도를 드러내는 인터페이스,사이드이팩트없는 함수(cqrs),어설션을 적용했으면 선언적영역으로 가고있는것
	이러면 선언적 설계의 여러 혜택을 받을수있음
	
	명세를 좀 더 선언적이고 유연해지게 만들면 여러 이점이 있음(dsl같이)
	보통 이런경우 and를 가장 많이쓰게되는데,다른걸 안쓸경우 and만 만들어도됨
	
  9.받음각
    많은 기법을 알아도 설계목표를 달성하긴 어렵고,목표를 선정하고 거기를 향해 가야함
	
	하위도메인으로 분할하라
      전체 설계영역을 동시에 다룰순없음,조금씩 뜯어내야함
	  전체영역을 조금씩 수정하기보단,특정 중요부분을 집중적으로 건드려서 거기만 매우 유연하게 바꾸는게 더 유익함
	  
	가능하다면 정립된 정형화를 사용하라
	  수학같은 이미 정립되고 다른사람들도 다 아는 정형화를 쓰는게 좋음
	  정형화를 통해 캡슐화를 할수있어지는데,이때 정형화의 방법을 기본지식으로 이미 다 알고있는걸 선택할수있다면 이걸 우선으로 선택하는게 좋음
  
11.분석패턴의 적용  
  분석패턴은 업무모델링 과정에서 사용되는 공통적인 구조를 말함
  즉 모델을 만들기전에,파악하기 힘든 도메인을 익숙한 모양으로 생각하고,거기서부터 모델을 만드는것,즉 지침서같은역할을 해줄수있음
  
  즉 비슷한 유형의 어플리케이션들의 기본틀들을 유형화한 패턴을 말함
  분석패턴은 참고할수있는 지식임,보통 현재 요구사항에 딱 들어맞는경우는 거의없지만 길잡이역할은 할수있고,어휘집역할도 할수있음
 
12.모델과 디자인패턴의 연결 
  디자인패턴의 일부는 도메인패턴으로 사용할수있음
  디자인패턴의 동기와 패턴 자체는 순수하게 기술적인 용어로 표현되지만,일부 설계요소는 많은 도메인에서 접하게되는 일반적인개념과 부합하기때문
  
  1.strategy(전략,정책)
    알고리즘군을 정의하고 각 알고리즘을 캡슐화해서 교환가능하게 만드는 전략패턴은
	도메인모델에서 기술적인 이유가 아닌,문제도메인관점에서 여러 프로세스중 하나를 선택해야할때 사용할수있음
	
	즉 프로세스의 중심부분과 변경되는부분을 분리하여 여러 프로세스의 선택이라는 문제를 해결하는것
	그러므로 프로세스에서 변화하는부분을 별도의 전략객체로 분리해서 모델에 표현하고,프로세스의 규칙과 프로세스를 제어하는행위를 서로 분리하면 도메인전략패턴임
	
	디자인패턴에서 전략패턴이 각기 다른 알고리즘간에 상호대체할수있는 능력에 중점을 뒀다면,
	도메인패턴에서 전략패턴은 프로세스 또는 정책규칙같은 하나의 개념을 표현하는능력에 중점을 둠
	
	사용법도 그냥 메서드매개변수로 인터페이스받아서 호출자가 선택하게하거나 di받아서 하면됨

  2.composite(복합체)
    부분과 전체의 계층을 표현하기위해 복합객체를 트리구조로 만드는 패턴임,이러면 클라에선 개별객체와 복합객체를 똑같이 다룰수있음
	
	이때 중첩된 복합객체간의 관련성을 모델에 반영하지않으면 계층구조상의 각 수준에 공통적인행위가 중복되고,이러면 유연성이 손상됨
	이러면 계층구조상의 각 수준에서 다루는개념에 차이가 없어도 클라는 서로 다른 수준을 처리하기위해 각기 다른 인터페이스를 사용해야함
	
	도메인모델에 디자인패턴을 적용할때 가장 우선적으로 고려해야하는건 패턴의 기본아이디어가 정말 도메인개념에 적합한지 여부임
	컴포짓패턴을 사용하면 연관객체를 재귀탐색하는게 수월해지긴하지만 
	이게 도메인개념간의 부분전체 계층구조가 존재하는지,
	하부의 모든부분이 실제로 동일한 추상화를 발견했는지 등을 만족하고 나서 적용해야함
	
	즉
	컴포짓 내부에 포함된 모든 구성요소를 포괄하는 추상타입을 정의하고,컨테이너에 포함된 항목의 집계정보를 반환할수있는 메서드를 컨테이너에 구현하고,
	단만노드의 경우 자신의값을 기반으로 정보를 제공하는 메서드를 구현하면 클라는 컨테이너와 단말노드를 구분하지않아도됨
	
13.더 심층적인 통찰력을 향한 리팩터링
  도메인 리팩터링의 핵심은
    활동의 근거지를 도메인으로 삼는다
	현상과 사물을 다른방식으로 바라보게 노력한다
	도메인 전문가와 지속적으로 대화한다
  이게 초점을 맞춰야할 사항임
  
  복잡성이나 부자연스러우면 보통 리팩터링을 하는데,이건 코드구조같은 문제가 아닌,모델에서 기인한 문제일수도 있음
  이런경우 도메인전문가가 이해하지못하는 언어로 모델이 작성되어있거나,새 요구사항을 자연스럽게 수용할수없다면 코드가 깔끔해보여도 이런느낌이 들수있음
  이때 문제가 있는 위치를 찾아내는게 가장 어려움
  
  원인이 무엇이든 모델을 더 명확하고 자연스럽게 의사소통할수있게 만드는 개선안을 찾아야함
  이건 기술적 리팩터링보다 시간도 많이들고 인력도 많이들긴함
  
  또한 서적이나 도메인자체의 지식을 정리해둔 다른 자료에서도 아이디어를 얻을수있음
  또한 비슷하게 분석패턴으로 이전 프로젝트등에서 얻은 경험을 사용할수도있음
  
  유연한 설계를 하면 리팩터링이 쉬워지기도함
  유연한설계는 설계의 의도를 전달함,이러면 코드의 동작을 예상하기도 쉬워지고 의존성과 부수효과를 감소시켜서 핵심부분만 세밀하게 표현할수있음
  
  또한 변경은 지속적으로 일어나야함
  특히
    현재팀에서 도메인을 이해하고있는바가 표현되지않은경우
	중요한개념이 설계상에 암시적으로 표현되어있고,이걸 명시적으로 바꿀방법이 보이는경우
	설계상의 중요한부분을 더욱 유연하게 만들 기회가 보이는경우
  에는 리팩터링을 해야함
  물론 출시전날같을때 할순없고,리팩터링에도 이유가 있어야하고,도메인전문가가 납득하지못하는 더 심층적인 모델을 도입하면안됨
  
  기술적 리팩터링은 안정적인 상태로 진행되지만,도메인 리팩터링은 갑자기 확하고 뜀
  이경우 보통 기회처럼 보이기보단 위기처럼 보이는데(안보이던 결점을 찾게되니),이게 정상임
  
14.모델의 무결성 유지  
  두 팀에서 서로 다른 모델을 보유한 상태로 아무생각없이 결합하면안됨
  서로 결합하지않던지,공통모델을 만들던지 일단 경계를 긋고나서 출발해야함
  
  대규모 시스템의 도메인모델을 완전히 단일화하는건 타당하지않거나 비용대비 효과적이지못함
  일단 선을 그어뒀으면,그안에서만 도메인모델이 단일화되면 됨
  
  1.bounded context
    규모가 큰 프로젝트는 다수의 모델이 공존하며,각 모델은 각각 컨텍스트를 가짐
	이때 서로간의 모델이 어디까지만 유효할것인지를 선을 그어둬야함
	개별적인 모델을 기반으로 한 코드들이 한군데에 섞이면 많은 버그가 발생하고,신뢰성이 떨어지고,이해가 힘들기때문
	
	모델은 컨텍스트에 적용되고,컨텍스트는 코드의 특정부분일수도,업무일수도 있음
	모델이 적용되는 컨텍스트를 명시적으로 정의해야함
	이때 컨텍스트의 경계는 팀조직,어플리케이션의 특정부분의 사용법,코드기반,db스키마등 물리적인 관점에서 명시적으로 설정해야함
	이 안에서는 모델을 엄격하게 일관된 상태로 유지하고,밖의 영향을 받으면 안됨
	
	모델이 컨텍스트 밖으로 나가야할땐 번역모듈을 거쳐서 나가면됨(즉 번역계층으로 캡슐화)
	
	또한 컨텍스트와 모듈은 서로 다른패턴임
	일반적으로 다른컨텍스트면 다른 모듈에 위치하지만,같은컨텍스트라고 같은모듈에 위치하진않음
	
	이렇게 제한된 컨텍스트를 정의하면,한 컨텍스트내에서의 명확함을 얻을수있고,컨텍스트밖에서의 자유로움을 얻을수있음
	
	모델을 합쳤는데 균열이 나는걸 인식하는건,코드로 작성된 인터페이스가 서로 맞지않거나,중복된개념과 허위동족언어가 나타날때 이럴수있음

  2.ci(지속적통합)
    다수의 사람이 같은 제한된컨텍스트내에서 작업하면 모델이 단편화될 가능성이 높음
	그렇다고 시스템을 더 작은 컨텍스트로 분할하면 응집성을 잃게됨
	
	그래서 지속적으로 코드베이스에 작업한걸 통합해야함(최소 하루한번)
	이러면 일관성을 유지할수있음
	
	또한 ci는 한 컨텍스트내에서만 계속 통합을 하면됨,굳이 컨텍스트를 자주 통합할필요는없음

  3.context map
    각각의 컨텍스트는 서로 독립적이지만,서로간에 영향을 주고받아야할수있음
	일단 컨텍스트끼리의 구조도를 그려서 서로 연락하는애들끼리 지도를 그려서 앞으로 어떻게 중간 번역층을 만들지 알아야하는데,이게 컨텍스트맵임
	즉 경계와 경계지점을 명확히 알수있어야함
	
	또한 맵을 그리던중 균열(서로 완전히 얽혀있지만 비일관성이 있는모델)을 발견하면 일단 모른다고적고 다른거부터 함
	다 하고나면 자잘한 균열들을 어케해야할지가 나오게됨
	
	그리고 서로 연락할땐 중간의 번역객체를 거쳐서 상대방꺼로 변환을 해서 넘겨줘야하는데,이 번역객체는 양쪽의 팀이 합심해서 유지해야하는 유일할 객체임
	이외의것들은 알아서하면됨

  4.공유커널
    기능통합의 한계가 있을때,ci의 비용이 매우높아진다면 땜빵으로 사용할수있는게 공유커널임
	양쪽의 컨텍스트의 합집합을 설정하고,그부분은 서로간의 협의없인 변경할수있게 하는방식임
	또한 이부분은 자주 통합하되,개별팀의 ci빈도보단 더 적은 빈도로 통합하고,이땐 양팀에서 작성한 테스트를 모두 실행해야함
	
	이거의 목표는 중복을 줄이고 두 하위시스템의 통합을 비교적 용이하게 하는것

  5.고객/공급자 개발 팀
    한 하위시스템이 다른시스템에 본질적으로 데이터를 공급할때,즉 의존성이 단방향으로 흐를때,양쪽은 자연스럽게 두개의 컨텍스트로 나눠짐
	이땐 번역을 단방향으로만 할수있게 해도됨
	
	그런데 이때 변경에 대한 거부권이 하위측에 있거나,변경요청절차가 복잡하면,상위가 개발을 진행하는걸 하위쪽에 속박당함
	또한 하위의 영향을 걱정해서 상위가 개발을 못하게될수있음
	
	그래서 하위쪽과 상위간의 중간에 계약을 해서 이건 지켜주겠다 이걸 정해두고 가는게 좋음(양쪽의 고객/공급자 관계를 확립)
	하위는 상위쪽에 일반고객처럼 질문하고 문제해결을 지원받을수있어야함
	이떈 유닛테스트자동화는 반드시 들어가야함
	
	또한 고객이 여러팀일경우엔,모든 팀들의 요구사항간에 균형을 맞춰야함

  6.conformist(준수자)
    상위 하위팀이 같은조직이 아니라면,고객/공급자같은걸 쓰기힘듬
	이러면 아예 상위팀의 기능사용을 포기하거나,부패방지계층을 만들거나 할수있고,그냥 현재 상위팀꺼를 그대로 사용할수도있음(기성제품을 그대로 사용)
	
	즉 상위팀의 시스템에 완전히 속박되게 개발하는것
	이건 나빠보이고 좋진않긴한데,양쪽같의 번역에 따른 복잡도를 제거할수있음
	설계방식은 완전히 속박되지만 통합자체는 쉬워지게됨
	
	이건 공유커널과 비슷하지만,공유커널이 양쪽간에 관심이 있을때 쓴다면,이건 상위쪽에서 관심이 없을때도 사용할수있음
	사실상 최후의 수단 바로앞정도느낌

  7.부패방지계층
    다른 시스템과 상호작용하기위한 거대한 인터페이스를 보유한 새 시스템을 구축할땐,
	두 모델을 연계할때의 어려움때문에 새모델을 기존 다른시스템의 모델과 유사하게 수정하려는 압력을 받아 모델의 의도가 매몰될수있음
	보통 레거시모델은 취약하고,그렇지않아도 현재프로젝트와 어울리지않는경우가 대부분임
	그러나 통합을 꼭 해야할땐 부패방지계층을 사용할수있음
	
	부패방지계층은 다른 시스템과 우리 시스템과의 번역계층을 만들고,그걸 기반으로 외부시스템을 추상화해서 사용하는 계층임
	부패방지계층은 대부분 서비스의 집합으로 표현됨(외부서비스가 단일컴포넌트인것도 이상하긴하니까)
	
	부패방지계층의 구현은 여러 통신메커니즘과 어댑터와 파사드를 조합하는것
	즉 우리쪽 시스템에선 파사드를 의존하고,파사드는 어댑터를 의존하고,어댑터는 통신메커니즘을 의존해서 받은 값을 번역하는식임
	또한 양방향통신이 필요할때는 역순으로 나가면됨

  8.separate ways(각자의 길)
    통합의 비용이 통합했을때의 이익보다 클거같다면,아예 서로 다른프로젝트로 취급하고 각각 따로가는게 나을수도있음

  9.공개 호스트 서비스
    하위시스템접근과 관련된 프로토콜을 서비스로 정의하고,이 프로토콜을 공개해서 이걸 의존하고싶은 모든 사람이 이걸 호출해서 가져다쓸수있게(rest처럼)할수있음
	이때 이 공개호스트서비스를 수정할땐,공통요구사항은 처리해야하지만,한팀에서만 요구하는 독특한 요구사항은 제외해야함

  10.퍼블리시드 랭귀지(공표된 언어)
    두 도메인모델이 반드시 공존해야하고,정보가 둘 사이에서 오갈땐 번역과정자체가 복잡해지기 쉬움
	이럴땐 둘 사이에서의 공통모델을 만들고,이것만 사용해서 서로 소통하면됨(json)
	
  11.모델의 컨텍스트 전략 선택
    팀에서는 컨텍스트를 어디에 정의하고 각 컨텍스트간의 관계는 어떨지를 먼저 결정해야함
	전체팀은 모두 같이 이 의사결정을 하거나,최소한 의사결정의 결과는 알고있어야함
	
	일반적으로 설계중인시스템은 한두개의 컨텍스트일거고,또 다른 컨텍스트나 두어개의 컨텍스트는 이걸 보조할거임
	
	컨텍스트의 경계를 세울떈 많은 상황과 선택사항이 있음
	이때 대개의 문제는
	  규모가 큰 컨텍스트 선호
	    사용자의 작업흐름이 단일모델을 토대로 처리될때 더 매끄러움
		두 모델의 매핑을 더하는거보다 일관성있는 하나의 모델을 이해하기 더 쉬움
		두모델간 번역이 어려울수있음
		공유언어를 토대로 팀 의사소통이 명확해짐
	  규모가 작은 컨텍스트 선호
	    개발자간 의사소통 과부하가 줄어듬
		소규모팀과 코드를 토대로 ci가 쉬워짐
		대형컨텍스트에서는 용도가 다양한 추상화모델을 요구할수있는데,이때 제공하기힘든 기술이 필요할떄가있음
		각기 다른모델이면 특수한 요구사항을 해결하기 쉬움
	이 안에서 장점따라 선택됨
	
	다양한 컨텍스트간 심층적인 기능통합은 현실적이지못하지만,두 시스템 사이에 규모가 작은 인터페이스가 있다면 가능할수도있음
	
	일단 가장 쉬운 의사결정부터 시작하는게 좋음
	어떤 하위시스템은 개발중인 시스템의 컨텍스트에 명확히 포함되지않을거임(외부시스템등)
	이런것들은 최우선적으로 설계에서 분리해야함
	이떄 할수있는 패턴은
	  separate ways:통합이 필요하지않다면 선택
	  부패방지계층:통합이 반드시 필요하고,기존시스템보다 설계중인 시스템이 복잡해질거같을떄 선택
	  준수자:통합이 반드시 필요하고,기존 시스템에 보조적인 시스템이 될거같으면 선택(또한 번역이 너무 어려울거같아도 선택)
	이렇게 3개가 있음
	만약 준수자를 선택했다면 확장에만 주력하고 기존모델을 수정하면 안됨
	
	팀이 커져서 ci가 어렵다면,공유커널을 찾아서 비교적 독립적인 기능집합으로 컨텍스트를 나누거나,
	중간에 번역계층을 둘수도있음
	
	프로젝트가 이미 진행중일때,개선하려고 한다면
	일단 현재상태에 따라 컨텍스트를 정의하고,현재조직을 중심으로 팀의 업무관행을 정비해야함(ci,빗나간 번역코드 부패방지계층으로 리팩터링등)

  12.변형
    컨텍스트에 관한 결정도 되돌릴수있음
	보통 초기에 컨텍스트에 내린 결정은 불가피하게 바꿔야할때가 많음
	그런데 나누기는 쉽지만 통합하고 컨텍스트간 관계를 바꾸는건 어려움
	그래서 여러 반복주기가 필요할수있음
	
	separate ways를 합칠땐 번역과부하가 매우 크고,중복이 너무 명확하게 드러남
	이건 합치기가 쉽지않긴함
	궁극적인목표는 ci를 토대로 단 하나의 컨텍스트로 가는거라고 하더라도,중간목표로 공유커널을 거쳐서 가는게 좋음
	
	공유커널까지 왔으면 이제 ci를 통합하는게 좋음
	그리고 레거시시스템은 단계적으로 폐기해야함
	이때 젤 먼저 테스트전략을 결정해야함
	

15.디스틸레이션
  디스틸레이션은 혼합된 요소를 분리해서 본질을 좀 더 값지고 유용한 형태로 뽑아내는과정임
  모델은 지식의 정수를 추출한것이고,심층적인 통찰력으로 향하는 리팩터링을 거쳐 우리는 도메인지식과 우선순위의 일부 중요한측면을 추상화함
  
  1.코어 도메인
    코어도메인은 해당 시스템의 핵심이 되는 부분임
	설계의 모든부분을 동일하게 정제할순없고,각 설계측면에서 우선순위를 매겨야하는데,거기서 1등을 차지하는 비즈니스로직 도메인을 말함
	
	이 코어도메인은 가장 고급기술을 갖춘 개발자가 맡는게 좋음
	이래야 핵심개발자가 도메인지식을 쌓게되고,아무리 잘못되더라도 코어는 제대로 살아남을수있음
	
	코어는 작아야하고,해당부분이 누가봐도 핵심이어야함
	코어를 구별되게 만드는데 노력을 쏟으면서,설계의 나머지부분은 실용적으로 일반화해서 유지하면됨
	리팩터링의 우선순위도 코어가 1순위임
	
	코어도메인을 만들려고 외부설계 전문가를 고용하거나,구입하는건 있을만한일이 아님
	우리가 프로그램을 만드는이유는 코어도메인을 완전하게 제어할수있기때문이라서..

  2.일반 하위 도메인
    모델의 일부는 전문지식을 포착하거나 전달하지않고,복잡성만 더하게함
	이런애들은 코어도메인을 식별하고 이해하는걸 더욱 어렵게 만듬
	
	즉 모델의 세부사항임
	모델은 코어와 세부사항으로 나눠지고,세부사항은 크게 중요하지않기때문에(있긴해야하지만 크게 중요하진않음),여기에 과투자를 하면 안됨
	이런 하위모듈은 추출해서 별도 모듈에 배치하는게 좋음
	또한 이런 하위모듈엔 핵심개발자를 배치하지않는게 좋음,그래야 핵심개발자가 도메인지식을 얻을수있음
	이런 하위모듈의 경우엔 오픈소스나 하청같은걸 고려해봐도됨
	
	이 기능이 빠지면 대체가 불가능하고 모델이 치명적으로 문제가 생긴다 이러면 코어고,아니고 대체가 가능하다면(레포지토리처럼) 하위도메인임
	즉 이 기능만 가지고 프로토타입 프로젝트를 굴릴수 있다 이러면 코어임

  3.도메인 비전 선언문
    이건 이 프로젝트에 있어서 코어기능을 구별할때 사용되는 방법임
	이 도메인모델과 다른것을 구별하는데 도움이 되지않는건 무시하고,도메인모델이 어떻게 다양한 관심사를 충족하고 균형을 이루는지를 보여야함
	
	즉 모델은 효과적인 항로 및 좌석 탐색과 이미 구축된 다른 비행예약 시스템과의 통합을 지원해야한다 이런걸 추가하고,
	고객이 예약내용을 전송할경우 5초안에 시각적으로 예약결과를 보여준다 이런걸 추가하지않는거임(세부사항)

  4.강조된 핵심   
    
  
  
  
  
  
  
  
  
  
  





  
  
  
  
  
  