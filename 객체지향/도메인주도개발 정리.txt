1.도메인모델 시작하기
*1.도메인이란?
  소프트웨어의 대상은 필요로하는 기능을 제공해야함
  이때 해결하고자 하는 문제영역이 도메인에 해당하게됨
  
  한 도메인은 여러 하위도메인으로 나뉠수있음
  
*2.도메인전문가와 개발자간 지식공유
  개발자는 요구사항을 분석하고 설계해서 코드를 만듬
  이떄 요구사항은 첫단추라서,요구사항을 잘못 분석하면 엉뚱한 기능을 만들게됨
  
  즉 코딩에 앞서 요구사항을 올바르게 이해하는게 제일 중요함
  이때 가장 간단한 방법은 개발자와 전문가가 직접 대화하는것
  
  개발자와 이해관계자,도메인전문가가 같은 지식을 공유하고 직접 소통할수록 도메인전문가가 원하는 제품을 만들 가능성이 높아짐
  단,도메인전문가라고해서 항상 올바른 요구사항을 주는게 아님
  도메인전문가가 말하는 기능을 듣고,왜 필요한지까지 듣고나서 더 합리적인 방향이 있다면 제안하는것도 좋음
  
*3.도메인모델
  도메인모델은 특정 도메인을 개념적으로 표현한것
  도메인모델을 사용하면 여러 관계자들이 동일한모습으로 도메인을 이해하고 지식을 공유할수있음
  
  도메인모델은 객체로만 만들어야하는건 아님,그냥 상태전이로 모델링할수도있음
  근데 객체가 제일 쓰기 편하긴함
  
  도메인모델은 도메인 자체를 이해하기위한개념모델이라,구현할땐 구현기술에 맞는 구현모델이 따로 필요함
  이때 구현모델이 개념모델을 최대한 따르게 하는게 좋은데,그래서 객체모델로 개념모델을 잡으면 편하긴함(물론 개념모델은 트랜잭션등의 고려가 없어서 직접꽂을순없음)
  
*4.도메인모델 패턴
  도메인계층은 도메인의 핵심규칙을 구현함(서비스레이어 밑의 도메인층)
  도메인규칙을 객체지향기법으로 구현하는게 도메인모델패턴임
  
  이때 도메인로직을 위치시킬때,해당 객체가 그일을 가장 잘 처리할수있는 지식이 있는곳에 두는게 좋음
  다떠나서 도메인모델에만 핵심로직이 있다는게 변경시 영향을 덜줄수있어서 좋음
    
*5.도메인모델 도출
  도메인을 모델링할때 기본이 되는 작업은,핵심구성요소,규칙,기능을 찾는것
  이건 요구사항에서 출발함
  
  요구사항을 가지고 상세구현을 할순없지만,관련기능을 해당객체에 메서드로 추가할순있음
  또한 해당 요구사항에서 필요한 정보들을 필드로 추가할수있음
  또한 제약조건을 가지고 메서드에 예외처리를 하는식으로 도메인규칙을 구현할수있음
  
  이런식으로 일부는 구현수준까지,일부는 이름정도만 결정한후 이걸 공유해서 논의하면됨
  
*6.엔티티와 밸류
  모델은 크게 엔티티와 밸류로 구분할수있음
  1.엔티티
    엔티티의 가장 큰 특징은 식별자를 가진다는것
	식별자는 엔티티객체를 통틀어 고유해서,각 엔티티는 서로 다른 식별자를 가짐
	이 식별자는 절대 변하지않음(엔티티를 삭제하기전까지)
	
	그래서 엔티티의 식별자가 같다면 같은 엔티티라고 볼수있음(equal,hashcode 오버라이드로 바꿀수있음)

  2.엔티티 식별자 생성
    식별자생성시점은 도메인특징과 사용기술에 따라 달라짐
	보통
	  특정규칙에 따라 생성(주문번호등)
	  uuid사용
	  값을 직접 입력
	  오토인크리즈 사용
	인데,자연키보단 인조키를 보통 선호해서 uuid나 오토인크리즈를 사용하는편임
	
	오토인크리즈를 제외한 나머지방식은 식별자를 먼저 만들고 엔티티객체를 생성하고,오토인크리즈는 db에 넣기전까진 -1이나 0같은 대체를 사용함

  3.밸류타입
    밸류타입은 그 자체로 식별할수없는,개념적으로 완전한 하나를 나타내는 필드들의 집합을 만들때 사용됨
	그냥 이름을 붙이기위해 밸류타입을 사용해서 필드하나를 감싸는경우도 있음
	또한 밸류타입을 사용하면,해당 타입만을 위한 기능을 최소범위로 노출하며 추가할수있음
	
	또한 밸류타입의 데이터를 변경할땐,기존데이터 변경보단 불변으로 취급하고 새 데이터를 만드는게 선호됨(참조투명성)

  4.엔티티식별자와 밸류타입
    엔티티식별자가 자연키인경우,그대로 사용하기보단 밸류타입을 만들어두는게 좋음

  5.도메인모델에 set넣지않기
    set은 반드시 필요한 필드에만 노출하고,그것도 한번 추상화를 거쳐서 추가하는게 좋음
	받을값은 생성자로 다 받아서 처리하는게 좋음
	
	또한 객체내부에서만 사용할목적의 set이라면 private로 설정
  
  
*7.도메인용어와 유비쿼터스 언어
  코드를 사용할때 도메인에서 사용하는용어는 매우 중요함
  이걸 반영하지않으면 코드의 의미를 해석해야하는 부담을 개발자에게 주게됨
  step1,step2를 결제대기중,상품준비중으로 바꾸면 해석하지않고 그대로 보면되니까(보통 이럴떄 enum을 사용함)
  
  또한 시간이 지날수록 도메인에 대한 이해가 높아지는데,이때 새롭게 이해한 내용을 잘 표현할수있는 용어를 찾아내고,이를 다시 공통의 언어로 만들어 다같이 사용하면됨
  이런 언어들은 기존 코드나 문서에도 반영해야함
  
2.아키텍처 개요 
*1.네개의 영역
  표현영역은 컨트롤러,즉 요청을 받아서 밑에 내리고,응답을 받아 다시 전달하는 역할을 함
  
  응용영역은 표현영역으로 부터 받은 요청에 대한 기능을 큰단위로 가지고있음
  응용영역은 기능을 구현하기위해 도메인영역의 도메인모델을 사용함,즉 직접 로직을 수행하기보단,도메인모델에 로직수행을 위임함
  
  도메인영역은 도메인모델을 구현함
  도메인모델은 도메인의 핵심로직을 구현함
  
  인프라영역은 구현기술에 대한 모든것(db,메일,restapi호출등)을 다룸
  인프라영역을 제외한 다른 영역들은 구현기술을 사용한 코드를 직접 만들지않고,인프라가 제공하는 기능을 사용해서 필요한기능을 개발함
  
*2.계층구조 아키텍처  
  보통은 4영역으로 나누고,도메인과 응용을 간단한경우 합치기도 하지만 보통 이구조를 따름
  핵심은 상위에서 하위로만 의존하고,하위는 상위를 의존하지않는것
  
  또한 엄격하게하면 바로 직전의 계층만 의존해야하지만,구현의 편리함을 위해 유연하게 적용하기도함
  
  문제는 표현,응용,도메인계층이 상세한 구현기술을 다루는 인프라계층에 종속된다는것
  이러면 상위계층의 테스트가 어려워지고,구현방식을 변경하기 어려워짐
  그래서 사용되는게 dip

*3.dip
  고수준모듈이 저수준에 직접적으로 의존하게된다면 구현변경과 테스트가 어려워짐
  그래서 저수준이 고수준에 의존하게하는게 dip임
  
  이건 추상화된 인터페이스를 사이에 두고,고수준 모듈이 이걸 소유하게해서 인터페이스의 변경을 통제하는거임
  이러면 인터페이스만 만족한다면 저수준도 알아서 구현하면되고,고수준도 딱 그정도만 기대하고 약의존하면됨
  
  그리고 테스트할땐 모킹객체를 사용해서 저수준을 대체해버리면됨
  
  주의점은,단순한 인터페이스와 구현클래스를 분리하는게 아니라,상위층으로 소유권을 넘기는게 핵심이라 인터페이스는 고수준모듈이 가지고있어야함
  즉 논리적으로 보면,도메인계층이 필요로해서 인터페이스를 만들고,이걸 하위계층에서 구현하는식으로 가는게 맞는거임
  
  또한 dip를 항상 적용할필요는 없고,구현기술에 의존적인 코드를 도메인에 포함하는게 효과적인경우도 있고,추상화대상이 잘 떠오르지않는경우도 있음
  이럴땐 dip의 이점을 얻는수준에서 적용범위를 검토해보면됨
  
*4.도메인영역의 구성요소 
  도메인영역을 구성하는 요소는
    엔티티:고유식별자를 갖는 객체,도메인의 고유한개념을 표현하고 데이터와 기능을 함께 제공함
	밸류:식별자가 없는 객체,개념적으로 하나인값을 표현할때 사용,엔티티의 속성(필드)로써 보통 사용되고,다른 밸류타입의 속성으로써도 사용됨
	애그리거트:연관된 엔티티와 밸류들을 개념적으로 하나로 묶은것
	리포지터리:도메인모델의 영속성을 처리
	도메인서비스:특정 엔티티에 속하지않는 도메인로직을 제공(도메인에 속하기 애매한로직들)
  이 있음
  
  1.엔티티와 밸류
    db테이블의 엔티티와 도메인모델의 엔티티는 같은게 아님
	이 둘의 가장 큰 차이점은,도메인의 엔티티는 데이터와 도메인기능을 함께 제공한다는것
	즉 데이터를 담고있는 데이터구조라기보단,데이터와 함께 기능을 제공하는 객체임(캡슐화)
	
	또한,두개이상의 데이터가 개념적으로 하나인경우엔 밸류타입으로 묶을수있다는게 차이점임
	db에선 이렇게 하기가 힘듬
	
	밸류는 불변으로 구현하는게 좋고,그래서 밸류를 교체할땐 객체자체를 완전히 교체한다는걸 의미함

  2.애그리거트
    도메인이 커지면 많은 엔티티와 밸류가 출현함
	이경우엔 개발자가 전체구조가 아닌 한 엔티티와 밸류에 집중하게되는데,이러면 상위수준이 아닌 개별요소에만 초점을 맞추게돼서 큰수준에서 모델을 이해하기힘들어짐
	이때 도움이되는게 애그리거트임
	
	애그리거트는 관련객체들을 하나로 묶은 군집이고,이걸 사용하면 개별객체가 아닌 관련객체를 묶어서 객체군집단위로 모델을 바라볼수있어짐
	또한 개별객체간의 관계가 아닌 애그리거트간의 관계로 도메인모델을 이해하고 구현하게되고,이를통해 도메인모델을 관리할수있음

	애그리거트는 군집에 속한 객체들을 관리하는 루트엔티티를 갖고,얘를통해서 애그리거트가 구현해야할 기능을 제공함(퍼사드같은느낌)
	루트엔티티는 애그리거트에 속해있는 엔티티와 밸류로 구현할 기능들을 구현함
	즉 루트엔티티를 통해 간접적으로 다른 엔티티에 접근하는식임(캡슐화)
	루트엔티티를 거치지않고 다른 엔티티를 접근할수없게 만드는게 핵심임
	
	애그리거트를 구현할땐 고려해야할게 많은데,이거때문에 구현이 복잡해지기도,트랜잭션범위가 달라지기도 하고,
	선택구현기술에 따라 애그리거트 구현에 제약이 생기기도함

  3.리포지터리
    도메인객체를 지속적으로 사용하려면 어딘가에 저장해야하는데,이때 필요한 도메인모델이 리포지터리임
	리포지터리는 애그리거트 단위로 도메인객체를 저장하고 조회함
	
	이떄 핵심은 루트단위로 저장한다는것(루트는 모든객체를 포함하고있으니까)
	
	응용서비스는 의존성주입등으로 실제 리포지터리 구현객체를 가져오는데,
	응용서비스와 리포지터리는 밀접한 연관이 있음
	  응용서비스가 필요한 도메인객체를 구하거나 저장할떄 리포지터리를 사용
	  응용서비스가 트랜잭션을 관리할때 트랜잭션처리는 리포지터리구현기술의 영향을 받음
	리포지터리를 사용하는 주체가 응용서비스라서,리포지터리는 얘들이 필요로하는 메서드를 제공함
	이때 애그리거트를 저장하는 메서드와 애그리거트 루트로 애그리거트를 조회하는 메서드가 기본이 됨(save,findById)
  
*5.요청 처리 흐름
  표현영역은 요청의 데이터형식이 올바른지 검사하고 응용층에 실행을 위임
  이때 데이터를 응용서비스가 필요로하는 형식으로 변환해서 전달해야함(dto)
  
  응용서비스는 도메인모델을 이용해서 기능을 구현
  기능구현에 필요한 도메인객체를 리포지터리에서 가져와 실행하거나,신규 도메인객체를 생성해서 리포지터리에 저장함
  
  또한 예매등 변경이 필요한경우 트랜잭션을 관리해야함(@Transactional)
  
*6.인프라스트럭처 개요
  인프라층은 표현,응용,도메인영역을 지원함
  얘는 영속성처리,rest클라이언트호출등 다른영역에서 필요로하는 구현기술등을 지원함
  
  도메인영역와 응용영역에서는 인프라층을 직접 사용하는것보다 인터페이스를 통해(dip)사용하는게 테스트가 편하고 유연해짐
  
  그렇지만 무조건 인프라층에 대한 의존을 없앨필요는 없음
  응용층의 @Transactional은 쓰는게 더 편하고,JPA를 쓸땐 @Entity등을 도메인모델에 붙이는게 훨 편함
  
  구현의 편리함은 dip가 주는 강점만큼이나 중요하고,dip의 강점을 해치지않는범위에선 구현기술에 대한 의존을 해도됨
  
  
*7.모듈 구성
  아키텍처의 각 영역은 별도 패키지에 위치함
  패키지 구성에 정답이 존재하는건 아니지만,ui,application,domain,infra로 폴더를 나눠서 쓰면됨
  좀 커진다 싶으면,도메인별로 각각 ui,application,domain,infra로 폴더를 나눠서 쓰면됨
  
  또한 도메인은 도메인에 속한 애그리거트를 기준으로 다시 패키지를 구성함(도메인폴더내에 각 폴더가 애그리거트임)
  애그리거트와 도메인모델,리포지터리는 같은패키지에 위치해야함
  
  도메인이 복잡하면 도메인모델과 도메인서비스를 별도패키지에 위치시킬수도있음
  응용서비스도 도메인별로 패키지를 구분할수있음
  
  대충 한 패키지에 가능하면 타입이 10~15개정도로 유지하는게 좋고,이걸 넘어가면 패키지를 분리하는 시도를 해보는게좋음
  
  
3.애그리거트  
*1.애그리거트
  애그리거트는 도메인객체들을 상위수준에서 묶어둔거임
  이러면 주요도메인간의 관계를 파악하기 쉬워지고,코드를 변경하고 확장하는게 좀 더 쉬워짐
  상위수준에서 모델이 어떻게 엮여있는지를 알아야 전체모델을 망가뜨리지않으면서 추가요구사항을 모델에 반영할수있기때문
  세부적인모델만 이해하면 코드를 수정하는게 꺼려지고,코드변경을 최대한 피하고싶어짐
  
  이럴때 사용하는 방법이 애그리거트임
  애그리거트는 객체들을 하나의 군으로 묶어서,상위수준에서 도메인모델간의 관계를 파악할수있게해줌
  애그리거트는 모델을 이해하는데도 도움을 주지만,일관성을 관리하는 기준도 됨
  그래서 복잡한 도메인을 단순한구조로 만들어줌,그래서 확장과 변경에 필요한 노력도 줄여줌
  
  애그리거트는 관련된 모델을 하나로 모았기때문에,한 애그리거트에 속한 객체는 유사하거나 동일한 라이프사이클을 가짐
  대부분 한 애그리거트에 속하는 애들은 함께 생성되고,함께 소멸함
  
  한 애그리거트에 속하는 객체는 다른애그리거트에 속하지않고,각 애그리거트는 자신을 관리할뿐 다른애그리거트를 관리하지않음
  즉 주문애그리거트는 배송지를 변경하거나 주문상품갯수는 변경할수있지만,회원비밀번호나 상품가격은 변경하지못함
  
  경계의 기본은 도메인규칙과 요구사항임
  도메인규칙에 따라 함께 생성되는 구성요소는 한 애그리거트에 속할 가능성이 높음
  단,a는 b를 갖는다 이런건 반드시 한 애그리거트에 속한다고 보장할순없음(상품과 리뷰처럼)
  보통 생성시기가 같고,생성주체가 같을때 속할지말지를 보면될거임
  
  보통 대부분의 애그리거트는 엔티티객체 하나만을 가지고,두개이상의 엔티티로 구성되는 애그리거트는 드뭄
  
*2.애그리거트 루트
  애그리거트 루트는 애그리거트 전체를 관리하는 주체고,이걸 루트엔티티라고도 부름
  애그리거트에 속하는 모든 객체는 애그리거트 루트엔티티에 직접,또는 간접적으로 속하게됨
  
  1.도메인규칙과 일관성
    애그리거트 루트가 단순히 애그리거트에 속한 객체를 포함하는걸로 끝나는게 아님
	얘의 핵심은 애그리거트의 일관성이 깨지지않도록 하는것
	
	모든 애그리거트를 조작,조회하는 모든 행위는 루트애그리거트를 통해서 일어나야함,절대 세부애그리거트로 직접접근할수없음
	이러면 상태확인로직들의 응집도도 올라가고,중복구현도 막을수있음
	이때 가장 필수로 들여야하는 습관은
	  단순히 필드를 변경하는 set은 퍼블릭으로 만들지않는다
	  밸류타입은 불변으로 구현한다
	임
	
	추상화,캡슐화되지않은 set은 단순 필드변경일텐데 이러면 도메인의미나 의도를 표현하지못하고,도메인로직이 서비스쪽으로 분산되게됨
	이러면 응집도가 떨어지고,유지보수나 분석에 많은시간이 필요함
	
	이거의 연장으로 밸류타입은 불변으로 만들어야함
	밸류타입을 변경할수없으면,루트에서 밸류타입을 가져가도 변경할수없으니 일관성이 꺠질가능성이 줄어듬
	이러면 밸류타입을 변경하는방법은 통째로 바꾸는방법밖에 없어지니까(또한 변경자체로 루트를 통해서만 가능해짐)

  2.애그리거트 루트의 기능구현
    루트는 애그리거트 내부의 다른객체들을 조합해서 기능을 완성함
	총주문금액을 구하기위해 모든 주문이 담긴 OrderLine리스트를 사용하는식
	
	모든 루트가 구성요소의 상태만 참조하는건 아니고,구성요소에게 기능실행을 위임하기도함(가장 전문가에게 일을 시켜라)
	단,변경기능이 구성요소에 있을경우,외부로 나간 객체가 변경될수가 있음
	이러니 애초에 불변으로 만들어버리는게 좋음
	안된다면 변경기능을 패키지나 protected로 한정해서 외부에서 실행할수없게 제한하는 방법도 있음

  3.트랜잭션 범위
    트랜잭션범위는 작을수록 좋음
	한 테이블을 수정하면 충돌을 막기위해 한 테이블의 한행으로 잠그는 대상이 한정되지만,세개의 테이블을 수정하면 잠금대상이 더 많아짐
	이러면 동시에 처리할수있는 트랜잭션갯수가 줄어든다는걸 의미하고 처리량을 떨어트림
	
	동일하게 한 트랜잭션에서는 한 애그리거트만 수정해야함
	한 트랜잭션에서 두개이상의 애그리거트를 수정하면 트랜잭션충돌확률이 더 높아져서,처리량이 떨어짐
	
	한트랜잭션에서 한 애그리거트만 수정한다는건,애그리거트에서 다른애그리거트를 변경하지않는다는것
	즉 애그리거트내부에서 다른애그리거트의 상태를 변경하는 기능을 실행하지않는다는것
	즉 주문의 배송지정보를 변경하면서 동시에 배송지정보를 회원의 주소로 설정할땐,주문애그리거트는 회원애그리거트의 정보를 변경하면안됨
	안그러면 애그리거트가 자신의 책임범위를 넘어 다른애그리거트의 상태까지 관리하는게 되어버리기때문
	이러면 결합도가 높아짐
	
	부득이하게 한트랜잭션으로 두개이상의 애그리거트를 수정해야한다면,애그리거트에서 직접 수정하는게 아닌,서비스단에서 수정해야함
	
	즉 가급적이면 한트랜잭션에서 한 애그리거트를 변경하는걸 추천하지만,두개이상의 변경을 트랜잭션으로 묶어야할땐 서비스단에서 처리해야함
	
  
*3.리포지터리와 애그리거트
  애그리거트는 개념상 완전한 한개의 도메인모델을 표현하므로,객체의 영속성을 처리하는 리포지터리는 애그리거트 단위로 존재함
  즉 루트애그리거트만 리포지터리를 만들수있고,나머지들은 루트 리포지터리를 통해서 변경이 일어나야함
  
  리포지터리는 save와 findById가 기본적으로 있어야하고,필요에따라 다양한 검색,삭제,추가 메서드가 생길수있음
  
  또한 구현기술에 따라 애그리거트의 구현도 영향을 받음
  jpa를 사용하면 db관계형모델에 객체도메인모델을 맞춰야할수있고,
  어떤경우(레거시db등)는 밸류타입인 도메인모델을 @Component가 아닌 @Entity로 매핑해야할수도있음
  
  애그리거트는 개념적으로 하나이므로 리포지터리는 애그리거트 전체를 저장소에 영속화해야함
  또한 애그리거트를 구하는 레포지토리 메서드는 완전한 애그리거트 전체를 제공해야함(모든걸 포함하는 루트애그리거트를 제공해야함)
  즉 루트애그리거트만 찾아서 써도,npe가 안떠야함
  
  또한 애그리거트의 상태가 변경되면 모든 변경을 원자적으로 저장소에 반영해야함
  애그리거트에서 두개의 객체를 변경했는데,저장소에는 한객체에 대한 변경만 반영되면 일관성이 깨짐
  
*4.ID를 이용한 애그리거트 참조  
  한 객체가 다른 객체를 참조하는거처럼 애그리거트도 다른 애그리거트를 참조함
  이때 다른애그리거트라는건 다른 애그리거트루트를 참조한다는거임
  
  이건 필드로 쉽게 구현할수있음
  이렇게 다른애그리거트를 직접 접근하는건 구현이 편해지지만,캡슐화가 약해진다는 문제가 있음
  즉
    편한 탐색을 오용할수있음
	성능에 대한 문제
	확장이 어려움(강의존)
  이런 문제가 생김
  
  다른애그리거트의 상태를 직접 변경할수있으면 트랜잭션범위도 여러 애그리거트로 늘어나게되서 성능도 떨어지고,의존결합도도 올라가서 변경이 어려워짐
  또한 n+1같은 문제에 대해서도 고민을 해야하게되고,여러 다른종류의 db를 사용하고싶을떄도 머리아파짐
  
  그래서 id를 이용해서 간접적으로 다른애그리거트를 참조하면 이런문제가 완화됨
  이렇게 하면 모든 객체가 참조로 연결되지않고,한 애그리거트에 속한 객체만 참조로 연결됨
  그래서 애그리거트간 경계가 명확해지고,물리적 연결을 제거해서 복잡도가 낮아짐
  또한 애그리거트간 의존을 제거해서 응집도도 올려줌
  
  구현복잡도도 낮아짐,직접 다른 애그리거트를 참조하지않으니 지연로딩같은걸 신경쓰지않아도됨
  다른 애그리거트가 필요하면 서비스에서 id를 이용해서 로딩하면됨
  
  이러면 복잡도도 낮출수있고,한애그리거트에서 다른 애그리거트를 수정하는걸 근본적으로 방지할수있음(불가능하니까)
  또한 애그리거트별로 다른 구현기술을 사용할수도있음
  
  1.id를 이용한 참조와 조회성능
    다른애그리거트를 id로 참조하면 여러 애그리거트를 읽을때 조회속도가 문제될수있음(n+1)
	그래서 이런경우엔 조인을 사용해야함
	물론 객체참조방식으로 돌리는것도 있지만 그러면 의미가없고..
	
	이럴땐 조회전용쿼리를 만들면됨
	조회를 위한 별도의 레포지토리를 만들고,여기서 조인으로 한번의 쿼리로 필요한 데이터를 모두 로딩하면됨
	
	애그리거트마다 서로 다른 저장소를 사용하면 한쿼리로 모두 조회할수없는데,이떈 캐시나 조회전용저장소를 따로 구성해야함

*5.애그리거트간 집합연관
  애그리거트간 1-N연관이 있을땐
  set같은 컬렉션으로 표현할수있음
  그런데 개념적으로 존재하는 애그리거트간 1-N을 실제 구현에 반영하는게 요구사항과 상관없을떄가 있음
  이걸 그대로 구현하면 n+1이 되니까,이러면 그냥 N-1로 바꿔서(카테고리안에 상품이 있는게 아닌,상품이 카테고리를 가지는식)만드는게 나음 
  
  M-N연관도 실제 요구사항에 그게 필요할지를 고려하고 결정해야함
  개념적으로 양방향 연관이 존재하더라도,구현에서 단방향만 존재한다면 그거만 적용하면됨
  기본적으로 M-N은 조인테이블(중간테이블)이 필요함
  
*6.애그리거트를 팩토리로 사용
  애그리거트에서 처리가 가능한 로직은 가급적 응용서비스보단 애그리거트에 있는게 응집도측면에서 더 좋음
  특히 특정 애그리거트가 다른 애그리거트를 생성할때,생성이 가능한지를 판단하고 생성하는건 논리적으로 하나의 도메인기능이니 생성하는 애그리거트쪽에 있는게 맞음
  (ex.store가 product를 생성할때,금지된품목이면 생성하지않음)
  이 도메인기능을 넣기위한 별도의 도메인서비스나 팩토리클래스를 만들수도있지만,이걸 애그리거트(store)에 넣을수도있음
  
  이러면 팩토리역할을 하면서도 중요한 도메인로직을 구현할수있어짐
  응용서비스는 팩토리를 사용해서 생성하면되는거
  
  즉 애그리거트가 자신의 데이터를 이용해서 다른 애그리거트를 생성해야한다면,애그리거트에 팩토리메서드를 구현하는걸 고려해볼수있음
  또한 그 애그리거트의 정보량을 벗어난 정보가 필요하다면,직접 생성하지않고 다른팩토리에 위임하는 방법도 있음
  이렇게 위임을 하더라도 도메인로직(금지된 품목이면 생성하지않음)은 한곳에 모이게됨
  
4.리포지터리와 모델구현 
*1.JPA를 이용한 리포지터리 구현
  1.모듈위치
    리포지터리 인터페이스는 도메인영역에 속하고,리포지토리 구현체는 인프라영역에 속함
	그래서 서로간에 직접의존을 끊어내고 약의존해야함

  2.리포지터리 기본기능 구현
    리포지터리는 id로 애그리거트조회와 애그리거트 저장은 반드시 있어야하는 기본 기능임
	조회 인터페이스는 애그리거트 루트를 기준으로 작성하고,루트를 리턴하면됨
	또한 업데이트는 더티체킹으로 하니까 메서드가 없어도됨
  
*2.스프링 데이터 JPA를 이용한 리포지터리 구현
  스프링 데이터 jpa를 사용하면,규칙에 맞게 만들면 알아서 스프링빈으로 만들어줌
  그래서 인터페이스만 만들고 주입받으면됨
  
  또한 중첩프로퍼티(특정 필드객체안의 속성으로 조회)도 가능함
  
  
*3.매핑 구현 
  1.엔티티와 밸류 기본 매핑
    엔티티는 @Entity로,
    밸류는 @Embeddable로 매핑을 설정하고,밸류타입 프로퍼티는 @Embedded로 매핑하면됨
  2.기본 생성자
    기본생성자는 불변타입이라면 필요없지만,jpa를 사용하면 있어야함,그래서 프로텍티드로 선언해두면 됨
  3.필드접근방식 사용
    엔티티가 객체로서 제역할을 하려면,필드공개가 아닌 의도가 잘 드러나는 기능(이름)으로 제공해야함

  4.AttributeConverter을 이용한 밸류 매핑 처리
    만약 여러 밸류타입프로퍼티를 한 칼럼에 매핑해야한다면(db의 한칼럼을 2개이상의 필드로 뽑아내야한다면) AttributeConverter을 사용할수있음
	또한 값을 특이하게 변환해서 저장하고,그걸 다시 특이하게 읽어와야할때도 사용됨(이게 주목적)
	이건 밸류타입과 칼럼데이터간의 변환을 처리하기위한 기능을 정의하고있음
	필요해지면 보자

  5.밸류컬렉션:별도테이블매핑
    컬렉션을 프로퍼티로 가져야하고,순서가 있다면 list로 컬렉션을 프로퍼티로 지정할수있음
	또한 컬렉션을 외부테이블로 매핑하려면
		@ElementCollection(fetch = FetchType.EAGER)
		@CollectionTable(name = “order_line”,
		joinColumns = @JoinColumn(name = “order_number”))
		@OrderColumn(name = “line_idx”)
		private List<OrderLine> orderLines;
	이런식으로 하면됨

  6.밸류컬렉션:한개 칼럼 매핑
    밸류컬렉션을 한개칼럼에 저장해야할땐(콤마구분),AttributeConverter를 사용할수있음
	
  7.밸류를 이용한 id매핑
    id도 클래스를 만들어서 표현할수있음
	이땐 @id대신 @EmbeddedId를 사용해야함
	또한 jpa에서 식별자타입은 serializable타입이어야함으로,이걸 상속받아야함
	이러면 식별자에 메서드를 추가할수있다는 장점이 있음

  8.별도 테이블에 저장하는 밸류 매핑
    애그리거트에서 루트를 뺀 나머지 구성요소는 대부분 밸류임
	다른 앤티티가 있다면 이게 진짜 엔티티인지 의심해봐야함(단지 별개의 테이블에 저장한다고 엔티티가 아님)
	
	그리고 앤티티가 확실하다면,그게 다른애그리거트가 아닌지도 확인해야함
	특히 자신만의 독자적인 라이프사이클을 갖는다면 구분되는 애그리거트일 가능성이 높음
	
	애그리거트에 속한 객체가 밸류인지 엔티티인지 구분하는건,고유식별자가 필요한지(단지 db에 저장하는 용도가 아닌 진짜로 필요한지)여부가 가장 확실함
	
	그리고 여러 테이블값을 한 밸류에 모을땐 @AttributeOverride와 @SecondaryTable를 사용하면됨

  9.밸류컬렉션을 @Entity로 매핑하기
    개념적으로 밸류인데 구현기술의 한계,팀표준등으로 @Entity로 매핑해야할수도 있음
	이떈 @Entity를 사용해서 상속매핑으로 처리해야함
	또한 상태를 변경하는 기능은 상위에서 가져가야하고,캐스케이드와 고아제거를 같이 넣으면 좋음

  10.id참조와 조인테이블을 이용한 단방향 M-N매핑
    만약 M-N매핑이 꼭 필요하다면,id참조를 이용해서 단방향 집합 연관을 적용해볼수있음
	이때 @ElementCollection을 사용하면됨
	id를 사용하면 영속성전파나 로딩전략등도 신경쓰지않아도됨
  
*4.애그리거트 로딩 전략 
  jpa 매핑에서 가장 중요한건 애그리거트에 속한 객체 모두 모여야 완전한 하나가 된다는것,
  즉 루트를 로딩하면 루트에 속한 모든객체가 이론상 완전한 하나여야한다는것
  
  그래서 jpa로딩 기본값이 EAGER인거임
  그런데 성능상의 이유로 이러면 n+1이 날수있음(특히 컬렉션 로딩할때 카타시안곱되면 큰일남)
  
  애그리거트는 개념적으론 하나여야하지만,루트엔티티를 로딩하는시점에 애그리거트에 속한 객체를 모두 로딩해야하는건 아님
  애그리거트가 완전해야하는 이유는
    상태를 변경할때 애그리거트가 완전해야함
	표현영역에서 애그리거트의 상태를 보여줄때 필요함(단 이건 별도의 조회전용기능과 모델을 구현하는게 나음)
  두가지 이유인데,이중 두번째는 다른방법이 있고,상태변경시 완전해야한다는게 더 관련성이 큼
  그런데 상태변경을 할때 꼭 조회시점에서 전부 들어차있어야할필요는 없어서 지연로딩을 하는거임(그리고 변경시점에 필요한걸 로딩해도됨)
  
  또한 보통은 상태변경보다 조회기능실행확률이 압도적으로 높기때문에,상태변경시의 지연로딩 추가쿼리로 인한 속도저하는 별로 문제가 되지않음
  
  지연로딩은 동작방식이 항상 동일해서 머리를 덜써도됨
  대신 쿼리실행횟수가 늘어날 가능성이 있긴함
  
*5.애그리거트의 영속성 전파
  애그리거트가 완전한 상태여야한다는건,루트를 조회할때만이 아니라 저장하거나 삭제할때도 하나로 처리해야함을 의미함
  즉
    저장메서드는 루트만 저장하면 안되고,애그리거트에 속한 모든 객체를 같이 저장해야함
	삭제메서드는 루트만 삭제하면 안되고,애그리거트에 속한 모든 객체를 삭제해야함
  임베딩 매핑타입(밸류)는 어짜피 같이 삭제되니 cascade를 추가설정하지않아도 되지만,애그리거트에 속한 엔티티는 캐스케이드를 설정해서 같이저장,같이삭제되어야함

*6.식별자 생성 기능
  식별자(id)는
    사용자가 직접 생성(이메일,아이디등)
	도메인로직으로 생성(uuid)
	db를 이용한 일련번호(오토인크리즈)사용
  3가지 방법으로 보통 생성함
  
  사용자가 직접 식별자를 입력하는건 생성주체가 사용자라서 별로 신경쓰지않아도 되지만,보통 이런 자연키보단 인조키를 사용하는편
  이게 아니라면 식별자생성규칙은 도메인규칙이므로 도메인영역에 식별자생성기능을 위치시켜야함
  응용서비스는 이걸 활용해서 식별자를 구하고 엔티티를 생성할수있음(아예 생성자에 박아도되긴함)
  
  아니면 리포지터리에서 식별자를 생성하는 메서드를 추가하거나,jpa를 의존할수도있음(오토인크리즈먼트)

*7.도메인 구현과 dip
  이론적으로는 도메인은 구현기술인 jpa를 의존하면 안됨(즉 @Entity등을 사용하면안됨)
  그런데 이렇게 하는 이유는,저수준 변경이 고수준에 영향을 주지않게 하기위함인데,리포지터리와 도메인 모델의 구현기술은 거의 바뀌지않음
  이렇게 변경이 거의 없는 상황에서 변경을 미리 대비하는건 과할수있고,이건 타협이 가능함
  
  그렇다고 이렇게한다고 테스트가 귀찮아지지도않음
  dip를 완벽하게 지키는것도 좋지만,편의와 실용성도 따져가면서 살아야함
  
  
5.스프링 데이터 JPA를 이용한 조회기능  
*1.시작에 앞서
  앞에서 본 모델(엔티티,애그리거트,리포지터리등)은 주문취소,배송지변경등 상태를 변경할때 주로 사용됨
  즉 도메인 모델은 명령모델로 주로 사용되고,
  정렬,페이징,검색조건지정등의 기능은 주문목록,상품상세같은 조회기능에 사용됨
  즉 조회모델과 명령모델은 분리하는게 CQRS패턴의 기본임

*2.검색을 위한 스펙
  검색조건이 다양하거나 동적조건이 필요하다면 필요한게 스펙임
  스펙은 애그리거트가 특정 조건을 만족하는지를 검사할떄 사용하는 인터페이스임
  이건 단순히 제네릭을 받고,현재 이게 만족하는지를 나타내는 메서드 하나만 있으면됨
  
  스펙을 리포지터리에 사용하면,제네릭은 애그리거트 루트가 되고,스펙을 dao(읽기전용레포)에 사용하면 제네릭은 검색결과로 리턴할 데이터객체가 됨
  그리고 메서드는 검사대상객체가 조건을 충족하면 true를,그렇지않으면 false를 리턴하는식으로 구현하면됨
  그래서 스펙구현체는 생성자로 필요한 정보를 받고,그걸가지고 메서드(제네릭)로 받은 객체를 비교하는식으로 하면됨
  
  스펙은 검색대상을 걸러내는용도로 사용됨(물론 메모리에 보관하고있을때)
  즉 특정조건을 충족하는 애그리거트를 찾고싶으면 원하는 스펙을 생성해서 리포지터리에 전달해주면됨
  물론 이건 비현실적이라서,보통은 스프링 데이터 JPA를 사용해서 스펙을 구현하게됨
  
*3.스프링 데이터 JPA를 이용한 스펙구현  
  스프링 데이터 JPA는 검색조건을 표현하기위한 인터페이스인 Specification이라는 스펙인터페이스를 제공함
  이것도 위에 스펙과 비슷하게,제네릭을 받고,검증메서드가 있음
  이때 특이한건,검증메서드에서 제네릭에 추가로 쿼리와 쿼리빌더를 받아서 검증해준다는것
  
  그래서 조건별로 스펙을 만들지않고,별도클래스에 스펙생성기능을 모아도됨
  
*4.리포지터리/DAO에서 스펙 사용하기 
  스펙을 충족하는 엔티티를 검색하려면 findAll을 사용하고 스펙을 넘겨주면됨(스펙인터페이스를 파라미터로 가짐)
  
*5.스펙조합
  스프링데이터 JPA는 스펙을 조합할수있는 두 메서드를 제공하는데,이건 and와 or임(디폴트메서드)
  이름그대로 and는 둘다 만족하는 조건을 표현하고,or은 둘중 하나만 만족하는걸 표현하는 스펙을 생성함
  
  또한 not도 제공함,이것도 이름그대로 조건을 반대로 적용할때 사용됨
  
  만약 null가능성이 있는 스펙객체와 다른객체를 조합해야할땐 where메서드를 사용하면 null을 제공받으면 빈 스펙을 만들어줌

*6.정렬 지정하기
  스프링데이터 JPA에서 정렬은 메서드이름에 OrderBy로 명시하거나,Sort를 인자로 전달하는방식으로 정렬을 지정할수있음
  메서드명으로 하는건 편하긴한데,정렬기준프로퍼티가 두개이상이면 이름이 너무길어지고,상황에 따른 정렬순서변경도 불가능함
  이땐 Sort를 사용하면됨
    sort=Sort.by("칼럼명").ascending()
	dao.findByOrderId("123",sort)
  Sort를 사용해서 두개이상의 정렬순서를 지정할떈 and를 사용하면됨
  
*7.페이징 처리하기
  스프링데이터 JPA에서 페이징을 할떈 Pageable타입을 이용하면됨
  sort와 마찬가지로 Pageable타입 파라미터를 find계열에 넣으면 자동으로 페이징을 해줌
  Pageable타입 객체는
    pagereq=PageRequest.of(1,10)
	dao.findByOrderId("123",pagereq)
  이런식으로 만들어서 쓰면됨
  또한 정렬도 해야한다면
	pagereq=PageRequest.of(1,10,sort)
	dao.findByOrderId("123",pagereq)
  이렇게 하면됨
  또한 이렇게하면 조건에 해당하는 전체 갯수도 알수있는데(count),
  리턴타입이 Page면 카운트쿼리를 돌리고,리턴이 List면 카운트쿼리를 돌리지않으니 상황에 따라 카운트갯수가 필요없다면 list로 받는게좋음
  단,스펙을 사용하는 findAll메서드에선 리턴타입이 Page가 아니어도 카운트쿼리가 실행되니 주의(이거막으려면 커스텀리포지토리 만들어야함)
  
  그리고 페이징이 아니라 n개만 필요하다면 findFirstN같은걸 사용할수있음
  
*8.스펙조합을 위한 스펙빌더클래스
  스펙을 조건에따라 조합해야할떈,if를 사용하면 실수하기 좋음
  그래서 이럴땐 스펙빌더를 만들어 쓰는게 좋음
  참고는 책보자
  
*9.동적 인스턴스 생성
  Jpa는 쿼리결과에서 임의의 객체를 동적으로 생성할수있는 기능을 제공함
  JPQL로 new를 붙이고 해당클래스의 경로를 전부 적으면 됨(책참고)
  
  이런식으로 하면 객체기준으로 쿼리를 작성하면서도 지연로딩 즉시로딩같은걸 신경쓰지않아도되서 편함
  
*10.하이버네이트 @Subselect사용
  @Subselect 는 쿼리결과를 @Entity로 매핑할수있는 기능임
  이건 하이버네이트 전용인데,이러면 테이블이 아닌 쿼리결과를 @Entity로 매핑할수있음
  이렇게 조회된 엔티티는 수정할수없음(뷰테이블처럼 사용됨)
  그래서 @Immutable을 붙여서 수정불가를 지정하고,@Synchronize를 붙여서 변경순서를 맞춤
  
  이건 보통 from절의 서브쿼리로 사용됨,즉 서브쿼리용도에선 조회만 하면되니까 사용되는것
  이게싫다면 네이티브SQL을 사용하거나 마이바티스같은걸 써야함

6.응용서비스와 표현영역
*1.표현영역과 응용영역
  표현영역은 사용자의 요청을 해석하고,이걸 응용영역에 전달함
  실제 사용자가 원하는 기능은 서비스에 있고,
  응용영역의 서비스는 기능을 실행하는데 필요한 입력값을 메서드인자로 받고 실행결과를 리턴함
  
  서비스의 메서드가 요구하는 파라미터와 표현영역이 사용자로부터 받는 데이터는 형식이 일치하지않기때문에,
  표현영역은 응용서비스가 요구하는 형식으로 사용자요청을 변환해서 서비스의 메서드를 호출함
  
  이후에 표현영역은 json등으로 사용자요청에 맞게 리턴하면됨
  
*2.응용서비스의 역할  
  서비스는 사용자가 요청한 기능을 실행함
  즉 요청을 처리하기위해 리포지터리에서 도메인객체를 가져와서 도메인의 기능을 실행하는 역할을 함
  굳이말하자면 창구같은느낌임,직접 뭘 하기보다 도메인간의 흐름을 제어하는역할
  
  그래서 보통 응용서비스는 코드가 간단하고,만약 복잡하다면 도메인로직의 일부를 구현하고있을 가능성이 높음
  이러면 응집도가 낮아지고 코드중복등 단점이 많으니 가급적 도메인단으로 내리는게 좋음
  
  또한 응용서비스는 트랜잭션처리도 담당함
  얘는 도메인의 상태변경을 트랜잭션으로 처리해야함,그래야 일관된 처리가 가능해짐
  
  1.도메인로직 넣지않기
    도메인로직은 도메인단에 있어야함
	암호변경같은게 응용서비스에 있다면 응집도와 코드중복같은게 생길가능성이 커짐
	그러니 가급적 도메인에 있고,응용서비스는 그걸 불러다가 사용하는,위임에 그쳐야함(물론 결과값을 기반으로 예외를 던지는건 서비스에서 해도됨)

3.응용서비스의 구현
  응용서비스는 파사드같은 역할을 하고,복잡한 로직을 수행하지않음
  서비스의 구현자체는 어렵지않지만 생각해볼만한게 몇개 있음
  1.응용서비스의 크기
    응용서비스는 모든 로직을 해당 도메인의 응용서비스에 몰빵할수도 있고,구분되는기능별로 응용서비스 클래스를 따로 구현할수도있음
	
	한곳에 몰빵하면 각 기능에서 동일로직에 대한 코드중복을 제거할수있다는 장점이 있음(멤버가 없을때 익셉션을 던지는 로직을 프라이빗메서드로 뽑아서 쓰기)
	대신 한 서비스클래스가 커진다는 단점이 있음,이러면 연관성이 적은 코드가 한클래스에 함께 위치할 가능성이 높아져서,이해가 좀 힘들어짐
	또한 엄연히 분리하는게 좋은상황이라도 관습적으로 계속 추가하게돼서 코드품질이 점점 낮아짐
	
	구분되는 기능별로 서비스클래스를 구현하는건 한 서비스클래스에서 한개 내지 두세개의 기능을 구현함
	이러면 클래스갯수는 많아지지만 코드품질이 일정수준으로 유지됨
	또한 코드의 중복의 경우 별도클래스로 로직을 구현하고(헬퍼) 이걸 가져다쓰는식으로 해결할수있음
	
	구분되는 기능별로 서비스를 구현하는걸 디폴트로 잡는게 좋음

  2.응용서비스의 인터페이스와 클래스
    인터페이스는 구현클래스가 여러개(런타임에 구현객체를 교체해야할때)거나,tdd를 하기위해서 사용됨
	그런데 보통서비스의 경우엔 구현클래스가 여러개일 이유가 별로없고,
	tdd의 경우에도 모킹객체를 만들어버리면돼서(mockito) 굳이 인터페이스가 필요하진않음

  3.메서드 파라미터와 값리턴
    응용서비스가 제공하는 메서드는 도메인을 이용해서 사용자가 요구한 기능을 실행하는데 필요한값을 파라미터로 받아야함
	이건 개별파라미터로 받을수도있고,dto로 받을수도있음
	
	또한 서비스의 리턴값을 표현영역에서 사용해야하면 값을 리턴해야하는데,이때 애그리거트를 그대로 리턴하면 도메인의 로직실행을 서비스와 표현영역 두군데서 하게됨
	이러면 응집도가 떨어지니 가급적 애그리거트를 까서 필요한거만 던지는게 좋음

  4.표현영역에 의존하지않기
    가장중요한건 서비스는 표현영역과 관련된 타입을 사용하면 안됨(HttpServletRequset나 HttpSession같은거)
	이러면 테스트가 어려워지고,표현영역의 구현이 변경되면 응용서비스의 구현도 함께 변경해야함
	이런 외부표현과 관련된건 컨트롤러단에서 다끝내고,로직실행만 응용서비스로 와야함
	
	이걸 지키기 가장 쉬운방법이 서비스에서 파라미터와 리턴타입으로 표현영역의 구현기술을 사용하지않는것

  5.트랜잭션 처리
    프레임워크가 제공하는 트랜잭션기능은 적극적으로 사용하는게 좋음

*4.표현영역
  표현영역은
    사용자가 시스템을 사용할수있는 흐름(화면)을 제공하고 제어한다
	사용자의 요청을 알맞은 응용서비스에 전달하고 결과를 사용자에 제공
	사용자세션을 관리
  이 3가지가 주요 책임임
  
  사용자가 요청을 하면,요청 맞는 폼을(mvc일때) 띄워주고,거기서 입력된 정보를 다시 받아서 응용서비스에 전달한후 리턴해주는게 주 역할임
  세션관리는 쿠키나 서버세션등으로 사용자와의 연결상태를 관리(+권한검사)
 
*5.값 검증
  값검증은 표현영역과 응용서비스 두곳에서 모두 할수있음
  원칙적으로는 응용서비스에서 처리하는게 맞음,단 표현영역에서 처리하는건,잘못된값이 존재할때 에러메시지를 보여주고 다시 값을 돌려주기쉬움
  그래서 응용서비스에서 에러코드를 모아 하나의 익셉션(밸리데이션에러)으로 발생시키는 방법도 있음
  이러고나서 해당에러가 발생하면,현재데이터랑 같이 리턴하는형식
  
  표현영역에서 밸리데이션을 처리하면,응용서비스는 id중복여부같은 논리적오류만 검사하면됨
  그래서 응용서비스를 사용하는 표현영역코드가 한곳이면,표현영역에서 필수값,값의형식,범위등을 검증하고,
  응용서비스에서 데이터의 존재유무등 논리적 오류를 검증할수있음
  
  근데 요즘은 어지간하면 응용서비스에서 전부 처리하는추세임
  이러면 응용서비스의 완성도(밀집도)가 올라가게됨

*6.권한검사
  개발하는 시스템마다 권한의 복잡도는 다름
  인증만 검사하면 될수도,관리자검사까지 해야할수도
  그래서 스프링시큐리티같은걸 사용하면 편한데,대신 복잡도가 높음
  
  보안프레임워크의 복잡도를 떠나서 보통 세곳에서 권한검사를 할수있음
    표현영역
	응용서비스
	도메인
  표현영역에서 할수있는 기본검사는 인증된사용자인지 아닌지,url별 권한등을 검사할수있음(해당회원이 맞는지),이건 서블릿필터(스프링인터셉터)단에서 처리됨
  응용서비스에선 메서드단위로 권한검사를 수행할수있음(@PreAuthorize등)
  개별 도메인단위로 권한검사를 해야한다면 좀 복잡해짐,이러면 로직을 직접 만들어야함

*7.조회전용기능과 응용서비스
  서비스에서 조회전용기능을 사용하면,서비스코드는 단순히 조회전용기능을 호출하는 형태로 끝날수있음
  이러면 서비스에서 수행하는 추가로직도 없고,단일쿼리만 실행하는 조회전용기능이니 트랜잭션도 필요없음
  이럴경우엔 표현영역에서 이걸 사용해도 됨

7.도메인서비스
*1.여러 애그리거트가 필요한 기능
  도메인영역의 코드중,한 애그리거트로 기능을 구현할수없을때(결제금액계산등),이때 한 애그리거트에 억지로 넣으면 안됨
  이러면 수정이 발생했을때 전혀 상관없는 애그리거트를 수정해야할수있어짐
  
  즉 애그리거트가 자신의 책임범위를 넘어서는 기능을 구현하기때문에,코드가 길어지고 외부의존이 높아져서 코드가 복잡해지고 수정이 어려워짐
  또한 이런경우 도메인개념이 애그리거트에 숨어 명시적으로 드러나지않게됨
  그래서 이땐 도메인서비스를 사용할수있음
  
*2.도메인서비스
  도메인서비스는 도메인영역에 위치한 도메인로직을 표현할때 사용됨
  주로 사용되는곳은
    계산로직:여러 애그리거트가 필요한 계산이나,한애그리거트에 넣긴 복잡한 계산로직
	외부시스템연동이 필요한 도메인로직:구현하기위해 타 시스템을 사용해야하는 도메인로직
  임
  1.계산로직과 도메인서비스
    할인금액계산처럼 한 애그리거트에 넣기 애매한 도메인개념은 도메인서비스로 도메인개념을 명시적으로 드러낼수있음
	응용서비스가 응용로직이라면,도메인서비스는 도메인로직을 다룸
	
	도메인서비스가 애그리거트나 밸류랑 다른점은,상태없이 로직만 구현한다는것
	상태는 다른방법(보통 매개변수)로 전달받음
	도메인서비스는 도메인의 의미가 드러나는 용어를 타입과 메서드명으로 가짐
	
	이 도메인서비스를 사용하는주체는 애그리거트가 될수도있고,응용서비스가 될수도있음
	즉 애그리거트에서 매개변수로 도메인서비스를 받아서 로직을 위임하고 값을 받아쓸수있음
	
	또한 애그리거트객체에 도메인서비스를 전달하는건 응용서비스의 책임임
	즉 도메인서비스객체를 애그리거트에 주입하는건 좋지않음,상태가 없고 일부기능에서만 사용하는 서비스객체를 di받을필요는 없음
	
	반대로 애그리거트메서드를 실행할떄 도메인서비스를 인자로 전달하는게 아닌,도메인서비스의 기능을 실행할때 애그리거트를 전달하기도 함
	보통 계좌이체같은걸 할때 이런식으로 만들게됨
	그리고 응용서비스에서 이 로직을 호출해서 애그리거트를 넣은다음 사용하는것
	단 이때 트랜잭션등의 응용로직은 응용서비스의 책임이니 하면안됨
	
	특정기능이 응용서비스인지 도메인서비스인지 감을 잡기 어려울땐,해당로직이 애그리거트의 상태를 변경하거나 애그리거트의 상태값을 계산하는지 검사해보면됨
	이런 로직들은 도메인로직임

  2.외부시스템연동과 도메인서비스
    외부시스템이나 타 도메인과의 연동도 도메인서비스가 될수있음
	설문조사시스템은 설문조사를 생성할때 사용자가 생성권한이 있는지를 확인하기위해 역할관리시스템과 연동하는 식임
	
	시스템간 연동은 api호출로 이뤄질수있지만,도메인입장에선 사용자가 생성권한이 있는지를 확인하는 로직임
	이러면 도메인에서 인터페이스(이때 도메인입장에서 만드는게 중요,연동관점에서 생성되면안됨)를 만들고,
	응용서비스는 이 인터페이스에 의존해서 생성권한을 검사할수있음
	또한 구현체의 경우는 인프라영역에서 구현해서 검사기능을 구현하면됨

  3.도메인서비스의 패키지 위치
    도메인서비스는 도메인로직을 표현하므로 도메인서비스는 다른 도메인과 같은패키지에 있으면됨
	즉 주문계산도메인서비스는 주문애그리거트와 같은패키지에 있으면됨
	만약 명시적으로 구분하고싶으면 도메인밑에 하위패키지를 만들어도됨

  4.도메인서비스의 인터페이스와 클래스
    도메인서비스의 로직이 고정되어있지않다면,도메인서비스 자체를 인터페이스로 만들고 이를 구현한 클래스를 둘수도있음
	특히 도메인로직을 외부시스템이나 별도엔진을 이용해서 구현할때 이렇게 분리하게됨
	이러면 도메인영역에는 도메인서비스인터페이스가,실제구현은 인프라영역에 위치하게됨
	이렇게해야 도메인영역이 특정구현에 종속되는걸 막을수있고,도메인영역의 테스트가 쉬워짐

8.애그리거트 트랜잭션관리
*1.애그리거트와 트랜잭션
  한 애그리거트에 대해 동시변경을 하면,논리적으로는 동일한 애그리거트지만 변경시점엔 물리적으로 서로 다른 애그리거트를 사용해서 변경하게됨
  이걸 막기위해 트랜잭션을 사용해 비관적락(선점잠금)이나 낙관적락(비선점잠금)을 사용해야함
*2.선점잠금
  선점잠금은 먼저 애그리거트를 구한 스레드가 애그리거트 사용이 끝날때까지 다른 스레드가 해당 애그리거트를 수정하지못하게 막는것
  이건 db단에서 for update등으로 구현하게됨
  jpa에서도 자체적으로 지원해줌
  
  1.선점잠금과 교착상태
    선점잠금을 사용할땐 교착상태(데드락)이 발생하지않게 주의해야함
	즉 모든 자원을 취득하는 순서를 통일하고,선점잠금에선 타임아웃을 넣어두는게 좋음(안전장치)

*3.비선점잠금
  선점잠금은 강력하지만,모든 트랜잭션충돌이 해결되진않음
  특히 애그리거트단위로 생각할때 문제가 되는데,선점잠금은 테이블단위로 잠기는데,애그리거트의 하위 엔티티가 별개의 테이블일경우가 문제가 될수있음
  
  이때 필요한게 비선점잠금임
  비선점잠금은 동시접근을 막는대신,변경한데이터를 실제 db에 반영하는시점에 변경가능여부를 확인하는 방식임
  
  이건 보통 버전을 사용해서 처리함
  자기가 본 마지막버전과 버전이 같은경우에만 업데이트를 하고,다른경우엔 예외를 발생시키는형식
  jpa에서도 @Version등으로 지원함
  
  응용서비스는 버전에대해 알필요가 없고,그냥 리포지터리쓰는거처럼 그대로 쓰면됨
  이때 버전에러가 나서 실패한경우에 OptimisticLockingFailureException이 발생하는데 이걸 가지고 충돌체크를 하면되는거
  
  1.강제버전증가
    애그리거트에 루트말고 다른 엔티티가 존재하는데,애그리거트는 그 단위 그대로 트랜잭션이 걸려야함
	이땐 다른 엔티티의 변경시에도 루트 애그리거트의 버전이 증가해야함
	jpa에선 LockModeType.OPTIMISTIC_FORCE_INCREMENT로 할수있음
	이건 해당 엔티티상태 변경에 관계없이,트랜잭션종료시에 버전값증가처리를 하게됨

*4.오프라인 선점잠금
  완전한 데이터 충돌을 막고싶다면 오프라인 선점잠금을 사용할수있음
  선점잠금이 단일 트랜잭션으로 동시변경을 막았다면,이건 여러 트랜잭션에 걸쳐 동시변경을 막음
  즉 작업이 여러 트랜잭션에 걸쳐야하는데,이안에서의 선점잠금이 필요할때 사용할수있음(폼요청후 계정수정등)
  이경우 오래 락이 걸리기때문에 반드시 타임아웃이 있어야함
  시간을 늘릴때도 계속 ajax호출등으로 시간을 늘리든가 이런식으로 해야함
  
  1.오프라인 선점 잠금을 위한 LockManager 인터페이스와 관련 클래스
    오프라인 선점잠금은 잠금선점시도,잠금확인,잠금해제,잠금유효시간연장 총 4가지 기능이 필요함
	그래서 LockManager인터페이스를 구현해서 사용하면됨
	
	상세는 책보자 그냥
	사용할일이 많진않을듯


9.도메인모델과 바운디드컨텍스트
*1.도메인모델과 경계
  도메인모델을 만들때 가장 빠지기 쉬운 함정은,도메인을 완벽하게 표현하는 단일모델을 만드는 시도를 하는것
  한 도메인은 다시 여러 하위도메인으로 구분되기때문에,하나의 모델로 모든 하위도메인을 표현하려고하면 모든 하위도메인에 맞지않는 모델이 나오게됨
  
  논리적으로 같은존재처럼 보이지만 하위도메인에 따라 다른용어를 사용하는 경우도 있음
  그래서 하위도메인마다 사용하는 용어가 다르기때문에,올바른 도메인모델을 개발하려면 하위도메인마다 모델을 만들어야함
  
  각 모델은 명시적인 경계를 가져서 섞이지않게 해야하고,모델은 컨텍스트하에서 완전한 의미를 가짐
  같은 제품이라도 카탈로그 컨텍스트와 재고컨텍스트에서 의미가 서로 다르고,이런 컨텍스트를 바운디드컨텍스트라고 부름

*2.바운디드 컨텍스트
  바운디드컨텍스트는 모델의 경계를 결정하고,한개의 바운디드컨텍스트는 논리적으로 하나의 모델을 가짐
  바운디드컨텍스트는 용어를 기준으로 구분할수있음
  
  하나의 하위도메인과 바운디드컨텍스트가 항상 일대일이면 좋겠지만,그렇지 않을떄가 많음
  팀에 따라 나눠지기도하고,용어구분을 실패해 두 하위도메인이 하나의 바운디드컨텍스트에 들어가기도함
  
  이렇게 여러 하위도메인을 하나의 바운디드컨텍스트에서 개발할떄 주의할점은,하위도메인의 모델이 섞이지않게하는것
  전체 하위도메인을 위한 단일모델을 만들려고하면안됨,확장이 어려워짐
  하나의 바운디드컨텍스트가 여러 하위도메인을 포함해도,각 도메인마다 구분되는 패키지를 갖게 구현해야하며,
  이렇게함으로써 하위도메인을 위한 모델이 서로 뒤섞이지않고 각 도메인마다 바운디드컨텍스트를 갖는 효과를 낼수있음
  
  즉 바운디드컨텍스트는 도메인모델을 구분하는 경계가 되고,그래서 구현하는 하위도메인별로 하나의 모델을 포함하게됨

*3.바운디드컨텍스트 구현
  바운디드컨텍스트에 도메인모델만 있는건 아님
  표현영역,응용서비스,인프라등을 모두 포함함
  또한 도메인모델의 데이터구조가 바뀌면 db테이블 스키마도 함께 변경되기때문에 테이블도 바운디드컨텍스트에 포함됨
  
  모든 바운디드컨텍스트를 도메인주도로 개발할필욘없음
  간단한건 crud해도됨
  crud로 만들면 도메인로직이 서비스로 흩어지는게 문제지만,애초에 도메인로직이 단순하다면 별로 신경쓰지않아도됨
  
  또 이거 두개를 섞을수도있는데,대표적으로 cqrs가 있음(조회부분을 crud로)
  
  또 각 바운디드컨텍스트를 서로 다른 구현기술을 사용해서 구현할수도있음

*4.바운디드컨텍스트간 통합
  두 팀이 관련된 바운디드 컨텍스트를 개발하면 자연스럽게 두 바운디드컨텍스트간 통합이 발생함
  이때 두 컨텍스트의 도메인모델은 서로 다른데,통합을 하려면 상대방의 도메인모델을 기반으로 기능을 표현해야하는 문제가 생길수있음
  이럴땐 도메인서비스를 사용할수있음
  
  통합에는 restapi를 호출하는식으로 직접 통합할수도 있고,
  메시지큐등으로 간접적으로 통합할수도있음
  중요한건 중간에 부패방지계층처럼 동작하는 통역레이어가 있어야한다는것

*5.바운디드 컨텍스트간 관계
  바운디드컨텍스트는 어떤식으로든 연결되기때문에 두 바운디드컨텍스트는 다양한 방식으로 관계를 맺음
  가장 흔한 관계는 한쪽에서 api를 제공하고 다른한쪽에서 api를 호출하는 관계임
  이러면 쓰는쪽이 주는쪽의 바운디드컨텍스트에 의존하게됨(상류/하류)
  이때 상류의 변경은 하류에 영향을 크게 주기떄문에,상류는 변경에 하류쪽을 신경써야함
  또한 하류는 상류서비스의 모델이 자신의 도메인모델에 영향을 주지않게 부패방지계층을 만들어야함
  
  두 바운디드컨텍스트가 같은 모델을 공유하는경우도 있는데,이건 공유커널이라고 부르고 중복설계를 막을수있음
  이거의 장점은 중복을 줄여주지만,단점은 한팀에서 임의로 모델을 변경할수없고,두팀이 밀접한관계여야함
  
  독립방식은 그냥 서로 통합하지않는방식임(마이웨이)
  이때의 두 바운디드컨텍스트간 통합은 수동으로 이뤄짐
  규모가 작을땐 괜찮은데,커지면 어케든 통합하긴해야함(아예 별도의 시스템을 만들수도있음)

*6.컨텍스트맵
  개별 바운디드컨텍스트에 매몰되면 전체를 보지못할때가 있음
  그래서 바운디드컨텍스트로 맵을 다이어그램으로 간단히 만들어두면 좋음
  이건 바운디드컨텍스트간 관계를 표시해둔 맵임
  이때 주요애그리거트를 함께 표시하면 모델에 대한 관계가 더 명확히 드러나고,
  오픈호스트서비스와 부패방지계층을 표시하고,하위 도메인등을 같이 표시하면 더 정보가 많아짐
  
  컨텍스트맵은 시스템의 전체구조를 보여줘서,하위도메인과 일치하지않는 바운디드컨텍스트를 찾아 도메인에 맞게 바운디드컨텍스트를 조절하고,
  핵심도메인을 위해 어떤 바운디드컨텍스트에 집중할지 파악하는데 도움을 줄수있음

10.이벤트
*1.시스템간 강결합 문제
  구매를 취소하면 환불을 처리해야하는데,이때 환불의 주체는 주문도메인 엔티티가 될수있고,응용서비스에서 환불을 할수도있음
  그런데 보통 결제시스템은 외부에 존재해서,외부의 결제시스템의 환불서비스를 호출하게됨
  이러면 외부가 정상이 아닐경우 트랜잭션처리가 애매해짐(특히 타임아웃,성공했을지 실패했을지 알수없어짐)
  또한 성능문제도 생기게됨
  
  추가적으로 도메인객체에 서비스를 전달하면 설계상문제(주문과 결제로직이 섞이는등)가 나타날수있음
  또한 기능을 추가할때 문제가 더 커지는데,이러면 로직이 섞이는문제가 더 커지고 트랜잭션처리가 더 복잡해짐(환불후 통지를 날리고싶을때 등)
  
  이런 문제들의 이유는 컨텍스트간 강결합때문임
  주문과 결제가 강결합되어있어서 영향을 받는것
  이걸 없애려면 이벤트를 사용해서 시스템간 결합도를 낮출수있음

*2.이벤트 개요
  이벤트란 과거에 벌어진 어떤것을 의미함
  이벤트가 발생했다는건 상태가 변경되었다는걸 의미하고,이벤트는 발생에서 끝나지않고 그 이벤트에 반응하여 원하는 동작을 수행하는 기능을 구현함
  
  도메인모델에서도 ui이벤트처럼 도메인의 상태변경과 관련된 요구사항을 이벤트를 이용해서 구현할수있음
  
  1.이벤트 관련 구성요소
    도메인모델에 이벤트를 도입하려면
      이벤트
	  이벤트생성주체
	  이벤트 디스패처(퍼블리셔)
	  이벤트 핸들러(구독자)
    이렇게 4가지를 구현해야함
    
    도메인모델에서 이벤트 생성주체는 엔티티,밸류,도메인서비스등 도메인객체임
    얘들은 도메인로직을 실행해서 상태가 바뀌면 관련이벤트를 발생시킴
    
    이벤트 핸들러는 이벤트생성주체가 발생한 이벤트에 반응해서,이벤트의 정보를 받아 원하는기능을 실행함
    
    이벤트 생성주체와 이벤트 핸들러를 연결해주는게 이벤트 디스패처임
    이벤트생성주체는 이벤트를 생성해서 디스패처에 전달하고,디스패처는 해당이벤트를 처리할수있는 핸들러에 이벤트를 전파함
    이 디스패처의 구현방식에 따라 이벤트생성과 처리를 동기나 비동기로 실행하게됨
    즉 카프카랑 같은방식(메시지큐가 이방식이니까..)
  2.이벤트의 구성
    이벤트는 발생한 이벤트에 대한 정보를 담음
	  이벤트종류:클래스명으로 이벤트종류를 표현
	  이벤트 발생시간
	  추가데이터:주문번호,배송지정보,전화번호등 이벤트와 관련된 정보
	보통 이런식으로 담게됨
	
	이벤트는 현재기준으로 과거에 벌어진것을 표현하기때문에 이벤트이름은 과거시제를(ex:Changed) 사용해야함
	또한 이벤트를 발생시키는 주체는 애그리거트고,애그리거트의 도메인기능을 사용한 후에 이벤트를 발생시키면됨
	
	또한 해당 이벤트를 처리하는 핸들러는,이벤트를 매개변수로 받아 필요한 작업을 수행하면됨
	이벤트는 이벤트 핸들러가 작업을 수행할때 필요한 정보를 담아야함
	이게 모자라면 db에서 직접 읽거나해야하기때문에 복잡도가 올라감(이걸 감수해야할때도 있긴함)
	
	이벤트는 데이터를 담아야하지만,이벤트와 관련없는 데이터를 포함할필요는 없음

  3.이벤트 용도
    이벤트는 크게 두가지용도로 사용됨
	하나는 트리거로,다른 후처리가 필요할때 후처리를 실행하기위한 트리거로 사용할수있음(주문취소후 이벤트를 발생시켜 환불트리거를 떙김)
	또 다른 용도는 서로 다른 시스템간 데이터 동기화가 있음,이건 바뀐 정보를 받아서 그걸가지고 정보를 서로 동기화시킬수있음

  4.이벤트 장점
    이벤트를 사용하면 서로 다른 도메인로직이 섞이는걸 방지할수있음
	즉 이벤트를 발생시키는 책임까지만 이벤트 발생도메인이 가져가고,후처리는 이벤트에 반응해서 기능을 실행하는 책임을 각각 가져가는것
	이러면 의존이 사라지고,또한 기능확장도 용이해짐(이벤트같이받으면되니까)
 
*3.이벤트,핸들러,디스패처 구현  
  스프링에서 이벤트를 구현할땐
    이벤트클래스:이벤트 표현클래스
	디스패처:스프링의 ApplicationEventPublisher을 사용할수있음
	Events:이벤트 발행,디스패처를 사용해 이벤트를 발행함
	이벤트 핸들러:이벤트를 수신해서 처리,스프링에서 기능제공
  이렇게 스프링에 의존하면됨
  이벤트 디스패처는 직접 구현할수도있긴함
  
  1.이벤트 클래스
    이벤트 자체를 위한 상위타입은 존재하지않음
	즉 원하는 클래스를 이벤트로 사용하면됨
	이벤트명은 과거시제를 사용해야한다는거만 유의하면되고,
	Event를 붙여서 명시적으로 표현(OrderCaceledEvent)해도되고,
	과거시제만 사용해도됨(OrderCaceled)
	
	이벤트클래스는 이벤트를 처리하는데 필요한 최소한의 데이터를 포함해야함
	또한 모든 이벤트가 공통적으로 갖는 프로퍼티가 있다면 상위클래스를 만들수도있음(발생시간등)

  2.Events클래스와 ApplicationEventPublisher
    이벤트 발생과 출판은 스프링이 제공하는 ApplicationEventPublisher를 사용할수있음
	
	Events는 직접 구현해야하는거지만,여기서 ApplicationEventPublisher를 사용해서 쉽게 이벤트구현을 만들수있음
	이건 그냥 이벤트 퍼블리셔를 생성자로 받아서,그걸사용해서 이벤트(오브젝트타입)를 발행하기만하면됨
	
	그리고 Events를 빈으로 등록해두면됨(315p)

  3.이벤트 발생과 이벤트 핸들러
    Events를 만들고,해당 클래스를 사용해서 이벤트를 발행하면됨
	
	이벤트를 처리할 핸들러는 스프링이 제공하는 @EventListener어노테이션으로 구현할수있음
	서비스로 구현한다음,메서드에 저 어노테이션을 붙이면 해당 이벤트가 발생하면 그걸 파라미터로 넣어서 실행해줌

  4.흐름정리
    즉
	  응용서비스에서 도메인기능 실행
	  도메인기능 실행 후 이벤트 발생
	  이벤트를 퍼블리셔에 공급
	  퍼블리셔는 이벤트를 핸들러로 전달
	  핸들러는 메서드 실행
	이런식으로 동작하게됨
	
	또한 이러면 도메인상태변경과 이벤트핸들러는 같은트랜잭션 범위에서 실행되게됨(응용서비스의 트랜잭션범위에 포함됨)
	  
4.동기이벤트 처리문제
  이벤트를 사용하면 강결합문제는 해결할수있지만,외부서비스에 영향을 받는 문제는 해결할수없음
  외부서비스가 느려지면 우리쪽 메서드로 느려짐(외부의 성능저하가 내 시스템의 성능저하로 이어짐)
  또한 트랜잭션도 문제가 되게됨
  점유갯수가 늘어나서 커넥션풀에 부담걸리고,익셉션 발생시 롤백을 해야될지 말지도 애매해짐
  
  이러면 일단 구매취소는 처리하고 환불만 재처리하거나,수동으로 처리할수있음
  
  이렇게 외부시스템과의 연동을 동기로 처리하면 성능과 트랜잭션범위문제가 생기는데,
  이걸 해소하려면 이벤트를 비동기로 처리하거나,이벤트와 트랜잭션을 연계할수있음

5.비동기 이벤트 처리

















  
  
  
  
  
  
  
  
  