1.도메인모델 시작하기
*1.도메인이란?
  소프트웨어의 대상은 필요로하는 기능을 제공해야함
  이때 해결하고자 하는 문제영역이 도메인에 해당하게됨
  
  한 도메인은 여러 하위도메인으로 나뉠수있음
  
*2.도메인전문가와 개발자간 지식공유
  개발자는 요구사항을 분석하고 설계해서 코드를 만듬
  이떄 요구사항은 첫단추라서,요구사항을 잘못 분석하면 엉뚱한 기능을 만들게됨
  
  즉 코딩에 앞서 요구사항을 올바르게 이해하는게 제일 중요함
  이때 가장 간단한 방법은 개발자와 전문가가 직접 대화하는것
  
  개발자와 이해관계자,도메인전문가가 같은 지식을 공유하고 직접 소통할수록 도메인전문가가 원하는 제품을 만들 가능성이 높아짐
  단,도메인전문가라고해서 항상 올바른 요구사항을 주는게 아님
  도메인전문가가 말하는 기능을 듣고,왜 필요한지까지 듣고나서 더 합리적인 방향이 있다면 제안하는것도 좋음
  
*3.도메인모델
  도메인모델은 특정 도메인을 개념적으로 표현한것
  도메인모델을 사용하면 여러 관계자들이 동일한모습으로 도메인을 이해하고 지식을 공유할수있음
  
  도메인모델은 객체로만 만들어야하는건 아님,그냥 상태전이로 모델링할수도있음
  근데 객체가 제일 쓰기 편하긴함
  
  도메인모델은 도메인 자체를 이해하기위한개념모델이라,구현할땐 구현기술에 맞는 구현모델이 따로 필요함
  이때 구현모델이 개념모델을 최대한 따르게 하는게 좋은데,그래서 객체모델로 개념모델을 잡으면 편하긴함(물론 개념모델은 트랜잭션등의 고려가 없어서 직접꽂을순없음)
  
*4.도메인모델 패턴
  도메인계층은 도메인의 핵심규칙을 구현함(서비스레이어 밑의 도메인층)
  도메인규칙을 객체지향기법으로 구현하는게 도메인모델패턴임
  
  이때 도메인로직을 위치시킬때,해당 객체가 그일을 가장 잘 처리할수있는 지식이 있는곳에 두는게 좋음
  다떠나서 도메인모델에만 핵심로직이 있다는게 변경시 영향을 덜줄수있어서 좋음
    
*5.도메인모델 도출
  도메인을 모델링할때 기본이 되는 작업은,핵심구성요소,규칙,기능을 찾는것
  이건 요구사항에서 출발함
  
  요구사항을 가지고 상세구현을 할순없지만,관련기능을 해당객체에 메서드로 추가할순있음
  또한 해당 요구사항에서 필요한 정보들을 필드로 추가할수있음
  또한 제약조건을 가지고 메서드에 예외처리를 하는식으로 도메인규칙을 구현할수있음
  
  이런식으로 일부는 구현수준까지,일부는 이름정도만 결정한후 이걸 공유해서 논의하면됨
  
*6.엔티티와 밸류
  모델은 크게 엔티티와 밸류로 구분할수있음
  1.엔티티
    엔티티의 가장 큰 특징은 식별자를 가진다는것
	식별자는 엔티티객체를 통틀어 고유해서,각 엔티티는 서로 다른 식별자를 가짐
	이 식별자는 절대 변하지않음(엔티티를 삭제하기전까지)
	
	그래서 엔티티의 식별자가 같다면 같은 엔티티라고 볼수있음(equal,hashcode 오버라이드로 바꿀수있음)

  2.엔티티 식별자 생성
    식별자생성시점은 도메인특징과 사용기술에 따라 달라짐
	보통
	  특정규칙에 따라 생성(주문번호등)
	  uuid사용
	  값을 직접 입력
	  오토인크리즈 사용
	인데,자연키보단 인조키를 보통 선호해서 uuid나 오토인크리즈를 사용하는편임
	
	오토인크리즈를 제외한 나머지방식은 식별자를 먼저 만들고 엔티티객체를 생성하고,오토인크리즈는 db에 넣기전까진 -1이나 0같은 대체를 사용함

  3.밸류타입
    밸류타입은 그 자체로 식별할수없는,개념적으로 완전한 하나를 나타내는 필드들의 집합을 만들때 사용됨
	그냥 이름을 붙이기위해 밸류타입을 사용해서 필드하나를 감싸는경우도 있음
	또한 밸류타입을 사용하면,해당 타입만을 위한 기능을 최소범위로 노출하며 추가할수있음
	
	또한 밸류타입의 데이터를 변경할땐,기존데이터 변경보단 불변으로 취급하고 새 데이터를 만드는게 선호됨(참조투명성)

  4.엔티티식별자와 밸류타입
    엔티티식별자가 자연키인경우,그대로 사용하기보단 밸류타입을 만들어두는게 좋음

  5.도메인모델에 set넣지않기
    set은 반드시 필요한 필드에만 노출하고,그것도 한번 추상화를 거쳐서 추가하는게 좋음
	받을값은 생성자로 다 받아서 처리하는게 좋음
	
	또한 객체내부에서만 사용할목적의 set이라면 private로 설정
  
  
*7.도메인용어와 유비쿼터스 언어
  코드를 사용할때 도메인에서 사용하는용어는 매우 중요함
  이걸 반영하지않으면 코드의 의미를 해석해야하는 부담을 개발자에게 주게됨
  step1,step2를 결제대기중,상품준비중으로 바꾸면 해석하지않고 그대로 보면되니까(보통 이럴떄 enum을 사용함)
  
  또한 시간이 지날수록 도메인에 대한 이해가 높아지는데,이때 새롭게 이해한 내용을 잘 표현할수있는 용어를 찾아내고,이를 다시 공통의 언어로 만들어 다같이 사용하면됨
  이런 언어들은 기존 코드나 문서에도 반영해야함
  
2.아키텍처 개요 
*1.네개의 영역
  표현영역은 컨트롤러,즉 요청을 받아서 밑에 내리고,응답을 받아 다시 전달하는 역할을 함
  
  응용영역은 표현영역으로 부터 받은 요청에 대한 기능을 큰단위로 가지고있음
  응용영역은 기능을 구현하기위해 도메인영역의 도메인모델을 사용함,즉 직접 로직을 수행하기보단,도메인모델에 로직수행을 위임함
  
  도메인영역은 도메인모델을 구현함
  도메인모델은 도메인의 핵심로직을 구현함
  
  인프라영역은 구현기술에 대한 모든것(db,메일,restapi호출등)을 다룸
  인프라영역을 제외한 다른 영역들은 구현기술을 사용한 코드를 직접 만들지않고,인프라가 제공하는 기능을 사용해서 필요한기능을 개발함
  
*2.계층구조 아키텍처  
  보통은 4영역으로 나누고,도메인과 응용을 간단한경우 합치기도 하지만 보통 이구조를 따름
  핵심은 상위에서 하위로만 의존하고,하위는 상위를 의존하지않는것
  
  또한 엄격하게하면 바로 직전의 계층만 의존해야하지만,구현의 편리함을 위해 유연하게 적용하기도함
  
  문제는 표현,응용,도메인계층이 상세한 구현기술을 다루는 인프라계층에 종속된다는것
  이러면 상위계층의 테스트가 어려워지고,구현방식을 변경하기 어려워짐
  그래서 사용되는게 dip

*3.dip
  고수준모듈이 저수준에 직접적으로 의존하게된다면 구현변경과 테스트가 어려워짐
  그래서 저수준이 고수준에 의존하게하는게 dip임
  
  이건 추상화된 인터페이스를 사이에 두고,고수준 모듈이 이걸 소유하게해서 인터페이스의 변경을 통제하는거임
  이러면 인터페이스만 만족한다면 저수준도 알아서 구현하면되고,고수준도 딱 그정도만 기대하고 약의존하면됨
  
  그리고 테스트할땐 모킹객체를 사용해서 저수준을 대체해버리면됨
  
  주의점은,단순한 인터페이스와 구현클래스를 분리하는게 아니라,상위층으로 소유권을 넘기는게 핵심이라 인터페이스는 고수준모듈이 가지고있어야함
  즉 논리적으로 보면,도메인계층이 필요로해서 인터페이스를 만들고,이걸 하위계층에서 구현하는식으로 가는게 맞는거임
  
  또한 dip를 항상 적용할필요는 없고,구현기술에 의존적인 코드를 도메인에 포함하는게 효과적인경우도 있고,추상화대상이 잘 떠오르지않는경우도 있음
  이럴땐 dip의 이점을 얻는수준에서 적용범위를 검토해보면됨
  
*4.도메인영역의 구성요소 
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  