1.도메인모델 시작하기
*1.도메인이란?
  소프트웨어의 대상은 필요로하는 기능을 제공해야함
  이때 해결하고자 하는 문제영역이 도메인에 해당하게됨
  
  한 도메인은 여러 하위도메인으로 나뉠수있음
  
*2.도메인전문가와 개발자간 지식공유
  개발자는 요구사항을 분석하고 설계해서 코드를 만듬
  이떄 요구사항은 첫단추라서,요구사항을 잘못 분석하면 엉뚱한 기능을 만들게됨
  
  즉 코딩에 앞서 요구사항을 올바르게 이해하는게 제일 중요함
  이때 가장 간단한 방법은 개발자와 전문가가 직접 대화하는것
  
  개발자와 이해관계자,도메인전문가가 같은 지식을 공유하고 직접 소통할수록 도메인전문가가 원하는 제품을 만들 가능성이 높아짐
  단,도메인전문가라고해서 항상 올바른 요구사항을 주는게 아님
  도메인전문가가 말하는 기능을 듣고,왜 필요한지까지 듣고나서 더 합리적인 방향이 있다면 제안하는것도 좋음
  
*3.도메인모델
  도메인모델은 특정 도메인을 개념적으로 표현한것
  도메인모델을 사용하면 여러 관계자들이 동일한모습으로 도메인을 이해하고 지식을 공유할수있음
  
  도메인모델은 객체로만 만들어야하는건 아님,그냥 상태전이로 모델링할수도있음
  근데 객체가 제일 쓰기 편하긴함
  
  도메인모델은 도메인 자체를 이해하기위한개념모델이라,구현할땐 구현기술에 맞는 구현모델이 따로 필요함
  이때 구현모델이 개념모델을 최대한 따르게 하는게 좋은데,그래서 객체모델로 개념모델을 잡으면 편하긴함(물론 개념모델은 트랜잭션등의 고려가 없어서 직접꽂을순없음)
  
*4.도메인모델 패턴
  도메인계층은 도메인의 핵심규칙을 구현함(서비스레이어 밑의 도메인층)
  도메인규칙을 객체지향기법으로 구현하는게 도메인모델패턴임
  
  이때 도메인로직을 위치시킬때,해당 객체가 그일을 가장 잘 처리할수있는 지식이 있는곳에 두는게 좋음
  다떠나서 도메인모델에만 핵심로직이 있다는게 변경시 영향을 덜줄수있어서 좋음
    
*5.도메인모델 도출
  도메인을 모델링할때 기본이 되는 작업은,핵심구성요소,규칙,기능을 찾는것
  이건 요구사항에서 출발함
  
  요구사항을 가지고 상세구현을 할순없지만,관련기능을 해당객체에 메서드로 추가할순있음
  또한 해당 요구사항에서 필요한 정보들을 필드로 추가할수있음
  또한 제약조건을 가지고 메서드에 예외처리를 하는식으로 도메인규칙을 구현할수있음
  
  이런식으로 일부는 구현수준까지,일부는 이름정도만 결정한후 이걸 공유해서 논의하면됨
  
*6.엔티티와 밸류
  모델은 크게 엔티티와 밸류로 구분할수있음
  1.엔티티
    엔티티의 가장 큰 특징은 식별자를 가진다는것
	식별자는 엔티티객체를 통틀어 고유해서,각 엔티티는 서로 다른 식별자를 가짐
	이 식별자는 절대 변하지않음(엔티티를 삭제하기전까지)
	
	그래서 엔티티의 식별자가 같다면 같은 엔티티라고 볼수있음(equal,hashcode 오버라이드로 바꿀수있음)

  2.엔티티 식별자 생성
    식별자생성시점은 도메인특징과 사용기술에 따라 달라짐
	보통
	  특정규칙에 따라 생성(주문번호등)
	  uuid사용
	  값을 직접 입력
	  오토인크리즈 사용
	인데,자연키보단 인조키를 보통 선호해서 uuid나 오토인크리즈를 사용하는편임
	
	오토인크리즈를 제외한 나머지방식은 식별자를 먼저 만들고 엔티티객체를 생성하고,오토인크리즈는 db에 넣기전까진 -1이나 0같은 대체를 사용함

  3.밸류타입
    밸류타입은 그 자체로 식별할수없는,개념적으로 완전한 하나를 나타내는 필드들의 집합을 만들때 사용됨
	그냥 이름을 붙이기위해 밸류타입을 사용해서 필드하나를 감싸는경우도 있음
	또한 밸류타입을 사용하면,해당 타입만을 위한 기능을 최소범위로 노출하며 추가할수있음
	
	또한 밸류타입의 데이터를 변경할땐,기존데이터 변경보단 불변으로 취급하고 새 데이터를 만드는게 선호됨(참조투명성)

  4.엔티티식별자와 밸류타입
    엔티티식별자가 자연키인경우,그대로 사용하기보단 밸류타입을 만들어두는게 좋음

  5.도메인모델에 set넣지않기
    set은 반드시 필요한 필드에만 노출하고,그것도 한번 추상화를 거쳐서 추가하는게 좋음
	받을값은 생성자로 다 받아서 처리하는게 좋음
	
	또한 객체내부에서만 사용할목적의 set이라면 private로 설정
  
  
*7.도메인용어와 유비쿼터스 언어
  코드를 사용할때 도메인에서 사용하는용어는 매우 중요함
  이걸 반영하지않으면 코드의 의미를 해석해야하는 부담을 개발자에게 주게됨
  step1,step2를 결제대기중,상품준비중으로 바꾸면 해석하지않고 그대로 보면되니까(보통 이럴떄 enum을 사용함)
  
  또한 시간이 지날수록 도메인에 대한 이해가 높아지는데,이때 새롭게 이해한 내용을 잘 표현할수있는 용어를 찾아내고,이를 다시 공통의 언어로 만들어 다같이 사용하면됨
  이런 언어들은 기존 코드나 문서에도 반영해야함
  
2.아키텍처 개요 
*1.네개의 영역
  표현영역은 컨트롤러,즉 요청을 받아서 밑에 내리고,응답을 받아 다시 전달하는 역할을 함
  
  응용영역은 표현영역으로 부터 받은 요청에 대한 기능을 큰단위로 가지고있음
  응용영역은 기능을 구현하기위해 도메인영역의 도메인모델을 사용함,즉 직접 로직을 수행하기보단,도메인모델에 로직수행을 위임함
  
  도메인영역은 도메인모델을 구현함
  도메인모델은 도메인의 핵심로직을 구현함
  
  인프라영역은 구현기술에 대한 모든것(db,메일,restapi호출등)을 다룸
  인프라영역을 제외한 다른 영역들은 구현기술을 사용한 코드를 직접 만들지않고,인프라가 제공하는 기능을 사용해서 필요한기능을 개발함
  
*2.계층구조 아키텍처  
  보통은 4영역으로 나누고,도메인과 응용을 간단한경우 합치기도 하지만 보통 이구조를 따름
  핵심은 상위에서 하위로만 의존하고,하위는 상위를 의존하지않는것
  
  또한 엄격하게하면 바로 직전의 계층만 의존해야하지만,구현의 편리함을 위해 유연하게 적용하기도함
  
  문제는 표현,응용,도메인계층이 상세한 구현기술을 다루는 인프라계층에 종속된다는것
  이러면 상위계층의 테스트가 어려워지고,구현방식을 변경하기 어려워짐
  그래서 사용되는게 dip

*3.dip
  고수준모듈이 저수준에 직접적으로 의존하게된다면 구현변경과 테스트가 어려워짐
  그래서 저수준이 고수준에 의존하게하는게 dip임
  
  이건 추상화된 인터페이스를 사이에 두고,고수준 모듈이 이걸 소유하게해서 인터페이스의 변경을 통제하는거임
  이러면 인터페이스만 만족한다면 저수준도 알아서 구현하면되고,고수준도 딱 그정도만 기대하고 약의존하면됨
  
  그리고 테스트할땐 모킹객체를 사용해서 저수준을 대체해버리면됨
  
  주의점은,단순한 인터페이스와 구현클래스를 분리하는게 아니라,상위층으로 소유권을 넘기는게 핵심이라 인터페이스는 고수준모듈이 가지고있어야함
  즉 논리적으로 보면,도메인계층이 필요로해서 인터페이스를 만들고,이걸 하위계층에서 구현하는식으로 가는게 맞는거임
  
  또한 dip를 항상 적용할필요는 없고,구현기술에 의존적인 코드를 도메인에 포함하는게 효과적인경우도 있고,추상화대상이 잘 떠오르지않는경우도 있음
  이럴땐 dip의 이점을 얻는수준에서 적용범위를 검토해보면됨
  
*4.도메인영역의 구성요소 
  도메인영역을 구성하는 요소는
    엔티티:고유식별자를 갖는 객체,도메인의 고유한개념을 표현하고 데이터와 기능을 함께 제공함
	밸류:식별자가 없는 객체,개념적으로 하나인값을 표현할때 사용,엔티티의 속성(필드)로써 보통 사용되고,다른 밸류타입의 속성으로써도 사용됨
	애그리거트:연관된 엔티티와 밸류들을 개념적으로 하나로 묶은것
	리포지터리:도메인모델의 영속성을 처리
	도메인서비스:특정 엔티티에 속하지않는 도메인로직을 제공(도메인에 속하기 애매한로직들)
  이 있음
  
  1.엔티티와 밸류
    db테이블의 엔티티와 도메인모델의 엔티티는 같은게 아님
	이 둘의 가장 큰 차이점은,도메인의 엔티티는 데이터와 도메인기능을 함께 제공한다는것
	즉 데이터를 담고있는 데이터구조라기보단,데이터와 함께 기능을 제공하는 객체임(캡슐화)
	
	또한,두개이상의 데이터가 개념적으로 하나인경우엔 밸류타입으로 묶을수있다는게 차이점임
	db에선 이렇게 하기가 힘듬
	
	밸류는 불변으로 구현하는게 좋고,그래서 밸류를 교체할땐 객체자체를 완전히 교체한다는걸 의미함

  2.애그리거트
    도메인이 커지면 많은 엔티티와 밸류가 출현함
	이경우엔 개발자가 전체구조가 아닌 한 엔티티와 밸류에 집중하게되는데,이러면 상위수준이 아닌 개별요소에만 초점을 맞추게돼서 큰수준에서 모델을 이해하기힘들어짐
	이때 도움이되는게 애그리거트임
	
	애그리거트는 관련객체들을 하나로 묶은 군집이고,이걸 사용하면 개별객체가 아닌 관련객체를 묶어서 객체군집단위로 모델을 바라볼수있어짐
	또한 개별객체간의 관계가 아닌 애그리거트간의 관계로 도메인모델을 이해하고 구현하게되고,이를통해 도메인모델을 관리할수있음

	애그리거트는 군집에 속한 객체들을 관리하는 루트엔티티를 갖고,얘를통해서 애그리거트가 구현해야할 기능을 제공함(퍼사드같은느낌)
	루트엔티티는 애그리거트에 속해있는 엔티티와 밸류로 구현할 기능들을 구현함
	즉 루트엔티티를 통해 간접적으로 다른 엔티티에 접근하는식임(캡슐화)
	루트엔티티를 거치지않고 다른 엔티티를 접근할수없게 만드는게 핵심임
	
	애그리거트를 구현할땐 고려해야할게 많은데,이거때문에 구현이 복잡해지기도,트랜잭션범위가 달라지기도 하고,
	선택구현기술에 따라 애그리거트 구현에 제약이 생기기도함

  3.리포지터리
    도메인객체를 지속적으로 사용하려면 어딘가에 저장해야하는데,이때 필요한 도메인모델이 리포지터리임
	리포지터리는 애그리거트 단위로 도메인객체를 저장하고 조회함
	
	이떄 핵심은 루트단위로 저장한다는것(루트는 모든객체를 포함하고있으니까)
	
	응용서비스는 의존성주입등으로 실제 리포지터리 구현객체를 가져오는데,
	응용서비스와 리포지터리는 밀접한 연관이 있음
	  응용서비스가 필요한 도메인객체를 구하거나 저장할떄 리포지터리를 사용
	  응용서비스가 트랜잭션을 관리할때 트랜잭션처리는 리포지터리구현기술의 영향을 받음
	리포지터리를 사용하는 주체가 응용서비스라서,리포지터리는 얘들이 필요로하는 메서드를 제공함
	이때 애그리거트를 저장하는 메서드와 애그리거트 루트로 애그리거트를 조회하는 메서드가 기본이 됨(save,findById)
  
*5.요청 처리 흐름
  표현영역은 요청의 데이터형식이 올바른지 검사하고 응용층에 실행을 위임
  이때 데이터를 응용서비스가 필요로하는 형식으로 변환해서 전달해야함(dto)
  
  응용서비스는 도메인모델을 이용해서 기능을 구현
  기능구현에 필요한 도메인객체를 리포지터리에서 가져와 실행하거나,신규 도메인객체를 생성해서 리포지터리에 저장함
  
  또한 예매등 변경이 필요한경우 트랜잭션을 관리해야함(@Transactional)
  
*6.인프라스트럭처 개요
  인프라층은 표현,응용,도메인영역을 지원함
  얘는 영속성처리,rest클라이언트호출등 다른영역에서 필요로하는 구현기술등을 지원함
  
  도메인영역와 응용영역에서는 인프라층을 직접 사용하는것보다 인터페이스를 통해(dip)사용하는게 테스트가 편하고 유연해짐
  
  그렇지만 무조건 인프라층에 대한 의존을 없앨필요는 없음
  응용층의 @Transactional은 쓰는게 더 편하고,JPA를 쓸땐 @Entity등을 도메인모델에 붙이는게 훨 편함
  
  구현의 편리함은 dip가 주는 강점만큼이나 중요하고,dip의 강점을 해치지않는범위에선 구현기술에 대한 의존을 해도됨
  
  
*7.모듈 구성
  아키텍처의 각 영역은 별도 패키지에 위치함
  패키지 구성에 정답이 존재하는건 아니지만,ui,application,domain,infra로 폴더를 나눠서 쓰면됨
  좀 커진다 싶으면,도메인별로 각각 ui,application,domain,infra로 폴더를 나눠서 쓰면됨
  
  또한 도메인은 도메인에 속한 애그리거트를 기준으로 다시 패키지를 구성함(도메인폴더내에 각 폴더가 애그리거트임)
  애그리거트와 도메인모델,리포지터리는 같은패키지에 위치해야함
  
  도메인이 복잡하면 도메인모델과 도메인서비스를 별도패키지에 위치시킬수도있음
  응용서비스도 도메인별로 패키지를 구분할수있음
  
  대충 한 패키지에 가능하면 타입이 10~15개정도로 유지하는게 좋고,이걸 넘어가면 패키지를 분리하는 시도를 해보는게좋음
  
  
3.애그리거트  
*1.애그리거트
  애그리거트는 도메인객체들을 상위수준에서 묶어둔거임
  이러면 주요도메인간의 관계를 파악하기 쉬워지고,코드를 변경하고 확장하는게 좀 더 쉬워짐
  상위수준에서 모델이 어떻게 엮여있는지를 알아야 전체모델을 망가뜨리지않으면서 추가요구사항을 모델에 반영할수있기때문
  세부적인모델만 이해하면 코드를 수정하는게 꺼려지고,코드변경을 최대한 피하고싶어짐
  
  이럴때 사용하는 방법이 애그리거트임
  애그리거트는 객체들을 하나의 군으로 묶어서,상위수준에서 도메인모델간의 관계를 파악할수있게해줌
  애그리거트는 모델을 이해하는데도 도움을 주지만,일관성을 관리하는 기준도 됨
  그래서 복잡한 도메인을 단순한구조로 만들어줌,그래서 확장과 변경에 필요한 노력도 줄여줌
  
  애그리거트는 관련된 모델을 하나로 모았기때문에,한 애그리거트에 속한 객체는 유사하거나 동일한 라이프사이클을 가짐
  대부분 한 애그리거트에 속하는 애들은 함께 생성되고,함께 소멸함
  
  한 애그리거트에 속하는 객체는 다른애그리거트에 속하지않고,각 애그리거트는 자신을 관리할뿐 다른애그리거트를 관리하지않음
  즉 주문애그리거트는 배송지를 변경하거나 주문상품갯수는 변경할수있지만,회원비밀번호나 상품가격은 변경하지못함
  
  경계의 기본은 도메인규칙과 요구사항임
  도메인규칙에 따라 함께 생성되는 구성요소는 한 애그리거트에 속할 가능성이 높음
  단,a는 b를 갖는다 이런건 반드시 한 애그리거트에 속한다고 보장할순없음(상품과 리뷰처럼)
  보통 생성시기가 같고,생성주체가 같을때 속할지말지를 보면될거임
  
  보통 대부분의 애그리거트는 엔티티객체 하나만을 가지고,두개이상의 엔티티로 구성되는 애그리거트는 드뭄
  
*2.애그리거트 루트
  애그리거트 루트는 애그리거트 전체를 관리하는 주체고,이걸 루트엔티티라고도 부름
  애그리거트에 속하는 모든 객체는 애그리거트 루트엔티티에 직접,또는 간접적으로 속하게됨
  
  1.도메인규칙과 일관성
    애그리거트 루트가 단순히 애그리거트에 속한 객체를 포함하는걸로 끝나는게 아님
	얘의 핵심은 애그리거트의 일관성이 깨지지않도록 하는것
	
	모든 애그리거트를 조작,조회하는 모든 행위는 루트애그리거트를 통해서 일어나야함,절대 세부애그리거트로 직접접근할수없음
	이러면 상태확인로직들의 응집도도 올라가고,중복구현도 막을수있음
	이때 가장 필수로 들여야하는 습관은
	  단순히 필드를 변경하는 set은 퍼블릭으로 만들지않는다
	  밸류타입은 불변으로 구현한다
	임
	
	추상화,캡슐화되지않은 set은 단순 필드변경일텐데 이러면 도메인의미나 의도를 표현하지못하고,도메인로직이 서비스쪽으로 분산되게됨
	이러면 응집도가 떨어지고,유지보수나 분석에 많은시간이 필요함
	
	이거의 연장으로 밸류타입은 불변으로 만들어야함
	밸류타입을 변경할수없으면,루트에서 밸류타입을 가져가도 변경할수없으니 일관성이 꺠질가능성이 줄어듬
	이러면 밸류타입을 변경하는방법은 통째로 바꾸는방법밖에 없어지니까(또한 변경자체로 루트를 통해서만 가능해짐)

  2.애그리거트 루트의 기능구현
    루트는 애그리거트 내부의 다른객체들을 조합해서 기능을 완성함
	총주문금액을 구하기위해 모든 주문이 담긴 OrderLine리스트를 사용하는식
	
	모든 루트가 구성요소의 상태만 참조하는건 아니고,구성요소에게 기능실행을 위임하기도함(가장 전문가에게 일을 시켜라)
	단,변경기능이 구성요소에 있을경우,외부로 나간 객체가 변경될수가 있음
	이러니 애초에 불변으로 만들어버리는게 좋음
	안된다면 변경기능을 패키지나 protected로 한정해서 외부에서 실행할수없게 제한하는 방법도 있음

  3.트랜잭션 범위
    트랜잭션범위는 작을수록 좋음
	한 테이블을 수정하면 충돌을 막기위해 한 테이블의 한행으로 잠그는 대상이 한정되지만,세개의 테이블을 수정하면 잠금대상이 더 많아짐
	이러면 동시에 처리할수있는 트랜잭션갯수가 줄어든다는걸 의미하고 처리량을 떨어트림
	
	동일하게 한 트랜잭션에서는 한 애그리거트만 수정해야함
	한 트랜잭션에서 두개이상의 애그리거트를 수정하면 트랜잭션충돌확률이 더 높아져서,처리량이 떨어짐
	
	한트랜잭션에서 한 애그리거트만 수정한다는건,애그리거트에서 다른애그리거트를 변경하지않는다는것
	즉 애그리거트내부에서 다른애그리거트의 상태를 변경하는 기능을 실행하지않는다는것
	즉 주문의 배송지정보를 변경하면서 동시에 배송지정보를 회원의 주소로 설정할땐,주문애그리거트는 회원애그리거트의 정보를 변경하면안됨
	안그러면 애그리거트가 자신의 책임범위를 넘어 다른애그리거트의 상태까지 관리하는게 되어버리기때문
	이러면 결합도가 높아짐
	
	부득이하게 한트랜잭션으로 두개이상의 애그리거트를 수정해야한다면,애그리거트에서 직접 수정하는게 아닌,서비스단에서 수정해야함
	
	즉 가급적이면 한트랜잭션에서 한 애그리거트를 변경하는걸 추천하지만,두개이상의 변경을 트랜잭션으로 묶어야할땐 서비스단에서 처리해야함
	
  
*3.리포지터리와 애그리거트
  애그리거트는 개념상 완전한 한개의 도메인모델을 표현하므로,객체의 영속성을 처리하는 리포지터리는 애그리거트 단위로 존재함
  즉 루트애그리거트만 리포지터리를 만들수있고,나머지들은 루트 리포지터리를 통해서 변경이 일어나야함
  
  리포지터리는 save와 findById가 기본적으로 있어야하고,필요에따라 다양한 검색,삭제,추가 메서드가 생길수있음
  
  또한 구현기술에 따라 애그리거트의 구현도 영향을 받음
  jpa를 사용하면 db관계형모델에 객체도메인모델을 맞춰야할수있고,
  어떤경우(레거시db등)는 밸류타입인 도메인모델을 @Component가 아닌 @Entity로 매핑해야할수도있음
  
  애그리거트는 개념적으로 하나이므로 리포지터리는 애그리거트 전체를 저장소에 영속화해야함
  또한 애그리거트를 구하는 레포지토리 메서드는 완전한 애그리거트 전체를 제공해야함(모든걸 포함하는 루트애그리거트를 제공해야함)
  즉 루트애그리거트만 찾아서 써도,npe가 안떠야함
  
  또한 애그리거트의 상태가 변경되면 모든 변경을 원자적으로 저장소에 반영해야함
  애그리거트에서 두개의 객체를 변경했는데,저장소에는 한객체에 대한 변경만 반영되면 일관성이 깨짐
  
*4.ID를 이용한 애그리거트 참조  
  한 객체가 다른 객체를 참조하는거처럼 애그리거트도 다른 애그리거트를 참조함
  이때 다른애그리거트라는건 다른 애그리거트루트를 참조한다는거임
  
  이건 필드로 쉽게 구현할수있음
  이렇게 다른애그리거트를 직접 접근하는건 구현이 편해지지만,캡슐화가 약해진다는 문제가 있음
  즉
    편한 탐색을 오용할수있음
	성능에 대한 문제
	확장이 어려움(강의존)
  이런 문제가 생김
  
  다른애그리거트의 상태를 직접 변경할수있으면 트랜잭션범위도 여러 애그리거트로 늘어나게되서 성능도 떨어지고,의존결합도도 올라가서 변경이 어려워짐
  또한 n+1같은 문제에 대해서도 고민을 해야하게되고,여러 다른종류의 db를 사용하고싶을떄도 머리아파짐
  
  그래서 id를 이용해서 간접적으로 다른애그리거트를 참조하면 이런문제가 완화됨
  이렇게 하면 모든 객체가 참조로 연결되지않고,한 애그리거트에 속한 객체만 참조로 연결됨
  그래서 애그리거트간 경계가 명확해지고,물리적 연결을 제거해서 복잡도가 낮아짐
  또한 애그리거트간 의존을 제거해서 응집도도 올려줌
  
  구현복잡도도 낮아짐,직접 다른 애그리거트를 참조하지않으니 지연로딩같은걸 신경쓰지않아도됨
  다른 애그리거트가 필요하면 서비스에서 id를 이용해서 로딩하면됨
  
  이러면 복잡도도 낮출수있고,한애그리거트에서 다른 애그리거트를 수정하는걸 근본적으로 방지할수있음(불가능하니까)
  또한 애그리거트별로 다른 구현기술을 사용할수도있음
  
  1.id를 이용한 참조와 조회성능
    다른애그리거트를 id로 참조하면 여러 애그리거트를 읽을때 조회속도가 문제될수있음(n+1)
	그래서 이런경우엔 조인을 사용해야함
	물론 객체참조방식으로 돌리는것도 있지만 그러면 의미가없고..
	
	이럴땐 조회전용쿼리를 만들면됨
	조회를 위한 별도의 레포지토리를 만들고,여기서 조인으로 한번의 쿼리로 필요한 데이터를 모두 로딩하면됨
	
	애그리거트마다 서로 다른 저장소를 사용하면 한쿼리로 모두 조회할수없는데,이떈 캐시나 조회전용저장소를 따로 구성해야함

*5.애그리거트간 집합연관
  애그리거트간 1-N연관이 있을땐
  set같은 컬렉션으로 표현할수있음
  그런데 개념적으로 존재하는 애그리거트간 1-N을 실제 구현에 반영하는게 요구사항과 상관없을떄가 있음
  이걸 그대로 구현하면 n+1이 되니까,이러면 그냥 N-1로 바꿔서(카테고리안에 상품이 있는게 아닌,상품이 카테고리를 가지는식)만드는게 나음 
  
  M-N연관도 실제 요구사항에 그게 필요할지를 고려하고 결정해야함
  개념적으로 양방향 연관이 존재하더라도,구현에서 단방향만 존재한다면 그거만 적용하면됨
  기본적으로 M-N은 조인테이블(중간테이블)이 필요함
  
*6.애그리거트를 팩토리로 사용
  애그리거트에서 처리가 가능한 로직은 가급적 응용서비스보단 애그리거트에 있는게 응집도측면에서 더 좋음
  특히 특정 애그리거트가 다른 애그리거트를 생성할때,생성이 가능한지를 판단하고 생성하는건 논리적으로 하나의 도메인기능이니 생성하는 애그리거트쪽에 있는게 맞음
  (ex.store가 product를 생성할때,금지된품목이면 생성하지않음)
  이 도메인기능을 넣기위한 별도의 도메인서비스나 팩토리클래스를 만들수도있지만,이걸 애그리거트(store)에 넣을수도있음
  
  이러면 팩토리역할을 하면서도 중요한 도메인로직을 구현할수있어짐
  응용서비스는 팩토리를 사용해서 생성하면되는거
  
  즉 애그리거트가 자신의 데이터를 이용해서 다른 애그리거트를 생성해야한다면,애그리거트에 팩토리메서드를 구현하는걸 고려해볼수있음
  또한 그 애그리거트의 정보량을 벗어난 정보가 필요하다면,직접 생성하지않고 다른팩토리에 위임하는 방법도 있음
  이렇게 위임을 하더라도 도메인로직(금지된 품목이면 생성하지않음)은 한곳에 모이게됨
  
4.리포지터리와 모델구현 
*1.JPA를 이용한 리포지터리 구현
  1.모듈위치
    리포지터리 인터페이스는 도메인영역에 속하고,리포지토리 구현체는 인프라영역에 속함
	그래서 서로간에 직접의존을 끊어내고 약의존해야함

  2.리포지터리 기본기능 구현
    리포지터리는 id로 애그리거트조회와 애그리거트 저장은 반드시 있어야하는 기본 기능임
	조회 인터페이스는 애그리거트 루트를 기준으로 작성하고,루트를 리턴하면됨
	또한 업데이트는 더티체킹으로 하니까 메서드가 없어도됨
  
*2.스프링 데이터 JPA를 이용한 리포지터리 구현
  스프링 데이터 jpa를 사용하면,규칙에 맞게 만들면 알아서 스프링빈으로 만들어줌
  그래서 인터페이스만 만들고 주입받으면됨
  
  또한 중첩프로퍼티(특정 필드객체안의 속성으로 조회)도 가능함
  
  
*3.매핑 구현 
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  