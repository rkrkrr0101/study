1.도메인모델 시작하기
*1.도메인이란?
  소프트웨어의 대상은 필요로하는 기능을 제공해야함
  이때 해결하고자 하는 문제영역이 도메인에 해당하게됨
  
  한 도메인은 여러 하위도메인으로 나뉠수있음
  
*2.도메인전문가와 개발자간 지식공유
  개발자는 요구사항을 분석하고 설계해서 코드를 만듬
  이떄 요구사항은 첫단추라서,요구사항을 잘못 분석하면 엉뚱한 기능을 만들게됨
  
  즉 코딩에 앞서 요구사항을 올바르게 이해하는게 제일 중요함
  이때 가장 간단한 방법은 개발자와 전문가가 직접 대화하는것
  
  개발자와 이해관계자,도메인전문가가 같은 지식을 공유하고 직접 소통할수록 도메인전문가가 원하는 제품을 만들 가능성이 높아짐
  단,도메인전문가라고해서 항상 올바른 요구사항을 주는게 아님
  도메인전문가가 말하는 기능을 듣고,왜 필요한지까지 듣고나서 더 합리적인 방향이 있다면 제안하는것도 좋음
  
*3.도메인모델
  도메인모델은 특정 도메인을 개념적으로 표현한것
  도메인모델을 사용하면 여러 관계자들이 동일한모습으로 도메인을 이해하고 지식을 공유할수있음
  
  도메인모델은 객체로만 만들어야하는건 아님,그냥 상태전이로 모델링할수도있음
  근데 객체가 제일 쓰기 편하긴함
  
  도메인모델은 도메인 자체를 이해하기위한개념모델이라,구현할땐 구현기술에 맞는 구현모델이 따로 필요함
  이때 구현모델이 개념모델을 최대한 따르게 하는게 좋은데,그래서 객체모델로 개념모델을 잡으면 편하긴함(물론 개념모델은 트랜잭션등의 고려가 없어서 직접꽂을순없음)
  
*4.도메인모델 패턴
  도메인계층은 도메인의 핵심규칙을 구현함(서비스레이어 밑의 도메인층)
  도메인규칙을 객체지향기법으로 구현하는게 도메인모델패턴임
  
  이때 도메인로직을 위치시킬때,해당 객체가 그일을 가장 잘 처리할수있는 지식이 있는곳에 두는게 좋음
  다떠나서 도메인모델에만 핵심로직이 있다는게 변경시 영향을 덜줄수있어서 좋음
    
*5.도메인모델 도출
  도메인을 모델링할때 기본이 되는 작업은,핵심구성요소,규칙,기능을 찾는것
  이건 요구사항에서 출발함
  
  요구사항을 가지고 상세구현을 할순없지만,관련기능을 해당객체에 메서드로 추가할순있음
  또한 해당 요구사항에서 필요한 정보들을 필드로 추가할수있음
  또한 제약조건을 가지고 메서드에 예외처리를 하는식으로 도메인규칙을 구현할수있음
  
  이런식으로 일부는 구현수준까지,일부는 이름정도만 결정한후 이걸 공유해서 논의하면됨
  
*6.엔티티와 밸류
  모델은 크게 엔티티와 밸류로 구분할수있음
  1.엔티티
    엔티티의 가장 큰 특징은 식별자를 가진다는것
	식별자는 엔티티객체를 통틀어 고유해서,각 엔티티는 서로 다른 식별자를 가짐
	이 식별자는 절대 변하지않음(엔티티를 삭제하기전까지)
	
	그래서 엔티티의 식별자가 같다면 같은 엔티티라고 볼수있음(equal,hashcode 오버라이드로 바꿀수있음)

  2.엔티티 식별자 생성
    식별자생성시점은 도메인특징과 사용기술에 따라 달라짐
	보통
	  특정규칙에 따라 생성(주문번호등)
	  uuid사용
	  값을 직접 입력
	  오토인크리즈 사용
	인데,자연키보단 인조키를 보통 선호해서 uuid나 오토인크리즈를 사용하는편임
	
	오토인크리즈를 제외한 나머지방식은 식별자를 먼저 만들고 엔티티객체를 생성하고,오토인크리즈는 db에 넣기전까진 -1이나 0같은 대체를 사용함

  3.밸류타입
    밸류타입은 그 자체로 식별할수없는,개념적으로 완전한 하나를 나타내는 필드들의 집합을 만들때 사용됨
	그냥 이름을 붙이기위해 밸류타입을 사용해서 필드하나를 감싸는경우도 있음
	또한 밸류타입을 사용하면,해당 타입만을 위한 기능을 최소범위로 노출하며 추가할수있음
	
	또한 밸류타입의 데이터를 변경할땐,기존데이터 변경보단 불변으로 취급하고 새 데이터를 만드는게 선호됨(참조투명성)

  4.엔티티식별자와 밸류타입
    엔티티식별자가 자연키인경우,그대로 사용하기보단 밸류타입을 만들어두는게 좋음

  5.도메인모델에 set넣지않기
    set은 반드시 필요한 필드에만 노출하고,그것도 한번 추상화를 거쳐서 추가하는게 좋음
	받을값은 생성자로 다 받아서 처리하는게 좋음
	
	또한 객체내부에서만 사용할목적의 set이라면 private로 설정
  
  
*7.도메인용어와 유비쿼터스 언어
  코드를 사용할때 도메인에서 사용하는용어는 매우 중요함
  이걸 반영하지않으면 코드의 의미를 해석해야하는 부담을 개발자에게 주게됨
  step1,step2를 결제대기중,상품준비중으로 바꾸면 해석하지않고 그대로 보면되니까(보통 이럴떄 enum을 사용함)
  
  또한 시간이 지날수록 도메인에 대한 이해가 높아지는데,이때 새롭게 이해한 내용을 잘 표현할수있는 용어를 찾아내고,이를 다시 공통의 언어로 만들어 다같이 사용하면됨
  이런 언어들은 기존 코드나 문서에도 반영해야함
  
2.아키텍처 개요 
*1.네개의 영역
  표현영역은 컨트롤러,즉 요청을 받아서 밑에 내리고,응답을 받아 다시 전달하는 역할을 함
  
  응용영역은 표현영역으로 부터 받은 요청에 대한 기능을 큰단위로 가지고있음
  응용영역은 기능을 구현하기위해 도메인영역의 도메인모델을 사용함,즉 직접 로직을 수행하기보단,도메인모델에 로직수행을 위임함
  
  도메인영역은 도메인모델을 구현함
  도메인모델은 도메인의 핵심로직을 구현함
  
  인프라영역은 구현기술에 대한 모든것(db,메일,restapi호출등)을 다룸
  인프라영역을 제외한 다른 영역들은 구현기술을 사용한 코드를 직접 만들지않고,인프라가 제공하는 기능을 사용해서 필요한기능을 개발함
  
*2.계층구조 아키텍처  
  보통은 4영역으로 나누고,도메인과 응용을 간단한경우 합치기도 하지만 보통 이구조를 따름
  핵심은 상위에서 하위로만 의존하고,하위는 상위를 의존하지않는것
  
  또한 엄격하게하면 바로 직전의 계층만 의존해야하지만,구현의 편리함을 위해 유연하게 적용하기도함
  
  문제는 표현,응용,도메인계층이 상세한 구현기술을 다루는 인프라계층에 종속된다는것
  이러면 상위계층의 테스트가 어려워지고,구현방식을 변경하기 어려워짐
  그래서 사용되는게 dip

*3.dip
  고수준모듈이 저수준에 직접적으로 의존하게된다면 구현변경과 테스트가 어려워짐
  그래서 저수준이 고수준에 의존하게하는게 dip임
  
  이건 추상화된 인터페이스를 사이에 두고,고수준 모듈이 이걸 소유하게해서 인터페이스의 변경을 통제하는거임
  이러면 인터페이스만 만족한다면 저수준도 알아서 구현하면되고,고수준도 딱 그정도만 기대하고 약의존하면됨
  
  그리고 테스트할땐 모킹객체를 사용해서 저수준을 대체해버리면됨
  
  주의점은,단순한 인터페이스와 구현클래스를 분리하는게 아니라,상위층으로 소유권을 넘기는게 핵심이라 인터페이스는 고수준모듈이 가지고있어야함
  즉 논리적으로 보면,도메인계층이 필요로해서 인터페이스를 만들고,이걸 하위계층에서 구현하는식으로 가는게 맞는거임
  
  또한 dip를 항상 적용할필요는 없고,구현기술에 의존적인 코드를 도메인에 포함하는게 효과적인경우도 있고,추상화대상이 잘 떠오르지않는경우도 있음
  이럴땐 dip의 이점을 얻는수준에서 적용범위를 검토해보면됨
  
*4.도메인영역의 구성요소 
  도메인영역을 구성하는 요소는
    엔티티:고유식별자를 갖는 객체,도메인의 고유한개념을 표현하고 데이터와 기능을 함께 제공함
	밸류:식별자가 없는 객체,개념적으로 하나인값을 표현할때 사용,엔티티의 속성(필드)로써 보통 사용되고,다른 밸류타입의 속성으로써도 사용됨
	애그리거트:연관된 엔티티와 밸류들을 개념적으로 하나로 묶은것
	리포지터리:도메인모델의 영속성을 처리
	도메인서비스:특정 엔티티에 속하지않는 도메인로직을 제공(도메인에 속하기 애매한로직들)
  이 있음
  
  1.엔티티와 밸류
    db테이블의 엔티티와 도메인모델의 엔티티는 같은게 아님
	이 둘의 가장 큰 차이점은,도메인의 엔티티는 데이터와 도메인기능을 함께 제공한다는것
	즉 데이터를 담고있는 데이터구조라기보단,데이터와 함께 기능을 제공하는 객체임(캡슐화)
	
	또한,두개이상의 데이터가 개념적으로 하나인경우엔 밸류타입으로 묶을수있다는게 차이점임
	db에선 이렇게 하기가 힘듬
	
	밸류는 불변으로 구현하는게 좋고,그래서 밸류를 교체할땐 객체자체를 완전히 교체한다는걸 의미함

  2.애그리거트
    도메인이 커지면 많은 엔티티와 밸류가 출현함
	이경우엔 개발자가 전체구조가 아닌 한 엔티티와 밸류에 집중하게되는데,이러면 상위수준이 아닌 개별요소에만 초점을 맞추게돼서 큰수준에서 모델을 이해하기힘들어짐
	이때 도움이되는게 애그리거트임
	
	애그리거트는 관련객체들을 하나로 묶은 군집이고,이걸 사용하면 개별객체가 아닌 관련객체를 묶어서 객체군집단위로 모델을 바라볼수있어짐
	또한 개별객체간의 관계가 아닌 애그리거트간의 관계로 도메인모델을 이해하고 구현하게되고,이를통해 도메인모델을 관리할수있음

	애그리거트는 군집에 속한 객체들을 관리하는 루트엔티티를 갖고,얘를통해서 애그리거트가 구현해야할 기능을 제공함(퍼사드같은느낌)
	루트엔티티는 애그리거트에 속해있는 엔티티와 밸류로 구현할 기능들을 구현함
	즉 루트엔티티를 통해 간접적으로 다른 엔티티에 접근하는식임(캡슐화)
	루트엔티티를 거치지않고 다른 엔티티를 접근할수없게 만드는게 핵심임
	
	애그리거트를 구현할땐 고려해야할게 많은데,이거때문에 구현이 복잡해지기도,트랜잭션범위가 달라지기도 하고,
	선택구현기술에 따라 애그리거트 구현에 제약이 생기기도함

  3.리포지터리
    도메인객체를 지속적으로 사용하려면 어딘가에 저장해야하는데,이때 필요한 도메인모델이 리포지터리임
	리포지터리는 애그리거트 단위로 도메인객체를 저장하고 조회함
	
	이떄 핵심은 루트단위로 저장한다는것(루트는 모든객체를 포함하고있으니까)
	
	응용서비스는 의존성주입등으로 실제 리포지터리 구현객체를 가져오는데,
	응용서비스와 리포지터리는 밀접한 연관이 있음
	  응용서비스가 필요한 도메인객체를 구하거나 저장할떄 리포지터리를 사용
	  응용서비스가 트랜잭션을 관리할때 트랜잭션처리는 리포지터리구현기술의 영향을 받음
	리포지터리를 사용하는 주체가 응용서비스라서,리포지터리는 얘들이 필요로하는 메서드를 제공함
	이때 애그리거트를 저장하는 메서드와 애그리거트 루트로 애그리거트를 조회하는 메서드가 기본이 됨(save,findById)
  
*5.요청 처리 흐름
  표현영역은 요청의 데이터형식이 올바른지 검사하고 응용층에 실행을 위임
  이때 데이터를 응용서비스가 필요로하는 형식으로 변환해서 전달해야함(dto)
  
  응용서비스는 도메인모델을 이용해서 기능을 구현
  기능구현에 필요한 도메인객체를 리포지터리에서 가져와 실행하거나,신규 도메인객체를 생성해서 리포지터리에 저장함
  
  또한 예매등 변경이 필요한경우 트랜잭션을 관리해야함(@Transactional)
  
*6.인프라스트럭처 개요
  인프라층은 표현,응용,도메인영역을 지원함
  얘는 영속성처리,rest클라이언트호출등 다른영역에서 필요로하는 구현기술등을 지원함
  
  도메인영역와 응용영역에서는 인프라층을 직접 사용하는것보다 인터페이스를 통해(dip)사용하는게 테스트가 편하고 유연해짐
  
  그렇지만 무조건 인프라층에 대한 의존을 없앨필요는 없음
  응용층의 @Transactional은 쓰는게 더 편하고,JPA를 쓸땐 @Entity등을 도메인모델에 붙이는게 훨 편함
  
  구현의 편리함은 dip가 주는 강점만큼이나 중요하고,dip의 강점을 해치지않는범위에선 구현기술에 대한 의존을 해도됨
  
  
*7.모듈 구성
  아키텍처의 각 영역은 별도 패키지에 위치함
  패키지 구성에 정답이 존재하는건 아니지만,ui,application,domain,infra로 폴더를 나눠서 쓰면됨
  좀 커진다 싶으면,도메인별로 각각 ui,application,domain,infra로 폴더를 나눠서 쓰면됨
  
  또한 도메인은 도메인에 속한 애그리거트를 기준으로 다시 패키지를 구성함(도메인폴더내에 각 폴더가 애그리거트임)
  애그리거트와 도메인모델,리포지터리는 같은패키지에 위치해야함
  
  도메인이 복잡하면 도메인모델과 도메인서비스를 별도패키지에 위치시킬수도있음
  응용서비스도 도메인별로 패키지를 구분할수있음
  
  대충 한 패키지에 가능하면 타입이 10~15개정도로 유지하는게 좋고,이걸 넘어가면 패키지를 분리하는 시도를 해보는게좋음
  
  
3.애그리거트  
*1.애그리거트
  애그리거트는 도메인객체들을 상위수준에서 묶어둔거임
  이러면 주요도메인간의 관계를 파악하기 쉬워지고,코드를 변경하고 확장하는게 좀 더 쉬워짐
  상위수준에서 모델이 어떻게 엮여있는지를 알아야 전체모델을 망가뜨리지않으면서 추가요구사항을 모델에 반영할수있기때문
  세부적인모델만 이해하면 코드를 수정하는게 꺼려지고,코드변경을 최대한 피하고싶어짐
  
  이럴때 사용하는 방법이 애그리거트임
  애그리거트는 객체들을 하나의 군으로 묶어서,상위수준에서 도메인모델간의 관계를 파악할수있게해줌
  애그리거트는 모델을 이해하는데도 도움을 주지만,일관성을 관리하는 기준도 됨
  그래서 복잡한 도메인을 단순한구조로 만들어줌,그래서 확장과 변경에 필요한 노력도 줄여줌
  
  애그리거트는 관련된 모델을 하나로 모았기때문에,한 애그리거트에 속한 객체는 유사하거나 동일한 라이프사이클을 가짐
  대부분 한 애그리거트에 속하는 애들은 함께 생성되고,함께 소멸함
  
  한 애그리거트에 속하는 객체는 다른애그리거트에 속하지않고,각 애그리거트는 자신을 관리할뿐 다른애그리거트를 관리하지않음
  즉 주문애그리거트는 배송지를 변경하거나 주문상품갯수는 변경할수있지만,회원비밀번호나 상품가격은 변경하지못함
  
  경계의 기본은 도메인규칙과 요구사항임
  도메인규칙에 따라 함께 생성되는 구성요소는 한 애그리거트에 속할 가능성이 높음
  단,a는 b를 갖는다 이런건 반드시 한 애그리거트에 속한다고 보장할순없음(상품과 리뷰처럼)
  보통 생성시기가 같고,생성주체가 같을때 속할지말지를 보면될거임
  
  보통 대부분의 애그리거트는 엔티티객체 하나만을 가지고,두개이상의 엔티티로 구성되는 애그리거트는 드뭄
  
*2.애그리거트 루트
  애그리거트 루트는 애그리거트 전체를 관리하는 주체고,이걸 루트엔티티라고도 부름
  애그리거트에 속하는 모든 객체는 애그리거트 루트엔티티에 직접,또는 간접적으로 속하게됨
  
  1.도메인규칙과 일관성
    애그리거트 루트가 단순히 애그리거트에 속한 객체를 포함하는걸로 끝나는게 아님
	얘의 핵심은 애그리거트의 일관성이 깨지지않도록 하는것
	
	모든 애그리거트를 조작,조회하는 모든 행위는 루트애그리거트를 통해서 일어나야함,절대 세부애그리거트로 직접접근할수없음
	이러면 상태확인로직들의 응집도도 올라가고,중복구현도 막을수있음
	이때 가장 필수로 들여야하는 습관은
	  단순히 필드를 변경하는 set은 퍼블릭으로 만들지않는다
	  밸류타입은 불변으로 구현한다
	임
	
	추상화,캡슐화되지않은 set은 단순 필드변경일텐데 이러면 도메인의미나 의도를 표현하지못하고,도메인로직이 서비스쪽으로 분산되게됨
	이러면 응집도가 떨어지고,유지보수나 분석에 많은시간이 필요함
	
	이거의 연장으로 밸류타입은 불변으로 만들어야함
	밸류타입을 변경할수없으면,루트에서 밸류타입을 가져가도 변경할수없으니 일관성이 꺠질가능성이 줄어듬
	이러면 밸류타입을 변경하는방법은 통째로 바꾸는방법밖에 없어지니까(또한 변경자체로 루트를 통해서만 가능해짐)

  2.애그리거트 루트의 기능구현
    루트는 애그리거트 내부의 다른객체들을 조합해서 기능을 완성함
	총주문금액을 구하기위해 모든 주문이 담긴 OrderLine리스트를 사용하는식
	
	모든 루트가 구성요소의 상태만 참조하는건 아니고,구성요소에게 기능실행을 위임하기도함(가장 전문가에게 일을 시켜라)
	단,변경기능이 구성요소에 있을경우,외부로 나간 객체가 변경될수가 있음
	이러니 애초에 불변으로 만들어버리는게 좋음
	안된다면 변경기능을 패키지나 protected로 한정해서 외부에서 실행할수없게 제한하는 방법도 있음

  3.트랜잭션 범위
    트랜잭션범위는 작을수록 좋음
	한 테이블을 수정하면 충돌을 막기위해 한 테이블의 한행으로 잠그는 대상이 한정되지만,세개의 테이블을 수정하면 잠금대상이 더 많아짐
	이러면 동시에 처리할수있는 트랜잭션갯수가 줄어든다는걸 의미하고 처리량을 떨어트림
	
	동일하게 한 트랜잭션에서는 한 애그리거트만 수정해야함
	한 트랜잭션에서 두개이상의 애그리거트를 수정하면 트랜잭션충돌확률이 더 높아져서,처리량이 떨어짐
	
	한트랜잭션에서 한 애그리거트만 수정한다는건,애그리거트에서 다른애그리거트를 변경하지않는다는것
	즉 애그리거트내부에서 다른애그리거트의 상태를 변경하는 기능을 실행하지않는다는것
	즉 주문의 배송지정보를 변경하면서 동시에 배송지정보를 회원의 주소로 설정할땐,주문애그리거트는 회원애그리거트의 정보를 변경하면안됨
	안그러면 애그리거트가 자신의 책임범위를 넘어 다른애그리거트의 상태까지 관리하는게 되어버리기때문
	이러면 결합도가 높아짐
	
	부득이하게 한트랜잭션으로 두개이상의 애그리거트를 수정해야한다면,애그리거트에서 직접 수정하는게 아닌,서비스단에서 수정해야함
	
	즉 가급적이면 한트랜잭션에서 한 애그리거트를 변경하는걸 추천하지만,두개이상의 변경을 트랜잭션으로 묶어야할땐 서비스단에서 처리해야함
	
  
*3.리포지터리와 애그리거트
  애그리거트는 개념상 완전한 한개의 도메인모델을 표현하므로,객체의 영속성을 처리하는 리포지터리는 애그리거트 단위로 존재함
  즉 루트애그리거트만 리포지터리를 만들수있고,나머지들은 루트 리포지터리를 통해서 변경이 일어나야함
  
  리포지터리는 save와 findById가 기본적으로 있어야하고,필요에따라 다양한 검색,삭제,추가 메서드가 생길수있음
  
  또한 구현기술에 따라 애그리거트의 구현도 영향을 받음
  jpa를 사용하면 db관계형모델에 객체도메인모델을 맞춰야할수있고,
  어떤경우(레거시db등)는 밸류타입인 도메인모델을 @Component가 아닌 @Entity로 매핑해야할수도있음
  
  애그리거트는 개념적으로 하나이므로 리포지터리는 애그리거트 전체를 저장소에 영속화해야함
  또한 애그리거트를 구하는 레포지토리 메서드는 완전한 애그리거트 전체를 제공해야함(모든걸 포함하는 루트애그리거트를 제공해야함)
  즉 루트애그리거트만 찾아서 써도,npe가 안떠야함
  
  또한 애그리거트의 상태가 변경되면 모든 변경을 원자적으로 저장소에 반영해야함
  애그리거트에서 두개의 객체를 변경했는데,저장소에는 한객체에 대한 변경만 반영되면 일관성이 깨짐
  
*4.ID를 이용한 애그리거트 참조  
  한 객체가 다른 객체를 참조하는거처럼 애그리거트도 다른 애그리거트를 참조함
  이때 다른애그리거트라는건 다른 애그리거트루트를 참조한다는거임
  
  이건 필드로 쉽게 구현할수있음
  이렇게 다른애그리거트를 직접 접근하는건 구현이 편해지지만,캡슐화가 약해진다는 문제가 있음
  즉
    편한 탐색을 오용할수있음
	성능에 대한 문제
	확장이 어려움(강의존)
  이런 문제가 생김
  
  다른애그리거트의 상태를 직접 변경할수있으면 트랜잭션범위도 여러 애그리거트로 늘어나게되서 성능도 떨어지고,의존결합도도 올라가서 변경이 어려워짐
  또한 n+1같은 문제에 대해서도 고민을 해야하게되고,여러 다른종류의 db를 사용하고싶을떄도 머리아파짐
  
  그래서 id를 이용해서 간접적으로 다른애그리거트를 참조하면 이런문제가 완화됨
  이렇게 하면 모든 객체가 참조로 연결되지않고,한 애그리거트에 속한 객체만 참조로 연결됨
  그래서 애그리거트간 경계가 명확해지고,물리적 연결을 제거해서 복잡도가 낮아짐
  또한 애그리거트간 의존을 제거해서 응집도도 올려줌
  
  구현복잡도도 낮아짐,직접 다른 애그리거트를 참조하지않으니 지연로딩같은걸 신경쓰지않아도됨
  다른 애그리거트가 필요하면 서비스에서 id를 이용해서 로딩하면됨
  
  이러면 복잡도도 낮출수있고,한애그리거트에서 다른 애그리거트를 수정하는걸 근본적으로 방지할수있음(불가능하니까)
  또한 애그리거트별로 다른 구현기술을 사용할수도있음
  
  1.id를 이용한 참조와 조회성능
    다른애그리거트를 id로 참조하면 여러 애그리거트를 읽을때 조회속도가 문제될수있음(n+1)
	그래서 이런경우엔 조인을 사용해야함
	물론 객체참조방식으로 돌리는것도 있지만 그러면 의미가없고..
	
	이럴땐 조회전용쿼리를 만들면됨
	조회를 위한 별도의 레포지토리를 만들고,여기서 조인으로 한번의 쿼리로 필요한 데이터를 모두 로딩하면됨
	
	애그리거트마다 서로 다른 저장소를 사용하면 한쿼리로 모두 조회할수없는데,이떈 캐시나 조회전용저장소를 따로 구성해야함

*5.애그리거트간 집합연관
  애그리거트간 1-N연관이 있을땐
  set같은 컬렉션으로 표현할수있음
  그런데 개념적으로 존재하는 애그리거트간 1-N을 실제 구현에 반영하는게 요구사항과 상관없을떄가 있음
  이걸 그대로 구현하면 n+1이 되니까,이러면 그냥 N-1로 바꿔서(카테고리안에 상품이 있는게 아닌,상품이 카테고리를 가지는식)만드는게 나음 
  
  M-N연관도 실제 요구사항에 그게 필요할지를 고려하고 결정해야함
  개념적으로 양방향 연관이 존재하더라도,구현에서 단방향만 존재한다면 그거만 적용하면됨
  기본적으로 M-N은 조인테이블(중간테이블)이 필요함
  
*6.애그리거트를 팩토리로 사용
  애그리거트에서 처리가 가능한 로직은 가급적 응용서비스보단 애그리거트에 있는게 응집도측면에서 더 좋음
  특히 특정 애그리거트가 다른 애그리거트를 생성할때,생성이 가능한지를 판단하고 생성하는건 논리적으로 하나의 도메인기능이니 생성하는 애그리거트쪽에 있는게 맞음
  (ex.store가 product를 생성할때,금지된품목이면 생성하지않음)
  이 도메인기능을 넣기위한 별도의 도메인서비스나 팩토리클래스를 만들수도있지만,이걸 애그리거트(store)에 넣을수도있음
  
  이러면 팩토리역할을 하면서도 중요한 도메인로직을 구현할수있어짐
  응용서비스는 팩토리를 사용해서 생성하면되는거
  
  즉 애그리거트가 자신의 데이터를 이용해서 다른 애그리거트를 생성해야한다면,애그리거트에 팩토리메서드를 구현하는걸 고려해볼수있음
  또한 그 애그리거트의 정보량을 벗어난 정보가 필요하다면,직접 생성하지않고 다른팩토리에 위임하는 방법도 있음
  이렇게 위임을 하더라도 도메인로직(금지된 품목이면 생성하지않음)은 한곳에 모이게됨
  
4.리포지터리와 모델구현 
*1.JPA를 이용한 리포지터리 구현
  1.모듈위치
    리포지터리 인터페이스는 도메인영역에 속하고,리포지토리 구현체는 인프라영역에 속함
	그래서 서로간에 직접의존을 끊어내고 약의존해야함

  2.리포지터리 기본기능 구현
    리포지터리는 id로 애그리거트조회와 애그리거트 저장은 반드시 있어야하는 기본 기능임
	조회 인터페이스는 애그리거트 루트를 기준으로 작성하고,루트를 리턴하면됨
	또한 업데이트는 더티체킹으로 하니까 메서드가 없어도됨
  
*2.스프링 데이터 JPA를 이용한 리포지터리 구현
  스프링 데이터 jpa를 사용하면,규칙에 맞게 만들면 알아서 스프링빈으로 만들어줌
  그래서 인터페이스만 만들고 주입받으면됨
  
  또한 중첩프로퍼티(특정 필드객체안의 속성으로 조회)도 가능함
  
  
*3.매핑 구현 
  1.엔티티와 밸류 기본 매핑
    엔티티는 @Entity로,
    밸류는 @Embeddable로 매핑을 설정하고,밸류타입 프로퍼티는 @Embedded로 매핑하면됨
  2.기본 생성자
    기본생성자는 불변타입이라면 필요없지만,jpa를 사용하면 있어야함,그래서 프로텍티드로 선언해두면 됨
  3.필드접근방식 사용
    엔티티가 객체로서 제역할을 하려면,필드공개가 아닌 의도가 잘 드러나는 기능(이름)으로 제공해야함

  4.AttributeConverter을 이용한 밸류 매핑 처리
    만약 여러 밸류타입프로퍼티를 한 칼럼에 매핑해야한다면(db의 한칼럼을 2개이상의 필드로 뽑아내야한다면) AttributeConverter을 사용할수있음
	또한 값을 특이하게 변환해서 저장하고,그걸 다시 특이하게 읽어와야할때도 사용됨(이게 주목적)
	이건 밸류타입과 칼럼데이터간의 변환을 처리하기위한 기능을 정의하고있음
	필요해지면 보자

  5.밸류컬렉션:별도테이블매핑
    컬렉션을 프로퍼티로 가져야하고,순서가 있다면 list로 컬렉션을 프로퍼티로 지정할수있음
	또한 컬렉션을 외부테이블로 매핑하려면
		@ElementCollection(fetch = FetchType.EAGER)
		@CollectionTable(name = “order_line”,
		joinColumns = @JoinColumn(name = “order_number”))
		@OrderColumn(name = “line_idx”)
		private List<OrderLine> orderLines;
	이런식으로 하면됨

  6.밸류컬렉션:한개 칼럼 매핑
    밸류컬렉션을 한개칼럼에 저장해야할땐(콤마구분),AttributeConverter를 사용할수있음
	
  7.밸류를 이용한 id매핑
    id도 클래스를 만들어서 표현할수있음
	이땐 @id대신 @EmbeddedId를 사용해야함
	또한 jpa에서 식별자타입은 serializable타입이어야함으로,이걸 상속받아야함
	이러면 식별자에 메서드를 추가할수있다는 장점이 있음

  8.별도 테이블에 저장하는 밸류 매핑
    애그리거트에서 루트를 뺀 나머지 구성요소는 대부분 밸류임
	다른 앤티티가 있다면 이게 진짜 엔티티인지 의심해봐야함(단지 별개의 테이블에 저장한다고 엔티티가 아님)
	
	그리고 앤티티가 확실하다면,그게 다른애그리거트가 아닌지도 확인해야함
	특히 자신만의 독자적인 라이프사이클을 갖는다면 구분되는 애그리거트일 가능성이 높음
	
	애그리거트에 속한 객체가 밸류인지 엔티티인지 구분하는건,고유식별자가 필요한지(단지 db에 저장하는 용도가 아닌 진짜로 필요한지)여부가 가장 확실함
	
	그리고 여러 테이블값을 한 밸류에 모을땐 @AttributeOverride와 @SecondaryTable를 사용하면됨

  9.밸류컬렉션을 @Entity로 매핑하기
    개념적으로 밸류인데 구현기술의 한계,팀표준등으로 @Entity로 매핑해야할수도 있음
	이떈 @Entity를 사용해서 상속매핑으로 처리해야함
	또한 상태를 변경하는 기능은 상위에서 가져가야하고,캐스케이드와 고아제거를 같이 넣으면 좋음

  10.id참조와 조인테이블을 이용한 단방향 M-N매핑
    만약 M-N매핑이 꼭 필요하다면,id참조를 이용해서 단방향 집합 연관을 적용해볼수있음
	이때 @ElementCollection을 사용하면됨
	id를 사용하면 영속성전파나 로딩전략등도 신경쓰지않아도됨
  
*4.애그리거트 로딩 전략 
  jpa 매핑에서 가장 중요한건 애그리거트에 속한 객체 모두 모여야 완전한 하나가 된다는것,
  즉 루트를 로딩하면 루트에 속한 모든객체가 이론상 완전한 하나여야한다는것
  
  그래서 jpa로딩 기본값이 EAGER인거임
  그런데 성능상의 이유로 이러면 n+1이 날수있음(특히 컬렉션 로딩할때 카타시안곱되면 큰일남)
  
  애그리거트는 개념적으론 하나여야하지만,루트엔티티를 로딩하는시점에 애그리거트에 속한 객체를 모두 로딩해야하는건 아님
  애그리거트가 완전해야하는 이유는
    상태를 변경할때 애그리거트가 완전해야함
	표현영역에서 애그리거트의 상태를 보여줄때 필요함(단 이건 별도의 조회전용기능과 모델을 구현하는게 나음)
  두가지 이유인데,이중 두번째는 다른방법이 있고,상태변경시 완전해야한다는게 더 관련성이 큼
  그런데 상태변경을 할때 꼭 조회시점에서 전부 들어차있어야할필요는 없어서 지연로딩을 하는거임(그리고 변경시점에 필요한걸 로딩해도됨)
  
  또한 보통은 상태변경보다 조회기능실행확률이 압도적으로 높기때문에,상태변경시의 지연로딩 추가쿼리로 인한 속도저하는 별로 문제가 되지않음
  
  지연로딩은 동작방식이 항상 동일해서 머리를 덜써도됨
  대신 쿼리실행횟수가 늘어날 가능성이 있긴함
  
*5.애그리거트의 영속성 전파
  애그리거트가 완전한 상태여야한다는건,루트를 조회할때만이 아니라 저장하거나 삭제할때도 하나로 처리해야함을 의미함
  즉
    저장메서드는 루트만 저장하면 안되고,애그리거트에 속한 모든 객체를 같이 저장해야함
	삭제메서드는 루트만 삭제하면 안되고,애그리거트에 속한 모든 객체를 삭제해야함
  임베딩 매핑타입(밸류)는 어짜피 같이 삭제되니 cascade를 추가설정하지않아도 되지만,애그리거트에 속한 엔티티는 캐스케이드를 설정해서 같이저장,같이삭제되어야함

*6.식별자 생성 기능
  식별자(id)는
    사용자가 직접 생성(이메일,아이디등)
	도메인로직으로 생성(uuid)
	db를 이용한 일련번호(오토인크리즈)사용
  3가지 방법으로 보통 생성함
  
  사용자가 직접 식별자를 입력하는건 생성주체가 사용자라서 별로 신경쓰지않아도 되지만,보통 이런 자연키보단 인조키를 사용하는편
  이게 아니라면 식별자생성규칙은 도메인규칙이므로 도메인영역에 식별자생성기능을 위치시켜야함
  응용서비스는 이걸 활용해서 식별자를 구하고 엔티티를 생성할수있음(아예 생성자에 박아도되긴함)
  
  아니면 리포지터리에서 식별자를 생성하는 메서드를 추가하거나,jpa를 의존할수도있음(오토인크리즈먼트)

*7.도메인 구현과 dip
  이론적으로는 도메인은 구현기술인 jpa를 의존하면 안됨(즉 @Entity등을 사용하면안됨)
  그런데 이렇게 하는 이유는,저수준 변경이 고수준에 영향을 주지않게 하기위함인데,리포지터리와 도메인 모델의 구현기술은 거의 바뀌지않음
  이렇게 변경이 거의 없는 상황에서 변경을 미리 대비하는건 과할수있고,이건 타협이 가능함
  
  그렇다고 이렇게한다고 테스트가 귀찮아지지도않음
  dip를 완벽하게 지키는것도 좋지만,편의와 실용성도 따져가면서 살아야함
  
  
5.스프링 데이터 JPA를 이용한 조회기능  
*1.시작에 앞서
  앞에서 본 모델(엔티티,애그리거트,리포지터리등)은 주문취소,배송지변경등 상태를 변경할때 주로 사용됨
  즉 도메인 모델은 명령모델로 주로 사용되고,
  정렬,페이징,검색조건지정등의 기능은 주문목록,상품상세같은 조회기능에 사용됨
  즉 조회모델과 명령모델은 분리하는게 CQRS패턴의 기본임

*2.검색을 위한 스펙
  검색조건이 다양하거나 동적조건이 필요하다면 필요한게 스펙임
  스펙은 애그리거트가 특정 조건을 만족하는지를 검사할떄 사용하는 인터페이스임
  이건 단순히 제네릭을 받고,현재 이게 만족하는지를 나타내는 메서드 하나만 있으면됨
  
  스펙을 리포지터리에 사용하면,제네릭은 애그리거트 루트가 되고,스펙을 dao(읽기전용레포)에 사용하면 제네릭은 검색결과로 리턴할 데이터객체가 됨
  그리고 메서드는 검사대상객체가 조건을 충족하면 true를,그렇지않으면 false를 리턴하는식으로 구현하면됨
  그래서 스펙구현체는 생성자로 필요한 정보를 받고,그걸가지고 메서드(제네릭)로 받은 객체를 비교하는식으로 하면됨
  
  스펙은 검색대상을 걸러내는용도로 사용됨(물론 메모리에 보관하고있을때)
  즉 특정조건을 충족하는 애그리거트를 찾고싶으면 원하는 스펙을 생성해서 리포지터리에 전달해주면됨
  물론 이건 비현실적이라서,보통은 스프링 데이터 JPA를 사용해서 스펙을 구현하게됨
  
*3.스프링 데이터 JPA를 이용한 스펙구현  
  스프링 데이터 JPA는 검색조건을 표현하기위한 인터페이스인 Specification이라는 스펙인터페이스를 제공함
  이것도 위에 스펙과 비슷하게,제네릭을 받고,검증메서드가 있음
  이때 특이한건,검증메서드에서 제네릭에 추가로 쿼리와 쿼리빌더를 받아서 검증해준다는것
  
  그래서 조건별로 스펙을 만들지않고,별도클래스에 스펙생성기능을 모아도됨
  
*4.리포지터리/DAO에서 스펙 사용하기 
  스펙을 충족하는 엔티티를 검색하려면 findAll을 사용하고 스펙을 넘겨주면됨(스펙인터페이스를 파라미터로 가짐)
  
*5.스펙조합
  스프링데이터 JPA는 스펙을 조합할수있는 두 메서드를 제공하는데,이건 and와 or임(디폴트메서드)
  이름그대로 and는 둘다 만족하는 조건을 표현하고,or은 둘중 하나만 만족하는걸 표현하는 스펙을 생성함
  
  또한 not도 제공함,이것도 이름그대로 조건을 반대로 적용할때 사용됨
  
  만약 null가능성이 있는 스펙객체와 다른객체를 조합해야할땐 where메서드를 사용하면 null을 제공받으면 빈 스펙을 만들어줌

*6.정렬 지정하기
  스프링데이터 JPA에서 정렬은 메서드이름에 OrderBy로 명시하거나,Sort를 인자로 전달하는방식으로 정렬을 지정할수있음
  메서드명으로 하는건 편하긴한데,정렬기준프로퍼티가 두개이상이면 이름이 너무길어지고,상황에 따른 정렬순서변경도 불가능함
  이땐 Sort를 사용하면됨
    sort=Sort.by("칼럼명").ascending()
	dao.findByOrderId("123",sort)
  Sort를 사용해서 두개이상의 정렬순서를 지정할떈 and를 사용하면됨
  
*7.페이징 처리하기
  스프링데이터 JPA에서 페이징을 할떈 Pageable타입을 이용하면됨
  sort와 마찬가지로 Pageable타입 파라미터를 find계열에 넣으면 자동으로 페이징을 해줌
  Pageable타입 객체는
    pagereq=PageRequest.of(1,10)
	dao.findByOrderId("123",pagereq)
  이런식으로 만들어서 쓰면됨
  또한 정렬도 해야한다면
	pagereq=PageRequest.of(1,10,sort)
	dao.findByOrderId("123",pagereq)
  이렇게 하면됨
  또한 이렇게하면 조건에 해당하는 전체 갯수도 알수있는데(count),
  리턴타입이 Page면 카운트쿼리를 돌리고,리턴이 List면 카운트쿼리를 돌리지않으니 상황에 따라 카운트갯수가 필요없다면 list로 받는게좋음
  단,스펙을 사용하는 findAll메서드에선 리턴타입이 Page가 아니어도 카운트쿼리가 실행되니 주의(이거막으려면 커스텀리포지토리 만들어야함)
  
  그리고 페이징이 아니라 n개만 필요하다면 findFirstN같은걸 사용할수있음
  
*8.스펙조합을 위한 스펙빌더클래스
  스펙을 조건에따라 조합해야할떈,if를 사용하면 실수하기 좋음
  그래서 이럴땐 스펙빌더를 만들어 쓰는게 좋음
  참고는 책보자
  
*9.동적 인스턴스 생성
  Jpa는 쿼리결과에서 임의의 객체를 동적으로 생성할수있는 기능을 제공함
  JPQL로 new를 붙이고 해당클래스의 경로를 전부 적으면 됨(책참고)
  
  이런식으로 하면 객체기준으로 쿼리를 작성하면서도 지연로딩 즉시로딩같은걸 신경쓰지않아도되서 편함
  
*10.하이버네이트 @Subselect사용
  @Subselect 는 쿼리결과를 @Entity로 매핑할수있는 기능임
  이건 하이버네이트 전용인데,이러면 테이블이 아닌 쿼리결과를 @Entity로 매핑할수있음
  이렇게 조회된 엔티티는 수정할수없음(뷰테이블처럼 사용됨)
  그래서 @Immutable을 붙여서 수정불가를 지정하고,@Synchronize를 붙여서 변경순서를 맞춤
  
  이건 보통 from절의 서브쿼리로 사용됨,즉 서브쿼리용도에선 조회만 하면되니까 사용되는것
  이게싫다면 네이티브SQL을 사용하거나 마이바티스같은걸 써야함

6.응용서비스와 표현영역
*1.표현영역과 응용영역
  표현영역은 사용자의 요청을 해석하고,이걸 응용영역에 전달함
  실제 사용자가 원하는 기능은 서비스에 있고,
  응용영역의 서비스는 기능을 실행하는데 필요한 입력값을 메서드인자로 받고 실행결과를 리턴함
  
  서비스의 메서드가 요구하는 파라미터와 표현영역이 사용자로부터 받는 데이터는 형식이 일치하지않기때문에,
  표현영역은 응용서비스가 요구하는 형식으로 사용자요청을 변환해서 서비스의 메서드를 호출함
  
  이후에 표현영역은 json등으로 사용자요청에 맞게 리턴하면됨
  
*2.응용서비스의 역할  
  서비스는 사용자가 요청한 기능을 실행함
  즉 요청을 처리하기위해 리포지터리에서 도메인객체를 가져와서 도메인의 기능을 실행하는 역할을 함
  굳이말하자면 창구같은느낌임,직접 뭘 하기보다 도메인간의 흐름을 제어하는역할
  
  그래서 보통 응용서비스는 코드가 간단하고,만약 복잡하다면 도메인로직의 일부를 구현하고있을 가능성이 높음
  이러면 응집도가 낮아지고 코드중복등 단점이 많으니 가급적 도메인단으로 내리는게 좋음
  
  또한 응용서비스는 트랜잭션처리도 담당함
  얘는 도메인의 상태변경을 트랜잭션으로 처리해야함,그래야 일관된 처리가 가능해짐
  
  1.도메인로직 넣지않기
    도메인로직은 도메인단에 있어야함
	암호변경같은게 응용서비스에 있다면 응집도와 코드중복같은게 생길가능성이 커짐
	그러니 가급적 도메인에 있고,응용서비스는 그걸 불러다가 사용하는,위임에 그쳐야함(물론 결과값을 기반으로 예외를 던지는건 서비스에서 해도됨)

3.응용서비스의 구현
  응용서비스는 파사드같은 역할을 하고,복잡한 로직을 수행하지않음
  서비스의 구현자체는 어렵지않지만 생각해볼만한게 몇개 있음
  1.응용서비스의 크기
    응용서비스는 모든 로직을 해당 도메인의 응용서비스에 몰빵할수도 있고,구분되는기능별로 응용서비스 클래스를 따로 구현할수도있음
	
	한곳에 몰빵하면 각 기능에서 동일로직에 대한 코드중복을 제거할수있다는 장점이 있음(멤버가 없을때 익셉션을 던지는 로직을 프라이빗메서드로 뽑아서 쓰기)
	대신 한 서비스클래스가 커진다는 단점이 있음,이러면 연관성이 적은 코드가 한클래스에 함께 위치할 가능성이 높아져서,이해가 좀 힘들어짐
	또한 엄연히 분리하는게 좋은상황이라도 관습적으로 계속 추가하게돼서 코드품질이 점점 낮아짐
	
	구분되는 기능별로 서비스클래스를 구현하는건 한 서비스클래스에서 한개 내지 두세개의 기능을 구현함
	이러면 클래스갯수는 많아지지만 코드품질이 일정수준으로 유지됨
	또한 코드의 중복의 경우 별도클래스로 로직을 구현하고(헬퍼) 이걸 가져다쓰는식으로 해결할수있음
	
	구분되는 기능별로 서비스를 구현하는걸 디폴트로 잡는게 좋음

  2.응용서비스의 인터페이스와 클래스
    인터페이스는 구현클래스가 여러개(런타임에 구현객체를 교체해야할때)거나,tdd를 하기위해서 사용됨
	그런데 보통서비스의 경우엔 구현클래스가 여러개일 이유가 별로없고,
	tdd의 경우에도 모킹객체를 만들어버리면돼서(mockito) 굳이 인터페이스가 필요하진않음

  3.메서드 파라미터와 값리턴
    응용서비스가 제공하는 메서드는 도메인을 이용해서 사용자가 요구한 기능을 실행하는데 필요한값을 파라미터로 받아야함
	이건 개별파라미터로 받을수도있고,dto로 받을수도있음
	
	또한 서비스의 리턴값을 표현영역에서 사용해야하면 값을 리턴해야하는데,이때 애그리거트를 그대로 리턴하면 도메인의 로직실행을 서비스와 표현영역 두군데서 하게됨
	이러면 응집도가 떨어지니 가급적 애그리거트를 까서 필요한거만 던지는게 좋음

  4.표현영역에 의존하지않기
    가장중요한건 서비스는 표현영역과 관련된 타입을 사용하면 안됨(HttpServletRequset나 HttpSession같은거)
	이러면 테스트가 어려워지고,표현영역의 구현이 변경되면 응용서비스의 구현도 함께 변경해야함
	이런 외부표현과 관련된건 컨트롤러단에서 다끝내고,로직실행만 응용서비스로 와야함
	
	이걸 지키기 가장 쉬운방법이 서비스에서 파라미터와 리턴타입으로 표현영역의 구현기술을 사용하지않는것

  5.트랜잭션 처리
    프레임워크가 제공하는 트랜잭션기능은 적극적으로 사용하는게 좋음

*4.표현영역
  표현영역은
    사용자가 시스템을 사용할수있는 흐름(화면)을 제공하고 제어한다
	사용자의 요청을 알맞은 응용서비스에 전달하고 결과를 사용자에 제공
	사용자세션을 관리
  이 3가지가 주요 책임임
  
  사용자가 요청을 하면,요청 맞는 폼을(mvc일때) 띄워주고,거기서 입력된 정보를 다시 받아서 응용서비스에 전달한후 리턴해주는게 주 역할임
  세션관리는 쿠키나 서버세션등으로 사용자와의 연결상태를 관리(+권한검사)
 
*5.값 검증
  값검증은 표현영역과 응용서비스 두곳에서 모두 할수있음
  원칙적으로는 응용서비스에서 처리하는게 맞음,단 표현영역에서 처리하는건,잘못된값이 존재할때 에러메시지를 보여주고 다시 값을 돌려주기쉬움
  그래서 응용서비스에서 에러코드를 모아 하나의 익셉션(밸리데이션에러)으로 발생시키는 방법도 있음
  이러고나서 해당에러가 발생하면,현재데이터랑 같이 리턴하는형식
  
  표현영역에서 밸리데이션을 처리하면,응용서비스는 id중복여부같은 논리적오류만 검사하면됨
  그래서 응용서비스를 사용하는 표현영역코드가 한곳이면,표현영역에서 필수값,값의형식,범위등을 검증하고,
  응용서비스에서 데이터의 존재유무등 논리적 오류를 검증할수있음
  
  근데 요즘은 어지간하면 응용서비스에서 전부 처리하는추세임
  이러면 응용서비스의 완성도(밀집도)가 올라가게됨

*6.권한검사
  개발하는 시스템마다 권한의 복잡도는 다름
  인증만 검사하면 될수도,관리자검사까지 해야할수도
  그래서 스프링시큐리티같은걸 사용하면 편한데,대신 복잡도가 높음
  
  보안프레임워크의 복잡도를 떠나서 보통 세곳에서 권한검사를 할수있음
    표현영역
	응용서비스
	도메인
  표현영역에서 할수있는 기본검사는 인증된사용자인지 아닌지,url별 권한등을 검사할수있음(해당회원이 맞는지),이건 서블릿필터(스프링인터셉터)단에서 처리됨
  응용서비스에선 메서드단위로 권한검사를 수행할수있음(@PreAuthorize등)
  개별 도메인단위로 권한검사를 해야한다면 좀 복잡해짐,이러면 로직을 직접 만들어야함

*7.조회전용기능과 응용서비스
  서비스에서 조회전용기능을 사용하면,서비스코드는 단순히 조회전용기능을 호출하는 형태로 끝날수있음
  이러면 서비스에서 수행하는 추가로직도 없고,단일쿼리만 실행하는 조회전용기능이니 트랜잭션도 필요없음
  이럴경우엔 표현영역에서 이걸 사용해도 됨

7.도메인서비스
*1.여러 애그리거트가 필요한 기능
  도메인영역의 코드중,한 애그리거트로 기능을 구현할수없을때(결제금액계산등),이때 한 애그리거트에 억지로 넣으면 안됨
  이러면 수정이 발생했을때 전혀 상관없는 애그리거트를 수정해야할수있어짐
  
  즉 애그리거트가 자신의 책임범위를 넘어서는 기능을 구현하기때문에,코드가 길어지고 외부의존이 높아져서 코드가 복잡해지고 수정이 어려워짐
  또한 이런경우 도메인개념이 애그리거트에 숨어 명시적으로 드러나지않게됨
  그래서 이땐 도메인서비스를 사용할수있음
  
*2.도메인서비스
  도메인서비스는 도메인영역에 위치한 도메인로직을 표현할때 사용됨
  주로 사용되는곳은
    계산로직:여러 애그리거트가 필요한 계산이나,한애그리거트에 넣긴 복잡한 계산로직
	외부시스템연동이 필요한 도메인로직:구현하기위해 타 시스템을 사용해야하는 도메인로직
  임
  1.계산로직과 도메인서비스
    할인금액계산처럼 한 애그리거트에 넣기 애매한 도메인개념은 도메인서비스로 도메인개념을 명시적으로 드러낼수있음
	응용서비스가 응용로직이라면,도메인서비스는 도메인로직을 다룸
	
	도메인서비스가 애그리거트나 밸류랑 다른점은,상태없이 로직만 구현한다는것
	상태는 다른방법(보통 매개변수)로 전달받음
	도메인서비스는 도메인의 의미가 드러나는 용어를 타입과 메서드명으로 가짐
	
	이 도메인서비스를 사용하는주체는 애그리거트가 될수도있고,응용서비스가 될수도있음
	즉 애그리거트에서 매개변수로 도메인서비스를 받아서 로직을 위임하고 값을 받아쓸수있음
	
	또한 애그리거트객체에 도메인서비스를 전달하는건 응용서비스의 책임임
	즉 도메인서비스객체를 애그리거트에 주입하는건 좋지않음,상태가 없고 일부기능에서만 사용하는 서비스객체를 di받을필요는 없음
	
	반대로 애그리거트메서드를 실행할떄 도메인서비스를 인자로 전달하는게 아닌,도메인서비스의 기능을 실행할때 애그리거트를 전달하기도 함
	보통 계좌이체같은걸 할때 이런식으로 만들게됨
	그리고 응용서비스에서 이 로직을 호출해서 애그리거트를 넣은다음 사용하는것
	단 이때 트랜잭션등의 응용로직은 응용서비스의 책임이니 하면안됨
	
	특정기능이 응용서비스인지 도메인서비스인지 감을 잡기 어려울땐,해당로직이 애그리거트의 상태를 변경하거나 애그리거트의 상태값을 계산하는지 검사해보면됨
	이런 로직들은 도메인로직임

  2.외부시스템연동과 도메인서비스
    외부시스템이나 타 도메인과의 연동도 도메인서비스가 될수있음
	설문조사시스템은 설문조사를 생성할때 사용자가 생성권한이 있는지를 확인하기위해 역할관리시스템과 연동하는 식임
	
	시스템간 연동은 api호출로 이뤄질수있지만,도메인입장에선 사용자가 생성권한이 있는지를 확인하는 로직임
	이러면 도메인에서 인터페이스(이때 도메인입장에서 만드는게 중요,연동관점에서 생성되면안됨)를 만들고,
	응용서비스는 이 인터페이스에 의존해서 생성권한을 검사할수있음
	또한 구현체의 경우는 인프라영역에서 구현해서 검사기능을 구현하면됨

  3.도메인서비스의 패키지 위치
    도메인서비스는 도메인로직을 표현하므로 도메인서비스는 다른 도메인과 같은패키지에 있으면됨
	즉 주문계산도메인서비스는 주문애그리거트와 같은패키지에 있으면됨
	만약 명시적으로 구분하고싶으면 도메인밑에 하위패키지를 만들어도됨

  4.도메인서비스의 인터페이스와 클래스
    도메인서비스의 로직이 고정되어있지않다면,도메인서비스 자체를 인터페이스로 만들고 이를 구현한 클래스를 둘수도있음
	특히 도메인로직을 외부시스템이나 별도엔진을 이용해서 구현할때 이렇게 분리하게됨
	이러면 도메인영역에는 도메인서비스인터페이스가,실제구현은 인프라영역에 위치하게됨
	이렇게해야 도메인영역이 특정구현에 종속되는걸 막을수있고,도메인영역의 테스트가 쉬워짐

8.애그리거트 트랜잭션관리






































  
  
  
  
  
  
  
  
  