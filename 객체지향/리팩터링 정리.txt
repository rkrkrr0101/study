1.리팩터링 예시
	프로그램이 새기능을 추가하기에 편한구조가 아니면,먼저 기능을 추가하기 쉬운형태로 리팩터링한다음 원하는기능을 추가해야함
	
	리팩터링을 할때 제일먼저해야할건 테스트코드임
	테스트코드가 있어야 변경할때 믿고 변경할수있음
	
	긴 함수를 리팩터링할때는 보통 중복이 발생할 부분에서 중복부분을 빼내는게 잘 사용됨
	case문처럼 분기처리가 일어나는 부분을 뽑아내는게 가장 쉬운 리팩터링임(컨트롤알트m)
	그래서 추가가 일어날때 거기내에서만 수정을 하면되게하는게 효과적
	
	수정을 했으면 바로 테스트코드를 돌려보면됨,아무리 작은수정이라도 테스트를 켜는게좋음(그래야 문제찾기기쉬움)
	그리고 테스트가 성공했으면 바로 깃에 커밋해서 기록하는식(하나의 리팩터링마다 커밋)
	
	함수추출을 하고 테스트가 성공했으면,해당함수의 표현이 명확하지않은부분(함수명이나 변수명,파라미터등)을 수정하는게좋음
	
	그리고 동적타입언어를 쓸땐 타입명이 이름에 드러나면 좋고,매개변수의 역할이 뚜렷하지않을땐 앞에 a나 an을 붙이면 좋음
	그리고 다른 매개변수에서 값을 받아올수있어서 필요없어진 매개변수가 있으면 제거하는게좋음(임시변수를 질의변수로 바꾸기)
	그리고 인라인이 가능하다면 인라인하는게 더 깔끔해짐
	
	지역변수를 제거하는건,추출작업이 훨씬 쉬워지기때문에 가치가있음
	
	그리고 함수내부에서 작업을 단위로 쪼갤수있다면,다 쪼개서 추출해내는게 좋음
	각 함수는 하나의 일만 하고,메인함수에서는 결합만 하게 만드는게좋음
	
	임시변수는 자신의 루틴내부에서만 의미가있어서 루틴이 길고 복잡해지기쉬움
	그래서 임시변수를 제거하고 함수화시키는게좋음
	
	함수이름지을때는 일단 떠오르는걸 붙이고,나중에 더 적절한이름이 떠오르면 바꾸면됨
	
	그리고 반복문을 쪼개는건 그렇게 큰 성능이슈를 내지못해서 막 쪼개도됨(컴파일러가 알아서 최적화함)
	그리고 문제가 생기더라도 수정하기가 더 쉬움
	즉 리팩터링성능문제는 특별한경우가 아니면 일단 무시하고,리팩터링후에 다시 손대는게나음
	
	만약 리팩터링중간에 테스트가 실패하고 원인을 못찾았다면,가장 최근커밋으로 돌아간다음 리팩터링 단계를 더 잘게 쪼개서 다시 시도하면 찾기쉬움
	
	
	리팩터링은
		코드를 각 논리적인 요소로 쪼개고(최소단위근처로)
		쪼개진 함수들을 의미있는단위로 묶어서 함수를 만들고,메인함수에서 조립
	하는식으로 접근하는게좋음
	이때 의미있는단위로 묶인 함수끼리 서로 연계가 되어야하니,입출력에는 신경써줘야함
	
	가변데이터는 쉽게 상하니까,불변데이터를 사용하는게좋음
	
	조건부로직은 다형성으로 바꿀수있음,즉 case문을 사용하는곳은 상속을 사용해서 처리하는게 깔끔함
	케이스문은 팩터리쪽으로 이동시켜서 거기서 하위클래스를 뽑아내는식
	
	리팩터링은 수정할때 얼마나 쉽게 수정할수있냐를 기준으로 접근하는게좋음
	그리고 제일 중요한건,단계를 잘게 나누고 매번 컴파일-테스트를 하는것
	
2.리팩터링 원칙
  1.리팩터링 정의
	리팩터링은 소프트웨어의 겉보기동작은 유지한채 내부만 수정하는것
	그래서 리팩터링을 할때 작동결과가 바뀌면안됨
	리팩터링하다가 코드가 깨짐->리팩터링이 아님
	
	리팩터링과 성능최적화는 비슷하지만 목적이 다름
	리팩터링은 코드를 이해하기쉽고 수정하기 쉽게 만드는것,성능최적화는 단순히 성능에만 신경쓰는것
	그래서 성능이 빡빡하게 제한걸리면 코드가 어려워지기쉬움
	
  2.두개의 모자	
	소프트웨어를 개발할때는 기능추가만 하거나,리팩터링만 하거나 둘중 하나만 해야함
	기능추가때문 기존코드는 전혀 건드리지않고 기능추가만 하고,리팩터링때는 기능추가는 전혀하지않고 리팩터링만 해야함
	리팩터링시에는 놓친테스트케이스를 발견하지않는한 테스트추가도 하지않음(인터페이스를 부득이하게 변경해야할때만 기존테스트를 수정)
	
	소프트웨어를 개발하면서 이 두가지 모자를 바꿔가면서 하는게 좋음(기능추가하려고 각잡으면서 리팩터링하면 더 쉬울거같으면 리팩터링만 하고 이후 기능추가)
	즉 짧게 치더라도 내가 뭘하려고하는지를 항상 신경쓰면서 작업을 해야함
	
  3.리팩터링하는 이유	
	리팩터링을 하면 코드를 건강한상태로 유지하는걸 도와줌(기능추가를 쉽게해줌)
	그리고 중복코드는 수정할때 여러군데를 수정해야하고,빼먹을수도 있음,이걸 밖으로 빼서 유일하게만드는게 바람직한설계의 핵심임
	또한 소프트웨어를 이해하기 쉬워짐,코드는 다른사람(혹은 미래의 나)이 수정해야할수있고,그사람이 이해하기쉬워야 수정이 쉬워짐
	이때 컴퓨터에게 시키려는일과 이를 표현한 코드의 차이를 최대한 줄여야함
	그리고 코드를 이해하기쉬우면 버그를 찾기도 쉬움
	
	즉,리팩터링을 하면 코드개발속도가 올라감
	
  4.언제 리팩터링을 해야할까
	리팩터링은
		1.처음에는 그냥 기능만듬
		2.비슷한일을 두번째하면 그냥 기능만듬
		3.비슷한일을 세번째하면 리팩터링
	이렇게 3번반복되면 리팩터링하면됨
	리팩터링을 하기 가장 좋은시점은,기능추가직전임
	어짜피 기능추가하려면 코드를 이해해야하고,
	구조를 건드려서 기능추가작업을 하기 쉽게만들면,기능추가도 하면서 싼가격에 리팩터링을 할수있음
	이때 중복이날거같으면 해당부분을 추출해서 함수화시킨후 그걸호출해서 쓰는식
	버그를 잡을떄도 오류를 일으키는코드가 여러군데 복제되어 퍼져있으면,일단 그걸 한곳으로 합친다음 작업하는게 훨씬편함
	또한 질의코드에 섞여있는 갱신로직을 분리하면,각 단계별로 처리할수있어서 꼬일확률을 줄일수있음
	
	이처럼 준비를 위한 리팩터링이 가장 하기편하고 좋음
	
	코드를 이해할때도 리팩터링모자를 쓰고 하면 좀 더 이해가 쉬움
	이해가 안되는부분을 좀 더 의도가 명확히 드러나게 수정하는식으로 접근하는거임
	리팩터링은 머리가 이해한걸 코드로 옮겨담을수있고,그걸 테스트돌려보면 그게 맞았는지도 확인할수있음
	즉 어떤역할을 하는지 이해됐지만 이름이 직관적이지않은 변수는 적절한이름으로 바꿔주고,긴함수를 잘게 나누고있으면,
	코드가 깔끔하게 정리되어 설계가 눈에 들어오기시작함
	
	그리고 코드를 파악하던중 이상한부분을 찾으면(로직이 쓸데없이 복잡하거나,매개변수하나면되는데 여러개쓸때),간단한일이면 즉시 고치고
	복잡한일이면 메모만 남기고 하던거 끝내고나서 처리하는식(쓰레기줍기 리팩터링)
	리팩터링은 어짜피 코드가 깨지면안되니까,조금씩해도 코드에 영향을 안주고 할수있음
	
	리팩터링을 날잡고 하는게 아닌(물론 안했으면 이렇게해야할수도있음,그래도 최대한줄여야함),
	평상시에 기능을 추가하거나 버그를 잡는동안 리팩터링도 같이 하는게좋음
	잘 작성된 코드도,다른코드가 추가되면서 리팩터링해야할수도 있게되고 그럼
	이때도 잘 작성되면 리팩터링도 쉬워짐
	
	라이브러리를 교체하는등 큰규모의 리팩터링을 할떈,기존것과 새것을 모두 포용하는 추상인터페이스부터 만들고,
	기존코드가 추상인터페이스를 호출하게하고나면 라이브러리교체가 훨씬 쉬워짐(추상화로 갈아타기)
	
	코드리뷰할때도 리팩터링하는게 도움이됨,실제로 코드가 더 나아지기도하고 더 명확한 결과로 보이니까
	
	그리고 굳이 수정할필요가 없다면 리팩터링하지않아도됨
	외부api호출하는거처럼 쓰는 코드면 걍 둬도되고,내부동작을 이해해야할때 리팩터링하면됨
	그리고 리팩터링보다 처음부터만드는게 쉬워보이면 걍 새로만드는게나음
	
  5.리팩터링시 고려할문제
    리팩터링이 필요해보이지만,추가하려는 기능이 매우작을땐,그냥 각보고 하는게 맞는데,이럴때도 보통은 리팩터링하는게 맞는선택일 확률이 높음
	새기능을 추가해넣는게 더 쉬워지는 리팩터링이 보이면 리팩터링하는게 나음
	반면 건드리지않아도 기능추가랑 상관없거나,그렇게 불편하지않으면 걍 기능추가함	
	리팩터링은 단순히 기능추가를 더 쉽게하기위해서+처음볼때 이해하기쉽게 하기위해서 하는거임
	
	코드소유권은 빡빡하게 관리하는게 아닌 팀단위로 느슨하게 관리하는게 리팩터링하기쉬움(함수명변경같은거 귀찮아짐)
	
	브랜치따서 작업할때도 계속 풀한뒤에 푸시하는,ci를 반복해야 나중에 합치기가 쉬움
	이걸 각자 최소 하루한번은 해야함
	이렇게하면 머지도 쉬워지지만 리팩터링과 궁합도 좋음(익스트림프로그래밍)
	
	리팩터링의 가장 큰 특성은 겉보기동작이 똑같이 유지된다는것
	만약 실수를 저질렀는데 해결이 안된다면 이전커밋으로 돌아가면됨
	이떄 가장 중요한건,테스트스위트가 잘되어있어야 검사를 믿을수있고,버그를 걱정하지않게됨
	
	레거시시스템을 파악할떄도 리팩터링이 도움됨,근데 이때도 테스트가없으면 리팩터링을 할수없음
	이때는 테스트를 보강해서 리팩터링을 하면서 이해해야하는데,어려운문제임 그래서 테스트를 잘 적어둬야함
	테스트가 있어도 복잡한애들은 어려운데,이때는 한부분씩 나눠서 하나씩 처리하는게 그나마쉬움
	그리고 이때는 자주 보게되는부분을 더 많이 리팩터링하는게 효율적임
	
	db를 리팩터링할때는 데이터마이그레이션스크립트를 작성하고,모든 변경을 이거로 처리하는식으로 하면 할수있음
  
  6.리팩터링,아키택처,애그니
	리팩터링은 미래의 요구사항을 추측하지않고,현재 필요한거만 처리하면서 확장성을 남겨둬서 미래에 확장을 쉽게만듬
	호출할때 항상 같은값을 넘기는 매개변수는 매개변수에서 제거하는식(애그니)
  
  7.리팩터링과 개발프로세스
	팀으로 개발할때 리팩터링을 하려면,각 팀원이 다른사람의 작업을 방해하지않으면서 언제든 리팩터링할수있어야함
	그래서 ci가 필요하고,팀원 각자가 수행한 리팩터링결과를 빠르게 동료와 공유할수있음
	즉 테스트코드,ci,리팩터링 3가지를 같이쓰면 상승효과가 있음
	이 3개를 쓰면 애그니방식으로 개발할수있고,애그니는 또한 리팩터링을 더 쉽게만들어줌(추측보단 단순한시스템이 변경이 쉬움)

  8.리팩터링과 성능
	프로그램의 케이스마다 이건 선택을 다르게해야함
	일반적으론 리팩터링하고,성능이 필요할때 성능최적화를 하는게 효율적임
	성능최적화를 할땐 항상 검증하고 검증결과를 바탕으로 어디서 성능을 많이쓰는지를 확인한후에 변경을 해야함(컴파일러동작을 예측하기어려우니)
	
3.코드에서 나는 악취
  1.기이한 이름
	함수와 변수명,클래스명등은 항상 단순하고 명료해야함
	해당 이름만 보고도 무슨일을할지 명확히 알수있어야하고,여기에 신경을 많이써야함
	그리고 마땅한 이름이 떠오르지않는다면,설계에 문제가 있을수있음
	
  2.중복코드
	같은 코드가 여러곳에서 반복되면,하나로 통합해야함
	이때는 함수추출후 해당 메서드를 호출하게하면됨
	만약 비슷한데 완전히 똑같진않으면,문장슬라이드로 비슷한부분을 한곳에 모아 추출할수있는지를 확인하고,
	같은부모로부터 파생된 서브클래스의 중복코드는 부모쪽으로 메서드를 올리면됨
	
  3.긴 함수
	함수가 길면 이해하기가 어렵고,이름붙이기도 힘듬
	함수가 짧으면 좋은건,해당 메서드의 행동에 대한 명확한 정의(이름)를 내릴수있다는것
	함수이름은 동작방식이 아닌 의도를 드러내게짓고,이런 함수들을 묶는 함수를 만드는식으로 조립해야함
	이건 함수추출로 거의 다 할수있고,함수가 매개변수와 임시변수를 많이 사용하면 추출에 방해가되니,
	임시변수를 질의함수로 바꾸고,매개변수객체만들기와 객체통째로 넘기기를 사용해서 매개변수의 수를 줄이고
	그래도 많으면 좀 큰수술인 함수를 명령으로 바꾸기를 고려할수있음
	
	긴함수는 주석이 있는곳을 분리하는식으로 하는게 편하고(이때 함수명은 해당주석을 참고하면됨),조건문이나 반복문도 추출하기좋음
	조건문은 조건문분해하기를 사용하고,스위치문은 각 케이스마다 함수추출을 하고,같은조건을 기준으로 나뉘는 스위치문이 여러개면 다형성으로 변경
	반복문은 그안의 코드와 같이 추출해서 독립된함수로 만들면됨,이떄 이름이 떠오르지않으면 성격이 다른 두가지작업이 섞여있어서 그럴수있음
	이때는 반복문쪼개기를 사용
	
  4.긴 매개변수 목록
	파라미터가 많으면 많을수록 함수이해는 어려워짐,만약 다른 매개변수에서 데이터를 뽑을수있다면,이건 매개변수를 질의변수로 바꾸기로 제거할수있고
	특정 클래스에서 값을 뽑아서 넣고있으면 객체를 통째로 넘겨버릴수있고,항상 함께 전달되는 매개변수들은,이것들을 묶어 객체로 만들수있음
	함수의 동작방식을 지정하는 플래그변수는 제거하는게좋음
	보통 클래스를 만들거나 해서 날려버리는게 많음
	
  5.전역데이터
	전역변수는 가급적 사용하지않는게 좋고,그나마 불변데이터까진 괜찮은데 가변데이터는 사용하면안됨
	어쩔수없이 사용해야하면,전역변수를 클래스로 감싸고 싱글톤으로 만든후,해당 클래스의 메서드로만 변수를수정할수있게 해서(protected set)
	어디서 수정했는지는 알수있게 할수있음
	
  6.가변데이터
	가변데이터는 값이 빠르게 상하니까 가급적이면 불변데이터를 사용하는게좋음
	가변데이터를 쓸때도 직접 데이터를 오픈하는게 아닌,메서드를 거쳐서 수정하게 하는게 나중에 문제생기거나했을때 찾기쉬움
	그리고 하나의 변수에 용도가 다른값들을 저장하면,변수쪼개기를 써서 용도별로 변수를 만드는게 낫고
	갱신로직은 다른코드와 떨어져있는게 좋음,이땐 문장슬라이드와 함수추출로 분리해내면됨
	api를 만들때는 질의메서드와 변경메서드를 분리해서,둘중 하나만 할수있게(cqrs)만드는게좋음
	
	값을 다른곳에서 수정할수있는(외부에서)애들은 특히머리아픔,이때는 파생변수를 질의함수로 바꾸는게좋음
	
  7.뒤엉킨 변경
	뒤엉킨변경은 srp(단일책임원칙)가 제대로 지켜지지않을때 나타남
	하나의 모듈이 서로 다른 이유로 여러가지방식으로 변경되는일이 많을때 발생함(지원db를 추가하는데 함수를 3개씩바꿔야하고 이런거)
	이럴땐 다음맥락에 필요한 데이터를 특정객체에 담아 전달하게하는식으로 단계를 분리하고(단계쪼개기),
	곳곳에서 각기 다른맥락의 함수를 호출하는 빈도가 높으면 각 맥락에 해당하는 모듈을 만들어서 관련함수들을 모으면됨(애그리거트별로 분리)
	이러면 각 모듈은 하나의 일만 하게됨
	모듈이 클래스면 클래스추출하기를 하면됨
	
  8.산탄총 수술
	이건 뒤엉킨변경과 비슷한데 정반대임,원인과 해법은 같은데 현상과 해법이 다름
	뒤엉킨변경이나 산탄총수술이나 원인은 맥락구분을 못한거고,해법도 맥락구분을 잘하는건데,
	뒤엉킨변경은 이 맥락들이 한코드에 섞여들어가는거고 산탄총수술은 여러코드에 흩뿌려진것
	즉 이건 코드를 변경할때 자잘하게 수정해야하는클래스가 많을때 생김
	해법도 뒤엉킨변경은 맥락들을 분리해주는거고,산탄총수술은 맥락들을 모아줘야하는거
	
	맥락을 모아야 변경이 쉽고,빼먹는걸 방지해줌
	이땐 함수옮기기와 필드옮기기로 함께 변경되는대상을 한 모듈로 묶어주고,비슷한데이터를 다루는 함수가 많으면 여러함수를 클래스로 묶어주면됨
	데이터구조를 변환하거나 보강(js용)하는 함수들은 함수들을 변환함수로 묶을수있음
	또한 어설프게 분리된 로직을 함수인라인이나 클래스인라인으로 합치는거도 좋은방법일수있고,이렇게 합치면 커지지만 이러면 나중에 추출이 더 깔끔하게됨
	즉 합치고나서 다시 맥락에맞게 쪼개면됨
	
  9.기능 편애
	프로그램을 클래스별로 나누고나면,클래스내부에선 상호작용을 최대한 늘리고,클래스끼리는 최소로 줄여야하는데
	기능편애는 클래스내부보다 클래스 외부와의 통신을 더 많이할때 발생함
	이럴땐 해당 메서드를 해당 외부클래스로 옮기거나,만약 해당 메서드의 일부에서만 그런다면 해당부분을 추출한다음 그부분만 옮기면됨
	즉 게터를 12개씩 호출한다면 해당 호출부분을 추출해서 해당 클래스로 옮기면됨
	이때 여러클래스에서 조금씩 호출한다면 가장 많은 데이터를 포함한곳으로 옮기거나,각 모듈마다 추출을 쪼갠뒤에 각각을 해당모듈로 옮길수도있음
	
	단,전략패턴이나 방문자패턴처럼 해당규칙을 거스르는패턴도 있음,얘들은 뒤엉킨변경을 제거할때 활용하는패턴들임
	보통은 데이터와 이 데이터를 사용하는동작은 한곳에 있는게 좋지만,예외일때는 같은데이터를 다루는 코드를 한곳에서 변경할수있게 옮기는것
	
  10.데이터뭉치
	서로 항상 같이다니는 데이터들은 클래스로 묶고,만약 해당데이터들을 사용하는 메서드들이 있으면 해당클래스로 이동시키면 엔티티를 만들수있음
	이때 데이터뭉치인지 판별하려면,어떤 데이터 하나를 삭제하면 다른데이터들이 다 의미없어지면 데이터뭉치임
	
  11.기본형집착
	모든걸 기본형으로 해결하려하지말고,기본형을 객체로 바꾸는게좋음(인트대신 화폐,스트링대신 이메일)
	기본형코드가 조건부동작을 제어하는 타입코드로만 쓰였으면,타입코드를 서브클래스로 바꾸기와 조건부로직을 다형성으로 바꾸기를 차례로 적용하면됨
	여기서도 데이터뭉치가 자주 생기니,클래스추출하기와 매개변수객체만들기로 뽑아낼수있으면 뽑아내는게좋음
	
  12.반복되는 스위치문
	스위치문은 특히 중복일때 문제가됨,스위치문이 중복이면 조건절을 하나 추가할때마다 다른스위치문도 모두 수정해야하기때문
	이런애들을 최우선적으로 추출해내고,다형성으로 바꾸는게좋음
	
  13.반복문
	반복문은 가급적이면 파이프라인(필터나 맵등)으로 바꾸는게좋음,이게 더 이해가 쉬움
	
  14.성의없는요소
	만약 해당 함수가 추출할이유가 없거나,별이유없이 메서드가 하나뿐인 클래스같은건 그냥 제거하는게좋음
	이때 함수인라인하기나 클래스인라인하기로 처리할수있고,상속을 사용했으면 계층합치기를 사용할수있음
	
  15.추측성 일반화
	나중에 필요할거야라는 생각으로 작성해둔 코드들은 쓸데없는 낭비임
	당장 현재필요한것들만 사용하고,확장만 가능하게 해두는게 제일 좋음
	
	하는일이 거의없는 추상클래스는 계층합치기로 제거하고,쓸데없이 위임하는코드는 함수인라인이나 클래스인라인으로 삭제
	본문에서 사용되지않는 매개변수는 함수선언변경으로 제거
	보통 테스트코드에서만 사용하는 코드들은 이런경우가 많음,테스트부터 제거한다음 제거하자
	
  16.임시필드
	만약 특정상황에서만 값이 설정되는 필드들은,객체를 가져올때 이해하기힘듬
	이런필드들은 클래스추출하기로 뽑아낸후,해당필드들을 사용하는 메서드들은 함수옮기기로 옮겨버리면됨
	그리고 임시필드들이 유효한지 확인한후 동작하는 조건부로직들은 특이케이스 추가하기로 대안클래스를 만들어서 제거할수있음

  17.메시지체인
	메시지체인은 abc.getUser().getEmail().getSite() 이런식으로 체인타는걸 말함
	이건 클라가 객체내비게이션구조에 종속됐음을 의미하고,네비게이션중간을 수정하면 클라코드도 수정해야함(email에서 getSite를 변경하면 다바꿔야함) 
	이런건 위임숨기기로,user에서 site를 뽑아내는 메서드를 만들고,해당 메시지체인을 거기다가 넣고 쓰는식으로 할수있음
	이건 이런식으로 사용하는애들이 여러명일때 이렇게 처리하고,걍 한두개면 저대로써도됨

  18.중개자
	객체의 캡슐화에선 위임이 자주 활용되는데,이게 선을넘어서 클래스의 메서드 절반이상이 구현을 위임하면 중개자를 제거하고 직접 통신하게하는게나음
	만약 위임메서드를 제거한후 남는일이 거의없어지면 호출하는쪽으로 인라인하면됨
	
  19.내부자 거래
	서로간에 은밀하게 데이터를 주고받는 클래스들이 있다면,함수옮기기와 필드옮기기로 떼어내고,
	여러모듈이 같은 관심사를 공유하면 해당부분을 새클래스로 만들거나,위임숨기기로 다른모듈이 중간자역할을 하게만듬
	
	상속에서 부모자식사이의 결탁이 생길때는,서브클래스를 위임으로 바꾸거나,슈퍼클래스를 위임으로 변경해서 대응
  20.거대한클래스
	클래스가 너무 많은일을 하려고하면 중복코드가 생기기쉽고 필드수가 늘어남
	이때는 클래스추출하기로 필드일부를 묶고(서로 같이있을만한애들끼리),떼어낸다음 해당 필드들의 메서드를 옮겨주면됨
	보통 같은 접두사나 접미사가 붙은애들을 떼어내기좋음
	
	만약 이게 상속관계가 깔끔할거같으면 슈퍼클래스추출하기나 타입코드를 서브클래스로 바꾸기를 사용하면됨
	
	보통 클래스가 모든필드를 사용하지않으면 분리해야할수있고,그냥 단순히 중복이 많아서 커보일수도있음
	일단 중복부터 제거하고생각
	클래스의 메서드들이 특정필드만 사용할경우,해당필드들을 묶을수있나 볼수도있음
  21.서로 다른 인터페이스의 대안클래스들(js용)
	덕타이핑언어에서 묶을클래스들의 인터페이스를 최대한 맞춰주고,함수옮기기로 없는애들채우고,중복이 생기면 슈퍼클래스추출하는거
	
  22.데이터클래스
	데이터클래스는 퍼블릭필드를 제거하고,변경하면안되는필드는 세터를 제거하고,
	다른클래스에서 데이터클래스의 게터세터를 사용하는메서드는 데이터클래스로 옮길수있나 생각해보자(코틀린에선 불변이라 신경안써도됨)
	
	또한 데이터클래스는 필요한동작이 엉뚱한곳에 정의되어있다는 신호일수있음,이땐 클라코드를 데이터클래스로 옮기기만해도 개선됨
	단,다른함수를 호출해 얻은 결과레코드로는 동작코드를 넣을이유가없음(단계쪼개기의 결과로 나온 중간데이터등)
	
	데이터클래스는 불변으로 사용하는게 좋음

  23.상속 포기
	서브클래스가 슈퍼클래스의 메서드 일부만 사용하는경우엔 새로운 서브클래스를 만들고,
	거기로 모든코드를 넘긴다음 공통부분만 부모쪽에 남길수있는데,이경우 좀 복잡해서 선호하지않음
	걍 서브클래스가 슈퍼클래스의 일부만 써도되긴하는데,이때 무조건 부모의 인터페이스는 따라야함
	이것도 싫으면 상속이 아닌 위임으로 바꾸는게좋음
	
  24.주석
	가급적 주석보단 해당부분을 추출해서 메서드명에 정보를 담거나 하는게 좋음
	즉 주석을 달고싶어지면 추출하자
	주석은 뭘할지 모를때나 확실하지않은부분등을 다는거지,코드를 설명하는거로 다는건 별로좋지않음

4.테스트 구축하기
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	