1.리팩터링 예시
	프로그램이 새기능을 추가하기에 편한구조가 아니면,먼저 기능을 추가하기 쉬운형태로 리팩터링한다음 원하는기능을 추가해야함
	
	리팩터링을 할때 제일먼저해야할건 테스트코드임
	테스트코드가 있어야 변경할때 믿고 변경할수있음
	
	긴 함수를 리팩터링할때는 보통 중복이 발생할 부분에서 중복부분을 빼내는게 잘 사용됨
	case문처럼 분기처리가 일어나는 부분을 뽑아내는게 가장 쉬운 리팩터링임(컨트롤알트m)
	그래서 추가가 일어날때 거기내에서만 수정을 하면되게하는게 효과적
	
	수정을 했으면 바로 테스트코드를 돌려보면됨,아무리 작은수정이라도 테스트를 켜는게좋음(그래야 문제찾기기쉬움)
	그리고 테스트가 성공했으면 바로 깃에 커밋해서 기록하는식(하나의 리팩터링마다 커밋)
	
	함수추출을 하고 테스트가 성공했으면,해당함수의 표현이 명확하지않은부분(함수명이나 변수명,파라미터등)을 수정하는게좋음
	
	그리고 동적타입언어를 쓸땐 타입명이 이름에 드러나면 좋고,매개변수의 역할이 뚜렷하지않을땐 앞에 a나 an을 붙이면 좋음
	그리고 다른 매개변수에서 값을 받아올수있어서 필요없어진 매개변수가 있으면 제거하는게좋음(임시변수를 질의변수로 바꾸기)
	그리고 인라인이 가능하다면 인라인하는게 더 깔끔해짐
	
	지역변수를 제거하는건,추출작업이 훨씬 쉬워지기때문에 가치가있음
	
	그리고 함수내부에서 작업을 단위로 쪼갤수있다면,다 쪼개서 추출해내는게 좋음
	각 함수는 하나의 일만 하고,메인함수에서는 결합만 하게 만드는게좋음
	
	임시변수는 자신의 루틴내부에서만 의미가있어서 루틴이 길고 복잡해지기쉬움
	그래서 임시변수를 제거하고 함수화시키는게좋음
	
	함수이름지을때는 일단 떠오르는걸 붙이고,나중에 더 적절한이름이 떠오르면 바꾸면됨
	
	그리고 반복문을 쪼개는건 그렇게 큰 성능이슈를 내지못해서 막 쪼개도됨(컴파일러가 알아서 최적화함)
	그리고 문제가 생기더라도 수정하기가 더 쉬움
	즉 리팩터링성능문제는 특별한경우가 아니면 일단 무시하고,리팩터링후에 다시 손대는게나음
	
	만약 리팩터링중간에 테스트가 실패하고 원인을 못찾았다면,가장 최근커밋으로 돌아간다음 리팩터링 단계를 더 잘게 쪼개서 다시 시도하면 찾기쉬움
	
	
	리팩터링은
		코드를 각 논리적인 요소로 쪼개고(최소단위근처로)
		쪼개진 함수들을 의미있는단위로 묶어서 함수를 만들고,메인함수에서 조립
	하는식으로 접근하는게좋음
	이때 의미있는단위로 묶인 함수끼리 서로 연계가 되어야하니,입출력에는 신경써줘야함
	
	가변데이터는 쉽게 상하니까,불변데이터를 사용하는게좋음
	
	조건부로직은 다형성으로 바꿀수있음,즉 case문을 사용하는곳은 상속을 사용해서 처리하는게 깔끔함
	케이스문은 팩터리쪽으로 이동시켜서 거기서 하위클래스를 뽑아내는식
	
	리팩터링은 수정할때 얼마나 쉽게 수정할수있냐를 기준으로 접근하는게좋음
	그리고 제일 중요한건,단계를 잘게 나누고 매번 컴파일-테스트를 하는것
	
2.리팩터링 원칙
  1.리팩터링 정의
	리팩터링은 소프트웨어의 겉보기동작은 유지한채 내부만 수정하는것
	그래서 리팩터링을 할때 작동결과가 바뀌면안됨
	리팩터링하다가 코드가 깨짐->리팩터링이 아님
	
	리팩터링과 성능최적화는 비슷하지만 목적이 다름
	리팩터링은 코드를 이해하기쉽고 수정하기 쉽게 만드는것,성능최적화는 단순히 성능에만 신경쓰는것
	그래서 성능이 빡빡하게 제한걸리면 코드가 어려워지기쉬움
	
  2.두개의 모자	
	소프트웨어를 개발할때는 기능추가만 하거나,리팩터링만 하거나 둘중 하나만 해야함
	기능추가때문 기존코드는 전혀 건드리지않고 기능추가만 하고,리팩터링때는 기능추가는 전혀하지않고 리팩터링만 해야함
	리팩터링시에는 놓친테스트케이스를 발견하지않는한 테스트추가도 하지않음(인터페이스를 부득이하게 변경해야할때만 기존테스트를 수정)
	
	소프트웨어를 개발하면서 이 두가지 모자를 바꿔가면서 하는게 좋음(기능추가하려고 각잡으면서 리팩터링하면 더 쉬울거같으면 리팩터링만 하고 이후 기능추가)
	즉 짧게 치더라도 내가 뭘하려고하는지를 항상 신경쓰면서 작업을 해야함
	
  3.리팩터링하는 이유	
	리팩터링을 하면 코드를 건강한상태로 유지하는걸 도와줌(기능추가를 쉽게해줌)
	그리고 중복코드는 수정할때 여러군데를 수정해야하고,빼먹을수도 있음,이걸 밖으로 빼서 유일하게만드는게 바람직한설계의 핵심임
	또한 소프트웨어를 이해하기 쉬워짐,코드는 다른사람(혹은 미래의 나)이 수정해야할수있고,그사람이 이해하기쉬워야 수정이 쉬워짐
	이때 컴퓨터에게 시키려는일과 이를 표현한 코드의 차이를 최대한 줄여야함
	그리고 코드를 이해하기쉬우면 버그를 찾기도 쉬움
	
	즉,리팩터링을 하면 코드개발속도가 올라감
	
  4.언제 리팩터링을 해야할까
	리팩터링은
		1.처음에는 그냥 기능만듬
		2.비슷한일을 두번째하면 그냥 기능만듬
		3.비슷한일을 세번째하면 리팩터링
	이렇게 3번반복되면 리팩터링하면됨
	리팩터링을 하기 가장 좋은시점은,기능추가직전임
	어짜피 기능추가하려면 코드를 이해해야하고,
	구조를 건드려서 기능추가작업을 하기 쉽게만들면,기능추가도 하면서 싼가격에 리팩터링을 할수있음
	이때 중복이날거같으면 해당부분을 추출해서 함수화시킨후 그걸호출해서 쓰는식
	버그를 잡을떄도 오류를 일으키는코드가 여러군데 복제되어 퍼져있으면,일단 그걸 한곳으로 합친다음 작업하는게 훨씬편함
	또한 질의코드에 섞여있는 갱신로직을 분리하면,각 단계별로 처리할수있어서 꼬일확률을 줄일수있음
	
	이처럼 준비를 위한 리팩터링이 가장 하기편하고 좋음
	
	코드를 이해할때도 리팩터링모자를 쓰고 하면 좀 더 이해가 쉬움
	이해가 안되는부분을 좀 더 의도가 명확히 드러나게 수정하는식으로 접근하는거임
	리팩터링은 머리가 이해한걸 코드로 옮겨담을수있고,그걸 테스트돌려보면 그게 맞았는지도 확인할수있음
	즉 어떤역할을 하는지 이해됐지만 이름이 직관적이지않은 변수는 적절한이름으로 바꿔주고,긴함수를 잘게 나누고있으면,
	코드가 깔끔하게 정리되어 설계가 눈에 들어오기시작함
	
	그리고 코드를 파악하던중 이상한부분을 찾으면(로직이 쓸데없이 복잡하거나,매개변수하나면되는데 여러개쓸때),간단한일이면 즉시 고치고
	복잡한일이면 메모만 남기고 하던거 끝내고나서 처리하는식(쓰레기줍기 리팩터링)
	리팩터링은 어짜피 코드가 깨지면안되니까,조금씩해도 코드에 영향을 안주고 할수있음
	
	리팩터링을 날잡고 하는게 아닌(물론 안했으면 이렇게해야할수도있음,그래도 최대한줄여야함),
	평상시에 기능을 추가하거나 버그를 잡는동안 리팩터링도 같이 하는게좋음
	잘 작성된 코드도,다른코드가 추가되면서 리팩터링해야할수도 있게되고 그럼
	이때도 잘 작성되면 리팩터링도 쉬워짐
	
	라이브러리를 교체하는등 큰규모의 리팩터링을 할떈,기존것과 새것을 모두 포용하는 추상인터페이스부터 만들고,
	기존코드가 추상인터페이스를 호출하게하고나면 라이브러리교체가 훨씬 쉬워짐(추상화로 갈아타기)
	
	코드리뷰할때도 리팩터링하는게 도움이됨,실제로 코드가 더 나아지기도하고 더 명확한 결과로 보이니까
	
	그리고 굳이 수정할필요가 없다면 리팩터링하지않아도됨
	외부api호출하는거처럼 쓰는 코드면 걍 둬도되고,내부동작을 이해해야할때 리팩터링하면됨
	그리고 리팩터링보다 처음부터만드는게 쉬워보이면 걍 새로만드는게나음
	
  5.리팩터링시 고려할문제
    리팩터링이 필요해보이지만,추가하려는 기능이 매우작을땐,그냥 각보고 하는게 맞는데,이럴때도 보통은 리팩터링하는게 맞는선택일 확률이 높음
	새기능을 추가해넣는게 더 쉬워지는 리팩터링이 보이면 리팩터링하는게 나음
	반면 건드리지않아도 기능추가랑 상관없거나,그렇게 불편하지않으면 걍 기능추가함	
	리팩터링은 단순히 기능추가를 더 쉽게하기위해서+처음볼때 이해하기쉽게 하기위해서 하는거임
	
	코드소유권은 빡빡하게 관리하는게 아닌 팀단위로 느슨하게 관리하는게 리팩터링하기쉬움(함수명변경같은거 귀찮아짐)
	
	브랜치따서 작업할때도 계속 풀한뒤에 푸시하는,ci를 반복해야 나중에 합치기가 쉬움
	이걸 각자 최소 하루한번은 해야함
	이렇게하면 머지도 쉬워지지만 리팩터링과 궁합도 좋음(익스트림프로그래밍)
	
	리팩터링의 가장 큰 특성은 겉보기동작이 똑같이 유지된다는것
	만약 실수를 저질렀는데 해결이 안된다면 이전커밋으로 돌아가면됨
	이떄 가장 중요한건,테스트스위트가 잘되어있어야 검사를 믿을수있고,버그를 걱정하지않게됨
	
	레거시시스템을 파악할떄도 리팩터링이 도움됨,근데 이때도 테스트가없으면 리팩터링을 할수없음
	이때는 테스트를 보강해서 리팩터링을 하면서 이해해야하는데,어려운문제임 그래서 테스트를 잘 적어둬야함
	테스트가 있어도 복잡한애들은 어려운데,이때는 한부분씩 나눠서 하나씩 처리하는게 그나마쉬움
	그리고 이때는 자주 보게되는부분을 더 많이 리팩터링하는게 효율적임
	
	db를 리팩터링할때는 데이터마이그레이션스크립트를 작성하고,모든 변경을 이거로 처리하는식으로 하면 할수있음
  
  6.리팩터링,아키택처,애그니
	리팩터링은 미래의 요구사항을 추측하지않고,현재 필요한거만 처리하면서 확장성을 남겨둬서 미래에 확장을 쉽게만듬
	호출할때 항상 같은값을 넘기는 매개변수는 매개변수에서 제거하는식(애그니)
  
  7.리팩터링과 개발프로세스
	팀으로 개발할때 리팩터링을 하려면,각 팀원이 다른사람의 작업을 방해하지않으면서 언제든 리팩터링할수있어야함
	그래서 ci가 필요하고,팀원 각자가 수행한 리팩터링결과를 빠르게 동료와 공유할수있음
	즉 테스트코드,ci,리팩터링 3가지를 같이쓰면 상승효과가 있음
	이 3개를 쓰면 애그니방식으로 개발할수있고,애그니는 또한 리팩터링을 더 쉽게만들어줌(추측보단 단순한시스템이 변경이 쉬움)

  8.리팩터링과 성능
	프로그램의 케이스마다 이건 선택을 다르게해야함
	일반적으론 리팩터링하고,성능이 필요할때 성능최적화를 하는게 효율적임
	성능최적화를 할땐 항상 검증하고 검증결과를 바탕으로 어디서 성능을 많이쓰는지를 확인한후에 변경을 해야함(컴파일러동작을 예측하기어려우니)
	
3.코드에서 나는 악취
  1.기이한 이름
	함수와 변수명,클래스명등은 항상 단순하고 명료해야함
	해당 이름만 보고도 무슨일을할지 명확히 알수있어야하고,여기에 신경을 많이써야함
	그리고 마땅한 이름이 떠오르지않는다면,설계에 문제가 있을수있음
	
  2.중복코드
	같은 코드가 여러곳에서 반복되면,하나로 통합해야함
	이때는 함수추출후 해당 메서드를 호출하게하면됨
	만약 비슷한데 완전히 똑같진않으면,문장슬라이드로 비슷한부분을 한곳에 모아 추출할수있는지를 확인하고,
	같은부모로부터 파생된 서브클래스의 중복코드는 부모쪽으로 메서드를 올리면됨
	
  3.긴 함수
	함수가 길면 이해하기가 어렵고,이름붙이기도 힘듬
	함수가 짧으면 좋은건,해당 메서드의 행동에 대한 명확한 정의(이름)를 내릴수있다는것
	함수이름은 동작방식이 아닌 의도를 드러내게짓고,이런 함수들을 묶는 함수를 만드는식으로 조립해야함
	이건 함수추출로 거의 다 할수있고,함수가 매개변수와 임시변수를 많이 사용하면 추출에 방해가되니,
	임시변수를 질의함수로 바꾸고,매개변수객체만들기와 객체통째로 넘기기를 사용해서 매개변수의 수를 줄이고
	그래도 많으면 좀 큰수술인 함수를 명령으로 바꾸기를 고려할수있음
	
	긴함수는 주석이 있는곳을 분리하는식으로 하는게 편하고(이때 함수명은 해당주석을 참고하면됨),조건문이나 반복문도 추출하기좋음
	조건문은 조건문분해하기를 사용하고,스위치문은 각 케이스마다 함수추출을 하고,같은조건을 기준으로 나뉘는 스위치문이 여러개면 다형성으로 변경
	반복문은 그안의 코드와 같이 추출해서 독립된함수로 만들면됨,이떄 이름이 떠오르지않으면 성격이 다른 두가지작업이 섞여있어서 그럴수있음
	이때는 반복문쪼개기를 사용
	
  4.긴 매개변수 목록
	파라미터가 많으면 많을수록 함수이해는 어려워짐,만약 다른 매개변수에서 데이터를 뽑을수있다면,이건 매개변수를 질의변수로 바꾸기로 제거할수있고
	특정 클래스에서 값을 뽑아서 넣고있으면 객체를 통째로 넘겨버릴수있고,항상 함께 전달되는 매개변수들은,이것들을 묶어 객체로 만들수있음
	함수의 동작방식을 지정하는 플래그변수는 제거하는게좋음
	보통 클래스를 만들거나 해서 날려버리는게 많음
	
  5.전역데이터
	전역변수는 가급적 사용하지않는게 좋고,그나마 불변데이터까진 괜찮은데 가변데이터는 사용하면안됨
	어쩔수없이 사용해야하면,전역변수를 클래스로 감싸고 싱글톤으로 만든후,해당 클래스의 메서드로만 변수를수정할수있게 해서(protected set)
	어디서 수정했는지는 알수있게 할수있음
	
  6.가변데이터
	가변데이터는 값이 빠르게 상하니까 가급적이면 불변데이터를 사용하는게좋음
	가변데이터를 쓸때도 직접 데이터를 오픈하는게 아닌,메서드를 거쳐서 수정하게 하는게 나중에 문제생기거나했을때 찾기쉬움
	그리고 하나의 변수에 용도가 다른값들을 저장하면,변수쪼개기를 써서 용도별로 변수를 만드는게 낫고
	갱신로직은 다른코드와 떨어져있는게 좋음,이땐 문장슬라이드와 함수추출로 분리해내면됨
	api를 만들때는 질의메서드와 변경메서드를 분리해서,둘중 하나만 할수있게(cqrs)만드는게좋음
	
	값을 다른곳에서 수정할수있는(외부에서)애들은 특히머리아픔,이때는 파생변수를 질의함수로 바꾸는게좋음
	
  7.뒤엉킨 변경
	뒤엉킨변경은 srp(단일책임원칙)가 제대로 지켜지지않을때 나타남
	하나의 모듈이 서로 다른 이유로 여러가지방식으로 변경되는일이 많을때 발생함(지원db를 추가하는데 함수를 3개씩바꿔야하고 이런거)
	이럴땐 다음맥락에 필요한 데이터를 특정객체에 담아 전달하게하는식으로 단계를 분리하고(단계쪼개기),
	곳곳에서 각기 다른맥락의 함수를 호출하는 빈도가 높으면 각 맥락에 해당하는 모듈을 만들어서 관련함수들을 모으면됨(애그리거트별로 분리)
	이러면 각 모듈은 하나의 일만 하게됨
	모듈이 클래스면 클래스추출하기를 하면됨
	
  8.산탄총 수술
	이건 뒤엉킨변경과 비슷한데 정반대임,원인과 해법은 같은데 현상과 해법이 다름
	뒤엉킨변경이나 산탄총수술이나 원인은 맥락구분을 못한거고,해법도 맥락구분을 잘하는건데,
	뒤엉킨변경은 이 맥락들이 한코드에 섞여들어가는거고 산탄총수술은 여러코드에 흩뿌려진것
	즉 이건 코드를 변경할때 자잘하게 수정해야하는클래스가 많을때 생김
	해법도 뒤엉킨변경은 맥락들을 분리해주는거고,산탄총수술은 맥락들을 모아줘야하는거
	
	맥락을 모아야 변경이 쉽고,빼먹는걸 방지해줌
	이땐 함수옮기기와 필드옮기기로 함께 변경되는대상을 한 모듈로 묶어주고,비슷한데이터를 다루는 함수가 많으면 여러함수를 클래스로 묶어주면됨
	데이터구조를 변환하거나 보강(js용)하는 함수들은 함수들을 변환함수로 묶을수있음
	또한 어설프게 분리된 로직을 함수인라인이나 클래스인라인으로 합치는거도 좋은방법일수있고,이렇게 합치면 커지지만 이러면 나중에 추출이 더 깔끔하게됨
	즉 합치고나서 다시 맥락에맞게 쪼개면됨
	
  9.기능 편애
	프로그램을 클래스별로 나누고나면,클래스내부에선 상호작용을 최대한 늘리고,클래스끼리는 최소로 줄여야하는데
	기능편애는 클래스내부보다 클래스 외부와의 통신을 더 많이할때 발생함
	이럴땐 해당 메서드를 해당 외부클래스로 옮기거나,만약 해당 메서드의 일부에서만 그런다면 해당부분을 추출한다음 그부분만 옮기면됨
	즉 게터를 12개씩 호출한다면 해당 호출부분을 추출해서 해당 클래스로 옮기면됨
	이때 여러클래스에서 조금씩 호출한다면 가장 많은 데이터를 포함한곳으로 옮기거나,각 모듈마다 추출을 쪼갠뒤에 각각을 해당모듈로 옮길수도있음
	
	단,전략패턴이나 방문자패턴처럼 해당규칙을 거스르는패턴도 있음,얘들은 뒤엉킨변경을 제거할때 활용하는패턴들임
	보통은 데이터와 이 데이터를 사용하는동작은 한곳에 있는게 좋지만,예외일때는 같은데이터를 다루는 코드를 한곳에서 변경할수있게 옮기는것
	
  10.데이터뭉치
	서로 항상 같이다니는 데이터들은 클래스로 묶고,만약 해당데이터들을 사용하는 메서드들이 있으면 해당클래스로 이동시키면 엔티티를 만들수있음
	이때 데이터뭉치인지 판별하려면,어떤 데이터 하나를 삭제하면 다른데이터들이 다 의미없어지면 데이터뭉치임
	
  11.기본형집착
	모든걸 기본형으로 해결하려하지말고,기본형을 객체로 바꾸는게좋음(인트대신 화폐,스트링대신 이메일)
	기본형코드가 조건부동작을 제어하는 타입코드로만 쓰였으면,타입코드를 서브클래스로 바꾸기와 조건부로직을 다형성으로 바꾸기를 차례로 적용하면됨
	여기서도 데이터뭉치가 자주 생기니,클래스추출하기와 매개변수객체만들기로 뽑아낼수있으면 뽑아내는게좋음
	
  12.반복되는 스위치문
	스위치문은 특히 중복일때 문제가됨,스위치문이 중복이면 조건절을 하나 추가할때마다 다른스위치문도 모두 수정해야하기때문
	이런애들을 최우선적으로 추출해내고,다형성으로 바꾸는게좋음
	
  13.반복문
	반복문은 가급적이면 파이프라인(필터나 맵등)으로 바꾸는게좋음,이게 더 이해가 쉬움
	
  14.성의없는요소
	만약 해당 함수가 추출할이유가 없거나,별이유없이 메서드가 하나뿐인 클래스같은건 그냥 제거하는게좋음
	이때 함수인라인하기나 클래스인라인하기로 처리할수있고,상속을 사용했으면 계층합치기를 사용할수있음
	
  15.추측성 일반화
	나중에 필요할거야라는 생각으로 작성해둔 코드들은 쓸데없는 낭비임
	당장 현재필요한것들만 사용하고,확장만 가능하게 해두는게 제일 좋음
	
	하는일이 거의없는 추상클래스는 계층합치기로 제거하고,쓸데없이 위임하는코드는 함수인라인이나 클래스인라인으로 삭제
	본문에서 사용되지않는 매개변수는 함수선언변경으로 제거
	보통 테스트코드에서만 사용하는 코드들은 이런경우가 많음,테스트부터 제거한다음 제거하자
	
  16.임시필드
	만약 특정상황에서만 값이 설정되는 필드들은,객체를 가져올때 이해하기힘듬
	이런필드들은 클래스추출하기로 뽑아낸후,해당필드들을 사용하는 메서드들은 함수옮기기로 옮겨버리면됨
	그리고 임시필드들이 유효한지 확인한후 동작하는 조건부로직들은 특이케이스 추가하기로 대안클래스를 만들어서 제거할수있음

  17.메시지체인
	메시지체인은 abc.getUser().getEmail().getSite() 이런식으로 체인타는걸 말함
	이건 클라가 객체내비게이션구조에 종속됐음을 의미하고,네비게이션중간을 수정하면 클라코드도 수정해야함(email에서 getSite를 변경하면 다바꿔야함) 
	이런건 위임숨기기로,user에서 site를 뽑아내는 메서드를 만들고,해당 메시지체인을 거기다가 넣고 쓰는식으로 할수있음
	이건 이런식으로 사용하는애들이 여러명일때 이렇게 처리하고,걍 한두개면 저대로써도됨

  18.중개자
	객체의 캡슐화에선 위임이 자주 활용되는데,이게 선을넘어서 클래스의 메서드 절반이상이 구현을 위임하면 중개자를 제거하고 직접 통신하게하는게나음
	만약 위임메서드를 제거한후 남는일이 거의없어지면 호출하는쪽으로 인라인하면됨
	
  19.내부자 거래
	서로간에 은밀하게 데이터를 주고받는 클래스들이 있다면,함수옮기기와 필드옮기기로 떼어내고,
	여러모듈이 같은 관심사를 공유하면 해당부분을 새클래스로 만들거나,위임숨기기로 다른모듈이 중간자역할을 하게만듬
	
	상속에서 부모자식사이의 결탁이 생길때는,서브클래스를 위임으로 바꾸거나,슈퍼클래스를 위임으로 변경해서 대응
  20.거대한클래스
	클래스가 너무 많은일을 하려고하면 중복코드가 생기기쉽고 필드수가 늘어남
	이때는 클래스추출하기로 필드일부를 묶고(서로 같이있을만한애들끼리),떼어낸다음 해당 필드들의 메서드를 옮겨주면됨
	보통 같은 접두사나 접미사가 붙은애들을 떼어내기좋음
	
	만약 이게 상속관계가 깔끔할거같으면 슈퍼클래스추출하기나 타입코드를 서브클래스로 바꾸기를 사용하면됨
	
	보통 클래스가 모든필드를 사용하지않으면 분리해야할수있고,그냥 단순히 중복이 많아서 커보일수도있음
	일단 중복부터 제거하고생각
	클래스의 메서드들이 특정필드만 사용할경우,해당필드들을 묶을수있나 볼수도있음
  21.서로 다른 인터페이스의 대안클래스들(js용)
	덕타이핑언어에서 묶을클래스들의 인터페이스를 최대한 맞춰주고,함수옮기기로 없는애들채우고,중복이 생기면 슈퍼클래스추출하는거
	
  22.데이터클래스
	데이터클래스는 퍼블릭필드를 제거하고,변경하면안되는필드는 세터를 제거하고,
	다른클래스에서 데이터클래스의 게터세터를 사용하는메서드는 데이터클래스로 옮길수있나 생각해보자(코틀린에선 불변이라 신경안써도됨)
	
	또한 데이터클래스는 필요한동작이 엉뚱한곳에 정의되어있다는 신호일수있음,이땐 클라코드를 데이터클래스로 옮기기만해도 개선됨
	단,다른함수를 호출해 얻은 결과레코드로는 동작코드를 넣을이유가없음(단계쪼개기의 결과로 나온 중간데이터등)
	
	데이터클래스는 불변으로 사용하는게 좋음

  23.상속 포기
	서브클래스가 슈퍼클래스의 메서드 일부만 사용하는경우엔 새로운 서브클래스를 만들고,
	거기로 모든코드를 넘긴다음 공통부분만 부모쪽에 남길수있는데,이경우 좀 복잡해서 선호하지않음
	걍 서브클래스가 슈퍼클래스의 일부만 써도되긴하는데,이때 무조건 부모의 인터페이스는 따라야함
	이것도 싫으면 상속이 아닌 위임으로 바꾸는게좋음
	
  24.주석
	가급적 주석보단 해당부분을 추출해서 메서드명에 정보를 담거나 하는게 좋음
	즉 주석을 달고싶어지면 추출하자
	주석은 뭘할지 모를때나 확실하지않은부분등을 다는거지,코드를 설명하는거로 다는건 별로좋지않음

4.테스트 구축하기
	테스트의 핵심은 회귀문제를 빠르게 잡아내는것
	테스트를 만들땐 테스트가 실패하는걸 한번씩은 확인해야함
	테스트는 모든 퍼블릭메서드를 검사하는게 아닌,비즈니스로직(유닛테스트)과 컨트롤러(통합테스트)만 검사해야함
	간단한코드는 테스트할필요없음(게터세터등)
	즉 만들려면 확실히 만들고,필요없어보이면 아예손안대면됨
	
	테스트의 중복은 허용하고,테스트끼리 상호작용하게하는 공유픽스처가 생기면 안됨(즉 테스트전역으로 뭐가생기면안됨)
	차라리 beforeEach로 생성하는거까진 괜찮음,이건 표준픽스처를 만들수있어서 쓸모있음
	
	각 테스트는 하나의 속성만 검증하는게좋음
	
	테스트는 성공테스트만이 아니라 실패테스트도 있어야함,이때 경계조건을 검사하는게 중요(이부분을 집중적으로 테스트해야함)
	
	버그리포트를 받으면 가장 먼저 그 버그가 나오는 테스트케이스부터 만들고,해결하면됨
	
5.리팩터링 카탈로그
	스킵
6.기본적인 리팩터링
  1.함수 추출하기
	컨트롤알트m,이걸 사용할때는 코드를 보고 무슨일을 하는지 한참 걸린다면,해당부분을 분리해서 이름을 붙일때 사용됨(한줄이라도 이 이유로 분리할수있음)
	즉 구현과 인터페이스를 분리할수있어짐,즉 코드에 이름을 붙이는게 가장 큰 장점임
	이때 어떻게가 아닌 무엇을 하는지가 드러나는 이름을 붙여야함
	
	이때 내부에서 받아야하는건 매개변수로 받고,내부에서 계산해서 내보내야하는건 리턴값으로 내보내면됨
	그리고 만약 해당메서드(분리전의 원본)의 매개변수를 변이해야한다면,그 변수를 쪼개서 임시변수를 만들어서 대입해야함
	
	만약 변수가 초기화되는시점과 사용되는시점이 떨어져있으면,이 분리할 함수쪽으로 붙인뒤에 추출하면됨
	이때 반환해야하는 값이 여러개라면,
		각각을 반환하는 함수 여러개로 만들기
		임시함수를 질의함수로 바꾸기
		변수쪼개기
		값들을 레코드로 묶어서 반환하기
	여기서 위에서부터 밑으로 우선순위잡고 선택하면됨

  2.함수인라인
	함수본문이 이름만큼 명확하다면 함수를 추출할필요가 없음
	해당부분을 다시 넣는게 더 명확함
	보통 리팩터링과정에서 잘못추출된 함수들을 다시 인라인한뒤,필요하다면 원하는형태로 다시 추출하는식으로 사용됨
	
	또한 간접호출이 과할경우,위임만 하는게 너무 많을때도 인라인해버림
	
	이때 서브클래스에서 오버라이드하는 메서드는 인라인하면안되고,여러군데서 사용하는 메서드면 다 인라인을 해줘야함(이때 하나넣을때마다 테스트돌리는게좋음)
	
  3.변수 추출하기
	표현식이 너무 복잡할경우,변수를 추출해서 이름을 붙이는게 알아보기힘듬
	이러면 각 단계마다 이름을 붙일수있어서 코드의 목적이 훨씬 명확해짐
	
	그리고 만약 해당 변수가 현재함수내에서만 의미가 있으면 변수로 추출하면 끝이지만,함수 외부까지 의미가 된다면 함수로 추출하는게 좋음
	이러면 다른곳에서 재사용할수있기때문
  
  4.변수 인라인하기
	추출된 변수의 이름이 표현식과 별 다를바없거나,주변코드를 리팩터링할때 방해가되면 다시 인라인해서 넣어버리면됨
	해당부분을 사용하는 코드 하나를 찾아서 변경한후 테스트해보고,계속 반복하면됨
	
  5.함수선언 바꾸기	
	그냥 단순하게 함수명을 더 명확하게 바꾸던지,매개변수를 추가하거나 제거하는거임
	만약 함수를 읽다가 더 명확한 이름이 떠오르면 즉시 이름을 바꿔야함(또는 의미가 와닿지않는 이름을 발견해도)
	또한 매개변수는 함수가 외부와 어우러지는 방식인데,이 매개변수는 함수를 사용하는 문맥을 결정함
	이 매개변수로 활용범위를 넓힐수있고,다른모듈과의 결합을 제거할수있음
		ex.전화번호포맷팅에서 사람객체를 받는거보다 전화번호를 받는게 사용하기 더편하고 커플링도 줄어듬
	즉 매개변수로 해당 객체를 지정하면,해당객체의 인터페이스와 결합되는대신 해당객체의 속성에 접근이 쉬워져서 캡슐화가 올라감
	이때 객체의 다른 속성에 접근하지않을거면 해당객체의 하위속성을 받는게 낫다는거
	
	그리고 이름변경과 매개변수추가를 동시에하고싶으면,하나하나 따로하는게 되돌리기편함
	
  6.변수 캡슐화하기
	함수는 데이터보다 다루기가 편함,함수를 쓴다는건 호출한다는거고,이름을 바꾸거나 다른모듈로 옮기기도 쉬움
	데이터는 함수보다 까다로운데,데이터는 데이터를 참조하는 모든부분을 한번에 바꿔야하기때문
	그래서 접근범위가 넓은 데이터를 옮길땐,해당 데이터로 접근을 독점하는 함수를 만드는식으로 캡슐화하는게 좋은방법일때가 많음
	즉 데이터재구성이라는 작업을 함수재구성이라는 더 쉬운작업으로 치환하는것
	
	또한 리스트같은 얕은복사를 리턴해주는애들을 깊은복사를 리턴해줄수도있고,게터와 세터를 사용할때 추가작업을 처리할수도있음
	
	또한 데이터가 함수화되어있으면 해당데이터에 접근하려면 함수를 무조건 콜해야하기때문에,그런부분을 찾기도 쉬움
	보통 메서드내부나 클래스내부에서 접근하는 가변데이터는 그냥 쓰고,그 외부로 나가면 캡슐화하는게 맞음
	그리고 불변데이터는 캡슐화할 이유가 크지않음
	
	할때는 일단 함수를 만들고,모든 참조를 수정하고,가시범위를 변경해서 빼먹은거없나 확인하면됨
	유의할건,복제본만들기와 클래스로 감싸기는 레코드구조에서 뎁스가 1인경우까지만 효과가있음(List<Int>)2이상이면 복잡해짐
	
  7.변수 이름 바꾸기
	이름은 사용범위가 커질수록 더 잘지어야함
	한줄짜리 람다식같은데에는 i나 a같은거도 상관없지만 길게 사용하면 이름을 잘지어야하고,영속되는 필드라면 특히 더 신경써야함
	그냥 해당메서드내부에서만 쓰는거면 걍 바꾸면되고,함수밖에서도 참조할수있다면 변수캡슐화하기로 빼는게나음

  8.매개변수 객체만들기
	매개변수들이 만약 맨날 같이다니는(범위를 나타내거나 할때)애들이면,얘들을 묶어서 클래스로 만들어서 사용하는게 더 명확함
	추가적으로 클래스가 생기니 해당 클래스에 해당 매개변수들이 하는 행동들을 메서드로 넣어서 중복을 제거할수도있고 재사용이 가능해짐
	
	보통 min,max같이 범위를 나타내거나 하는애들이 주로 대상이됨
	
  9.여러함수를 클래스로 묶기
	공통데이터를 중심으로 긴밀하게 엮여 작동하는 함수들은 해당 데이터들과 함수들을 묶어서 클래스로 만들면 좋음
	이러면 함수들의 매개변수도 줄일수있고,다른곳에서 참조하기도 좋음(중복제거)
	
	또 다른방법으로는 여러함수를 변환함수로 묶는거도 있는데,두개는 문맥을 넓게보고 선택해야함
	클래스로 묶을땐 클라가 객체의 핵심데이터를 변경할수있고,파생객체들을 일관되게 관리할수있음
	
	이걸 할때는 
		공통데이터를 일단 캡슐화하고
		공통데이터를 사용하는 함수 각각을 새클래스로 옮기고
		데이터를 조작하는 로직들은 함수로 추출해서 새클래스로 옮기면됨
	즉 데이터부터 옮긴다음에,해당 데이터를 사용하는걸 싹 다 새클래스로 옮기고 사용하는부분에서 해당클래스를 생성해서쓰면됨
	
  10.여러 함수를 변환함수로 묶기
	같은 변환로직(111을 'oneoneone'이런식으로)을 여러곳에서 사용한다면 해당 작업들을 묶어서 변환함수로 만들수있음
	보통 해당데이터가 있는 클래스에 해당변환로직이 없어서 각각의 개발자마다 함수를 만든거니까 묶어주는것
	이건 원본데이터를 입력받아서 중간계산을 끝내고 각각을 출력데이터필드에 넣어서 반환하는것
	이러면 해당변환로직에 문제가 생기면 해당변환로직만 보면됨
	
	여러함수를 클래스로 묶기랑 비슷한데,원본데이터가 코드안에서 갱신될때는 클래스로 묶는게 나음,변환함수는 새레코드에 저장해서 일관성이 깨질수있기때문
	
	이게 단순 함수추출이랑 비슷하지만 다른게,함수추출은 데이터구조와 이를 사용하는 함수가 근처에 없어도되는데,
	변환함수로 묶으면 데이터구조와 같이 둘수있어서 찾기가 쉬워짐
	즉 중복해서 해당코드를 만드는걸 방지할수있음
	
	이때 변환함수의 리턴값은 깊은복사로 처리하는게좋음(불변이면 상관없지만)
	
  11.단계 쪼개기
	서로 다른 두 대상을 한꺼번에 다루는 코드를 발견하면,각 대상을 별개의 모듈로 나누는게 좋음
	이러면 코드를 수정할때 신경써야할게 하나로 줄어듬
	이럴때 유용한게 한가지 동작을 연이은 두 단계로 쪼개는것
	즉 데이터를 선가공한다음 로직수행하는 메서드면,데이터가공과 로직을 각각 함수추출해내는것
	
	할땐
		두번째에 해당하는 코드를 함수로 추출(데이터가공보다 이게 더 먼저뺴기쉬움)
		중간데이터구조를 만들어서 앞에서 추출한 함수의 인수로 추가(선가공한 데이터)
		그후 첫번째에서만 사용하는 데이터를 인수에서 제거
		첫번째코드를 함수로 추출하면서 중간데이터구조를 반환하게함
	이런식으로 하면됨
	
	이때 테스트하기 불편한작업과,자주테스트해야할 복잡한로직을 분리(험블객체패턴)하면 테스트가 쉬워짐
	

7.캡슐화
  1.레코드 캡슐화하기	
	데이터들을 묶어서 사용하면,각각을 따로 취급할때보다 훨씬 더 의미있어짐(pair같은거)
	단,계산해서 얻을수있는값과 그렇지않은값을 구분해야하는게 귀찮음,
	그래서 레코드대신에 해당 데이터들을 객체에 넣어서 쓰면 계산해서나온값이든 걍 필드값이든 구분하지않고 쓸수있음(게터커스텀)
	추가적으로 게터를 거쳐서 출력하니,중간에 로깅같은거넣기도 편하고
	이러면 사용자는 계산값인지 필드값인지를 알필요도 없고 그냥 가져다가쓰면됨
	특히 가변데이터일때 유용함(불변이면 걍 저장한후에 복제하면되니까 좀 유용성이 떨어지긴함,그래도 이름붙일수있지만)
	
	그리고 필드의 이름과 게터의 이름을 다르게 가져갈수있다는거도 장점	
	중첩된 리스트나 해시맵을 받아서 json으로 변환할때도,이런 구조를 캡슐화해두면 나중에 포맷바꾸기랑 추적하기어려운 데이터를 수정하기가 쉬워짐
	
	할때는
		레코드를 담은 변수를 캡슐화
		레코드를 담은 단순한 클래스로 해당변수내용을 교체후 해당변수를 사용하던애들도 교체후 테스트
		원본레코드대신 새로 정의한 클래스타입의 객체를 반환하는 함수를 새로만듬
		레코드를 반환하는 예전함수들을 해당클래스를 반환하게변경
		레코드의 필드도 데이터구조인 중첩구조라면,레코드캡슐화하기와 컬렉션캡슐화하기를 재귀적으로 적용
	이렇게 하면됨,그냥 레코드를 변수처럼 캡슐화한다음,해당레코드를 사용하던곳을 다 변경하고,해당레코드를 반환하던애들도 다 변경하면됨
	재귀타야할때는,내부의 데이터를 수정할수있는 세터를 만들어두면편함(유니크값을 키로 검색하는느낌으로)
	그리고 내부데이터는 깊은복사로 던져줘야함,아니면 세터를 안거치고 수정할수있어짐(캡슐화깨짐),아니면 불변객체로 던져도되긴함
	
  2.컬렉션 캡슐화하기
	가변데이터는 모두 캡슐화하는게 좋고,컬렉션도 다 캡슐화하는게 좋음
	이때 주의해야할건 게터가 컬렉션자체를 반환하면,
	그 컬렉션을 감싼 클래스가 눈치채지못하는 상태에서 컬렉션원소가 바뀔수있음(코틀린은 val에 list쓰면 안날듯)
	
	그래서 컬렉션을 감싼 클래스에 add나 remove같은 컬렉션변경자 메서드를 만들고,해당메서드를 통해서 변경이 일어나게해야함
	그리고 컬렉션자체를 반환할때는,깊은복사를 해서 던져주는방법도있음
	
	컬렉션은 강박적으로 불필요한 복제본을 만드는게,예상치못한 수정이 버그를 만드는거보다 나음

  3.기본형을 객체로 바꾸기
	단순한 기본형도 객체로 바꿔야할수도있음
	단순한 출력 이상의 기능이 필요해지는순간,그 데이터를 표현하는 전용클래스를 정의하는게 좋음
	즉 전화번호를 문자열로 표현했는데,나중에 포맷팅이나 지역코드추출같은 추가동작이 생기는 시점에서 뽑아내면됨
	
  4.임시변수를 질의함수로 바꾸기
	함수내부에서 재참조를 위한 임시변수가 있고,만약 다른곳에서 사용할거같으면 해당 임시변수를 함수로 뽑아내면 다른곳에서도 같이 사용할수있음
	이러면 일단 중복이 없어지고,추출한 함수와 기존함수와의 경계가 분명해져서,부자연스러운 의존관계나 부수효과를 찾기 쉬워짐 
	이건 클래스안에서 적용할때 효과가 가장 큼,이경우엔 추출한 메서드들이 공유필드를 사용할수있기때문(필드를 매개변수로 안받아도되니)
	
	주의점은,이때 변수는 값을 한번만 계산하고 그뒤로는 읽기만(불변)해야함,그래서 옛날주소처럼 스냅샷용도로 사용하는 변수는 빼면안됨 
	
  5.클래스 추출하기
	클래스가 너무 비대해지거나,역할이 크게 나눠지면,클래스를 추출해내야함,안그러면 굉장히 복잡해짐
	이때 일부데이터와 메서드를 따로 묶을수있다면 분리하라는 신호니까 분리하면되고,함께 변경되는일이 많거나 서로 의존하는데이터도 분리하면됨
	이떄 특정 데이터나 메서드 일부를 제거해도 다른 필드나 메서드들에 문제가 안생긴다면 분리하면됨
	또한 서브클래스를 작은 일부의 기능만을 위해 만들거나,확장해야할 기능이 무엇이냐에 따라 서브클래스를 만드는 방식이 달라졌다면 나눠야하는신호임
	
  6.클래스 인라인하기
	클래스인라인하기는 클래스 추출하기를 취소하는 리팩터링임
	만약 리팩터링들의 결과로 특정클래스에 남은역할이 거의없어지면,다른 클래스와 합병시켜주는거임
	또한 두 클래스의 기능을 지금과 다르게 배분하고싶을때도 인라인한후 다시 추출하는게 더 쉬울수있음(케바케)
	
	이때 옮길쪽으로 현재 클래스의 모든 퍼블릭메서드를 위임하는메서드를 만들고,
	해당부분을 사용하는걸 전부 위임메서드로 치환한후 메서드와 필드를 옮기면됨(하나옮길때마다 테스트)
	
  7.위임 숨기기
	위임받은객체는 외부에 공개하지않는게 좋음,위임객체의 메서드는 해당 클래스의 메서드로 감싸서 위임객체의 존재를 숨길수있음
	이러면 위임객체를 수정해도 클라는 아무 영향을 받지않음

  8.중개자 제거하기
	이건 위임숨기기의 반대인데,만약 위임메서드가 너무 많아질경우엔(계속 클라가 요구하는기능이 늘어나서),
	그냥 위임을 풀고 클라가 위임객체를 직접 쓰라고 하는게 나을수있음
	이건 그냥 위임객체를 얻는 게터를 만든후에,위임메서드들을 사용하는 클라쪽을 전부 위임객체를 직접얻어쓰게 바꾸고,
	위임메서드를 전부 삭제하면됨
	
  9.알고리즘 교체하기
	특정 로직이 함수 하나에 전부 들어있을경우(구현은 각각 나눠져있어도 통합해서 콜하는 함수,즉 컨트롤러함수),알고리즘을 변경하기가 쉬워짐
	해당 함수테스트를 만들고나서,로직을 변경하고 테스트가 성공하면 교체가 성공한거임
	그래서 로직에서 일정부분의 알고리즘만 수정했어도,해당함수테스트가 성공하면 아무문제없는거

8.기능 이동
  1.함수 옮기기
	만약 특정 함수가 자기클래스내의 함수나 필드보다,다른 클래스의 함수나 필드를 더 많이 참조한다면,그쪽으로 옮기는게 나음
	또한,다른 함수 안에서 도우미역할로 정의된 함수중,독립적으로도 가치가 있으면 더 접근하기 쉬운장소(따로 클래스뽑는다거나)로 옮기는게 나음
	
	옮기는거 자체는 쉽지만,옮길지 말지를 정하기는 어려운데,그땐 대상함수의 현재컨텍스트와 후보컨텍스트를 둘러보고,
	해당함수를 호출하는 함수들은 무엇인지,해당 함수가 호출하는 함수들은 무엇인지,해당 함수가 사용하는 데이터는 무엇인지를 살펴봐야함
	이러면 아예 새 컨텍스트가 필요해질수도있는데,그럴땐 클래스추출하면됨(보통 선택이 어려우면 큰문제가 아니고,큰문제면 딱 보임)
	
	보통 옮기고 나서도 원래클래스에서도 해당 메서드를 꽤 사용하고있으면,그럴땐 위임메서드를 만들어서 해당 메서드를 자기필드값을 넣어서 호출하게하면됨
	이후에 이 메서드를 인라인할지 남겨둘지를 정하면됨

  2.필드 옮기기
    현재 데이터구조가 적절하지 않다고 판명되면 즉시 수정해야함,걍 두고 땜빵하면 나중에 복잡해지기때문
	만약 함수에 어떤 클래스를 넘길때마다 또 다른 클래스의 필드도 같이 넘겨야하면 데이터의 위치를 옮겨야하고,
	함수에 항상 함께 건네지는 데이터조각들은 상호관계가 명확하게 드러나도록 한 클래스에 담아야함
	또한 한 클래스를 변경하려할때 또 다른 클래스의 필드까지 변경해야한다면 필드의 위치가 틀렸다는것
	
	필드옮기기는 대체로 더 큰 리팩터링의 일환으로 수행됨

  3.문장을 함수로 옮기기
	만약 특정 함수를 실행할때마다 앞뒤로 똑같은 코드가 추가로 실행된다면,해당 코드를 함수내부로 옮기면 반복을 제거할수있음
	또한 이 코드의 동작을 여러 변형으로 나눠야하는 순간이 오면 다시 함수에서 문장을 빼내면됨
	
	문장을 함수로 옮길땐,그 문장들이 피호출함수의 일부라는 확신이 있어야함,만약 한몸은 아니지만 여전히 함께 호출되어야한다면,
	그거까지 같이 또 하나의 함수로 추출하면됨
	
  4.문장을 호출한 곳으로 옮기기
	만약 여러곳에서 사용하던기능이 일부 호출자에게는 다르게 동작하게 바뀌어야한다면,달라진동작을 함수에서 꺼내 해당 호출자로 옮겨야함
	그래서 문장슬라이드하기로 달라지는동작을 함수의 시작이나 끝으로 옮기고나서 문장을 호출한곳으로 옮기면됨
	그 이후에는 필요할때마다 독립적으로 수정할수있음
	
	또한 복잡한상황에서는 이동하지않기를 원하는 모든 문장을 함수로 추출한다음,
	임시이름을 지어주고 원래함수를 인라인한다음 추출된 함수의 이름을 원래대로돌리면됨
	
  5.인라인 코드를 함수 호출로 바꾸기
	만약 인라인코드와 같은 동작을 하는 함수가 이미 있다면,해당부분을 함수호출로 바꾸면 중복이 제거됨
	즉 함수추출하기가 이미 다른곳에서 일어났을경우엔 그거 가져다쓰면된다는거
	예외는,우연히 비슷한 코드가 만들어졌을때,즉 기존 함수의 코드를 수정해도 인라인코드의 동작은 바뀌지않아야할때는 바꾸면안됨
	이때 코드위치에 해당함수명을 넣었을때 말이되면 바꾸고,좀 이상하면 안바꾸는식으로 판별하면됨(물론 함수명이 적절해야함)

  6.문장 슬라이드하기
	관련코드가 가까이 모여있으면 이해하기 더 쉬움,그래서 해당 코드들끼리 뭉치게 함수내부에서 이동시키는거
	보통 함수추출하기의 준비단계로 사용함,이때 모으고나면 동작이 달라지는 코드가 있다면 이 리팩터링을 포기함
		참조요소를 선언하는 문장 앞으로는 이동할수없음
		참조요소 뒤로는 이동할수없음
		참조요소를 수정하는 문장을 건너띄어 이동할수없음
		수정하는요소를 참조하는요소를 건너띄어 이동할수없음
	이런 제약이 있음(어려워보이지만 걍 코드옮길때 신경쓰던그거임)
	또한 변수는 맨위에서 다 선언하는거보다,해당 변수를 사용하는시점에서 선언하는게 더 보기편함
	
	추가적으로 조건문의 안팎으로 슬라이드할때,조건문 밖으로 슬라이드하면 각 조건문의 중복로직이 제거되고,
	안으로 슬라이드하면 각 조건문에 중복로직이 추가됨
  
  7.반복문 쪼개기
	반복문내에서 두가지이상의 작업을 동시에 처리하고있으면 그걸 반복문 두개로 나눠서 각각을 따로 처리하는게 더 알아보기편함
	또한 반복문내에서 두가지이상의 작업을 하고있으면,함수가 두가지이상의 일을 하고있을 가능성이 커서 쪼갠반복문을 함수로 추출할수있는지도 보는게좋음
	
	보통 반복문을 두번 실행해도 해당부분이 병목이되는일은 극히드뭄(컴파일러가 최적화하기도하고),그리고 쪼개고나면 다시 합치기도 쉬움
	
	하는방법은 단순히 반복문을 복제한다음,한부분씩을 각각 제거하면됨
	
  8.반복문을 파이프라인으로 바꾸기
	요즘은 반복문보다는 파이프라인(map등)으로 표현하는게 더 알아보기편함
	이걸 교체할땐,
		반복문에서 사용하는 컬렉션을 가리키는 변수(걍 복사해서만들면됨)를 하나 추가로 만들고
		반복문의 첫줄부터 각각의 단위행위를 적절한 파이프라인연산으로 대체하고(즉 하나씩 밖에서 미리 해당영역을 처리하는느낌),
		모든걸 대체했으면 반복문을 지우면됨
	이런식으로 교체하면됨

  9.죽은코드 제거하기
	코드가 아무곳에서도 사용하지않게되면,주석처리하는게 아닌 걍 지워버리는게 좋음
	어짜피 깃에 다 저장되니까 상관없고,애초에 다시 사용하는일도 거의없음

9.데이터 조직화	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	