1.계층형 아키텍처의 문제는 무엇일까?
  1.계층형 아키텍처는 db주도설계를 유도한다
	레이어드의 토대는 db임
	웹계층은 도메인(서비스+도메인)계층에 의존하고,도메인은 영속성계층에 의존하기때문에 자연스럽게 db에 의존하게됨
	문제는,우리는 상태가 아닌 행동을 중심으로 모델링해야하는데,
	db를 토대로 아키텍처를 만들게되면 상태중심이 되고 도메인보다 영속성계층을 먼저 만들게됨
	도메인부터 만들어야 로직을 제대로 이해했는지 확인할수있고,그걸 확인한후에 그걸기반으로 영속성계층과 웹계층을 붙여야하기때문
	
	특히 orm을 사용할경우,엔티티는 영속성계층에 위치하고,영속성모델을 비즈니스모델처럼 사용하게 되는경우가 흔함
	이러면 영속성코드가 도메인코드에 녹아들어가서 둘중 하나만 변경하기가 힘들어짐

  2.지름길을 택하기 쉬워진다
	기본적으로 레이어드아키텍처는 같은계층이나 아래의 계층에만 접근가능함
	문제는 상위계층에 위치한 컴포넌트를 아래로 내려버리는거에 대해 제한이 없다는게 문제임
	그래서 모든게 영속성계층으로 내려가게되고,영속성계층이 엄청나게 커지게됨

  3.테스트하기 어려워짐
	계층을 건너뛰는게 발생하면(웹에서 영속성계층으로 직접접근),도메인계층이 웹계층에 계속 책임이 섞이고,핵심도메인로직이 퍼저나갈수 있고,
	제일 큰 문제는,웹 테스트에서 도메인뿐아니라 영속성계층도 모킹해야한다는것
	이러면 단위테스트의 복잡도가 올라감

  4.유스케이스를 숨긴다
	레이어드는 도메인서비스의 너비에 대해 강제하지않기때문에,엄청나게 큰 유스케이스 하나가 모든걸 다 처리하게될수있음
	이러면 넓은 서비스는 영속성에 많은 의존성을 갖게되고,웹계층의 많은 컴포넌트가 여기에 의존하게됨
	이러면 테스트도 어려워지고,유스케이스를 책임지는 서비스를 찾기도 어려워짐
	
	그래서 특화된 좁은 도메인서비스가 유스케이스 하나씩만 담당하는게 좋음

  5.동시작업이 어려워짐
	영속성이 나와야 도메인이 나오고,도메인이 나와야 웹이 나오기때문에 레이어드에서는 동시작업이 매우힘듬
	물론 인터페이스를 먼저 정의하고 하면 되지만,이건 db주도설계를 하지 않아야 가능함,db주도설계는 영속성로직과 도메인로직이 뒤섞이기때문

  6.유지보수가능한 소프트웨어를 만드는데 어떻게 도움이 될까?
	레이어드도 잘쓰면(여러 추가규칙을 붙이면)괜찮지만,잘못된 방향으로 흘러가는걸 막지못한다는게 문제임
	
2.의존성 역전하기	
  1.단일책임원칙
	단일책임원칙은
		컴포넌트를 변경하는 이유는 오직 하나여야 한다
	임
	이렇게되면 컴포넌트는 딱 한가지 일만 하게되고,변경할이유도 하나임
	이러면 어떤 다른이유로 소프트웨어를 변경하더라도,이컴포넌트에 대해서는 전혀 신경쓸필요가 없어짐
	
	근데 의존성역전을 하지않으면,다른 컴포넌트에 의존할경우 바로 변경에 영향을 받음
  
  2.의존성역전원칙
	레이어드에서 계층간 의존성은 항상 다음계층인 아래계층을 가리킴
	또한 단일책임원칙을 고수준에서 적용하면,상위계층이 하위계층에 비해 변경할 이유가 많음
	
	그런데 영속성계층에 대한 도메인계층의 의존성때문에,영속성계층을 변경할때마다 잠재적으로 도메인계층도 변경해야하는데,
	도메인계층은 어플리케이션에서 가장 중요한곳이라서 영속성코드때문에 도메인을 바꾸고싶진않음
	여기서 사용되는게 dip,의존성역전원칙임
	
	만약 의존성의 양쪽코드를 제어할수있다면,도메인계층에 영속성계층의 레포지토리에 대한 인터페이스를 만들고,
	영속성계층에서 이 인터페이스를 구현하는것
	이게 핵심임

  3.클린아키텍처
	클린아키텍처의 핵심은,도메인코드가 바깥으로 향하는 어떤 의존성도 없어야함을 의미함,
	대신 의존성역전으로 모든 의존성이 도메인을 향하게됨
	
	이 아키텍쳐에서 가장 중요한규칙은,계층간 모든 의존성이 안쪽으로 향해야한다는것
	이 아키텍처의 코어에는 주변유스케이스에서 접근하는 도메인 엔티티가 있고,유스케이스는 서비스를 좀 더 세분화시켜서 단일책임을 지켜주는것
	
	도메인코드에서는 어떤 영속성프레임워크나 ui프레임워크가 사용되는지 알수없어서 특정 프레임워크에 특화된 코드를 가질수없고,
	비즈니스로직에 집중하게됨(pojo)
	
	클린아키텍처의 대가는,도메인이 외부와 철저히 분리되므로,어플리케이션의 엔티티에 대한 모델을 각 계층에서 유지보수해야함
	즉 orm에 해당하는 엔티티클래스는,도메인과 영속성에 각각 만들고,데이터를 주고받을때 두 엔티티를 서로 변환해야함
	또한 도메인과 다른계층사이에서도 마찬가지임
	이렇게해서 도메인을 프레임워크에서 결합을 완전히 제거할수있음

  4.육각형 아키텍처
	헥사고날의 안에는 도메인엔티티와 이와 상호작용하는 유스케이스가 있고,헥사고날의 바깥에는 어플리케이션과 상호작용하는 다양한 어댑터들이 있음(웹,db등)
	그리고 외부에서 안쪽으로 들어오는 어댑터와,안에서 바깥으로 나가는 어댑터가 각각있고,
	코어와 어댑터간의 통신은 코어에서 만든 포트를 통해서 이뤄짐
	즉 코어에서 포트를 만들고,그걸 구현하는 어댑터가 있고,어댑터선택은 di받는식임
	
	즉  헥사고날은 포트어댑터 아키텍처임

  5.유지보수가능한 소프트웨어
	뭘 쓰든 의존성을 역전시켜서 도메인코드가 바깥에 의존하지않게한다면,영속성과 ui에 특화된 모든 문제로부터 결합을 제거하고 변경의 가짓수를 줄일수있음
	이렇게 변경할이유가 적어질수록 유지보수성은 올라감
	또한 도메인코드는 비즈니스로직에 딱 맞게 모델링할수있고,영속성코드와 ui코드도 영속성문제와 ui문제에 맞게 자유롭게 모델링할수있음
	
3.코드구성하기
  1.계층으로 구성하기
	단순히 도메인,레포지토리,웹 이런식으로 코드를 구성하는건(레이어드 기본)
		어플리케이션의 기능조각이나 특성을 구분짓는 패키지경계가 없음
		어플리케이션이 어떤 유스케이스를 제공하는지 파악하기가 힘듬,서비스로 직접가서 하나하나봐야함
	즉 어떤기능이 어디서 호출되는지,어떤기능을 제공하는지를 알아볼수없음
	즉 인포트와 아웃포트가 코드속에 숨어있음

  2.기능으로 구성하기
	그렇다고 도메인을 중심으로 패키지를 만들고 다때려박아버리면,프로텍티드로 외부접근은 막을수있고,
	서비스의 책임을 좁히기위해 도메인+서비스가 아닌 기능+서비스가 가능해짐(해당도메인패키지에 넣을수있으니까)
	즉 소리치는 아키텍처가 가능해짐
	
	근데 이건 계층패키징보다 더 가시성이 떨어짐
	어댑터를 나타내는 패키지명이 없고,인포트 아웃포트를 확인할수없고,의존성역전으로 프로텍티드로 도메인이 실수로 영속성에 접근하는걸 막을수없음

  3.아키텍처적으로 표현력있는 패키지구조
	그래서 큰 틀은 기능으로 구성하되,각 종류마다 각각 폴더를 만들어주는게좋음
	예를들어
		어카운트
			어댑터
				인
					웹
						어카운트컨트롤러
				아웃
					퍼시스턴트
						어카운트퍼시스턴트어댑터
						스프링jpa레포지토리
			도메인
				어카운트
				액티비티
			어플리케이션
				송금서비스
				포트
					인
						송금유즈케이스
					아웃
						계좌포트
						계좌업데이트포트
	이런식으로 각각 바로 뭔지 알수있게 하면 알아보기편해짐
	즉 구조의 각 요소(어카운트)는 패키지하나에 직접 매핑되고,
	그다음레벨로 도메인을 담는 도메인패키지,
	도메인을 포함하는 서비스계층을 담는 어플리케이션 패키지
	어플리케이션패키지 속의 송금유스케이스를 구현하는 송금서비스,아웃포트 인터페이스인 계좌포트와 업데이트포트,
	이걸 구현하는건 어댑터에서 담당하는식
	
	이런 구조를 가지면 해당 api의 위치를 바로 찾을수있고,아키텍처와 코드의 갭을 줄일수있음
	또한 대부분을 퍼블릭으로 열지않고 프로텍티드로 닫아두고,어댑터에서 접근가능해야하는 포트만 열어두는식임

  4.의존성 주입의 역할
	이렇게 만든다음,의존성을 주입해줄 전용 클래스를 하나 만들고 여기서 모든 생성을 처리하는거임(모든 계층에 의존성을 가지는 컴포넌트)
	이렇게 하지않으면 어플리케이션계층에서 어댑터에 대한 의존성이 생기기때문

  5.유지보수가능한 소프트웨어를 만드는데 어떻게 도움이 될까
	이런 구조를 가지면 특정요소를 찾기위해 패키지 탐색이 쉬워지고,의사소통,개발,유지보수가 모두 조금 더 수월해짐

4.유스케이스 구현하기
  1.도메인모델 구현
	헥사고날을 사용하면 어플리케이션과 웹,영속성계층이 약결합상태기때문에 필요한대로 도메인코드를 자유롭게 모델링할수있음
	
	구현할때는 먼저 도메인을 만들고(일단 그 전에 유저스토리부터 만들어야겠지만),
	그다음에 유스케이스를 만들어야함
  
  2.유스케이스 둘러보기
	유스케이스는
		입력을 받는다
		비즈니스로직을 검증한다
		모델상태를 조작한다
		출력을 반환한다
	단계를 따름
	유스케이스는 인커밍 어댑터로부터 입력을 받지만,이때 입력유효성 검증은 하지않음
	그렇지만 유스케이스는 비즈니스규칙을 검증할 책임이 있고,이걸 도메인엔티티와 책임을 공유함
	
	비즈니스규칙을 충족하면,유스케이스는 입력을 기반으로 어떤방법으로든 모델의 상태를 변경하거나(도메인객체의 상태를 바꾸고,영속성어댑터로 전달),
	아웃고잉어댑터를 호출함
	그리고 마지막으로 출력객체로 변환하는것
	
	그리고 유스케이스는 한 서비스클래스에 모두 넣지않고 각 유스케이스별로 분리된 각각의 서비스로 만들면됨

  3.입력유효성 검증
	입력유효성검증은 유스케이스의 책임이 아니지만,어플리케이션계층의 책임이긴함
	인커밍어댑터에서 검증을 할수도있지만,인커밍어댑터는 여러 유스케이스에서 호출될텐데 각 유스케이스마다 다 맞춰줄순없음
	그래서 입력유효성검증은 입력모델이라는 DTO(커맨드)에서 검증하고 들어오는게 좋음
	또한 이때 밸리데이션 어노테이션을 사용하면 더 편하고
	
	즉 유스케이스에 들어오는 매개변수를 DTO를 받는식으로 구성하면됨

  4.생성자의 힘
	또한 DTO를 만들때는 빌더패턴이 아닌 생성자로 만드는게 실수를 덜할수있음

  5.유스케이스마다 다른 입력 모델
	그리고 비슷한 모양의 입력을 받는 유스케이스들이라도,각각 각자의 입력모델을 사용하는게 좋음
	이건 유스케이스별로 받을수있는 사전조건이 다를수있기때문
	이러면 비즈니스로직에 입력유효성검증 관심사가 섞여들어감
	
	아예 유스케이스별로 입력모델을 다르게쓴다면 유스케이스를 훨씬 명확하게 만들고,다른 유스케이스와의 결합도 제거할수있음

  6.비즈니스로직 검증
	비즈니스로직검증은 유스케이스로직의 일부임
	이건 도메인모델의 현재상태에 접근하는거고,입력유효성검증은 선언적으로(@NotNull) 검증하는것
	즉 좀 더 의미적인 유효성을 검증하는거라고 볼수있음
	예를들면 계좌에서 초과출금이 안된다는 규칙은 입력유효성검증으로 처리할수없고,모델의 현재상태를 가져와야만 알수있음(비즈니스로직 검증)
	반면에 송금되는 금액은 0보다 커야한다는 모델에 접근하지않고 선언적으로 검증할수있음(입력유효성 검증)
	
	이런식으로 구분하면 특정 유효성검증을 어디서할지,어느위치에 둘지가 명확해지고 찾기도 쉬워짐
	즉 현재상태에 접근해야하는지만 확인하면되니까
	
	이렇게 비즈니스로직 검증을 하는 가장 좋은방법은 도메인 엔티티 안에 해당 비즈니스규칙을 넣는것
	만약 어렵다면(영속성에서 값을 가져와야해서),유스케이스에서 도메인엔티티를 사용하기 전에 해도 됨
	
	즉 유효성검증코드를 호출하고,실패할경우 유효성검증 전용 예외를 던지는것
	웹어댑터는 이 에러메시지를 사용자에게 보여주거나 적절한 다른방법으로 처리하면됨

  7.풍부한 도메인모델vs빈약한 도메인모델
	헥사고날은 도메인모델을 어떻게하든 상관없음
	근데 보통 풍부한도메인모델을 선호하는편
	
	풍부한 도메인모델의 경우 유스케이스는 도메인의 작업들을 조합하고,의도만을 표현하는 도메인엔티티 메서드 호출 로직으로 변경되고,
	비즈니스로직은 유스케이스대신 엔티티에 위치하게됨
	빈약한 도메인모델의 경우,엔티티는 상태만 가지게되고,유스케이스가 비즈니스로직을 전부 가지게됨

  8.유스케이스마다 다른 출력모델
	유스케이스에서 값을 리턴해줄때도 입력처럼 각각 출력모델을 가지는게 좋고,가능한 정보가 최소가 되도록 반환해야함
	또한 유스케이스들끼리 같은 출력모델을 공유할경우에도 결합이 생기니 조심
	
	또한 도메인엔티티를 출력모델로 사용하는것도 좋지않음

  9.읽기전용 유스케이스
	쿼리용 유스케이스는(조회),쿼리를 위한 인커밍전용포트를 만들고,이걸 쿼리서비스에 구현하는방법이 있음
	이 쿼리서비스는 유스케이스서비스와 같은방식으로 동작하지만,단지 패키지 구분을 위해 나눠두는것임

  10.유지보수 가능한 소프트웨어를 만드는데 어떻게 도움이 될까
	입출력모델을 독립적으로 모델링하면 원치않는 부수효과를 피할수있음
	이건 작업이 좀 필요하지만,유스케이스별로 모델을 만들면 명확하게 이해할수있고,유지보수도 더 쉬움
	또한 여러 개발자가 다른사람이 작업중인 유스케이스를 건드리지않고 여러 유스케이스를 동시작업할수도 있음

5.웹어댑터 구현하기
  1.의존성 역전
	웹 어댑터는 기본적으로 인커밍 어댑터임,얘로부터 로직이 실행되고 무슨일을 해야할지 알려줌
	즉 웹어댑터의 컨트롤러로부터 어플리케이션의 서비스로 흐르게됨
	이떄 어플리케이션 계층은 웹 어댑터가 통신할수있는 포트를 제공하고,서비스는 이 포트를 구현하고 웹 어댑터는 이 포트를 호출함
	즉 dip임
	
	사실 어댑터와 유스케이스사이에 간접계층(포트)가 없어도 되긴하지만,포트가 있으면 외부와 어떤통신이 일어나는지 명확하게 알수있고,
	이건 유지보수할때 코드를 처음보는사람에게 도움이됨(물론 생략하기도함)
	
	또한 만약에 소켓통신으로 데이터를 사용자의 브라우저로 보내야한다면(예를들어 카프카로 이벤트가 발생했을때 전달하는식),
	이때는 아웃커밍 어댑터의 역할도 같이하기때문에 반드시 포트가 필요해짐
	이 포트는 웹 어댑터에서 구현하고 어플리케이션 코어에서 호출해야하기때문
	즉 인커밍이자 아웃커밍 어댑터일수도 있다는거

  2.웹 어댑터의 책임
	웹 어댑터의 책임은
		http요청을 자바객체로 매핑
		권한검사
		입력유효성 검증(http)
		입력을 유스케이스의 dto로 매핑
		유스케이스 호출
		유스케이스 출력을 http로 매핑
		http응답을 반환
	이렇게 책임을 가짐
	기본적으로 url,경로,http메서드,콘텐츠타입등의 기준을 만족하는 요청을 수신해서,
	해당 요청의 파라미터와 콘텐츠를 객체로 역직렬화하고,
	인증과 권한부여를 수행하고 실패하면 에러를 반환해야함
	
	이러고나서 객체의 상태유효성검증을 해야하는데,여기서 입력유효성검증은 유스케이스랑 다르게,
	http요청을 유스케이스입력모델로 변경할수있냐 만 체크하는거임
	그리고 유스케이스를 호출하고 출력을 받아서 http응답으로 바꿔서 리턴하는거
	
	이런 로직들은 어플리케이션코어에 들어가면 안되는로직들이라서,컨트롤러에서 다 처리해야하는거고,
	또한 안그래도 책임이 많기때문에 어플리케이션 관련 로직들은 다 밑에서 처리하는게 좋음
	
	이렇게 웹과 어플리케이션 코어와의 경계는,
	웹부터가 아닌 도메인부터 개발을 시작하는경우 자연스럽계 경계가 생기고,유스케이스를 먼저 구현하는데 따른 이점임

  3.컨트롤러 나누기
	웹프레임워크를 사용하면 앞에서의 대부분을 처리해줌
	또한 웹 어댑터는 하나이상이어도 되지만,클래스들이 같은 소속이라는걸 표현하기위해 같은패키지수준에 놓여야함
	그리고 컨트롤러는 너무 갯수가 적은거보단 많은게 낫고,각 컨트롤러는 가능한 좁고 다른컨트롤러와 가능한 적게 공유하는 웹어댑터 조각을 구현해야함
	
	즉 해당 엔티티의 컨트롤러 하나만 만드는거보다,각 행위마다 따로따로 만드는게 좋음
	일단 단일클래스의 코드가 줄어들고,테스트코드의 코드도 줄어들어서 원하는걸 찾기가 쉬워짐
	
	그리고 제일 중요한건,한군데 다때려박으면 데이터구조의 재활용을 할 가능성을 높인다는데 있음
	그래서 사용할수있는 방법으로,각 유스케이스마다 하나씩 컨트롤러를 만들고,메서드와 클래스명은 유스케이스를 최대한 반영해서 짓는 방식이 있음
	이때 각 연산에 대해 가급적이면 별도의 패키지안에 별도의 컨트롤러를 만드는방식이 좋음
	그리고 각 컨트롤러가 컨트롤러 자체의 모델(dto)를 가지거나 원시값을 직접 받아서 유스케이스dto로 만들어서 줘도됨
	
	이런 전용모델클래스들은 컨트롤러패키지에 대해 프라이빗으로 선언할수있어서 실수로 다른곳에서 재사용될일이 없음	
	컨트롤러끼리는 모델을 공유할수있지만,다른패키지에 있으니 공유해서 사용되기전에 다시한번 생각해볼수있음
	
	또한 이땐 컨트롤러명과 서비스명도 createAccount보다는 RegisterAccount같이 더 명확한 이름을 짓는게 좋음
	
	이렇게하면 동시작업시 머지컴플릭트가 덜일어나는 장점도 있음

  4.유지보수 가능한 소프트웨어를 만드는데 어떻게 도움이 될까
	이렇게 웹과 어플리케이션 코어를 분리하면 요청을 어플리케이션에서 http에 대한 정보를 알필요가 없어지고,
	웹도 http요청만 처리하고 유스케이스호출만 할수있게됨
	
	또한 웹컨트롤러를 나눌때는 모델을 공유하지않는 여러 작은 클래스들을 만드는걸 두려워하면 안됨,이러면 파악하기 더 쉽고,테스트가 더 쉽고,동시작업을 지원함
	이게 처음엔 공수가 좀 더 들어가긴하지만 유지보수하기가 좋음
	
6.영속성 어댑터 구현하기
  1.의존성역전
	어플리케이션 서비스는 영속성기능을 사용하기위해 포트인터페이스를 호출하고,
	영속성어탭터는 주도되는(아웃고잉) 어댑터임,즉 어플리케이션에 의해 호출될뿐 호출하지않음
	
	또한 포트는 어플리케이션서비스와 영속성 코드 사이의 간접계층이고,이걸통해 서비스와 도메인은 영속성에 신경쓰지않고 개발할수있음
	어댑터가 포트의 계약을 만족하는한,서비스(코어)는 전혀 신경쓰지않고 자기일만 할수있음
	
  2.영속성 어댑터의 책임
	영속성 어댑터는
		입력을 받는다
		입력을 db포맷으로 매핑
		입력을 db로 보냄
		db출력을 어플리케이션 포맷으로 매핑
		출력을 반환
	하는 책임을 가지고있고,영속성 어댑터는 포트인터페이스를 통해 입력을 받음
	여기서 입력모델은 특정도메인엔티티나 특정 db용 dto가 됨
	
	그리고 영속성어댑터는 db를 쿼리하거나 변경할때 사용할수있는 포맷(jpa엔티티)으로 입력모델을 매핑함(상황따라서 그냥 합치기도함,즉 도메인과 jpa를 하나로)
	
	이렇게 포트를 구현하는식의 핵심은,입력모델이 코어에 있기때문에 영속성어댑터를 어케바꾸든 코어에 영향을 주지않는다는것
	즉 입출력모델을 코어가 관리한다는거만 빼면 일반적인 영속성계층의 책임과 다르지않긴한데,여러가지 이상한점이 생기긴함

  3.포트인터페이스 나누기
	가장 일반적인방법은 하나의 레포지토리 포트를 사용하고,그 포트를 어댑터가 구현하는건데,
	문제는 이러면 하나의 메서드만 필요해도 isp에 어긋나는 넓은 포트인터페이스에 의존하게된다는것
	
	또한 이렇게 필요하지않은 메서드에 생긴 의존성은 코드를 이해하고 테스트하기 어렵게만듬(어떤 메서드를 모킹해야할지)
	또한 다른사람이 테스트를 만들때 모킹이 당연히 돼있을거라고 생각한 메서드가 안돼있다던가 할수있음
	
	그래서 각 종류별로 포트를 나누고,어댑터는 그 모든 포트를 구현한다음,서비스는 각자 자기가 필요한 포트만 가져다가 써서 해결할수있음
	즉 기본적으로 한 메서드당 하나의 포트,추가적으로 응집도있고 같이사용되는애들끼리는 같은 포트 이런식
	이러면 서비스는 진짜 필요한 메서드에만 의존하게됨

  4.영속성어댑터 나누기
	또한 어댑터도 여러개를 쓸수있음,이건 ddd같은경우 자주 사용되는데,각 애그리거트당 하나의 영속성 어댑터를 구현하는식
	어짜피 코어는 어댑터에 관심이 없기때문에 상관없음,모든 포트가 계약에 맞게 구현만 된다면 아무렇게나 해도됨

  5.db트랜잭션은?
	트랜잭션은 하나의 유스케이스에 대해서 일어나는 모든 쓰기작업에 걸쳐있어야하기때문에,영속성 어댑터에서 처리할수없음
	이건 서비스에서 처리해야함

  6.유지보수가능한 소프트웨어를 만드는데 어떻게 도움이 될까
	이런식으로 플러그인처럼 동작하는 영속성 어댑터를 만들면,도메인이 영속성과 분리되어 풍부한 도메인모델을 만들수있음
	또한 좁은 포트인터페이스를 사용하면,포트마다 다른방식으로 구현할수있고,포트뒤에서 어플리케이션에 영향을 주지않고 다른기술을 쓸수도있음

7.아키텍처 요소 테스트하기
  1.테스트 피라미드
	테스트는 생성비용이 적고,유지보수가 쉽고,빨리 실행되고,안정적인 크기의 테스트들이 많아야함(단위테스트)
	또한 여러 단위를 넘는 경계를 결합하는 테스트는 비용이 비싸고 실행이 느려져서 깨지기 더 쉬워짐
	즉 테스트피라미드는 테스트가 비싸질수록 커버리지목표는 낮아져야한다는걸 의미함(코드보다 테스트생성시간이 더 길어져서)
	
	단위테스트는 하나의 클래스를 인스턴스화하고,해당클래스의 인터페이스를 통해 기능을 테스트함
	만약 다른 클래스에 해당클래스가 의존한다면 인스턴스화하지않고 모킹으로 대체(런던파)하던가 아니면 그냥 인스턴스화해서 테스트함(고전파)
	
	통합테스트는 여러 유닛을 인스턴스화하고,시작점이 되는 클래스의 인터페이스로 데이터를 보내서 유닛들의 네트워크가 기대한대로 잘 동작하는지 검증함
	
	시스템테스트는 어플리케이션의 모든 객체네트워크를 가동시켜,특정 유스케이스가 전계층에서 잘 동작하는지 검증함

  2.단위테스트로 도메인엔티티 테스트
	헥사고날의 핵심인 도메인은 단위테스트를 하기 매우좋음
	만들기도 쉽고 이해도 쉽고 빠르게 실행됨
	도메인은 다른종류의 테스트는 필요하지않음

  3.단위테스트로 유스케이스 테스트
	유스케이스의 테스트를 모킹해서 한다면 해당 메서드를 호출했는지 체크하는방법밖에없음(상태가 없으니까)
	그래서 이경우에는 변경에 취약해지고,그냥 통합테스트로 하는게 나을수있음

  4.통합테스트로 웹 어댑터 테스트
	어댑터는 통합테스트로 하는게 좋음
	스프링을 키고 di를 받고,mockmvc로 해당 http요청을 날리는식으로 전체통합테스트를 하는게 좋음
	굳이 단위테스트를 만들면 중복이기때문에,그냥 이거하나로 땡치는게 나음

  5.통합테스트로 영속성어댑터 테스트
	영속성도 통합테스트로 하는게 좋음
	어댑터로직뿐아니라,db매핑도 검증할수있기때문
	그래서 db를 모킹하지않고,실제 db에 접근하게하는게 좋음,또한 db도 인메모리가 아닌 프로덕션과 같은환경의 db를 사용하는게 좋고
	그래서 testContainers를 사용하기좋음

  6.시스템테스트로 주요경로 테스트하기
	시스템테스트는 전체어플리케이션을 띄우고,api를 통해요청을 보내고 모든계층이 조화롭게 동작하는지 검증함
	이때는 mockmvc가 아닌,testRestTemplate로 요청을 보내면 좀 더 프로덕션에 가깝게 통신할수있음
	또한 출력(아웃고잉)어댑터도 실제출력어댑터를 사용하면됨(이때 외부api같이 비용청구되는건 모킹쳐도됨,어짜피 포트모킹치면되니까)
	
	시스템테스트는 단위테스트와 통합테스트와 겹치는 부분이 많은데,이게 있으면 단위나 통합과는 다른종류의 버그를 발견할수있게해줌
	시스템테스트는 여러개의 유스케이스를 결합해서 시나리오를 만들때 더 빛이 남
	각 시나리오는 사용자가 어플리케이션을 사용하면서 거쳐갈 특정 경로를 의미하고,
	시스템테스트로 중요한시나리오가 커버되면,최신변경사항이 어플리케이션을 망가뜨리지않았음을 가정할수있고,배포될 준비가 됐다는 확신을 가질수있음
	
  7.얼마만큼의 테스트가 충분할까?
	라인 커버리지로 이걸 판단하면안됨,라인커버리지가 낮으면 나쁜거지만 높다고 좋은건아님
	테스트를 믿고 배포할수있냐가 중요함
	
	또한 전략을 만들어두는거도 좋음
		도메인은 단위테스트로 커버
		유스케이스는 통합테스트로 커버
		어댑터는 통합테스트로 커버
		사용자경로는 시스템테스트로 커버
	이런식으로
	또한 기능개발후가 아닌 개발중에 같이 하는게 좋음,이래야 숙제같지않음
	그리고 새필드를 추가할때마다 테스트를 고치는데 한시간씩 들어가면 뭔가 잘못된거니까,중복제거한후 추출하던가 해서 개선해야함

  8.유지보수가능한 소프트웨어를 만드는데 어떻게 도움이 될까
	헥사고날은 경계를 나누고 그부분을 전부 포트처리해버리기떄문에,테스트하기가 매우편하고 포트는 아주 뚜렷한 모킹지점이됨
	또한 모킹이 너무 버거워지거나 코드의 특정부분을 커버하기위해 어떤테스트를 써야할지 모르겠다면 이는 경고신호임
	그래서 테스트는 아키텍처의 문제에 대해 경고하고,유지보수 가능한 코드를 만들기위한 카나리아역할도 함

8.경계간 매핑하기
  1.매핑하지않기 전략
	이건 유스케이스(서비스인터페이스)와 서비스,레포지토리포트(레포지토리인터페이스)가 모두 매핑하지않고 도메인을 직접 입출력하는거임
	즉 웹계층과 어플리케이션,영속성계층 모두 같은 모델(도메인)을 직접 사용하는것
	
	이거의 장점은 보일러 플레이트가 없다는거고,
	단점은 웹과 영속성모델에서 모델에 대해 특별한 요구사항이 있을경우(웹계층의 요구에따른 json직렬화어노테이션,영속성계층의 jpa어노테이션 등),
	도메인이 해당 어노테이션에 대해 의존해야하는,즉 웹이나 영속성등 외부의존성이 섞여들어갈수있다는거고,
	그래서 단일책임원칙을 위반함
	또한 각 계층이 필요로 하는 필드가 도메인에 섞여들어가기 좋음(id같은거)
	
	이거의 장점은 간단할수록 이렇게하는게 더 효율적이라는거고,외부의존성이라고 해봐야 어노테이션이라 큰 문제는 안됨
	단,어플리케이션계층이나 도메인계층에서 웹과 영속성문제를 다뤄야하게된다면,즉시 다른전략을 취해야함
	
	즉 가장 기본전략임

  2.양방향 매핑 전략
	이건 웹에서는 dto를 받고,유스케이스부터는 도메인을 사용하고,영속성 유스케이스에서는 도메인을 받아서 jpa엔티티모델로 저장하는식임
	즉 양방향 유스케이스에서 변환하는 형식이 됨,즉 유스케이스부터 도메인을 사용하고,외부 어댑터구간에서는 자기껄쓰는식
	
	각 계층이 전용모델을 가지고있어서 전용모델을변경하더라도 다른계층에 영향이 없다는 장점이 있고,
	그래서 웹은 데이터를 최적으로 표현하는 구조를 가질수있고,영속성에서는 db에 적절한 구조를 가지고,도메인은 외부를 신경쓰지않아도됨
	
	또한 이건 매핑하지않기 다음으로 편한방법임,매핑책임이 명확하기때문
	단점으로는 너무많은 보일러플레이트코드가 생기고,특히 매핑프레임워크가 내부동작방식을 제네릭과 리플렉션뒤로 숨기면 디버깅이 머리아픔
	또한 도메인모델이 계층경계를 넘어서 통신하는데 사용됨(인포트의 입력값,아웃포트의 반환값),그래서 바깥계층의 요구에 따른 변경에 취약해짐
	
	기본적으로 디폴트전략으로 사용할수있음

  3.완전 매핑 전략
	이건 웹,유스케이스,영속성 계층이 전부 자기의 모델을 가지고있는거임
	즉 도메인은 서비스에서만 건드릴수있고,유스케이스도 각 연산마다 별도의 입출력모델을 가지게됨
	
	웹계층은 입력을 어플리케이션의 커맨드객체(유스케이스dto)로 매핑할 책임을 가지고있고,이런방식은 어플리케이션의 인터페이스를 명확하게 만듬
	각 유스케이스는 전용필드와,유효성검증로직을 가진 전용 커맨드를 가짐
	어떤필드를 채울지,어떤필드를 비울지도 전혀 신경쓰지않아도됨,무조건 채워야하기때문
	
	또한 어플리케이션계층은 커맨드객체를 유스케이스에 따라 도메인모델을 변경하기위해 필요한 무엇인가로 매핑할 책임을 가지게됨
	
	이런방식은 한 계층을 다른 여러커맨드로 매핑하는데는 하나의 웹모델과 도메인모델간의 매핑보다 더 많은 코드가 필요하지만,
	이러면 여러 유스케이스의 요구사항을 함께 다뤄야하는 매핑보다 신경쓸게적어서 구현과 유지보수가 편함
	
	이 완전매핑전략은 전역패턴으로 쓰기는 좋지않음
	이건 인커밍어댑터와 어플리케이션계층 사이에서 상태변경 유스케이스의 경계를 명확히 해야할때 가장 좋음
	또한 어플리케이션과 영속성계층사이에서는 매핑오버헤드때문에 사용하지않는게 좋음
	
	또한 어떤경우엔 입력모델에만 이매핑을 쓰고,출력모델에서는 그냥 도메인을 던지는 방식도 좋음
	즉 매핑전략은 한 프로젝트 내에서도 여러가지를 섞어서 써야함(각 종류마다 다르게)

  4.단방향 매핑 전략
	이건 도메인을 포함한 웹모델(인커밍어댑터모델)과 도메인,영속성모델(아웃커밍어댑터모델)이 인터페이스를 만들고 공유하는 패턴임
	이 인터페이스는 관련있는 특성에 대한 get을 제공해서 도메인모델의 상태를 캡슐화할수있음
	
	이걸 사용하면 도메인모델은 풍부한 행동을 구현할수있고,서비스에서도 이런행동에 접근할수있고,
	도메인객체를 바깥으로 전달해도 상관없음,어짜피 같은인터페이스니까
	그리고 바깥에서는 상태인터페이스를 사용할지,전용모델로 매핑할지를 선택할수있음(단,set은 없기때문에 도메인값은 변경불가)
	
	또한 어플리케이션으로 들어오는 전용모델들도 인터페이스를 구현해서,이 객체를 쉽게 도메인모델로 매핑해서 사용할수있음(팩터리로 하면 좋음)
	
	즉 이 전략에서의 매핑책임은,받은쪽에서 받자마자 즉시 해당계층에서 쓸수있게 다른 무언가로 매핑하는것,그래서 각계층은 한방향(받은방향)으로만 매핑함
	그래서 단방향매핑임
	단,이건 매핑이 계층을 넘나들며 퍼져있기때문에 다른전략에 비해 개념적으로 어려움
	이건 계층간 모델이 비슷할때 가장 효과적임(읽기전용연산은 상태인터페이스가 모든걸 설명하기때문에 전용모델이 필요없음)

  5.언제 어떤 매핑전략을 사용할것인가
	일단,전역전략을 만드는건 대부분상황에서 안좋음
	보통 간단한 전략에서 시작해서 계층간 결합을 떼어내는데 도움이 되는 복잡한적략으로 갈아타는것도 괜찮음
	
	제일 중요한건 가이드라인을 만드는것
	예를들어
		변경 유스케이스는 웹과 어플리케이션 사이에서는 완전매핑을 쓴다
		변경 유스케이스는 어플리케이션과 영속성 사이에서는 매핑하지않기를 쓴다
		쿼리는 매핑하지않기를 쓴다,단 어플리케이션계층에서 다른계층 문제를 다뤄야하면 양방향으로 바꾼다
	이런식으로 하는거임

  6.유지보수가능한 소프트웨어를 만드는데 어떻게 도움이 될까
	인커밍포트와 아웃고잉포트는 다른계층에서 어떻게 통신하는지를 정의함,여기에는 매핑을 수행할지 여부와,어떤매핑전략을 쓸지가 포함됨
	각 유스케이스에 대해 좁은 포트를 사용하면,유스케이스마다 다른전략을 사용할수있고,다른유스케이스에 영향을 미치지 않으면서 코드를 개선할수있음
	
	또한 상황별로 매핑전략을 선택하는것은 모든상황에 같은 매핑전략을 사용하는것보다 어렵지만,가이드라인이 있다면 나름 쉽고,더유지보수하기 좋은 코드가 나옴
	
9.어플리케이션 조립하기	
  1.왜 조립까지 신경써야할까
	new를 쓰면 안되는이유는,의존성이 섞이기때문,모든 의존성은 안쪽으로 향해야 외부에 대해서 내부가 안전해짐
	즉 유스케이스가 영속성 어댑터를 호출하고,스스로 인스턴스화 한다면 코드의존성이 거꾸로되는것,또한 이거때문에 아웃고잉 포트가 생기는 이유임
	
	단 런타임에서 실행하려면 누군가는 생성을 해줘야함,그래서 사용되는게 모든 클래스에 의존성을 가지는 설정컴포넌트임
	얘는 어플리케이션을 조립하는걸 책임짐,즉 모든 의존성연결은 여기서함
	이건 단일책임원칙(변경하는이유는 하나여야한다)을 어기지만,한군데서는 어겨야하니까 그걸 모아둔거임

  2.평범한 코드로 조립하기
	di프레임워크가 없다면 main에서 다 조립하고 시작할수있음
	근데 그냥 di프레임워크쓰자

  3.스프링의 클래스패스 스캐닝으로 조립하기
	@Component같은걸 달면 알아서 스캔해서 찾아다가 조립해줌,단 해당인터페이스를 구현한게 하나뿐이어야함
	단점으로는 클래스에 특화된 어노테이션을 붙여야함,특히 프레임워크나 라이브러리를 만들때는 이러면 의존성이 생기기떄문에 금기임
	또한 마법같은,즉 이유를 알수없는 일이 생기기 쉬움

  4.스프링의 자바 컨피그로 조립하기
	그래서 아예 빈 생성 클래스를 만들고,거기서 명시적으로 조립하는게 가장 깔끔함
	이러면 여기저기 @Component를 만들필요도없어짐
	단,이경우에 설정클래스가 생성하는빈이 설정클래스와 같은 패키지에 없다면 빈들을 퍼블릭으로 만들어야함

  5.유지보수가능한 소프트웨어를 만드는데 어떻게 도움이 될까
	클래스패스 스캐닝은 편하지만,프로젝트가 커지면 알아보기가 힘듬
	그래서 좀 커진다싶으면 명시적으로 조립하는게 좋음
	또한 명시적으로 조립하면,테스트에서 일부만 띄우기도 좋음
	

10.아키텍처 경계 강제하기	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	