1.계층형 아키텍처의 문제는 무엇일까?
  1.계층형 아키텍처는 db주도설계를 유도한다
	레이어드의 토대는 db임
	웹계층은 도메인(서비스+도메인)계층에 의존하고,도메인은 영속성계층에 의존하기때문에 자연스럽게 db에 의존하게됨
	문제는,우리는 상태가 아닌 행동을 중심으로 모델링해야하는데,
	db를 토대로 아키텍처를 만들게되면 상태중심이 되고 도메인보다 영속성계층을 먼저 만들게됨
	도메인부터 만들어야 로직을 제대로 이해했는지 확인할수있고,그걸 확인한후에 그걸기반으로 영속성계층과 웹계층을 붙여야하기때문
	
	특히 orm을 사용할경우,엔티티는 영속성계층에 위치하고,영속성모델을 비즈니스모델처럼 사용하게 되는경우가 흔함
	이러면 영속성코드가 도메인코드에 녹아들어가서 둘중 하나만 변경하기가 힘들어짐

  2.지름길을 택하기 쉬워진다
	기본적으로 레이어드아키텍처는 같은계층이나 아래의 계층에만 접근가능함
	문제는 상위계층에 위치한 컴포넌트를 아래로 내려버리는거에 대해 제한이 없다는게 문제임
	그래서 모든게 영속성계층으로 내려가게되고,영속성계층이 엄청나게 커지게됨

  3.테스트하기 어려워짐
	계층을 건너뛰는게 발생하면(웹에서 영속성계층으로 직접접근),도메인계층이 웹계층에 계속 책임이 섞이고,핵심도메인로직이 퍼저나갈수 있고,
	제일 큰 문제는,웹 테스트에서 도메인뿐아니라 영속성계층도 모킹해야한다는것
	이러면 단위테스트의 복잡도가 올라감

  4.유스케이스를 숨긴다
	레이어드는 도메인서비스의 너비에 대해 강제하지않기때문에,엄청나게 큰 유스케이스 하나가 모든걸 다 처리하게될수있음
	이러면 넓은 서비스는 영속성에 많은 의존성을 갖게되고,웹계층의 많은 컴포넌트가 여기에 의존하게됨
	이러면 테스트도 어려워지고,유스케이스를 책임지는 서비스를 찾기도 어려워짐
	
	그래서 특화된 좁은 도메인서비스가 유스케이스 하나씩만 담당하는게 좋음

  5.동시작업이 어려워짐
	영속성이 나와야 도메인이 나오고,도메인이 나와야 웹이 나오기때문에 레이어드에서는 동시작업이 매우힘듬
	물론 인터페이스를 먼저 정의하고 하면 되지만,이건 db주도설계를 하지 않아야 가능함,db주도설계는 영속성로직과 도메인로직이 뒤섞이기때문

  6.유지보수가능한 소프트웨어를 만드는데 어떻게 도움이 될까?
	레이어드도 잘쓰면(여러 추가규칙을 붙이면)괜찮지만,잘못된 방향으로 흘러가는걸 막지못한다는게 문제임
	
2.의존성 역전하기	
  1.단일책임원칙
	단일책임원칙은
		컴포넌트를 변경하는 이유는 오직 하나여야 한다
	임
	이렇게되면 컴포넌트는 딱 한가지 일만 하게되고,변경할이유도 하나임
	이러면 어떤 다른이유로 소프트웨어를 변경하더라도,이컴포넌트에 대해서는 전혀 신경쓸필요가 없어짐
	
	근데 의존성역전을 하지않으면,다른 컴포넌트에 의존할경우 바로 변경에 영향을 받음
  
  2.의존성역전원칙
	레이어드에서 계층간 의존성은 항상 다음계층인 아래계층을 가리킴
	또한 단일책임원칙을 고수준에서 적용하면,상위계층이 하위계층에 비해 변경할 이유가 많음
	
	그런데 영속성계층에 대한 도메인계층의 의존성때문에,영속성계층을 변경할때마다 잠재적으로 도메인계층도 변경해야하는데,
	도메인계층은 어플리케이션에서 가장 중요한곳이라서 영속성코드때문에 도메인을 바꾸고싶진않음
	여기서 사용되는게 dip,의존성역전원칙임
	
	만약 의존성의 양쪽코드를 제어할수있다면,도메인계층에 영속성계층의 레포지토리에 대한 인터페이스를 만들고,
	영속성계층에서 이 인터페이스를 구현하는것
	이게 핵심임

  3.클린아키텍처
	클린아키텍처의 핵심은,도메인코드가 바깥으로 향하는 어떤 의존성도 없어야함을 의미함,
	대신 의존성역전으로 모든 의존성이 도메인을 향하게됨
	
	이 아키텍쳐에서 가장 중요한규칙은,계층간 모든 의존성이 안쪽으로 향해야한다는것
	이 아키텍처의 코어에는 주변유스케이스에서 접근하는 도메인 엔티티가 있고,유스케이스는 서비스를 좀 더 세분화시켜서 단일책임을 지켜주는것
	
	도메인코드에서는 어떤 영속성프레임워크나 ui프레임워크가 사용되는지 알수없어서 특정 프레임워크에 특화된 코드를 가질수없고,
	비즈니스로직에 집중하게됨(pojo)
	
	클린아키텍처의 대가는,도메인이 외부와 철저히 분리되므로,어플리케이션의 엔티티에 대한 모델을 각 계층에서 유지보수해야함
	즉 orm에 해당하는 엔티티클래스는,도메인과 영속성에 각각 만들고,데이터를 주고받을때 두 엔티티를 서로 변환해야함
	또한 도메인과 다른계층사이에서도 마찬가지임
	이렇게해서 도메인을 프레임워크에서 결합을 완전히 제거할수있음

  4.육각형 아키텍처
	헥사고날의 안에는 도메인엔티티와 이와 상호작용하는 유스케이스가 있고,헥사고날의 바깥에는 어플리케이션과 상호작용하는 다양한 어댑터들이 있음(웹,db등)
	그리고 외부에서 안쪽으로 들어오는 어댑터와,안에서 바깥으로 나가는 어댑터가 각각있고,
	코어와 어댑터간의 통신은 코어에서 만든 포트를 통해서 이뤄짐
	즉 코어에서 포트를 만들고,그걸 구현하는 어댑터가 있고,어댑터선택은 di받는식임
	
	즉  헥사고날은 포트어댑터 아키텍처임

  5.유지보수가능한 소프트웨어
	뭘 쓰든 의존성을 역전시켜서 도메인코드가 바깥에 의존하지않게한다면,영속성과 ui에 특화된 모든 문제로부터 결합을 제거하고 변경의 가짓수를 줄일수있음
	이렇게 변경할이유가 적어질수록 유지보수성은 올라감
	또한 도메인코드는 비즈니스로직에 딱 맞게 모델링할수있고,영속성코드와 ui코드도 영속성문제와 ui문제에 맞게 자유롭게 모델링할수있음
	
3.코드구성하기
  1.계층으로 구성하기
	단순히 도메인,레포지토리,웹 이런식으로 코드를 구성하는건(레이어드 기본)
		어플리케이션의 기능조각이나 특성을 구분짓는 패키지경계가 없음
		어플리케이션이 어떤 유스케이스를 제공하는지 파악하기가 힘듬,서비스로 직접가서 하나하나봐야함
	즉 어떤기능이 어디서 호출되는지,어떤기능을 제공하는지를 알아볼수없음
	즉 인포트와 아웃포트가 코드속에 숨어있음

  2.기능으로 구성하기
	그렇다고 도메인을 중심으로 패키지를 만들고 다때려박아버리면,프로텍티드로 외부접근은 막을수있고,
	서비스의 책임을 좁히기위해 도메인+서비스가 아닌 기능+서비스가 가능해짐(해당도메인패키지에 넣을수있으니까)
	즉 소리치는 아키텍처가 가능해짐
	
	근데 이건 계층패키징보다 더 가시성이 떨어짐
	어댑터를 나타내는 패키지명이 없고,인포트 아웃포트를 확인할수없고,의존성역전으로 프로텍티드로 도메인이 실수로 영속성에 접근하는걸 막을수없음

  3.아키텍처적으로 표현력있는 패키지구조
	그래서 큰 틀은 기능으로 구성하되,각 종류마다 각각 폴더를 만들어주는게좋음
	예를들어
		어카운트
			어댑터
				인
					웹
						어카운트컨트롤러
				아웃
					퍼시스턴트
						어카운트퍼시스턴트어댑터
						스프링jpa레포지토리
			도메인
				어카운트
				액티비티
			어플리케이션
				송금서비스
				포트
					인
						송금유즈케이스
					아웃
						계좌포트
						계좌업데이트포트
	이런식으로 각각 바로 뭔지 알수있게 하면 알아보기편해짐
	즉 구조의 각 요소(어카운트)는 패키지하나에 직접 매핑되고,
	그다음레벨로 도메인을 담는 도메인패키지,
	도메인을 포함하는 서비스계층을 담는 어플리케이션 패키지
	어플리케이션패키지 속의 송금유스케이스를 구현하는 송금서비스,아웃포트 인터페이스인 계좌포트와 업데이트포트,
	이걸 구현하는건 어댑터에서 담당하는식
	
	이런 구조를 가지면 해당 api의 위치를 바로 찾을수있고,아키텍처와 코드의 갭을 줄일수있음
	또한 대부분을 퍼블릭으로 열지않고 프로텍티드로 닫아두고,어댑터에서 접근가능해야하는 포트만 열어두는식임

  4.의존성 주입의 역할
	이렇게 만든다음,의존성을 주입해줄 전용 클래스를 하나 만들고 여기서 모든 생성을 처리하는거임(모든 계층에 의존성을 가지는 컴포넌트)
	이렇게 하지않으면 어플리케이션계층에서 어댑터에 대한 의존성이 생기기때문

  5.유지보수가능한 소프트웨어를 만드는데 어떻게 도움이 될까
	이런 구조를 가지면 특정요소를 찾기위해 패키지 탐색이 쉬워지고,의사소통,개발,유지보수가 모두 조금 더 수월해짐

4.유스케이스 구현하기
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	