1.계층형 아키텍처의 문제는 무엇일까?
  1.계층형 아키텍처는 db주도설계를 유도한다
	레이어드의 토대는 db임
	웹계층은 도메인(서비스+도메인)계층에 의존하고,도메인은 영속성계층에 의존하기때문에 자연스럽게 db에 의존하게됨
	문제는,우리는 상태가 아닌 행동을 중심으로 모델링해야하는데,
	db를 토대로 아키텍처를 만들게되면 상태중심이 되고 도메인보다 영속성계층을 먼저 만들게됨
	도메인부터 만들어야 로직을 제대로 이해했는지 확인할수있고,그걸 확인한후에 그걸기반으로 영속성계층과 웹계층을 붙여야하기때문
	
	특히 orm을 사용할경우,엔티티는 영속성계층에 위치하고,영속성모델을 비즈니스모델처럼 사용하게 되는경우가 흔함
	이러면 영속성코드가 도메인코드에 녹아들어가서 둘중 하나만 변경하기가 힘들어짐

  2.지름길을 택하기 쉬워진다
	기본적으로 레이어드아키텍처는 같은계층이나 아래의 계층에만 접근가능함
	문제는 상위계층에 위치한 컴포넌트를 아래로 내려버리는거에 대해 제한이 없다는게 문제임
	그래서 모든게 영속성계층으로 내려가게되고,영속성계층이 엄청나게 커지게됨

  3.테스트하기 어려워짐
	계층을 건너뛰는게 발생하면(웹에서 영속성계층으로 직접접근),도메인계층이 웹계층에 계속 책임이 섞이고,핵심도메인로직이 퍼저나갈수 있고,
	제일 큰 문제는,웹 테스트에서 도메인뿐아니라 영속성계층도 모킹해야한다는것
	이러면 단위테스트의 복잡도가 올라감

  4.유스케이스를 숨긴다
	레이어드는 도메인서비스의 너비에 대해 강제하지않기때문에,엄청나게 큰 유스케이스 하나가 모든걸 다 처리하게될수있음
	이러면 넓은 서비스는 영속성에 많은 의존성을 갖게되고,웹계층의 많은 컴포넌트가 여기에 의존하게됨
	이러면 테스트도 어려워지고,유스케이스를 책임지는 서비스를 찾기도 어려워짐
	
	그래서 특화된 좁은 도메인서비스가 유스케이스 하나씩만 담당하는게 좋음

  5.동시작업이 어려워짐
	영속성이 나와야 도메인이 나오고,도메인이 나와야 웹이 나오기때문에 레이어드에서는 동시작업이 매우힘듬
	물론 인터페이스를 먼저 정의하고 하면 되지만,이건 db주도설계를 하지 않아야 가능함,db주도설계는 영속성로직과 도메인로직이 뒤섞이기때문

  6.유지보수가능한 소프트웨어를 만드는데 어떻게 도움이 될까?
	레이어드도 잘쓰면(여러 추가규칙을 붙이면)괜찮지만,잘못된 방향으로 흘러가는걸 막지못한다는게 문제임
	
2.의존성 역전하기	
  1.단일책임원칙
	단일책임원칙은
		컴포넌트를 변경하는 이유는 오직 하나여야 한다
	임
	이렇게되면 컴포넌트는 딱 한가지 일만 하게되고,변경할이유도 하나임
	이러면 어떤 다른이유로 소프트웨어를 변경하더라도,이컴포넌트에 대해서는 전혀 신경쓸필요가 없어짐
	
	근데 의존성역전을 하지않으면,다른 컴포넌트에 의존할경우 바로 변경에 영향을 받음
  
  2.의존성역전원칙
	레이어드에서 계층간 의존성은 항상 다음계층인 아래계층을 가리킴
	또한 단일책임원칙을 고수준에서 적용하면,상위계층이 하위계층에 비해 변경할 이유가 많음
	
	그런데 영속성계층에 대한 도메인계층의 의존성때문에,영속성계층을 변경할때마다 잠재적으로 도메인계층도 변경해야하는데,
	도메인계층은 어플리케이션에서 가장 중요한곳이라서 영속성코드때문에 도메인을 바꾸고싶진않음
	여기서 사용되는게 dip,의존성역전원칙임
	
	만약 의존성의 양쪽코드를 제어할수있다면,도메인계층에 영속성계층의 레포지토리에 대한 인터페이스를 만들고,
	영속성계층에서 이 인터페이스를 구현하는것
	이게 핵심임

  3.클린아키텍처
	클린아키텍처의 핵심은,도메인코드가 바깥으로 향하는 어떤 의존성도 없어야함을 의미함,
	대신 의존성역전으로 모든 의존성이 도메인을 향하게됨
	
	이 아키텍쳐에서 가장 중요한규칙은,계층간 모든 의존성이 안쪽으로 향해야한다는것
	이 아키텍처의 코어에는 주변유스케이스에서 접근하는 도메인 엔티티가 있고,유스케이스는 서비스를 좀 더 세분화시켜서 단일책임을 지켜주는것
	
	도메인코드에서는 어떤 영속성프레임워크나 ui프레임워크가 사용되는지 알수없어서 특정 프레임워크에 특화된 코드를 가질수없고,
	비즈니스로직에 집중하게됨(pojo)
	
	클린아키텍처의 대가는,도메인이 외부와 철저히 분리되므로,어플리케이션의 엔티티에 대한 모델을 각 계층에서 유지보수해야함
	즉 orm에 해당하는 엔티티클래스는,도메인과 영속성에 각각 만들고,데이터를 주고받을때 두 엔티티를 서로 변환해야함
	또한 도메인과 다른계층사이에서도 마찬가지임
	이렇게해서 도메인을 프레임워크에서 결합을 완전히 제거할수있음

  4.육각형 아키텍처
	헥사고날의 안에는 도메인엔티티와 이와 상호작용하는 유스케이스가 있고,헥사고날의 바깥에는 어플리케이션과 상호작용하는 다양한 어댑터들이 있음(웹,db등)
	그리고 외부에서 안쪽으로 들어오는 어댑터와,안에서 바깥으로 나가는 어댑터가 각각있고,
	코어와 어댑터간의 통신은 코어에서 만든 포트를 통해서 이뤄짐
	즉 코어에서 포트를 만들고,그걸 구현하는 어댑터가 있고,어댑터선택은 di받는식임
	
	즉  헥사고날은 포트어댑터 아키텍처임

  5.유지보수가능한 소프트웨어
	뭘 쓰든 의존성을 역전시켜서 도메인코드가 바깥에 의존하지않게한다면,영속성과 ui에 특화된 모든 문제로부터 결합을 제거하고 변경의 가짓수를 줄일수있음
	이렇게 변경할이유가 적어질수록 유지보수성은 올라감
	또한 도메인코드는 비즈니스로직에 딱 맞게 모델링할수있고,영속성코드와 ui코드도 영속성문제와 ui문제에 맞게 자유롭게 모델링할수있음
	
3.코드구성하기
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	