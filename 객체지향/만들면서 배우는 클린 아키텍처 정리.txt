1.계층형 아키텍처의 문제는 무엇일까?
  1.계층형 아키텍처는 db주도설계를 유도한다
	레이어드의 토대는 db임
	웹계층은 도메인(서비스+도메인)계층에 의존하고,도메인은 영속성계층에 의존하기때문에 자연스럽게 db에 의존하게됨
	문제는,우리는 상태가 아닌 행동을 중심으로 모델링해야하는데,
	db를 토대로 아키텍처를 만들게되면 상태중심이 되고 도메인보다 영속성계층을 먼저 만들게됨
	도메인부터 만들어야 로직을 제대로 이해했는지 확인할수있고,그걸 확인한후에 그걸기반으로 영속성계층과 웹계층을 붙여야하기때문
	
	특히 orm을 사용할경우,엔티티는 영속성계층에 위치하고,영속성모델을 비즈니스모델처럼 사용하게 되는경우가 흔함
	이러면 영속성코드가 도메인코드에 녹아들어가서 둘중 하나만 변경하기가 힘들어짐

  2.지름길을 택하기 쉬워진다
	기본적으로 레이어드아키텍처는 같은계층이나 아래의 계층에만 접근가능함
	문제는 상위계층에 위치한 컴포넌트를 아래로 내려버리는거에 대해 제한이 없다는게 문제임
	그래서 모든게 영속성계층으로 내려가게되고,영속성계층이 엄청나게 커지게됨

  3.테스트하기 어려워짐
	계층을 건너뛰는게 발생하면(웹에서 영속성계층으로 직접접근),도메인계층이 웹계층에 계속 책임이 섞이고,핵심도메인로직이 퍼저나갈수 있고,
	제일 큰 문제는,웹 테스트에서 도메인뿐아니라 영속성계층도 모킹해야한다는것
	이러면 단위테스트의 복잡도가 올라감

  4.유스케이스를 숨긴다
	레이어드는 도메인서비스의 너비에 대해 강제하지않기때문에,엄청나게 큰 유스케이스 하나가 모든걸 다 처리하게될수있음
	이러면 넓은 서비스는 영속성에 많은 의존성을 갖게되고,웹계층의 많은 컴포넌트가 여기에 의존하게됨
	이러면 테스트도 어려워지고,유스케이스를 책임지는 서비스를 찾기도 어려워짐
	
	그래서 특화된 좁은 도메인서비스가 유스케이스 하나씩만 담당하는게 좋음

  5.동시작업이 어려워짐
	영속성이 나와야 도메인이 나오고,도메인이 나와야 웹이 나오기때문에 레이어드에서는 동시작업이 매우힘듬
	물론 인터페이스를 먼저 정의하고 하면 되지만,이건 db주도설계를 하지 않아야 가능함,db주도설계는 영속성로직과 도메인로직이 뒤섞이기때문

  6.유지보수가능한 소프트웨어를 만드는데 어떻게 도움이 될까?
	레이어드도 잘쓰면(여러 추가규칙을 붙이면)괜찮지만,잘못된 방향으로 흘러가는걸 막지못한다는게 문제임
	
2.의존성 역전하기	
  1.단일책임원칙
	단일책임원칙은
		컴포넌트를 변경하는 이유는 오직 하나여야 한다
	임
	이렇게되면 컴포넌트는 딱 한가지 일만 하게되고,변경할이유도 하나임
	이러면 어떤 다른이유로 소프트웨어를 변경하더라도,이컴포넌트에 대해서는 전혀 신경쓸필요가 없어짐
	
	근데 의존성역전을 하지않으면,다른 컴포넌트에 의존할경우 바로 변경에 영향을 받음
  
  2.의존성역전원칙
	레이어드에서 계층간 의존성은 항상 다음계층인 아래계층을 가리킴
	또한 단일책임원칙을 고수준에서 적용하면,상위계층이 하위계층에 비해 변경할 이유가 많음
	
	그런데 영속성계층에 대한 도메인계층의 의존성때문에,영속성계층을 변경할때마다 잠재적으로 도메인계층도 변경해야하는데,
	도메인계층은 어플리케이션에서 가장 중요한곳이라서 영속성코드때문에 도메인을 바꾸고싶진않음
	여기서 사용되는게 dip,의존성역전원칙임
	
	만약 의존성의 양쪽코드를 제어할수있다면,도메인계층에 영속성계층의 레포지토리에 대한 인터페이스를 만들고,
	영속성계층에서 이 인터페이스를 구현하는것
	이게 핵심임

  3.클린아키텍처
	클린아키텍처의 핵심은,도메인코드가 바깥으로 향하는 어떤 의존성도 없어야함을 의미함,
	대신 의존성역전으로 모든 의존성이 도메인을 향하게됨
	
	이 아키텍쳐에서 가장 중요한규칙은,계층간 모든 의존성이 안쪽으로 향해야한다는것
	이 아키텍처의 코어에는 주변유스케이스에서 접근하는 도메인 엔티티가 있고,유스케이스는 서비스를 좀 더 세분화시켜서 단일책임을 지켜주는것
	
	도메인코드에서는 어떤 영속성프레임워크나 ui프레임워크가 사용되는지 알수없어서 특정 프레임워크에 특화된 코드를 가질수없고,
	비즈니스로직에 집중하게됨(pojo)
	
	클린아키텍처의 대가는,도메인이 외부와 철저히 분리되므로,어플리케이션의 엔티티에 대한 모델을 각 계층에서 유지보수해야함
	즉 orm에 해당하는 엔티티클래스는,도메인과 영속성에 각각 만들고,데이터를 주고받을때 두 엔티티를 서로 변환해야함
	또한 도메인과 다른계층사이에서도 마찬가지임
	이렇게해서 도메인을 프레임워크에서 결합을 완전히 제거할수있음

  4.육각형 아키텍처
	헥사고날의 안에는 도메인엔티티와 이와 상호작용하는 유스케이스가 있고,헥사고날의 바깥에는 어플리케이션과 상호작용하는 다양한 어댑터들이 있음(웹,db등)
	그리고 외부에서 안쪽으로 들어오는 어댑터와,안에서 바깥으로 나가는 어댑터가 각각있고,
	코어와 어댑터간의 통신은 코어에서 만든 포트를 통해서 이뤄짐
	즉 코어에서 포트를 만들고,그걸 구현하는 어댑터가 있고,어댑터선택은 di받는식임
	
	즉  헥사고날은 포트어댑터 아키텍처임

  5.유지보수가능한 소프트웨어
	뭘 쓰든 의존성을 역전시켜서 도메인코드가 바깥에 의존하지않게한다면,영속성과 ui에 특화된 모든 문제로부터 결합을 제거하고 변경의 가짓수를 줄일수있음
	이렇게 변경할이유가 적어질수록 유지보수성은 올라감
	또한 도메인코드는 비즈니스로직에 딱 맞게 모델링할수있고,영속성코드와 ui코드도 영속성문제와 ui문제에 맞게 자유롭게 모델링할수있음
	
3.코드구성하기
  1.계층으로 구성하기
	단순히 도메인,레포지토리,웹 이런식으로 코드를 구성하는건(레이어드 기본)
		어플리케이션의 기능조각이나 특성을 구분짓는 패키지경계가 없음
		어플리케이션이 어떤 유스케이스를 제공하는지 파악하기가 힘듬,서비스로 직접가서 하나하나봐야함
	즉 어떤기능이 어디서 호출되는지,어떤기능을 제공하는지를 알아볼수없음
	즉 인포트와 아웃포트가 코드속에 숨어있음

  2.기능으로 구성하기
	그렇다고 도메인을 중심으로 패키지를 만들고 다때려박아버리면,프로텍티드로 외부접근은 막을수있고,
	서비스의 책임을 좁히기위해 도메인+서비스가 아닌 기능+서비스가 가능해짐(해당도메인패키지에 넣을수있으니까)
	즉 소리치는 아키텍처가 가능해짐
	
	근데 이건 계층패키징보다 더 가시성이 떨어짐
	어댑터를 나타내는 패키지명이 없고,인포트 아웃포트를 확인할수없고,의존성역전으로 프로텍티드로 도메인이 실수로 영속성에 접근하는걸 막을수없음

  3.아키텍처적으로 표현력있는 패키지구조
	그래서 큰 틀은 기능으로 구성하되,각 종류마다 각각 폴더를 만들어주는게좋음
	예를들어
		어카운트
			어댑터
				인
					웹
						어카운트컨트롤러
				아웃
					퍼시스턴트
						어카운트퍼시스턴트어댑터
						스프링jpa레포지토리
			도메인
				어카운트
				액티비티
			어플리케이션
				송금서비스
				포트
					인
						송금유즈케이스
					아웃
						계좌포트
						계좌업데이트포트
	이런식으로 각각 바로 뭔지 알수있게 하면 알아보기편해짐
	즉 구조의 각 요소(어카운트)는 패키지하나에 직접 매핑되고,
	그다음레벨로 도메인을 담는 도메인패키지,
	도메인을 포함하는 서비스계층을 담는 어플리케이션 패키지
	어플리케이션패키지 속의 송금유스케이스를 구현하는 송금서비스,아웃포트 인터페이스인 계좌포트와 업데이트포트,
	이걸 구현하는건 어댑터에서 담당하는식
	
	이런 구조를 가지면 해당 api의 위치를 바로 찾을수있고,아키텍처와 코드의 갭을 줄일수있음
	또한 대부분을 퍼블릭으로 열지않고 프로텍티드로 닫아두고,어댑터에서 접근가능해야하는 포트만 열어두는식임

  4.의존성 주입의 역할
	이렇게 만든다음,의존성을 주입해줄 전용 클래스를 하나 만들고 여기서 모든 생성을 처리하는거임(모든 계층에 의존성을 가지는 컴포넌트)
	이렇게 하지않으면 어플리케이션계층에서 어댑터에 대한 의존성이 생기기때문

  5.유지보수가능한 소프트웨어를 만드는데 어떻게 도움이 될까
	이런 구조를 가지면 특정요소를 찾기위해 패키지 탐색이 쉬워지고,의사소통,개발,유지보수가 모두 조금 더 수월해짐

4.유스케이스 구현하기
  1.도메인모델 구현
	헥사고날을 사용하면 어플리케이션과 웹,영속성계층이 약결합상태기때문에 필요한대로 도메인코드를 자유롭게 모델링할수있음
	
	구현할때는 먼저 도메인을 만들고(일단 그 전에 유저스토리부터 만들어야겠지만),
	그다음에 유스케이스를 만들어야함
  
  2.유스케이스 둘러보기
	유스케이스는
		입력을 받는다
		비즈니스로직을 검증한다
		모델상태를 조작한다
		출력을 반환한다
	단계를 따름
	유스케이스는 인커밍 어댑터로부터 입력을 받지만,이때 입력유효성 검증은 하지않음
	그렇지만 유스케이스는 비즈니스규칙을 검증할 책임이 있고,이걸 도메인엔티티와 책임을 공유함
	
	비즈니스규칙을 충족하면,유스케이스는 입력을 기반으로 어떤방법으로든 모델의 상태를 변경하거나(도메인객체의 상태를 바꾸고,영속성어댑터로 전달),
	아웃고잉어댑터를 호출함
	그리고 마지막으로 출력객체로 변환하는것
	
	그리고 유스케이스는 한 서비스클래스에 모두 넣지않고 각 유스케이스별로 분리된 각각의 서비스로 만들면됨

  3.입력유효성 검증
	입력유효성검증은 유스케이스의 책임이 아니지만,어플리케이션계층의 책임이긴함
	인커밍어댑터에서 검증을 할수도있지만,인커밍어댑터는 여러 유스케이스에서 호출될텐데 각 유스케이스마다 다 맞춰줄순없음
	그래서 입력유효성검증은 입력모델이라는 DTO(커맨드)에서 검증하고 들어오는게 좋음
	또한 이때 밸리데이션 어노테이션을 사용하면 더 편하고
	
	즉 유스케이스에 들어오는 매개변수를 DTO를 받는식으로 구성하면됨

  4.생성자의 힘
	또한 DTO를 만들때는 빌더패턴이 아닌 생성자로 만드는게 실수를 덜할수있음

  5.유스케이스마다 다른 입력 모델
	그리고 비슷한 모양의 입력을 받는 유스케이스들이라도,각각 각자의 입력모델을 사용하는게 좋음
	이건 유스케이스별로 받을수있는 사전조건이 다를수있기때문
	이러면 비즈니스로직에 입력유효성검증 관심사가 섞여들어감
	
	아예 유스케이스별로 입력모델을 다르게쓴다면 유스케이스를 훨씬 명확하게 만들고,다른 유스케이스와의 결합도 제거할수있음

  6.비즈니스로직 검증
	비즈니스로직검증은 유스케이스로직의 일부임
	이건 도메인모델의 현재상태에 접근하는거고,입력유효성검증은 선언적으로(@NotNull) 검증하는것
	즉 좀 더 의미적인 유효성을 검증하는거라고 볼수있음
	예를들면 계좌에서 초과출금이 안된다는 규칙은 입력유효성검증으로 처리할수없고,모델의 현재상태를 가져와야만 알수있음(비즈니스로직 검증)
	반면에 송금되는 금액은 0보다 커야한다는 모델에 접근하지않고 선언적으로 검증할수있음(입력유효성 검증)
	
	이런식으로 구분하면 특정 유효성검증을 어디서할지,어느위치에 둘지가 명확해지고 찾기도 쉬워짐
	즉 현재상태에 접근해야하는지만 확인하면되니까
	
	이렇게 비즈니스로직 검증을 하는 가장 좋은방법은 도메인 엔티티 안에 해당 비즈니스규칙을 넣는것
	만약 어렵다면(영속성에서 값을 가져와야해서),유스케이스에서 도메인엔티티를 사용하기 전에 해도 됨
	
	즉 유효성검증코드를 호출하고,실패할경우 유효성검증 전용 예외를 던지는것
	웹어댑터는 이 에러메시지를 사용자에게 보여주거나 적절한 다른방법으로 처리하면됨

  7.풍부한 도메인모델vs빈약한 도메인모델
	헥사고날은 도메인모델을 어떻게하든 상관없음
	근데 보통 풍부한도메인모델을 선호하는편
	
	풍부한 도메인모델의 경우 유스케이스는 도메인의 작업들을 조합하고,의도만을 표현하는 도메인엔티티 메서드 호출 로직으로 변경되고,
	비즈니스로직은 유스케이스대신 엔티티에 위치하게됨
	빈약한 도메인모델의 경우,엔티티는 상태만 가지게되고,유스케이스가 비즈니스로직을 전부 가지게됨

  8.유스케이스마다 다른 출력모델
	유스케이스에서 값을 리턴해줄때도 입력처럼 각각 출력모델을 가지는게 좋고,가능한 정보가 최소가 되도록 반환해야함
	또한 유스케이스들끼리 같은 출력모델을 공유할경우에도 결합이 생기니 조심
	
	또한 도메인엔티티를 출력모델로 사용하는것도 좋지않음

  9.읽기전용 유스케이스
	쿼리용 유스케이스는(조회),쿼리를 위한 인커밍전용포트를 만들고,이걸 쿼리서비스에 구현하는방법이 있음
	이 쿼리서비스는 유스케이스서비스와 같은방식으로 동작하지만,단지 패키지 구분을 위해 나눠두는것임

  10.유지보수 가능한 소프트웨어를 만드는데 어떻게 도움이 될까
	입출력모델을 독립적으로 모델링하면 원치않는 부수효과를 피할수있음
	이건 작업이 좀 필요하지만,유스케이스별로 모델을 만들면 명확하게 이해할수있고,유지보수도 더 쉬움
	또한 여러 개발자가 다른사람이 작업중인 유스케이스를 건드리지않고 여러 유스케이스를 동시작업할수도 있음

5.웹어댑터 구현하기
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	