1.객체,설계
  1.티켓판매 구현
	스킵
  2.무엇이 문제인가
	시키지않고 직접 일을 처리하는거는,결합도가 매우올라가는 주요 원인임
	소프트웨어 모듈은 3가지 기능을 가져야하는데
		실행중에 제대로 동작하는것
		변경을 위해 동작하는것
		코드를 읽는사람과 의사소통하는것
	임
	
	시키지않고 직접 일을 처리하는거는,변경에도 취약하고,다른사람이 읽을때도 불편함
	모든 객체들은 자기의 데이터내에서는 모두 능동적으로 일을 처리할수있어야함
	이래야 보는사람이 이해하기도 쉽고,구현에 의존하지않고 api에 의존할수있기때문에 결합도도 낮아짐
	
	그냥 메서드를 호출하는거는,메서드명만 봐도 무슨일인지 알수있지만,직접 처리하는거는 신경써서 봐야하기때문에 이해하는데 코스트가 더 들어가고
	가장 큰 문제는,하위객체를 변경하는데(필드명을 바꾼다던지),상위객체의 코드도 같이 변경되어야하게 됨
	즉 변경에 취약해짐,그래서 강의존이 아닌 약의존,구현에 의존하지말고 인터페이스에 의존해서 결합도를 낮춰야한다는것

  3.설계 개선하기
	그래서 객체들은 가급적이면,자신이 의존하는 대상의 필드가 아닌 메서드에 의존하는게 좋고,
	대상의 대상같이 체인타고 내려가는건 삼가는게 좋음,또한 합성한 필드들은 프라이빗으로 잠궈두는게 좋고(캡슐화)
	
	이렇게 캡슐화가 잘 되면,의존성이 내려가고 인터페이스에만 의존하기때문에 변경이 쉬워짐
	또한 코드를 다른사람이 봐도 api명에 다 나와있으니 이해도 쉬움
	
	즉 핵심은 객체내부의 상태를 캡슐화하고,객체간에 메시지(api)를 통해서만 상호작용하는것
	이러면 자기가 쓰는 객체 내부가 어떻게 되어있건 전혀 신경쓰지않아도 됨
	
	이게 객체지향의 핵심임
	
	절차지향의 경우,데이터와 프로세스(처리로직)이 서로 별개로 위치함(도메인은 데이터홀더역할만 수행함)
	이거의 가장 큰 문제는,데이터의 변경으로 인한 영향을 지역적으로 고립시키기가 힘듬,
	데이터와 로직이 서로 떨어져있고,다른 해당 데이터를 사용하는데서는 디깅해서 사용해버리니까
	이러면 변경이 어려워짐
	
	변경하기 쉬운 설계는,한번에 하나의 클래스만 변경할수 있는 설계임
	그래서 자신이 가진 데이터를 처리하는건 자신이 하는,즉 데이터와 프로세스를 같은 모듈에 위치하게 하는방식이 객체지향임
	즉 책임(기능)을 묶어서,가능한 객체들이 하나의 책임만 가지게 하는것,하위로직이면 하위로직,하위로직묶음이면 호출하는책임만 받는식으로

	객체지향에서는 독재자가 존재하지않고 각 객체에 책임이 적절하게 분배됨
	그래서 각 객체는 자신을 스스로 책임짐
	
	객체지향의 핵심은 불필요한 의존성을 제거해서 객체사이의 결합도를 낮추는것,이걸위해 캡슐화,dip,합성등을 사용할수있음
	
	그리고 이렇게 캡슐화를 하다보면 결합도와 응집도를 트레이드오프해야 하는 경우도 있음

  4.객체지향 설계
	설계는 코드를 배치하는것
	변경을 수용할수있는 설계가 중요한 이유는,요구사항이 항상 변경되기 때문임
	그래서 좋은설계란 오늘 완성해야하는 기능을 구현하는 동시에 내일 쉽게 변경할수있는 코드를 짜는것
	또한 변경을 수용할수 있는 설계는,코드를 변경할때 버그가 추가될 가능성이 높은데,이렇게 코드를 수정하려는 의지가 꺾이는게 위험해서임
	
	그래서 의존성을 효율적으로 통제해서 변경에 좀 더 수월하게 대응할수있는 가능성을 높이는것
	
	또한 변경가능한 코드는 이해하기쉬운코드임
	객체지향은 우리가 생각한대로 돌아가는경우가 많아서 예상가능한 코드를 짜기가 쉬워짐
	

2.객체지향 프로그래밍
  1.영화 예매 시스템
	스킵
  2.객체지향프로그래밍을 향해
	객체와 클래스는 다르고,객체지향은 클래스를 지향하는게 아닌 객체를 지향하는것
	
	어떤 클래스가 필요한지를 고민하기전에,어떤 객체가 필요한지를 고민해야함
	클래스는 공통상태와 행동을 공유하는 객체들을 추상화한거고,그러니 객체가 먼저 나오고(상태와 행동),그다음에 클래스로 추상화시켜야함
	
	객체는 독립적인 존재가 아닌 기능을 구현하기위해 협력하는 공동체의 일원임
	객체를 협력하는 공동체의 일원으로 바라봐야 설계를 유연하고 확장하기쉽게만들기 좋음
	그래서 객체를 고립된존재가 아닌,협력에 참여하는 협력자로 봐라봐야함
	
	도메인은 문제를 해결하기위해 사용자가 프로그램을 사용하는 분야임
	객체지향이 좋은이유는,요구사항분석(시작)부터 프로그램을 구현(끝)까지 객체라는 동일한 추상화기법을 사용할수있기 때문임
	또한 클래스의 이름은 대응되는 도메인개념의 이름과 같거나 비슷해야하고,클래스사이의 관계도 도메인개념의 관계와 유사해야함
	
	또한 필드들은 다 프라이빗으로 두고,해당 도메인이 공개하는게 마땅한 메서드들만 퍼블릭으로 둬야함(도메인이 공개할걸 선택해야함)
	그래야 외부와 내부가 명확해지고,객체의 자율성이 보장됨(구현의자유)
	
	객체는 상태와 행동을 함께 가지는 복합적인 존재고,객체는 스스로 판단하고 행동하는 자율적인 존재임
	또한 이렇게 데이터와 기능(상태와 행동)을 객체내부로 함께 묶는걸 캡슐화라고 하고,외부에서 접근하는걸 통제하는걸 접근제어라고 함
	
	이렇게 객체 내부에 대한 접근을 통제하는 이유는,객체를 자율적인 존재로 만들기위해서임
	객체 외부에서는 객체가 어떤상태인지,어떤생각을하는지를 알아서는 안되고,결정에 직접적으로 개입해서도 안됨
	객체에게 요청하고 객체가 알아서 리턴해주기를 기다려야함
	
	캡슐화와 접근제어는 객체를 두부분으로 나눔 
	퍼블릭인터페이스와 구현임
	
	일반적으로 객체의 상태는 숨기고,행동만 외부에 공개해야함
	또한 어떤 메서드들은 서브클래스나 내부에서만 접근가능해야하면 프라이빗으로 잠궈야함(퍼블릭만 인터페이스에 들어감)
	즉 프라이빗메서드와 상태는 구현에 포함됨
	
	프로그래머의 역할은 클래스작성자와 클라이언트 프로그래머임
	즉 클래스를(새로운 데이터타입을)만드는것과,만들어진 클래스를 가져다 사용하는 역할로 분리해서 생각하면 좋음
	클라이언트 프로그래머의 목표는,필요한 클래스들을 엮어서 어플리케이션을 빠르고 안정적으로 구축하는것
	클래스 작성자는,클라프로그래머에게 필요한부분만 공개하고,나머지는 숨겨야함
	그래야 클라프로그래머의 영향을 걱정하지않고 내부구현을 맘대로 변경할수있음(구현은닉)
	
	이렇게 구현은닉을 하면,클라프로그래머는 내부구현은 무시한채 인터페이스만 알고 클래스를 사용할수있어지고
	클래스작성자는 인터페이스를 바꾸지않는한 외부영향을 걱정하지않고 내부구현을 맘대로 변경할수있어짐(퍼블릭만 안건드리면 코드수정이 자유로움)
	그래서 클래스를 만들때마다 인터페이스와 구현을 깔끔하게 분리해야함
	
	설계가 필요한이유는 변경을 관리하기위해서임,이때 쓸수있는 기법중 가장 대표적인제 접근제어임
	변경될수있는 세부구현을 프라이빗내부로 감춰서 변경으로 인한 혼란을 최소화할수있음
	
	추가적으로 객체를 사용하면,기본형을 사용하는거보다 의미를 명확하게 전달할수있음
	기본형도 구현관점의 제약은 표현할수있지만,의미를 전달할수는 없기때문
	그래서 도메인이 하나의 변수만 포함하더라도 개념을 명시적으로 표현하는게 전체설계의 명확성과 유연성을 높여줌
	
	객체지향프로그램을 작성할땐,먼저 협력의 관점에서 어떤객체가 필요한지를 정하고,객체의 공통상태와 행위를 구현하기위해 클래스를 작성함
	즉 인터페이스만 가지고 어떻게 플로우가 흘러갈지를 생각해보고,다 한뒤에 세부구현을 하는것
	
	또한 메시지와 메서드를 구분하는거도 중요함
	인터페이스의 메서드명과 매개변수는 메시지이고,그 메시지의 세부구현은 메서드임
	이거에서부터 다형성이 출발함

  3.할인요금 구하기
	상속과 다형성을 위해 추상화를 사용할수있음

  4.상속과 다형성
	컴파일시간의존성과 실행시간의존성을 구분하는건 중요함
	컴파일시간의존성은 인터페이스와 의존하고 실행시간의존성은 구현체와 의존함
	즉 코드레벨의존성과 실행시점의존성은 서로 다를수있음,이게 객체지향설계의 특징임
	
	단 코드의존성과 실행시점의존성이 다르면 다를수록 코드를 이해하기는 어려워짐
	코드뿐만아니라 객체를 생성하고 연결하는부분을 찾아야하기때문,대신 다르면 다를수록 유연하고 확장가능해짐
	즉 트레이드오프임
	
	만약 클래스를 하나 추가하고싶은데 그 클래스가 기존클래스와 매우 흡사하다면,사용할수있는게 상속임
	이렇게 부모클래스와 다른부분만을 추가해서 새 클래스를 만드는방법을 차이에 의한 프로그래밍이라고 함
	
	상속의 핵심은 부모의 인터페이스를 자식이 모두 물려받을수있다는것
	상속의 핵심은 구현의 재사용이 아님 인터페이스의 재사용이지
	
	협력자입장에서는 자신이 협력하는 객체가 뭐든 신경쓰지않고,자기가 보내려는 메시지만 잘 가면 땡이기때문
	이렇게 자식클래스가 부모클래스를 대신하는걸 업캐스팅이라고 부름
	
	메시지와 메서드는 다르다는게,이렇게 상속으로 처리했을때도 어떤 구현체를 가져다 붙이든 메시지는 같음(같은인터페이스에 같은메소드명에 같은 매개변수)
	메서드(구현)이 다를뿐,이걸 다형성이라고 부름
	다형성이란 동일한 메시지를 수신했을떄 객체의 타입에 따라 다르게 응답할수 있는 능력을 말함
	
	다형성구현의 핵심은 메시지에 응답하기위해 실행될 메서드를 컴파일시점이 아닌 실행시점에 결정한다는거임
	이걸 지연바인딩,혹은 동적바인딩이라고 부르고,컴파일시점에 정해지던걸 초기바인딩,혹은 정적바인딩이라고 부름
	
	즉 구현상속이 아닌 인터페이스상속,서브클래싱이 아닌 서브타이핑을 해야함
	코드를 재사용하고싶으면 상속이 아닌 합성을 사용하는게 좋음
	
  5.추상화와 유연성
	인터페이스는 구현보다 더 추상적임,추상클래스나 인터페이스는 구현보다 추상적임(둘다 인터페이스에 초점을 맞추기때문)
	추상화를 사용하면,추상화계층만 떼어내서 생각하면,요구사항의 정책을 높은수준에서 생각해볼수있고,추상화를 이용하면 설계가 좀 더 유연해짐
	즉 세부내용을 무시하고 상위정책을 쉽게 표현할수있어지고,기존것들을 수정하지않고 새 기능을 추가하고 확장할수있음(클래스추가하면됨)
	
	코드 재사용을 하고싶으면 상속이 아닌 합성을 해야함
	구현상속은 캡슐화를 위반하고(부모내부를 잘 알아야함),그래서 변경이 어려워짐
	또한 설계가 유연하지않아짐(부모와 자식사이의 관계를 컴파일시점에 결정해서 실행시점에 객체를 바꿀수없음,보통할일없긴하지만)
	
	합성은 매개변수로 받는거니,언제든 바꿀수있고,세터를 열어서 변경도 가능함(유연함)
	또한 인터페이스에만 의존하니까 캡슐화도 깨지지않음
	
	보통은 합성을 우선하고,다형성을 위해 인터페이스를 상속해야하면 상속을 사용하는식으로 조합해서 써야함
	
	
3.역할,책임,협력	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	