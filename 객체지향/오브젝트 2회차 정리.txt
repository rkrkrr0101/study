1.객체,설계
  1.티켓판매 구현
	스킵
  2.무엇이 문제인가
	시키지않고 직접 일을 처리하는거는,결합도가 매우올라가는 주요 원인임
	소프트웨어 모듈은 3가지 기능을 가져야하는데
		실행중에 제대로 동작하는것
		변경을 위해 동작하는것
		코드를 읽는사람과 의사소통하는것
	임
	
	시키지않고 직접 일을 처리하는거는,변경에도 취약하고,다른사람이 읽을때도 불편함
	모든 객체들은 자기의 데이터내에서는 모두 능동적으로 일을 처리할수있어야함
	이래야 보는사람이 이해하기도 쉽고,구현에 의존하지않고 api에 의존할수있기때문에 결합도도 낮아짐
	
	그냥 메서드를 호출하는거는,메서드명만 봐도 무슨일인지 알수있지만,직접 처리하는거는 신경써서 봐야하기때문에 이해하는데 코스트가 더 들어가고
	가장 큰 문제는,하위객체를 변경하는데(필드명을 바꾼다던지),상위객체의 코드도 같이 변경되어야하게 됨
	즉 변경에 취약해짐,그래서 강의존이 아닌 약의존,구현에 의존하지말고 인터페이스에 의존해서 결합도를 낮춰야한다는것

  3.설계 개선하기
	그래서 객체들은 가급적이면,자신이 의존하는 대상의 필드가 아닌 메서드에 의존하는게 좋고,
	대상의 대상같이 체인타고 내려가는건 삼가는게 좋음,또한 합성한 필드들은 프라이빗으로 잠궈두는게 좋고(캡슐화)
	
	이렇게 캡슐화가 잘 되면,의존성이 내려가고 인터페이스에만 의존하기때문에 변경이 쉬워짐
	또한 코드를 다른사람이 봐도 api명에 다 나와있으니 이해도 쉬움
	
	즉 핵심은 객체내부의 상태를 캡슐화하고,객체간에 메시지(api)를 통해서만 상호작용하는것
	이러면 자기가 쓰는 객체 내부가 어떻게 되어있건 전혀 신경쓰지않아도 됨
	
	이게 객체지향의 핵심임
	
	절차지향의 경우,데이터와 프로세스(처리로직)이 서로 별개로 위치함(도메인은 데이터홀더역할만 수행함)
	이거의 가장 큰 문제는,데이터의 변경으로 인한 영향을 지역적으로 고립시키기가 힘듬,
	데이터와 로직이 서로 떨어져있고,다른 해당 데이터를 사용하는데서는 디깅해서 사용해버리니까
	이러면 변경이 어려워짐
	
	변경하기 쉬운 설계는,한번에 하나의 클래스만 변경할수 있는 설계임
	그래서 자신이 가진 데이터를 처리하는건 자신이 하는,즉 데이터와 프로세스를 같은 모듈에 위치하게 하는방식이 객체지향임
	즉 책임(기능)을 묶어서,가능한 객체들이 하나의 책임만 가지게 하는것,하위로직이면 하위로직,하위로직묶음이면 호출하는책임만 받는식으로

	객체지향에서는 독재자가 존재하지않고 각 객체에 책임이 적절하게 분배됨
	그래서 각 객체는 자신을 스스로 책임짐
	
	객체지향의 핵심은 불필요한 의존성을 제거해서 객체사이의 결합도를 낮추는것,이걸위해 캡슐화,dip,합성등을 사용할수있음
	
	그리고 이렇게 캡슐화를 하다보면 결합도와 응집도를 트레이드오프해야 하는 경우도 있음

  4.객체지향 설계
	설계는 코드를 배치하는것
	변경을 수용할수있는 설계가 중요한 이유는,요구사항이 항상 변경되기 때문임
	그래서 좋은설계란 오늘 완성해야하는 기능을 구현하는 동시에 내일 쉽게 변경할수있는 코드를 짜는것
	또한 변경을 수용할수 있는 설계는,코드를 변경할때 버그가 추가될 가능성이 높은데,이렇게 코드를 수정하려는 의지가 꺾이는게 위험해서임
	
	그래서 의존성을 효율적으로 통제해서 변경에 좀 더 수월하게 대응할수있는 가능성을 높이는것
	
	또한 변경가능한 코드는 이해하기쉬운코드임
	객체지향은 우리가 생각한대로 돌아가는경우가 많아서 예상가능한 코드를 짜기가 쉬워짐
	

2.객체지향 프로그래밍
  1.영화 예매 시스템
	스킵
  2.객체지향프로그래밍을 향해
	객체와 클래스는 다르고,객체지향은 클래스를 지향하는게 아닌 객체를 지향하는것
	
	어떤 클래스가 필요한지를 고민하기전에,어떤 객체가 필요한지를 고민해야함
	클래스는 공통상태와 행동을 공유하는 객체들을 추상화한거고,그러니 객체가 먼저 나오고(상태와 행동),그다음에 클래스로 추상화시켜야함
	
	객체는 독립적인 존재가 아닌 기능을 구현하기위해 협력하는 공동체의 일원임
	객체를 협력하는 공동체의 일원으로 바라봐야 설계를 유연하고 확장하기쉽게만들기 좋음
	그래서 객체를 고립된존재가 아닌,협력에 참여하는 협력자로 봐라봐야함
	
	도메인은 문제를 해결하기위해 사용자가 프로그램을 사용하는 분야임
	객체지향이 좋은이유는,요구사항분석(시작)부터 프로그램을 구현(끝)까지 객체라는 동일한 추상화기법을 사용할수있기 때문임
	또한 클래스의 이름은 대응되는 도메인개념의 이름과 같거나 비슷해야하고,클래스사이의 관계도 도메인개념의 관계와 유사해야함
	
	또한 필드들은 다 프라이빗으로 두고,해당 도메인이 공개하는게 마땅한 메서드들만 퍼블릭으로 둬야함(도메인이 공개할걸 선택해야함)
	그래야 외부와 내부가 명확해지고,객체의 자율성이 보장됨(구현의자유)
	
	객체는 상태와 행동을 함께 가지는 복합적인 존재고,객체는 스스로 판단하고 행동하는 자율적인 존재임
	또한 이렇게 데이터와 기능(상태와 행동)을 객체내부로 함께 묶는걸 캡슐화라고 하고,외부에서 접근하는걸 통제하는걸 접근제어라고 함
	
	이렇게 객체 내부에 대한 접근을 통제하는 이유는,객체를 자율적인 존재로 만들기위해서임
	객체 외부에서는 객체가 어떤상태인지,어떤생각을하는지를 알아서는 안되고,결정에 직접적으로 개입해서도 안됨
	객체에게 요청하고 객체가 알아서 리턴해주기를 기다려야함
	
	캡슐화와 접근제어는 객체를 두부분으로 나눔 
	퍼블릭인터페이스와 구현임
	
	일반적으로 객체의 상태는 숨기고,행동만 외부에 공개해야함
	또한 어떤 메서드들은 서브클래스나 내부에서만 접근가능해야하면 프라이빗으로 잠궈야함(퍼블릭만 인터페이스에 들어감)
	즉 프라이빗메서드와 상태는 구현에 포함됨
	
	프로그래머의 역할은 클래스작성자와 클라이언트 프로그래머임
	즉 클래스를(새로운 데이터타입을)만드는것과,만들어진 클래스를 가져다 사용하는 역할로 분리해서 생각하면 좋음
	클라이언트 프로그래머의 목표는,필요한 클래스들을 엮어서 어플리케이션을 빠르고 안정적으로 구축하는것
	클래스 작성자는,클라프로그래머에게 필요한부분만 공개하고,나머지는 숨겨야함
	그래야 클라프로그래머의 영향을 걱정하지않고 내부구현을 맘대로 변경할수있음(구현은닉)
	
	이렇게 구현은닉을 하면,클라프로그래머는 내부구현은 무시한채 인터페이스만 알고 클래스를 사용할수있어지고
	클래스작성자는 인터페이스를 바꾸지않는한 외부영향을 걱정하지않고 내부구현을 맘대로 변경할수있어짐(퍼블릭만 안건드리면 코드수정이 자유로움)
	그래서 클래스를 만들때마다 인터페이스와 구현을 깔끔하게 분리해야함
	
	설계가 필요한이유는 변경을 관리하기위해서임,이때 쓸수있는 기법중 가장 대표적인제 접근제어임
	변경될수있는 세부구현을 프라이빗내부로 감춰서 변경으로 인한 혼란을 최소화할수있음
	
	추가적으로 객체를 사용하면,기본형을 사용하는거보다 의미를 명확하게 전달할수있음
	기본형도 구현관점의 제약은 표현할수있지만,의미를 전달할수는 없기때문
	그래서 도메인이 하나의 변수만 포함하더라도 개념을 명시적으로 표현하는게 전체설계의 명확성과 유연성을 높여줌
	
	객체지향프로그램을 작성할땐,먼저 협력의 관점에서 어떤객체가 필요한지를 정하고,객체의 공통상태와 행위를 구현하기위해 클래스를 작성함
	즉 인터페이스만 가지고 어떻게 플로우가 흘러갈지를 생각해보고,다 한뒤에 세부구현을 하는것
	
	또한 메시지와 메서드를 구분하는거도 중요함
	인터페이스의 메서드명과 매개변수는 메시지이고,그 메시지의 세부구현은 메서드임
	이거에서부터 다형성이 출발함

  3.할인요금 구하기
	상속과 다형성을 위해 추상화를 사용할수있음

  4.상속과 다형성
	컴파일시간의존성과 실행시간의존성을 구분하는건 중요함
	컴파일시간의존성은 인터페이스와 의존하고 실행시간의존성은 구현체와 의존함
	즉 코드레벨의존성과 실행시점의존성은 서로 다를수있음,이게 객체지향설계의 특징임
	
	단 코드의존성과 실행시점의존성이 다르면 다를수록 코드를 이해하기는 어려워짐
	코드뿐만아니라 객체를 생성하고 연결하는부분을 찾아야하기때문,대신 다르면 다를수록 유연하고 확장가능해짐
	즉 트레이드오프임
	
	만약 클래스를 하나 추가하고싶은데 그 클래스가 기존클래스와 매우 흡사하다면,사용할수있는게 상속임
	이렇게 부모클래스와 다른부분만을 추가해서 새 클래스를 만드는방법을 차이에 의한 프로그래밍이라고 함
	
	상속의 핵심은 부모의 인터페이스를 자식이 모두 물려받을수있다는것
	상속의 핵심은 구현의 재사용이 아님 인터페이스의 재사용이지
	
	협력자입장에서는 자신이 협력하는 객체가 뭐든 신경쓰지않고,자기가 보내려는 메시지만 잘 가면 땡이기때문
	이렇게 자식클래스가 부모클래스를 대신하는걸 업캐스팅이라고 부름
	
	메시지와 메서드는 다르다는게,이렇게 상속으로 처리했을때도 어떤 구현체를 가져다 붙이든 메시지는 같음(같은인터페이스에 같은메소드명에 같은 매개변수)
	메서드(구현)이 다를뿐,이걸 다형성이라고 부름
	다형성이란 동일한 메시지를 수신했을떄 객체의 타입에 따라 다르게 응답할수 있는 능력을 말함
	
	다형성구현의 핵심은 메시지에 응답하기위해 실행될 메서드를 컴파일시점이 아닌 실행시점에 결정한다는거임
	이걸 지연바인딩,혹은 동적바인딩이라고 부르고,컴파일시점에 정해지던걸 초기바인딩,혹은 정적바인딩이라고 부름
	
	즉 구현상속이 아닌 인터페이스상속,서브클래싱이 아닌 서브타이핑을 해야함
	코드를 재사용하고싶으면 상속이 아닌 합성을 사용하는게 좋음
	
  5.추상화와 유연성
	인터페이스는 구현보다 더 추상적임,추상클래스나 인터페이스는 구현보다 추상적임(둘다 인터페이스에 초점을 맞추기때문)
	추상화를 사용하면,추상화계층만 떼어내서 생각하면,요구사항의 정책을 높은수준에서 생각해볼수있고,추상화를 이용하면 설계가 좀 더 유연해짐
	즉 세부내용을 무시하고 상위정책을 쉽게 표현할수있어지고,기존것들을 수정하지않고 새 기능을 추가하고 확장할수있음(클래스추가하면됨)
	
	코드 재사용을 하고싶으면 상속이 아닌 합성을 해야함
	구현상속은 캡슐화를 위반하고(부모내부를 잘 알아야함),그래서 변경이 어려워짐
	또한 설계가 유연하지않아짐(부모와 자식사이의 관계를 컴파일시점에 결정해서 실행시점에 객체를 바꿀수없음,보통할일없긴하지만)
	
	합성은 매개변수로 받는거니,언제든 바꿀수있고,세터를 열어서 변경도 가능함(유연함)
	또한 인터페이스에만 의존하니까 캡슐화도 깨지지않음
	
	보통은 합성을 우선하고,다형성을 위해 인터페이스를 상속해야하면 상속을 사용하는식으로 조합해서 써야함
	
	
3.역할,책임,협력	
  1.협력
	협력이란 객체들이 앱의 기능을 구현하기위해 수행하는 상호작용을 말함
	객체들이 협력에 참여하기위해 수행하는 로직을 책임이라고 부르고,객체들이 협력안에서 수행하는 책임들이 모여 역할을 구성함
	
	두 객체의 협력은 메시지전송이라는 유일한 커뮤니케이션 수단으로만 가능함
	객체는 다른객체 내부의 상세구현에 대해 접근할수없기때문에 메시지전송만 가능함
	
	메시지를 수신한 객체는,메서드를 실행해서 요청에 응답함
	여기서 중요한건,메시지를 처리할 방법을 스스로 선택한다는점이 중요함
	즉 외부의객체는 오직 메시지를 전송할수 있을 뿐이며,메시지를 어떻게 처리할지는 메시지를 수신한 객체가 직접 결정함
	
	이때 메시지를 전달할 객체를 선택하는 기준은,해당 정보를 가장 잘 알고있는 객체에게 전달하는식임
	이렇게 캡슐화를 통해 객체의 자율성을 올리고 변경의 파급효과를 제한함으로써,변경도 쉬워지게 됨
	
	객체가 가질수있는 상태와 행동은,이 협력이라는 문맥안에서 필요로해서 생겨나야함
	상태와 행동이 있어서 그쪽으로 협력하는게 아님
	그래서 협력이 바뀌면 객체가 제공하는 행동도 바뀌어야함
	즉 협력은 객체를 설계할때 필요한 문맥을 제공함

  2.책임
	협력에 참여하기위해 객체가 수행하는 행동을 책임이라고 부름
	책임은 객체에 의해 정의되는 응집도있는 행위의 집합으로,객체가 무엇을 알고있는가와 무엇을 할수있는가로 구성됨
	
	여기서 하는것엔
		객체를 생성하거나 계산을 수행하는등을 하는것
		다른객체의 행동을 시작시키는것
		다른객체의 활동을 제어하고 조절하는것
	아는것엔
		사적인 정보에 관해 아는것
		관련된 객체에 관해 아는것
		자신이 유도하거나 계산할수있는것에 관해 아는것
	이 있음
	일반적으로 책임과 메시지의 크기는 다르고,책임은 객체가 수행할수 있는 행동을 종합적이고 간략하게 서술하기때문에,메시지보다 추상적이고 개념도 더 큼
	단순한 책임이 여러 메시지로 분할되기도 하고,하나의 객체로만 하던 책임이 여러객체의 협력으로 만들수있는 책임으로 자라기도 함
	
	여기서 중요한건,책임의 관점에서 아는것과 하는것은 밀접하게 연관되어있음
	객체는 자신이 맡은 책임을 수행하는데 필요한 정보를 알고있을 책임이 있고,객체는 자신이 할수없는 작업을 도와줄 객체를 알고있을 책임이 있음
	즉 책임을 수행하기위해서는 그 책임을 수행하는데 필요한 정보도 알고있을 책임이 따라온다는것
	
	책임은 객체지향설계의 핵심임
	협력이 중요한 이유도,객체에게 할당할 책임을 결정할수있는 문맥을 제공하기 때문
	객체의 구현방법은 책임보다는 상대적으로 덜중요하고,책임을 결정한다음에 고민해도 됨
	
	책임은 해당 정보를 가장 잘 알고있는 전문가한테 그책임을 할당하는게 가장 기본적인 방법임,이를 정보전문가 패턴이라고 함
	이를위해 먼저 협력을 정의해야하는데,이떄 시스템이 사용자에게 제공하는 기능을 하나의 책임으로 바라본다음,
	해당 책임을 분해해서 적절한 위치로 던지는걸 가장 작은책임이 나올때까지 재귀하는것
	즉 먼저 책임(메시지명)을 선택한다음,메시지를 처리할수있는 가장 적절한 객체(가장 관련정보를 많이알고있는 객체)를 찾아서 맡기는식
	또한 해당객체가 모르는정보가 있다면,새로운 책임을 만들고 그걸 가장적절한 객체에 맡기는걸 반복하는거를 모르는정보가 없어질때까지 반복하는것
	
	이렇게 결정된 메시지가 객체의 퍼블릭 인터페이스를 구성하게됨
	즉 객체의 책임을 식별해나가는 과정에서,최종적으로 얻게되는 결과물은 객체들의 인터페이스와 오퍼레이션의 목록임
	
	물론 꼭 이렇게만 되는건 아님,어떤경우엔 응집도와 결합도관점에서 정보전문가가 아닌 다른객체에 맡겨야할때도 있음
	그래도 기본은 정보전문가를 찾는거라는것(일단 자율성을 먹고들어가니까 제일 점수높을 확률이 큼)
	
	객체에게 책임을 할당할때 필요한 메시지를 먼저 식별하고,메시지를 처리할 객체를 나중에 선택하는,
	객체가 메시지를 선택하는게 아닌 메시지가 객체를 선택하게 해야하는 이유는
		객체가 최소한의 인터페이스를 가지게됨(메시지가 있어야 메서드가 생김)
		객체가 추상적인 인터페이스를 가지게됨(메시지가 먼저 나오고 그뒤에 객체가 선택되니,추상적인 메서드명,무엇을 하는지만 표현하는 이름이 나옴)
	임
	
	객체지향에서 가장 쉬운 실수는,행동이 아닌 상태에 초점을 맞추는것
	객체에 필요한 상태가 무엇인지를 결정하고,그후로 상태에 필요한 행동을 결정하는건 내부구현이 인터페이스에 노출되기때문에 캡슐화를 저해함
	그래서 구현에 대한 결정을 뒤로 미루면서 객체의 행위를 고려하기위해서는 협력이라는 문맥안에서 객체를 생각해야함

  3.역할
	객체를 협력이라는 문맥안에서 특정 목적을 가지게됨,이때 객체의 목적은 협력안에서 객체가 맡게되는 책임의 집합임,이걸 역할이라고 부름
	실제로 협력을 모델링할때는 특정객체가 아닌 역할에게 책임을 할당한다고 생각해야함
	
	역할을 사용하면,이걸통해 유연하고 재사용가능한 협력을 얻을수있음
	즉 구현체가 아닌 인터페이스에 맡긴다고 생각하면됨(사실상 설계할땐 모든게 인터페이스기도 하고)
	그래서 객체가 아닌 책임에 초점에 맞추고,같은책임이라면 역할이라는걸로 묶어버리는것(슬롯이라고 생각해도됨)
	
	만약 대체가 필요없다면,역할대신 객체를 사용해도됨,즉 단 한종류의 객체만 협력에 참여한다면 역할대신 객체를 간주해도됨(서비스같은거)
	즉 정석대로는
		협력->역할->객체->클래스
	순서임,보통 설계초반에는 역할인지 객체인지 알기어렵고,다 객체로 간주하다가 책임과 협력을 정제해가면서 필요해지면 객체를 역할로 분리해내면됨
	
	역할은 공통의 책임을 바탕으로 객체의 종류를 숨겨서,역할을 객체의 추상화로 간주할수있음
	그래서 이경우에도 구현에 상관없이 상위수준정책을 쉽게 표현할수있고,세부사항대신 핵심을 강조할수있다는 장점은 같음
	
	객체에게 중요한것은 행동이고,역할이 중요한이유는 같은협력을 수행하는 객체들을 추상화할수있기때문임
	
	
4.설계품질과 트레이드오프	
  1.데이터 중심의 영화예매시스템
	객체지향설계에서는 상태(데이터)를 분할의 중심축으로 삼을수도있고,책임(행동)을 분할의 중심축으로 삼을수도 있음
	데이터중심관점에서는 객체가 자신이 포함하고있는 데이터를 조작하는 행동을 정의하고
	책임중심관점에서는 다른객체가 요청할수있는 행동을 위해 상태를 추가함
	
	시스템을 분할할떄는 데이터중심이 아닌 책임중심으로 초점을 맞춰야함,그래야 변경이 쉬움
	
	객체의 상태는 구현에 속하고,구현은 불안정하기때문에 변하기쉬움
	그래서 상태를 분할의 중심축으로 삼으면,구현세부사항이 인터페이스로 스며들어 캡슐화가 깨짐
	그래서 상태변경은 인터페이스의 변경을 초래하고,이 인터페이스에 의존하는 모든 객체에게 변경의 영향이 퍼지게됨
	그래서 데이터에 초점을 맞추는 설계는 변경에 취약함
	
	그에비해 책임(행동)은 인터페이스에 속함
	객체는 책임을 드러내는 안정적인 인터페이스뒤로 책임을 수행하는데 필요한 상태를 캡슐화해서 구현변경에 대한 파장이 외부로 퍼져나가는걸 방지함
	그래서 책임에 초점을 맞추면 상대적으로 변경에 안정적인 설계를 얻을수있게됨
	
	
	데이터중심설계는 일단 객체가 내부에 저장해야하는 데이터가 무엇인가를 묻는것으로 시작됨
	즉 객체의 필드들을 미리 정해둔다음에 행동을 끼워맞춤
	특히 객체의 종류를 저장하는 인스턴스변수(타입선택형)나 인스턴스의 종류에 따라 배타적으로 사용될 인스턴스변수가 같은클래스내에 있는게 흔한 안티패턴임
	
	또한 필드가 먼저 나오고 행동이 나오기때문에,필드명이 인터페이스에 노출될 확률이 높음

  2.설계 트레이드오프
	좋은설계의 지표로는 캡슐화,응집도,결합도가 널리 사용됨
	
	캡슐화는 외부에서 알필요가 없는부분을 감춰서,대상을 단순화시키는 추상화의 한 종류임
	불안정한 구현을 안정적인 인터페이스뒤로 숨기기위해 사용됨
	객체내부의 변경될수있는 어떤것이라도 다 캡슐화해야함
	
	응집도는 모듈에 포함된 내부요소들이 연관된 정도를 나타냄
	모듈내의 요소들이 하나의 목적을위해 긴밀하게 협력하면 높은응집도,모듈내의 요소들이 서로 다른 목적을 추구한다면 낮은응집도임
	즉 객체가 얼마나 관련높은책임들을 모아뒀는지를 나타냄
	
	결합도는 의존성의 정도를 나타내고,다른모듈에 대해 얼마나 많은지식을 갖고있는지를 나타냄
	어떤모듈이 다른모듈에 대해 너무 자세한(보통 구현)부분까지 알고있다면 두 모듈은 높은 결합도를 가짐(강의존)
	어떤모듈이 다른모듈에 대해 꼭 필요한(보통 인터페이스)부분만 알고있다면 두 모듈은 낮은 결합도를 가짐(약의존)
	
	일반적으로 좋은설계란 높은응집도와 낮은결합도를 가진 모듈로 구성된 설계를 의미함
	이러면 변경이 발생할때 한모듈만 고치면되게됨
	
	추가적으로 변경될 확률이 적은 안정적인모듈은 맘대로 의존해도됨(String같은거)
	단 내가 직접 작성한 코드는 항상 불안정하고,언제든 변경될 가능성이 높으니 최대한 낮은 결합도를 유지해야함
	
	어떤 설계를 쉽게 변경할수있다면 높은응집도를 가진요소들로 구성되어있고,요소사이의 결합도가 낮을 확률이 높음
	코드가 변경에 강하게 저항한다면,구성요소들의 응집도가 낮고 강결합되어있을확률이 높음
	
	또한 캡슐화의 정도가 응집도와 결합도에 큰 영향을 미침
	캡슐화를 지키면 응집도는 높아지고 결합도는 낮아지지만,캡슐화가 깨지면 응집도는 낮아지고 결합도는 높아짐

  3.데이터 중심의 영화예매시스템의 문제점
	데이터중심의 핵심문제는 캡슐화를 다루는 방식임
	캡슐화의 정도가 응집도와 결합도를 결정하는데,데이터중심설계는 캡슐화를 위반하기 쉽기때문에 응집도가낮고 결합도가 높은 객체들이 나올 확률이 큼
	즉
		캡슐화위반
		높은결합도
		낮은응집도
	임
	
	캡슐화에서 가장 큰 문제는 인터페이스에 해당 필드명이 그대로 나오기쉽고(getFee,setFee),
	실제로 사용하지않을 게터세터가 추가되기쉬워짐(추측에 의한 설계)
	
	또한 이렇게 내부구현이 인터페이스에 드러나면 캡슐화가 깨지고,이를통해 구현이 객체의 인터페이스에 드러나고,그래서 클라이언트는 구현에 강결합됨
	예를들면 fee를 money로 바꾸게되면,메서드명들도 다 바꿔야하고(getMoney),클라에서 메서드를 호출하는거도 다 바꿔야함
	추가적으로 여러 데이터객체들을 사용하는 제어로직이 특정 객체에 집중돼서,하나의 제어객체가 다수의 데이터객체에 강결합되기쉬움
	즉 전체시스템이 하나의 의존성덩어리가 되기 쉬움
	
	또한 응집도측면에서도 서로 다른이유로 변경되는 코드가 하나의 모듈에 들어있기쉬워짐
	그래서 변경의 이유를 모듈내에서 통일시키지 못해서,모듈내의 다른코드에 사이드이펙트를 일으키기쉽고
	하나의 변경사항을 위해 여러모듈을 수정해야하고,버그확률이 올라감
	어떤 변경사항을 수용하기위해 하나이상의 클래스를 수정해야하는것은 응집도가 낮다는 증거임

  4.자율적인 객체를 향해
	캡슐화는 설계의 제1원리임
	데이터중심설계의 문제는 캡슐화를 깨기쉽다는거임
	객체는 자신의 데이터목록을 노출해서는 안되고 반드시 캡슐화해야함
	객체는 스스로의 상태를 책임져야하고 외부에 정의된 메서드를 통해서만 상태에 접근할수 있어야함
	
	여기서 메서드는 단순히 값을 반환하거나 수정하는 게터세터를 의미하는게 아닌,객체가 책임져야하는 무언가를 수행하는 메서드임
	즉 필드를 프라이빗으로 잠궈도,게터세터열어두면 퍼블릭이랑 똑같은거니까..
	게터세터를 열어두면 해당변수의 존재사실을 인터페이스를 통해 외부로 노출시키게 된다는 추가적인 문제도 있음
	
	즉 해결법은 상태를 직접 열어두는게 아닌,상태를 변경시킬수있는 메서드를 세터보다 더 발전된 형태로 제공해야함
	
	데이터중심설계에서 그나마 나은방법은,이 객체가 어떤 데이터를 포함해야하는가?를
		이 객체가 어떤 데이터를 포함해야하는가?
		이 객체가 데이터에 대해 수행해야하는 행동은 무엇인가?
	이렇게 분리해서 둘다 생각한후 조합하는것
	이를통해 객체의 내부상태를 저장하는 방식과,저장된 상태에 대해 호출할수있는 행동집합을 얻을수있음

  5.하지만 여전히 부족하다
	이러면 좀 나아지긴하는데,그래도 여전히 캡슐화가 깨지기 쉬움
	변경메서드의 매개변수로 객체내부의 필드를 변경하니,필드의 타입을 변경하든가 하면 변경에 바로 영향을 받음
	즉 캡슐화는 단순히 객체 내부의 데이터를 외부로부터 감추는것 이상으로,변경될수있는 어떤것이라도 감추는것을 의미함
	
	이렇게 외부로 내부구현이 노출되면 결합도는 올라가고,변경의 영향이 전파될 확률이 높아짐(높은 결합도)
	또한 하나의 변경을 수용하기위해 코드의 여러곳을 동시에 변경해야할수도 있음(낮은 응집도)
	
	즉 모든건 캡슐화가 깨져서 구현이 인터페이스로 흘러나와서 생기는 문제임

  6.데이터중심설계의 문제점
	데이터중심설계가 변경에 취약한 이유는
		너무 이른시기에 데이터에 대해 결정하는걸 강요당함
		협력이라는 문맥을 고려하지않고 오퍼레이션이 결정됨
	이 두가지임
	데이터중심설계에서는 행동보다는 상태에 초점이 맞춰지고,내부구현에 속하는 상태를 먼저 설계하게됨
	데이터중심설계에 익숙한 사람들은,데이터와 기능을 분리하는 절차적 프로그래밍방식을 따름
	이건 상태와 행동을 하나로 캡슐화하는 객체지향 패러다임에 반하는것
	그래서 게터세터가 과도하게 추가되고,이 데이터객체를 사용하는 절차를 분리된 별도의 객체안에 구현하게됨
	
	데이터를 처리하는작업과 데이터가 같은객체에 있더라도,데이터를 먼저 결정하고 행동을 나중에 결정하게되면,
	데이터에 대한 지식이 객체의 인터페이스에 고스란히 드러나게됨
	그래서 인터페이스는 구현을 캡슐화하는데 실패하고 변경에 취약해지게됨
	
	즉 너무 이른시기에 데이터에 대해 고민하기때문에 캡슐화에 실패하는것
	객체지향은 협력하는 객체들의 공동체를 구축하는것,그래서 책임이 제일먼저 나오고 이를 수행할 객체를 결정하는,
	즉 설계의 무게중심은 내부가 아닌 외부에있어야함,가장 중요한건 객체가 다른 객체와 협력하는 방법이기때문
	
	
5.책임 할당하기	
  1.책임주도설계를 향해
	책임주도설계를 하려면 데이터보다 행동을 먼저 결정하고,협력이라는 문맥안에서 책임을 결정해야함
	데이터는 객체가 책임을 수행할때 필요한 재료를 제공할뿐임
	또한 협력에 적합한 책임이란,메시지 수신자가 아닌 메시지 전송자에게 적합한 책임을 의미함
	즉 객체입장에서 자기가 가지고싶은 책임이 아닌,클라입장에서 시키고싶은 책임을 줘야함
	그래서 메시지가 나온다음에 그 메시지를 누구한테 할당할건지 정하는식으로 가야함
	
	즉 메시지를 결정하고 이메시지를 누구한테 전송할지를 찾는식으로 설계가 진행됨
	메시지는 클라이언트의 의도를 표현하고,객체를 결정하기전에 객체가 수신할 메시지가 먼저 결정됨
	그래서 메시지가 먼저 결정되므로 송신자는 수신자에 대한 어떤 가정도 할수없고,즉 캡슐화가 됨
	
	책임주도설계의 흐름은
		시스템이 사용자에게 제공해야하는 시스템책임을 파악
		시스템책임을 더 작은책임으로 분할
		분할된 책임을 수행할수있는 적절한 객체 또는 역할을 찾아 책임을 할당
		객체가 책임을 수행하는 도중 다른객체의 도움이 필요하면,이를 책임질 객체 또는 역할을 찾음
		해당객체나 역할에게 책임을 할당해서 두 객체가 협력하게 함
	순서로 진행됨

  2.책임할당을 위한 grasp패턴
	설계를 시작하기전에 도메인에 대한 개략적인 모습을 그려보면 유용함
	이 도메인개념들을 책임할당의 대상으로 사용하면 코드에 도메인의 모습을 투영하기가 쉬워짐
	이 도메인개념은,도메인명과 도메인끼리의 대략적인 관계(1대다같은거)를 표현하면됨
	이때는 개념들의 의미와 관계가 정확하거나 완벽할필요없음,그냥 시작점이 필요한거임
	그냥 적당히 해두고 넘어가면됨
	
	도메인을 만들었으면,어플리케이션이 제공해야하는 기능(유저스토리)를 어플리케이션의 책임으로 생각하는것이 제일 처음임
	즉 기능요청을 어플리케이션에 대한 메시지로 간주하고,이 메시지를 책임질 첫 객체를 선택하는걸로 설계를 시작하면됨
	이때 메시지는 수신할객체가 아닌 전송할객체의 의도를 반영해서 이름과 매개변수,리턴타입이 결정되어야함
	즉,첫 질문은 메시지를 전송할객체는 무엇을 원하는가 임
	
	그리고 메시지를 정하고나면 메세지를 수신할 적합한 객체는 누구인가 를 선택하면됨
	이때는 객체가 상태와 행동을 통합한 캡슐화의 단위라는 사실에 집중하고,객체의 책임과 책임을 수행하는데 필요한 상태는 동일한 객체안에 존재해야하니,
	책임을 수행할 정보를 알고있는 객체에게(정보전문가) 책임을 할당하면됨
	
	책임을 할당하고나면 대충 구현을 상상해보면서,얘가 처리할수 없는 작업이 있다면 그걸 또 메시지로 뽑아내고,해당 메시지를 처리할수있는 객체를 찾으면됨
	
	이 정보전문가패턴만으로 다 해결되지는 않음,설계는 트레이드오프고 다른것들도 신경써야함
	대표적으로 응집도와 결합도가 있음
	만약 지금 선택한애가 정보 전문가라고 해도,도메인의존성에 없던 다른 도메인을 의존해야한다면,
	원래 의존성을 유지하고 진행하는 방법이없나 생각해봐야함
	
	또한 해당 책임이 원래 있던 책임들과 결이 많이 다를경우엔(특히 레벨구분,상위레벨과 하위레벨)떼어내는게 좋음
	또한 비슷한 책임을 가지고있는애가 있다면 그쪽으로 몰아주는게 좋음
	
	그리고 메서드 시그니처의 리턴값을 생각할때 생각해야하는건 객체생성책임임
	결합된객체의 객체생성책임은
		b가 a객체를 포함하거나 참조
		b가 a객체를 기록
		b가 a객체를 긴밀하게 사용
		b가 a객체를 초기화하는데 필요한데이터를 가지고있음(b는 a에대해 전문가임)
	를 가장 많이 가진애한테 맡기면됨
	
	이렇게 대충 설계스케치를 그려두고나서,구현하면서 검증하면서 수정하면됨

  3.구현을 통한 검증
	책임이 결정됐으면,일단 메서드를 추가하고,이떄 필요한 변수를 결정해서 필드로 깔면됨
	또한 다른 객체에게 보낼 요청이 있으면,가급적 프라이빗메서드로 빼내서 송신자의 의도를 명시적으로 드러내게 하는게 좋음
	
	이 과정에서 변경에 취약한곳이 드러나면,해당부분을 추상화시키는식으로 대응하면됨(변경의 이유에 따라 클래스를 분리)
	이때 구현을 공유해야하면 추상클래스,필요없으면 인터페이스를 쓰면됨(대표적으로 객체타입같은게 필요해지면 다형성을 사용해야한다는 근거임)
	
  4.책임주도설계의 대안
	이게 어렵다면 그냥 데이터주도설계를 한 다음 리팩터링하는방법도 있음
	즉 만들어진것들의 책임을 적절히 분배하는것
	이때,제일먼저 긴메서드는 이해하기힘드니 자르고,그뒤로 각 메서드들을 적절한 책임으로 이동시키는것
	
	이때 가장 우선되는건,객체가 자신이 소유하는데이터는 자신이 처리하도록 만드는거고,캡슐화,응집도,결합도를 따져가면서 옮기면됨
	
6.메시지와 인터페이스
  1.협력과 메시지
	협력은 어떤 객체가 다른객체에게 무언가 요청할때 시작됨
	이때 메시지는 객체사이의 협력이 가능하게하는 유일한 매개체임
	
	이때 협력관계를 설명하기위해 전통적으로 사용되는건 클라-서버 모델임
	
	메시지는 오퍼레이션명과 인자로 구성되고,메시지전송은 여기서 메시지수신자를 추가한것
		abcService.isIdol("koko")
		수신자.오퍼레이션명(인자)
	이런식
	메시지를 수신했을때 실제로 실행되는코드는,메시지수신자의 실제타입에 달려있고 이떄 실행되는 함수나 프로시저를 메서드라고 부름
	즉 코드상에서 같은이름의 변수에 같은메시지를 전송하더라도,실제타입에 따라 다른메서드가 실행될수있음
	즉 코드의의미가 컴파일시점과 실행시점에 다른것
	이렇게 메시지와 메서드의 구분은 전송자와 수신자가 느슨하게 결합될수있게해줌
	전송자는 그냥 자신이 어떤 메시지를 보내야하는지만 알면되고,수신자가 어떤타입인지등은 몰라도됨
	
	객체는 안과 밖을 구분하는 뚜렷한 경계를 가짐,이때 의사소통을 위해 외부로 공개하는 메시지의 집합을 퍼블릭 인터페이스 라고 부름
	또한 이 퍼블릭 인터페이스에 포함된 메시지를 오퍼레이션이라고 부름
	또한 이 메시지를 수신했을때 실제 실행되는코드를 메서드라고 부름
	
	오퍼레이션과 파라미터목록을 합쳐서 시그니처라고 부름,즉 오퍼레이션은 실행코드없이 시그니처만을 정의한거고,메서드는 시그니처에 구현을 더한것임

  2.인터페이스와 설계품질
	좋은인터페이스는 최소한의 인터페이스와 추상적인 인터페이스라는 조건을 만족해야함
	즉 꼭 필요한 오퍼레이션만을 포함하고,어떻게가 아닌 무엇을 하는지 표현해야함
	
	이걸위해 가장좋은방법이 책임주도설계임
	메시지를 먼저 선택해서 협력과 무관한 오퍼레이션이 인터페이스에 스며들지않게하고(최소한의 인터페이스)
	메시지가 객체를 선택하게 해서 클라이언트의 의도를 메시지에 표현할수 있게 함(추상적인 인터페이스)
	
	
	디미터법칙을 사용하면 객체의 내부구조결합으로 인해 발생하는 설계문제를 해결할수있음
	이건 .을 하나만 찍어라 라고 표현할수있음,즉 바로인접한 객체까지만 접근하고,거기서 디깅하지마라는것
	이러면 수신자의 구조가 전송자에게 노출되지않고,내부구현에 결합되지않아서 낮은결합도를 유지할수있음
	즉 객체가 자율적으로 처리할수있게하라는것(묻지말고시켜라),
	단 무비판적으로 이걸 수용하면 응집도가 낮아질수있으니 주의
	
	그리고 그냥 묻지않고 시킨다고 다 해결되는건 아니고,객체가 어떻게 작업을 수행하는지도 노출하면안됨
	즉 뭘하는지만 노출해야함(의도만 드러내야함)
	그래야 유연성이 향상됨(추상화가 가능해짐),즉 결과와 목적만을 포함하도록 클래스와 오퍼레이션의 이름을 부여해야함
	퍼블릭 인터페이스는 이벤트와 규칙 그 자체만 명시해야함
	즉 티켓을 판매할땐 setTicket보다 sellTo가 더낫고,
	티켓을 구매할땐 setTicket보다 buy가 더 나은식
	즉 협력이라는 관점에서 문맥을 반영해야함,즉 클라가 객체에게 무엇을 원하는지를 표현해야함

  3.원칙의 함정
	단 디머터법칙도 스트림같은,객체의 내부구조가 외부로 노출되지않고 캡슐화가 유지되면 .을 여러개찍어도됨
	스트림같은경우도 점이몇개든간에 자기자신을 계속 리턴하면서 묻지않고 시키는거니까
	
	추가적으로 계속 무지성으로 위임메서드를 추가하면,
	퍼블릭인터페이스안에 어울리지않는 오퍼레이션들이 공존하게되고 응집도가 낮아짐
	그래서 트레이드오프를 따라서 그냥 물어야하는경우도 있음
	대표적으로 묻는대상이 객체가 아닌 자료구조라면,당연히 내부를 노출해야하므로 디미터법칙을 적용할필요가 없음

  4.명령-쿼리 분리 원칙
	이건 프로시저와 함수를 구분하는,즉 리턴값이 있는 조회함수(쿼리)와,리턴값이 없고 상태를 변경하는 프로시저(명령)를 구분해서 사용하는 원칙임
	즉 어떤 오퍼레이션도 명령이면서 쿼리이면 안된다는것
	
	조회메서드안에 명령이 숨어있으면 버그가 터지기 쉬움,사용자가 예측하지 못하는 동작을 하기 쉽기때문
	이러면 퍼블릭인터페이스가 늘어나지만,명령과 쿼리를 분리해서 얻는 이점이 더 큼
	
	추가적으로 참조투명성을 제한적으로 누릴수있게되기도하고(val같은거)
	
	책임주도설계가 미치는 영향은
		디미터 법칙:메시지를 먼저 결정하면 구조적인 결합도를 낮출수있고,
			수신할객체를 모르는상태에서 메시지를 먼저 선택하기떄문에 내부구조를 고민할필요가 없어지고 디미터법칙을 위반할 위험을 최소화할수있음
		묻지말고시켜라:메시지를 먼저 결정하니 클라입장에서 메시지가 나오게되고,묻지말고시키게됨
		의도를 드러내는 인터페이스:클라입장에서 메시지를 결정하니 의도가 분명하게 드러나게됨
		명령-쿼리 분리 원칙:메시지를 먼저 선택하면 협력이라는 문맥안에서 인터페이스에 대해 고민하게되고,
			객체가 뭔일을 하는지를 넘어서 협력속에서 객체의 상태를 예측하고 이해하기쉽게 만들기위해 고민하게됨
			그래서 예측가능한 협력을 만들기위해 명령과 쿼리를 분리하게될거임
	이렇게 좋은점이 많음
	
	단 시그니처는 이름과 인자의 타입만 표현할수있어서,어떤경우에 실행할수있는지를 표현할수는 없음
	그래서 있는게 계약에 의한설계임
	
	
7.객체 분해
  1.프로시저추상화와 데이터추상화
	프로그래밍 패러다임은 추상화의 종류와 추상화를 이용해 소프트웨어를 분해하는 방법 두가지로 결정됨
	즉 모든 프로그래밍패러다임은 추상화와 분해관점에서 설명할수있음
	
	추상화는 프로시저추상화와 데이터추상화 두개가 있음
	프로시저추상화는 소프트웨어가 무엇을 해야하는지를 추상화하고
	데이터추상화는 소프트웨어가 무엇을 알아야하는지를 추상화함
	
	프로시저추상화를 중심으로 시스템을 분해하면 기능분해의 길로 들어서는것,이건 알고리즘분해라고도 부름
	
	데이터추상화를 중심으로 시스템을 분해하면,두가지중 하나를 선택해야함
	데이터를 중심으로 타입을 추상화하는것과(추상데이터타입),데이터를 중심으로 프로시저를 추상화하는것(객체지향)
	
	즉 객체지향은 데이터를 중심으로 데이터추상화를 한다음 프로시저추상화를 하는것
	이를위해 객체지향언어는 클래스라는 도구를 제공함,즉 객체지향이란 데이터추상화와 프로시저추상화를 함께 포함한 클래스를 이용해 시스템을 분해하는것

  2.프로시저추상화와 기능분해
	프로시저는 반복적으로 실행되거나 유사하게 실행되는작업들을 하나의 장소에 모아둠으로써 로직을 재사용하고 중복을 방지할수있는 추상화기법임
	즉 구현을 은닉하고 인터페이스만 알면 프로시저를 사용할수있게하는것
	이 관점에서 시스템은 입력값을 계산해서 출력값을 반환하는 수학의 함수와 동일하고,시스템은 더 작은 작업으로 분해될수있는 하나의 큰 메인함수임
	
	이 관점에서는 분해방법이 하향식(탑다운)접근법을 따름
	시스템을 구성하는 가장 최상위기능을 정의하고,이 최상위기능을 좀 더 작은단계의 하위기능으로 분해해나가는 방법을 말함
	이때 분해는 세분화된 마지막 하위기능이 프로그래밍언어로 구현가능할수준이 될때까지 반복하고,각 세분화단계는 바로위단계보다 구체적이어야함
	
	이방식에서는 기능을 중심으로 필요한데이터를 결정함,즉 기능이 주연이고 데이터는 보조임
	즉 먼저 필요한기능을 생각하고 이 기능을 분해하고 정제하는 과정에서 필요한 데이터의 종류와 저장방식을 식별함
	이게 하향식 기능분해의 가장 큰 문제점임
	
	하향식 기능분해로 설계한 시스템은 메인함수를 루트로하는 트리로 표현할수있음
	하향식 기능분해의 문제점은
		시스템은 하나의 메인함수로 이루어지지않음
		기능추가나 요구사항변경으로 메인함수를 빈번하게 수정해야함
		비즈니스로직이 사용자인터페이스와 강결합함
		너무 이른시기에 함수의 실행순서를 고정시켜 유연성과 재사용성이 저하됨
		데이터형식이 변경되면 파급효과를 예측할수없음
	즉 변경에 약하다는게 가장 큰 문제점임
	
	하향식접근법은 로직설계 초기단계부터 입력방법과 출력양식을 함께 고민하게 강요함
	이러면 비즈니스로직과 인터페이스관심사가 섞이게됨
	
	또한 시스템이 무엇을 해야하는지가 아닌,어떻게 동작하는지에 집중하게만듬
	이거의 문제는,제어구조를 미리 결정하지않으면 분해를 진행할수없는데,제어구조는 빈번한 변경의 대상이라는거임
	
	즉 모든문제의 핵심은 결합도임,함수는 상위함수가 강요하는 문맥에 강하게 결합되고,함께 절차를 구성하는 다른함수들과 시간적으로 강하게 결합됨
	또한 어떤 데이터를 어떤 함수가 사용하고있을지 추적하기 어려움,그래서 데이터를 변경할때 어떤 함수가 영향을 받을지 예상하기어려움
	즉 함수에서 데이터를 세는건 쉬운데,데이터에서 피인용함수를 세는건 어려움
	그래서 중요한게 정보은닉과 모듈임
	
	하향식 접근법은 설계가 안정화되고 문서화할때 유용함,설계할때는 쓰기어려움

  3.모듈
	시스템의 변경을 관리하는 기본적인 전략은 함께 변경되는 부분을 하나의 구현단위로 묶고,퍼블릭인터페이스를 통해서만 접근하게 하는것
	즉 기능을 기반으로 시스템을 분해하지않고,변경에 방향에 맞춰 시스템을 분해하는것
	
	정보은닉은 외부에 감춰야하는 비밀에 따라 시스템을 분할하는 모듈분할원리임
	모듈은 변경될 가능성이 있는 비밀을 내부로 감추고,쉽게 변경되지않을 퍼블릭인터페이스를 외부에 제공해서 내부의 비밀에 함부로 접근하지 못하게함
	
	모듈과 기능분해는 상호배타적이지 않고,시스템을 모듈로 분해하고,각 모듈내부를 구현하기위해 기능분해를 적용할수있음
	즉 기능분해가 하나의 기능을 구현하기위해 필요한 기능들을 순차적으로 찾는 탐색과정이라면
	모듈분해는 감춰야할 비밀을 선택하고 비밀주변에 안정적인 보호막을 설치하는 보존의 과정임
	비밀을 결정하고 모듈을 분해한후에 기능분해를 사용해서 모듈에 필요한 퍼블릭 인터페이스를 구현할수있음
	
	이때 시스템을 모듈로 분해할땐,시스템이 감출 비밀을 찾고,그걸 퍼블릭인터페이스로 둘러싸면됨
	모듈은 두가지를 감춰야함
		복잡성:모듈이 복잡하면 사용하기어려우니,모듈을 추상화할수있는 간단한 인터페이스를 제공해야함
		변경가능성:변경가능한 설계결정이 외부에 노출되면 실제로 변경이 발생했을때 파급효과가 커짐,
			그래서 변경발생시 모듈하나만 수정하면되게 변경가능한 설계결정을 모듈내부로 감추고,변경이 어려운 인터페이스만 제공해야함
	시스템의 가장 일반적인 비밀은 데이터임,근데 데이터만 숨긴다고 되는건아님
	
	모듈의 장점은
		모듈내부의 변수가 변경돼도 모듈내부에만 영향을 미침
		비즈니스로직과 사용자인터페이스 관심사를 분리함
		전역변수와 전역함수를 제거해서 네임스페이스오염을 방지
	즉 기능이 아닌 변경의 정도에 따라 시스템을 분해할수있게함,각 모듈은 외부에 감춰야하는 비밀과 관련성높은 데이터와 함수의 집합임
	그래서 모듈은 높은응집도를 유지하고,
	모듈과 모듈사이에는 퍼블릭인터페이스를 통해서만 통신해야함,그래서 낮은결합도를 유지함
	
	모듈에 있어서 핵심은 데이터임,하향식 기능분해와 달리 모듈은 감춰야할 데이터를 결정하고,이데이터를 조작하는데 필요한 함수를 결정함
	즉 기능이 아닌 데이터를 중심으로 시스템을 분해함
	모듈은 데이터와 함수가 통합된 한차원 높은 추상화를 제공하는 설계단위임
	
	모듈이 프로시저추상화보다 높은 추상화개념을 제공하지만,태생적으로 변경을 관리하기위한 구현기법이기때문에 추상화관점에서 한계가 명확함
	가장큰 문제는 인스턴스의 개념을 제공하지않는다는것
	그래서 등장한게 추상데이터타입임

  4.데이터추상화와 추상데이터타입
	타입이란 변수에 저장할수있는 내용물의 종류와 변수에 적용될수있는 연산의 가짓수임
	즉 변수가 어떻게 행동할것이라는걸 예측하게하는것
	
	추상데이터타입은 시스템의 상태를 저장할 데이터를 표현함(타입을 구분하는 데이터가 있음)
	이 데이터를 이용해서 기능을 구현하는 핵심로직은 추상데이터타입 외부에 존재함
	
	즉 추상데이터타입은 그냥 공통데이터들의 묶음이고,이 안에서 값들의 차이로 불러올 외부핵심로직이 달라지는것
	클래스에 타입변수가 있는거랑 비슷한느낌

  5.클래스
	클래스는 추상데이터타입이라고 볼수도있음
	둘다 외부에서 객체내부속성에 직접접근할수없고,퍼블릭인터페이스를 통해서만 외부와 의사소통할수있음
	근데 차이가 있는데,클래스는 상속과 다형성을 지원하는데,추상데이터타입은 지원하지못함
	
	추상데이터타입은 오퍼레이션(메서드)를 기준으로 타입을 묶게되고,
	객체지향은 타입을 기준으로 오퍼레이션을 묶게됨
	
	즉 추상데이터타입은 완전하게 구현되지만,
	클래스로 구현되면 공통속성과 메서드시그니처만 정의하는 불완전한 구현체를 상속받아서 메꾸는느낌으로 진행됨
	
	단순히 클래스를 구현단위로 쓰는게 객체지향이 아님
	타입을 기준으로 절차를 추상화해야 객체지향분해임
	즉 클래스내부에 타입변수가 있다면 이건 객체지향이 아닌 추상데이터타입임
	
	객체지향에서는 타입변수를 이용한 조건문을 다형성으로 대체함,
	이러면 클라가 객체타입을 확인한후 적절한 메서드를 호출하는게 아닌,객체가 메시지를 처리할 적절한 메서드를 선택함
	그래서 객체지향은 조건문을 제거하는것 이라는 소리가 나오는것임
	
	이렇게 조건문에 값을 추가하지않고,새 타입으로 행위를 추가하는특성을 개방폐쇄원칙이라고 함
	
	그렇다고 추상데이터타입이 최악의선택은 아님,타입추가확률이 크다면 객체지향이 이기지만,오퍼레이션추가확률이 더 크다면 추상데이터타입이 이길수있음
	객체지향은 새 오퍼레이션을 추가하려면 상속계층에 속하는 모든클래스를 한번에 수정(모든곳에 메서드를 추가)해야하니까
	
	그리고 객체지향의 핵심은 책임과 협력임,
	객체가 참여할 협력을 결정하고,협력에 필요한 책임을 수행하기위해 어떤 객체가 필요한지에 관해 고민하고,
	그 책임을 다양한방식으로 수행해야할때문 타입계층안에 각 절차를 추상화하면됨
	타입과 다형성은 협력이라는 문맥안에 책임을 수행하는방법에 관해 고민한 결과물이지,그게 목적이되어서는 안됨
	
	
8.의존성 관리하기
  1.의존성 이해하기
	어떤 객체가 다른객체와 협력하려면 반드시 의존성이 존재하게됨
	이 의존성은 실행시점과 구현시점에 서로 다른의미를 가짐
		실행시점:의존객체가 정상동작하려면 실행시에 반드시 의존대상객체가 존재해야함
		구현시점:의존대상객체가 변경되면 의존하는객체도 함께 변경
	구현시점에 의존성이 있으면 실행시점을 포함함
	즉 우리가 하고싶은거는 구현시점을 최대한 제거하고싶은거임,실행시점의 의존성은 협력하려면 반드시 있어야함
	
	의존성은 방향성을 가지며 항상 단방향임
	피의존객체가 변경되면 의존객체도 영향을 받지만,역은 성립하지않음
	
	또한 의존성은 전이될수있음
	해당피의존객체가 의존하고있는 의존성에 대해서도 의존객체는 의존하게되는것(간접의존)
	물론 모든경우에서 전이되는건 아님,의존성이 실제로 전이될지 여부는 변경의 방향과 캡슐화의 정도에 따라 달라짐
	보통 캡슐화에 성공했을경우엔 변경이 전파되지않음(내부구현에 영향을 받지않게 캡슐화됐다면)
	의존성전이란 변경에 의해 영향이 전파될수있다는 경고일뿐임
	
	의존성은 그래서 직접의존성과 간접의존성으로 나뉘고,의존성이라는건 클래스뿐이 아닌,의존하고있는 대상의 변경에 영향을 받을수있는 가능성임
	
	의존성은 런타임의존성과 컴파일타임의존성으로도 나눌수있음
	이건 위에 실행시점과 구현시점과 같음
	런타임시점의 주체는 객체 그 자체고,컴파일타임의 주체는 클래스임
	객체지향에서 중요한건 이 두 의존성을 다르게 만들수있다는거임
	
	즉 추상화를 통해 인터페이스나 추상클래스를 생성함으로써 컴파일타임에서는 모호성을 가져가 다형성을 챙길수있다는거
	이러면 결합이 낮아지고 인터페이스를 구현한 새로운 클래스를 생성해서 확장할수있어짐
	만약 구체클래스 자체를 의존한다면 이게 불가능해짐,그래서 구체클래스에 대한(상세구현)건 전혀 모르는 상태로 인터페이스만 의존하게 만드는게 핵심임
	즉 이러면 코드작성시점의 의존객체는 피의존객체에 대해 인터페이스밖에 모르지만,런타임시점의 의존객체는 인터페이스를 구현한 모든 구현체를 사용할수있어짐
	이렇게 만드는게 객체지향의 핵심이고,이렇게 될수록(컴파일타임 구조와 런타임구조가 멀면 멀수록) 설계가 유연해지고 재사용가능해짐
	
	클래스가 특정 문맥에 강하게 결합될수록 다른문맥에는 사용하기 어려워짐,이를 컨텍스트독립성이라고 부름
	설계가 유연해지려면 가능한 자신이 실행될 컨텍스트에 대한 구체적인 정보를 최대한 적게알아야함,이럴수록 재사용이 쉬워짐
	
	
	컴파일타임의존성은 반드시 구체적인 런타임의존성으로 언젠가는 대체되어야함(실행이 되어야하니까)
	이렇게 컴파일타임의존성을 실행컨텍스트에 맞는 적절한 런타임의존성으로 교체하는걸 의존성해결이라고 부름
	이 의존성해결의 방법은 일반적으로
		생성자를 통해 의존성해결
		setter로 의존성해결
		메서드인자로 의존성해결
	이렇게 3개임
	
	만약 해당 클래스가 항상 해당 의존성이 필요하다면 생성자를 통해 받고,의존성 변경이 필요하다면 setter를 추가할수있음
	만약 특정메서드에서만 의존성이 필요하다면,메서드의 매개변수로 의존성을 등록할수있음
	이건 매 실행시점마다 의존성이 변경되어야할떄도 유용함

  2.유연한 설계
	변경가능한곳에서의 의존성은 가능한 낮아야함,변경가능한 클래스는 인터페이스를 만들고,의존객체는 인터페이스를 의존해야함
	어떤 의존성이 다양한 환경에서 클래스를 재사용하지 못하게 막는 의존성은 나쁜의존성이고,영향을 안주면 좋은의존성임
	즉 컨텍스트독립적인 의존성은 좋은의존성이고 특정컨텍스트에 강결합된 의존성은 나쁜의존성임
	
	특정컨텍스트에 강결합된 의존성을 다른 컨텍스트에서 재사용하는방법은 구현을 변경하는것뿐임
	그래서 결합도는 낮을수록좋음
	
	결합도는 지식에 따라 결정됨
	정확히는 의존객체가 피의존객체에 대해 알고있는 정보의 양에 따라(또한 정보의 변경가능성에 따라)결정됨
	이 양이 많아질수록 강결합이고,적어질수록 약결합임
	
	그래서 추상화를 통해 정보의 양을 줄여서 결합도를 낮출수있는거임
	
	추가적으로 new가 나쁘다는게,클래스 내부에서 특정 클래스를 선택해서 생성해버리면 결합도가 올라가기때문임
	가능하면 특정 클래스를 선택해서 내가 생성하는게 아닌,인터페이스로 의존성주입을 받아야함
	
	이렇게되면 추가적인 장점도 있는데,생성자주입이든 메서드인자주입이든 퍼블릭인터페이스에 의존성이 명시적으로 노출됨
	즉 명시적의존성이 됨
	만약 클래스내부에서 인스턴스를 직접 생성하면 외부에서는 뭘 의존하는지 알수없음,즉 숨겨진 의존성이 됨
	
	의존성이 명시적이지 않으면 의존성을 파악하기위해 내부구현을 직접 살펴볼수밖에 없음
	또한 클래스를 다른컨텍스트에서 재사용하려면 내부구현을 직접 변경해야함,그래서 버그생성확률이 올라감
	
	의존성은 명시적으로 표현되어야함,의존성은 구현내부에 숨으면 안됨
	의존성은 나쁜게 아님,문제는 의존성이 감춰지는것이지
	
	추가적으로 new가 나쁘다는건,
		new를 쓰려면 구체클래스명을 직접 알아야함,즉 구체클래스에 의존할수밖에 없어서 결합도가 올라감
		new는 생성하려는 구체클래스명뿐 아니라 어떤 인자를 통해 클래스의 생성자를 호출해야하는지도 알아야함,즉 지식의양이 늘어나서 결합도가 올라감
	이건 전부 해당 클래스가 변경하면 내가 영향을 받기때문에 나쁘다는거임
	즉,변경가능성이 있는(내가만든)클래스에 대한 new가 나쁜거임
	그래서 new는 의존클래스를 피의존클래스에 결합시키는거로 끝나는게 아닌,해당 클래스가 어떤인자가 필요한지때문에 인자에 대한 의존성도 생겨버리게됨
	그래서 외부에서 의존성을 주입받아야하는것
	
	그렇지만 무조건 죽어도 이거를 고정적으로 쓰게될거같으면 직접 생성해도되고,
	거의 대부분 이거를 쓰고,진짜 가끔 다른거를 써야하면 생성자를 오버로딩해서 하나는 직접생성,하나는 의존성주입으로 처리해도됨
	이때는 생성자를 체이닝해서(직접생성생성자에서 의존성주입생성자를 호출) 처리하면됨(이건 메서드에서도 유용함)
	
	또한자바 디폴트라이브러리같은,변경가능성이 없는 클래스는 new를 막 써도됨,어짜피 안바뀔거니까 인터페이스처럼 써도 됨
	그래도 이경우에도 가능하면 추상적타입을 쓰는게 확장성측면에서는 좋음,내가 쓰려는 기능이 있는 가장 추상적인 타입을 선택하는식으로 하면됨
	
	이런식으로 인터페이스를 사용해 확장하는식으로 구현할때는,사용할때도 인터페이스를 구현한게 누군지 알지못하는상태에서 쓸수있게 구현되어야함
	만약 아무일도 안해야한다면,아무것도 안하는 구현체를 만들어서 넣어서 실행시키는식으로 동작해야함
	또한 중복처리가 필요하다면,데코레이터패턴을 사용할수있음(데코레이터가 리스트로 인터페이스를 받아서 처리)
	
	이렇게하면 코드를 수정하지않고 협력대상을 교체할수있어서,클래스가 조합가능해짐
	그리고 이래서 객체의 조합을 통해 무엇을 하는지 표현하는 클래스로 구성할수있고,쉽게 파악할수있어짐

9.유연한 설계
  1.개방폐쇄원칙
	소프트웨어 개체는 확장에 대해 열려있어야하고,수정에 대해서는 닫혀있어야함
	여기서 확장은 어플리케이션의 동작에 대해 추가할수있어야한다는것이고,
	수정은 기존의 코드를 수정하지 않고 동작을 추가할수있어야한다는것임
	
	이건 런타임의존성과 컴파일타임의존성에 관한 이야기임
	즉 컴파일타임 의존성은 유지하면서 런타임 의존성의 가능성을 확장하고 수정할수 있는 구조를 말함
	
	개방폐쇄원칙의 핵심은 추상화에 의존하는것 임
	개방폐쇄원칙의 관점에서 추상화되지않고 남겨지는 부분은 다양한 상황에서의 공통점을 반영한 추상화의 결과물임
	공통적인 부분은 문맥이 바뀌더라도 변하지않아야함,즉 수정할 필요가 없어야함(추상화부분은 수정에 대해 닫혀있음)
	또한 생략된 부분은 확장의 여지를 남겨줌
	이게 추상화가 개방폐쇄원칙을 만드는 방법임
	
	단,단순히 추상화를 썼다고 수정에 대해 닫혀있게 만들어지는건 아님
	폐쇄를 가능하게하는건 의존성의 방향임,즉 수정에 대한 영향을 최소화하기위해서는 모든 요소가 추상화에 의존해야함
	즉 변하는것과 변하지않는것이 무엇인지를 이해하고 이를 추상화의 목적으로 삼아야함

  2.생성 사용 분리
	추상화를 해도 추상화 된 인터페이스의 구현체를 직접 가져다가 생성하면(new) 개방폐쇄원칙을 위반하게됨
	특히 생성은 생성자의 인자들까지 결합되기때문에 강하게 결합됨
	
	근데 언젠가는 한번은 무조건 생성을 하긴해야함,
	문제는 생성이 아님,부적절한곳에서 객체를 생성하는게 문제지
	
	즉 메세지를 전송하거나(인터페이스 의존),객체를 생성하거나(구체클래스 의존) 한 클래스에서는 하나만 해야함
	그래서 나온 패턴이 생성과 사용의 분리임
	이건 시스템을 객체들을 제작하고 의존성을 서로 연결하는 시작단계와 그 이후 이어지는 실행단계로 분리하는것
	이걸 따르는 가장 보편적인 방법은,객체를 생성할 책임을 클라이언트로 옮기고,주입받는거임
	이게 좋은게,문맥상 어떤 객체를 선택할지 아는건 클라이언트기 때문(지식을 그래서 클라가 가지고있음)
	이러면 피의존객체는 지식에 대해서 자유로워지고 추상화에만 의존할수있어짐
	
	클라이언트가 의존하는것도 싫다면,객체들의 생성책임만 가지는 factory객체를 만들수있음
	
	이런 factory객체같은거는 도메인모델에 속하지 않는 순수한 가공물임
	이건 순수하게 기술적인 결정이고,결합도를 낮추고 재사용성을 높이기위해 도메인이 가진 객체생성책임을 아무상관없는 가공의 객체로 옮기는것
	
	도메인모델은 단지 설계를 위한 출발점일뿐임
	모든 책임을 도메인모델에 할당하면 낮은응집도,높은 결합도,재사용성 저하등의 문제점이 생김
	이럴때는 도메인개념을 표현한 객체가 아닌,편의상 임의로 만들어낸 가공의 객체에 책임을 할당해서 문제를 해결해야함
	
	어떤 행동을 추가하려는데,이 행동을 책임질 마땅한 도메인 개념이 존재하지않으면 가공물객체를 추가하고 이 객체에 책임을 할당하면됨
	보통 이런 순수한 가공물 객체는 특정한 행동을 표현하는게 일반적임
	
	즉 도메인의 본질적 개념을 표현하는 추상화로 어플리케이션을 만들다가,만족스럽지 못하면 인공객체를 만들어서 책임을 넣으면됨

  3.의존성주입
	생성과 사용을 분리하면 해당 객체는 생성을 할수없고,외부로부터 주입받아야함
	이렇게 외부의 독립적인 객체가 인스턴스를 생성해서 전달해주는걸 의존성주입이라고 함
	
	의존성주입은 의존성을 해결하기위해 의존성을 객체의 퍼블릭 인터페이스에 명시적으로 드러내서 외부에서 필요한 런타임의존성을 전달할수 있게 만드는 방법임
	여기엔
		생성자주입:생성자시점에 주입
		세터주입:생성후 세터로 주입
		메서드주입:메서드 실행시 인자로 주입
	3가지가 있음
	
	의존성주입 말고도 의존성을 해결하는 다양한 방법들이 존재하고,
	그중에 Service Locator패턴이 있음
	이건 추상화를 구현한 객체(현재 사용하는)들을 전부 모아두고,해당하는 추상화에 맞는 객체를 돌려주는 객체임(팩토리객체라고 보면됨)
	이거도 의존성을 해결할수있긴하지만,이거의 문제는 의존성을 숨긴다는것임
	그래서 문제가 생기면 컴파일타임이 아닌 런타임에 문제가 발견되게됨
	또한 단위테스트 작성도 어려움,중간객체가 있으니 해당객체로 모든 단위테스트가 서로 고립되지않게됨
	
	클래스의 퍼블릭인터페이스만으로 사용방법을 이해할수 있는 코드가 캡슐화의 관점에서 훌륭한 코드임
	클래스의 사용법을 익히기위해 구현내부를 샅샅히 뒤져야하면 캡슐화가 무너진거임
	
	숨겨진 의존성의 가장 큰 문제는,의존성을 이해하기위해 코드의 내부구현을 이해할것을 강요한다는것
	그래서 Service Locator는 캡슐화를 위반할수밖에 없음
	
	그래서 의존성주입은 퍼블릭인터페이스에 깔끔하게 드러나고,의존성을 이해하기위해 코드 내부를 읽을 필요가 없음
	즉 명시적의존성이 숨겨진 의존성보다 좋다 임
	
	Service Locator패턴을 사용해야할때는,di프레임워크를 사용하지 못하거나,
	깊은 호출계층에 걸쳐 동일한 객체를계속해서 전달해야하는 고통을 못견딜때(di는 계속 내려줘야하니까) 한해서 사용을 고려할수있음
	

  4.의존성 역전 원칙
	객체사이의 협력이 존재할때,그 협력의 본질을 담고있는건 상위(클라)의 정책임,하위는 구현일뿐 핵심은 상위임
	근데 상위가 하위에 의존하면 하위의 변경에 의해 상위가 영향받는데,이건 거꾸로 상위가 변경되면 하위가 영향받아야함
	
	그래서 의존성은 높은수준에서 낮은수준으로 흘러야함(상위는 하위를 의존하면안됨)
	그래서 사용되는게 의존성 역전 원칙이고,이경우에도 해결법은 추상화임
	
	상위와 하위 모두 인터페이스를 의존하면,구현의 변경으로 클라이언트가 영향을 받는걸 방지할수있음
	또한 상위를 재사용할떄도 하위에 얽매이지 않고 재사용할수있음
	
	즉 가장 중요한건 추상화에 의존하는것,유연하고 재사용 가능한 설계를 원하면 모든 의존성의 방향이 추상화여야함
	구체클래스는 의존성의 시작점이어야지,목적지면 안됨
	
	추가적으로,역전은 의존성의 방향뿐 아니라 인터페이스의 소유권에도 적용됨
	그래서 상위쪽으로 인터페이스를 넘겨줘야함
	이건 컴파일수준에서도 패키지 재배포를 막을수있기때문(패키지단위로 컴파일되니까)
	이건 Separated interface패턴이라고 부름

  5.유연성에 대한 조언
	유연하고 재사용가능한 설계는 필연적으로 복잡한 설계가 됨
	그래서 복잡성에 대한 걱정보다,유연하고 재사용가능한 설계의 필요성이 더 크다면 추상화를 하면됨
	
	또한 중요한건 객체의 협력과 책임임,설계를 유연하게 만들기 위해서는 협력에 참여하는 객체가 다른 객체에게 어떤 메시지를 전송하는지가 중요함
	즉 핵심은 역할,책임,협력임
	객체의 역할과 책임이 자리잡고 나서 객체생성을 해야함,즉 객체를 생성하는 방법은 모든 책임이 자리를 잡고 나서 가장 마지막에 내리는게 적절함
	그래야 머리가 덜아픔

10.상속과 코드 재사용
  1.상속과 중복코드
	중복코드는 변경을 방해함
	n개의 중복코드를 수정하려면 n번 찾아야하고 n번 수정해야하고 n번 테스트해서 같은결과가 나오는지 확인해야함
	
	중복여부를 판단하는 기준은 변경임,즉 코드가 변경에 반응하는 방식임
	요구사항이 변경됐을때 두 코드를 함께 수정해야하면 중복이고,아니라면 중복이 아님,
	코드의 모양은 중복코드의 여부가 아님,징후일뿐임
	
	중복코드를 찾는일은 쉽지않고,중복코드는 항상 함께 수정되어야하기 때문에 하나라도 빼먹으면 버그임
	또한 중복코드를 서로 다르게 수정하기가 쉽고,중복코드는 새로운 중복코드를 부름
	중복코드를 제거하지않고 수정하는 유일한방법은 새 중복코드를 추가하는것뿐임
	또한 이렇게되면 변경에 취약해지고 버그확률이 올라감,즉 중복코드의 양이 늘어나면 버그의 수가 증가하고 코드를 변경하는속도는 느려짐
	
	근데 그렇다고 클래스를 합친다음에 타입코드를 쓰면,낮은응집도와 높은 결합도라는 문제에 시달리게됨
	그래서 사용되는게 상속과 합성임
	
	상속은 이미 존재하는 클래스와 유사한 클래스가 필요하다면,코드를 복사하지말고 상속으로 재사용하라는거
	근데 문제는,상속을 염두에 두지않고 설계된 클래스는 상속을 이용해 재사용하기가 어려움
	이런경우는 자식클래스가 부모클래스의 구현방법에 대해 정확한 지식을 가져야한다는걸 의미함
	
	즉 상속은 결합도를 높임,그리고 부모클래스와 자식클래스 사이의 강한결합은 코드를 수정하기 어렵게 만듬
	특히 super를 사용하는 시점부터(부모의 구현을 가져오는 시점부터) 결합도가 급격히 올라감
	그래서 super이 있다면 이걸 제거할 방법을 찾아야함
	
	이렇게 상속관계의 자식클래스가 부모클래스의 변경에 취약해지는 현상을 취약한 기반클래스 문제 라고 부름
	이건 코드재사용을 위해 상속을 사용할때 발생하는 대표적 문제임

  2.취약한 기반클래스 문제
	구현을 상속하면 파생클래스는 기반클래스에 강하게 결합됨
	기반클래스에 대한 단순한 변경이,전체 프로그램을 불안정한 상태로 만들어버릴수도 있음
	
	취약한 기반클래스는 캡슐화를 약화시키고 결합도를 높임
	상속은 자식클래스가 부모클래스의 구현세부사항에 의존하게 만들기때문에 캡슐화를 약화시킴
	이게 상속이 위험한 이유인 동시에 상속을 피해야하는 첫번째 이유임
	
	객체를 사용하는 이유는 구현세부사항을 퍼블릭인터페이스 뒤로 숨길수있기때문임
	캡슐화는 변경에 의한 파급효과를 제어할수있어서 가치가 있음
	근데 상속은 부모의 퍼블릭인터페이스가 아닌 구현을 변경하더라도,자식클래스가 영향을 받기 쉬워짐
	
	객체지향의 기반은 캡슐화를 통한 변경의 통제임
	상속은 코드의 재사용을 위해 캡슐화의 장점을 희석시키고,구현결합도를 높여서 객체지향의 장점을 희석시킴
	
	상속이 잘못쓰이면,하위 구현클래스의 규칙을 어기는 상위 클래스의 메서드도 같이 받게됨(stack같은)
	물론 안쓰면 되지만,인터페이스는 제대로쓰기엔 쉽게,엉터리로 쓰기엔 어렵게 만들어야함
	즉 상속받은 부모클래스의 메서드가 자식클래스의 내부구조에 대한 규칙을 깨트릴수 있음
	이게 상속을 피해야하는 두번째 이유임
	
	자식이 부모의 메서드를 오버라이딩하면,부모클래스가 자신의 메서드를 사용하는 방법에 자식클래스가 결합될수있음
	이게 상속을 피해야하는 세번째 이유임
	
	클래스가 상속을 원하면,클래스를 설계하고 문서화해야하며,그렇지않으면 상속을 금지시켜야한다는 소리가있음
	근데 이건 내부구현을 문서화하라는거임,즉 캡슐화와 정 반대임
	상속은 코드재사용을 위해 캡슐화를 희생하게됨
	
	상속은 기본적으로 부모클래스의 구현을 재사용한다는 기본전제를 따르기때문에,자식클래스가 부모클래스의 내부에 대해 속속들이 알게 강요함
	클래스를 상속하면,결합도로 인해 자식과 부모의 구현을 영원히 변경하지않거나,동시에 변경하거나 둘중 하나를 선택할수밖에 없음

  3.phone다시 살펴보기
	그래도 추상화를 사용하면,취약한 기반클래스 문제를 어느정도 완화시킬수있음
	즉 자식클래스가 부모클래스의 구현이 아닌,추상화에 의존해야함
	정확히는 자식과 부모 모두 추상화에 의존해야함(dip)
	이건
		두 메서드가 유사하다면 차이점을 메서드로 추출해서 동일한형태로 보이게 만듬
		부모클래스의 코드를 하위로 내리지말고,자식클래스의 코드를 상위로 올리자
	이런식으로 할수있음
	
	차이를 메서드로 추출하라는건,변하는것으로 부터 변하지않는걸 분리하라는걸 메서드수준으로 적용한거임
	즉 중복코드의 시그니처를 상위 추상클래스로 올리고,자식클래스에서 오버라이딩할수있게 프로텍트로 선언하면됨
	이러면 실패해도 문제를 쉽게찾고 쉽게 고칠수있음(하위클래스가 해당행동을 사용하면 바로 눈에 뜀)
	또한 모든 하위클래스가 이 행동을 할수있게 만드려면 여러 중복코드를 만들거나,이걸 상위클래스로 올리는방법밖에 없어져서 눈에 쉽게 뜀
	근데 이걸 반대로,현재클래스를 구체클래스에서 추상클래스로 바꾸려고하면 작은실수 한번으로 구체적인 행동을 상위클래스에 남겨놓기 쉬움
	
	이렇게 공통코드를 이동시키면,각 클래스는 서로 다른 변경이유를 가지게됨
	
	이렇게 하더라도,부모클래스에 인스턴스 변수 목록이 변하는경우엔 상속계층 전반에 변경을 유발함
	그래도 이렇게 인스턴스 초기화 로직을 변경하는게,같은 코드를 중복시키는거보다 현명한 선택임
	
	핵심로직은 한곳에 모아두고 조심스럽게 캡슐화해야하고,공통핵심로직은 최대한 추상화해야함

  4.차이에 의한 프로그래밍
	기존코드와 다른부분만을 추가해서 어플리케이션을 확장하는 방법을 차이에 의한 프로그래밍이라고 함
	이거의 목표는 중복코드를 제거하고 코드를 재사용하는것
	이떄 상속을 사용할수있는데,사실 상속보다는 합성이 대부분의 경우에 안전함

11.합성과 유연한설계































	
	
	
	
	
	