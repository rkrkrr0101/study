1.객체,설계
	소프트웨어는,동작해야하고,간단히 변경되어야하고,코드를 읽는사람이 읽기쉬워야함
	
	객체는 항상 능동적이어야함
	즉,자신의 데이터를 사용해서 발생하는 행위는,객체 자기자신이 메서드로 가지고있고,
	외부는 단지 그 인터페이스를 가지고 메서드를 사용할수있을뿐이어야함(로직의 책임은 객체가 가지고,로직을 콜하는 책임만 외부가 가짐)
	이렇게되면,콜하는쪽(mvc에선 서비스)의 부담이 엄청나게 줄어들고,하위도메인의 변경점이 있더라도,상위까지 전파되지않음
	즉 세부사항에 의존하게되면,변경에 취약해지고,그냥 선언적으로 시킬수있어야함
	
	즉,알필요없는건 다 캡슐화해서 객체안에 밀어넣고,공개된 인터페이스만 사용해라,
	객체가 할수있는일까지 도맡아서 하지마라
	구현에 의존하지말고,인터페이스에 의존하라는것(강의존이 아닌 약의존으로 만들어라)
	이러려면,게터세터를 생성하지 않는것으로 좀 더 쉽게할수있음(제약을통해)
	
	이렇게,데이터와 행위를 묶어두는걸(캡술화) 일반적으로 객체지향이라고 하고,데이터와 행위가 다른모듈로 나눠진걸 절차지향이라고 함
	
	설계를 어렵게 만드는건 의존성이고,이걸 쉽게만드는법은 불필요한 의존성을 제거해서,객체사이의 결합도를 낮추는것
	이 방법으로 세부사항을 캡슐화하는것이 있음
	이러면 객체의 자율성을 높이고,객체의 응집도도 올라감
	훌륭한 객체지향은,불필요한 세부사항을  캡슐화하는 자율적인 객체들이,낮은결합도와 높은 응집도로 협력하게 최소한의 의존성만 남기는거
	
	근데 이렇게 세부사항을 캡슐화하다보면,의존성을 추가해야하는경우가 있음(보통 매개변수로 대상을 받아야할때,자율성을 높이고,결합도가 상승함)
	이런건 트레이드오프로 선택해야함

2.객체지향 프로그래밍
	만약 한곳에서 여러개중 하나를 선택해야하면,인터페이스를 구현하는방법을 선택할수있고,
	여러개중 만족하는걸 골라야하면,인터페이스에 isSupport를 넣고,불린값을 반환하게해서 여기서 해당구현체를 지원하는지를 받을수있게한다음
	List<해당인터페이스>로 구현체를 전부 받은뒤에,포이치돌려서 isSupport를 통과하는거만 걸러내면됨
	
	객체지향식으로 설계할땐,어떤 클래스가 필요한지가 아니라,어떤 객체가 필요한지부터 고민하고
	이때도 어떤 객체가 어떤 행동을 가지는지,그로인해 어떤 상태가 필요한지부터 고민해야함
	그리고,객체를 독립적인 존재가 아니라,기능을 구현하기위해 협력하는 공동체의 일원으로 봐야함
	즉,
		1.대충 여기에 무슨 도메인이 있을지를 생각한다
		2.여기에 무슨 행동이 있어야하는지를 뽑아내고(유스케이스사용),그걸 맞는 양쪽의 도메인에 붙인다
		3.모든행동들이 맞는 도메인에 들어갔으면,도메인의 필요한 상태를 추가한다
		4.공통된 특성과 상태를 가진 객체들을,타입으로 분류하고(인터페이스),이걸기반으로 클래스를 구현한다
	순서로 하면됨
	
	객체지향이 좋은게,요구사항을 분석하는 초기단계부터,프로그램구현하는 마지막까지 같은 추상화기법을 사용할수있어서임
	클래스를 구현할때 가장 중요한건,클래스의 경계를 구분짓는것
	클래스는 내부(private)와 외부(public)로 구분되며,중요한건 여기서 어떤걸 공개하고 어떤걸 감출지 결정하는것
	이래야 객체의 자율성이 보장됨,막 getter로 가져가대면 온몸이 묶여있어서 움직이기가 힘듬
	
	즉,객체는 상태와 행동을 함께 포함하는,식별가능한 단위고,여기서 상태와 행동을 묶는걸 캡슐화라고함
	이걸 돕기위해,객체지향언어들은 private같은 접근제어자를 제공함
	
	이때,외부에서 접근가능한부분을 퍼블릭인터페이스(메서드중 메시지만),외부에서 접근불가능한 private붙은걸 구현이라고 부름
	이 인터페이스와 구현의 분리가,객체지향에서 중요한 핵심원칙중 하나임
	
	
	프로그래머를,자기 안에서 클래스작성자와,클라이언트프로그래머로 나눠서 생각하면 좋음
	클래스 작성자는,새로운 데이터타입을 프로그램에 추가하고(타입의 구현),
	클라이언트프로그래머는 이 데이터타입을 사용해서 앱을 빠르고 안정적으로 구축하는것
	클래스작성자는 이때,필요한부분만 공개하고 나머지는 숨겨야함(구현은닉),그래서 클라이언트프로그래머를 걱정하지않고 막 내부를 변경할수있음
	이러면 클라이언트프로그래머입장에서도,알아야할게 줄어들게됨(변경의 파급효과 제어)
	즉,도메인클래스의 작성과,나머지부분(레포지토리,서비스,컨트롤러)을 나눠서 보면 편하다는것
	
	그리고 Long같은,기본형을 쓰는건,구현관점에서의 제약을 표현할순있는데,의미전달이 잘 안되니까,
	값이 딱 하나뿐이라고해도 값객체를 쓰는게 더 나을수도있음(money클래스같은)
	이러면 관련된로직들은 바로 표시가나고,다른곳에 중복되어 구현되는걸 방지할수있음
	이렇게 개념을 명시적으로 표현하면,전체적 설계의 명확성과 유연성이 올라감
	
	그리고 생성자의 파라미터목록으로,초기화에 필요한 정보를 전달하게 강제하는거로,올바른 상태를 가진 객체의 생성을 보장할수있음(di)
	즉 이렇게 컴파일시기엔 인터페이스에 의존하고,런타임시기엔 구현체에 의존하는식으로 의존을 분리하고,
	런타임에 생성자로 주입시켜버리는식으로 의존성을 변경할수있음
	단,이게 유연해지고 확장가능하긴한데,너무 아무데나 쓰면 이해하기가 힘드니까,이거도 트레이드오프임(현재 도메인만 보고 어떤 구현체에 의존하는지 알수없으니까)
	
	그리고 상속은,기존클래스를 기반으로 새 클래스를 쉽고 빠르게 추가할수있는데,이때 상속의 목적이 메서드나 인스턴스변수를 재사용하기위해서이면 안됨
	상속의 목적은,인터페이스를 상속받아서,내가 저기있는걸 전부 처리할수있다 라고 선언하는게 주 목적이 되어야함(자식클래스를 부모클래스로 간주할수있다)
	이래서,좀 상속을 세분화해서,인터페이스를 상속하는걸 구현(서브타이핑)으로 표현하고,구체클래스를 상속하는걸 상속(서브클래싱)이라고 말하는듯
	그래서 상속보단 구현하라는 말이 있고
	이렇게 자식클래스가 부모클래스를 대신하는걸 업캐스팅이라고 함
	
	이렇게 같은메시지를 인터페이스를 상속받은 여러타입들이 다르게 구현할수있는걸 다형성이라고 함
	그리고 이런 메시지와 메서드를 런타임시기에 바인딩하는걸 지연바인딩,혹은 동적바인딩이라고 함
	이렇게 상속을 이용하면,같은인터페이스를 공유하는 클래스들을,하나의 타입계층으로 묶을수있음
	
	단,다형성을 이루는 방법이 상속하나만 있는건 아님
	도메인의 내부에 다른객체의 인터페이스 필드를 생성하고,거기에 생성자로 di받는걸 합성이라고함(스프링 di받는거 그거임)
	즉 다른객체의 인스턴스를 자신의 인스턴스로 포함해서 재사용하는것
	
	
	상속은,단점이 두가지 있는데,
		캡슐화위반:부모클래스의 내부구조를 알아야함,특히 추상클래스일경우 더심하고(가장큰이유)//자식클래스는 부모클래스의 메서드를 호출할수있기때문,super
		설계유연성낮음:부모자식클래스의 관계를 컴파일시점에 결정해서,실행시점에 객체종류변경이 불가능함(솔직히 바꿀일이 글케많지않음 이건)	
	그래서 상속보단 합성하라는 말이 있는거
	즉
		상속:다형성을 위해 인터페이스를 재사용하고싶을떄 사용
		합성:외부인스턴스에 의존해야할때 사용,이러면 결합도가 낮아짐
	이렇게 사용하면됨,걍 내가 하던대로 하면됨,딱보면 감오잖아
	일반화-특수화할땐 상속을 사용하고,집합을 시킬땐 합성을 사용하는거
	이렇게 합성을 사용하면,캡슐화를 더 잘할수있다는 장점이 있음,메시지만 알면되니까
	
3.역할,책임,협력	
	객체지향의본질은,협력하는 객체들의 공동체를 창조하는것
	즉,어떤 기능에 대해 어떤 협력이 필요하고,여기에 어떤 역할과 책임이 필요한지를 고민하지않고 구현부터하면,
	변경하기어렵고 유연하지못한 코드가 나타남

	객체들끼리의 협력은,메시지전송이라는 단 하나의 수단으로만 할수있고,협력은 객체지향에서 기능을 구현하는 단 하나의 방법임
	이때 메시지를 수신한 객체는 메서드를 실행하는데,여기서 객체가 메시지를 처리할방법을 스스로 선택한다는게 중요함(자율적인존재라는걸 의미)
	언어에따라 여기서 메서드를 선택하는것도 가능하기때문
	
	객체에서 행동이 존재하는이유는,그 객체가 협력에서 해당 행동을 필요로하기때문
	협력은 객체가 존재하는이유와,수행하는하는 행동의 동기를 제공해야함
	
	
	책임은,객체에 의해 정의되는,응집도있는 행위의 집합임
	객체가 유지해야하는 정보(상태)와 수행할수있는 행동들이라고 보면됨
	이건 크게 하는것과 아는것으로 나눠짐
	하는것은
		객체를 생성하거나 계산을 수행하는것
		다른객체의 행동을 시작시키는것
		다른객체의 활동을 제어하고 조절하는것(파라미터로)
	아는것은
		사적인(private)정보에 대해 아는것
		관련된객체에 대해 아는것
		자신이 뭘 유도하거나 계산할수있는지 아는것
	이렇게됨
	즉 하는것을 수행하기위해,자기밑으로 객체를 인스턴스로 가지는것
	책임과 메시지의 크기는 다름,책임이 메시지보다 더 커서,
	한책임이 여러메시지로 분할되기도 하고그럼(예매한다는 책임이 결제정보계산,그시간에 시간있는지 계산 이렇게 나뉘는거처럼)
	
	여기서 중요한건,책임의 관점에서,아는것과 하는것은 밀접하게 연관되어있다는것
	객체는 자신이 맡은 행동을 수행할때  필요한 정보를 알고있을 책임이 있고,자기가 할수없는 작업을 대신해줄 객체를 알고있을 책임이 있음
	이게 객체에 책임을 할당할때의,가장 기본적인 힌트임
	이렇게 객체지향설계에서 가장 중요한건 책임임
	
	이렇게 자율적인 객체를 만드는 가장 기본적인방법은,책임을 수행하는데 있어서 필요한 정보를 가장 잘알고있는 객체에게 그 책임을 할당하는것임
	즉,메시지를 먼저 생성하고,거기서 그걸 처리할수있는 적절한 객체에 할당하는식임
	또 그 객체가 해당행동을 수행할수있는 모든걸 알지못한다면,다시 메시지를 생성해서 다른객체에 할당하는식으로,자기내부에서 끝날때까지 체인을 타는것
	이렇게 결정된 메시지가,객체의 퍼블릭인터페이스를 구성하게되는것
	물론 가끔은,이렇게 가장 잘아는애가 아닌,다른애한테 시켜야할수도있음(응집도와 결합도관점에서)
	이렇게 설계하는게,책임주도설계(rdd)임
	즉
		시스템이 사용자에게 제공해야하는 기능(시스템책임)을 파악
		시스템책임을 더작은책임으로 분할
		분할된책임을 수행할수있는 적절한 객체 혹은 역할에 책임을 할당함
		해당객체가 책임을 수행하는도중,다른객체의 도움이 필요할경우 이를 책임질 적절한 객체 혹은 역할을 찾음
		그 객체에게 책임을 할당함으로써,두객체는 협력하게됨
	이런순서로 모든 기능을 분배하는거임
	
	이때 중요한건,객체에게 책임을 할당할때,메시지부터 정하고 여기에 맞는 객체를 선택하는거임
	즉 객체가 메시지를 선택하는게 아니라,메시지가 객체를 선택하는것
	이러면
		객체가 최소한의 인터페이스를 갖게됨
		객체는 충분히 추상적인 인터페이스를 갖게됨(뭘하는진 표현되지만,어떻게하는진 표현안되게)
	그리고,상태의 존재이유는,단순히 행동에 필요한것들임
	즉 행동을 보고 상태가 생기는것(책임->행동->상태)

	
	객체가 어떤 특정한 협력안에서,수행되는 책임의 집합을 역할이라고 부름
	실제로 협력을 모델링할땐,특정객체가 아닌,역할에 책임을 할당한다고 생각하는게좋음
	즉,책임을 할당할때도 해당 책임을 수행할수있는 역할을 찾고,거기서 역할을 수행할 인스턴스를 찾는것
	일반적으로 인터페이스(추상클래스도 가능)를 선택하고,구현체를 선택한다고 생각하면됨
	이렇게 추상화를 해야, 좀 더 유연하게 설계가 나옴
	
	이렇게 역할은 객체가 참여할수있는 일종의 슬롯임,이때 후보가 딱 하나뿐일경우에는 역할과 객체가 합쳐져서 그냥 객체가 됨
	즉,구현체가 하나밖에없을떄,인터페이스를 안만드는 그런느낌
	
	근데 설계초반엔,이걸 막 칼같이구분할필요는 없고,대충 던져놓고 거기서 분할이 필요해지면 인터페이스로 잡고 밑으로 내리는식으로 하면될듯
	중요한건 책임이니까
	
	이렇게 추상화를 하면,
		세부사항에 억눌리지않고 상위수준정책만들기가 쉽고,세부사항을 생략하고 핵심개념을 표현할수있음
		설계가 유연해짐(슬롯개념이 생기면서 대체가 편해짐)
	이런 장점이 있음
	
	그리고 한 객체가 여러 협력을 할수도있는데,이럴경우 각 협력에 따라 하나의 역할만 보여지게됨(여러인터페이스를 구현해도 하나의 인터페이스만 보여짐)



4.설계품질과 트레이드오프
	이 객체가 포함해야 하는 데이터는 무엇인가?이런 질문이 객체책임을 정하기도전에 계속 떠오르면,데이터중심설계를 하고있는거임
	특히 객체의 종류를 저장하는 인스턴스변수와,인스턴스의 종류에 따라 배타적으로 사용될 인스턴스변수가 하나의 클래스에 있는게 대표적패턴
	그리고 getter,setter이 있으면,그냥 캡슐화가 안된거임,결국 public로 풀려있는거랑 다른게없으니

	이 데이터중심설계의 단점은,
		캡슐화하기가 힘들고(객체자체가 수동적일 확률이 높으니 캡슐화도 덩달아서 힘들어짐)
		결합도가 높고(하나건드리면 다건드려야함)
		응집도가 낮음
	이건,객체가 수행할 책임이 아닌,데이터에 초점이 맞춰지기때문에 어쩔수없게됨
	이렇게 설계할때 협력에 관해 고민하지않으면,과도한 setter,getter이 생기는 경향이 있음
	이건 개발자가 객체가 사용될 문맥을 추측할수밖에 없어서 이렇게되는거
	이러면 대부분의 내부구현이 퍼블릭인터페이스에 노출되고,그 결과 캡슐화를 위반하는 변경에 취약한 설계가 나오게됨
	이렇게되면 객체를 사용하는 클라이언트들이,내부구현에 강결합하게되고 그래서 내부구현을 변경했는데 다른것도 함께 변경해야하게됨(제어객체도 같이바꿔야함)
	
	응집도가 낮으면,한 객체를 수정하는 이유가 여러개가 되기때문에,전혀 다른이유로 수정했는데,바꾸지않아도 되는거까지 영향을 받게되고,
	하나의 요구사항을 변경하기위해,동시에 여러 모듈을 수정해야함(응집도가낮아서 결합도가 높아짐)
	이래서 단일책임원칙이 나온거
	이런거의 특징은,객체내부에서 처리할수있는것도 다 외부에 모듈이 있어서,그 모듈을 여러객체가 의존하고..이렇게 되버림
	즉 수동적인 객체가 나오고,게터세터가 많고 이런 특징이 있음
	
	그래서 객체의 상태는,이 객체가 어떤 데이터를포함해야하는가+이 객체가 데이터에 대해 수행해야하는 행동이 뭔가 이렇게 두개로 나눠서생각해야함
	
	그리고 퍼블릭인터페이스엔,해당 객체가 어떻게 구현되었는지를 추론할수있을만한 힌트도 남겨선안됨
	이러면 캡슐화가 반쯤실패한거
	즉,좀더 전역적인거로 dto받는거처럼 받아서 내부에서 바꾸는식으로 하는게 더 나을듯

	이렇게 데이터중심설계는,
		너무 이른시기에 데이터에 대해 결정하는걸 강요하고
		협력이라는 문맥을 고려하지않고,객체를 고립시킨채 행동을 결정함(객체의 행동이 정해진상태로,협력에 끼워맞추게됨)
	즉 행동보단 상태에 중점을 맞추는게 제일 큰 원인임


5.책임 할당하기
	책임에 초점을 맞춰서 설계할때 어려운건,어떤객체에 어떤책임을 할당할지 결정하기 어렵다는것
	이건 본질적으로 트레이드오프라서,하나의 문제에 대한 여러 해결법이 존재함
	그래서 기본적인 가이드가 있는데,이게 grasp패턴임
	
	객체에 할당된 책임의 품질은 협력에 적합한 정도로 결정됨
	객체에게 할당된 책임이 협력에 어울리지않으면,그책임은 나쁜것임
	그래서 객체에게 그 책임이 좀 어색해보여도,협력에 적합하면 그 책임은 좋은것
	즉 책임은 객체의 입장이 아닌,객체가 참여하는 협력에 적합해야함
	그래서 메시지를 결정한 후 객체를 선택해야하는것
	
	설계를 시작할땐,개념들의 의미와 관계가 정확할필요없음,단지 출발점이 필요하고,객체들이 대충 뭐뭐가있을지,어떻게 연관될지 감만 잡히면됨
	grasp패턴은
		앱이 제공해야하는 기능을 앱에 대한 책임으로 생각
		해당 책임을 책임질 첫번째 객체를 선택(자신안에 해당행동에 대한 정보가 제일많은애,참조로 인한 정보도 포함임)
		해당 객체가 할수있는일과 할수없는일을 대략적으로 판단하고,할수없는일이 있으면 메시지를 생성
		해당메시지에 대해 다음객체를 선택
	이걸 반복하면됨
	그리고 이때,여러설계중에 하나를 선택해야할수있는데(본질적으로 설계의 가짓수는 무한하니까),이때 손실함수가 되어주는게 낮은결합도패턴과 높은응집도패턴임
	낮은결합도패턴은,어떻게하면 의존성을 낮출지,최대한 의존성이 적어지는쪽으로 책임을 할당하라는것
	높은응집도패턴은,같은책임이 이미 있는쪽에 책임을 할당하라는것,즉 한 객체가 가지는 책임의 가짓수가,최대한 추가가 적은쪽으로 책임을 할당하라는것임
	그리고 행동에 대한 결과물로 객체가 나올때,객체를 생성할 책임은,
		해당 객체를 포함하거나 참조하는 객체
		해당 객체를 기록하는 객체
		해당 객체를 긴밀하게 사용하는 객체
		해당 객체를 초기화하는데 필요한 데이터가 있는 객체
	이것들을 가장 많이 가지고있는 객체가 생성하면됨,그 객체는 이미 결합되어있기때문에,결합도에 영향을 주지않음
	
	
	이렇게 대충 밑그림을 그리고나면,실제로 구현을 해서 돌려보면,문제있는부분을 알수있게됨
	행동이 결정되었으니,행동에 필요한 상태를 넣어주면됨
	해당객체가 메시지를 전송해야하는 객체는 합성으로 가지고있고,필요한 정보들도 인스턴스변수로 넣어두고 하는식(생성자로 주입하면되니까)
	그리고 메시지는,수신자의 입장이 아닌,송신자의 의도만 가지고 이름이 나와야함
	이렇게 만들어보면 또 문제점이 나오는데,
	변경에 취약한 클래스를 포함하고있음->추상화로 해결할수있으면 추상화(이러면 응집도 따라 별개의 구현으로 가니까 응집도도 올라감)
		이렇게 설계를 개선할땐,
		변경의 이유가 하나 이상인 클래스를 찾는거로 시작하는게 좋음
			이건 인스턴스가 생성될때 인스턴스변수가 전부 같이 초기화되는지,일부는 남아있는지 확인,
				이때 같이 초기화되는 속성을 기준으로 코드를 분리할수있음
			메서드들이 인스턴스변수를 사용하는걸 확인
				모든메서드가 모든 인스턴스변수를 사용한다면,응집도는 높고,메서드들이 사용하는속성에 따라 그룹이 나뉘면,
				속성그룹과,해당 속성그룹에 접근하는 메서드그룹을 기준으로분리할수있음
		타입분리하기,두개의 독립적인 타입이 하나의 클래스에서 공존할경우,추상화를 통해 해결	
	이렇게 응집도가 올라가면,각 객체가 바뀌어야하는 이유가 하나가 되고,이렇게되면 캡슐화가 일어난것
	
	설계에서 제일 중요한건 변경임,이거에 대비하는방법으론,
	변경이 쉽게 설계를 잘하는 기본적인것과,
	코드를 수정하지않고도 변경을 수용할수있게 코드를 더 유연하게 만드는것
	이렇게 코드를 유연하게만드는건,복잡성이 상승한다는 단점이 있긴하지만,유사한변경이 반복적으로 발생한다면 그걸 감수할 가치가 있음
	이런 방식의 대표적인게 합성임,상속대신 합성을 쓰면,복잡성이 약간 상승하고,유연성이 많이 올라감
	 
	이런 책임주도설계가 어려우면,대안이 있는데,
	코드를 작성하고 코드상에 명확히 나타나는책임을 올바른위치로 이동시킴(이떄 코드를 수정해도,겉으로 드러나는 동작이 바뀌면안됨,캡슐화)//리팩토링
		1.메서드응집도를 바탕으로,메서드를 쪼개고,한메서드에 하나의 일만 하게 만들기(메서드는 최대한 짧게,주석을 쓰지않게,클래스는 길어져도됨)
		2.쪼개진 메서드를 가지고,적절한 클래스로 이동시키기
			이때 자신이 소유한 데이터는 자신이 처리하게 만드는,즉,객체를 자율적으로 만들면됨
			이건 리팩토링 전 코드가 getter를 사용하고있을때,해당객체로 넘겨버리는식임
	이런식으로 하는방법도있음


6.메시지와 인터페이스
	협력안에서 객체가 수행하는 책임에 초점을 맞춰야함,
	특히 중요한건, 책임이 객체가 수신할수있는 메시지의 기반이 된다는것
	
	두 객체사이의 협력관계를 설명하기위해 사용되는 전통적인 방법은,클라이언트-서버 모델임
	객체는 협력에 참여하는동안,클라이언트와 서버역할을 둘 다 수행하는게 일반적
	즉 협력은 객체가 수신하는 메시지들의 집합과,외부의 객체에게 전송하는 메시지의 집합으로 이루어짐
	이때 객체가 수신하는 메시지들의 집합만 초점을 맞추는경우가 있는데,협력에 적합한 객체를 설계하려면 외부에 전송하는 메시지집합도 같이고려하는게 좋음
	여기서 중요한건,객체가 독립적으로 수행할수 있는 것 보다 더 큰 책임을 수행하려면,다른객체와 협력해야한다는것
	그리고 두 객체사이의 협력을 가능하게 해주는것이 메시지
	
	메시지를 가지고 어떤 코드가 실행되는지는,메시지수신자의 실제타입(구현체)가 무엇인가냐에 따라서 달라짐
	이때 실제 실행되는 함수를 메서드라고 부름
	
	좋은 인터페이스는 최소한의 인터페이스와 추상적인 인터페이스라는 조건을 만족해야함
	최소한의 인터페이스는 꼭 필요한 오퍼레이션(객체가 다른객체에 제공하는 추상적 서비스,즉 전송자가 아닌 수신자의 관점만을 다룸)만을 인터페이스에 포함함
	추상적 인터페이스는 어떻게가 아닌 무엇을 하는지를 표현함
	이 좋은 인터페이스들은 책임주도설계를 하면 자동적으로 이렇게되는데,얘들은 특징이 있음
		디미터법칙
		묻지말고 시켜라
		의도를 드러내는 인터페이스
		명령쿼리 분리
	같은 특징들을 가지게됨
	
	디미터법칙은 오직 이웃하고만 말해라,즉 .를 1개이상 찍지 마라 라는거임
	이건 특정객체를 콜해서,그 객체까지만 보고 그 객체가 합성하고있는 객체의 필드들에 접근하지 마라는거임
	단 이걸 무비판적으로 수용하면,퍼블릭인터페이스관점에서 응집도가 낮아질수 있어서 주의하긴해야함
	즉 디미터법칙은,객체의 내부구조가 외부로 노출되는경우로 한정해서 적용해야함
	
	이 디미터법칙을 하게되면,get으로 상태를 가져오는게 아닌,걍 그 객체한테 시켜버리는게 편해지는데 이게 묻지말고 시켜라 라는거임
	이렇게되면 자동적으로 정보전문가한테 책임을 할당하게되고,이러면 응집도가 높아질 확률이 커짐
	단 이때 응집도에 맞는지도 생각을 해야함,아무생각없이하면 응집도가 오히려 떨어질수있고,결합도는 올라갈수있음
	
	즉 묻는대상이 객체면 숨기고 자료구조라면 노출하는게 맞음
	
	그리고 인터페이스는,자기가 일을 어떻게 하는지가 아닌,뭘 하는지만 드러내면됨(findByName 이런식)
	이렇게되면 추상화로 메서드를 바꾸기도 편해지게됨
	그리고 인터페이스의 메시지는,해당메시지가 뭘 하는지를 처음보는사람도 이해할수있게 이름이 나와야함
	
	명령쿼리 분리는,명령은 명령만(void리턴),쿼리는 쿼리만(멱등성)따로따로 존재하는게 좋다는것
	즉 프로시저와 함수의 분리를 해야한다는것
	이래야 쿼리가 멱등성있게 동작하게됨(사이드이펙트가 있으면 예상이어려워짐)
	
	이런 모든것들은,책임주도설계를 하게되면 따라오게됨
	
7.객체분해
	사람은 일정갯수이상을 동시에 단기기억에서 꺼낼수없음(인지과부하)
	그래서 사용되는게,추상화와 분해임
	즉 숫자8x11개가 아닌,전화번호 8개로 나누는,즉 청크를 잡아서 좀 더 크게 잡으면 인지과부하가 덜해짐
	이렇게 큰문제를 해결가능한 작은문제로 줄이는걸 분해라고 하고,기억해야할 양을 쳐내는걸 추상화라고 함
	
	프로그래밍에서도 똑같이 이방식으로 진행되는데,이때 프로시저추상화와 데이터 추상화로 나눠지게됨
	프로시저추상화를 중심으로 시스템을 분해하면 기능분해(알고리즘분해)
	데이터추상화를 중심으로 시스템을 분해하면 추상데이터타입(데이터중심타입추상화),객체지향(데이터중심프로시저추상화)로 나눠지게됨
	
	프로그래밍에서 프로시저중심의 분해의 문제는,메인함수를 잡고 그거기준으로 쪼개야하는데,변경시 메인함수가 여러개되는상황이 될때에 너무 약해짐
	즉 트리구조인데 루트가 여러개생기면 머리아픔,억지로 하나의 메인잡으려고하면 ocp가 안깨질수가없고
	추가적으로,너무 이른시점에 제어구조가 고정되서,제어구조의경우 변경할일이 작은데 변경할때마다 머리아프고,함수의 재사용도 어려움(딱 그케이스에만 맞게되니까)
	즉 결합도에서 큰 문제가 생기게됨
	
	즉 이런 하향식분해는,프로그램을 설계할때가 아닌,프로그램이 다 만들어지고나서 설명문서를 작성할때엔 이해가 쉬워서 적합함
	
	이렇게 시스템의 변경을 관리하는건,함께 변경되는 부분을 하나의 구현단위로 묶고,퍼블릭인터페이스를 통해서만 접근하게하는것
	즉 기능기반분해가 아닌,변경의 방향에 맞춰 시스템을 분해하는 전략을 짜게 됨
	이때 정보은닉은,시스템을 모듈단위로 분해하기위해 자주변경되는부분을 덜 변경되는 인터페이스뒤로 숨겨야한다는,가장 중요한 개념임
	정보은닉은,외부에 감춰야하는 비밀에 따라 시스템을 분할하는 모듈 분할 원리임,모듈은 변경가능성이 있는 비밀을 내부로 감추고,
	쉽게 변경되지않는 퍼블릭인터페이스를 외부에 제공해서 내부비밀에 함부로 접근하지 못하게 한다
	
	모듈과 기능분해는 상호 배타적인게 아닌,시스템을 모듈로 분해하고,모듈내부를 구현하기위해 기능분해를 적용하는식임
	즉 기능분해는 기능을 구현하기위해 필요한기능을 찾아가는 과정이고,모듈분해는 감출비밀을 선택하고 비밀주변에 안정적인 보호막을 설치하는 보존의 과정임
	이렇게 비밀을 선택하고 모듈을 분해하고나선 기능분해를 사용해 퍼블릭인터페이스를 구현할수있음
	
	즉 감출걸 찾고,방어막을치고(이때 방어막이 퍼블릭인터페이스임)하는게 모듈분해임
	모듈은
		복잡성:모듈이 너무복잡하면 이해와 사용이 어려우니,모듈을 추상화할수있는 인터페이스를 제공
		변경가능성:변경가능한 설계결정이 외부에 노출되면 변경시 파급효과가 커지니까,이런건 감추기
	이 두가지를 감춰야함
	이때 가장 일반적으로 감춰야하는게 데이터지만,이것만 감추면 되는게 아님
	복잡한 로직이거나,변경가능성이 큰 자료구조등도 감춰야함
	
	이렇게 모듈을 쓰면,
		모듈내부변수가 변경돼도 모듈내부에만 영향을 줌
		비즈니스로직과 인터페이스에 대한 관심사 분리
		전역변수를없앨수있음
	이렇게 모듈은,데이터와 함수가 통합된 한차원 높은 추상화를 제공하는 단위임
	이런 장점이 있지만,추상화관점에서 한계가(인스턴스가없으니) 명확함
	그래서 나온게 추상데이터타입
	
	추상데이터타입은 클래스와 유사하지만,상속과 다형성을 지원하지 않는것
	즉 추상데이터타입에 다형성을 추가한 발전된상태가 클래스라고 볼수있음
	즉 추상데이터타입은 타입을 추상화하고,클래스는 절차를 추상화한것임
	추상데이터타입은 함수를 기준으로 타입을 묶게되고,
	객체지향은 타입을 기준으로 함수를 묶게됨
	그래서 객체지향에서는 타입에 따라 메시지가 다르게 동작하는것=다형성
	이렇게 내부절차는 달라도,이 절차를 감춰서 객체지향을 절차추상화라고 부르는것임
	
	그래서 클래스를 사용해도,절차추상화가 되지않으면 객체지향이 아닌것임(메시지에 절차가 남아있다던가)
	그래서 객체지향에선 조건분기가 없어지는것(타입에따라 메시지가 다르게동작하면되니까)
	이렇게 조건문이 기피되는것 역시 변경취약성때문이고(ocp위반)



8.의존성 관리하기
	객체사이의 협력은 필수적이지만,과도한협력은 설계가 개판될수있음 
	다른객체와 협력하기위해선 그런객체가 존재한다는걸 알고,수신할수있는 메시지에 대해서도 알아야하기때문,이런게 의존성을 낳음
	
	협력을위해 의존성은 필수적이지만,과도한의존성은 앱을 수정하기 어렵게 만듬
	그래서 객체지향의 핵심은,협력을위해 필요한 의존성은 유지하면서,변경에 방해되는 의존성은 제거하는것
	즉 객체지향설계는 의존성을 관리하는거고,객체가 변화를 받아들일수 있게 의존성을 정리하는기술임

	의존성은,실행시점엔 반드시 의존하는 객체가 존재해야하고,구현시점엔 의존대상객체가 변경되면 의존객체도 함께 변경됨
	의존성은 방향성을 가지며 항상 단뱡향임
	즉 의존하는대상이 바뀌면 의존대상이 영향을 받지않지만,의존대상이 바뀌면 의존하는대상이 영향을 받음
	
	의존성은 전이될수있음
	해당 의존성을 의존하고있는 객체를 의존할경우,해당의존성도 생기게 된다는것(간접의존)
	물론 의존성은 함께 변경될수있는 가능성을 의미하기때문에,무조건 의존성이 전이되는건 아니고,변경의 방향과 캡슐화에 따라 달라짐
	즉 그럴 가능성이 있으니까 주의해야한다는것
	
	의존성은 런타임의존성과 컴파일타임의존성으로 나뉘는데,이게 그 강결합약결합시 다르게 의존되는 그걸말하는것
	컴파일타임엔 인터페이스를 의존하고,런타임시 구현체를 의존하는게 약결합,
	둘다 구현체를 의존하는게 강결합
	약결합이 되면될수록 설계가 유연해지고 재사용가능해짐(복잡성은 좀 올라가지만,한눈에 뭐의존하는지 안보이니까)
	그래서 new를 사용하지마라는것,이러면 강결합이되니까
	이렇게 클래스가 특정문맥에 강하게 결합되지않은,최소한의 가정으로만 이뤄져있는걸 컨텍스트독립성이라고 부름
	
	이렇게 애들을 최대한 떼어두고,약결합으로 만든다음에,런타임시기에서 ioc와 di를 통해서 결합을 시키는거임 프레임워크한테(의존성해결)
	이때 방법이 생성자를통해 하던가,세터를통해하던가,필드를 통해 할수있는데 일반적으로는 생성자로 많이함
	세터는 의존성을 바꿔야하는이유가 있으면 사용할순있음
	아니면,메서드의 인자를 통해서도 할수있음(파라미터로 객체를받는거)
	

	객체들끼리 의존성이 있다는건 전혀 문제가 아님,의존성이 있어야 협력을 할수있기때문
	문제는 의존성의 정도와 숨은 의존성임
	의존성을 어지간하면 약결합인게 좋고(최대한 재사용성이 높게,컨텍스트에 독립적이게)
	최대한 서로간에 지식이 없어야함(메시지정도만 알고있는게 베스트,의존성도 di받으면)
	즉 구체클래스보단 인터페이스가 알아야하는 지식이 더 적으니 인터페이스를 의존하는게 좋다는것
	
	그리고 생성자에서 구체클래스(new)를 받는거도,외부에서 한번에 넣기 귀찮아지고,
	내가 협력할 대상에 대해 알아야하기때문에 급격하게 의존성이 올라가게됨
	그래서 인스턴스를 생성하는로직과 사용하는로직을 분리해서 사용하는것(ioc)
	즉 명시적으로 뭘 의존하는지 공개해야지,생성자같은 찾기힘든데서 new로 생성해버리면 찾기 너무 힘들어짐(숨겨진의존성)
	
	뭐 어짜피 트레이드오프니까 꼭 new를 금지해야한다 정도는 아니긴한데,ioc있는시점에서 자바기본구조체들 말고 쓸일이 없는거도 사실이긴한듯
	자바기본 표준클래스같은경우야 당연히 new써도 상관없고(안정성이 높으니)
	
	유연하고 재사용가능한 설계는,객체가 어떻게 하는지가 아닌,객체들의 조합으로 무엇을 하는지를 표현하는 클래스로 구성됨
	따라서 클래스의 인스턴스를 생성하는 코드만 봐도 뭘할지가 보이게됨,즉 선언적으로 객체의 행동을 정의할수있음


9.유연한 설계
	앱은 확장에 열려있구 수정에 닫혀있어야함
	즉 기능추가는 되어야하는데,그 기능추가가 기존코드를 수정하는것이면 안됨
	이러기위해서 컴파일의존성을 고정시키고,런타임 의존성을 변경시키는 방식을 사용하는것
	
	즉 이러기위해서 핵심은,추상화에 의존하는것
	이때 중요한건,의존성의 방향임,즉 모든 요소가 추상화에 의존해야하고,변하는것과 변하지않는걸 구분해서 추상화엔 변하지않는것만 들어가야함
	
	그리고,생성자에서도 추상화를 의존해야하니까,외부로 해당 구현체를 선택하는걸 빼버려야함(생성전담객체,팩토리객체)
	즉 같은클래스내에서 객체생성과 사용이라는 다른목적의 코드가 공존하는게 문제인것
	이때 가장 보편적인방법은,객체생성책임을(구현체선택책임까지도) 클라이언트쪽으로 빼버리는것
	이거도 맘에안들고(특정컨텍스트에 클라가 묶이는것도 싫음)그러면 아예 ioc처럼 외부로 던져버리고,선택만 거기서 미리 해둘수도있음
	이 객체생성에 특화된 객체를 팩토리라고 부름
	
	이렇게 결합도를 낮추고 재사용성을 높이기위해,도메인객체에서 아예 관계가없는 가공의 객체로 책임을 이동시킬때,
	가공의 객체를 순수한 가공물(퓨어파브리케이션,도메인서비스라고도 부름)이라고 부름
	어떤 행동을 추가하려고하는데 마땅한 도메인개념이 없다면,퓨어파브리케이션을 추가하고(도메인서비스랑 같은거,걍도메인서비스라고 부름),거기에 책임을 할당하면됨
	
	그래서 객체지향이 실세계의 모방이라는게 아닌것,인공적인 추상화들이 있으니까
	
	즉 도메인을 먼저 추상화해서 만들다가,먼가 애매하다싶은게있으면 걍 해당인공객체를 만들어서 거기다가 박으면됨
	또한 도메인객체에 책임을 할당하는게 맞는데,그러면 결합도와 응집도에 문제가 생긴다면,이때도 인공객체에 넣는걸 고민하면됨

	이렇게 사용하는 객체가 아닌 외부의 독립적인 객체가 인스턴스를 생성해서 이를 전달해서 의존성을 해결하는 방법을 의존성주입이라고 부름
	이게 왜 의존성주입이냐면,외부에서 의존성대상을 해결하고 이를 사용하는쪽으로 주입하기때문
	여기서는 대표적으로 생성자주입,세터주입,메서드주입이 있음
	
	이 의존성주입말고도 의존성해결을 위한 다양한 방법이 있는데,대표적으로 서비스 로케이터패턴이 있음
	이건 의존성을 해결할 객체들을 보관하는 저장소에서,해당 인터페이스를 구현한 객체를 달라고 요청해서 받아다쓰는것
	이거의 단점은,의존성을 감춘다는것,이러면 암시적인 의존성이 되버리게됨
	즉 저거사용하지않고 걍 new로 생성해버리면,해당의존성은 null이 되니까 npe떠버리고 그런것
	즉 문제가 런타임에서 터지니까 머리아파짐,이러면 단위테스트작성도 힘들기도하고
	그래서 걍 의존성주입이 젤 무난함,숨겨진의존성도 없고
	
	그리고 클라이언트와 서버가 둘다 의존성에 의존하면,하위의 변경으로 상위가 영향을 받는걸 방지할수있고,상위를 재사용할떄도 하위를 신경안써도됨
	그래서 중앙에 추상화를 넣는게 좋은거,이게 의존성역전원칙임(이떄 역전이라는건,걍 절차지향에서와 반대라는것)
	
	그리고 이때,역전은 의존성의 방향뿐 아니라 인터페이스의 소유권에도 적용됨
	객체지향에서 어떤 구성요소의 소유권을 결정하는건 모듈이고(자바에서의 패키지),이 폴더 내에 변경이 일어나면 재컴파일이 일어나게됨
	그래서 인터페이스를 상위쪽으로 붙여버리고(변경이 덜한쪽),하위쪽은 따로두는것(변경이 잦은쪽)
	이렇게 빌드시간을 줄일수있음
	
	즉 추상화를 클라이언트패키지에 포함시키고,함께 재사용될 필요가 없는 클래스들은 별도의 독립적인 패키지에 모으는것,
	이걸 분리 인터페이스(SEPARATED INTERFACE)패턴이라고 부름
	이렇게되면 추가적으로 해당 클라이언트를 특정컨텍스트로부터 완전히 독립시킬수있음
	
	
	유연한 설계는,유연성이 필요할때만 옳음
	유연한 설계라는말은 복잡한 설계라는말과 같기때문에,유연성을 올릴려면 단순성과 명확성을 낮출수밖에없음
	그리고 설계를 유연하게 만드려면,협력에 참여하는객체가 다른객체에 무슨 메시지를 날리는지가 중요함
	즉 객체를 생성할 객체를 만드는거나 이런건,할거 다하고 마지막에 하는거고,비즈니스로직처리를 위해 책임을 할당하고 협력에 균형을 맞추는게 젤 중요
	특히 싱글톤같은거 사용되는게,너무 이른시기에 객체생성에 관해 고민하면 자주 사용하게됨
	즉 의존성관리는,역할책임협력이 끝나고나서 하는것임

10.상속과 코드재사용
	중복코드는 문제가 많음,일단 수정하려면 다 고쳐야하고,두개가 같은건지도 확인해야하고,없애야하는지 아닌지도 잘모르겠고 등등
	가장 큰 문제는 변경을 방해함
	그리서 중복여부를 판단하는 가장 큰 기준은,코드의 모양이 아닌 요구사항이 변경되면 같이변경되면 중복코드임,
	즉 변경에 반응하는 방식에 따라 중복이냐 아니냐가 결정됨
	
	기본적으로 중복을 허용하고 만들면,일단 구현속도자체는 엄청빠르긴한데,잠재적인 코스트가 너무 큼,걍 폭탄에 불붙여둔거
	중복코드에 양쪽다 적용해야하는 수정이 들어가는순간부터 머리가아파짐
	어떤 코드가 중복이고,어떤게 아닌지부터 판별해야하고,하나까먹으면 그대로 버그,고쳤다고해도 둘다 다른방식으로 동작하면 잠재적인 문제점임

	이걸 해결하는 간단하지만 문제가 좀 있는방법은,타입코드를 추가하는건데,이러면 응집도가 낮아지고 결합도가 올라감
	그래서 이걸해결하는건,즉 중복코드를 관리하는방법은 보통 상속이나 합성임
	
	상속은 이미 존재하는클래스와 유사한 클래스가 필요하면,코드를 복사하지말고 상속으로 재사용하는것
	단 이때 주의해야할게 있는데,super로 부모메서드를 호출하게되면,부모와 자식간의 결합이 엄청강해지기때문에 어지간하면 사용하면안됨
	추가적으로 코드보고 이해도 어렵고
	즉 상속을 사용할거라고 만들어지지 않은 클래스에서 상속으로 재사용을 하는건 좀 어려움
	
	이렇게 자식이 부모의 변경에 취약해지는문제를,취약한 기반 클래스문제 라고 부름
	이건 코드재사용을 목적으로 상속을 사용할때 발생하는 대표적인 문제임
	이건 상속을 사용하면 피할수없는 객체지향의 근본적인 취약성임
	
	즉 상속을 사용하면,기능을 확장하는덴 유리하지만 부모클래스를 건드리는건 어려워짐
	최악의경우엔 부모와 모든 자식을 수정하고 테스트해야할수도있음
	이건 자식클래스가 부모의 세부구현에 의존하기때문에 이렇게됨,그래서 캡슐화가 약화되고 결합도가 올라가는거
	
	인터페이스 설계는 제대로쓰기엔 쉽게,엉터리로 쓰기엔 어렵게 만들어야함
	퍼블릭 인터페이스에 대한 고려없이 단순 코드재사용을 위해 상속을 사용하면 많이 위험함(상속받은 부모메서드가 자식의 내부구조규칙을 깨트릴수있음)
	그리고 자식이 부모메서드를 오버라이딩하면,부모가 자신의 메서드를 사용하는 방법에 자식클래스가 결합될수있음(프라이빗이나 다른메서드를 호출하거나..)
	즉 새로운 변수가 추가되어서,부모클래스에서 그걸 메서드로 관리해야한다면 자식도 그걸 관리해야하게될수있음
	클래스를 상속하면 결합도로 자식클래스와 부모클래스의 구현을 영원히 변경하지않거나,동시에 변경하거나 둘중하나를 택일해야함
	
	그래서 클래스를 상속할땐,상속을위해 클래스를 설계하고 문서화해야하며,이걸못하면 상속을 사용하면안됨
	근데 이렇게되면 내부구현을 문서화하는거라서,코드재사용과 캡슐화를 트레이드오프하는거임
	
	이 취약한 기반클래스 문제를 해결할순없지만,완화할순 있는데 이게 추상화의존임
	부모와 자식 모두 추상화에 의존하고,
	비슷한메서드가 있으면 차이점만 메서드로 추출하고,
	부모클래스의 코드를 하위로 내리지말고,자식클래스의 코드를 상위로 올리는게 더 나음
	
	가장 먼저 할일은,중복코드안에서 차이점을 별도의 메서드로 추출하는것
	즉 변하는것으로부터 변하지않는걸 분리하는거임(변하는걸 찾아서 캡슐화해라)
	이건 일단 한 메서드속에서 서로 중복되는부분을 찾고,이걸 별도의 메서드로 분리한다음(일단 자기꺼안에),
	똑같은거 확인하고 자식거를 지워서 중복을 제거하는거임
	이때 추상클래스를 사용할수있고,인스턴스변수보단 메서드를 먼저옮기는게 ide도움을 받을수있어서 편함(꼭 필요한변수만 옮길수있음)
	
	이렇게 위로 올리면,문제가생겨도 찾기쉬운데,밑으로 내리면 문제가생기면 찾기힘듬
	즉 구체적인 구현을 위로 올려버리는게 나중에편함
	이렇게되면 각 자식클래스와 부모클래스는 서로 다른 변경의 이유를 가지게되어서,단일책임원칙이 지켜지게됨
	
	그리고 추가적으로,클래스명은 자기가 구현하는것에 대한 내용을 명확히 드러내는게좋음
	이래도 뭐 변수추가되는거 같은 일들은 같이 초기화시켜야하고 이런건 같이건드려야할수있긴한데,예전보단 나음
	
	물론 이거보다 코드재사용측면에서는 나은게 합성임


11.합성과 유연한 설계
	상속을 사용하면 쉽게 재사용을 할수있긴하지만,내부구현을 알아야하기때문에 결합도가 올라감
	그래서 나온게 합성임
	합성은 객체의 구현이 아닌 퍼블릭 인터페이스에 의존함
	그래서 내부구현이 변경되더라도 영향을 최소화할수있음
	
	상속은 클래스간의 정적관계고,합성은 객체사이 동적관계임
	그래서 상속은 변경이 불가능하지만,합성은 런타임시점에 동적으로 변경할수있어서,좀 더 유연해짐
	물론 좀 더 구현할때 귀찮긴하지만
	
	상속은 부모클래스의 코드 자체를 재사용하지만,합성은 포함되는 객체의 퍼블릭인터페이스를 재사용함
	그래서 구현에 대한 의존성을 인터페이스의존성으로,강결합을 약결합으로 바꿀수있는것
	이러면 불필요한 인터페이스상속,메서드오버라이딩의 부작용을 해결할수있고
	그래도 부모자식간의 동시수정문제는 남아있지만,좀 약화됨(인터페이스가 구현코드보단 더 캡슐화가 잘되니까)
	
	그리고 상속에는,클래스폭발이라는 문제가 있는데,만약 서로 병렬적으로 붙여야하는 로직이 있을때(데코레이터패턴 유즈케이스 생각하면됨),
	상속을 사용하면 조합의 갯수만큼 클래스를 만들어야해서 엄청머리아파짐
	이걸 상속이 아닌 합성으로 바꾸면,퍼블릭인터페이스에 대해서만 의존하기때문에,클래스내부에 인터페이스로 해당객체변수를 받는식으로 해결할수있음
	이안에서 데코레이터로 둘둘감싸서 던지면,클래스 막 조합갯수만큼 안만들고,하나만 만들어도되는거
	이래서 합성이 상속보다 일반적으로 코드재사용을 위해 사용할땐 좋음
	상속은 인터페이스상속을 위해서만 사용하는게 좋음
		
	추가적으로 추상메서드는, 모든자식클래스에서 구현해야하는 단점이 있는데,모두 같은방식이라면 이게 중복이니 편의를위해 기본구현을 제공할수있음,이게 훅메서드임
	
	추가적으로 코드재사용기법이 하나 더있는데,이게 믹스인임
	이건 상속과 합성의 특성을 모두 보유하고있음
	이건 객체를 생성할때,코드일부를 클래스안에 섞어넣어 재사용하는 방법임
	즉 컴파일시점에 필요한 코드조각을 조합하는것
	대상 타입의 주된기능에 선택적기능을 합친다는느낌
	자바에선,메인 타입인터페이스와(기존에 이미 있던) 서브타입 인터페이스를(새로 기능추가를 위해 만든) 둘다 상속받아서 구현한다고 생각하면됨
	가장 쉬운방법은 인터페이스의 디폴트메서드를 사용하는것,즉 템플릿메서드패턴을 사용하면됨



12.다형성
	상속은 코드재사용이 아닌,타입계층을 구조화하기위해 사용해야함
	이 타입계층은 다형성의 기반을 제공함
	
	상속은 코드를 재사용하기위해서가 아닌,클라관점에서 인스턴스들을 동일하게 행동하는 그룹으로 묶기위해서 사용해야함
	
	다형성은,크게 유니버설 다형성과,임시다형성으로 구분할수있고
		유니버설다형성
			매개변수다형성
			포함다형성
		임시다형성
			오버로딩다형성
			강제다형성
	이렇게 분류할수있음
	
	일반적으로 하나의 클래스안에 같은이름의 메서드가 존재하면 오버로딩다형성이라고 부르고,
	강제다형성은 언어가 지원하는 자동타입변환(int끼리의 +와 string+int의 동작방식이 다른거같은),직접구현한타입변환 이런것들임
	일반적으로 오버로딩다형성과 강제다형성을 섞어쓰면,뭐가호출될지몰라서 같이사용하지 않음
	
	매개변수다형성은 제네릭임,받을 타입을 실제 인스턴스를 생성하는시점에 구체적으로 정하는것
	포함다형성은 메시지가 동일해도 수신한 객체의 타입에 따라 실제수행행동이 달라지는,일반적으로 의미하는 다형성임
	보통 그냥 다형성이라고 하면 포함다형성을 말함
	
	포함다형성은 일반적으로 상속으로 구현할수있고,이걸위한 전제조건은 자식클래스가 부모클래스의 서브타입이어야함
	그리고 상속의 진정한목적은 코드재사용이 아닌,다형성을 위한 서브타입구축임
	즉 상속으로 클래스계층을 쌓고,상황에따라 적절한 메서드를 선택하는것
	이때 객체지향시스템은,메시지를 처리할수있는 적절한 메서드를 탐색스코프를 넓혀가면서 탐색해서 처음걸린걸 사용하게됨
	
	그래서 타입계층에 대한 고민없이 상속을 사용하면,이해하기어렵고 유지보수가 어려운 코드가 만들어질 확률이 높음
	그래서 상속의 메커니즘을 이해하는데 필요한 몇가지 개념은
		업캐스팅
		동적메서드탐색
		동적바인딩
		self참조
		super참조
	들을 알고있어야함
	이러면 상속의 내부메커니즘뿐 아니라 타입계층을 기반으로 한 다형성의 동작방식을 알게됨
	
	기본적으로 자식클래스와 부모클래스의 메서드시그니처(이름과 매개변수)가 완전히 동일할경우,스코프에 따라 자식이 우선순위가 더 높아 자식이 나가게됨
	이렇게 완전히 같은 시그니처를 재정의해서 구현을 바꿔치기하는걸 메서드 오버라이딩이라고 부름
	그리고 메서드의 이름은 동일하지만 시그니처는 다른(그중에서 매개변수가 다른)걸 자식클래스에 추가하는걸 메서드 오버로딩이라고 부름
	
	상속을 데이터관점에서 보면,자식클래스의 인스턴스안에 부모클래스의 인스턴스가 포함되는거처럼 생각하면되는데,기본적으로는 바로 부모클래스에 접근할수없음
	혹은 행동관점으로 볼수도 있는데,이경우엔 부모클래스가 정의한 일부 메서드를 자식클래스의 메서드로 포함시키는걸 의미함
	여기서 일반적으로 부모의 모든 퍼블릭 메서드는,자식의 퍼블릭인터페이스에 포함되게됨,즉 부모에게 전송할수있는 모든 메시지는 자식에게 전송할수있음
	
	이때 실제로 클래스코드를 합치거나 하는건 아니고,자식클래스에 정의되지않은 메서드가 있을경우 부모클래스에서 탐색하는 루틴을 돌기때문임
	그리고 추가적으로,객체의경우엔 서로 다른 상태를 저장할수있도록 각자 독립적인 메모리를 할당받아야하지만,
	메서드는 다 똑같으므로 한군데만 넣어두고(클래스단위로 묶어둠),인스턴스마다 포인터만 가져가게됨
	이때,클래스단위 메서드를 묶어두는데다가 자신의 부모의 포인터도 넣어두기때문에 상속체인을 타고 탐색하는게 가능해짐
	이때 오브젝트까지 탐색하고도 해당메서드를 못찾으면 예외가 터지거나,컴파일언어의경우 컴파일이 실패함
	
	부모클래스타입으로 선언된 변수에 자식클래스의 인스턴스를 할당하는걸 업캐스팅이라고 하고,
	선언된 변수의 타입이 아닌,메시지를 수신하는 객체의 타입에 따라 실행되는 메서드가 결정되는걸 동적바인딩이라고 함
	이렇게 부모클래스의 타입에 메시지를 던져도,실행시엔 실제 클래스기반으로 메서드를 선택하는걸 동적 메서드탐색이라고 함
	
	이렇게 업캐스팅과 동적메서드탐색이 ocp를 지키는 주된방법임
	이 상속을 사용해서 업캐스팅을 걸고,명시적인 타입변환없이 자식이 부모를 대체할수있게 허용하는것
	이런걸 활용하는 두가지가 대입과 메서드의 파라미터타입임
	모든 객체지향언어는,명시적으로 타입을 변환하지않아도,부모의 참조변수에 자식의 인스턴스를 대입할수있게 허용함(policy A=new displuspolicy())
	이렇게 업캐스팅을 사용해서 기존코드를 건드리지않고 확장을 할수있는것
	반대로 부모를 자식으로 변환하려면 명시적인 타입캐스팅이 필요한데,이게 다운캐스팅임(보통 오브젝트를 변환할때 사용)
		
	
	함수호출과 메시지전송의 차이는 생각보다 큰데,이건 두개의 언어적메커니즘이 완전히 다르기때문임
	함수를 호출하는 언어들은,호출될 함수를 컴파일타임에 결정함,즉 정적바인딩임(컴파일타임바인딩)
	객체지향에서는 실행될 메서드가 런타임에 결정되는데,즉 동적바인딩임(런타임바인딩)
	그래서 해당 메서드를 호출하는곳에 적혀있는 클래스만 봐서는 정확한 메서드를 알수없고,실제로 무슨인스턴스를 생성하는지를 알아야 정확한 메서드를 알수있음
	
	이때 규칙은
		메시지를 수신한 객체는,자신의 클래스에 적합한 메서드가 있는지 검사,있으면탐색종료
		없으면 부모에서 탐색,오브젝트까지 재귀타고 찾으면 종료
		오브젝트에서도 못찾으면 예외터트림
	순임
	여기서 중요한게있는데,self참조임(자바에서의 this)
	객체가 메시지를 수신하면,self참조라는 임시변수를 자동으로 생성하고,메시지를 수신한객체를 가리키게해둠
	그래서 여기서부터 역방향으로 탐색돌리다가 종료되면 이 self참조는 소멸함
	즉 첫 시작을 위해 객체의 메모리를 가리키는 포인터임
	
	이렇게 동적메서드탐색은,자동적인 메시지위임(이해할수없는건 부모로 위임)과 동적인문맥(컴파일시점이 아닌 실행시점에 메서드선택)으로 구성됨
	그래서 오버라이딩은,그냥 자식에서 같은이름으로 메서드를 만들수있게 허용해주는거뿐임,그러면 그냥 스코프상 그거부터 걸릴테니까
	
	그런데 오버로딩은,언어마다 좀 다를수있음
	상속대상간의 메서드오버로딩을 지원하지않는경우가 있기때문(c++),자바쪽에서나 일반적으론 지원함
	c++에선 하나의 부모메서드를 오버로딩하면,해당 부모메서드를 전부 자식클래스에서 감춰버림,즉 같은클래스내에서의 오버로딩은 허용하지만
	그래서 언어마다 이건 다를수있다는건 알아둬야함
	
	그래서 같은코드라도 self가 가리키는,할당받은 인스턴스가 뭐냐에 따라 메서드탐색을 위함 상속계층의 범위가 동적으로 변함
	이걸이용해서 객체가 실행될 문맥을 동적으로 바꿀수있음
	근데 이건,어떤메서드가 실행될지 예상이 좀 어려워지긴함
	대표적으로 자기자신에게 메시지를 전송하는 self전송임
	이때 중요한건,현재 클래스의 메서드를 호출하는게 아니라 현재 객체에게 메시지를 전송하는거라서,
	만약 상속타고 저게 있는 메서드가 내려가고,거기서 해당메서드가 오버라이딩되면 그 객체가 가진 메서드가 호출되는거
	즉 self참조에 있는 메서드를 호출하는거임
	그래서 self전송이 깊은상속과 메서드오버라이딩들과 만나면 진짜머리아프고 이해하기힘듬
	
	추가적으로 super참조는,자신의 부모클래스에게 메시지를 전송함
	즉 self가 자신부터 탐색을 시작하는거라면,super은 자신의 부모부터 탐색을 시작하는것
	그래서 부모클래스에서 해당메서드가 오버라이딩해서 자기가 만든게 아니라면,부모의 부모로 상속체인을 타고 위에있는애것이 실행될수있음
	
	이렇게 다형성은 self가 타입이 아닌 현재 객체에 메시지를 전송한다는특성에 기반함
	그래서 상속을 자식클래스에서 부모클래스로 self를 전달하는 메커니즘으로 바라볼수도있음
	
	self는 항상 메시지를 수신한 객체를 가리키기때문에,한 탐색루틴중엔 모든 인스턴스가 동일한 self참조를 공유함
	그래서 부모로 self를 던져주면서 공유하는,즉 인스턴스사이 링크를 가진 연결관계처럼 생각할수도있음
	이렇게해서 사용하는게 위임이라는,프로토타입식 접근법임
	클래스기반에서 사용하는건 쉽지않지만,프로토타입기반언어쪽에서도 상속을 구현할수있다(이게 유일한방법임)는것
	
	
	

13.서브클래싱과 서브타이핑
	상속의 첫번째용도는 타입계층을 구현하는것,여기서 부모는 일반화되고,자식은 특수화됨
	두번째용도는 코드재사용인데,이걸위해서는 안하는게좋음
	
	타입이란 심볼(이름),내연(공통속성),외연(타입에 속하는 객체들의 집합)으로 구성됨
	그리고 컴퓨터속에선 연속적인 비트에 의미와 제약을 부여하기위해 사용되고,추가로 타입에 수행될수있는 오퍼레이션의 집합을 정의함
	객체지향에서 오퍼레이션은 객체가 수신할수있는 메시지임
	근데 객체가 수신할수있는 메시지의 집합은,퍼블릭인터페이스임
	즉 객체지향에서 타입을 정의하는건,퍼블릭인터페이스를 정의하는것과 같음
	
	그래서 객체에서 상태보다 행위가 중요한것,상태가 같아도 행위가 다르면 다른타입이고,상태가  달라도 행위가 같으면 같은타입임
	
	타입계층을 구성하는 두 타입간에,더 일반적인타입을 슈퍼타입,더 특수한타입을 서브타입이라고 부름
	내연관점에서 일반화는,좀 더 타입정의를 보편적이고 추상적으로 만드는것이고
	특수화는 어떤타입정의를 좀 더 구체적이고 문맥종속적으로 만드는것을 의미함
	외연관점에서는,일반적인 타입의 집합은,특수한타입의 집합을 포함하는 슈퍼셋이고,
	특수한타입의 집합은 일반타입의 집합에 포함된 서브셋임
	
	즉 객체지향에서,더 일반적이라는건(슈퍼타입),퍼블릭인터페이스가 더 범용적이고 넓은의미라는것
	더 특수하다는건(서브타입),퍼블릭인터페이스가 구체적이고 좁은의미라는것
	
	서브타입의 인스턴스는 수퍼타입의 인스턴스로 간주될수 있다는게 핵심임,이게 다형성의 핵심
	
	
	상속의 용도는 타입계층을 구현하는거고,그래서 만족해야할조건은
		상속관계라 is-a관계,즉 자식클래스는 부모클래스다 라는게 클라관점에서 이상하지않아야함(행동관점에서)
		클라입장에서 부모타입으로 자식클래스를 사용해도 이상하지않아야함,즉 행동호환성을 만족해야함
	클라관점에서 is-a여야한다는게,정사각형클래스와 직사각형클래스를 만들어보면,정사각형은 직사각형과 호환되지않는것으로 이해할수있음(추상화상태에선)
	새의 서브타입으로 펭귄을 넣었는데,날수있다는 메서드가 필요하다면 문제가 생기는거처럼..
	즉 타입의 이름사이에 개념적으로 연관성이 있어도,행동에 연관성이 없다면 is-a가 아님
	
	이런경우를 해결하려면,상위타입으로 새를 두고,서브타입으로 날수있는새,날수없는새를 둔다음 날수없는애를 상속받은 펭귄을 만들어야함
	아니면 새에 fly를 넣지말고,그냥 새를 상속받고,날수있는애만 서브타입으로 빼던지
	이경우에 날수있는새쪽의 코드를 가져와야하면,합성으로 빼내는게 맞는선택임
	이렇게 인터페이스를 클라의 기대에 따라 분리해서,영향을 제어하는걸 인터페이스분리원칙 이라고 함
	물론 나는게 별 상관없는요구사항이면,저런거 안하고 바로 새를 상속받아도됨
	즉 현실묘사가 아닌,요구사항을 실용적으로 수용하는게 중요함
	
	그래서 코드재사용을 하려고 상속을 하는걸 서브클래싱(구현상속),타입계층을 구성하려고 상속을 하는걸 서브타이핑(인터페이스상속)이라고 부르고,
	상속은 서브타이핑을 위해서만 사용되어야함
	이렇게 서브타이핑관계가 유지되려면,서브타입이 슈퍼타입이 하는 행동을 동일하게 할수있어야함,즉 부모가 사용되는 모든문맥에서,대체할수있어야함
	이걸 리스코프 치환 원칙이라고함
	리스코프치환원칙은,서브타이핑관계를 만족시키는 조건임,즉 서브타입은 기반타입에 대해 대체가능해야한다는것
	차이점을 모르는채로도 기반타입의 인터페이스만을 사용해 서브클래스를 사용할수있어야한다는것임
	그래서 자식은 부모가 가지고있는 가정을 준수해야함,이건 클라와 격리한태로 본모델을 검증하는게 불가능하다는걸 이끌어냄
	어떤 모델의 유효성은 클라관점에서만 검증가능하다는것
	
	물론 상속을 사용하지않아도 타입계층을 구현할수있고,서브타이핑관계를 구현할수있음(덕타이핑이나 인터페이스등)
	단 그래도 리스코프치환원칙을 준수해야 서브타이핑이라고 할수있음
	
	이때,클라관점에서 자식이 부모의 행동을 보존한다는건,
		클라가 정상적으로 메서드를 실행하기위해 만족시켜야하는 사전조건,
		메서드가 실행된후에 서버가 클라에 보장해야하는 사후조건
		메서드실행전과 실행후 인스턴스가 만족시켜야하는 클래스불변식
	에서,서브타입은 클라와 슈퍼타입간의 계약을 준수해야한다는것
	즉 오버라이딩을 하든 뭘하든간에,	
		서브타입은 슈퍼타입보다 더 강력한 사전조건을 정의할수없음(더 약한건 상관없음,어짜피 지켜질테니까)
		서브타입은 슈퍼타입보다 더 약한 사후조건을 정의할수없음(강한건 상관없음,최소조건은 넘기니까)
	를 지켜야함



14.일관성있는 협력
	비슷한 기능을 구현할땐,비슷한 협력패턴을 사용하는게 시스템을 처음보는사람이 이해하기쉬움
	즉 구현의 방식이 일관적인게,수정할떄도 그렇고 이해할때도 그렇고 좋음
	그래서 디자인패턴이 사용되는것
	기본적으론,변하는개념을 변하지않는개념으로 분리하고,변하는개념을 캡슐화한다고 생각하고있으면됨
	맨날나오는 변경의캡슐화
	
	객체지향에서는 변경을 위해 분기문대신,객체사이의 이동을 사용함
	이렇게되면 큰 클래스를 작게쪼개야하고,그 작은클래스들은 서로간에 역할이라는 추상화로 묶이고 일관성을 부여하기가 더 쉬워짐
	핵심은 훌륭한 추상화를 찾아 추상화에 의존하도록 만드는것,추상화에 대한 의존은 결합도를 낮추고 대체가능한 역할로 구성된 협력을 설계할수있게 만들어줌
	
	캡슐화는,데이터은닉만이 아닌,변경가능한 모든걸 감추는걸 말함
	대표적으로 퍼블릭인터페이스와 구현을 캡슐화,어떤객체 서브타입으로 있는지 캡슐화,데이터를 캡슐화 이런식
	일반적으로 데이터캡슐화는 기본이고,보통 인터페이스상속(서브타입캡슐화)와 합성(객체캡슐화)를 이용하는데
	변하는부분을 분리해서 타입계층을 만들고(서브타입캡슐화),변하지않는부분의 일부로 타입계층을 합성(객체캡슐화)
	이런식으로 사용함
	
	그리고 변하지않는 요소와 추상적인 요소,즉 인터페이스만 가지고도 이게 제대로 구현될지를 알수있고,
	추가적으로 변하지않는부분을 재사용할수있음,그래서 재사용성이 향상되고 테스트할코드의 양이 감소함
	이렇게 유사한기능에 대해 유사한 협력패턴을 적용하는게 일관성을 유지하는 가장 효과적인 방법임
	약간의 부조화(리스트반환인데 무조건 하나만 반환되는 메서드)를 감수해서라도 일관성을 지키는게 더 좋음
	
	그리고 일관적으로 보이는곳에 새로운 요구사항으로 도저히 구현을 못하겠으면,그걸 수용할수있는 협력패턴을 찾아서 아예 리팩토링하는게 맞음
	
	앱에서 유사한기능에 대한 변경이 지속적으로 발생하면,변경을 캡슐화하는 적절한 추상화를 찾고,거기에 변하지않는 공통적인 책임을 할당하자
	현재구조가 변경을 캡슐화하기 적당하지않으면,코드를 수정하지않아도 원하는 변경을 수용할수있게 협력과 코드를 리팩토링하자
	
15.디자인패턴과 프레임워크
	디자인패턴은,소프트웨어설계에서 반복적으로 발생하는 문제에 반복적으로 적용할수있는 해결방법
	이것의 목적은 설계를 재사용하는것,이걸배우면 변경의 방향과 주기를 이해하기만 하면,필요한역할,책임,역할의 협력방식을 바로 떠올릴수있음
	프레임워크는 설계와 코드를 함께 재사용하기 위한것
	이 두가지 모두 일관성있는 협력을 하기위한 템플릿을 제공하는게 목적이고,
	디자인패턴이 일관성있는 협력을 재사용할수있는 설계의 묶음이면,
	프레임워크는 일관성있는 협력을 제공하는 확장가능한 코드라고 할수있음
	
	패턴은
		반복적으로 발생하는 문제와 해법의 쌍으로 정의됨
		이걸로 이미 알려진문제와 거기에 대한 해법을 문서로 정리할수있고,의사소통이 편해짐
		추상적 원칙과 실제코드작성 사이의 간극을 메워줌
	즉 한컨텍스트에서 유용한 동시에 다른컨텍스트에서도 유용한 아이디어가 패턴임
	
	패턴에서 가장 중요한건 패턴의 이름임,이거로 압축된 의사소통,즉 상위레벨의 대화를 할수있음
	패턴은 공통으로 사용할수있는 역할,책임,협력의 템플릿임
	즉 패턴으로 현재상황에 적용할수있는 설계를 빠르게 떠올릴수있다는게 중요함
	이때 패턴을 구성하는 요소는 클래스가 아닌 역할임,그래서 그 역할만 만족시킬수잇으면 그패턴이라고 할수있고,그래서 다양한 구현법이 존재한다는걸 암시함
	
	패턴은 출발점이지,목적지가 아님,
	패턴으로 처음 시작할때 이런식으로 하면되겠다 라는 느낌을 주는거지,그대로 적용못할거같으면 거기서 틀어서 가야함
	무조건 패턴을 그대로 적용하려는건 패턴만능주의임
	패턴을 사용하면,복잡성이 늘어나는데,그 복잡성을 감수할만큼 유연성을 필요로할때만 사용해야하고,코드를 공유하는사람들이 해당패턴에 대해 알고있어야함
	
	
	프레임워크는,앱개발자가 현재의 요구사항에 맞게 커스터마이징할수있는 앱의 골격을 의미함
	프레임워크의 핵심은 추상화임,이것도 일관성있는 협력을 위한,의존성역전원칙을 사용하는데,아예 상위정책과 하위정책을 나누고,
	상위엔 인터페이스만 두고,하위엔 구현만 둬서 변경으로부터 지키고,더 나아가서는 상위정책만 아예 떼서 재사용을 할수도있음
	이렇게 상위정책을 재사용한다는건,결국 도메인의 핵심개념사이의 협력관계를 재사용한다는것,여기서 사용되는게 의존성역전원리고,
	프레임워크에서 의존성역전을 걸어버리면 제어흐름의 주체역시 역전됨,이걸 제어역전원리(ioc)라고 함
	
	프레임워크는 일반적해결책만 제공하고,앱에따라 달라지는동작은 비워둠,이 비워둔걸 훅이라고 부름(템플릿메서드나 전략패턴같은느낌)
	훅은 프레임워크코드에서 호출하는 프레임워크의 특정부분임
	이렇게 템플릿메서드처럼 동작하니까,제어하는건 프레임워크가 되는것,우리는 그냥 프레임워크가 저쯤실행하겠지 하는 코드를 작성할뿐임



추가1.계약에 의한 설계
	계약은,명령의 부수효과를 명확하게 표현할수있는 커뮤니케이션수단임
	이걸 사용하면 협력에 필요한 다양한 제약과 부수효과를 명시적으로 정의하고 문서화할수있음
	그리고 계약은 실행가능해서(코드상에다가 표시하니),적용됐는지를 런타임에 검증할수있어서 주석과 달리 과거주석이 남아있는 그런걸 고민안해도됨
	
	순수자바에선 기본적으로는 없고,스프링이나 jpa를 사용하면 어노테이션을 이용해서 어느정도 사용할수있음
	이걸 사용하면,클래스의 부수효과를 명시적으로 문서화하고 명확하게 커뮤니케이션 할수있을뿐아니라,실행가능한 검증도구로도 사용할수있음

	객체지향의 핵심은,협력안에서 객체들이 수행하는 행동임
	근데 인터페이스는 객체가 수신할수있는 메시지는 정의할수있어도,의사소통방식은 명확히 정의할수있음
	즉 메시지의이름,파라미터목록은 시그니처로 전달가능하지만,약속과 제약(파라미터의 값이 0이상이어야한다던가)는 전달할수없어서,
	이런것들이 암시적으로 남게됨
	이런것들을 명시적으로 파라미터에 표시하는느낌(ide자체에 표시되니까)
	
	이때 계약은,한쪽의 의무가 반대쪽의 권리가 됨
	그래서 내가 돈을 더줄수는 있고,일을 덜시킬순 있지만,돈을 덜줄수는없고,일을 더시킬순없음(사전조건,사후조건)
	여기서 조건을 명시해주는거임,조건이 만족되지않으면 해당 메서드를 호출하지못하게 하는것
	이때
		사전조건:메서드가 호출되기위해 만족되어야하는조건,메서드의 요구사항,이게만족되지않으면 메서드가 실행되면안됨,이걸만족시키는건 클라의 의무
		사후조건:메서드가 실행된후에 클라에게 보장해야하는조건,클라가 사전조건을 만족시켜서 실행시켰으면,무조건 이건 보장해줘야함,못하면 예외던져야함
		불변식:항상 참이라고 보장되는 서버의 조건,메서드가 실행되는도중에는 불변식을 만족시키지 못할수있는데,메서드가 실행전이나 후는 항상 참이어야함
	이 3가지가 계약에 의한 설계를 구성하는 요소들임
	이걸 사용하면 실행절차를 기술하지않고,상태변경만을 명시해서 코드이해와 분석이 쉬워짐
	
	시전조건은 메서드가 정상적으로 실행되기위해 만족해야하는조건임,이걸 만족시키지못하는건 클라쪽에 버그가 있다는걸 의미함
	보통 사전조건은 메서드에 전달된 인자의 정합성을 체크하기위해 사용됨(널이 아니고,0보다크고 이런거)
	이걸 만족시키지못하면 해당메서드는 실행되면안됨,만약 만족시키지못하는값으로 들어오면 최대한빨리실패해서 클라쪽으로 해당예외던져줘야함	
	이게 계약에의한설계의 장점임,계약만을 위한 표기법으로 계약을 서술해서,강조할수있고,메서드의 일부로 넣어서 계약을 강제할수있음
	
	사후조건은 메서드의 실행결과가 올바른지를 검사하고,실행후에 객체가 유효한상태로 남아있는지 검증함
	즉 사후조건으로 메서드를 호출한 후에 어떤일이 일어났는지를 설명할수있는것
	클라가 사전조건을 만족시켰는데도 서버가 사후조건을 만족시키지못하면 서버에 버그가 있는거
	사후조건은
		인스턴스변수의 상태가 올바른지 서술하기위해
		메서드에 전달된 파라미터값이 올바르게 변경됐는지 서술하기위해 
		반환값이 올바른지 서술하기위해
	사용됨
	사전조건보다 사후조건정의가 더 어려운데
		한메서드안에 리턴문이 여러개일경우,근데 보통 이런라이브러리에선 한번만 적어도 되게 해줌
		실행전과 실행후값을 비교해야하는경우,근데 보통 라이브러리에서 실행전값에 접근할수있는걸 열어줌
	같은 이유때문
	
	불변식은,인스턴스생명주기 전반에 걸쳐 지켜져야함
		불변식은 클래스의 모든인스턴스가 생성된 후 만족되어야함,즉 모든 생성자는 불변식을 준수해야함
		불변식은 클라에 의해 호출가능한 모든 메서드에 의해 준수되어야함,실행중간은 괜찮은데,전후는 항상 불변식만족이 유지되어야함
	즉 해당클래스의 모든 메서드에 사전조건과 사후조건에 추가되는 공통의 조건이라고 생각하면됨
	보통 라이브러리에선 생성자실행후,메서드실행전,메서드실행후에 이걸 호출해서 체크함
	
	이렇게 계약에의한설계를 하고,리스코프치환원칙을 지키려면 결국
		서브타입이 리스코프치환원칙을 지키려면,클라와 슈퍼타입간에 체결된 계약을 준수해야함
	이라는 조건이 생김
	이건 또 두개로 나뉘는데,협력에 참여하는 객체에 대한 기대를 표현하는 계약규칙,교체가능한타입과 관련된 가변성규칙으로 나뉨
	계약규칙은 슈퍼타입과 서브타입간의 사전,사후,불변식에 대한 제약에 대한 규칙임
		서브타입에 더 강력한 사전조건을 정의할순없음(돈덜주고 일시킬순없음,단 돈더주는건상관없음)
		서브타입에 더 완화된 사후조건을 정의할순없음(돈받고 일덜할순없음,단 일더하는건 상관없음)
		슈퍼타입의 불변식은 서브타입에서도 반드시 유지되어야함(도구를 부수면안됨)
	가변성규칙은 파라미터와 리턴타입의 변형과 관련된 규칙임
		서브타입의 메서드파라미터는 반공변성을 가져야함(슈퍼타입의 메서드파라미터를 그대로 서브타입에 넣을수있음,자바에선 허용안됨)
		서브타입의 리턴타입은 공변성을 가져야함(서브타입을 슈퍼타입 대신 사용할수있음,사실상 사후조건의 강화라고보면됨)
		서브타입은 슈퍼타입의 예외와 다른 타입의 예외를 발생시켜선안됨
	이렇게됨,즉 리스코프치환원칙으로,슈퍼타입쓰는거 그대로 서브타입을 사용할수있어야한다는거
	보통 공변,반공변이 중요해지는곳은 상속이 제네릭과 만나는지점임,
	그리고 가변성규칙보단 계약규칙이 중요하고,
	가변성규칙에선 슈퍼타입과 다른타입의예외(자식클래스예외나 이런건 ㄱㅊ)를 던지면 안된다는거만 알아둬도될듯
	
추가2.타입계층의 구현	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	




