1.객체,설계
	소프트웨어는,동작해야하고,간단히 변경되어야하고,코드를 읽는사람이 읽기쉬워야함
	
	객체는 항상 능동적이어야함
	즉,자신의 데이터를 사용해서 발생하는 행위는,객체 자기자신이 메서드로 가지고있고,
	외부는 단지 그 인터페이스를 가지고 메서드를 사용할수있을뿐이어야함(로직의 책임은 객체가 가지고,로직을 콜하는 책임만 외부가 가짐)
	이렇게되면,콜하는쪽(mvc에선 서비스)의 부담이 엄청나게 줄어들고,하위도메인의 변경점이 있더라도,상위까지 전파되지않음
	즉 세부사항에 의존하게되면,변경에 취약해지고,그냥 선언적으로 시킬수있어야함
	
	즉,알필요없는건 다 캡슐화해서 객체안에 밀어넣고,공개된 인터페이스만 사용해라,
	객체가 할수있는일까지 도맡아서 하지마라
	구현에 의존하지말고,인터페이스에 의존하라는것(강의존이 아닌 약의존으로 만들어라)
	이러려면,게터세터를 생성하지 않는것으로 좀 더 쉽게할수있음(제약을통해)
	
	이렇게,데이터와 행위를 묶어두는걸(캡술화) 일반적으로 객체지향이라고 하고,데이터와 행위가 다른모듈로 나눠진걸 절차지향이라고 함
	
	설계를 어렵게 만드는건 의존성이고,이걸 쉽게만드는법은 불필요한 의존성을 제거해서,객체사이의 결합도를 낮추는것
	이 방법으로 세부사항을 캡슐화하는것이 있음
	이러면 객체의 자율성을 높이고,객체의 응집도도 올라감
	훌륭한 객체지향은,불필요한 세부사항을  캡슐화하는 자율적인 객체들이,낮은결합도와 높은 응집도로 협력하게 최소한의 의존성만 남기는거
	
	근데 이렇게 세부사항을 캡슐화하다보면,의존성을 추가해야하는경우가 있음(보통 매개변수로 대상을 받아야할때,자율성을 높이고,결합도가 상승함)
	이런건 트레이드오프로 선택해야함

2.객체지향 프로그래밍
	만약 한곳에서 여러개중 하나를 선택해야하면,인터페이스를 구현하는방법을 선택할수있고,
	여러개중 만족하는걸 골라야하면,인터페이스에 isSupport를 넣고,불린값을 반환하게해서 여기서 해당구현체를 지원하는지를 받을수있게한다음
	List<해당인터페이스>로 구현체를 전부 받은뒤에,포이치돌려서 isSupport를 통과하는거만 걸러내면됨
	
	객체지향식으로 설계할땐,어떤 클래스가 필요한지가 아니라,어떤 객체가 필요한지부터 고민하고
	이때도 어떤 객체가 어떤 행동을 가지는지,그로인해 어떤 상태가 필요한지부터 고민해야함
	그리고,객체를 독립적인 존재가 아니라,기능을 구현하기위해 협력하는 공동체의 일원으로 봐야함
	즉,
		1.대충 여기에 무슨 도메인이 있을지를 생각한다
		2.여기에 무슨 행동이 있어야하는지를 뽑아내고(유스케이스사용),그걸 맞는 양쪽의 도메인에 붙인다
		3.모든행동들이 맞는 도메인에 들어갔으면,도메인의 필요한 상태를 추가한다
		4.공통된 특성과 상태를 가진 객체들을,타입으로 분류하고(인터페이스),이걸기반으로 클래스를 구현한다
	순서로 하면됨
	
	객체지향이 좋은게,요구사항을 분석하는 초기단계부터,프로그램구현하는 마지막까지 같은 추상화기법을 사용할수있어서임
	클래스를 구현할때 가장 중요한건,클래스의 경계를 구분짓는것
	클래스는 내부(private)와 외부(public)로 구분되며,중요한건 여기서 어떤걸 공개하고 어떤걸 감출지 결정하는것
	이래야 객체의 자율성이 보장됨,막 getter로 가져가대면 온몸이 묶여있어서 움직이기가 힘듬
	
	즉,객체는 상태와 행동을 함께 포함하는,식별가능한 단위고,여기서 상태와 행동을 묶는걸 캡슐화라고함
	이걸 돕기위해,객체지향언어들은 private같은 접근제어자를 제공함
	
	이때,외부에서 접근가능한부분을 퍼블릭인터페이스(메서드중 메시지만),외부에서 접근불가능한 private붙은걸 구현이라고 부름
	이 인터페이스와 구현의 분리가,객체지향에서 중요한 핵심원칙중 하나임
	
	
	프로그래머를,자기 안에서 클래스작성자와,클라이언트프로그래머로 나눠서 생각하면 좋음
	클래스 작성자는,새로운 데이터타입을 프로그램에 추가하고(타입의 구현),
	클라이언트프로그래머는 이 데이터타입을 사용해서 앱을 빠르고 안정적으로 구축하는것
	클래스작성자는 이때,필요한부분만 공개하고 나머지는 숨겨야함(구현은닉),그래서 클라이언트프로그래머를 걱정하지않고 막 내부를 변경할수있음
	이러면 클라이언트프로그래머입장에서도,알아야할게 줄어들게됨(변경의 파급효과 제어)
	즉,도메인클래스의 작성과,나머지부분(레포지토리,서비스,컨트롤러)을 나눠서 보면 편하다는것
	
	그리고 Long같은,기본형을 쓰는건,구현관점에서의 제약을 표현할순있는데,의미전달이 잘 안되니까,
	값이 딱 하나뿐이라고해도 값객체를 쓰는게 더 나을수도있음(money클래스같은)
	이러면 관련된로직들은 바로 표시가나고,다른곳에 중복되어 구현되는걸 방지할수있음
	이렇게 개념을 명시적으로 표현하면,전체적 설계의 명확성과 유연성이 올라감
	
	그리고 생성자의 파라미터목록으로,초기화에 필요한 정보를 전달하게 강제하는거로,올바른 상태를 가진 객체의 생성을 보장할수있음(di)
	즉 이렇게 컴파일시기엔 인터페이스에 의존하고,런타임시기엔 구현체에 의존하는식으로 의존을 분리하고,
	런타임에 생성자로 주입시켜버리는식으로 의존성을 변경할수있음
	단,이게 유연해지고 확장가능하긴한데,너무 아무데나 쓰면 이해하기가 힘드니까,이거도 트레이드오프임(현재 도메인만 보고 어떤 구현체에 의존하는지 알수없으니까)
	
	그리고 상속은,기존클래스를 기반으로 새 클래스를 쉽고 빠르게 추가할수있는데,이때 상속의 목적이 메서드나 인스턴스변수를 재사용하기위해서이면 안됨
	상속의 목적은,인터페이스를 상속받아서,내가 저기있는걸 전부 처리할수있다 라고 선언하는게 주 목적이 되어야함(자식클래스를 부모클래스로 간주할수있다)
	이래서,좀 상속을 세분화해서,인터페이스를 상속하는걸 구현(서브타이핑)으로 표현하고,구체클래스를 상속하는걸 상속(서브클래싱)이라고 말하는듯
	그래서 상속보단 구현하라는 말이 있고
	이렇게 자식클래스가 부모클래스를 대신하는걸 업캐스팅이라고 함
	
	이렇게 같은메시지를 인터페이스를 상속받은 여러타입들이 다르게 구현할수있는걸 다형성이라고 함
	그리고 이런 메시지와 메서드를 런타임시기에 바인딩하는걸 지연바인딩,혹은 동적바인딩이라고 함
	이렇게 상속을 이용하면,같은인터페이스를 공유하는 클래스들을,하나의 타입계층으로 묶을수있음
	
	단,다형성을 이루는 방법이 상속하나만 있는건 아님
	도메인의 내부에 다른객체의 인터페이스 필드를 생성하고,거기에 생성자로 di받는걸 합성이라고함(스프링 di받는거 그거임)
	즉 다른객체의 인스턴스를 자신의 인스턴스로 포함해서 재사용하는것
	
	
	상속은,단점이 두가지 있는데,
		캡슐화위반:부모클래스의 내부구조를 알아야함,특히 추상클래스일경우 더심하고(가장큰이유)
		설계유연성낮음:부모자식클래스의 관계를 컴파일시점에 결정해서,실행시점에 객체종류변경이 불가능함(솔직히 바꿀일이 글케많지않음 이건)	
	그래서 상속보단 합성하라는 말이 있는거
	즉
		상속:다형성을 위해 인터페이스를 재사용하고싶을떄 사용
		합성:외부인스턴스에 의존해야할때 사용,이러면 결합도가 낮아짐
	이렇게 사용하면됨,걍 내가 하던대로 하면됨,딱보면 감오잖아
	
3.역할,책임,협력	
	




























