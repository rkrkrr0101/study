1.객체,설계
	소프트웨어는,동작해야하고,간단히 변경되어야하고,코드를 읽는사람이 읽기쉬워야함
	
	객체는 항상 능동적이어야함
	즉,자신의 데이터를 사용해서 발생하는 행위는,객체 자기자신이 메서드로 가지고있고,
	외부는 단지 그 인터페이스를 가지고 메서드를 사용할수있을뿐이어야함(로직의 책임은 객체가 가지고,로직을 콜하는 책임만 외부가 가짐)
	이렇게되면,콜하는쪽(mvc에선 서비스)의 부담이 엄청나게 줄어들고,하위도메인의 변경점이 있더라도,상위까지 전파되지않음
	즉 세부사항에 의존하게되면,변경에 취약해지고,그냥 선언적으로 시킬수있어야함
	
	즉,알필요없는건 다 캡슐화해서 객체안에 밀어넣고,공개된 인터페이스만 사용해라,
	객체가 할수있는일까지 도맡아서 하지마라
	구현에 의존하지말고,인터페이스에 의존하라는것(강의존이 아닌 약의존으로 만들어라)
	이러려면,게터세터를 생성하지 않는것으로 좀 더 쉽게할수있음(제약을통해)
	
	이렇게,데이터와 행위를 묶어두는걸(캡술화) 일반적으로 객체지향이라고 하고,데이터와 행위가 다른모듈로 나눠진걸 절차지향이라고 함
	
	설계를 어렵게 만드는건 의존성이고,이걸 쉽게만드는법은 불필요한 의존성을 제거해서,객체사이의 결합도를 낮추는것
	이 방법으로 세부사항을 캡슐화하는것이 있음
	이러면 객체의 자율성을 높이고,객체의 응집도도 올라감
	훌륭한 객체지향은,불필요한 세부사항을  캡슐화하는 자율적인 객체들이,낮은결합도와 높은 응집도로 협력하게 최소한의 의존성만 남기는거
	
	근데 이렇게 세부사항을 캡슐화하다보면,의존성을 추가해야하는경우가 있음(보통 매개변수로 대상을 받아야할때,자율성을 높이고,결합도가 상승함)
	이런건 트레이드오프로 선택해야함

2.객체지향 프로그래밍
	만약 한곳에서 여러개중 하나를 선택해야하면,인터페이스를 구현하는방법을 선택할수있고,
	여러개중 만족하는걸 골라야하면,인터페이스에 isSupport를 넣고,불린값을 반환하게해서 여기서 해당구현체를 지원하는지를 받을수있게한다음
	List<해당인터페이스>로 구현체를 전부 받은뒤에,포이치돌려서 isSupport를 통과하는거만 걸러내면됨
	
	객체지향식으로 설계할땐,어떤 클래스가 필요한지가 아니라,어떤 객체가 필요한지부터 고민하고
	이때도 어떤 객체가 어떤 행동을 가지는지,그로인해 어떤 상태가 필요한지부터 고민해야함
	그리고,객체를 독립적인 존재가 아니라,기능을 구현하기위해 협력하는 공동체의 일원으로 봐야함
	즉,
		1.대충 여기에 무슨 도메인이 있을지를 생각한다
		2.여기에 무슨 행동이 있어야하는지를 뽑아내고(유스케이스사용),그걸 맞는 양쪽의 도메인에 붙인다
		3.모든행동들이 맞는 도메인에 들어갔으면,도메인의 필요한 상태를 추가한다
		4.공통된 특성과 상태를 가진 객체들을,타입으로 분류하고(인터페이스),이걸기반으로 클래스를 구현한다
	순서로 하면됨
	
	객체지향이 좋은게,요구사항을 분석하는 초기단계부터,프로그램구현하는 마지막까지 같은 추상화기법을 사용할수있어서임
	클래스를 구현할때 가장 중요한건,클래스의 경계를 구분짓는것
	클래스는 내부(private)와 외부(public)로 구분되며,중요한건 여기서 어떤걸 공개하고 어떤걸 감출지 결정하는것
	이래야 객체의 자율성이 보장됨,막 getter로 가져가대면 온몸이 묶여있어서 움직이기가 힘듬
	
	즉,객체는 상태와 행동을 함께 포함하는,식별가능한 단위고,여기서 상태와 행동을 묶는걸 캡슐화라고함
	이걸 돕기위해,객체지향언어들은 private같은 접근제어자를 제공함
	
	이때,외부에서 접근가능한부분을 퍼블릭인터페이스(메서드중 메시지만),외부에서 접근불가능한 private붙은걸 구현이라고 부름
	이 인터페이스와 구현의 분리가,객체지향에서 중요한 핵심원칙중 하나임
	
	
	프로그래머를,자기 안에서 클래스작성자와,클라이언트프로그래머로 나눠서 생각하면 좋음
	클래스 작성자는,새로운 데이터타입을 프로그램에 추가하고(타입의 구현),
	클라이언트프로그래머는 이 데이터타입을 사용해서 앱을 빠르고 안정적으로 구축하는것
	클래스작성자는 이때,필요한부분만 공개하고 나머지는 숨겨야함(구현은닉),그래서 클라이언트프로그래머를 걱정하지않고 막 내부를 변경할수있음
	이러면 클라이언트프로그래머입장에서도,알아야할게 줄어들게됨(변경의 파급효과 제어)
	즉,도메인클래스의 작성과,나머지부분(레포지토리,서비스,컨트롤러)을 나눠서 보면 편하다는것
	
	그리고 Long같은,기본형을 쓰는건,구현관점에서의 제약을 표현할순있는데,의미전달이 잘 안되니까,
	값이 딱 하나뿐이라고해도 값객체를 쓰는게 더 나을수도있음(money클래스같은)
	이러면 관련된로직들은 바로 표시가나고,다른곳에 중복되어 구현되는걸 방지할수있음
	이렇게 개념을 명시적으로 표현하면,전체적 설계의 명확성과 유연성이 올라감
	
	그리고 생성자의 파라미터목록으로,초기화에 필요한 정보를 전달하게 강제하는거로,올바른 상태를 가진 객체의 생성을 보장할수있음(di)
	즉 이렇게 컴파일시기엔 인터페이스에 의존하고,런타임시기엔 구현체에 의존하는식으로 의존을 분리하고,
	런타임에 생성자로 주입시켜버리는식으로 의존성을 변경할수있음
	단,이게 유연해지고 확장가능하긴한데,너무 아무데나 쓰면 이해하기가 힘드니까,이거도 트레이드오프임(현재 도메인만 보고 어떤 구현체에 의존하는지 알수없으니까)
	
	그리고 상속은,기존클래스를 기반으로 새 클래스를 쉽고 빠르게 추가할수있는데,이때 상속의 목적이 메서드나 인스턴스변수를 재사용하기위해서이면 안됨
	상속의 목적은,인터페이스를 상속받아서,내가 저기있는걸 전부 처리할수있다 라고 선언하는게 주 목적이 되어야함(자식클래스를 부모클래스로 간주할수있다)
	이래서,좀 상속을 세분화해서,인터페이스를 상속하는걸 구현(서브타이핑)으로 표현하고,구체클래스를 상속하는걸 상속(서브클래싱)이라고 말하는듯
	그래서 상속보단 구현하라는 말이 있고
	이렇게 자식클래스가 부모클래스를 대신하는걸 업캐스팅이라고 함
	
	이렇게 같은메시지를 인터페이스를 상속받은 여러타입들이 다르게 구현할수있는걸 다형성이라고 함
	그리고 이런 메시지와 메서드를 런타임시기에 바인딩하는걸 지연바인딩,혹은 동적바인딩이라고 함
	이렇게 상속을 이용하면,같은인터페이스를 공유하는 클래스들을,하나의 타입계층으로 묶을수있음
	
	단,다형성을 이루는 방법이 상속하나만 있는건 아님
	도메인의 내부에 다른객체의 인터페이스 필드를 생성하고,거기에 생성자로 di받는걸 합성이라고함(스프링 di받는거 그거임)
	즉 다른객체의 인스턴스를 자신의 인스턴스로 포함해서 재사용하는것
	
	
	상속은,단점이 두가지 있는데,
		캡슐화위반:부모클래스의 내부구조를 알아야함,특히 추상클래스일경우 더심하고(가장큰이유)
		설계유연성낮음:부모자식클래스의 관계를 컴파일시점에 결정해서,실행시점에 객체종류변경이 불가능함(솔직히 바꿀일이 글케많지않음 이건)	
	그래서 상속보단 합성하라는 말이 있는거
	즉
		상속:다형성을 위해 인터페이스를 재사용하고싶을떄 사용
		합성:외부인스턴스에 의존해야할때 사용,이러면 결합도가 낮아짐
	이렇게 사용하면됨,걍 내가 하던대로 하면됨,딱보면 감오잖아
	일반화-특수화할땐 상속을 사용하고,집합을 시킬땐 합성을 사용하는거
	이렇게 합성을 사용하면,캡슐화를 더 잘할수있다는 장점이 있음,메시지만 알면되니까
	
3.역할,책임,협력	
	객체지향의본질은,협력하는 객체들의 공동체를 창조하는것
	즉,어떤 기능에 대해 어떤 협력이 필요하고,여기에 어떤 역할과 책임이 필요한지를 고민하지않고 구현부터하면,
	변경하기어렵고 유연하지못한 코드가 나타남

	객체들끼리의 협력은,메시지전송이라는 단 하나의 수단으로만 할수있고,협력은 객체지향에서 기능을 구현하는 단 하나의 방법임
	이때 메시지를 수신한 객체는 메서드를 실행하는데,여기서 객체가 메시지를 처리할방법을 스스로 선택한다는게 중요함(자율적인존재라는걸 의미)
	언어에따라 여기서 메서드를 선택하는것도 가능하기때문
	
	객체에서 행동이 존재하는이유는,그 객체가 협력에서 해당 행동을 필요로하기때문
	협력은 객체가 존재하는이유와,수행하는하는 행동의 동기를 제공해야함
	
	
	책임은,객체에 의해 정의되는,응집도있는 행위의 집합임
	객체가 유지해야하는 정보(상태)와 수행할수있는 행동들이라고 보면됨
	이건 크게 하는것과 아는것으로 나눠짐
	하는것은
		객체를 생성하거나 계산을 수행하는것
		다른객체의 행동을 시작시키는것
		다른객체의 활동을 제어하고 조절하는것(파라미터로)
	아는것은
		사적인(private)정보에 대해 아는것
		관련된객체에 대해 아는것
		자신이 뭘 유도하거나 계산할수있는지 아는것
	이렇게됨
	즉 하는것을 수행하기위해,자기밑으로 객체를 인스턴스로 가지는것
	책임과 메시지의 크기는 다름,책임이 메시지보다 더 커서,
	한책임이 여러메시지로 분할되기도 하고그럼(예매한다는 책임이 결제정보계산,그시간에 시간있는지 계산 이렇게 나뉘는거처럼)
	
	여기서 중요한건,책임의 관점에서,아는것과 하는것은 밀접하게 연관되어있다는것
	객체는 자신이 맡은 행동을 수행할때  필요한 정보를 알고있을 책임이 있고,자기가 할수없는 작업을 대신해줄 객체를 알고있을 책임이 있음
	이게 객체에 책임을 할당할때의,가장 기본적인 힌트임
	이렇게 객체지향설계에서 가장 중요한건 책임임
	
	이렇게 자율적인 객체를 만드는 가장 기본적인방법은,책임을 수행하는데 있어서 필요한 정보를 가장 잘알고있는 객체에게 그 책임을 할당하는것임
	즉,메시지를 먼저 생성하고,거기서 그걸 처리할수있는 적절한 객체에 할당하는식임
	또 그 객체가 해당행동을 수행할수있는 모든걸 알지못한다면,다시 메시지를 생성해서 다른객체에 할당하는식으로,자기내부에서 끝날때까지 체인을 타는것
	이렇게 결정된 메시지가,객체의 퍼블릭인터페이스를 구성하게되는것
	물론 가끔은,이렇게 가장 잘아는애가 아닌,다른애한테 시켜야할수도있음(응집도와 결합도관점에서)
	이렇게 설계하는게,책임주도설계(rdd)임
	즉
		시스템이 사용자에게 제공해야하는 기능(시스템책임)을 파악
		시스템책임을 더작은책임으로 분할
		분할된책임을 수행할수있는 적절한 객체 혹은 역할에 책임을 할당함
		해당객체가 책임을 수행하는도중,다른객체의 도움이 필요할경우 이를 책임질 적절한 객체 혹은 역할을 찾음
		그 객체에게 책임을 할당함으로써,두객체는 협력하게됨
	이런순서로 모든 기능을 분배하는거임
	
	이때 중요한건,객체에게 책임을 할당할때,메시지부터 정하고 여기에 맞는 객체를 선택하는거임
	즉 객체가 메시지를 선택하는게 아니라,메시지가 객체를 선택하는것
	이러면
		객체가 최소한의 인터페이스를 갖게됨
		객체는 충분히 추상적인 인터페이스를 갖게됨(뭘하는진 표현되지만,어떻게하는진 표현안되게)
	그리고,상태의 존재이유는,단순히 행동에 필요한것들임
	즉 행동을 보고 상태가 생기는것(책임->행동->상태)

	
	객체가 어떤 특정한 협력안에서,수행되는 책임의 집합을 역할이라고 부름
	실제로 협력을 모델링할땐,특정객체가 아닌,역할에 책임을 할당한다고 생각하는게좋음
	즉,책임을 할당할때도 해당 책임을 수행할수있는 역할을 찾고,거기서 역할을 수행할 인스턴스를 찾는것
	일반적으로 인터페이스(추상클래스도 가능)를 선택하고,구현체를 선택한다고 생각하면됨
	이렇게 추상화를 해야, 좀 더 유연하게 설계가 나옴
	
	이렇게 역할은 객체가 참여할수있는 일종의 슬롯임,이때 후보가 딱 하나뿐일경우에는 역할과 객체가 합쳐져서 그냥 객체가 됨
	즉,구현체가 하나밖에없을떄,인터페이스를 안만드는 그런느낌
	
	근데 설계초반엔,이걸 막 칼같이구분할필요는 없고,대충 던져놓고 거기서 분할이 필요해지면 인터페이스로 잡고 밑으로 내리는식으로 하면될듯
	중요한건 책임이니까
	
	이렇게 추상화를 하면,
		세부사항에 억눌리지않고 상위수준정책만들기가 쉽고,세부사항을 생략하고 핵심개념을 표현할수있음
		설계가 유연해짐(슬롯개념이 생기면서 대체가 편해짐)
	이런 장점이 있음
	
	그리고 한 객체가 여러 협력을 할수도있는데,이럴경우 각 협력에 따라 하나의 역할만 보여지게됨(여러인터페이스를 구현해도 하나의 인터페이스만 보여짐)



4.설계품질과 트레이드오프
	이 객체가 포함해야 하는 데이터는 무엇인가?이런 질문이 객체책임을 정하기도전에 계속 떠오르면,데이터중심설계를 하고있는거임
	특히 객체의 종류를 저장하는 인스턴스변수와,인스턴스의 종류에 따라 배타적으로 사용될 인스턴스변수가 하나의 클래스에 있는게 대표적패턴
	그리고 getter,setter이 있으면,그냥 캡슐화가 안된거임,결국 public로 풀려있는거랑 다른게없으니

	이 데이터중심설계의 단점은,
		캡슐화하기가 힘들고(객체자체가 수동적일 확률이 높으니 캡슐화도 덩달아서 힘들어짐)
		결합도가 높고(하나건드리면 다건드려야함)
		응집도가 낮음
	이건,객체가 수행할 책임이 아닌,데이터에 초점이 맞춰지기때문에 어쩔수없게됨
	이렇게 설계할때 협력에 관해 고민하지않으면,과도한 setter,getter이 생기는 경향이 있음
	이건 개발자가 객체가 사용될 문맥을 추측할수밖에 없어서 이렇게되는거
	이러면 대부분의 내부구현이 퍼블릭인터페이스에 노출되고,그 결과 캡슐화를 위반하는 변경에 취약한 설계가 나오게됨
	이렇게되면 객체를 사용하는 클라이언트들이,내부구현에 강결합하게되고 그래서 내부구현을 변경했는데 다른것도 함께 변경해야하게됨(제어객체도 같이바꿔야함)
	
	응집도가 낮으면,한 객체를 수정하는 이유가 여러개가 되기때문에,전혀 다른이유로 수정했는데,바꾸지않아도 되는거까지 영향을 받게되고,
	하나의 요구사항을 변경하기위해,동시에 여러 모듈을 수정해야함(응집도가낮아서 결합도가 높아짐)
	이래서 단일책임원칙이 나온거
	이런거의 특징은,객체내부에서 처리할수있는것도 다 외부에 모듈이 있어서,그 모듈을 여러객체가 의존하고..이렇게 되버림
	즉 수동적인 객체가 나오고,게터세터가 많고 이런 특징이 있음
	
	그래서 객체의 상태는,이 객체가 어떤 데이터를포함해야하는가+이 객체가 데이터에 대해 수행해야하는 행동이 뭔가 이렇게 두개로 나눠서생각해야함
	
	그리고 퍼블릭인터페이스엔,해당 객체가 어떻게 구현되었는지를 추론할수있을만한 힌트도 남겨선안됨
	이러면 캡슐화가 반쯤실패한거
	즉,좀더 전역적인거로 dto받는거처럼 받아서 내부에서 바꾸는식으로 하는게 더 나을듯

	이렇게 데이터중심설계는,
		너무 이른시기에 데이터에 대해 결정하는걸 강요하고
		협력이라는 문맥을 고려하지않고,객체를 고립시킨채 행동을 결정함(객체의 행동이 정해진상태로,협력에 끼워맞추게됨)
	즉 행동보단 상태에 중점을 맞추는게 제일 큰 원인임


5.책임 할당하기







