1.객체,설계
	소프트웨어는,동작해야하고,간단히 변경되어야하고,코드를 읽는사람이 읽기쉬워야함
	
	객체는 항상 능동적이어야함
	즉,자신의 데이터를 사용해서 발생하는 행위는,객체 자기자신이 메서드로 가지고있고,
	외부는 단지 그 인터페이스를 가지고 메서드를 사용할수있을뿐이어야함(로직의 책임은 객체가 가지고,로직을 콜하는 책임만 외부가 가짐)
	이렇게되면,콜하는쪽(mvc에선 서비스)의 부담이 엄청나게 줄어들고,하위도메인의 변경점이 있더라도,상위까지 전파되지않음
	즉 세부사항에 의존하게되면,변경에 취약해지고,그냥 선언적으로 시킬수있어야함
	
	즉,알필요없는건 다 캡슐화해서 객체안에 밀어넣고,공개된 인터페이스만 사용해라,
	객체가 할수있는일까지 도맡아서 하지마라
	구현에 의존하지말고,인터페이스에 의존하라는것(강의존이 아닌 약의존으로 만들어라)
	이러려면,게터세터를 생성하지 않는것으로 좀 더 쉽게할수있음(제약을통해)
	
	이렇게,데이터와 행위를 묶어두는걸(캡술화) 일반적으로 객체지향이라고 하고,데이터와 행위가 다른모듈로 나눠진걸 절차지향이라고 함
	
	설계를 어렵게 만드는건 의존성이고,이걸 쉽게만드는법은 불필요한 의존성을 제거해서,객체사이의 결합도를 낮추는것
	이 방법으로 세부사항을 캡슐화하는것이 있음
	이러면 객체의 자율성을 높이고,객체의 응집도도 올라감
	훌륭한 객체지향은,불필요한 세부사항을  캡슐화하는 자율적인 객체들이,낮은결합도와 높은 응집도로 협력하게 최소한의 의존성만 남기는거
	
	근데 이렇게 세부사항을 캡슐화하다보면,의존성을 추가해야하는경우가 있음(보통 매개변수로 대상을 받아야할때,자율성을 높이고,결합도가 상승함)
	이런건 트레이드오프로 선택해야함

2.객체지향 프로그래밍
	만약 한곳에서 여러개중 하나를 선택해야하면,인터페이스를 구현하는방법을 선택할수있고,
	여러개중 만족하는걸 골라야하면,인터페이스에 isSupport를 넣고,불린값을 반환하게해서 여기서 해당구현체를 지원하는지를 받을수있게한다음
	List<해당인터페이스>로 구현체를 전부 받은뒤에,포이치돌려서 isSupport를 통과하는거만 걸러내면됨
	
	객체지향식으로 설계할땐,어떤 클래스가 필요한지가 아니라,어떤 객체가 필요한지부터 고민하고
	이때도 어떤 객체가 어떤 행동을 가지는지,그로인해 어떤 상태가 필요한지부터 고민해야함
	그리고,객체를 독립적인 존재가 아니라,기능을 구현하기위해 협력하는 공동체의 일원으로 봐야함
	즉,
		1.대충 여기에 무슨 도메인이 있을지를 생각한다
		2.여기에 무슨 행동이 있어야하는지를 뽑아내고(유스케이스사용),그걸 맞는 양쪽의 도메인에 붙인다
		3.모든행동들이 맞는 도메인에 들어갔으면,도메인의 필요한 상태를 추가한다
		4.공통된 특성과 상태를 가진 객체들을,타입으로 분류하고(인터페이스),이걸기반으로 클래스를 구현한다
	순서로 하면됨
	
	객체지향이 좋은게,요구사항을 분석하는 초기단계부터,프로그램구현하는 마지막까지 같은 추상화기법을 사용할수있어서임
	클래스를 구현할때 가장 중요한건,클래스의 경계를 구분짓는것
	클래스는 내부(private)와 외부(public)로 구분되며,중요한건 여기서 어떤걸 공개하고 어떤걸 감출지 결정하는것
	이래야 객체의 자율성이 보장됨,막 getter로 가져가대면 온몸이 묶여있어서 움직이기가 힘듬
	
	즉,객체는 상태와 행동을 함께 포함하는,식별가능한 단위고,여기서 상태와 행동을 묶는걸 캡슐화라고함
	이걸 돕기위해,객체지향언어들은 private같은 접근제어자를 제공함
	
	이때,외부에서 접근가능한부분을 퍼블릭인터페이스(메서드중 메시지만),외부에서 접근불가능한 private붙은걸 구현이라고 부름
	이 인터페이스와 구현의 분리가,객체지향에서 중요한 핵심원칙중 하나임
	
	
	프로그래머를,자기 안에서 클래스작성자와,클라이언트프로그래머로 나눠서 생각하면 좋음
	클래스 작성자는,새로운 데이터타입을 프로그램에 추가하고(타입의 구현),
	클라이언트프로그래머는 이 데이터타입을 사용해서 앱을 빠르고 안정적으로 구축하는것
	클래스작성자는 이때,필요한부분만 공개하고 나머지는 숨겨야함(구현은닉),그래서 클라이언트프로그래머를 걱정하지않고 막 내부를 변경할수있음
	이러면 클라이언트프로그래머입장에서도,알아야할게 줄어들게됨(변경의 파급효과 제어)
	즉,도메인클래스의 작성과,나머지부분(레포지토리,서비스,컨트롤러)을 나눠서 보면 편하다는것
	
	그리고 Long같은,기본형을 쓰는건,구현관점에서의 제약을 표현할순있는데,의미전달이 잘 안되니까,
	값이 딱 하나뿐이라고해도 값객체를 쓰는게 더 나을수도있음(money클래스같은)
	이러면 관련된로직들은 바로 표시가나고,다른곳에 중복되어 구현되는걸 방지할수있음
	이렇게 개념을 명시적으로 표현하면,전체적 설계의 명확성과 유연성이 올라감
	
	그리고 생성자의 파라미터목록으로,초기화에 필요한 정보를 전달하게 강제하는거로,올바른 상태를 가진 객체의 생성을 보장할수있음(di)
	즉 이렇게 컴파일시기엔 인터페이스에 의존하고,런타임시기엔 구현체에 의존하는식으로 의존을 분리하고,
	런타임에 생성자로 주입시켜버리는식으로 의존성을 변경할수있음
	단,이게 유연해지고 확장가능하긴한데,너무 아무데나 쓰면 이해하기가 힘드니까,이거도 트레이드오프임(현재 도메인만 보고 어떤 구현체에 의존하는지 알수없으니까)
	
	그리고 상속은,기존클래스를 기반으로 새 클래스를 쉽고 빠르게 추가할수있는데,이때 상속의 목적이 메서드나 인스턴스변수를 재사용하기위해서이면 안됨
	상속의 목적은,인터페이스를 상속받아서,내가 저기있는걸 전부 처리할수있다 라고 선언하는게 주 목적이 되어야함(자식클래스를 부모클래스로 간주할수있다)
	이래서,좀 상속을 세분화해서,인터페이스를 상속하는걸 구현(서브타이핑)으로 표현하고,구체클래스를 상속하는걸 상속(서브클래싱)이라고 말하는듯
	그래서 상속보단 구현하라는 말이 있고
	이렇게 자식클래스가 부모클래스를 대신하는걸 업캐스팅이라고 함
	
	이렇게 같은메시지를 인터페이스를 상속받은 여러타입들이 다르게 구현할수있는걸 다형성이라고 함
	그리고 이런 메시지와 메서드를 런타임시기에 바인딩하는걸 지연바인딩,혹은 동적바인딩이라고 함
	이렇게 상속을 이용하면,같은인터페이스를 공유하는 클래스들을,하나의 타입계층으로 묶을수있음
	
	단,다형성을 이루는 방법이 상속하나만 있는건 아님
	도메인의 내부에 다른객체의 인터페이스 필드를 생성하고,거기에 생성자로 di받는걸 합성이라고함(스프링 di받는거 그거임)
	즉 다른객체의 인스턴스를 자신의 인스턴스로 포함해서 재사용하는것
	
	
	상속은,단점이 두가지 있는데,
		캡슐화위반:부모클래스의 내부구조를 알아야함,특히 추상클래스일경우 더심하고(가장큰이유)
		설계유연성낮음:부모자식클래스의 관계를 컴파일시점에 결정해서,실행시점에 객체종류변경이 불가능함(솔직히 바꿀일이 글케많지않음 이건)	
	그래서 상속보단 합성하라는 말이 있는거
	즉
		상속:다형성을 위해 인터페이스를 재사용하고싶을떄 사용
		합성:외부인스턴스에 의존해야할때 사용,이러면 결합도가 낮아짐
	이렇게 사용하면됨,걍 내가 하던대로 하면됨,딱보면 감오잖아
	일반화-특수화할땐 상속을 사용하고,집합을 시킬땐 합성을 사용하는거
	이렇게 합성을 사용하면,캡슐화를 더 잘할수있다는 장점이 있음,메시지만 알면되니까
	
3.역할,책임,협력	
	객체지향의본질은,협력하는 객체들의 공동체를 창조하는것
	즉,어떤 기능에 대해 어떤 협력이 필요하고,여기에 어떤 역할과 책임이 필요한지를 고민하지않고 구현부터하면,
	변경하기어렵고 유연하지못한 코드가 나타남

	객체들끼리의 협력은,메시지전송이라는 단 하나의 수단으로만 할수있고,협력은 객체지향에서 기능을 구현하는 단 하나의 방법임
	이때 메시지를 수신한 객체는 메서드를 실행하는데,여기서 객체가 메시지를 처리할방법을 스스로 선택한다는게 중요함(자율적인존재라는걸 의미)
	언어에따라 여기서 메서드를 선택하는것도 가능하기때문
	
	객체에서 행동이 존재하는이유는,그 객체가 협력에서 해당 행동을 필요로하기때문
	협력은 객체가 존재하는이유와,수행하는하는 행동의 동기를 제공해야함
	
	
	책임은,객체에 의해 정의되는,응집도있는 행위의 집합임
	객체가 유지해야하는 정보(상태)와 수행할수있는 행동들이라고 보면됨
	이건 크게 하는것과 아는것으로 나눠짐
	하는것은
		객체를 생성하거나 계산을 수행하는것
		다른객체의 행동을 시작시키는것
		다른객체의 활동을 제어하고 조절하는것(파라미터로)
	아는것은
		사적인(private)정보에 대해 아는것
		관련된객체에 대해 아는것
		자신이 뭘 유도하거나 계산할수있는지 아는것
	이렇게됨
	즉 하는것을 수행하기위해,자기밑으로 객체를 인스턴스로 가지는것
	책임과 메시지의 크기는 다름,책임이 메시지보다 더 커서,
	한책임이 여러메시지로 분할되기도 하고그럼(예매한다는 책임이 결제정보계산,그시간에 시간있는지 계산 이렇게 나뉘는거처럼)
	
	여기서 중요한건,책임의 관점에서,아는것과 하는것은 밀접하게 연관되어있다는것
	객체는 자신이 맡은 행동을 수행할때  필요한 정보를 알고있을 책임이 있고,자기가 할수없는 작업을 대신해줄 객체를 알고있을 책임이 있음
	이게 객체에 책임을 할당할때의,가장 기본적인 힌트임
	이렇게 객체지향설계에서 가장 중요한건 책임임
	
	이렇게 자율적인 객체를 만드는 가장 기본적인방법은,책임을 수행하는데 있어서 필요한 정보를 가장 잘알고있는 객체에게 그 책임을 할당하는것임
	즉,메시지를 먼저 생성하고,거기서 그걸 처리할수있는 적절한 객체에 할당하는식임
	또 그 객체가 해당행동을 수행할수있는 모든걸 알지못한다면,다시 메시지를 생성해서 다른객체에 할당하는식으로,자기내부에서 끝날때까지 체인을 타는것
	이렇게 결정된 메시지가,객체의 퍼블릭인터페이스를 구성하게되는것
	물론 가끔은,이렇게 가장 잘아는애가 아닌,다른애한테 시켜야할수도있음(응집도와 결합도관점에서)
	이렇게 설계하는게,책임주도설계(rdd)임
	즉
		시스템이 사용자에게 제공해야하는 기능(시스템책임)을 파악
		시스템책임을 더작은책임으로 분할
		분할된책임을 수행할수있는 적절한 객체 혹은 역할에 책임을 할당함
		해당객체가 책임을 수행하는도중,다른객체의 도움이 필요할경우 이를 책임질 적절한 객체 혹은 역할을 찾음
		그 객체에게 책임을 할당함으로써,두객체는 협력하게됨
	이런순서로 모든 기능을 분배하는거임
	
	이때 중요한건,객체에게 책임을 할당할때,메시지부터 정하고 여기에 맞는 객체를 선택하는거임
	즉 객체가 메시지를 선택하는게 아니라,메시지가 객체를 선택하는것
	이러면
		객체가 최소한의 인터페이스를 갖게됨
		객체는 충분히 추상적인 인터페이스를 갖게됨(뭘하는진 표현되지만,어떻게하는진 표현안되게)
	그리고,상태의 존재이유는,단순히 행동에 필요한것들임
	즉 행동을 보고 상태가 생기는것(책임->행동->상태)

	
	객체가 어떤 특정한 협력안에서,수행되는 책임의 집합을 역할이라고 부름
	실제로 협력을 모델링할땐,특정객체가 아닌,역할에 책임을 할당한다고 생각하는게좋음
	즉,책임을 할당할때도 해당 책임을 수행할수있는 역할을 찾고,거기서 역할을 수행할 인스턴스를 찾는것
	일반적으로 인터페이스(추상클래스도 가능)를 선택하고,구현체를 선택한다고 생각하면됨
	이렇게 추상화를 해야, 좀 더 유연하게 설계가 나옴
	
	이렇게 역할은 객체가 참여할수있는 일종의 슬롯임,이때 후보가 딱 하나뿐일경우에는 역할과 객체가 합쳐져서 그냥 객체가 됨
	즉,구현체가 하나밖에없을떄,인터페이스를 안만드는 그런느낌
	
	근데 설계초반엔,이걸 막 칼같이구분할필요는 없고,대충 던져놓고 거기서 분할이 필요해지면 인터페이스로 잡고 밑으로 내리는식으로 하면될듯
	중요한건 책임이니까
	
	이렇게 추상화를 하면,
		세부사항에 억눌리지않고 상위수준정책만들기가 쉽고,세부사항을 생략하고 핵심개념을 표현할수있음
		설계가 유연해짐(슬롯개념이 생기면서 대체가 편해짐)
	이런 장점이 있음
	
	그리고 한 객체가 여러 협력을 할수도있는데,이럴경우 각 협력에 따라 하나의 역할만 보여지게됨(여러인터페이스를 구현해도 하나의 인터페이스만 보여짐)



4.설계품질과 트레이드오프
	이 객체가 포함해야 하는 데이터는 무엇인가?이런 질문이 객체책임을 정하기도전에 계속 떠오르면,데이터중심설계를 하고있는거임
	특히 객체의 종류를 저장하는 인스턴스변수와,인스턴스의 종류에 따라 배타적으로 사용될 인스턴스변수가 하나의 클래스에 있는게 대표적패턴
	그리고 getter,setter이 있으면,그냥 캡슐화가 안된거임,결국 public로 풀려있는거랑 다른게없으니

	이 데이터중심설계의 단점은,
		캡슐화하기가 힘들고(객체자체가 수동적일 확률이 높으니 캡슐화도 덩달아서 힘들어짐)
		결합도가 높고(하나건드리면 다건드려야함)
		응집도가 낮음
	이건,객체가 수행할 책임이 아닌,데이터에 초점이 맞춰지기때문에 어쩔수없게됨
	이렇게 설계할때 협력에 관해 고민하지않으면,과도한 setter,getter이 생기는 경향이 있음
	이건 개발자가 객체가 사용될 문맥을 추측할수밖에 없어서 이렇게되는거
	이러면 대부분의 내부구현이 퍼블릭인터페이스에 노출되고,그 결과 캡슐화를 위반하는 변경에 취약한 설계가 나오게됨
	이렇게되면 객체를 사용하는 클라이언트들이,내부구현에 강결합하게되고 그래서 내부구현을 변경했는데 다른것도 함께 변경해야하게됨(제어객체도 같이바꿔야함)
	
	응집도가 낮으면,한 객체를 수정하는 이유가 여러개가 되기때문에,전혀 다른이유로 수정했는데,바꾸지않아도 되는거까지 영향을 받게되고,
	하나의 요구사항을 변경하기위해,동시에 여러 모듈을 수정해야함(응집도가낮아서 결합도가 높아짐)
	이래서 단일책임원칙이 나온거
	이런거의 특징은,객체내부에서 처리할수있는것도 다 외부에 모듈이 있어서,그 모듈을 여러객체가 의존하고..이렇게 되버림
	즉 수동적인 객체가 나오고,게터세터가 많고 이런 특징이 있음
	
	그래서 객체의 상태는,이 객체가 어떤 데이터를포함해야하는가+이 객체가 데이터에 대해 수행해야하는 행동이 뭔가 이렇게 두개로 나눠서생각해야함
	
	그리고 퍼블릭인터페이스엔,해당 객체가 어떻게 구현되었는지를 추론할수있을만한 힌트도 남겨선안됨
	이러면 캡슐화가 반쯤실패한거
	즉,좀더 전역적인거로 dto받는거처럼 받아서 내부에서 바꾸는식으로 하는게 더 나을듯

	이렇게 데이터중심설계는,
		너무 이른시기에 데이터에 대해 결정하는걸 강요하고
		협력이라는 문맥을 고려하지않고,객체를 고립시킨채 행동을 결정함(객체의 행동이 정해진상태로,협력에 끼워맞추게됨)
	즉 행동보단 상태에 중점을 맞추는게 제일 큰 원인임


5.책임 할당하기
	책임에 초점을 맞춰서 설계할때 어려운건,어떤객체에 어떤책임을 할당할지 결정하기 어렵다는것
	이건 본질적으로 트레이드오프라서,하나의 문제에 대한 여러 해결법이 존재함
	그래서 기본적인 가이드가 있는데,이게 grasp패턴임
	
	객체에 할당된 책임의 품질은 협력에 적합한 정도로 결정됨
	객체에게 할당된 책임이 협력에 어울리지않으면,그책임은 나쁜것임
	그래서 객체에게 그 책임이 좀 어색해보여도,협력에 적합하면 그 책임은 좋은것
	즉 책임은 객체의 입장이 아닌,객체가 참여하는 협력에 적합해야함
	그래서 메시지를 결정한 후 객체를 선택해야하는것
	
	설계를 시작할땐,개념들의 의미와 관계가 정확할필요없음,단지 출발점이 필요하고,객체들이 대충 뭐뭐가있을지,어떻게 연관될지 감만 잡히면됨
	grasp패턴은
		앱이 제공해야하는 기능을 앱에 대한 책임으로 생각
		해당 책임을 책임질 첫번째 객체를 선택(자신안에 해당행동에 대한 정보가 제일많은애,참조로 인한 정보도 포함임)
		해당 객체가 할수있는일과 할수없는일을 대략적으로 판단하고,할수없는일이 있으면 메시지를 생성
		해당메시지에 대해 다음객체를 선택
	이걸 반복하면됨
	그리고 이때,여러설계중에 하나를 선택해야할수있는데(본질적으로 설계의 가짓수는 무한하니까),이때 손실함수가 되어주는게 낮은결합도패턴과 높은응집도패턴임
	낮은결합도패턴은,어떻게하면 의존성을 낮출지,최대한 의존성이 적어지는쪽으로 책임을 할당하라는것
	높은응집도패턴은,같은책임이 이미 있는쪽에 책임을 할당하라는것,즉 한 객체가 가지는 책임의 가짓수가,최대한 추가가 적은쪽으로 책임을 할당하라는것임
	그리고 행동에 대한 결과물로 객체가 나올때,객체를 생성할 책임은,
		해당 객체를 포함하거나 참조하는 객체
		해당 객체를 기록하는 객체
		해당 객체를 긴밀하게 사용하는 객체
		해당 객체를 초기화하는데 필요한 데이터가 있는 객체
	이것들을 가장 많이 가지고있는 객체가 생성하면됨,그 객체는 이미 결합되어있기때문에,결합도에 영향을 주지않음
	
	
	이렇게 대충 밑그림을 그리고나면,실제로 구현을 해서 돌려보면,문제있는부분을 알수있게됨
	행동이 결정되었으니,행동에 필요한 상태를 넣어주면됨
	해당객체가 메시지를 전송해야하는 객체는 합성으로 가지고있고,필요한 정보들도 인스턴스변수로 넣어두고 하는식(생성자로 주입하면되니까)
	그리고 메시지는,수신자의 입장이 아닌,송신자의 의도만 가지고 이름이 나와야함
	이렇게 만들어보면 또 문제점이 나오는데,
	변경에 취약한 클래스를 포함하고있음->추상화로 해결할수있으면 추상화(이러면 응집도 따라 별개의 구현으로 가니까 응집도도 올라감)
		이렇게 설계를 개선할땐,
		변경의 이유가 하나 이상인 클래스를 찾는거로 시작하는게 좋음
			이건 인스턴스가 생성될때 인스턴스변수가 전부 같이 초기화되는지,일부는 남아있는지 확인,
				이때 같이 초기화되는 속성을 기준으로 코드를 분리할수있음
			메서드들이 인스턴스변수를 사용하는걸 확인
				모든메서드가 모든 인스턴스변수를 사용한다면,응집도는 높고,메서드들이 사용하는속성에 따라 그룹이 나뉘면,
				속성그룹과,해당 속성그룹에 접근하는 메서드그룹을 기준으로분리할수있음
		타입분리하기,두개의 독립적인 타입이 하나의 클래스에서 공존할경우,추상화를 통해 해결	
	이렇게 응집도가 올라가면,각 객체가 바뀌어야하는 이유가 하나가 되고,이렇게되면 캡슐화가 일어난것
	
	설계에서 제일 중요한건 변경임,이거에 대비하는방법으론,
	변경이 쉽게 설계를 잘하는 기본적인것과,
	코드를 수정하지않고도 변경을 수용할수있게 코드를 더 유연하게 만드는것
	이렇게 코드를 유연하게만드는건,복잡성이 상승한다는 단점이 있긴하지만,유사한변경이 반복적으로 발생한다면 그걸 감수할 가치가 있음
	이런 방식의 대표적인게 합성임,상속대신 합성을 쓰면,복잡성이 약간 상승하고,유연성이 많이 올라감
	
	이런 책임주도설계가 어려우면,대안이 있는데,
	코드를 작성하고 코드상에 명확히 나타나는책임을 올바른위치로 이동시킴(이떄 코드를 수정해도,겉으로 드러나는 동작이 바뀌면안됨,캡슐화)//리팩토링
		1.메서드응집도를 바탕으로,메서드를 쪼개고,한메서드에 하나의 일만 하게 만들기(메서드는 최대한 짧게,주석을 쓰지않게,클래스는 길어져도됨)
		2.쪼개진 메서드를 가지고,적절한 클래스로 이동시키기
			이때 자신이 소유한 데이터는 자신이 처리하게 만드는,즉,객체를 자율적으로 만들면됨
			이건 리팩토링 전 코드가 getter를 사용하고있을때,해당객체로 넘겨버리는식임
	이런식으로 하는방법도있음











































