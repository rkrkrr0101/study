1.배민다움 만들기
  스킵?
  mr관련
    머지 리퀘스트(mr) 템플릿 만들면 작성이 편함
    mr은 삭제포함 300줄 미만
    하나의 티켓에서 여러mr을 만들어도됨 
    리팩터링은 분리

  문화
    무엇을 하는지를 적는 주석은 좋지않지만,왜하는지를 적는 주석은 괜찮음
	그것보다 더 좋은건 테스트코드를 명확하게 작성하고 설명에 이유를 적어두는것

2.프론트엔드 개발자로 성장하기 
  스킵

3.백엔드 개발자로 성장하기
  1.개발자 머피의 법칙
    어떤일을 하는데 두가지 이상의 방법이 있고,그중 하나가 나쁜결과를 불러오면 누군가는 꼭 그걸 사용함
	즉 잘못되는건 꼭 잘못되기 마련임
	
	1.사용자의 입력은 반드시 검증한다
	  뷰를 어떻게 만들어뒀든 사용자의 모든 입력은 반드시 검증해야함
	  ui단에서 검증하는건 단순한 편의목적이고,반드시 서버에서 올바른범위의 값인지를 무조건 검증해야함
	  즉 클라에서 검증한건 검증하지않은거임
	  보통 배송일입력같은 날짜에서 이런문제가 생기기쉬윔
	  
	  그리고 모든 계산은 클라가 아닌 서버에서 해야함
	  안그러면 값바꿔치기에 매우 취약함
	  클라계산은 단순히 편의성을 전달하기위한 목적이어야함(즉 최종결과는 서버에서 재계산해야함)
	  
	  사용자의 요청에 의해 쿼리의 모든 조건이 사라지면 안됨
	  queryDSL이나 이런거 쓸때 주의해야하는건데,동적쿼리에서 모든 조건이 동시에 절대 사라지면 안되고,이걸 반드시 검증해야함
	  즉 배타적인 조회조건을 사용할때,두 조건중 하나 이상이 요청매개변수에 존재하는지를 항상 검증해야함
	  또한 사내api에서도 반드시 검증해야하고,페이징사이즈같은것도 일정이상 못넘어가게 막아야함
	
	2.성능측정없는 캐시사용은 성능을 저하시킬수있다
	  레디스같은 원격분산캐시를 사용할때 주의점은,얘들은 네트워크대역폭을 먹고살아서 캐시에 너무 많은 데이터를 담으면 캐시히트율이 높아도 대역폭떔에 느려짐
	  그래서 실제 운영서비스기준으로 성능테스트를 하고 충분한 대역폭이 있는지 확인해야함
	  또한 데이터가 크면 압축을 생각할수있는데,이경우에도 압축을 해제하고 직렬화를하는데 코스트가 드니 테스트가 필요함
	  
	  또 다른 문제로는,직렬화 데이터포멧의 변경 체크문제임
	  데이터에 필드를 추가하거나 이름을 변경하면 배포되기전 서버에서 캐싱한 데이터와,배포중인 서버에서 캐싱한 데이터가 서로 다른 필드를 가지게됨
	  이러면 둘중 한군데서는 특정필드데이터를 누락하게됨
	  즉
		네트위크대역폭 성능테스트는 필수,aws는 인스턴스타입에 따라 대역폭이 다르니 이것도 주의
		직렬화/역직렬화를 할때 성능테스트도 필수
		원격캐시대상 데이터필드는 db칼럼과 동일하게 조심스럽게 리팩터링해야함,아니면 로컬캐시써야함
		캐시가 아니라 이미지파일용량이 큰경우에도 대역폭을 많이 차지하므로,대규모 이벤트는 렌딩페이지 크기를 최적화하고 cdn을 써야함
	  가 요약임
	  
	3.인증과 권한은 다르다
	  인증은 해당 신분증이 유효한지를 체크하는거고,권한은 해당 신분증이 뭐까지 할수있는지를 체크하는거임
	  두개는 반드시 따로따로 처리되어야함
	  
	4.사용자의 로그인실패 횟수를 트래킹해야함
	  브루트포스로 해킹하는걸 막기위해 캡챠등을 도입했을때엔,브라우저쿠키에 로그인실패횟수를 가져가는게 아닌,서버에서 처리해야함
	
	5.사용자의 가상재화는 별도 결제수단처럼 독립인증해야함
	  이건 필수는 아닌데,사용자의 책임이긴 하기때문
	  그래도 포인트같은걸 사용할때도 별도 인증을 거치는게좋음
	  이때는 포인트가 우회수단으로 현금같은거로 변환이 가능할땐 넣는게좋음(게임머니같은거)
	
	6.직원pc에서 운영서버api,db저장소 접근을 통제
	  서비스용 db접근계정에선 ddl(가급적 dml까지)권한을 제거해야함,즉 읽기전용으로 둬야함
	  특히 jpa create같은문제땜에라도 이래야함
	  
	  또한 메세지큐에서도 똑같은데,여기선 읽기만해도 소비한거로 취급되니 더 심함
	  
	  또한 api서버를 직접 호출해야하는경우가 잦다면,해당역할을 하는 인증과 권한관리가 된 내부 어드민서비스를 만들어야함
	  
	  모든 서버는 프라이빗하게 둬야하고,회사망에서도 접근을 통제해야함
	  이때도 되도록 쓰기없이 읽기권한만 주는게 좋음
	  물론 스타트업 초창기에서 이정도로 할필요없긴한데,커질거같다면 계속 보완해나가야함
	
	7.중요 배치는 실행여부를 제3의 시스템에서 검증해야함
	  배치의 크론탭 시간을 잘못 변경하는등의 일로 배치가 동작하지않을수도있음
	  이런건 모니터링솔루션으로 특정시간범위에 성공적으로 실행됐는지를 확인해야함(그라파나등으로)
	
	8.로그를 외부서버로 수집하는건 별도프로세스에서 비동기로
	  로그가 엄청나게 많이 발생하는경우도 생각을 해야함
	  이러면 로그자체가 디도스처럼 작용해버림
	  
	  애초에 로그수집시스템 솔루션을 쓰는게 낫긴함
	
	9.기본키는 Long로
	  프라이머리키는 integer이 아닌 Long로 잡는게 무조건 좋음
	
	10.오류로그는 일상적인것과 크리티컬한걸 구분
	  중요한 알림은 error로,아닌건 워링이나 인포로 두어야함
	
	11.롤백가능한 배포
	  웹만 아니라 배치도 롤백가능해야함
	
	12.spof(단일장애점)를 제거
	  안죽는서버가 아닌 죽어도되는서버를 만들어야함
	  또한 내가만든 앱만이 아닌 내가 호출하는 앱이 죽었을경우도 염두에 둬야함
	  
	핵심은 모든걸 대응할순없지만,문제가 생겼을때 무슨일이 터질지를 가정해보고,그게 감당불가능한 수준일경우엔 최우선처리를 해야함
	그러나 감당가능한수준이라면 그것대로 넘어가야함,모든걸 대비할순 없기때문
	이건 서비스의 성장에 맞추어 대비를 해나가야하는거임

  2.메인데이터베이스 idc 탈출기
    서비스가 종료되거나 아키텍처개선등으로 리팩터링될경우,레거시는 정리해야함
	안그러면 나중에 이게 쓰는건지 아닌지 알아보기가힘들고,신규개발자도 이해가 힘듬
	프로젝트를 계획할때 레거시제거도 프로젝트범위에 포함해야함
	
	또한 변수명등은 통일시켜야함
	명명규칙을 미리 정하고 최대한 많은사람에게 공유해야함
	
	그리고 특정코드의 주인을 만들어두는게 관리가 잘됨
	
	또한 같은기능을 하는 코드는 우연히 비슷한게 아닐경우엔 통합시켜야함
	로직은 가급적 단순하고 명료하게 만들고,불필요한 로직이 수행되지않는지를 점검해야함

  3.메시지 발송 이중화 여정기
    이중화를 하면 장애가 생겼을때 뭔가 대응이라는걸 할수있어짐
	또한 꼭 처음부터 모든걸 한번에 이중화하려고 하지말고,제일 중요하고 비용이 낮은부분부터 하는게 효과적임
	로드밸런서나 라우터등을 활용해서 이중화를 할수있음
	
	처음에는 대응을 수동으로 하는게 만들기쉽고,이후에 돌아가는거 보고 자동으로 바꾸는게 좋음
	또한 배포없이 트래픽을 변경하려면
	  특정 위치에 있는 스케줄링 설정파일을 주기적으로 읽어오거나(poll)
	  카프카등으로 변경시 이벤트를 던질수있음(push)
	카프카는 실시간에 가깝게 반영되지만 카프카 의존성이 생긴다는 단점이 있고,
	지속적풀링은 클라갯수마다 통신코스트가 추가되고 특정시간마다 바뀐다는 단점이 있음

  4.배민상회와 검색플랫폼 연동기
    서로 다른 시스템을 연동할땐,서로 다른 팀간의 용어통일이 가장 먼저되어야함
	또한 팀은 팀마다의 사정이 있고,그안에서의 규칙이 있음
	즉 당연했던게 당연하지않게됨
	
  5.네트워크 인증 시스템 교체기
    스킵
  6.사장님용 통계데이터 서빙
    통계데이터처리는 배치로 하는게
	  테스트가 쉽고
	  변경사항에 유연하게 대응가능하고
	  통계처리를 가독성있게 코드로 표현할수있음
	단 데이터 크기에 주의해야함
	
	그리고 처음쓰는기술을 사용할땐,내가 일주일의 빈시간이 있으면 뭘 할지,
	어디가 가장 불안한지,어떻게 불안감을 해소할지를 생각해보고 그부분이 가능한지를 확인하는 방법을 사용할수있음
	
	즉
	  가치의 우선순위를 파악하고,기술의 장단점을 분석후 우선순위에 따라 기술선택
	  생소한 기술에 대한 불안감을 질문으로 해소(즉 어떤식으로 구현할지를 미리 그려보고,어느부분이 젤 불안한지를 확인후 그부분을 따로 확인)
	순으로 할수있음
	
4.인공지능으로 한단계 업그레이드하기
  1.머신러닝으로 배민앱리뷰 품질 높이기	  
    굳이 현재기준으로 쓰진않을듯
	요즘은 llm 연결해서 탐지하는게 훨 편하고 싸기도하니까

  2.배민의 ai서비스와 mlops 도입기
    mlops가 필요한 이유는,계속 모델은 업데이트되어야하고,모델을 만든 방법을 정확히 따라하면 정확히 같은 모델을 만들수있어야함(재현성)
	
	가장 먼저 mlops로 해결해야할 문제를 명확히 설정해야함
	예를들어 모델을 개발환경과 동일하게 운영환경으로 배포,파이프라인 테스트자동화 cicd구축등이 목표가 될수있음
	
	구체적으로는 모델을 모아두는 레포(모노레포)와 모델을 서빙하는 프로젝트를 분리해서 프로젝트의 변경없이 모델을 변경할수있게 하는것등을 할수있음
	또한 클라이언트 도커이미지를 만들어볼수도있음
	
	즉 데이터과학자는 모델개발에만 집중할수있게 판을 만들어준다고 생각하면됨

  3.슬랙에 chatgpt를 연결하여 업무활용해보기
    슬랙에 연결할땐 개발자만이 아니라 비개발자도 같이 쓴다는걸 명심하고 만들어야함

5.테스트와 코드품질 관리하기
  1.잊을만하면 돌아오는 정산시스템
    프로그램에서 가장 중요한건 요구사항임
	명시적 요구사항이 아니라 당연하게 들어있어야하는 요구사항도 만족시켜야함
	
	컨트롤러의 입력dto가 레포지토리까지 흐르게되면 서비스가 컨트롤러에 의존하게됨
	즉 최소 서비스단에서는 끊고 dto를 도메인으로 변경해야함
	안그러면 서비스를 모듈로 분리할수없고,dto의 변경도 힘들어짐
	그리고 dto의 소유권은 서비스가 가져가야함
	
	테스트를 작성할땐 최대한 예외케이스부터 작성하고 해피패스를 작성해야함
	최대한 다양한걸 테스트해야함
	
	그리고 jpa를 사용할때는 쿼리가 어떻게 날아가는지를 항상 확인하는 습관을 가져야함
	
	도메인특화 로직의 경우 util로 이름지으면안됨
	
	현재상황에서 모듈로 분리되지않아도 될거는 나중에 분리할수 있게만 만들어두고 분리하지않는게 더 효율적임
	즉 모듈은 최소스펙으로,데이터는 확장가능한 형태를 지향해야함
	
	배치에서는 연산을 db에서 연산하면 테스트도 편하고 그룹핑도 편함,이건 근데 다 케바케임
	일단 유지보수하기 편한쪽으로 로직을 작성하는게 좋음
	
	청크를 사용할땐,모든작업을 이름에 맞춰서 하는것도 괜찮지만,프로세서의 역할을 좀 더 확장해서 분할해서 사용하는것도 괜찮은방법임
	즉 리더,프로세서,라이터는 실행순서를 보장하고
	  리더:트랜잭션의 시작,한방쿼리가 가능하면 조회의 모든기능을 담당하지만,그렇지않으면 트랜잭션을 시작하고 배치를 시작하는 엔드포인트의 역할
	  프로세서:데이터를 가공하는 역할,리더의 데이터가 모자라다면 추가조회가능,작업을 세분화하는 형태로 사용됨
	  라이터:데이터를 수정/저장하는 역할
	이런식으로 생각할수도있음
	보통 리더에서 읽어온 데이터마다 다른 api를 요청하거나 각 데이터 저장수정이 필요한경우엔 프로세서에서 처리하고 최종데이터만 라이터에서 저장하고
	일괄적으로 동일하게 저장수정할땐 라이터에서 처리
	둘다 상호배타적이지않으니 적절하게 고르면됨
	
	배포에선
	aws ec2에서는 서버시간이 한국기준이 아니니까 한국기준으로 바꿔야함
	db시간/언어설정을 바꿔야함
	
	즉 기본에 충실해야함

  2.품질담당자의 회고
    클라와 서버는 서로 분리해서 테스트하는게 좋음,생각할게 줄어듬
	클라이전에 서버부터 테스트를 하는게 더 좋음,이후 안정적인 상황에서 통합테스트를 하는게 좋음

  3.단위테스트로 복잡한 도메인의 프론트엔드 프로젝트 정복하기
    뷰로직에서 테스트를 추가할땐
	  기존의 동작하는 코드를 기반으로 사용자시나리오 작성
	    상황에따라 어떻게 동작하는지 전부 분류
		엣지케이스발견시 추가정리
	  사용자 시나리오 기반으로 테스트코드 작성
	    이때 엣지케이스가 아니라면 전부 성공해야함(기존동작코드니까)
	  리팩터링
	    컴포넌트분리,코드분리,로직간소화등
	이런순서로 하면됨
	
	테스트가 있으면 컴포넌트분리도 테스트하기 좋은 기준으로 나눌수있음
	또한 기능에 대한 문서화도 겸하게됨

  4.자동화된 ui 회귀테스트 도입하기
    ui테스트는 가장 비싸니 제일 양이 적어야함
	그래서 테스트자동화를 도입할땐
	  기존 테스트항목을 시나리오에 어케 분류하고 나눌지 고민이 필요
	  꾸준한 유지보수가 필요
	  초기에 공격적으로 ui테스트 자동화작업을 진행해야만 안정적인 자동화가 가능
	  
6.시행착오 겪으며 성장하기
  1.가정의달 이벤트가 쏘아올린 배민 선물하기 대란	
	이벤트같은거도 모든 상황을 전부알순없어도,최대한 파급력과 이슈에 대해 더 깊이 고민해야함

  2.외부시스템 장애에 대처하는 우리의 자세
    외부시스템은 직접 개발하는거에 비해서 간단히 연동할수있으면서 높은수준의 서비스를 이용할수있고,비용측면에서도 직접 구축하고 운영하는것보다 저렴하지만,
	우리 통제밖에있는 불안요소이기도함
	
	외부시스템의 장애가 우리 서비스의 장애로 이어지지않게 주의를 기울여야하고,항상 장애가 날수있다고 염두에 두고 연동해야하고 장애가 터졌을때 영향을 최소화해야함
	
	일단 해당 외부시스템이 꼭 필요한지를 고민해봐야함
	반드시 필요한게 아니라면 의존관계를 맺지않는게 더 좋음
	또한 이미 연동해서 사용중인 시스템이라도 주기적으로 확인해야함
	서비스가 커지고 구조가 변경되면서 리스크가 더 커지는경우가 있기때문
	
	널리 사용되는 서비스의 경우,여러업체에서 비슷한기능을 제공하니까 이걸로 이중화하는 방법도 있음
	이때 어드민에 전환기능을 구현해두고 권한있는 다수의 팀원이 조치하게 구성하는게 일반적임
	이때 주의할점은 이런 전환이 자주쓰이지않기때문에,처음부터 8:2정도로 계속 트래픽을 흘려보내는게 좋음,이래야 문제가 생겼을때 바로 알수있음
	
	이중화에 비용이 너무많이들거나 그런걸 할 상황이 아닐때는,장애가 연동과 관련없는부분으로 전파되지않게 장애를 격리하는게 중요함
	사용자가 최소기능은 사용할수있게 제공하는게 핵심임
	
	다 안되면 일단 장애가 발생했다는걸 확인할수는 있어야함(aws같은 클라우드),즉 모니터링은 최소한으로 있어야함

  3.우아한 장애 대응
    장애가 발생하는걸 원천적으로 차단할순없음
	그래서 빠르고 적절히 장애에 대응해야하고,장애가 발생해도 영향범위를 최소화하고 빠르게 복구하고 고객에게 적절한 정보를 제공하고 같은장애가 터지지않게해야함
	
	장애는 시스템알람을 통해서 탐지할수도있고,cs센터를 통해 인지할수도있음
	일단 모니터링으로 이상현상을 감지하고 슬랙으로 알림을 던지는게 가장 기본임
	이때 중요한 알람은 담당자에게 즉시 연락이 가게 할수있는것도 좋음
	
	사용빈도가 극히 낮거나,특정 os,브라우저에따른 제한적인 오류는 고객센터를 통해 인지하게됨
	
	장애공지는 최소한의 정보만 가지고 빠르게 공지하는게 중요함(화재경보기)
	이때 장애를 해결하는거만큼이나 장애상황과 해결방안을 전파하는것도 중요한데,이걸 같은사람이 하지않게 분리하는게 좋음
	또한 개발자와 비개발자간의 지식수준에 따라 번역을 다르게해야하니 이런것도 처리하려면 바쁜사람이 더 바쁘지않게 하는게 좋음
	
	대부분의 경우 서비스 정상화가 원인파악보다 우선됨
	그래서
	  장비증설:트래픽이 몰리거나 변경된코드가 시스템에 부하를 주는경우
	  롤백:장애발생직전 변경된내용이 있는지 확인하고(24시간정도) 롤백,이게 가장 우선시되는 방법
	  핫픽스:롤백이 불가능할경우(db스키마변경등)나 문제의 원인이 명확해서 핫픽스가 빠를경우 사용,이때 반드시 페어로 확인하고 베타에서 검증한후 진행해야함
	  장비교체:특정장비에 문제가 생겼을경우 해당장비만 교체하는식
	이런방식으로 일단 서비스를 정상화시켜야함
	
	장애복구가 완료됐으면 원인을 파악하고 재발방지를 해야함
	이때 가장 근본적인 원인을 파악해야함,그래서 5ways기법을 사용할수있음
	근본원인을 찾았으면 그 문제가 다시 발생하지않게 재발방지대책을 수립해야함
	이 재발방지대책은 근본원인제거에만 그치지않고 더빠른 탐지와 더빠른 복구에 도움이 되는 모든조치를 포함함
	모니터링 지표 추가,설정값 변경,코드리뷰절차개선,배포프로세스 수정등 여러가지로 고민하며 단기,중기,장기적으로 개선할 방안을 도출해야함
	단기적으로는 알람강화나 부하가 발생하는 로직개선등의 항목이 도출되고,중장기적으로는 아키텍처개선이나 레거시제거등 대규모작업이 진행됨
	
	장애보고서엔 많은 항목이 수집되고있음,이데이터를 모아서 전체적인 장애대응프로세스를 개선하는데 참고할수있음
	가장 중요한건 같은실수를 반복하지않는것

  4.장애와 관련된 엑스트라백업 적용기
	  
	  
	  
	  
	  
	  
	  
	  
	  
	  
	  
	  
	  
	  
	  
	  
	  
	  
	  
	  
	  
	  
	  
	  
	  