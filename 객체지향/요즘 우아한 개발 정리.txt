1.배민다움 만들기
  스킵?
  mr관련
    머지 리퀘스트(mr) 템플릿 만들면 작성이 편함
    mr은 삭제포함 300줄 미만
    하나의 티켓에서 여러mr을 만들어도됨 
    리팩터링은 분리

  문화
    무엇을 하는지를 적는 주석은 좋지않지만,왜하는지를 적는 주석은 괜찮음
	그것보다 더 좋은건 테스트코드를 명확하게 작성하고 설명에 이유를 적어두는것

2.프론트엔드 개발자로 성장하기 
  스킵

3.백엔드 개발자로 성장하기
  1.개발자 머피의 법칙
    어떤일을 하는데 두가지 이상의 방법이 있고,그중 하나가 나쁜결과를 불러오면 누군가는 꼭 그걸 사용함
	즉 잘못되는건 꼭 잘못되기 마련임
	
	1.사용자의 입력은 반드시 검증한다
	  뷰를 어떻게 만들어뒀든 사용자의 모든 입력은 반드시 검증해야함
	  ui단에서 검증하는건 단순한 편의목적이고,반드시 서버에서 올바른범위의 값인지를 무조건 검증해야함
	  즉 클라에서 검증한건 검증하지않은거임
	  보통 배송일입력같은 날짜에서 이런문제가 생기기쉬윔
	  
	  그리고 모든 계산은 클라가 아닌 서버에서 해야함
	  안그러면 값바꿔치기에 매우 취약함
	  클라계산은 단순히 편의성을 전달하기위한 목적이어야함(즉 최종결과는 서버에서 재계산해야함)
	  
	  사용자의 요청에 의해 쿼리의 모든 조건이 사라지면 안됨
	  queryDSL이나 이런거 쓸때 주의해야하는건데,동적쿼리에서 모든 조건이 동시에 절대 사라지면 안되고,이걸 반드시 검증해야함
	  즉 배타적인 조회조건을 사용할때,두 조건중 하나 이상이 요청매개변수에 존재하는지를 항상 검증해야함
	  또한 사내api에서도 반드시 검증해야하고,페이징사이즈같은것도 일정이상 못넘어가게 막아야함
	
	2.성능측정없는 캐시사용은 성능을 저하시킬수있다
	  레디스같은 원격분산캐시를 사용할때 주의점은,얘들은 네트워크대역폭을 먹고살아서 캐시에 너무 많은 데이터를 담으면 캐시히트율이 높아도 대역폭떔에 느려짐
	  그래서 실제 운영서비스기준으로 성능테스트를 하고 충분한 대역폭이 있는지 확인해야함
	  또한 데이터가 크면 압축을 생각할수있는데,이경우에도 압축을 해제하고 직렬화를하는데 코스트가 드니 테스트가 필요함
	  
	  또 다른 문제로는,직렬화 데이터포멧의 변경 체크문제임
	  데이터에 필드를 추가하거나 이름을 변경하면 배포되기전 서버에서 캐싱한 데이터와,배포중인 서버에서 캐싱한 데이터가 서로 다른 필드를 가지게됨
	  이러면 둘중 한군데서는 특정필드데이터를 누락하게됨
	  즉
		네트위크대역폭 성능테스트는 필수,aws는 인스턴스타입에 따라 대역폭이 다르니 이것도 주의
		직렬화/역직렬화를 할때 성능테스트도 필수
		원격캐시대상 데이터필드는 db칼럼과 동일하게 조심스럽게 리팩터링해야함,아니면 로컬캐시써야함
		캐시가 아니라 이미지파일용량이 큰경우에도 대역폭을 많이 차지하므로,대규모 이벤트는 렌딩페이지 크기를 최적화하고 cdn을 써야함
	  가 요약임
	  
	3.인증과 권한은 다르다
	  인증은 해당 신분증이 유효한지를 체크하는거고,권한은 해당 신분증이 뭐까지 할수있는지를 체크하는거임
	  두개는 반드시 따로따로 처리되어야함
	  
	4.사용자의 로그인실패 횟수를 트래킹해야함
	  브루트포스로 해킹하는걸 막기위해 캡챠등을 도입했을때엔,브라우저쿠키에 로그인실패횟수를 가져가는게 아닌,서버에서 처리해야함
	
	5.사용자의 가상재화는 별도 결제수단처럼 독립인증해야함
	  이건 필수는 아닌데,사용자의 책임이긴 하기때문
	  그래도 포인트같은걸 사용할때도 별도 인증을 거치는게좋음
	  이때는 포인트가 우회수단으로 현금같은거로 변환이 가능할땐 넣는게좋음(게임머니같은거)
	
	6.직원pc에서 운영서버api,db저장소 접근을 통제
	  서비스용 db접근계정에선 ddl(가급적 dml까지)권한을 제거해야함,즉 읽기전용으로 둬야함
	  특히 jpa create같은문제땜에라도 이래야함
	  
	  또한 메세지큐에서도 똑같은데,여기선 읽기만해도 소비한거로 취급되니 더 심함
	  
	  또한 api서버를 직접 호출해야하는경우가 잦다면,해당역할을 하는 인증과 권한관리가 된 내부 어드민서비스를 만들어야함
	  
	  모든 서버는 프라이빗하게 둬야하고,회사망에서도 접근을 통제해야함
	  이때도 되도록 쓰기없이 읽기권한만 주는게 좋음
	  물론 스타트업 초창기에서 이정도로 할필요없긴한데,커질거같다면 계속 보완해나가야함
	
	7.중요 배치는 실행여부를 제3의 시스템에서 검증해야함
	  배치의 크론탭 시간을 잘못 변경하는등의 일로 배치가 동작하지않을수도있음
	  이런건 모니터링솔루션으로 특정시간범위에 성공적으로 실행됐는지를 확인해야함(그라파나등으로)
	
	8.로그를 외부서버로 수집하는건 별도프로세스에서 비동기로
	  로그가 엄청나게 많이 발생하는경우도 생각을 해야함
	  이러면 로그자체가 디도스처럼 작용해버림
	  
	  애초에 로그수집시스템 솔루션을 쓰는게 낫긴함
	
	9.기본키는 Long로
	  프라이머리키는 integer이 아닌 Long로 잡는게 무조건 좋음
	
	10.오류로그는 일상적인것과 크리티컬한걸 구분
	  중요한 알림은 error로,아닌건 워링이나 인포로 두어야함
	
	11.롤백가능한 배포
	  웹만 아니라 배치도 롤백가능해야함
	
	12.spof(단일장애점)를 제거
	  안죽는서버가 아닌 죽어도되는서버를 만들어야함
	  또한 내가만든 앱만이 아닌 내가 호출하는 앱이 죽었을경우도 염두에 둬야함
	  
	핵심은 모든걸 대응할순없지만,문제가 생겼을때 무슨일이 터질지를 가정해보고,그게 감당불가능한 수준일경우엔 최우선처리를 해야함
	그러나 감당가능한수준이라면 그것대로 넘어가야함,모든걸 대비할순 없기때문
	이건 서비스의 성장에 맞추어 대비를 해나가야하는거임

  2.메인데이터베이스 idc 탈출기
    서비스가 종료되거나 아키텍처개선등으로 리팩터링될경우,레거시는 정리해야함
	안그러면 나중에 이게 쓰는건지 아닌지 알아보기가힘들고,신규개발자도 이해가 힘듬
	프로젝트를 계획할때 레거시제거도 프로젝트범위에 포함해야함
	
	또한 변수명등은 통일시켜야함
	명명규칙을 미리 정하고 최대한 많은사람에게 공유해야함
	
	그리고 특정코드의 주인을 만들어두는게 관리가 잘됨
	
	또한 같은기능을 하는 코드는 우연히 비슷한게 아닐경우엔 통합시켜야함
	로직은 가급적 단순하고 명료하게 만들고,불필요한 로직이 수행되지않는지를 점검해야함

  3.메시지 발송 이중화 여정기
	  
	  
	  
	  
	  
	  
	  
	  
	  
	  
	  
	  
	  
	  
	  
	  
	  
	  
	  
	  
	  
	  
	  
	  
	  
	  
	  
	  