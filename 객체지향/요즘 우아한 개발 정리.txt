1.배민다움 만들기
  스킵?
  mr관련
    머지 리퀘스트(mr) 템플릿 만들면 작성이 편함
    mr은 삭제포함 300줄 미만
    하나의 티켓에서 여러mr을 만들어도됨 
    리팩터링은 분리

  문화
    무엇을 하는지를 적는 주석은 좋지않지만,왜하는지를 적는 주석은 괜찮음
	그것보다 더 좋은건 테스트코드를 명확하게 작성하고 설명에 이유를 적어두는것

2.프론트엔드 개발자로 성장하기 
  스킵

3.백엔드 개발자로 성장하기
  1.개발자 머피의 법칙
    어떤일을 하는데 두가지 이상의 방법이 있고,그중 하나가 나쁜결과를 불러오면 누군가는 꼭 그걸 사용함
	즉 잘못되는건 꼭 잘못되기 마련임
	
	1.사용자의 입력은 반드시 검증한다
	  뷰를 어떻게 만들어뒀든 사용자의 모든 입력은 반드시 검증해야함
	  ui단에서 검증하는건 단순한 편의목적이고,반드시 서버에서 올바른범위의 값인지를 무조건 검증해야함
	  즉 클라에서 검증한건 검증하지않은거임
	  보통 배송일입력같은 날짜에서 이런문제가 생기기쉬윔
	  
	  그리고 모든 계산은 클라가 아닌 서버에서 해야함
	  안그러면 값바꿔치기에 매우 취약함
	  클라계산은 단순히 편의성을 전달하기위한 목적이어야함(즉 최종결과는 서버에서 재계산해야함)
	  
	  사용자의 요청에 의해 쿼리의 모든 조건이 사라지면 안됨
	  queryDSL이나 이런거 쓸때 주의해야하는건데,동적쿼리에서 모든 조건이 동시에 절대 사라지면 안되고,이걸 반드시 검증해야함
	  즉 배타적인 조회조건을 사용할때,두 조건중 하나 이상이 요청매개변수에 존재하는지를 항상 검증해야함
	  또한 사내api에서도 반드시 검증해야하고,페이징사이즈같은것도 일정이상 못넘어가게 막아야함
	
	2.성능측정없는 캐시사용은 성능을 저하시킬수있다
	  레디스같은 원격분산캐시를 사용할때 주의점은,얘들은 네트워크대역폭을 먹고살아서 캐시에 너무 많은 데이터를 담으면 캐시히트율이 높아도 대역폭떔에 느려짐
	  그래서 실제 운영서비스기준으로 성능테스트를 하고 충분한 대역폭이 있는지 확인해야함
	  또한 데이터가 크면 압축을 생각할수있는데,이경우에도 압축을 해제하고 직렬화를하는데 코스트가 드니 테스트가 필요함
	  
	  또 다른 문제로는,직렬화 데이터포멧의 변경 체크문제임
	  데이터에 필드를 추가하거나 이름을 변경하면 배포되기전 서버에서 캐싱한 데이터와,배포중인 서버에서 캐싱한 데이터가 서로 다른 필드를 가지게됨
	  이러면 둘중 한군데서는 특정필드데이터를 누락하게됨
	  즉
		네트위크대역폭 성능테스트는 필수,aws는 인스턴스타입에 따라 대역폭이 다르니 이것도 주의
		직렬화/역직렬화를 할때 성능테스트도 필수
		원격캐시대상 데이터필드는 db칼럼과 동일하게 조심스럽게 리팩터링해야함,아니면 로컬캐시써야함
		캐시가 아니라 이미지파일용량이 큰경우에도 대역폭을 많이 차지하므로,대규모 이벤트는 렌딩페이지 크기를 최적화하고 cdn을 써야함
	  가 요약임
	  
	3.인증과 권한은 다르다
	  인증은 해당 신분증이 유효한지를 체크하는거고,권한은 해당 신분증이 뭐까지 할수있는지를 체크하는거임
	  두개는 반드시 따로따로 처리되어야함
	  
	4.사용자의 로그인실패 횟수를 트래킹해야함
	  브루트포스로 해킹하는걸 막기위해 캡챠등을 도입했을때엔,브라우저쿠키에 로그인실패횟수를 가져가는게 아닌,서버에서 처리해야함
	
	5.사용자의 가상재화는 별도 결제수단처럼 독립인증해야함
	  이건 필수는 아닌데,사용자의 책임이긴 하기때문
	  그래도 포인트같은걸 사용할때도 별도 인증을 거치는게좋음
	  이때는 포인트가 우회수단으로 현금같은거로 변환이 가능할땐 넣는게좋음(게임머니같은거)
	
	6.직원pc에서 운영서버api,db저장소 접근을 통제
	  서비스용 db접근계정에선 ddl(가급적 dml까지)권한을 제거해야함,즉 읽기전용으로 둬야함
	  특히 jpa create같은문제땜에라도 이래야함
	  
	  또한 메세지큐에서도 똑같은데,여기선 읽기만해도 소비한거로 취급되니 더 심함
	  
	  또한 api서버를 직접 호출해야하는경우가 잦다면,해당역할을 하는 인증과 권한관리가 된 내부 어드민서비스를 만들어야함
	  
	  모든 서버는 프라이빗하게 둬야하고,회사망에서도 접근을 통제해야함
	  이때도 되도록 쓰기없이 읽기권한만 주는게 좋음
	  물론 스타트업 초창기에서 이정도로 할필요없긴한데,커질거같다면 계속 보완해나가야함
	
	7.중요 배치는 실행여부를 제3의 시스템에서 검증해야함
	  배치의 크론탭 시간을 잘못 변경하는등의 일로 배치가 동작하지않을수도있음
	  이런건 모니터링솔루션으로 특정시간범위에 성공적으로 실행됐는지를 확인해야함(그라파나등으로)
	
	8.로그를 외부서버로 수집하는건 별도프로세스에서 비동기로
	  로그가 엄청나게 많이 발생하는경우도 생각을 해야함
	  이러면 로그자체가 디도스처럼 작용해버림
	  
	  애초에 로그수집시스템 솔루션을 쓰는게 낫긴함
	
	9.기본키는 Long로
	  프라이머리키는 integer이 아닌 Long로 잡는게 무조건 좋음
	
	10.오류로그는 일상적인것과 크리티컬한걸 구분
	  중요한 알림은 error로,아닌건 워링이나 인포로 두어야함
	
	11.롤백가능한 배포
	  웹만 아니라 배치도 롤백가능해야함
	
	12.spof(단일장애점)를 제거
	  안죽는서버가 아닌 죽어도되는서버를 만들어야함
	  또한 내가만든 앱만이 아닌 내가 호출하는 앱이 죽었을경우도 염두에 둬야함
	  
	핵심은 모든걸 대응할순없지만,문제가 생겼을때 무슨일이 터질지를 가정해보고,그게 감당불가능한 수준일경우엔 최우선처리를 해야함
	그러나 감당가능한수준이라면 그것대로 넘어가야함,모든걸 대비할순 없기때문
	이건 서비스의 성장에 맞추어 대비를 해나가야하는거임

  2.메인데이터베이스 idc 탈출기
    서비스가 종료되거나 아키텍처개선등으로 리팩터링될경우,레거시는 정리해야함
	안그러면 나중에 이게 쓰는건지 아닌지 알아보기가힘들고,신규개발자도 이해가 힘듬
	프로젝트를 계획할때 레거시제거도 프로젝트범위에 포함해야함
	
	또한 변수명등은 통일시켜야함
	명명규칙을 미리 정하고 최대한 많은사람에게 공유해야함
	
	그리고 특정코드의 주인을 만들어두는게 관리가 잘됨
	
	또한 같은기능을 하는 코드는 우연히 비슷한게 아닐경우엔 통합시켜야함
	로직은 가급적 단순하고 명료하게 만들고,불필요한 로직이 수행되지않는지를 점검해야함

  3.메시지 발송 이중화 여정기
    이중화를 하면 장애가 생겼을때 뭔가 대응이라는걸 할수있어짐
	또한 꼭 처음부터 모든걸 한번에 이중화하려고 하지말고,제일 중요하고 비용이 낮은부분부터 하는게 효과적임
	로드밸런서나 라우터등을 활용해서 이중화를 할수있음
	
	처음에는 대응을 수동으로 하는게 만들기쉽고,이후에 돌아가는거 보고 자동으로 바꾸는게 좋음
	또한 배포없이 트래픽을 변경하려면
	  특정 위치에 있는 스케줄링 설정파일을 주기적으로 읽어오거나(poll)
	  카프카등으로 변경시 이벤트를 던질수있음(push)
	카프카는 실시간에 가깝게 반영되지만 카프카 의존성이 생긴다는 단점이 있고,
	지속적풀링은 클라갯수마다 통신코스트가 추가되고 특정시간마다 바뀐다는 단점이 있음

  4.배민상회와 검색플랫폼 연동기
    서로 다른 시스템을 연동할땐,서로 다른 팀간의 용어통일이 가장 먼저되어야함
	또한 팀은 팀마다의 사정이 있고,그안에서의 규칙이 있음
	즉 당연했던게 당연하지않게됨
	
  5.네트워크 인증 시스템 교체기
    스킵
  6.사장님용 통계데이터 서빙
    통계데이터처리는 배치로 하는게
	  테스트가 쉽고
	  변경사항에 유연하게 대응가능하고
	  통계처리를 가독성있게 코드로 표현할수있음
	단 데이터 크기에 주의해야함
	
	그리고 처음쓰는기술을 사용할땐,내가 일주일의 빈시간이 있으면 뭘 할지,
	어디가 가장 불안한지,어떻게 불안감을 해소할지를 생각해보고 그부분이 가능한지를 확인하는 방법을 사용할수있음
	
	즉
	  가치의 우선순위를 파악하고,기술의 장단점을 분석후 우선순위에 따라 기술선택
	  생소한 기술에 대한 불안감을 질문으로 해소(즉 어떤식으로 구현할지를 미리 그려보고,어느부분이 젤 불안한지를 확인후 그부분을 따로 확인)
	순으로 할수있음
	
4.인공지능으로 한단계 업그레이드하기
  1.머신러닝으로 배민앱리뷰 품질 높이기	  
    굳이 현재기준으로 쓰진않을듯
	요즘은 llm 연결해서 탐지하는게 훨 편하고 싸기도하니까

  2.배민의 ai서비스와 mlops 도입기
    mlops가 필요한 이유는,계속 모델은 업데이트되어야하고,모델을 만든 방법을 정확히 따라하면 정확히 같은 모델을 만들수있어야함(재현성)
	
	가장 먼저 mlops로 해결해야할 문제를 명확히 설정해야함
	예를들어 모델을 개발환경과 동일하게 운영환경으로 배포,파이프라인 테스트자동화 cicd구축등이 목표가 될수있음
	
	구체적으로는 모델을 모아두는 레포(모노레포)와 모델을 서빙하는 프로젝트를 분리해서 프로젝트의 변경없이 모델을 변경할수있게 하는것등을 할수있음
	또한 클라이언트 도커이미지를 만들어볼수도있음
	
	즉 데이터과학자는 모델개발에만 집중할수있게 판을 만들어준다고 생각하면됨

  3.슬랙에 chatgpt를 연결하여 업무활용해보기
    슬랙에 연결할땐 개발자만이 아니라 비개발자도 같이 쓴다는걸 명심하고 만들어야함

5.테스트와 코드품질 관리하기
  1.잊을만하면 돌아오는 정산시스템
    프로그램에서 가장 중요한건 요구사항임
	명시적 요구사항이 아니라 당연하게 들어있어야하는 요구사항도 만족시켜야함
	
	컨트롤러의 입력dto가 레포지토리까지 흐르게되면 서비스가 컨트롤러에 의존하게됨
	즉 최소 서비스단에서는 끊고 dto를 도메인으로 변경해야함
	안그러면 서비스를 모듈로 분리할수없고,dto의 변경도 힘들어짐
	그리고 dto의 소유권은 서비스가 가져가야함
	
	테스트를 작성할땐 최대한 예외케이스부터 작성하고 해피패스를 작성해야함
	최대한 다양한걸 테스트해야함
	
	그리고 jpa를 사용할때는 쿼리가 어떻게 날아가는지를 항상 확인하는 습관을 가져야함
	
	도메인특화 로직의 경우 util로 이름지으면안됨
	
	현재상황에서 모듈로 분리되지않아도 될거는 나중에 분리할수 있게만 만들어두고 분리하지않는게 더 효율적임
	즉 모듈은 최소스펙으로,데이터는 확장가능한 형태를 지향해야함
	
	배치에서는 연산을 db에서 연산하면 테스트도 편하고 그룹핑도 편함,이건 근데 다 케바케임
	일단 유지보수하기 편한쪽으로 로직을 작성하는게 좋음
	
	청크를 사용할땐,모든작업을 이름에 맞춰서 하는것도 괜찮지만,프로세서의 역할을 좀 더 확장해서 분할해서 사용하는것도 괜찮은방법임
	즉 리더,프로세서,라이터는 실행순서를 보장하고
	  리더:트랜잭션의 시작,한방쿼리가 가능하면 조회의 모든기능을 담당하지만,그렇지않으면 트랜잭션을 시작하고 배치를 시작하는 엔드포인트의 역할
	  프로세서:데이터를 가공하는 역할,리더의 데이터가 모자라다면 추가조회가능,작업을 세분화하는 형태로 사용됨
	  라이터:데이터를 수정/저장하는 역할
	이런식으로 생각할수도있음
	보통 리더에서 읽어온 데이터마다 다른 api를 요청하거나 각 데이터 저장수정이 필요한경우엔 프로세서에서 처리하고 최종데이터만 라이터에서 저장하고
	일괄적으로 동일하게 저장수정할땐 라이터에서 처리
	둘다 상호배타적이지않으니 적절하게 고르면됨
	
	배포에선
	aws ec2에서는 서버시간이 한국기준이 아니니까 한국기준으로 바꿔야함
	db시간/언어설정을 바꿔야함
	
	즉 기본에 충실해야함

  2.품질담당자의 회고
    클라와 서버는 서로 분리해서 테스트하는게 좋음,생각할게 줄어듬
	클라이전에 서버부터 테스트를 하는게 더 좋음,이후 안정적인 상황에서 통합테스트를 하는게 좋음

  3.단위테스트로 복잡한 도메인의 프론트엔드 프로젝트 정복하기
	  
	  
	  
	  
	  
	  
	  
	  
	  
	  
	  
	  
	  
	  
	  
	  
	  
	  
	  
	  
	  
	  
	  
	  
	  
	  
	  