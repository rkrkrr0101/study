1.들어가며
  스킵
2.느려진 서비스 어디부터 봐야할까
*1.처리량과 응답시간
  1.응답시간
    요청이 10초이상걸리면 성능이 나쁜거임
    이때 서버성능과 관련있는 중요지표 2개는 응답시간과 처리량임
    
    응답시간은 사용자의 요청을 처리하는데 걸리는 시간임
    가장 일반적인 요청은 
      1.api요청
	    1.1번 sql실행
	    2.2번 sql실행
	  2.json 반환
    이런 순서를 가지게되는데,이떄 api요청을 호출하고 json반환을 받을때까지 걸린 시간이 응답시간임
    
    응답시간을 나눠보면
      api요청
        서버에 연결
	    서버로 데이터 전송
	  서버실행
	    sql실행
	    응답생성 등
	  api응답
	    클라이언트로 데이터전송
    이렇게 나눠짐
    서버에 연결은 tcp를 이용해서 서버와 연결하는거고,데이터전송은 프로토콜에 맞춰 데이터를 서버에 전송하는것
    또한 응답시간은 응답데이터중 첫바이트가 도착하는데 걸린시간(TTFB)와 응답데이터중 마지막 바이트가 도착하는데 걸리는 시간(TTLB)로 나눌수도있음
    이건 보통땐 상관없는데,다운로드같은거나 네트워크가 느릴떈 차이가 커질수있음
    
    응답시간은 보통 ms단위로 잼
    응답시간은 사업에 영향이 큼(100ms지연시 매출1%감소)
    
    응답시간은 api요청 전송시간,서버의 처리시간,api응답 전송 시간으로 나뉨
    서버개발자는 주로 서버의 처리시간을 확인하고,서버처리시간은 다음과 같은 요소를 포함함
      로직수행
	  db연동
	  외부api연동
	  응답데이터 전송
    이중 db연동과 api연동이 응답시간에 큰 비중을 차지함
    그래서 이걸 줄이는게 핵심임
  2.처리량
    처리량은 단위시간당 시스템이 처리하는 작업량을 의미하고,흔히 TPS(초당 트랜잭션 수)나 RPS(초당 요청 수)로 나타냄
	
	최대TPS는 시스템이 처리할수있는 최대 요청수를 의미함
	서버가 한번에 5개의 요청을 처리할수있고,요청당 처리시간이 1초라면 5임
	이걸 넘긴수의 요청이 들어오면,초과된 요청을 나중에 처리함(2초)
	
	응답시간의 증가는 사용자 이탈로 이어질수있음,그래서
	  서버가 동시에 처리할수있는 요청수를 늘려 대기시간 줄이기(배치크기 늘리기)
	  처리시간 자체를 줄여 대기시간 줄이기(속도 높이기)
	두 방법을 적용해 TPS를 높여야함
	
	모든 개선을 할때 제일 먼저해야할건 측정임
	먼저 트래픽이 많은 시간대의 TPS와 응답시간을 측정하고,이결과를 바탕으로 목표TPS와 응답시간을 설정하고 효과적인 성능개선안을 도출해야함
	이때 가장쓰기편한건 모니터링시스템임(스카우터,뉴렐릭등)

*2.서버 성능 개선 기초
  1.병목 지점
    서비스 초기에는 성능문제가 잘 발생하지않지만,서비스가 커지면서 간헐적으로 응답시간이 느려짐
	이걸 방치하면 어느순간 심각한 성능문제가 생김
	  순간적으로 모든 사용자요청에 대한 응답시간이 심각하게 느려짐
	  서버를 재시작하면 잠시 괜찮다가 다시 응답시간이 느려짐
	  트래픽이 줄어들때까지 심각한상황이 지속됨
	이게 발생하는 주된이유는,최대TPS를 넘은 트래픽이 유입되기때문
	그래서 최대TPS를 높여야함
	
	이땐 먼저 성능문제가 발생하는 지점을 찾아야하는데,가장쉬운방법이 처리시간이 오래걸리는 작업을 식별하는것
	가능하면 모니터링도구로 측정하는게 유용함(로깅도 괜찮음)
	보통 db나 api연동에서 발생하는편임
	
  2.수직확장과 수평확장
    성능문제를 일으키는 원인을 찾았다면,개선안을 빠르게 도출해야함
	근본을 해결하는것도 중요하지만,일단 급한불부터 꺼야함
	
	가장 편한건 수직확장임(스케일업),즉 현재 서버를 비싼거로 교체하는것
	클라우드서비스에선 이게 젤 빠름,db나 서버나 상관없이 올리기도 쉽기도 하고
	대신 비싸고 임시땜빵밖에 되지않음,트래픽은 계속 증가하는데,사양은 계속 올릴수없기때문
	
	그래서 사용되는게 수평확장임(스케일아웃),이건 서버를 추가해 tps를 올리는것
	이건 스테이트리스 서버를 확장할땐,로드밸런서만 추가하면 쉽게 늘이고 줄일수있다는 장점이 있고,가격도 비싸지않음	
	단,문제가 서버라면 괜찮은데,병목지점이 db라면 조심해야함
	db에 부하가 있는 상황에서 서버를 늘려버리면 더 부하가 커지고,성능문제가 악화되기때문
	또한 외부api가 문제인경우도 서버를 늘려봐야 효과가 없음

  3.db커넥션 풀
    db를 사용할땐 3가지 단계를 거침
	  db에 연결
	  쿼리실행
	  연결 종료
	그런데 이 연결을 생성하고 종료하는데 걸리는 시간이 0.5초에서 1초로 매우 길기때문에,요즘은 연결을 이미 몇백개씩 맺어두고 가져다쓰는 커넥션풀을 사용함
	
	커넥션풀을 사용할때는 다양한 설정이 있는데
	  커넥션풀 크기(최소,최대크기)
	  풀에 커넥션이 없을때 커넥션을 구할때까지 최대 대기시간
	  커넥션의 유지시간(최대유휴시간,최대유지시간)
	가 있음
  4.커넥션풀 크기
    커넥션풀 크기는 커넥션풀에 미리 생성해둘 커넥션갯수를 지정하는 설정임
	이건 가장 중요한 설정임(커넥션 갯수가 TPS와 직결되기때문)
	
	또한 요즘은 최소크기,최대크기로 TPS를 초과하는 요청이 생기면,점차 커넥션을 늘려가고,일정시간안쓰면 줄이는 방식으로 하기도함
	또한 트래픽은 시간대별로 가장 높은 시간대가 있고,이때 맞춰서 갯수를 변경할수도있음
	
	만약 트래픽이 순간적으로 급증하는 패턴을 보인다면,커넥션풀의 최소크기를 최대크기에 맞추는게 좋음
	트래픽이 점진적으로 증가하면 조금씩 늘려가는게 효과가 있지만,갑자기 튄다면 db연결시간도 성능저하의 주요원인이 될수있기때문
	
	커넥션풀을 무조건 크게하면 좋을거같지만,커넥션으로 뭘 처리하는거 자체가 db에 부하를 거는거라서,
	db에 부하가 너무 클경우에는 오히려 커넥션풀을 줄여서 db서버가 포화상태에 이르지않도록 해야함
	서버를 스케일아웃하는것도 커넥션풀크기를 늘리는것과 같은 맥락임(서버가 늘어나면 처리할수있는 커넥션갯수가 늘어나니) 

  5.커넥션 대기시간
    대부분 커넥션풀은 대기시간을 설정할수있음
	이건 풀에 사용할수있는 커넥션이 없을때 얼마나 기다릴지임
	이걸 초과하면 db연결실패 에러가 나게됨
	
	기본값은 보통 30초인데,이건 최악의경우 응답시간이 30초라는것
	그래서 이건 보통 0.5초나 3초내로 지정하고 빠르게 에러띄우는게 나음
	무응답보단 에러가 낫기때문
	
	에러를 띄우면 커넥션 요청 자체가 무효가 되지만,무응답의 경우 사용자가 계속 새로고침하면 횟수마다 요청이 계속 쌓이게됨
	즉 계속 에러를 띄우면서 요청자체를 처리하는게 훨씬 더 응답처리시점에선 낫다는것

  6.최대유휴시간,유효성검사,최대유지시간
    보통 일정시간이상 상호작용이 없으면 자동으로 연결을 끊는 기능을 db들은 제공함
	그래서 커넥션이 일정이상 사용되지않으면 db와의 연결이 끊어지게됨
	이걸 방지하기위해
	  최대유휴시간 지정
	  유효성검사
	기능을 커넥션풀은 제공함
	
	최대유휴시간은 사용되지않은 커넥션풀을 유지할수있는 최대시간을 의미함
	이걸 30분으로 설정하면 30분이상 사용되지않은 커넥션은 종료됨
	즉 db의 비활성화시간보다 짧게 설정하면됨
	최대 유지시간은,커넥션은 이 시점까지만 존재할수있고 이게 지나면 유효하든말든 풀에서 제거됨
	
	유효성검사는 커넥션이 정상적으로 사용할수있는 상태인지를 커넥션을 가져올때나,주기적으로 검사하는 기능임
  7.서버 캐시
    db서버의 확장은 비용이 많이들고,처리량은 늘어나지만 실행시간을 줄어들지않음
	그래서 사용되는게 캐시임
	
	보통 캐시에서 읽는게 db보다 빨라서 자주 사용됨
	이건
	  캐시에서 키에 해당하는 값 조회->있으면 값 사용
	  없으면 db에서 조회
	  키값을 캐시에 저장
	  값사용
	이런식으로 사용됨
	복잡한 계산결과나 외부api 연동결과도 캐시에 보관해서 응답시간을 줄일수있음

  8.적중률과 삭제 규칙
    캐시가 얼마나 효율적으로 사용되는지는 적중률로 판단할수있음
	  적중률=캐시에 존재한 건수/캐시에서 조회를 시도한 건수
	이걸 높이는 가장 간단한 방법은 캐시에 최대한 많은 데이터를 저장하는거지만 현실적으로 메모리땜에 불가능함
	그래서 lru나lfu fifo같은 캐시데이터 삭제방법을 사용함
	또한 캐시에 유효시간을 넣는 방법도 자주사용됨(최신영상이 예전영상보단 자주보는 이런느낌으로)

  9.로컬 캐시와 리모트 캐시
    로컬캐시는 서버프로세스와 같은 메모리를 캐시저장소로 쓰는거고,리모트캐시는 별도 프로세스를 캐시저장소로 사용함
	
	로컬캐시는 간단하고 속도가 빠르지만,용량에 한계가 있고,스케일아웃을 해서 서버가 여러개일때와,서버를 재시작했을때에 캐시가 초기화되는 문제가 있음
	리모트캐시는 캐시크기를 유연하게 확장할수있고 서버를 재시작해도 남아있지만,속도가 느리고(통신해야하니) 뭘 추가해야하니 구조가 복잡해짐
	
	캐시가 작고 변경빈도가 낮다면 로컬캐시로 충분함
	데이터규모가 크다면 리모트캐시를 사용해야함(쇼핑사이트같은거)
	또한 배포가 잦다면 리모트캐시사용을 적극적으로 고려해야함

  10.캐시 사전 적재
    트래픽이 순간적으로 급증하는 패턴을 보인다면,캐시에 미리 데이터를 저장해두는것도 생각해볼수있음
	특정날에 요금정보를 푸시를 날리는데,캐시저장을 이달동안 요금조회를 했어야 저장해두는식이면 캐시적중률이 0%니까 미리 저장해두는 방법도 있음
	이러면 db부하도 줄어들고,적중률도 99%에 가깝게 올릴수있음

  11.캐시 무효화
    캐시를 쓸때 가장 주의해야하는건,유효하지않은 데이터를 적절한 시점에 캐시에서 삭제하는것임
	원본이 바뀌었는데 캐시에 저장된 데이터가 변경되거나 삭제되지않으면 오래된 잘못된 정보를 확인하게됨
	
	캐시에 저장된 데이터의 특성에 따라 캐시무효화시점을 달리해야함
	가격,게시글내용같은 민감한 데이터는 변경즉시 무효화해야하고,이런건 로컬캐시가 아닌 리모트캐시에 보관해야함(다른서버의 로컬캐시관리가 안되니까)
	
	변경에 민감하지않고 데이터가 작다면 유효시간을 설정해서,주기적으로 갱신하는방법을 사용해도됨
	최근 인기글 같은건 좀 늦어도 되니까 만료시간넘기면 갱신되게 해도됨

  12.가비지컬렉터와 메모리 사용
    gc가 있는 애들은 메모리관리를 우리가 안해도되지만,스탑더월드같은 일이 생김
	또한 메모리를 많이사용하고 생성된객체가 많으면 gc가 오래걸림
	
	또한 한번에 대량으로 객체를 생성하는것도 주의해야함
	실질적으로 사용하는 메모리가 현재 총 메모리를 초과해버리면 gc를 해도 계속 메모리가 부족하기때문
	이건 조회범위를 제한해서 한번에 생성되는거 자체를 막아야함
	그래서 사이트들이 구매목록을 3개월,1년단위로 끊어서 보여주는거
	또한 다운로드같은건 스트림을 사용해서 처리해야지,한꺼번에 메모리에올리면 안됨

  13.응답데이터 압축
    응답시간엔 데이터전송시간이 포함됨
	이건
	  네트워크 속도
	  전송데이터 크기
	에 영향을 받음
	서버는 사용자의 네트워크속도를 제어할순없지만,전송되는 데이터크기는 제어할수있음
	그래서 사용되는게 압축임
	압축을하면 응답시간+비용에도 영향을 줘서 적극검토해볼수있음
	
	이 압축은 html,css,js,json같은 텍스트 형식은 효과적이지만,이미지같은 이미 압축된 데이터는 효과가없으니 주의
	또한 방화벽이 압축을 풀수도있는데,서버에서 압축설정을 했는데도 압축이 안되면 방화벽설정을 확인해야함

  14.정적 자원과 브라우저 캐시
    동적자원이 아닌 정적자원의 경우 브라우저 캐시를 사용해서 한번 가져간다음 재사용시키면 트래픽도 줄고 화면도 빨리나옴

  15.정적자원과 CDN
    또한 직접 서버에서 받아가는게 아닌,CDN을 거쳐서 CDN에서 뿌리게하면 훨씬 더 효과적임
	즉 리버스프록시로 cdn을 사용하는거임,cdn은 일정시간마다 오리진서버에서 값을 갱신하고
	
	그리고 cdn과는 상관없지만,정적파일을 관리할때 크기를 주의해야함,특히 이미지같은거 30mb이런거 올리면 비용 개비싸지니까 주의
  16.대기처리
    사용자가 순간적으로 폭증할때(이벤트 등),서버는 증설할수있지만 DB는 증설하기힘듬(늘린다음 다시 줄이기가 힘듬)
	이렇게 잠시 빤짝했다가 다시 트래픽 줄어들면 늘리면 개손해니까..
	
	그래서 그냥 대기표뽑아서 한번에 수용할수있는만큼의 트래픽만 받고 나머지 대기처리해서 순차처리하는게 나음
	이러면
	  서버를 증설하지않고 서비스를 안정적으로 제공가능
	  사용자의 지속적인 새로고침으로 인한 트래픽폭증도 방지할수있음(새로고침하면 순번이 뒤로밀리니까)
	또한 대기제어는 이미 여러 솔루션도 있어서 빠르게 도입도 할수있음
3.성능을 좌우하는 db설계와 쿼리	
*1.성능에 핵심인 db
  풀스캔을 조심하자
*2.조회 트래픽을 고려한 인덱스 설계
  보통은 조회의 실행비율이 가장 높고,이걸 최적화하기위해 인덱스를 사용함
  이때도 트래픽의 규모와 사용되는 패턴(조회기능)에 맞게 인덱스를 추가해야함
  
  예를들어 게시판에서 공지같은 카테고리에 인덱스가 없다면 공지를 찾으려고 매번 풀스캔을 때려야함
  또한 내가 작성한 글 목록 보기같은경우도,글쓴이 인덱스가없다면 매번 풀스캔을 해야함
  
  이런식으로 풀스캔을 피하는게 최우선임
  또한 특정 단어로 검색같은경우 %aaa%라 일반적으로는 풀스캔을 피할수없지만,전문검색기능이나 엘라스틱서치같은걸 쓸수있음

  1.단일인덱스와 복합인덱스
    케이스에 따라 쌓일만한 row의 수를 미리 계산하고,거기에 맞게 인덱스의 규모를 맞춰야함
	단일인덱스 기준으로도 감당이 불가능할정도로 많다면 결국 복합인덱스를 써야함
	즉 사용자기준으로 단일인덱스를 썼는데,이게 ~1000건정도 잡히면 걍 단일인덱스써도 되는데,32000건 잡힌다면 복합인덱스로 범위를 줄여야한다는것
	이떄 주로 추가로 사용되는게 보통 날짜임 

  2.선택도를 고려한 인덱스 칼럼 선택
    인덱스를 생성할땐 일반적으로는 선택도가 높은 칼럼을 골라야함
	즉 여자와 남자같은 성별보단,id같이 유니크의 갯수가 높은걸 고르는식
	물론 카테고리나 배치작업의 상태(대기중인 조회 검색)같이 유니크갯수가 낮아도 조회패턴에 맞다면 고를수있음

  3.커버링인덱스 활용하기
    커버링인덱스는 특정 쿼리를 실행하는데 필요한 칼럼을 인덱스에 전부 넣어두는거임
	이러면 메인테이블 안가도되서 효율이 높음
	
  4.인덱스는 필요한만큼만 만들기
    인덱스를 만들면 
	  반드시 쓰기성능이 나빠짐
	  반드시 메모리와 저장공간을 사용함
	  사용가능하다면 읽기성능이 좋아짐
	그러니 무지성으로 인덱스를 만들면 안됨,사용할거만 만들어야함
	
	또한 새로 추가할 쿼리가 기존인덱스를 타지않는다면,요구사항을 약간 변경해서 타게 할수있을지를 검토해봐야함
	즉 다른 인덱스를 탄다음 그 인덱스에서 스캔을 떄리는방식
	
	또한 같은칼럼을 사용하는 인덱스를 2개추가해봐야 의미없고 낭비니까 지우자

*3.몇가지 조회 성능 개선 방법
  1.미리 집계하기
    조회수나 설문조사결과같은 집계가 필요한건 반드시 정확한 값을 사용자에게 보여줄필요가 없음
	즉 집계를 일정간격마다 미리 해두고,그값을 보여주면됨
	이 방법은 비정규화를 사용하고,약간의 무결성을 포기해서 성능을 올리는 패턴임
	
	또한 추가적으로,현재값에+1하는등의 쿼리를 실행할땐 동시성문제(원자성)를 트랜잭션격리수준에서 원자적으로 처리하는지를 반드시 검증해야함

  2.페이지 기준 목록 조회 대신 id기준 목록 조회방식 사용하기
    페이징시에 limit offset으로 조회를 한다면 가면갈수록 풀스캔을 때려야함(처음에는 그냥 주면되는데,나중엔 그위치까지 가서 줘야하니까)
	
	그래서 게시글id에 인덱스를 걸고,
	페이지를 조회할때 현재 페이지의 마지막 게시글의 id를 기준으로 그것보다 작은거로 조건을 걸고 limit를 사용하면 인덱스를 타고 쉽게 조회할수있음
	또한 다음데이터가 있는지를 알려면,한개를 더읽고 갯수를 세면됨

  3.조회범위를 시간기준으로 제한하기
    자주 쓰이는 방법중 하나는,시간기준으로 조건을 걸어서 인덱스를 사용하는방식이 있음
	보통 기사조회나,주문내역조회(사용자id,주문일자 로 이루어진 인덱스)등에 주로사용되는 패턴임
	이건 페이지 목록조회나 id목록조회보다 쿼리도 단순해지고 성능문제도 안생김
	
	또 다른 패턴으로는,최신 1개만 조회하는것
	이건 청구서나 공지사항등에 주로 사용됨
	이런식으로 줄일수있다면 담당자와 협의해서 기능을 줄이고 구현을 단순화할수있음

  4.전체 개수 세지 않기
    목록을 페이징해서 표시할떈 갯수를 함께 표시하는경우가 많은데,이러면 카운트함수가 들어가야해서 성능이 나빠짐
	꼭 필요한게 아니라면 이걸 실행하지않는방법을 찾아야함(인덱스를 타더라도 조건에 걸린 모든걸 찾아야하고,인덱스를 안타면 풀스캔)
  
  5.오래된 데이터 삭제 및 분리보관하기
    로그같은 쌓이는 데이터는 일정 시간 이후엔 삭제하거나,아니면 분리해서 외부로 빼내는게 좋음
	이러면 데이터개수도 일정하게 유지할수있어짐
	
	이런거의 대표적인예가 로그인시도내역등임

  6.DB장비 확장하기
    DB에 부하가 증가해 성능문제가 발생한다면,일단 스케일업을 하고나서 생각할수있음
	
	그리고나서 스케일아웃도 고려는 할수있음
	이땐 보통 데이터변경은 주DB로,조회는 복제DB로 실행하는식으로 주로 함
	이때 복제DB간 시간차같은거땜에 문제생길수있으니 주의

  7.별도 캐시서버 구성하기
    트래픽이 급격히 증가하면,DB만으로 모든 트래픽을 처리하기 어려워질수있음
	이땐 캐시서버를 구성하는걸 고려해봐야함
	
*4.알아두면 좋을 몇가지 주의사항  
  1.쿼리 타임아웃
    응답시간은 처리량에 큰 영향을 줌
	동시사용자가 증가할때 응답시간이 길어지면 처리량이 감소하는데,거기서 끝나는게 아님
	사용자는 재시도를 할수있고,이거때문에 응답의 갯수 자체가 뛰어버림
	
	이런 상황을 방지하는 방법중 하나는,쿼리실행시간을 제한하는것
	쿼리실행시간을 5초로 제한하면,이걸 넘어가면 에러가 뜨게되는데,이건 사용자입장에선 에러지만,서버입장에서는 해당요청을 정상적으로 처리한것
	이러면 동시요청수의 폭증을 막을수있음
	
	단 이때,기능의 특성에 따라 시간은 다르게 설정해야함
	글조회같은 중요하지않은건 짧게,상품결제같은 중요한건 길게 잡아야함
	결제가 타임아웃나면 후속처리와 정합성이 꺠질수있기때문
  2.상태변경기능은 복제db에서 조회하지않기
    메인-복제 db를 구성했다고 무조건 모든 조회를 복제에서 하면 안됨
	특히 메인으로 변경쿼리를 날리고 나서,그걸 다시 조회할땐 메인에서 해야지,복제db에서 하면 복제까지 걸리는 시간때문에 제대로 갱신되지않을 확률이 있음
	
	또한 트랜잭션문제가 발생할수있음
	
	즉 변경후 조회는 무조건 메인으로 날리기

  3.배치쿼리 실행시간 증가
    한번에 조회하고 집계하는 데이터가 많아질수록 일괄처리 실행시간도 증가함
	문제는 몇시간이 지나도 쿼리가 끝나지않아(메모리사용량이 특정범위를 넘어가서 가상메모리를 사용하게될때 이럼),24시간을 지나서 쿼리가 2개되는 이런경우도 있음
	
	이런문제를 예방하려면 배치쿼리를 지속적으로 추적하고,갑자기 큰폭으로 실행시간이 증가했다면,문제가 되는쿼리를 발견해서 원인을 찾아 해결할수있음
	이때 근본을 해결하기전에 가장 쉽게 땜빵하는게 스케일업이지만,이게 반드시 가능한건 아님
	그래서 사용되는 다른 방법으로는
	  커버링 인덱스 활용
	  데이터를 일정크기로 나눠서 처리
	집계대상칼럼이 인덱스에 포함되어있다면 커버링인덱스를 해서 메인테이블에 접근하지않고 끝낼수도있음
	
	또한 데이터를 날짜같은 범위로 쪼개서 집계한후,그 집계된 데이터를 모아 다시 집계하는식으로 처리할수도 있음

  4.타입이 다른 칼럼 조인 주의
    타입이 다른 칼럼끼리 조인을 할때,타입이 다르다면 인덱스를 타지 못할수도있음
	그래서 이경우엔 두 칼럼의 타입을 맞춰서 비교해야함
	또한 문자열이라도 칼럼의 캐릭터셋이 다르다면 인덱스못탈수있으니 주의

  5.테이블 변경은 신중하게
    데이터가 많은 테이블에 새칼럼을 추가하거나,기존열거칼럼을 변경할땐 매우 주의해야함
	mysql등은 테이블변경시에 새 테이블을 생성하고,원본테이블데이터를 복사한후,복사가 완료되면 새 테이블로 교체함
	이동안은 업데이트,인서트,델리트가 허용되지않기때문에 복사시간동안 서비스가 멈춤

  6.db최대연결개수
    db의 최대 커넥션 갯수를 넘는 api서버의 증설은 아무의미없음,이경우엔 db의 커넥션 갯수부터 늘리고 서버를 늘려야함
	주의할건 db서버가 cpu사용률이 이미 높다면(70%이상) 연결갯수를 늘리면안됨
	이경우엔 캐시서버나 쿼리튜닝등으로 부하를 낮춘다음 갯수를 늘려야함
	
	
*5.실패와 트랜잭션 고려하기
  비정상상황에서의 트랜잭션 처리는 반드시 고려되어야함
  안그러면 일관성에 문제가 생길수있음
  
  자주 발생하는 실수는,트랜잭션없이 여러 데이터를 수정하는것,실수로 트랜잭션을 빼먹거나 했을때 이럴수있음
  db관련코드를 작성할땐 트랜잭션의 시작과 종료 경계를 명확히 설정했는지 반드시 확인해야함
  
  추가적으로,비중없는 사이드이펙트에 해당되는 기능은(회원가입의 가입축하메일발송),실패하더라도 성공시켜야하는경우도 있음
  이렇게 외부api연동과 db작업이 섞이면 트랜잭션처리가 복잡해짐
  
4.외부연동이 문제일때 살펴봐야 할 것들
  연동하는 서비스에 장애가 발생하면 우리 서비스도 영향을 받음
  서비스간 연동이 많아질수록 연동시스템의 품질도 함께 신경써야함
  물론 문제를 완전히 차단하긴 어렵지만,영향을 줄일수는 있음
*1.타임아웃
  외부연동에서 가장 중요한 설정은 타임아웃임
  사람들은 안되면 재시도를 해서 부하를 더 키우기때문
  그래서 요청이 안될거같으면 빠른시점에 종료를 때려야함
  
  일단 외부api로 가는 부하는 어짜피 거기서 문제가 생겼으니 해결되지않을거고
  문제는 내쪽 서버도 요청이 계속 쌓여서 부하가 늘어나서,해당 기능 말고 다른 기능들도 같이 문제가 생기게됨
  
  그래서 사용자요청에 대해 스레드풀같은 자원이 포화되기전에 타임아웃이라도 응답해서,연동서비스문제가 다른기능에 주는 영향을 줄일수있음
  
  1.연결 타임아웃,읽기 타임아웃
    연결 타임아웃은 연결시도 자체가 오래걸리는경우에 나는 타임아웃임
	즉 상대서버에서 시작도 하지않은거
	
	일단 연결이 되면 요청을 전송하고 응답을 기다리는데,이때 타임아웃은 읽기 타임아웃임
	
	연결 타임아웃은 3~5초로 짧게 잡고,읽기 타임아웃은 5~30초로 길게 잡는게 좋음
	또할 읽기타임아웃의 경우,해당 요청은 이미 처리중이기때문에 타임아웃이 난 이후에 처리를 잘 해야함
	애초에 이런일이 잘 안생기게 길게잡는게 좋고
  
*2.재시도  
  외부연동이 실패했다면 처리방법중 하나는 재시도가 있음
  간헐적으로 실패한다면 이걸 사용할수있음
  1.재시도 가능 조건
    단 이때,연동 api를 다시 호출해도 되는 조건인지를 확인해야함
	재시도가 가능한 조건은
	  단순 조회 기능
	  연결 타임아웃
	  멱등성을 가진 변경기능
	임
	
	단순 조회기능은 재시도를 통해 성공확률을 높일 수 있음
	연결타임아웃도 애초에 요청이 안갔으니 괜찮음
	
	단 읽기타임아웃은 이미 요청이 처리되고있는중이기 때문에 중복처리가 될수있음
	그래서 멱등성을 가진 요청만 읽기타임아웃 재시도를 할수있음

  2.재시도 횟수와 간격
    재시도를 무한정 할수는 없음,재시도횟수만큼 응답시간이 증가하는거기때문
	대부분 1~2회정도가 적장함
	
	또한 간격도 바로 날리는거보단,좀 5초정도 뒤에 날리는게 성공확률이 더 높아짐
	여러차례를 할땐 간격을 점진적으로 늘리기도함

  3.재시도폭풍 안티패턴
    재시도는 연동서비스엔 더 큰 부하를 줄수있음
	요청이 n배로 뛰기때문
	재시도를 검토할떈 연동서비스의 성능상황도 함께 고려해야함
	
*3.동시 요청 제한
   연동서비스가 한번에 처리할수 있는 동시요청수보다 더 많은 요청이 들어온다면,내쪽에서 그걸 차단해서 임계치까지의 요청만 보내는게 나음
   나머지는 에러응답을 때리는거임(503)
   이게 벌크헤드 패턴임
  
*4.서킷 브레이커
  외부api가 정상상태가 아니라면,거기로 요청을 보내지않고 바로 에러를 보내는게 나음
  이러면 부하가 줄어드니까
  즉
    연동서비스가 장애라면 바로 에러 응답
	정상화됐다면 연동 재개
  임
  
  서킷브레이커는 누전차단기처럼 동작함
  과도한 오류가 발생하면 연동을 중지시키고 바로 에러를 응답함
  얘는 닫힘,열림,반열림 3개의 상태를 갖고,
    평소엔 닫힘 상태다가,
    실패갯수가 임계치를 넘기면 열림으로 변경
	열림상태에서 일정 차단시간이 지나면 반열림으로 변경
	반열림에서 일부 요청을 보내보고 문제없으면 답힘으로,문제있다면 열림으로 다시 변경
  이런 순서로 동작함	
  
  이렇게 실패를 빠르게 감지하고 문제가 있는 기능을 실행하지않고 중단시키는걸 빠른실패라고 함

*5.외부 연동과 db연동
  1.외부연동과 트랜잭션 처리
    db연동과 외부연동을 같이 처리해야할땐 어떻게 처리할지 알맞게 판단해야함
	  외부연동에 실패했을때 트랜잭션을 롤백
	  외부연동은 성공했지만 db연동에 실패해 트랜잭션을 롤백
	대표적으로 이런 패턴이 있음
	
	트랜잭션 범위안에서 외부연동에 실패했다면,트랜잭션을 그냥 롤백시킬수있음
	단 이때도 읽기타임아웃으로 실패했다면,이걸 따로 보상트랜잭션처럼 어케 처리를 해야함
	이때
	  일정주기마다 두 시스템의 데이터가 일치하는지 확인하고 보정(수동이든 자동이든)
	  성공확인 api가 지원된다면 성공확인 api를 호출(읽기 타임아웃의 경우)
	  취소 api가 제공된다면 취소 api를 호출
	세가지 방법을 사용할수있음
	
	외부연동은 성공했지만 db연동에 실패했다면,취소api로 외부연동을 이전상태로 되돌려야함
	db연동에 실패했기때문에 성공확인api같은건 의미가없음
	만약 그런게 없거나,취소에 실패할수도 있기때문에,일관성이 중요하다면 일정주기로 데이터가 맞는지 비교하는 프로세스를 갖추는게 좋음

  2.외부연동이 느려질때 db커넥션풀 문제
    외부연동이 느려지면,한 요청이 커넥션풀을 오래 점유하게됨
	이러면 커넥션풀이 바닥나기 쉬워짐
	
	만약 db와 무관하게 외부연동을 처리할수있다면,커넥션을 사용하기 전이나 후에 외부연동을 시도할수있음
	단,이경우 외부연동이 트랜잭션밖에서 이뤄지기때문에 트랜잭션커밋이후 외부연동이 실패할경우 롤백이 불가능해지니까,실패한 외부연동에 대한 후처리를 반드시 고민해야함
	보상트랜잭션이나,기능특성에 따라 후보정을 할수도있음
	  
*6.HTTP 커넥션 풀
   HTTP연결도 db처럼 커넥션풀을 사용하면 연결시간을 줄일수있음
   이때 고려할 설정은
     HTTP 커넥션풀의 크기
	 풀에서 커넥션을 가져올때까지 대기하는 시간
	 커넥션을 유지할 시간
   이렇게 3가지임
   
   풀 크기는 연동할 서비스의 성능에 따라 결정해야함
   연동서비스의 성능을 생각하지않고 무턱대고 늘리면,순간적으로 트래픽이 몰릴때 응답시간이 급격하게 느려질수있음
   그래서 우리서비스까지 느려질수있고
   
   대기시간은 커넥션풀을 바로 확보하지못했을때 대기시간인데,보통 1~5초정도 잡으면됨
   
   커넥션 유지 시간은,연동서비스에 맞춰 적절히 설정해야함(Keep-Alive헤더등으로 지정됨)
   이걸 보고 저거보다 좀 작게 해야함
  
*7.연동 서비스 이중화
  서비스가 대량트래픽을 처리할만큼 성장했다면,연동서비스의 이중화를 고려해야함
  이러면 한곳에 장애가 발생해도,다른서비스를 이용해 계속 진행할수있음
  
  물론 이중화는 개발유지비용이 증가하게됨,그래서 연동서비스를 이중화할지 여부를 결정할땐
    해당기능이 핵심기능인지
	이중화비용이 감당가능한 수준인지
  를 따져봐야함
  
  즉 쇼핑의 결제같은정도여야 할만함
  또한 재정적으로 이중화를 감당할수있어야,즉 장애로 인한 손실보다 이중화에 드는 비용이 더작아야함
  
  
5.비동기 연동,언제 어떻게 써야할까 
*1.동기연동과 비동기연동
  동기식으로 만들면 떠올리기도 편하고 만들기도 쉽고 디버깅도 쉽지만,외부연동을 만났을때 실패하면 다른것도 못하게됨
  또한 외부서비스가 느려지면 이후로직들도 전부 영향을 받게됨
  
  그래서 사용되는게 비동기방식임
  비동기를 사용하면 외부서비스를 기다리지않고 바로 다음작업을 진행할수있어짐
  
  생각보다 많은곳에서 비동기를 사용해도됨
    연동에 약간에 시차가 생겨도 문제가 되지않음
	기능이 실패해도 재시도가 가능함
	연동에 실패했을때 수동으로 처리가 가능함
	연동에 실패했을때 무시해도됨
  이 4가지중 일부에 해당한다면 비동기처리를 검토해볼수있음(포인트지급,결제결과반영등)
  
  비동기처리는
    별도스레드로 실행
	메시징시스템이용
	트랜잭션아웃박스패턴
	배치
	CDC
  이렇게 대표적으로 5개가 있음

*2.별도스레드로 실행
  가장 쉬운방법은 스레드로 돌리는것
  매번 스레드를 생성하는게 싫다면,스레드풀을 이용하는방법도 있음
  또한 스프링같은건 @Async같은걸로 비동기실행을 지원함
  비동기로직의 경우 메서드명에 Async같은거로 비동기라는걸 표현해주는게좋음
  
  별도스레드로 실행할땐,연동과정에서의 에러처리를 더 신경써야함
  예외를 던져도 소용이 없기때문(그래서 코드내부에서 예외처리를 직접 처리해야함)
  
  또한 스레드를 많이 생성해야한다면,메모리사용량도 주의해야하지만,스레드풀을 사용한다면 괜찮음(대신 풀을 넘는요청은 대기해야함)
  그리고 비동기로 실행할 코드가 외부api호출이나 db연동등 네트워크io라면 가상스레드나 코루틴같은걸 사용하는것도 괜찮음

*3.메시징
  서로 다른 시스템간에 비동기로 연결할땐,카프카같은 메시징시스템을 중간에 둬서 사용하는것도 좋음
  이러면 양쪽간에 강의존이 끊어지고,서로의 부하가 영향을 주지않아짐(자기가 할수있는만큼만 처리하니까)
  또한 각각 확장하기가 더 쉬워짐
  만약 생산자를 늘리고싶으면 그냥 만들고 카프카에 연결하면되고,소비자를 늘리고싶어도 그냥 만들고 카프카에 연결하면됨
  
  메시징 시스템 기술중 카프카는
    높은 처리량,초당 백만개이상 처리가능
	수평확장이 용이
	메시지를 파일에 보관해서 유실되지않음
	1개의 토픽이 여러 파티션을 가질수있고,파티션단위로 순서를 보장함(단 토픽단위로는 순서를 보장하지않음)
	소비자는 메시지를 언제든 재처리가능
	풀모델을 사용(소비자가 브로커에서 메시지를 읽어감)
  래빗MQ는
    클러스터를 통해 처리량을 높일수있음(단 카프카보다 많은자원을 사용)
	메모리에만 메시지를 보관하는설정을 하면,메시지가 유실될수있음
	메시지는 큐에 등록된 순서대로 소비자에 전송됨
	메시지가 소비자에 전달됐는지 확인하는 기능을 제공
	푸시모델을 사용(소비자성능이 느려지면 큐에 과부하가 걸려 성능저하 가능)
	다재다능함(여러 프로토콜,패턴등을 사용가능)
  레디스pub/sub는
    메모리를 사용해서 지연시간이 짧고,래빗MQ대비 처리량이 높음
	구독자가 없으면 메시지가 유실됨
	영구메시지가 없음
	모델이 단순함
  대충 이런 특징들이 있음
  
  메시지가 유실되어도 상관없다면 레디스pub/sub을 사용할수있음,성능이 좋고 사용법이 쉬움
  대량트래픽 발생할땐 카프카(초당 수백만 메시지)
  트래픽이 크진않지만 메시지를 정확하게 순서대로 소비자에게 전달해야하거나,AMQP나 STOMP프로토콜을 사용해야하면 래빗MQ
  
  1.메시지 생성측 고려사항
    메시지를 생성할떄 고려할점은 메시지유실이 있음
	타임아웃등으로 메시지가 가지않을경우
	  무시한다
	  재시도한다
	  실패로그를 남긴다
	3가지중 하나를 골라야함
	메시지가 유실되어도 상관없다면 무시할수있고(로그등)
	일시적인 네트워크불안정이라면 재시도를 할수있음,단 이경우 중복메시지전송이 될수도있음,그래서 브로커가 못걸러준다면 소비자가 알아서 처리해야함(id등 사용)
	로그를 남겨서 나중에 후처리를 시도할수도 있음,이때 실패로그는 후처리에 필요한 데이터를 담고있어야함
	
	메시지 생성자는 db트랜잭션과의 연동도 고려해야함,db트랜잭션에 실패했는데 메시지가 발송되면 잘못된 데이터가 전달될수있음
	그래서 트랜잭션이 끝난후에 메시지를 전송해야함

  2.메시지 소비측 고려사항
    소비자는 2가지 이유로 동일메시지를 중복처리할수있음
	  생산자가 같은 데이터를 가진 메시지를 메시징시스템에 두번 전송
	  소비자가 메시지를 처리하는 과정에서 오류가 발생해서 메시지 재수신
	생산자가 같은데이터메시지를 두번던지면 두번 처리하는것과 같음
	물론 id등으로 확인해서 거를수있긴함
	이때 메시지처리여부는 db로 넣거나 하면됨
	
	메시지 재수신이 가능한경우,소비자가 메시지를 처리할때 에러가 발생하면,재처리를 위해 메시지를 다시 수신할수있음
	단 이때 중복처리가 되지않도록 멱등성을 가지게 api를 구현해야함
	
	중복메시지처리와 함께 메시지 소비자를 구현할떄 고려할점은,메시지를 잘 소비하고있는지 모니터링하는것
	갑자기 소비자처리속도가 느려진다면,큐에 메시지가 계속 쌓이게됨,이러면 큐가 가득찰수도 있고,이러면 생산자까지 영향을 받게됨

  3.메시지종류:이벤트와 커맨드
    이벤트는 어떤 일이 발생했음을 알려주는 메시지임,즉 주문을 했다,배송을 완료했다 이런게 이벤트임	
	즉 이벤트 트리거를 위해 날리는것,뭘 처리할지는 소비자맘임
	
	커맨드는 뭔가를 요청하는 메시지임,포인트를 지급해라,배송완료문자를 발송해라 이런게 커맨드임
	이건 수신측의 기능실행에 초점이 맞춰져있음,즉 수신자가 정해져있음(생산자가 소비자를 선택해서 날린다는뜻)
	반면 이벤트는 정해진 수신자가 없고,받은애가 알아서 생각해서 필요하면 쓰는거임
	
	이벤트는 소비자확장에 적합함,받는애들이 알아서 처리하니까 걍 소비자만 만들어서 붙이면됨
	보통 이벤트가 선호되는듯?

*4.트랜잭션 아웃박스패턴
  잘못된 메시지 발송을 막으려고 db트랜잭션이 완료된 이후 메시지를 전송할수있지만,이거로는 완벽하지않음
  메시징시스템 연동 자체가 실패할수있기때문
  
  그래서 메시지 데이터 자체를 일단 db에 저장해두고,그 뒤에 이 메시지들을 읽어 메시징시스템에 전송하는 방식이 트랜잭션 아웃박스 패턴임
  즉 이 패턴은 한 트랜잭션 내에서
    실제 업무 수행
	메시지데이터를 아웃박스 테이블에 추가
  하는 두가지 일을 처리하는것
  또한 쌓인 메시지 데이터는,별도의 중계프로세스가 주기적으로 메시징시스템에 전송하는 구조임
  
  이 패턴을 사용하면 메시지데이터가 유실되지않고,트랜잭션을 롤백하면 메시지데이터도 롤백되니 잘못된 메시지데이터가 전송될일도 없음
  이때 중계프로세스가 메시지를 전송하는데 실패하면 메시지전송루프를 멈추는데,이건 메시지를 순서대로 발송하기 위해서임
  순서가 중요하지않다면 예외처리하고 계속해도됨
  
  만약 순서가 중요하다면 발송상태칼럼을 두고 이 칼럼으로 조회해서 메시지를 던지던가,
  마지막 메시지id를 기록해두고 이 id 이후의 메시지만 던지는식으로 할수있음
  
  1.아웃박스 테이블 구조
    이건 그냥 아웃박스테이블을 어케짜냐임,책보자

*5.배치전송
  배치는 데이터를 비동기로 연동하는 가장 전통적인 방법임
  메시징이 실시간에 가깝게 데이터를 연동한다면,배치는 일정 간격으로 데이터를 전송함
  즉 결제 승인 데이터를 다음날 보내거나,택배발송요청 데이터를 1시간간격으로 보내는식임
  
  배치의 실행과정은
    db에서 전송할 데이터를 조회
	조회한 결과를 파일로 기록
	파일을 연동시스템에 전송
  보통 이런방식으로 실행됨
  
  파일은 보통 json으로 보내는경우가 많지만,이경우는 데이터크기가 커지기 쉬워서 그냥 구분자로 구분하는경우도 있음
  또한 이때 형식 이외에도 송수신주체(업로드로 올려줄지,다운로드로 받아갈지),시간(언제까지 줄지),경로등을 함께 정해야함
  
  생산자가 소비자로 파일을 업로드할때,소비자는
    지정된 경로에 파일이 존재하는지 확인
	존재한다면 파일로부터 데이터를 읽음,파일이 없다면 알맞게 후처리	
	읽어온 데이터를 시스템에 반영
	처리를 완료한 파일은 다른폴더로 옮김
  이런 루틴을 타게됨
  이 루틴은 파일을 업로드하는 시간을 기준으로 이걸 실행하게됨(8시에 업로드한다면 8시30분에 처리하는식)
  
  파일 말고도 api로 데이터를 전송하거나,읽기전용으로 db를 열어주는경우도 있음
  
  1.재처리기능 만들기
    파일을 지정시간에 전송하지못할수도있음
	파일을 생성하는과정에서 오류가 발생하거나,네트워크 상태가 좋지않아 전송하지 못하는경우 등등
	
	어떤 이유에서든 전송에 실패하면,일정시간후에 재전송하는 기능을 구현해두는게 좋음
	한두번정도만 재시도해도 수작업을 할일이 많이 줄어듬
	
	재시도를 해도 실패하는 경우도 있는데(9시30분에 처리하는데 2시에 전송하면 처리는 실패),이럴때를 대비해서 수동배치실행방법을 만들어두면 편함


*6.CDC(체인지 데이터 캡쳐)
  이건 변경된 데이터를 추적하고 판별해서,변경된 데이터로 작업을 수행할수있게 하는 패턴임
  즉 db의 데이터변경시 이걸 통지하는 기능을 사용해서,cdc처리기에서 그 데이터를 받아서 대상시스템에 맞게 처리하는 방식임
  
  cdc는 커밋된 데이터만 변경된 순서에 맞게 전달됨
  순서가 틀리거나 롤백된 데이터같은건 들어오지않음
  또한 변경데이터는 레코드 단위로 전달됨
  
  이떄 cdc처리기는 크게 2가지 형태로 대상시스템에 데이터를 전파함
    변경데이터를 그대로 전파
	변경데이터를 가공,변환후 전파
  그대로 전파하는건 두 시스템의 데이터가 1대1관계를 가질때 적합함(회원시스템에서 회원의 이름을 변경할떄,컨텐츠시스템에서도 회원의 이름칼럼이 같이 변경)
  
  변환후 전파의 경우,조금 다르게 처리해야할때(주문시스템과 통지시스템)에 적합함
  주문상태가 배송중으로 변경되서 알림을 날릴때 모든 주문데이터를 던질필요는 없으니까 이럴땐 주문id와 변경된 주문상태만 던지는식임  
  
  또한 단순히 시스템간 데이터 동기화가 목적이라면,db와 db사이에 cdc를 두어 데이터를 복제할수있음
  그리고 메시징시스템에 데이터를 전파하면,여러 시스템에 변경된 데이터를 한꺼번에 전달할수도 있어 확장에 유리함
  
  1.cdc와 데이터위치
    cdc처리기는 변경데이터를 어디까지 처리했는지 기록해야함
	이걸 기록하지않으면 마지막로그데이터로부터 읽어야하는데,이경우 cdc처리기를 재시작하는동안 발생한 변경데이터를 놓치게됨

  2.cdc가 유용할때
    cdc는 시스템이 복잡해서 연동코드를 넣기 부담스러울때 유용함
	실제 코드와는 별개의 영역(db)에서 사용할수있기때문


6.동시성,데이터가 꼬이기전에 잡아야한다
*1.서버와 동시 실행
  서버는 반드시 비동기로 돌아가게됨
  이때 클라마다 스레드를 할당하냐,비동기io로 처리하냐의 차이일뿐임
  
  그래서 서버는 항상 동시실행을 고려하고 만들어야함
  
*2.잘못된 데이터 공유로 인한 문제 예시
  싱글톤객체는 상태가 있으면 안됨
  이런 빈같은 객체들은 stateless로 동작해야함
  
  또한 db도 동시성을 고려하지않으면 동시성문제에서 자유롭지않음

*3.프로세스 수준에서의 동시접근 제어
  동시성문제는 프로세스수준과 db수준 모두에서 검토되어야함
  이건 프로세스단에서의 동시접근 제어방식임,즉 서버가 여러대일때는 고려되지않음
  1.잠금을 이용한 접근제어
    프로세스수준에서 데이터를 동시에 수정하는걸 막는 일반적인 방법은 잠금을 사용하는것(뮤텍스)
	즉
	  잠금을 획득함
	  공유자원에 접근
	  잠금을 해제함
	순서로 일을 처리하는거
	
	잠금은 한번에 한 쓰레드만 획득할수있음
	또한 자바에서 잠금은 synchonized나 ReentrantLock등을 사용해서 락을 걸수있음

  2.동시접근제어를 위한 구성요소
    ReentrantLock는 한번에 1개스레드만 잠금을 구할수있음
	그래서 동시접근을 막는게 아닌 제어하고싶을땐 세마포어나 읽기쓰기잠금등이 있음
  3.세마포어
    세마포어는 동시에 실행할수있는 스레드수를 제한함
	자원에 대한 접근을 일정수준으로 제한하고싶을때 세마포어를 사용할수있음
	세마포어는
	  세마포어에서 퍼밋획득(허용가능숫자1감소)
	  코드실행
	  세마포어에 퍼밋 반환(허용가능숫자 1증가)
	순서로 진행됨
	
	읽기쓰기잠금은 읽기와 쓰기의 잠금을 서로 다르게 처리하는 방식임
	읽기의 경우 동시실행해도 문제가 되지않으니,쓰기를 할때만 통제하자는 방식임
	즉 이건
	  쓰기잠금은 한번에 한 스레드만
	  읽기잠금은 한번에 여러스레드
	  한 스레드가 쓰기잠금을 획득했다면 쓰기잠금이 해제될때까지 읽기잠금을 구할수없음
	  읽기잠금을 획득한 모든 스레드가 읽기잠금을 해제할떄까지 쓰기잠금을 구할수없음
	이런식임

  4.원자적 타입
    잠금은 cpu효율이 떨허짐
	그래서 사용되는게 원자적 타입임(AtomicLong등)
	이건 다중스레드 환경에서 동시성문제없이 여러스레드가 공유하는 데이터를 변경할수있음

  5.동시성 지원 컬렉션
    스레드에 안전하지않은 컬렉션을 여러 스레드가 공유하면 동시성 문제가 발생할수있음
	그래서 사용되는게 동기화된컬렉션임(ConcurrentHashMap)


*4.db와 동시성
  db트랜잭션은 여러 조회나 쓰기를 하나의 연산으로 묶고,여기안에 있는 모든 연산은 모두 커밋되거나 모두 롤백됨
  단,이 트랜잭션만 가지곤 모든 동시성문제를 해결할순없음
  db를 동시수정할때등으로 생기는 문제가 있기때문
  이럴땐 락을 사용해야함
  
  1.비관적 락
    비관적락은 먼저 접근한 트랜잭션이 잠금을 갖는 방식임
	mysql에서는 for update를 붙인 조회쿼리를 날리면,거기에 해당하는 레코드들이 락이 걸리는 방식임
	이렇게 잠금을 획득했다면,잠금을 해제할때까지 다른 트랜잭션은 동일 레코드에 대한 잠금을 획득하지못하고 대기해야함
	이 잠금은 트랜잭션이 종료될때 반환됨
	
	즉 for update끼리 서로 경합이 붙어서 먼저따낸애가 가져가는식으로 동작함
	그래서 한쪽이 수정을 했다면 다음애는 그걸 못찾아서 실패하는식으로 구현하면됨

  2.낙관적 락
    이건 db랑 상관없이 데이터를 조회한 시점의 레코드 버전과,업데이트하는시점의 레코드 버전을 비교해서 같은지 확인하는식으로 처리함
	즉 이건 프로세스단에서의 락임
	
	이건  update가 1개 이상 됐는지 안됐는지 리턴받는걸로 트랜잭션을 커밋할지 롤백할지 정하면됨

  3.외부연동과 잠금
    트랜잭션 범위 내에서 외부연동을 해야한다면,비관적락을 쓰는게 더 나음
	이러면 db변경을 하고나서 외부연동이 실패했을때 롤백하기가 훨 더 편함
	
	만약 낙관적락을 써야한다면(성능등의 이유로),트랜잭션 아웃박스 패턴을 적용하는 방법도 있음

  4.증분쿼리
    특정 레코드의 값을 1 올리는식의 로직을 조회한값+1등으로 하면,동시에 조회하고 업데이트했을땐 1밖에 안올라가는 문제가 있을수있음
	이걸 해결하기위해 비관적락을 사용할수도 있지만,응답시간이 길어짐
	
	그래서 대신 증분쿼리를 사용할수도있음
	  update table set count=count+1 where id=3
	이런식으로 날리면,원자적연산으로 쿼리가 처리되기때문에 누락되지않음(단 db에따라 다를수있음)
	
*5.잠금 사용시 주의사항
  1.잠금해제하기
	잠금을 획득한 후에는 반드시 잠금을 해제해야함
	이건 세마포도 마찬가지임
	
	그래서 try-finally로 반드시 해제해주는게 젤 편함

  2.대기시간 지정하기
    락을 쓸땐 타임아웃을 거는게 좋음
	오래 대기하는거보단 빠르게 실패하는게 나음

  3.교착상태 피하기
    만약 두가지 이상의 테이블에 대한 잠금이 필요한 로직이 있고,다른로직에서도 똑같은 테이블들을 락하는 로직이 있다고 했을때,
	두가지 테이블을 락하는 순서를 동일하게 맞춰야 교착상태에 빠지지않음
	
	그리고 실수할수도 있으니,락을 쓸땐 타임아웃을 반드시 걸자

*6.단일스레드로 처리하기
  동시성문제가 발생하는 주된이유는,여러스레드가 동시에 동일자원에 접근하기때문
  그래서 이걸 방지하기위해 잠금같은걸 쓰는거
  
  그래서 아예 단일스레드로만 접근하게하면 동시성문제가 발생하지않음(단 서버가 스케일아웃되면 똑같음 이것도)
  단일스레드는 동시성문제에서 자유로워지지만,구조는 복잡해지니 이것도 고려해야함
  
  논블로킹이나 비동기io를 쓸땐 블로킹을 최소화해야하므로 단일스레드 처리방식이 적합함
  
  또한 단일스레드로 성능이 충분할지는,동시에 실행할 작업갯수와 임계영역의 실행시간에 따라 달라지니 이것도 알아보고써야함

7.IO병목,어떻게 해결하지
*1.네트워크 IO와 자원효율
  서버에서의 많은 작업들은 네트워크를 통해 데이터를 주고받는 과정임
  이때 데이터를 보내고 받는동안 코드를 실행하는 스레드는 데이터전송이 완료될때까지 대기하게됨
  즉 입출력이 끝날때까지 스레드가 블로킹됨
  보통 입출력시간은 코드실행시간보다 훨씬 길어서,이렇게하면 처리량이 매우 줄어듬
  
  그래서 스레드를 늘려서 해결해볼수도 있지만,스레드를 직접 만들게되면 스레드의 메모리사용량때문에 이번엔 메모리가 병목에 걸리게됨
  추가적으로 동시실행되는 스레드가 증가하면 컨텍스트스위칭 코스트때문에 효율도 낮아지게되고
  
  그렇지만 대부분의 서비스들은 이런 서버의 자원낭비를 걱정할필요가 없음
  수백만에서 수천만이상의 고객이 사용하는 서비스에서나 cpu나 메모리자원부족이 눈에뛰지,그전까진 괜찮기때문
  
  서비스가 인기를 끌기 시작하면 트래픽이 증가하고,이때부터 처리량을 더 높이기위한 방법을 고민하면됨
  가장 쉬운건 스케일아웃이나 스케일업임
  
  또 다른 방법으로는 자원효율을 높이는것
  즉 가상스레드나 코루틴등을 사용해서 경량스레드를 사용하거나,비동기io를 사용할수있음

*2.가상스레드로 자원효율 높이기
  가상스레드나 코루틴은 경량스레드로,경량스레드는 jvm같은 언어의 런타임이 관리하는 스레드임
  즉 스레드풀을 만들고,그안에서 cpu쓰는거처럼 스위칭해가면서 돌리는것
  
  가상스레드는 플랫폼스레드보다 더 적은 자원을 소모함(특히 메모리)
  1만개의 플랫폼스레드가 10gb의 메모리를 차지한다면,1만개의 가상스레드는 28mb의 메모리만 사용함
  또한 스레드를 생성하는 시간도 많이 차이가 남
  
  1.네트워크IO와 가상스레드
    가상스레드를 실행하는중에 블로킹되면,플랫폼스레드와 언마운트되고 실행을 멈춤
	이때 플랫폼스레드는 실행대기중인 다른 가상스레드와 연결한후 그걸 실행함
	즉 cpu스케줄링하는거처럼 하는거

  2.가상스레드와 성능
    IO중심 작업의 경우 가상스레드를 사용하면 효과가 매우 크지만,cpu중심의 작업의 경우 가상스레드를 써봐야 별차이없음
	또한 가상스레드는 플랫폼스레드의 갯수보다 더 양이 많아야 효과가 나지,작으면 별의미없음(그냥 진짜 쓰레드쓰면되니까)
	
	그래서 이런경우,부하가 작다면 cpu코어를 줄이는방법도 생각해볼수있음
	
	가상스레드를 사용해서 높일수있는건 처리량뿐임
	이걸 쓴다고 실행속도가 당연히 올라가진않음

  3.가상스레드의 중요한 장점
    가장 중요한점은,기존코드를 크게 수정할필요가 없다는것
	보통 좀 큰 라이브러리들은 가상스레드를 지원하고있기때문

*3.논블로킹IO로 성능 더 높이기
  가상스레드를 사용하면 io중심작업을 하는 서버의 처리량을 높일수있지만,이거 자체도 메모리를 사용하고 스케줄링이 필요함
  그래서 사용자가 폭발적으로 증가하면 가상스레드로도 한계가 옴
  이땐 논블로킹io를 사용해야함
  
  1.논블로킹IO동작 개요
    논블로킹IO는 입출력이 끝날때까지 스레드가 기다리는게 아닌,바로 다음코드를 실행함
	즉 루프내에서 조회를 반복해서 호출하고,데이터를 읽었을때만 처리하는 방식으로 구현할수있음
	단 이렇게하면 메모리낭비가 심하기때문에,읽기를 바로 시도하기보다 어떤 연산을 할수있는지를 확인하고 해당연산을 실행하는식으로 구현함
	  실행가능한 io연산의 목록을 구함
	  구한 io연산의 목록을 차례대로 순회하며 처리
	  이걸 반복
	이런순서임
	
	논블로킹IO는 접속자수와 상관없이 스레드수를 일정하게 유지할수있어,같은 메모리로 더 많은 클라연결을 처리할수있음
	
	논블로킹IO를 1개스레드로 구현하면 동시성이 떨어져서,채널을 n개의 그룹으로 나누고 각 그룹마다 스레드를 생성하는게 자주쓰임
	즉 cpu갯수만큼 그룹을 나누고,각 그룹마다 입출력을 처리할 스레드를 할당하는식으로 동시성을 높일수있음

  2.리액터 패턴
    리액터 패턴은 논블로킹IO를 사용해서 구현할때 사용하는 패턴으로,이건 동시에 들어오는 여러 이벤트를 처리하기위한 이벤트 처리방법임
	
	리액터는 리액터와 핸들러로 구성되고,
	리액터는 이벤트가 발생할때까지 대기하다가 이벤트가 발생하면 알맞은 핸들러에 이벤트를 전달함
	이벤트를 받은 핸들러는 필요한 로직을 수행함
	
	리액터는 이벤트를 대기하고 핸들러에 전달하는 과정을 반복하는데,그래서 이벤트루프라고도 부름
	
	이벤트루프는 단일스레드로 실행되는데,이때 처리량문제로 스레드풀로 돌리기도함

  3.프레임워크 사용하기
	논블로킹IO를 직접 구현하면 주고받는데이터 형식이 조금만 바뀌어도 저수준코드를 처리해야함
	그래서 이런걸 직접 구현하기보단 프레임워크쓰는게 나음(리액터 네티등)

  4.논블로킹/비동기IO와 성능
    논블로킹IO를 사용하면 동시접속자를 20배정도 늘리는식의 성능향상을 기대할수있음


*4.언제 어떤 방법을 택할까
  논블로킹IO나 가상스레드나 적용하기전에
    문제가 있나?
	문제가 있다면 네트워크IO관련 성능문제인가?
	구현변경이 가능한가?
  이 3가지를 반드시 검토해야함
  
  성능문제가 없다면 바꿀필요가 없음,시간낭비임
  성능문제가 있다면 네트워크문제인지를 먼저 확인해야함
  db문제거나라면 저런거해도 의미없고,쿼리최적화를 하거나 캐시를 사용해야함
  또한 cpu중심작업도 의미없음
  
  문제가 네트워크IO라면 구현변경이 가능한지를 따져봐야함
  만약 가상스레드를 적용가능하다면 이거만해도 메모리사용률을 줄일수있음
  
  만약 우선순위에 밀린다면,스케일업이나 스케일아웃으로 처리한후에 나중에 해야함

8.실무에서 꼭 필요한 보안지식




























  
  
  
  
  
  
  
  