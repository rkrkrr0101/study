1.소개
  1.설계와 아키텍처란?
	소프트웨어 아키텍처의 목표는 필요한시스템을 만들고 유지보수하는데 투입되는 인력을 최소화하는것
  2.두가지 가치에 대한 이야기
	소프트웨어는 기계가 수익을 창출하거나 비용을 절약하게 만들어줌
	이떄 소프트웨어는 변경하기쉬워야하고,이해관계자가 생각을 바꾸면 이 변경사항을 간단하고 쉽게 적용할수있어야함
	그리고 변경사항을 적용할때의 어려움은 범위에 비례해야하고,형태와는 연관이 없어야함
	
	긴급함과 중요함을 잘 생각해야함
		긴급하고 중요한
		긴급하지않지만 중요한
		긴급하지만 중요하지않은
		긴급하지도 중요하지도 않은
	이 순서대로 일을 처리해야지,3번째인 긴급하지만 중요하지않은게 위로 올라가면안됨
	
	
2.프로그래밍 패러타임
	프로그래밍 패러다임은 모두 프로그래밍을 할때 제약을 부과함
		구조적프로그래밍:goto(직접문맥전환)의 금지
		객체지향프로그래밍:간접문맥전환에 대한 규칙부과
		함수형 프로그래밍:할당에 대한 규칙을 부과(가변성)
	즉 무언가를 쓰기 힘들게 만드는게 목적임,즉 너무 많은 권한을 제거해서 생각할걸 줄여주는것
  1.구조적 프로그래밍
	모든 프로그램은 순차,분기,반복 3가지만으로도 표현할수있음
	구조적프로그래밍의 핵심은,모듈을 증명가능한 더 작은단위로 재귀적으로 쪼갤수있다는것
	즉 요구사항을 고수준의 기능들로 쪼개고,기능을 더 작은 함수들로 쪼갤수있다는것임
	또한 수학적이 아닌 과학적증명으로,서술이 참임을 증명하는게 아닌 거짓임을 증명하는식(테스트)로 진행됨
	
	구조적 프로그래밍의 기능적분해가 아키텍처관점에서는 최고의 실천법중 하나임
  2.객체지향 프로그래밍
	객체지향의 핵심은 다형성임
	캡슐화와 상속은 객체지향이 아니라도 구현할수있는데,다형성의 경우 구현할수없고 객체지향에서 제일 메인이 되는 규칙임
	절차지향에서도 가능하긴하지만(포인터를 통해),특정관례를 수동으로 따르는방식이라 좀 위험하고,이런식으로 생긴 버그는 찾기가 어려움
	
	다형성을 사용하면 dip를 만들수있고 이게 객체지향의 핵심임
	즉 상위가 하위의 구현에 대해 직접적으로 얽매이지않고,상위가 생성한 인터페이스에 대해 하위가 의존하는식으로 의존성을 역전시킬수있다는게 핵심임
	이러면 하위의 구현의 수정이 일어나도,인터페이스가 바뀌지않으니 상위코드에 수정이 필요없는식
	또한 상위에 수정이 일어나도 인터페이스를 바꾸지않으면 하위도 신경쓸필요없음
	
	이러면 아키텍트는 소스코드의존성의 방향에 대한 절대적인 권한을 가지게됨
	이러면 상위든 하위든 db든 ui든 전부 인터페이스의 플러그인처럼 동작하게되고,전부 독립적으로 배포할수있어지고,그러면 전부 독립적으로 개발할수있어짐

  3.함수형 프로그래밍
	함수형의 핵심은 람다와 재할당불가(val)임
	함수형 프로그래밍 언어에선 변수의 재할당을 할수없음
	이걸로 인해 얻는게 많은데,이러면 동시성문제들의 거의 대부분이 사라짐
	
	이를 통해 얻을수있는 교훈은,어플리케이션을 구조화할땐 변수를 변경하는 컴포넌트와 변경하지않는 컴포넌트를 분리하고,
	가능한 많은 처리를 불변컴포넌트로 옮겨야함
	
	함수형처리의 다른방식으로는 이벤트소싱이 있음
	저장공간과 처리능력의 한계가 매우커지니,그냥 상태를 저장하지않고 모든 트랜잭션을 저장하고,
	필요할때 모든트랜잭션을 실행하는식으로 상태를 가져오는거임
	이러면 가변변수가 하나도 필요없고,중간에 스냅샷을 만들어서 최적화도 가능함
	이러면 crud가 아닌 cr만 수행하면됨 또한 그래서 변경과 삭제가 발생하지않으니 동시업데이트문제도 발생하지않음
	즉 이방식은 git와 같은방식임
	

3.설계원칙
	solid의 목적은 중간수준(모듈보단 하위 코드보단 상위,클래스나 메서드수준)의 소프트웨어가
		변경에 유연하고
		이해하기쉽고
		많은 소프트웨어 시스템에 사용할수있는 컴포넌트의 기반이 되게
	만드는것임
	
  1.단일책임원칙(SRP)
	이건 하나의 모듈의 변경이유는 오직 하나뿐이어야한다는것
	즉 하나의 모듈은 하나의 액터에 대해서만 책임져야한다는것
	
	이게 깨진 징후는
		우발적중복:여러사람이 한 클래스에다가 각기 다른곳에서 사용하기위해 메서드를 추가,즉 서로 다른이유로 추가된애들이 프라이빗메서드를 공유할때
			변경시에 다른곳에 사이드이펙트를 주는것
		병합:서로 다른 팀에서 다른이유로 같은 코드를 수정할때 컨플릭트가 발생,즉 다른액터가 둘이상 있다는것
	즉 서로 다른 사람들이 서로 다른목적으로 같은 코드를 건드리려할때 srp가 깨진것
	
	이문제의 해결법은 그냥 전부 째서 다른클래스로 분할시키고,꼭 같은곳에 있어야한다면 퍼사드패턴을 사용하는것
	이떄 분리할때는 자신의 메서드에 반드시 필요한 소스코드만 포함해야함,그리고 각 클래스들은 서로의 존재를 몰라야함(의존성이 없어야함)
	
  2.개방-폐쇄원칙(OCP)
	소프트웨어는 확장은 가능해야하고,확장할때 코드를 수정하지않아야함
	즉 추가적으로 뭘 붙여야하거나 할때,기존코드를 건드리지않고 추가할수있어야함
	단일책임원칙과 의존성역전원칙을 사용해서 결과적으로 이렇게 되어야하는것
	
	이거의 핵심은 책임의 분리임,각 행위들은 하나의 일만 해야함(보고서용 데이터생성과 데이터를 받아서 보고서생성 이런식으로)
	그리고 비즈니스로직을 의존해야지 비즈니스로직이 의존하면안됨(비즈니스로직과 의존성객체는 분리되어서 복잡한코드가 나오면안됨)
	이때 인터페이스를 사이에 끼워두면,양쪽에 대한 변경에대해 서로가 안전해지게됨

  3.리스코프 치환 원칙(LSP)
	상위타입대신 하위타입을 넣어도 행위가 변하지않아야함
	대표적으로 직사각형 정사각형문제
	이게 깨지면 정말 머리아파짐,하위타입을 그냥 가져다가 상위타입처럼 쓰는게 불가능해지기때문(하위인스턴스종류를 계속 체크해야함)
	이게 깨지면 이것만을 위한 메커니즘이 대량으로 추가돼버림

  4.인터페이스 분리 원칙(ISP)
	모든 클래스는 자기가 사용할 인터페이스만 생성하고,의존해야함
	만약 여러 클래스가 서로 다른 메서드를 사용하는데,둘다 한 인터페이스를 의존한다면 자기와 상관없는 일때문에(상대방의 수정)자기도 수정되어야함
	이때는 인터페이스를 서로 분리시켜야함

  5.의존성 역전 원칙(DIP)
	모든 의존성은 추상에 의존해야하고 구체에 의존하면 안됨,포트어댑터패턴을 사용하라는것
	정확히는 안정적인거에 의존하고,불안정한걸 의존하면 안된다에 가까움
	인터페이스는 변경확률이 작으니 의존해도되고,구현체는 변경확률이 높으니 의존하면 안된다는것
	
	또한 변동성이 큰 구체적인 객체는 특별히 주의해서 생성해야함(추상팩토리사용)
	모든 구체적인것들과 추상적인것들을 분리해내고,구체적인것들이 추상적인것들을 의존해야함
	
	또한 모든 dip위배를 없앨수는없어도,한곳에 모을수는있음(보통 main의 dip위배는 없앨수없음)
		

4.컴포넌트 원칙
  1.컴포넌트
	컴포넌트는 시스템의 구성요소로 배포할수있는 가장 작은단위임,자바로치면 jar,닷넷에서는 dll
	이런 컴포넌트들을 서로 링크해서 실행가능한 단일파일로 생성할수있고,이런것들을 묶어서 동적으로 로드할수있는 플러그인이나 exe로 만들수있음
  2.컴포넌트 응집도
	어떤클래스를 어느컴포넌트에 포함시킬지에 대한 원칙으로는
		재사용/릴리스 등가 원칙(REP)
		공통 폐쇄 원칙(CCP)
		공통 재사용 원칙(CRP)
	가 있음
	
	rep는 재사용단위는 릴리스단위와 같다(같이배포할애들끼리 재사용가능해야한다)라는것
	즉 한 컴포넌트에 들어있는애들끼리는,같은버전일경우 다 호환되어야한다는것
	즉 단일컴포넌트는 응집성높은 클래스와 모듈로 구성되어야하고,컴포넌트를 구성하는 모듈들은 서로 공유하는 테마가 있어야함
	제일 중요한건,하나의 컴포넌트로 묶인 클래스와 모듈은 항상 버전이 같아야하고,같은릴리스로 추적관리되고 같은 릴리스문서에 포함된다는게 당연해야함
	
	ccp는 같은이유로 같은시점에 변경되는 클래스를 같은 컴포넌트로 묶으라는것,
	또한 다른시점에 다른이유로 변경되는 클래스는 다른컴포넌트로 분리하라는것
	이건 단일책임원칙(srp)을 컴포넌트관점에서 다시쓴것
	단일컴포넌트는 변경의 이유가 여러개있어서는 안됨
	보통 유지보수성은 재사용성보다 훨씬 중요하고,코드가 반드시 변경되어야 한다면 도처에서 변경하는거보다 컴포넌트하나에서 전부 발생하는게 나음
	이러면 그 컴포넌트만 재배포하면되니까
	그래서 항상 함께 변경되는 클래스들을 하나의 컴포넌트로 묶으라는것
	또한 개방폐쇄원칙(ocp)와도 밀접한 연관이 있음,이거도 같은유형의 변경에 대해 닫혀있는 클래스들을 묶어서 변경으로 영향을 주는 컴포넌트들을 최소화하는것
	
	crp는 같이 재사용되는 경향이 있는 클래스와 모듈을 같은컴포넌트에 포함시키라는것
	컨테이너와 이터레이터를 예로 들수있음,강결합된 클래스들은 반드시 함께 위치해있어야함
	강결합되면 사용되는 컴포넌트가 변경되면 사용하는 컴포넌트도 같이 변경해야할 확률이 높기때문에,ccp의 관점에서 봐도 같이있어야하는것
	또한,crp때문에 하나의 컴포넌트의 클래스에 의존하면,해당 컴포넌트 전체에 대해 의존한다는걸 확실히 인지해야함
	특정 클래스 하나에 대해서만 의존할수는없음
	즉 이건 어떤 클래스를 한데 묶어서는 안되는지(강결합되지않은 클래스들)를 말하는거에 가까움
	crp는 인터페이스분리원칙(isp)의 포괄적인 버전임,둘다 필요하지않은것에 의존하지마라는것
	
	이 3가지 원칙은 서로 상충되는데,rep와 ccp는 포함원칙이라 컴포넌트를 크게만들고,crp는 배제원칙이라 컴포넌트를 작게만듬
	이 중간 어딘가에 위치해야하는데
		crp가 없을때->불필요한 릴리스가 너무 빈번함
		ccp가 없을때->컴포넌트변경에 너무 빈번함
		rep가 없을때->재사용이 어려움
	이런식으로 됨 극단적으로가면
	보통 프로젝트 초창기에는 rep를 포기하다가,그 프로젝트에서 파생된 프로젝트가 시작되면 점점 rep를 챙기면서 ccp를 낮춰나감
	보통 crp는 항상 챙기는편

  3.컴포넌트 결합
	의존성 비순환 원칙(ADP)는 컴포넌트 의존성그래프에 사이클이 있어선 안된다는것
	즉 순환의존성을 제거해야한다는건데,이유는 a를 변경하면 a를 의존하는 b가 변경되고,b가 변경되면서 다시 b를 의존하는 a가 변경되고..이런식으로 되기때문
	애초에 요즘언어는 컴파일도 안되기도하고
	보통 이경우에 해결법은 의존성역전원칙(포트어댑터)를 사용하고,
	요구사항이 변경되면 컴포넌트 구조도 같이 변경되는데,이경우 순환의존성이 발생하는지를 항상 관찰하고 발생하면 끊어야함
	
	결국 컴포넌트 구조는 탑다운으로 설계될수없고,개발이 진행되면서 변동성을 격리하면서 서로서로 붙이고 떼고를 하면서 생기게되는것
	이러면서 재사용성을 위해 crp가 영향을 주고,순환이 발생하면 adp가 영향을 주고 이러는것임
	즉 아무클래스도 없는상태에서 의존성구조를 설계하려고 시도하면 실패할확률이 많이 높음
	
	
	안정된 의존성 원칙(SDP)는 더 안정된쪽에 의존하라는것
	즉 구체보다 인터페이스에 의존하라는거도 이쪽에서 나온것
	변경이 쉽지않은 컴포넌트가 변동이 예상되는 컴포넌트에 의존하게 만들면 절대안됨,이러면 변동이 예상되는 컴포넌트도 변경이 어려워지기때문
	
	즉 현재 모듈을 다른모듈들이 의존하기 시작하면 점점 변경이 어려워짐
	그러니 애초에 변경이 어려운애들쪽에 의존하는게 좋음
	그래서 변경난이도계산을 의존성갯수를 세서 하는경우도 있음
		i=해당객체가 의존하는대상/(해당객체가 의존하는대상+해당객체를 의존하는대상)
	으로 계산함,이때 값이 0이면 최고로 안정된 컴포넌트고(인터페이스등),값이1이면 최고로 불안정한 컴포넌트라는 뜻
	불안정한 컴포넌트들은 언제든 수정해도 상관없고(나를 의존하는게 없으니 책임성이 없음),또한 이경우는 언젠가 해당 컴포넌트를 변경할 이유가 있다는것
	또한 값이 0인 안정적인 컴포넌트(도메인)는 변경하긴 어렵지만,다른곳에서 강제로 변경을 시키진않음
	
	sdp는 컴포넌트의 i지표가 의존하는 대상으로 갈수록 작아져야한다고 말하는 원칙임(상위의존성으로 갈수록 작아져야한다는것)
	모든 컴포넌트가 안정적이면 변경이 불가능하니까 안됨,즉 불안정한 컴포넌트도,안정된 컴포넌트도 존재하는 상태가 좋음
	이때 의존성을 끊을때는 dip를 사용할수있음(불안정한곳에서 인터페이스를 생성하는식)
	
	
	안정된 추상화 원칙(SAP)는 컴포넌트는 안정된 정도만큼만 추상화되어야한다는것
	즉 비즈니스로직은 반드시 안정된 컴포넌트에 위치해야하고,불안정한 컴포넌트는 반드시 변동성이 큰것만을 포함해야함
	근데 이러면 비즈니스로직을 수정하기 어려워짐,이걸 해결하기위해 ocp를 사용할수있음,이때 사용되는게 추상클래스임
	
	안정된 컴포넌트는 추상컴포넌트여야하고,이를통해 안정성이 컴포넌트가 확장하는걸 방해해서는 안된다는걸 말함
	또한 불안정한 컴포넌트는 구체컴포넌트여야하고,컴포넌트내부의 구체적인코드를 쉽게 변경할수있어야하기때문
	이러면 반드시 인터페이스와 추상클래스로 구성되기때문에 확장이 쉬워짐
	즉 sap+sdp는 컴포넌트단에서의 dip와 마찬가지임
	
	컴포넌트의 추상화정도를 측정하는건
		(컴포넌트의추상클래스갯수+인터페이스갯수)/컴포넌트의 클래스갯수
	로 구할수있고,0이면 완전한 추상클래스가 하나도없다는거고,1이면 오직 추상클래스만 있다는것
	
	이때 안정성과 추상화 정도를 가지고 2차원 그래프를 그릴수있는데,(0,1),(1,0)을 잇는 선에 가까울수록 좋고(해당점에 가까우면 더 좋음)
	(0,0)은 매우 안정적인데 구체적이라 확장할수없고,변경도 어려움,그래서 고통의구역임
	보통 db스키마가 여기있음,물론 여기있어도 절대 변경하지않을거면 상관없음(string같은거)
	(1,1)은 최고로 추상적이지만,아무도 의존하지않기때문에 쓸데없음,그래서 쓸모없는구역임
	이건 보통 누구도 구현하지않은 추상클래스같은게 더미로 남아있는거임,지워버리면됨
	
	물론 완전히 절대적인건 아니고,이거로 대충 값을 뽑아본다음에 0,0이나 1,1쪽에 매우 가까운애들을 찾는방법으로 쓸수있음
	
5.아키텍처






























































































	
	
	
	
	
	
	