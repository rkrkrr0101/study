1.소개
  1.설계와 아키텍처란?
	소프트웨어 아키텍처의 목표는 필요한시스템을 만들고 유지보수하는데 투입되는 인력을 최소화하는것
  2.두가지 가치에 대한 이야기
	소프트웨어는 기계가 수익을 창출하거나 비용을 절약하게 만들어줌
	이떄 소프트웨어는 변경하기쉬워야하고,이해관계자가 생각을 바꾸면 이 변경사항을 간단하고 쉽게 적용할수있어야함
	그리고 변경사항을 적용할때의 어려움은 범위에 비례해야하고,형태와는 연관이 없어야함
	
	긴급함과 중요함을 잘 생각해야함
		긴급하고 중요한
		긴급하지않지만 중요한
		긴급하지만 중요하지않은
		긴급하지도 중요하지도 않은
	이 순서대로 일을 처리해야지,3번째인 긴급하지만 중요하지않은게 위로 올라가면안됨
	
	
2.프로그래밍 패러타임
	프로그래밍 패러다임은 모두 프로그래밍을 할때 제약을 부과함
		구조적프로그래밍:goto(직접문맥전환)의 금지
		객체지향프로그래밍:간접문맥전환에 대한 규칙부과
		함수형 프로그래밍:할당에 대한 규칙을 부과(가변성)
	즉 무언가를 쓰기 힘들게 만드는게 목적임,즉 너무 많은 권한을 제거해서 생각할걸 줄여주는것
  1.구조적 프로그래밍
	모든 프로그램은 순차,분기,반복 3가지만으로도 표현할수있음
	구조적프로그래밍의 핵심은,모듈을 증명가능한 더 작은단위로 재귀적으로 쪼갤수있다는것
	즉 요구사항을 고수준의 기능들로 쪼개고,기능을 더 작은 함수들로 쪼갤수있다는것임
	또한 수학적이 아닌 과학적증명으로,서술이 참임을 증명하는게 아닌 거짓임을 증명하는식(테스트)로 진행됨
	
	구조적 프로그래밍의 기능적분해가 아키텍처관점에서는 최고의 실천법중 하나임
  2.객체지향 프로그래밍
	객체지향의 핵심은 다형성임
	캡슐화와 상속은 객체지향이 아니라도 구현할수있는데,다형성의 경우 구현할수없고 객체지향에서 제일 메인이 되는 규칙임
	절차지향에서도 가능하긴하지만(포인터를 통해),특정관례를 수동으로 따르는방식이라 좀 위험하고,이런식으로 생긴 버그는 찾기가 어려움
	
	다형성을 사용하면 dip를 만들수있고 이게 객체지향의 핵심임
	즉 상위가 하위의 구현에 대해 직접적으로 얽매이지않고,상위가 생성한 인터페이스에 대해 하위가 의존하는식으로 의존성을 역전시킬수있다는게 핵심임
	이러면 하위의 구현의 수정이 일어나도,인터페이스가 바뀌지않으니 상위코드에 수정이 필요없는식
	또한 상위에 수정이 일어나도 인터페이스를 바꾸지않으면 하위도 신경쓸필요없음
	
	이러면 아키텍트는 소스코드의존성의 방향에 대한 절대적인 권한을 가지게됨
	이러면 상위든 하위든 db든 ui든 전부 인터페이스의 플러그인처럼 동작하게되고,전부 독립적으로 배포할수있어지고,그러면 전부 독립적으로 개발할수있어짐

  3.함수형 프로그래밍
	함수형의 핵심은 람다와 재할당불가(val)임
	함수형 프로그래밍 언어에선 변수의 재할당을 할수없음
	이걸로 인해 얻는게 많은데,이러면 동시성문제들의 거의 대부분이 사라짐
	
	이를 통해 얻을수있는 교훈은,어플리케이션을 구조화할땐 변수를 변경하는 컴포넌트와 변경하지않는 컴포넌트를 분리하고,
	가능한 많은 처리를 불변컴포넌트로 옮겨야함
	
	함수형처리의 다른방식으로는 이벤트소싱이 있음
	저장공간과 처리능력의 한계가 매우커지니,그냥 상태를 저장하지않고 모든 트랜잭션을 저장하고,
	필요할때 모든트랜잭션을 실행하는식으로 상태를 가져오는거임
	이러면 가변변수가 하나도 필요없고,중간에 스냅샷을 만들어서 최적화도 가능함
	이러면 crud가 아닌 cr만 수행하면됨 또한 그래서 변경과 삭제가 발생하지않으니 동시업데이트문제도 발생하지않음
	즉 이방식은 git와 같은방식임
	

3.설계원칙
	solid의 목적은 중간수준(모듈보단 하위 코드보단 상위,클래스나 메서드수준)의 소프트웨어가
		변경에 유연하고
		이해하기쉽고
		많은 소프트웨어 시스템에 사용할수있는 컴포넌트의 기반이 되게
	만드는것임
	
  1.단일책임원칙(SRP)
	이건 하나의 모듈의 변경이유는 오직 하나뿐이어야한다는것
	즉 하나의 모듈은 하나의 액터에 대해서만 책임져야한다는것
	
	이게 깨진 징후는
		우발적중복:여러사람이 한 클래스에다가 각기 다른곳에서 사용하기위해 메서드를 추가,즉 서로 다른이유로 추가된애들이 프라이빗메서드를 공유할때
			변경시에 다른곳에 사이드이펙트를 주는것
		병합:서로 다른 팀에서 다른이유로 같은 코드를 수정할때 컨플릭트가 발생,즉 다른액터가 둘이상 있다는것
	즉 서로 다른 사람들이 서로 다른목적으로 같은 코드를 건드리려할때 srp가 깨진것
	
	이문제의 해결법은 그냥 전부 째서 다른클래스로 분할시키고,꼭 같은곳에 있어야한다면 퍼사드패턴을 사용하는것
	이떄 분리할때는 자신의 메서드에 반드시 필요한 소스코드만 포함해야함,그리고 각 클래스들은 서로의 존재를 몰라야함(의존성이 없어야함)
	
  2.개방-폐쇄원칙(OCP)
	소프트웨어는 확장은 가능해야하고,확장할때 코드를 수정하지않아야함
	즉 추가적으로 뭘 붙여야하거나 할때,기존코드를 건드리지않고 추가할수있어야함
	단일책임원칙과 의존성역전원칙을 사용해서 결과적으로 이렇게 되어야하는것
	
	이거의 핵심은 책임의 분리임,각 행위들은 하나의 일만 해야함(보고서용 데이터생성과 데이터를 받아서 보고서생성 이런식으로)
	그리고 비즈니스로직을 의존해야지 비즈니스로직이 의존하면안됨(비즈니스로직과 의존성객체는 분리되어서 복잡한코드가 나오면안됨)
	이때 인터페이스를 사이에 끼워두면,양쪽에 대한 변경에대해 서로가 안전해지게됨

  3.리스코프 치환 원칙(LSP)
	상위타입대신 하위타입을 넣어도 행위가 변하지않아야함
	대표적으로 직사각형 정사각형문제
	이게 깨지면 정말 머리아파짐,하위타입을 그냥 가져다가 상위타입처럼 쓰는게 불가능해지기때문(하위인스턴스종류를 계속 체크해야함)
	이게 깨지면 이것만을 위한 메커니즘이 대량으로 추가돼버림

  4.인터페이스 분리 원칙(ISP)
	모든 클래스는 자기가 사용할 인터페이스만 생성하고,의존해야함
	만약 여러 클래스가 서로 다른 메서드를 사용하는데,둘다 한 인터페이스를 의존한다면 자기와 상관없는 일때문에(상대방의 수정)자기도 수정되어야함
	이때는 인터페이스를 서로 분리시켜야함

  5.의존성 역전 원칙(DIP)
	모든 의존성은 추상에 의존해야하고 구체에 의존하면 안됨,포트어댑터패턴을 사용하라는것
	정확히는 안정적인거에 의존하고,불안정한걸 의존하면 안된다에 가까움
	인터페이스는 변경확률이 작으니 의존해도되고,구현체는 변경확률이 높으니 의존하면 안된다는것
	
	또한 변동성이 큰 구체적인 객체는 특별히 주의해서 생성해야함(추상팩토리사용)
	모든 구체적인것들과 추상적인것들을 분리해내고,구체적인것들이 추상적인것들을 의존해야함
	
	또한 모든 dip위배를 없앨수는없어도,한곳에 모을수는있음(보통 main의 dip위배는 없앨수없음)
		

4.컴포넌트 원칙
  1.컴포넌트
	컴포넌트는 시스템의 구성요소로 배포할수있는 가장 작은단위임,자바로치면 jar,닷넷에서는 dll
	이런 컴포넌트들을 서로 링크해서 실행가능한 단일파일로 생성할수있고,이런것들을 묶어서 동적으로 로드할수있는 플러그인이나 exe로 만들수있음
  2.컴포넌트 응집도
	어떤클래스를 어느컴포넌트에 포함시킬지에 대한 원칙으로는
		재사용/릴리스 등가 원칙(REP)
		공통 폐쇄 원칙(CCP)
		공통 재사용 원칙(CRP)
	가 있음
	
	rep는 재사용단위는 릴리스단위와 같다(같이배포할애들끼리 재사용가능해야한다)라는것
	즉 한 컴포넌트에 들어있는애들끼리는,같은버전일경우 다 호환되어야한다는것
	즉 단일컴포넌트는 응집성높은 클래스와 모듈로 구성되어야하고,컴포넌트를 구성하는 모듈들은 서로 공유하는 테마가 있어야함
	제일 중요한건,하나의 컴포넌트로 묶인 클래스와 모듈은 항상 버전이 같아야하고,같은릴리스로 추적관리되고 같은 릴리스문서에 포함된다는게 당연해야함
	
	ccp는 같은이유로 같은시점에 변경되는 클래스를 같은 컴포넌트로 묶으라는것,
	또한 다른시점에 다른이유로 변경되는 클래스는 다른컴포넌트로 분리하라는것
	이건 단일책임원칙(srp)을 컴포넌트관점에서 다시쓴것
	단일컴포넌트는 변경의 이유가 여러개있어서는 안됨
	보통 유지보수성은 재사용성보다 훨씬 중요하고,코드가 반드시 변경되어야 한다면 도처에서 변경하는거보다 컴포넌트하나에서 전부 발생하는게 나음
	이러면 그 컴포넌트만 재배포하면되니까
	그래서 항상 함께 변경되는 클래스들을 하나의 컴포넌트로 묶으라는것
	또한 개방폐쇄원칙(ocp)와도 밀접한 연관이 있음,이거도 같은유형의 변경에 대해 닫혀있는 클래스들을 묶어서 변경으로 영향을 주는 컴포넌트들을 최소화하는것
	
	crp는 같이 재사용되는 경향이 있는 클래스와 모듈을 같은컴포넌트에 포함시키라는것
	컨테이너와 이터레이터를 예로 들수있음,강결합된 클래스들은 반드시 함께 위치해있어야함
	강결합되면 사용되는 컴포넌트가 변경되면 사용하는 컴포넌트도 같이 변경해야할 확률이 높기때문에,ccp의 관점에서 봐도 같이있어야하는것
	또한,crp때문에 하나의 컴포넌트의 클래스에 의존하면,해당 컴포넌트 전체에 대해 의존한다는걸 확실히 인지해야함
	특정 클래스 하나에 대해서만 의존할수는없음
	즉 이건 어떤 클래스를 한데 묶어서는 안되는지(강결합되지않은 클래스들)를 말하는거에 가까움
	crp는 인터페이스분리원칙(isp)의 포괄적인 버전임,둘다 필요하지않은것에 의존하지마라는것
	
	이 3가지 원칙은 서로 상충되는데,rep와 ccp는 포함원칙이라 컴포넌트를 크게만들고,crp는 배제원칙이라 컴포넌트를 작게만듬
	이 중간 어딘가에 위치해야하는데
		crp가 없을때->불필요한 릴리스가 너무 빈번함
		ccp가 없을때->컴포넌트변경에 너무 빈번함
		rep가 없을때->재사용이 어려움
	이런식으로 됨 극단적으로가면
	보통 프로젝트 초창기에는 rep를 포기하다가,그 프로젝트에서 파생된 프로젝트가 시작되면 점점 rep를 챙기면서 ccp를 낮춰나감
	보통 crp는 항상 챙기는편

  3.컴포넌트 결합
	의존성 비순환 원칙(ADP)는 컴포넌트 의존성그래프에 사이클이 있어선 안된다는것
	즉 순환의존성을 제거해야한다는건데,이유는 a를 변경하면 a를 의존하는 b가 변경되고,b가 변경되면서 다시 b를 의존하는 a가 변경되고..이런식으로 되기때문
	애초에 요즘언어는 컴파일도 안되기도하고
	보통 이경우에 해결법은 의존성역전원칙(포트어댑터)를 사용하고,
	요구사항이 변경되면 컴포넌트 구조도 같이 변경되는데,이경우 순환의존성이 발생하는지를 항상 관찰하고 발생하면 끊어야함
	
	결국 컴포넌트 구조는 탑다운으로 설계될수없고,개발이 진행되면서 변동성을 격리하면서 서로서로 붙이고 떼고를 하면서 생기게되는것
	이러면서 재사용성을 위해 crp가 영향을 주고,순환이 발생하면 adp가 영향을 주고 이러는것임
	즉 아무클래스도 없는상태에서 의존성구조를 설계하려고 시도하면 실패할확률이 많이 높음
	
	
	안정된 의존성 원칙(SDP)는 더 안정된쪽에 의존하라는것
	즉 구체보다 인터페이스에 의존하라는거도 이쪽에서 나온것
	변경이 쉽지않은 컴포넌트가 변동이 예상되는 컴포넌트에 의존하게 만들면 절대안됨,이러면 변동이 예상되는 컴포넌트도 변경이 어려워지기때문
	
	즉 현재 모듈을 다른모듈들이 의존하기 시작하면 점점 변경이 어려워짐
	그러니 애초에 변경이 어려운애들쪽에 의존하는게 좋음
	그래서 변경난이도계산을 의존성갯수를 세서 하는경우도 있음
		i=해당객체가 의존하는대상/(해당객체가 의존하는대상+해당객체를 의존하는대상)
	으로 계산함,이때 값이 0이면 최고로 안정된 컴포넌트고(인터페이스등),값이1이면 최고로 불안정한 컴포넌트라는 뜻
	불안정한 컴포넌트들은 언제든 수정해도 상관없고(나를 의존하는게 없으니 책임성이 없음),또한 이경우는 언젠가 해당 컴포넌트를 변경할 이유가 있다는것
	또한 값이 0인 안정적인 컴포넌트(도메인)는 변경하긴 어렵지만,다른곳에서 강제로 변경을 시키진않음
	
	sdp는 컴포넌트의 i지표가 의존하는 대상으로 갈수록 작아져야한다고 말하는 원칙임(상위의존성으로 갈수록 작아져야한다는것)
	모든 컴포넌트가 안정적이면 변경이 불가능하니까 안됨,즉 불안정한 컴포넌트도,안정된 컴포넌트도 존재하는 상태가 좋음
	이때 의존성을 끊을때는 dip를 사용할수있음(불안정한곳에서 인터페이스를 생성하는식)
	
	
	안정된 추상화 원칙(SAP)는 컴포넌트는 안정된 정도만큼만 추상화되어야한다는것
	즉 비즈니스로직은 반드시 안정된 컴포넌트에 위치해야하고,불안정한 컴포넌트는 반드시 변동성이 큰것만을 포함해야함
	근데 이러면 비즈니스로직을 수정하기 어려워짐,이걸 해결하기위해 ocp를 사용할수있음,이때 사용되는게 추상클래스임
	
	안정된 컴포넌트는 추상컴포넌트여야하고,이를통해 안정성이 컴포넌트가 확장하는걸 방해해서는 안된다는걸 말함
	또한 불안정한 컴포넌트는 구체컴포넌트여야하고,컴포넌트내부의 구체적인코드를 쉽게 변경할수있어야하기때문
	이러면 반드시 인터페이스와 추상클래스로 구성되기때문에 확장이 쉬워짐
	즉 sap+sdp는 컴포넌트단에서의 dip와 마찬가지임
	
	컴포넌트의 추상화정도를 측정하는건
		(컴포넌트의추상클래스갯수+인터페이스갯수)/컴포넌트의 클래스갯수
	로 구할수있고,0이면 완전한 추상클래스가 하나도없다는거고,1이면 오직 추상클래스만 있다는것
	
	이때 안정성과 추상화 정도를 가지고 2차원 그래프를 그릴수있는데,(0,1),(1,0)을 잇는 선에 가까울수록 좋고(해당점에 가까우면 더 좋음)
	(0,0)은 매우 안정적인데 구체적이라 확장할수없고,변경도 어려움,그래서 고통의구역임
	보통 db스키마가 여기있음,물론 여기있어도 절대 변경하지않을거면 상관없음(string같은거)
	(1,1)은 최고로 추상적이지만,아무도 의존하지않기때문에 쓸데없음,그래서 쓸모없는구역임
	이건 보통 누구도 구현하지않은 추상클래스같은게 더미로 남아있는거임,지워버리면됨
	
	물론 완전히 절대적인건 아니고,이거로 대충 값을 뽑아본다음에 0,0이나 1,1쪽에 매우 가까운애들을 찾는방법으로 쓸수있음
	
5.아키텍처
  1.아키텍처란?
	아키텍처란 시스템의 형태고,핵심은
		가능한 많은 선택지를 가능한 오래 남겨두는 전략
	임
	아키텍처는 시스템의 동작여부와는 거의 관련이 없고,얘는 시스템의 생명주기를 지원하는게 목적임
	즉 쉽게 이해하고,쉽게 개발하며,쉽게 유지보수하고 쉽게 배포하게 해주는게 역할임,
	즉 수명과 관련된 비용을 최소화하고,생산성을 최대화하는게 목적
	
	보통 팀구조가 작으면 아키텍처관련 제약들이 방해가 된다고 느끼지만,
	팀구조가 커지고 여러팀으로 구성되기시작하면 아키텍처가 없으면 개발이 진척되지않음
	
	아키텍처는 소프트웨어를 부드럽게 유지하는 방법이고,그 방법은 선택사항들을 가능한 많이,가능한 오래 선택하지않고 두는것
	여기서 선택사항들은 중요치않은 세부사항들임
	소프트웨어는 정책과 세부사항으로 분해할수있음
	정책요소는 모든 업무규칙과 업무절차를 구체화하는 소프트웨어의 핵심임
	세부사항은 외부요소(사람,시스템,프로그래머등)가 정책과 소통할때 필요한 요소지만,정책에는 전혀 영향을 미치지않음
	이런것에는 입출력장치,db,웹,프레임워크등이 있음
	
	즉 아키텍트는 정책을 가장 핵심요소로 식별하고,세부사항은 정책에 부관하게 만들수있는 형태의 시스템을 구축하는데 있음
	이를통해 세부사항을 결정하는일은 미루거나 연기할수있게됨
	
	예를들어 개발초기엔 db를 선택할필요가 없고,웹서버를 선택할필요가 없음
	이런식으로 결정을 오래 미룰수있으면 더 많은 정보를 얻을수있고,이를 기초로 제대로된 결정을 내릴수있음
	또한 이를통해 다양한 실험을 해볼수도 있음
	그리고 이미 누군가 결정을 내렸다고 해도,여전히 결정을 가능한한 오래 연기하거나 변경할수있는 형태로 시스템을 만드는게 효율적임
	
	즉 정책의 외부부분은 다 추상화를 친다음,모킹해서 사용하다가 최대한 뒤로 미루고 정책부터 만드는것
	이를위해 세부사항과 정책을 신중하게 가려내고,정책이 세부사항과 결합되지않게 엄격하게 분리해야함
	이를통해 정책은 세부사항에 관한 어떤 지식도 의존하지않게됨

  2.독립성
	시스템 아키텍처는 시스템의 의도를 지원해야함(유스케이스)
	단,아키텍처는 시스템의 행위에 영향을 그다지 끼치지못하지만,여기서의 할일은 행위를 명확히하고 외부로 드러내며,
	이를통해 시스템이 지닌 의도를 아키텍처수준에서 알아볼수있게 만드는것(누가봐도 명확하게)
	
	운영관점에서는 아키텍처는 요구사항에 맞는 스펙을 제공해야함(초당 10000명처리가 가능해야하면 가능해야함)
	또한 다른구조로 변경이 쉬우면 좋음
	
	개발관점에서는 각 팀이 독립적으로 행동하기 편한 아키텍처를 확보하고,개발하는동안 팀들이 서로를 방해하지않도록 잘 격리되어야함
	
	배포관점에서는 즉각적인 배포를 목표로 해야함
	시스템이 빌드되고나면 즉각 배포할수있게 지원되어야함,이걸위해서 시스템을 컴포넌트단위로 적절하게 분할시키고 격리하는것
	여기에는 마스터컴포넌트(메인같은거)도 포함됨
	
	좋은아키텍처는 이 사이에서 균형을 맞추고 각 관심사 모두를 만족시켜야함
	하지만 현실에서는 매우 어려운데,모든유스케이스를 알수도없고,각프로젝트마다의 제약사항등도 아직 알지못하고 변하기때문
	그래서 가능한 선택사항을 미뤄두고,반드시 선택해야할때 가장 비용이 싼 선택지를 고르는것
	
	
	유스케이스측면에서 아키텍트는 모든 유스케이스를 알지는 못하지만,시스템의 기본적인 의도는 알수있음
	이를통해 단일책임원칙과 공통폐쇄원칙을 적용해서,의도의 맥락에 따라 다른이유로 변경되는것들은 분리하고 같은이유로 변경되는것들은 묶을수있음
	보통 ui와 업무규칙은 관련이 없어서 다른이유로 변경되니 분리하고,업무규칙중에서도 입력값검사나 이자계산등은 다른속도로 다른이유로 변경되니 분리할수있음
	또한 유스케이스 자체도 다른이유로 변경됨(서로 다른 유스케이스들)
	이렇게 결합을 분리하면,각 유스케이스들을 따로 둘수있고,각각 다른서버에서 실행할수도있음(마이크로서비스)
	
	개발측면에서 컴포넌트가 완전히 분리되면,팀간의 간섭이 줄어들고 서로간에 신경쓸일이 별로 없어짐	
	배포측면에서도 이러면 고도의 유연성이 생김,운영중에서도 유스케이스를 교체할수있으니까

	중복은 일반적으로 나쁜거지만,중복중에서 진짜중복과 가짜중복을 구별해야함
	진짜로 변경하면 다같이 변경해야하는것과,그냥 어쩌다보니 같아진것(또 앞으로 달라질것)을 구분해서 봐야함
	
	결합을 분리하는 방법은
		소스수준 분리:소스상에서 의존성제어
		배포수준 분리:jar같이 배포가능한 단위사이의 의존성제어
		서비스수준 분리:서로간에 네트워크패킷을 통해서만 통신하게 제어
	가 있고,초기에는 분리하되 서비스가 되기직전에 멈추는식으로 하는게 가장 늦게 선택하는 방법임
	즉 소스수준으로 분리하다가 배포에서 문제가 생기면 일부결합만 배포수준으로 분리하고,나중에 커지면 서비스수준으로 분리하는것
	핵심은 변환이 쉬워야한다는것
  
  3.경계:선 긋기
	소프트웨어 아키텍처는 선(경계)을 긋는 기술임
	경계는 소프트웨어 요소를 서로 분리하고 반대편의 요소를 알지못하게 막음
	이런 선중 어떤건 아주 초기에,어떤건 매우 나중에 그어짐
	이 선들은 결정이 핵심적인 업무로직을 오염시키는걸 막기위해 사용되고,여기서 오염은 결합임
	특히 너무 일찍 내려진 결정에 따른 결합임
	
	여기서 이른결정은 유스케이스와 아무 상관없는 결정임
	즉 서버고 db고 간에 일단 유스케이스부터 만들고나서 진짜로 필요해지면 선택하는게 맞다는것
	즉 유스케이스를 구현하는데 직접 필요하기전까진 모든 결정을 미루고,
	직접 구현할때도 어짜피 포트어댑터로 처리가 가능하면 가장 쉬운방법을 선택하라는것임
	
	선을 그을때는 관련이 있는것과 없는것 사이에 그으면됨
	gui와 업무규칙,업무규칙과 db,gui와 db 이런식
	그리고 서로 통신해야하면 인터페이스를 만들어 포트어댑터를 사용하는것(즉 선은 인터페이스 바로 아래에 그어짐)
	또한 더 크게보면,레포지토리가 도메인을 의존하는거여야함,도메인은 레포지토리를 알면 안됨
	그러니 소프트웨어의 핵심인 도메인은 db가 뭐든 아무상관없으니,db는 아무렇게나 바꿔끼울수있다는거,즉 그래서 db에 대한 결정은 연기할수있어지는거임
	
	이런식으로 비즈니스로직과 별개의 플러그인의 집합으로 시스템을 볼수있음
	소프트웨어는 플러그인을 손쉽게 생성하여,확장가능하며 유지보수가 쉬운 아키텍처를 확립할수있게 만들어야함
	그래서 선택적이거나 수많은 형태로 구현될수있는 나머지 컴포넌트로 부터 도메인은 분리되어있고,독립적이어야함
	
	이를통해 어떤 변경이 일어나더라도 비즈니스로직은 영향을 전혀 받지않게됨,즉 경계는 변경의 축이 있는 지점에 그어지고
	경계의 양쪽은 서로 변경의 속도와 이유가 다르게됨(단일책임원칙)
	
  4.경계 해부학
	런타임에 경계를 횡단한다는건 그냥 반대편에 있는 함수를 호출하는거임
	이떄 적절한위치에서 경계를 횡단하게하는건 소스코드의존성 관리에 비결이 있음
	
	모놀리틱도 다 같은 모놀리틱이 아님,배포관점에서 보면야 경계가 드러나지않지만,
	개발과정에서는 그안에 컴포넌트들이 존재하고,각각을 독립적으로 수행할수있게함
	이런 아키텍처들은 거의 모든경우에 동적다형성에 의존해서 의존성을 관리함
	
	가장 단순한 형태의 경계횡단은,저수준클라에서 고수준 서비스로 향하는 함수호출임,일반적인 행위
	만약 고수준클라가 저수준 서비스를 호출해야한다면,dip를 사용해 인터페이스를 거쳐야함(런타임과 컴파일타임 의존성을 반대로잡음)
	이러면 경계지점에서의 의존성은 항상 저수준이 고수준을 의존하게됨
	
	배포형컴포넌트의 경우 경계가 물리적으로 드러나는데(각각의 파일단위로),이건 단순하게 배포가능한단위를 좀 더 편리한상태로 묶는거일뿐임
	둘다 함수호출을 싸고,스레드를 사용할수있는거부터 별차이없음
	
	서비스의 경우는 좀 다른데,각 서비스들끼리의 통신은 함수호출에 비해 매우 느리고,가능하면 서로 통신하는횟수를 최소로 해야함
	또한 고수준의 서비스의 소스코드엔 저수준서비스를 특정짓는 어떤 물리적인정보도 절대 포함되면안됨(특히 url,이런건 환경변수로 받거나해야할듯)

  5.정책과 수준
	소프트웨어 시스템이란 정책을 기술한거임
	어짜피 입력을 출력으로 변환하는 정책을 상세하게 설명한것일 뿐이니까
	그리고 하나의 정책은 이 정책을 서술하는 여러 조그마한 정책으로 쪼갤수있음
	
	아키텍처를 개발하는 기술중에는,이런 정책을 신중하게 분리하고,정책이 변경되는 양상에 따라 정책을 재편성하는일도 포함됨
	같은이유로 같은시점에 변경되는 정책은 같은수준에 있어야하고,
	다른이유로 혹은 다른시점에 변경되는 정책은 다른수준에 위치하고,반드시 다른컴포넌트로 분리되어야함
	
	좋은 아키텍처는 각 컴포넌트를 연결할때 의존성의 방향이 컴포넌트의 수준을 기반으로 연결되게 만들어야함
	즉 저수준컴포넌트가 고수준컴포넌트에 의존하게 설계되어야함
	
	여기서 수준은 입력과 출력까지의 거리임
	시스템의 입력과 출력 모두로부터 멀리 위치할수록 고수준임(도메인),또한 입력과 출력을 다루는정책은 시스템에서 최하위수준에 위치함(웹,db)
	여기서 주의해야할건,데이터흐름과 소스코드의존성이 항상 같은방향알 가리키진않음
	입력-도메인-출력으로 일어나면 도메인이 출력을 호출하던가 하는 잘못된방식이 생기기쉬움
	이럴때 dip를 써서 의존성을 역전시키는거임(또한 인터페이스는 더 고수준에 속하게됨)
	
	보통 저수준일수록 변경빈도가 높고,덜중요한이유로 변경되고,
	고수준일수록 덜 빈번하게 변경되고,중요한이유로 변경됨
	그래서 dip를 사용하든 어쩌든 분리를 시키면 저수준이 변경하는일을 고수준에서 신경쓰지않아도됨(저수준이 고수준에 플러그인되는느낌)

  6.업무규칙
	어플리케이션을 업무규칙과 플러그인으로 구분하려면 업무규칙이 실제로 뭔지를 알아야함
	업무규칙은 사업적으로 수익을 얻거나 비용을 줄일수있는 핵심업무규칙과,이에 필요한 데이터인 핵심업무데이터로 구성되고
	이 둘을 묶어서 엔티티라고 부름
	
	엔티티는 핵심업무데이터를 기반으로 동작하는 자그마한 핵심업무규칙을 구체화하는 객체임
	얘는 핵심업무데이터를 직접 포함하거나,매우쉽게 접근할수있음
	또한 엔티티의 인터페이스는 핵심업무데이터를 기반으로 동작하는 핵심업무규칙을 구현한 함수들로 구성됨
	
	이 엔티티는 db,ui,서드파티 프레임워크등에 대해서 오염되어서는 절대 안됨
	또한 이 클래스는 어떤 시스템에서도 업무를 수행할수있어야하며,표현방식,저장방식등에 무관해야함
	즉 엔티티는 순전히 업무에 관한것이고 이외의것은 없음
	
	
	모든 업무규칙이 엔티티처럼 순수하진않음
	자동화된 시스템이 동작하는 방법을 정의하고 제약함으로써 수익을 얻거나 비용을 줄이는 업무규칙도 존재함
	이런 규칙들은 자동화된 시스템의 요소로 존재해야만 의미가 있음(엔티티의 사용방법에 가까운느낌)
	이게 바로 유스케이스임
	엔티티가 핵심업무규칙이라면,유스케이스는 어플리케이션에 특화된 업무규칙을 설명함
	유스케이스는 엔티티 내부의 핵심업무규칙을 어떻게,언제 호출할지를 명시하는 규칙을 담음
	또한 유스케이스는 사용자인터페이스를 기술하지않음,유스케이스만 봐서는 웹을통해 전달되는지 뭔지 알수없음
	
	즉,유스케이스는 시스템이 사용자에게 어떻게 보이는지를 설명하지않고,
	어플리케이션에 특화된 규칙을 설명하며 이를통해 사용자와 엔티티사이의 상호작용을 규정함
	엔티티는 유스케이스에 대해 몰라야하고,유스케이스는 엔티티에 대해 알고있음
	또한 엔티티는 유스케이스에 비해 고수준이고,유스케이스는 저수준임(유스케이스는 한 어플리케이션에 특화되어있고,엔티티는 아니기때문)
	
	유스케이스는 입력데이터를 받아서 출력데이터를 생성함,이때 유스케이스는 세부구현(db나 웹 작동방식)을 몰라야함
	즉 웹이든 db든 직접 의존하면안됨
	
  7.소리치는 아키텍처
	프로젝트의 디렉토리구조와 최상위 소스파일만 봐도 이 프로젝트가 무슨프로젝트인지 알수있어야함
	좋은 아키텍처는 유스케이스를 중심에 두기때문에,유스케이스를 지원하는 구조를 아무문제없이 기술할수있음
	즉 세부사항을 제외하고 볼수있음,또한 웹이라는거도 당연히 영향을 주면 안됨
	
	아키텍처가 유스케이스를 최우선으로 한다면,또한 프레임워크와 적당한 거리를 둔다면 프레임워크없이 유스케이스 전부에 대해 단위테스트할수있어야함

  8.클린 아키텍처
	모든 아키텍처의 목표는 관심사의 분리임(헥사고날등)
	그래서
		프레임워크 독립성
		테스트 용이성
		ui 독립성
		db 독립성
		모든 외부와의 독립성
	을 갖추게됨
	이런 아키텍처가 동작하게 하는 가장 중요한 규칙은 의존성규칙임
		소스코드의존성은 반드시 고수준정책을 향해야함
	즉 내부에 속한건 외부에 대해 전혀 알지못해야함
	즉 엔티티는 외부의 변경에 영향을 받지 않아야하고,유스케이스는 엔티티에만 영향을 받아야함
	인터페이스어댑터는 자기단에서 sql이나 웹등을 다 처리해야함

  9.프레젠터와 험블객체	
	험블객체는 테스트하기 어려운행위를 분리해서 최대한 저수준으로 몰아내는것
	즉 테스트하기 어려운행위가,테스트하기 쉬운행위까지 어렵게 만드는거를 분리해서 제거하는것이 목표임
	
	보통 외부의존성,gui,db등이 험블객체이고,여기에 직접닿는애들과 그 상위를 분리해내는것임(유스케이스,즉 서비스와 레포지토리의 분리 등)

  10.부분적 경계
	아키텍처 경계를 완벽하게 만드는건 비용이 많이듬
	바운더리 인터페이스,인풋아웃풋용 데이터구조,두 영역을 독립적으로 컴파일하고 배포할수있게 격리를 위한 의존성관리등
	근데 이렇게 선제적으로 만들어두면 yagni(미리만들어두지마라)원칙에 위배됨
	그러면 부분적 경계를 생각해볼수있음
	
	방법은 여러개가 있는데
		마지막단계(독립적 컴파일,배포가능까지만 하고)인 컴포넌트 분리만 하지않는것
			이러면 만드는데 비용은 그대로 들지만,다수의 컴포넌트를 관리하는비용은 들지않음(배포부담은 들지않음)
		일차원경계인 쌍방향 인터페이스를 사용,이건 양쪽으로부터 분리된 인터페이스를 사용하는것,단 클라가 구현체를 직접가져가는걸 막을수없음
		퍼사드는 모든 서비스클래스를 메서드형태로 정의하고,호출이 발생하면 해당서비스클래스로 호출을 전달하는것
			클라는 직접 서비스클래스에 접근할수없음,단 클라는 모든 서비스클래스에 대해 추이종속성을 가지게됨(퍼사드를 의존하니까)
	등이 있음,각각 나름의 비용과 장점을 가짐
	
  11.계층과 경계
	그냥 단순하게 도메인과 입력출력으로 구성될수도있지만,입력과 출력에서 여러가지를 구현해야할수있음
	이때도 그냥 dip를 사용해서,인터페이스를 만들어 소스코드의존성과 런타임의존성을 뒤집으면됨
	
	그리고 아키텍처 경계는 어디에나 존재하지만,이게 언제 필요한지를 신중하게 파악해내야함
	이렇게 경계를 제대로 구현하는건 비용이 많이들기때문,또한 이런 경계가 무시되면 나중에 다시 추가하는비용이 더 크기도 하고
	즉 알아서 잘해라..인듯
	경계가 필요할수도 있는 부분에 주목하고,조짐이 보이면 비용을 가늠해보고 있어야겠다싶으면 만드는식
	
  12.메인 컴포넌트
	모든 시스템에는 최소한 하나의 컴포넌트가 존재하고,이게 메인컴포넌트임
	메인컴포넌트는 가장 낮은수준의 정책으로,얘는 시스템의 초기진입점임
	그래서 운영체제를 제외한 모든건 메인에 의존하지않음
	
	메인은 모든 팩토리와 전략,시스템관련 기반을 생성하고,제어권을 더 높은수준으로 넘김
	그래서 의존성주입 프레임워크를 이용해 의존성을 주입하는일은 메인에서 이루어져야함,
	또한 메인에 의존성이 주입되고나면 메인은 di프레임워크없이 의존성분배를 할수있어야함
	
	보통 메인에서는 입력스트림생성,입력명령어 해석등만 처리하고,실제로 명령어를 처리하는건 고수준으로 넘겨야함
	
  13.크고작은 모든 서비스들
	마이크로서비스같은 물리적으로 분할된 아키텍처를 사용한다고 하더라도,바로 서로간의 의존성이 끊어지는게 아님
	단순하게 함수호출이 비싸질뿐임
	핵심은 고수준과 저수준의 분리이고,즉 의존성규칙을 따르며 아키텍처 경계를 넘나드는 함수호출이어야함
	
	단순히 시스템을 서비스들로 분리한다고 결합이 확실히 분리되지않고(한쪽에서 수정하면 반대쪽도 수정해야할수있으니까)
	개발 및 배포독립성도 없을수있으며(한쪽에 의존하면 그쪽이 끝나기전까지 개발할수없고,한쪽이 수정하면 다른쪽도 같이 배포해야할수있음)
	
	횡단관심사가 있으면 새로운 기능을 추가하기 어려운데,이때는 인터페이스들을 만들고 새로운 기능들을 구현하는 클래스집합을 추가하면됨(각각)
	이러면 의존성규칙을 준수할수있음
	생성할때는 템플릿메서드나 전략패턴을 사용하는식임
	
	서비스단위에서도 이게 가능해야함
	즉 아키텍처 경계는 서비스사이에 있지않고,서비스를 컴포넌트단위로 관통함,그래서 서비스들을 의존성규칙도 준수하는 컴포넌트아키텍처로 설계해야함
	즉 서비스는 아키텍처적으로 그리 중요하지않고,아키텍처쪽에서는 내부에 그어진 경계와 경계를 넘나드는 의존성에 의해 정의됨

  14.테스트 경계
	테스트는 시스템의 일부이고,아키텍처에도 관여함
	본질적으로 테스트는 의존성규칙을 따르고,매우 세부적이고 구체적으로 항상 테스트대상이 되는 코드를 향함
	즉 아키텍처의 가장 바깥쪽 원이라고 볼수있음
	
	테스트가 가장 바깥이라고 테스트가 시스템의 설계범위 밖에있다고 여기면,테스트는 깨지기쉬워지고 시스템은 뻣뻣해져서 변경하기가 어려워짐
	여기서 문제는 결합인데,시스템에 강하게 결합된 테스트는 시스템이 변경될때 함께 변경되어야하고,공통컴포넌트가 변경되면 엄청난수의 테스트가 망가짐
	즉 gui에 의존하는 테스트가 있다면,gui를 조금만 건드려도 다 깨진다는것
	그래서 설계할때는 테스트를 생각해서 설계해야하고,변동성이 있는것에 의존하면안됨
	즉 포트어댑터를 사용한 약의존을 사용하는것
	
	테스트api의 역할은 어플리케이션의 구조를 테스트로부터 숨기는데 있고,이러면 코드를 리팩터링하거나 변경해도 테스트에는 전혀 영향을 주지않음
  
  15.클린 임베디드 아키텍처
	임베디드에서도 펌웨어(변경이 어려운부분)와 소프트웨어(변경이 쉬운부분)을 구분해서 만들어야한다는것
	즉 펌웨어는 가장 작아야하고,소프트웨어가 그부분을 잡아먹어야함


6.세부사항
  1.데이터베이스는 세부사항이다
	데이터베이스는 데이터모델이 아니고,세부사항일뿐임
	즉 데이터에 접근할 방법을 제공하는 유틸리티일뿐임
	
	어플리케이션의 유스케이스는 데이터가 테이블구조를 가지는지를 몰라야함
	결국 데이터베이스도 하드디스크를 잘 사용하기위해 나온거고,나중에 ssd(ram)기반이 되면 또 어떻게 될지모름,즉 그래서 세부사항일뿐임
	또한 성능문제도 어플리케이션에 중간에서는 알필요없고,가장자리인 db와 통신하는 레포지토리에서 신경쓸문제임

  2.웹은 세부사항이다
	웹이라는거도 어짜피 클라와 서버중 어디서 연산할지를 두고 계속 진동하는거일뿐임
	그리고 결국 웹이라는것도 입출력도구일뿐이니까 비즈니스로직과는 완전히 분리되어서 웹에 의존하면안됨

  3.프레임워크는 세부사항이다
	프레임워크를 비즈니스로직과 붙여버리면,다시는 뗄수없을정도로 뽑아내기가 매우 힘들어짐
	또한 프레임워크가 어플리케이션의 초기에는 도움이되지만,성숙해져서 프레임워크를 벗어나야할때 힘들어짐
	또한 사용중이던 기능이 사라지거나(업데이트),반영하기 힘들게 변경될수있음
	
	프레임워크는 아키텍처의 바깥쪽 원에 속하는 세부사항이어야함,즉 프레임워크가 아키텍처의 안쪽원에 들어오면안됨
	만약 프레임워크가 자신의 기반클래스로부터 파생하기를 원하면 프록시를 만들어서 di받아야함

  4.사례연구:비디오 판매
	초기아키텍처 구축의 첫단계는 액터와 유스케이스를 식별하는것
	기존기능을 변경해야한다면,이유는 반드시 이들 액터중 하나에게 해당기능을 제공하기위해서여야함
	그래서 특정액터를 위한 변경이 다른액터로 퍼지지않게 만들어야함
	
	또한 여러 유스케이스들이 같은걸 건드리면,해당 유스케이스(대상)를 추상유스케이스로 하고,다른유스케이스에서 이걸 더 구체화하면됨
	
	의존성은 하위에서 상위로 의존해야함,데이터흐름과는 상관없음
	만약 데이터흐름과 의존성이 역행해야한다면 의존성역전을 사용하면됨

  5.빠져있는 장
	가장 단순한 설계방식은 레이어드아키텍처임
	단 레이어드아키텍처의 단점은 소프트웨어가 커지면 이거만으로는 해결되지않고,또한 이건 업무도메인에 대해 아무것도 말해주지않음
	
	다른방법은 기능기반 으로 묶는방식이 있음
	이건 애그리거트 루트에 기반해서 수직의 얇은조각으로 코드를 나누는 방식임
	즉 한 기능에 속하는걸 전부 한 패키지에 다 담아버리는방식임
	이러면 이 코드가 어떤 기능과 관련된 무언가를 한다는걸 바로 알수있어짐,또한 해당 작업과 관련된 코드를 찾기가 쉬워짐
	
	핵사고날아키텍처는 도메인과 외부와의 분리를 위해 생긴 아키텍처임
	이거도 모든 의존성은 내부를 향하고,내부는 외부에 절대 의존하지않음
	
	또 신경써야하는건 의존성 건너뛰기임
	컨트롤러가 직접 레포지토리를 사용하는등을 말함
	이건 cqrs패턴을 지키기위해서가 아니면 바람직하지못함
	이런걸 막기위해 자동화된 린트같은거로 이런걸 막아내야함


























































































	
	
	
	
	
	
	