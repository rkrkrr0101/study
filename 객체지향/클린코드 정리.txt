1.깨끗한 코드
	처음부터 코드를 깔끔하게 짜둬야 생산성저하가 덜일어남
	결국 코드짤때 하는거중 90퍼는 다른코드를 보는거라,이래야 효율이좋음

2.의미있는 이름
	이름은 의도가 분명하게 이름을 지어야함
	즉 함수나 변수의 이름만 봐도,이게 뭐하는앤지,왜있는지,어떻게 사용할지가 주석없이 바로 보여야함
	즉
		int d;//이걸
		int fileAgeInDays;//이런식으로 명시적으로 적어야함
	즉 변수에있어서는 측정하려는값과 단위를 표현하는 이름이 필요함
	
	그리고 코드맥락이 변수명에 드러나야함
	a,b같은거 대신 gameBoard같은 명시적인 이름을 사용해야,얘가 이거로 뭘하려고하는지가 바로보임
	
	그리고 코드에 잘못된 정보가 있으면 안됨
	즉 널리 쓰이는 의미가 있는 단어를 다른의미로 사용하면안됨
	즉 실제 list타입이 아니면 accountList대신 accounts나 accountGroup 이런식으로 적어야함
	
	그리고 의미없이 비슷한이름을 가진애가있으면 헷갈리니까,이름이 비슷하려면 같은일을 하는친구여야함

	변수명에는 의미없는 불용어나 단숫숫자나열을 붙이면안됨
	a1,a2,a3이런거 대신 명시적인 이름을 붙여야하고
	Product가 있다고 ProductData라는 새로운 클래스를 만들면,의미가 중복됨
	즉 해당 이름이 이미 선점되어있으면,그안에 넣거나 그걸쓰거나,둘이 구분되는 이유를 찾아서 그걸 이름에붙여야함
	
	불용어의 경우엔 어짜피 의미가없으면 걍 지우는게맞음
	최대한 의미가 드러나는 가장 짧은 이름을 사용해야함
	
	그리고 해당일을 하는 함수명은 하나여야함
		getActiveAccount();
		getActiveAccounts();
		getActiveAccountInfo();
	이렇게 3개가 같이있으면,뭘써야할지 모르게됨
	
	그리고 이름은 발음하기 쉬운이름이 좋음 genymdhms대신 generationTimestamp같은이름을 사용
	
	그리고 검색하기 쉬운 이름을 사용해야함
	그래서 상수를 언더바를 사용해서 대문자로 정의하는것
	7같은건 찾기힘들지만 상수는 찾기쉬움
	이름길이는 검색스코프의 크기에 비례해야함

	
	요즘은 타입을 이름에 명시할필요가 없음,어짜피 ide가 다처리해주니까
	그래서 헝가리안이 죽기도했고
	멤버변수에 m_을 붙일필요도없음
	애초에 저런거 구분할필요가 없을정도의 크기로 함수가 나와야함
	
	그리고 인터페이스와 구현클래스에 이름을 붙일떄도,딱히 구분지을필요는없음
	어짜피 인터페이스를 구현클래스처럼 다뤄야하는데,쓸데없는 정보를 줄필요는 없음
	
	읽는사람이 읽으면서 변수이름을 치환해서읽어야하면 그건 잘못된것임
	문자하나만 사용하는 변수이름은,반복문을 제외하곤 사용하면안됨

	
	클래스이름과 객체이름은 명사나 명사구가 적합함
	Manager,processor,Data,Info같은 단어를 피하고,동사는 사용하지않음
	
	메서드이름은 동사나 동사구가 적합함
	postPayment,deletePage,save 이렇게 동사+대상이나 동사로만 구성되는게 적절함
	그리고 관례상 접근자엔 get,변경자엔 set,조건자는 is를 붙임
	
	생성자를 오버로드해야하면 정적팩토리메서드를 사용하는게 좋음
		Complex fulcrumPoint=new Complex(23.0)//이거보단
		Complex fulcrumPoint=Complex.FromRealNumber(23.0)//이게나음
	생성자사용을 제한하려면 private를 걸면됨
	
	이름이 너무 기발하면,생각이 비슷한사람만 이름을 기억함
	그래서 재밌는이름보다 명료한 이름을 선택해야함
	
	한개념에 한단어를 사용해야함
	즉,어떤값을 가져오는거에 get,fetch,retrieve등 제각각 부르면 혼란스러우니까,컨벤션을 정해 하나로 통일해야함
	즉 해당일을 하는거면 그단어가 들어가는식으로 통일해야함
	
	한단어를 두가지목적으로 사용하면안됨
	다른곳에서 이미 다른용도로 사용하고있는거면,해당용도가 아니면 그걸 사용하면안됨
	예를들어 숫자나 문자 더하는데서 add를 사용하고 있었는데,리스트에 값을 추가하는데에 add를 사용하면안됨
	이때는 insert나 append같은 다른단어를 사용해야함
	
	코드를 읽을사람도 프로그래머니까,이쪽단어들(패턴이름,알고리즘이름등)은 사용해도됨
	단 문제영역(도메인영역)은 정 없으면 가져오는데,가능하면 다른거로 해결하는게좋음
	
	의미있는 맥락을 추가해야함
	스스로 의미가 분명한애들은 상관없는데,안되는애들은 클래스나 함수같은데 넣어 맥락을 부여해야함
	그래도안되면 마지막수단으로 접두어를 붙이면됨
	즉 state가 street랑 같이있으면 주 지만,다른곳에있으면 상태일수 있는거처럼,다른친구들(다른변수들)이랑 묶어서 알아볼수있게 해주는거임
	
	불필요한 맥락을 없애야함
	모든곳에서 동일하게 사용되는 접두어나 접미어는,아무의미없이 이름만 길어지니까 필요없음
	그리고 클래스이름은 짧아지고,인스턴스이름은 길어지는게 일반적임
	Address와 accountAddress같은느낌
	
3.함수		
	함수는 작게만들어야함
	함수는 작을수록 이해하기쉽고,하나의 역할만 하기좋음
	이런 작은함수들을 모아서 일을 시켜야함
	
	그리고 if나 for같은 블록안에 다시 if로 들여쓰기가 2줄이상되면안됨
	그러면 안에꺼를 메서드추출해야함
	
	그리고 함수는 한가지만 해야함
	여기서 한가지란,한가지 기능을 구현하거나,기능들을 여러개 같이 호출하거나 둘중 하나임
	여기서 함수안에서 만약 다른이름으로 추출할수있는게 보이면,그건 여러작업을 하고있는거임
	
	그리고 함수안에서의 모든문장의 추상화수준은 동일해야함
	즉 같은레벨에서의 일을 해야함
	다른기능들을 호출하기만 하다가 로우레벨의 직접계산같은걸 하면안됨
	
	코드는 위에서 아래로 이야기처럼 읽혀야함
	한 함수밑에는 추상화수준이 한단계 낮은 함수를 배치해야함
	즉 to를 읽듯이 읽혀야함

	스위치문은 작게만들기 어려워서 잘 사용하지않음
	근데 가끔 써야할땐,다형성을 이용해서 저차원클래스에 숨긴다음에 절대로 반복하지않는방법은 있음
	즉 추상팩토리에 스위치문을 숨기고,그걸통해서 생성에만 사용하는것
	즉 다형성객체를 생성하는 추상팩토리에서만 허용됨
	
	함수의 이름은 서술적이어야함
	즉 testableHtml보단 SetupTeardownIncluder.render이 나음
	코드를 읽으면서 짐작했던 기능이 그대로 수행되려면,함수이름에 다 드러나는게좋음
	이름이 좀 길어도 어짜피 ide가 불러주니까 상관없고,이름을 여러번 바꿔서 읽어봐도됨(어짜피 바꾸기쉬우니)
	그리고 이름을 붙일때는 일관성이 있어야함
	모듈내에서 함수이름은 같은문구,명사,동사를 사용해야함(같은단어는 같은맥락으로)
	includeSetupPages가 있으면,includeSuiteSetupPages가 있는식
	
	함수의 인수는,이상적으로는 0개,그다음은 1개,마지막으로 2개,3개이상은 피하는게좋음
	인수가 있으면 이해하기 어렵고,거기를 읽을때 브레이크가 한번 걸림
	거기다 테스트관점에서 보면 경우의수가 너무늘어남
	그리고 출력인수는 입력인수보다 이해하기어려워서 가능하면 사용하지않는게 좋음
	
	함수에 인수를 하나넘기는건 보통,인수로 질문을 던지거나,인수를 뭐로 변환해서 받거나 둘중하나임
	그거말곤 가끔씩 이벤트를 넣는건 있음
	이벤트함수는 조심해야하는게,이벤트라는게 코드에 명확히 드러나야함
	이런게 아니면 단항함수는 가급적 피하는게 좋음
	출력인수같은건 쓰면 이게뭐지하고 헷갈림
	
	플래그인수와,함수로 불리언값을 던지는건 함수가 여러개를 처리한다고 대놓고 말하는거니까 쪼개야함
	
	이항함수는 인수가 1개인함수보다 이해하기어려움
	물론 좌표계같은경우엔,둘을 하나로 묶어야하니까 단항이라고 생각해도됨
	여기서 말하는건 인수끼리의 관계가 없는경우
	만약 첫인수로 대상을 받고,두번째로 값을 받는 그런건 걍 확장함수나 그 클래스의 멤버함수로 만들어서 단항함수로 만드는게 읽기쉬움
	
	삼항함수는 신중하게 써야함
	인수가 2~3개 필요하면 일부를 독자적인 클래스 변수로 선언할 가능성이 없는지를 확인해야함
	아예 데이터클래스같은 클래스로 뽑아버리는게 훨씬 읽기쉬워짐
	
	그리고 인수갯수가 가변적이면,해당 변동인수를 리스트로 묶어서 생각하면됨
	
	그리고 함수의 의도나 인수의 순서와 의도를 제대로 표현하려면,좋은 함수이름이 필요함
	단항함수는 함수와 인수가 동사/명사 쌍을 이뤄야함(write(name)이나 writeField(name))
	그리고 함수이름에 인수이름을 넣어버리면,덜헷갈릴수있고,인수순서도 그대로적으면됨
	
	
	사이드이펙트는,함수에서 하나만한다고 해놓고 두개이상을 하는거니까 사기치는거임
	이러면 시간적결합이나 순서종속성같은게 생겨버릴수가있음

	보통 우리는 인수를 함수입력으로 해석함
	출력인수는 피해야함
	
	함수는 뭔가를 수행하거나,뭔가에 답하거나 둘중 하나만 해야함
	둘다하면안됨
	그래서 나온게 명령과 쿼리의 분리임
	즉 객체상태를 변경하거나,객체정보를 반환하거나 둘중 하나만 해야함
	
	오류코드보다 예외를 던지는게 나음
	명령함수에서 오류코드를 반환하면,미묘하게 명령조회분리규칙이 깨짐
	if에서 명령을 표현식으로 사용하기쉬워지기때문
	그래서 void로 리턴하고,아니면 예외를 던지는게나음
	예외를 던지면,오류처리코드가 원래코드에서 분리되니까 코드가 깔끔해짐
	
	try/catch블록은 보기싫고,정상동작과 오류처리동작을 섞어버리니 별도함수로 뽑아내는게좋음
		try{
			deleteUser(user)
		}
		catch(Exception e){
			logError(e)
		}
	이런식으로 안에거를 뽑아내는게좋음
	저거자체도 함수로 만들어서 가져다쓰면 훨씬 더 보기좋고
	즉 오류처리자체도 하나의 작업으로 봐야함

	로직이 같은이유로 반복되면,그걸 뽑아내야함
	즉 한이유로 여러군데를 동시에 수정해야하면,그걸 뽑아낼수있다는거니까 뽑아내야함
	
	함수는 처음엔 생각나는대로 짠다음에,그걸 테스트를 만들고,그다음에 코드를 다듬고,함수를 만들고 이름을 바꾸고 중복을 제거하고,
	메서드를 줄이고 순서를 바꾸고,때로는 전체클래스를 쪼개는식으로 리팩토링을 하면됨
	

4.주석
	주석은 좋아봐야 필요악임
	코드로 의도를 표현하지못해서,즉 실패를 만회하기위해 주석을 사용하는거
	주석을 사용하고싶으면,코드로 어떻게 전달할수없을지를 생각해봐야함
	주석의 문제는,코드와 생명주기가 다르고,같이 변경되지않는다는거임
	
	부정확한 주석은,없는거보다 훨씬 더 나쁨
	단일진실공급원은 코드뿐이고,코드만이 정확한 정보를 제공하는 유일한 출처임
	그러므로 주석을 최대한 줄여야함
	
	코드에 주석을 추가하는 일반적인 이유는,코드품질이 나쁘기때문임
	모듈을 짜고나서보니,엉망이고 알아보기 힘들어서,주석으로 땜빵치는거
	주석적기전에 코드를 정리할생각부터 해야함
	
	코드로 의도를 표현해야함,어지간하면 코드로 대다수의 의도를 표현할수있음
	많은경우,주석의 설명을 함수로 만들어서 표현해도 충분함
	
	주석을 사용하는 베스트는
		법적인 주석:법적이유로 주석을 꼭달아야함
		정보를 제공하는 주석:추상메서드가 반환할값을 설명한다던가,이거도 가능하면 함수이름에 정보를 넣는게 더 좋음
		의도를 설명하는 주석:왜 이렇게 구현했냐 의도를 설명하는주석
		의미를 명료하게 밝히는 주석:라이브러리같은 변경하지못하는코드라면,의미를 명료하게 밝히는주석이 유용함,단 이건 주석이맞는지 검증이어려움
		결과를 경고하는 주석:테스트케이스중 엄청나게 긴시간이 소요된다던가 하는걸 경고하려고 달수있음
		todo주석:앞으로 할일을 주석으로 남겨두면 편함,단 주기적으로 지워야함
		중요성을 강조하는 주석:대수롭지않아보여도 중요할때 표시할수있음
		공개api에서의 javadocs:설명이 잘된 공개api는 엄청 유용함,물론 이거도 틀릴수있어서 조심해야함
	나쁜 주석은
		주절거리는주석:그냥 의무감으로 이유없이 다는주석,주석+해당코드만으로 이해가안되면 의미없는주석임
		같은이야기를 중복하는 주석:주석이 코드에서 보이는내용을 반복하면(코드보다 더많은 정보를 제공하지못하면)의미없음
		오해할여지가 있는 주석:주석에 담긴 살짝 잘못된정보로 인해,머리아플수있음
		의무적으로 다는 주석:모든함수나 변수에 의무적으로 다는 주석읜 의미없으니까 하면안됨,헷갈리기만함
		이력기록주석:이건 깃있는데 2023년에 왜함
		있으나마나한 주석:너무 당연한사실을 언급하는 주석,이건 생성자야 이런거
	가 있음
	
	함수나 변수로 표현할수있으면 주석을 달필요가 없음
	그리고 위치를 표시하는 주석(배너)은,정말 가끔 사용해야만 의미가있음
	닫는괄호에 주석을달고싶으면(이건 이프문이야 이건 반복문끝이야),함수를 뽑자
	
	코드를 주석으로 처리하는건 하면안됨,브랜치에 머지를 한순간에는 이런건 없어야함
	
	html주석은 사용하면안됨,이런거를 html로 바꾸는책임은 해당 도구가 져야지,프로그래머가 가지는게아님
	
	주석을 달아야하면 근처에있는 코드만 기술해야함,즉 해당주석이 있는위치는 바로밑을 설명해야함
	그리고 주석에 쓸데없는 정보를 넣을필요는없음
	
	주석과 주석이달린코드는,둘사이의 관계가 명백해야함
	독자가 주석과 코드를읽고 무슨소린지를 알수있어야함
	
	짧은함수는 긴설명이 필요없어서 좋음
	
	비공개코드에서는 javadocs는 쓸모없음



5.형식 맞추기
	코드는 형식을 맞추기위해 규칙을 정하고 모두 그 규칙을 따라야함
	린트같은 도구를 사용할수있음
	
	코드의(한파일의) 세로길이는 보통 200~500근처임 200내로 처리하는편임
	엄격한규칙은 아닌데,보통 이정도로 맞추는게 이해하기쉬움
	가로길이는 보통 120자정도까지만 허용
	소스도 신문처럼 이름은 간단하고 설명가능하게(이름만보고도 여기봐야하는지 알수있게),
	맨위는 고차원개념과 알고리즘설명
	내려갈수록 저차원 구현
	이런식으로 작성하는게좋음
	
	그리고 각 개념들은 빈행으로 분리하면 일기 좋음
	즉 빈행이 나오면 거기서 한문단이 끝난거
	
	그리고 서로 밀접된 관계가 있는 코드는,세로로 가까이 놓여야함
	즉 여기저기 찾으러 다니지 않아도되게,붙어있어야함
	
	변수는 사용하는위치에 최대한 가까이 선언하는게 좋음
	인스턴스의 변수는,클래스의 맨처음에 선언하면됨
	
	한 함수가 다른함수를 호출하면,두 함수는 세로로 가까이 배치하고,호출하는 함수를 호출되는 함수보다 앞에 배치함
	그리고 서로 비슷한 코드(오버로드된코드,개념적으로 비슷한코드)는 근처에 배치
	
	가로로는 공백을 사용해 밀접한개념과 느슨한개념을 표현할수있음
	즉 왼쪽과 관계가 많은(함수의 인수같은)거면 붙이고, +=같은거는 양쪽에 공백을 줘서 강조할수있음
	
	들여쓰기는 if문내에 한줄이 들어가더라도 늘려쓰는게나음


6.객체와 자료구조
	그냥 변수를 외부에 퍼블릭으로 공개하는것과,게터세터로 싸서 공개하는것과의 차이는,한번 추상화를 할수있다는것에 있음
	물론 게터세터를 다 열어두면,구현을(클래스의 구현) 외부로 노출하는것과 똑같기때문에 피하긴해야함
	걍 게터세터로 싸둔다고 추상화가 되는것도아니고,그런다고 클래스가 되는것도아님
	
	자료를 세세하게 변수단위로 공개하는것보다,추상적인 개념으로 표현하는게 더 좋음
	
	단 모든게 객체지향이어야 하는게 아님(상속받고하는거)
	절차지향으로 만들면,따로 다른데 신경쓸필요없이 각 클래스에 메서드를 추가할수있고,대신 새 클래스를 추가할때 다 고쳐야함
	객체지향으로 만들면,따로 다른데 신경쓸필요없이 새 클래스를 추가할수있고,대신 클래스에 메서드를 추가할때 다고쳐야함
	
	즉 절차지향은 자료구조를 만들때 사용하기쉽고,객체지향은 객체를 만들때 사용하기쉬움
	그래서 새로운 함수가 아닌 새로운 자료타입이 필요하면 객체지향과 클래스,새로운 함수가 필요하면 절차지향과 자료구조가 더 적합함
	
	디미터법칙은,모듈은 자신이 조작하는 객체의 속사정을 몰라야한다
	즉 자기랑 친한애만 호출해라는 법칙임
	단 여기서도,대상이 자료구조면 상관없음,객체라면 문제지만
	자료구조는 내부를 숨기지않기때문에 들어가도됨(그래서 아예 public으로 둬서 구분하기쉽게하는게좋음)
	그리고 객체에게 뭘 가져오려고 해결하지말고,객체에게 시키는게 좋음(해당일을 알아서 해서 가져다달라고)

	자료구조체의 전형적인 형태는,dto임
	이건 보통 api로 리턴을 던질떄나,db에서 통신할때 같을때 사용됨
	
	활성레코드는 dto의 특수한형태임
	공개변수가 있거나 비공개변수에 게터세터가 있는구조지만,save나 find같은 탐색함수도 제공함
	이건 db같은데서 자료를 직접 변환한 결과임
	이런 활성레코드에 비즈니스로직을 직접 추가해서 객체로 취급하는건 바람직하지않음
	즉 활성레코드는 자료구조로 취급해야함

7.오류처리
	오류코드보단 예외를 사용하는게 더 깔끔하게 설계가 나옴
	오류코드의 문제는 빼먹고 처리안하기가 너무쉽다는데있음
	그래서 대신 예외를 사용하면,걍 터지니까 처리안할수가 없게만듬
	그리고 추가로,비즈니스로직과 오류처리로직을 분리할수있다는 장점이 있음
	
	트라이캐치는,트랜잭션과 비슷한느낌임
	트라이에서 무슨일이 생기든,캐치에선 상태를 일관성있게 유지해야함
	그리고 캐치에서도 예외를 핀포인트로 잡아서 처리하기도 쉽고(오류코드처럼)
	
	그리고 체크예외보단 언체크예외가 쓰기편함
	체크예외는ocp를 위반함(무슨예외를 던지는지 밑에서부터 캐치있는데까지 다 알아야함),즉 캡슐화가 깨짐
	
	그리고 예외를 던질땐 전후상황을 충분히 덧붙여서,오류메시지에 정보를 담아 예외랑 같이던지는게좋음
	이때 실패한연산이름과 실패유형도 같이넣는게 좋음(로깅하기편함)
	
	예외를 분류할땐,예외를 잡아내는방법이 가장 중요한 관심사가 되어야함
	예외처리는 보통,예외를 기록하고,계속진행해도되는지 확인만 하면됨
	한 클래스가 던지는 예외들의 래퍼클래스를 만들어서,거기서 분류하는방법이 잘 사용됨
	보통 외부api를 감싸서 사용할때 자주사용됨
	이러면 외부에서 api를 설계한방식에 발목잡히지않아서 자주사용됨
	
	이렇게하면,비즈니스로직과 오류처리로직이 분리된 코드가 나오는데,문제는 오류처리가 프로그램 언저리로 밀려나게됨
	이게 가끔 문제될때가 있음
	보통 특수상활을 처리할필요가 없을떄 나옴
	이떈 특수사례패턴을 사용하면됨(필요해지면 찾아보자)
	
	그리고 흔히 실수하는것들은
		널을 반환하지마라:널을 반환하면 받는쪽에서 널확인도 해야하고,빼먹을수도있고 머리아프니까 널은 반환하면안됨
			만약 외부api가 그러면,그걸감싸서 null이면 예외를 던지는 객체를 만들수있음
		널을 전달하지마라:메서드로 널을 보내는방식은 더 안좋음,정상적인수로 널을 기대하는api가 아니라면 이렇게 던지는건 최대한피해야함
	가 있음(코틀린쓰자)
	

8.경계
	인터페이스 제공자는 적용성을 최대한 넓히고싶어하고,사용자는 최대한 좁은걸 사용하고싶어함
	사용할떄 생각해보면,map같은거도 그래서 map하나만 있어도 클래스로 싸서 쓰라고 그러는거처럼 최대한 내 상황에 딱 맞는걸 쓰고싶어함 사용자는
	그런식으로 컬렉션을 클래스로 숨기고,거기서 사용할 액션만 메서드로 뽑아서 감춰서 캡슐화하는게 자주사용되는 패턴임
	
	추가로,map같은걸 인수로 넘기거나 반환값으로 사용하면안됨,이경우에도 위처럼 클래스로 숨겨서 던지거나 해야함
	
	그리고 외부코드를 사용할경우,즉 라이브러리같은걸 사용할때는 학습테스트를 만들면서 돌리면,어짜피 학습하려고 툭툭쳐보긴 해야하니까 어짜피 해야할일인데
	테스트까지 추가로 남아서,나중에 라이브러리버전을 바꿀때도 도움이됨
	이런식으로 하는게 좋음
	
	그리고,아는코드와 모르는 코드를 분리할때,혹은 아직 만들어지지않은 코드와 분리할떄도,인터페이스를 사용해 양쪽다 인터페이스에 의존하면 쉽게 만들수있음
	이런식으로 경계를 잘만들어두면,변경을할때도 싸게할수있음

9.단위테스트
	테스트는,단지 지금 돌아가는걸 확인하는것만이 아닌,회귀테스트까지 같이하게끔 해야 효율이 좋음
	
	tdd는
		실패하는 단위테스트를 작성할때까지 코드를 건드리지않음
		컴파일은 실패하지않으면서 실행이 실패하는정도로만 단위테스트를 작성
		현재실패하는 테스트를 통과할정도로만 실제코드를 작성
	하는 방식임
	이러면 개발과 테스트가 30초주기정도로 묶이고,테스트코드와 실제코드가 같이나올뿐더러,테스트코드가 실제코드보다 몇초전에 나옴
	이러면 테스트가 막 엄청나게 생기는데,여기서오는 관리문제가 생기기도함
	
	테스트코드의 품질을 관리하지 않으면,만약 비즈니스로직에 변화가 생겨서 테스트코드를 변경해야할때 변경하는게 너무힘들어짐
	그래서 테스트코드가 합연산의 부하가 아닌,곱연산의 부하가 돼버림
	
	테스트는 유연성,유지보수성,재사용성을 제공해야함
	추가로 테스트로 인해 변경이 어려워지는거도 없어야함
	
	깨끗한 테스트코드를 만들기위해선,가독성이 제일 중요함
	그러려면,명료성,단순성,풍부한 표현력이 필요함
	테스트코드는 최소의 표현으로 많은걸 나타내야함
	
	한 테스트코드에선,하나만 테스트하는게 좋고,가능하면 gwt로 문단을 나눠서,고정된 형식으로 테스트하는게 좋음
	테스트코드에서 효율성은 좀 제쳐놔도됨,가독성이 제일중요함
	그래서 좀 이해안되는부분들을 함수로 만들어서 이름을 붙이고 할수있음
	그리고 테스트함수 하나당,한 개념만 테스트하는게 좋음
	아니면 이해하는게 버퍼링이생김
	
	깨끗한 테스트에서 따라야할 규칙은
		빠르게:테스트는 빨라야함
		독립적으로:각 테스트는 서로 의존하면안됨
		반복가능:테스트는 어떤환경에서도 반복가능해야함
		자가검증가능:테스트는 불리언값으로 결과를 내야함,성공아니면 실패로 나와야함
		적시에:테스트는 테스트하려는 실제코드를 구현하기 직전에 구현해야함(tdd)
	가 있음

10.클래스
	클래스의 표준관례는
		정적공개상수
		정적비공개상수
		비공개인스턴스변수
		
		공개함수
		비공개함수
	이런식으로 추상화단계가 순차적으로 내려가게 배치되어있음
	변수와 유틸함수는 가능한 공개하지않는게 낫지만,테스트코드에서 필요할경우 protected로 선언해 테스트에선 접근허용하기도 함
	근데 이건 최후의방법이고,가능하면 비공개상태로 두는방법을 찾는게좋음
	
	클래스에서 가장 중요한건 크기임
	클래스는 작아야함,즉 클래스는 단 하나의 책임만 가지고있어야함
	클래스명을 지을때 간결한이름이 떠오르지않는다면,클래스가 너무커서그런거니까 더 쪼개야함
	그리고 processor,manager,super같은게 이름에 들어가면 클래스에 여러책임이 있다는것
	클래스설명은 만약,그리고,하며,하지만을 사용하지않고 25단어내로 끊을수있어야함
	이래야 단일책임원칙을 지킬수있음
	한 클래스를 수정하는 이유는 단 하나여야함
	
	보통 처음부터 이렇게 만들기 어려우니까,일단 처음엔 돌아가게 만든다음에,
	거기서 책임을 분리해가면서 책임을 하나만 남게 만드는게 일반적임
	
	그리고 클래스는 응집도가 높은게 좋음
	그래서 인스턴스 변수 수가 가능한 적은게 좋고,응집도가 가장 높은건,모든 인스턴스변수를 모든메서드가 사용하는것
	이정도까진 필요없지만,가능하면 응집도를 높게하는게좋음
	즉,함수는 작게,매개변수목록은 짧게 라는 전략을 따르는게좋음
	이러다보면 몇몇메서드만이 사용하는 인스턴스변수들이 많아지는데,이러면 걔네들만 다른클래스로 분리할수있다는 신호임
	이런식으로 응집도를 유지하는것
	
	그리고 구현에 의존하지말고,인터페이스에 의존하는식으로 위험에서 빠져나갈수있음
	이러면 테스트를 짤때,외부에 의존하는애를 테스트할때도,페이크객체를 만들어서 처리할수있어짐
	이러면 결합도도 낮아지고,유연성과 재사용성도 올라감(변경으로부터 격리가 잘되어있으니까)



11.시스템
	소프트웨어에서 제작과 사용은 로직을 분리해야함
	즉 의존성연결과,런타임로직을 분리해야함
	이래야 관심사분리+단일책임원칙이 지켜지게됨
	
	그래서 사용되는게 의존성주입이고,의존성주입은 제어역전을 의존성관리에 적용한 메커니즘임
	이건 아예 의존성을 연결해주는일만 하는 객체를 만들어서,걔한테 init를 맡겨버리는거임
	클래스는 그냥 생성자를 열어서 주입만 받고,만들어지는 수동적인 존재가 되는거고
	이렇게 사용하는게 스프링임
	
	처음부터 올바르게,완벽하게 시스템을 만들수는없음,단지 확장하기 쉽게 만들수만 있을뿐임
	이게 애자일의 핵심임
	
	그리고 aop도 횡단관심사라는,여러군데서 동시에 나오는 관심사들을 처리하기위해 나온 방법임
	이건 프록시를 사용해,마트료시카처럼 데코레이터로 구성해버리는거로 가능해짐
	이러면,도메인로직을 순수자바로 만들수있으면,테스트주도아키텍쳐의 구축이 가능해짐


12.창발성
	켄트백의 규칙4가지만 따르면,설계품질이 올라감
		모든테스트를 실행한다
		중복을 없앤다
		프로그래머의도를 표현한다
		클래스와 메서드수를 최소로 줄인다
	위에서부터 아래로 중요도순임
	
	테스트를 철저히거쳐,모든테스트케이스를 항상 통과하는 시스템은,테스트가 가능한 시스템임
	테스트가 불가능한 시스템은 검증이 불가능하기때문에 중요함
	추가적으로,테스트가 가능한 시스템을 만들려고하면,설계품질이 같이 올라감
	크기가 작고,목적하나만 수행하는 클래스가 나오기때문임(srp를 준수하면 테스트가 쉬워짐,모킹을 하지않을때)
	
	이게 가장 중요하고,나머지는 그냥 리팩토링이라고 보면됨
	즉 저상태로 만들어둔다음,리팩토링으로 코드를 고쳐가는것
	코드몇줄을 추가할때마다 한번씩 보면서,새로추가한 코드가 설계품질을 낮춘다면 정리하고,테스트케이스를 돌리는걸 반복하는거임
	즉 테스트케이스가 보루역할을 해줌
	이떄,응집도를높이고,결합도를 낮추고,관심사를 분리하고,시스템관심사를 모듈로 나누고,함수와 클래스의 크기를 줄이고,이름을 바꾸는등 다양한걸 할수있음
	
	그중에서 중요한건 중복제거임
	중복은 추가작업,추가위험,불필요한 위험도를 뜻하기때문에 최대한없애야함
	그리고 여기선 구현중복도 포함됨
	비슷한로직을 사용하는 메서드라면,다른메서드를 사용해서 중복되는부분을 제거할수있다는거
	깔끔한 시스템을 만들려면,단 몇죽이라고 중복을 제거하겠다는 의지가 필요함
	이렇게 뽑아두면,이걸 다른데서 가져다쓰기고 쉽고,다른맥락에서 사용할 가능성도 있어짐
	템플릿메서드패턴은,고차원중복을 제거할때 자주 사용되는 기법임
	메서드로 분리한다음,추상메서드를 구현을 바꿔야하는데만 넣어버리면되니까
	
	그리고 코드는,자기자신이 뭘하는지를 이름으로 표현하고있어야함
	그리고 함수와 클래스의 크기는 작을수록 이해하기가 쉬워지고,구현도쉬워짐,추가적으로 이름붙이기도 쉬워짐
	그리고 디자인패턴같은걸 사용할땐,그 패턴의 이름을 메서드에 넣는게좋음
	그리고 단위테스트는,예제로써 사용할수도있기때문에 꼼꼼히,가독성좋게 넣어두는게좋음
	
	클래스와 메서드수가 너무 많아지면,이래도 가독성이 낮아짐
	그래도 이건 중요도가 제일 낮기때문에,막 진짜 말도안되게 쪼개는거 아니면 그렇게 신경안써도됨,가독성이 더 중요함
	
13.동시성
	스레드를 여러개돌리는 코드는 문제를 찾기가 어렵고,깨끗하게 짜기 어려움
	동시성은 결합을 없애서,동시에 여러군데서 돌릴수있게해서 효율을 높이는전략임
	즉 what과 when을 분리하는전략임
	
	이게 서로간에 연관이 없을경우엔 문제가 없는데,서로간에 공유자원이 있을경우에는 문제가 생김
	그리고 동시성은,하나이상의 작업으로 구성되어있었을때 성능을 올려주지,하나의작업의 성능은 올리지못함
	
	동시성코드를 작성할때,동시성문제로부터 시스템을 방어하는 원칙은
		단일책임원칙:동시성은 이거하나만으로도 충분히 복잡하니,동시성이있으면 그부분을 바로 떼버려야함
		자료범위제한:코드내 임계영역의 수를 줄이고,해당부분은 synchronized키워드로 보호해야함(성능에 안좋으니 수를 최대한줄여야함)
			그래서 자료를 캡슐화하는방법을 잘 사용함
		자료사본사용:공유자원을 줄이려면 처음부터 공유를 안하면됨,이경우엔 객체를 복사해 읽기전용으로 사용하는게 가능함,어지간하면 코스트얼마안돼서 쓸만함
		스레드의 독립적구현:외부에 영향을 주지않고,받지않는 스레드를 구현하는게 제일좋음(백엔드에서 db안건드리는 요청처럼)
	들이 있음
	그리고 스레드환경에 안전한 컬렉션을 사용하고,가능하면 스레드가 블로킹되지않는 방법을 사용해야함
	생산자소비자패턴은,잘못하면 둘다 진행가능한데 서로 시그널을 기다려서 교착에 빠질가능성이 있고(생산자가 큐에 빈공간이 없다고 판단될때)
	읽기쓰기패턴은 처리율을 높이면 기아현상이 생겨서 적당히 높여야함
	
	그리고 synchronized키워드가 붙은 메서드사이에 의존성이 존재하면,버그가 생길확률이 높음
	그래서 클래스하나에 동기화메서드가 여러개면,이렇게 꼭 구현해야하는지 확인하고 하나로 줄이는게좋음
	정안되면
		클라에서잠금:클라에서 첫메서드를 호출하기전에 서버를 잠금,마지막메서드호출까지 잠금유지
		서버에서잠금:서버에서 서버를잠그고 모든메서드를 호출한후 잠금을 해제하는 메서드를 구현,클라는 이메서드를 호출
		연결서버:잠금을 수행하는 중간단계를 생성(원래서버는 걍 두고,잠구는걸 구현한 서버를 새로만듬)
	같은 방법을 쓸수있음
	
	synchronized키워드가 붙으면,해당코드영역은 한번에 한스레드만 실행이 가능해짐
	그래서 이게 바로 병목이 걸릴수있어서 최대한 줄이는게 좋지만,임계영역의경우엔 반드시 보호해야함
	그리고 동기화하는 부분은 최대한 작게만들어야 성능이슈가 덜남
	
	그리고 스레드를 올바르게 종료하는건 데드락걸릴확률이 높으니까,시간을 많이써서 만들어야함
	(부모가 자식3명꺼 종료기다리는데 한명이 데드락걸려있으면 전체가 데드락)

	
	스레드코드는 올바르다고 증명하기가 매우어려움,어떨땐 실패하고 어떨땐 성공하기때문
	그래서 프로그램설정과 시스템설정,부하를 바꿔가며 테스트케이스를 자주돌리고,테스트가 실패하면 원인을 추적해야함,다음에 돌려서 성공했다고 넘어가면안됨
	
	이때,말이안되는실패는 잠정적으로 스레드문제로 생각하고,다중스레드를 고려하지않은코드부터 정상적으로 만드는게 효율적임
	다중스레드를 쓰는부분을 다양한환경에 쉽게 끼워넣을수있게 코드를 구현하는게 좋음(이래야 테스트가 쉬워짐)
	그리고 프로세서수보다 많은 스레드를 돌려보면,문제를 찾을확률이 높고,os를 바꿔보는거도 괜찮음
	아예 바이트코드건드리는거로 강제로 실패를 일으키게하는방법도 있음



14.점진적인 개선
	코드는 일단 테스트를 통과하는 코드를 만든 후,그걸 정리해야함
	즉 초안을 쓰고,그걸 수정하면서 최종안을 만들어야하는것
	그래서 동작하는게 끝이 아닌,동작하는걸 만드는게 20%고,그뒤로 테스트코드를 등뒤에 두고 확장가능한 형태로 만들어야함
	
	보통 코드가 개판이 되어가는건,수정에서 다른 타입을 지원해야 하거나 그렇게되버리면(큰틀에서),코드가 전체적으로 분기가 들어가며 개판이나버림
	그래서 보통 더 추가하면 머리아파지겠다 싶은 시점에,일단 리팩토링으로 확장이 가능하게 수정한다음 추가를 해야함
	이때 인수의중복을 인터페이스로 뺴버리고,구현을 서브타이핑으로 처리하는게 깔끔함 보통
	이때도 항상 테스트는 성공해야함
	이때,각 인수유형을 처리하는 코드를,인터페이스를 처음엔 클래스로 만들어 다 때려박은다음,클래스를 인터페이스로 만들고 상속하는게 더 편하고좋음
	테스트도 안깨지고
	그다음에 유형을 하나씩 떼가면서 처리하면됨
	
	잘만들어진 코드는,변경이 쉬워야함,이미 있는 분류에서 하나를 추가하는데 있어서 어려움이 없어야함
	
	
15.junit들여다보기
	조건문의 조건이 여러개면,해당부분을 메서드로 뽑아서 캡슐화하자
	멤버변수의 범위를 따로 표시할필요가 없음 요즘은
	그리고 같은이름의 다른스코프의 변수가 있으면,이름을 명확하게 붙이자
	부정문이 긍정문보다 이해하기 좀 더 어려우니,if의 조건메서드명을 긍정으로 만들자
	함수이름은,해당함수가 하는 모든일을 설명해야함(해당추상화레벨에서의)
	시간결합은 없애거나,외부에 명확히 노출해야함(노출하는건 인수로 넘기는식으로 명시하던가,명확한 이름으로 명시하면됨)
	
	리팩토링을 하다보면,바로 직전에 내린 결정을 번복하는일이 자주생김,원래이러니까 그냥 그런갑다하면됨
	
16.serialDate 리팩터링
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	




































