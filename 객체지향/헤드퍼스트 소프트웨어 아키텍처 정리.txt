1.시작하기
  아키텍처는 소프트웨어의 구조(사용자인터페이스,서비스,db,통신프로토콜등)를 정의함
  이건 최종결과를 가시화하고 지침과 제약을 제공함
  
  아키텍처는 4개의 차원으로 구성됨
    아키텍처특성:아키텍처가 지원할 시스템의 측면,즉 확장성,가용성,테스트용이성등
	아키텍처결정:시스템에 시사점을 갖는 중요한결정,db의 종류,서비스갯수,서비스통신방식 등
	논리적 컴포넌트:시스템기능의 구성요소와 그것들이 어떻게 상호작용하는지,즉 어떤 컴포넌트(재고관리,결제등)를 사용하고 어떻게 통신할건지
	아키텍처스타일:물리적구조와 형태를 정의(헥사고날,레이어드등)
  모든 차원은 서로 연계됨
  예를들어 아키텍처스타일은 특성만이 아닌 결정과도 일치해야하고,
  유사하게 정의된 논리적 컴포넌트는 특성과 스타일,결정과 일치해야함
  
  아키텍처를 세울땐 4가지 모든 차원이 다 필요하고,어떤것도 생략할수없음
  즉 내 아키텍처는 MSA야 하는걸로는 아키텍처 스타일만 설명하고,그외의 많은것들을 답하지않은 상태로 두는것
  즉 어떤 특성이 있어야하고,어떤 컴포넌트들이 있고,어떤 결정이 있었는지도 대답에 있어야함
  
  아키텍처특성은 아키텍처의 기반을 형성함
  이게 없다면 아키텍처 관련 결정을 내리거나,트레이드오프를 분석할수없음
  즉 여기서 필요한,즉 확장성,가용성등을 기준으로 트레이드오프의 결정을 내릴수있음
  
  아키텍처결정은 시스템의 구조적측면에 관한 선택으로 장기적으로 중요한 영향을 미침
  이런 결정들은 일종의 제약사항이 되어서,시스템 기획,구축에 도움을 줌
  예를들면 사용자인터페이스가 db와 직접 통신하지않고,서비스를 거쳐서야만 데이터를 조회,갱신할수있다고 하는것
  이건 제약이 되고,다른 개발자들이 어떤식으로 접근하고 갱신해야하는지에 대한 지침을 제공함
  
  논리적 컴포넌트는 시스템의 구성요소로,집으로 치면 방에 해당하는 특정 기능을 수행함
  보통 디렉터리나 네임스페이스로 표현됨
  논리적컴포넌트는 함께 작용하는 블록임(애그리거트)
  논리적 컴포넌트는 항상 시스템에서 잘 정의된 역할과 책임을 가져야함
  다른말로 하면 그것이 무엇을 하느냐에 대한 명확한 정의가 필요함
  즉 주문처리 컴포넌트라면
    이 컴포넌트는 ‘선택과 포장’을 담당합니다.
	창고에 물건을 위치시키는 것은 ‘선택’이고, 그물건에 맞는 정확한 박스 크기를 결정하여 발송될 수 있도록 하는것은 ‘포장’입니다.
  이런식으로 명확한 정의가 있어야함
  
  아키텍처스타일은 각기 다른 고유한 특성들로,전반적인 모습과 구조를 정의함
  msa는 확장성이 좋고,민첩성이 높고,레이어드는 덜복잡하고 비용이 적게듬
  이벤트기반은 높은확장성을 제공하고,매우 빠르고 응답성이 좋음
  이건 시스템의 전반적인 모습과 특성을 정의하기때문에 처음부터 올바른 선택을 하는게 중요함
  이걸 바꾸는건 큰작업이기때문
  
  
  아키텍처와 설계는 다름
  아키텍처는 구조에 중점을 두고,설계는 외관에 중점을 둠
  아키텍처가 전략이라면 설계는 전술임
  즉 아키텍처는 어떤식으로 크게 구성될것인지고,설계는 어떻게 필드를 배치할지,어떤 패턴을 사용할지같은 세부사항에 가까움
  
  설계관점에서는 클래스파일이 어떻게 상호작용하는지를 uml등으로 나타낼수있음
  즉 order이 PaymentMethod와 어떤식의 관계가 있고 이런것들을 다룸
  단 소스의 물리적인 구조(배포,조직등)는 나타내지않음
  아키텍처관점에선 서비스,db등이 다른 서비스나 사용자인터페이스와 어떻게 통신하는지를 다룸
  즉 주문배치서비스가 결제대행서비스와 어떤식으로 통신하는지,어떤 db를 사용하는지등을 다룸
  
  어떤 결정은 아키텍처와 확실히 관련된거지만,다른결정은 분명히 설계와 관련된거임
  보통 대부분의 결정은 이 사이에 있음
  이걸 신경쓰는건 중요함
  이건 누가 이 결정을 내려야하는지를 결정하는데도 도움이 됨(개발팀,아키텍트,함께등)
  
  보통 전략적인 결정(장기적이고 미래의 행동에 영향을 주는)이면 아키텍처,전술적인 결정(단기적이고 일반적으로 다른 행동들에 독립적)이면 설계의 비율이 높음
  또한 변경에 많은 노력이 든다면 아키텍처에 가깝고,적은 노력이 든다면 설계에 가까움
  그리고 중대한 트레이드오프라면 아키텍처,적은 트레이드오프라면 설계에 가까움
  
  즉 결정하는데 많은 생각과 계획이 필요하다면 전략적이고 아키텍처적임
  또한 많은 사람이 참여해야한다면 전략적이고 아키텍처적임
  결정을 위해 장기적인 비전이 필요하다면 전략적이고 아키텍처적임
  또한 나중에 변경할때 높은수준의 노력이 필요하다면 전략적이고 아키텍처적임
  중대한 트레이드오프라면 전략적이고 아키텍처적임
  
  이런것들로 각각 1~10으로 점수를 매긴다음에 평균을 내보면됨
  
2.아키텍처 특성
  어플리케이션을 개발할때 가장 먼저 해야할건 요구사항문서 작성임
  이 요구사항문서를 가지고 아키텍처특성과 논리적 컴포넌트를 분석한후,이걸 기준으로 아키텍처 스타일을 고르면서 아키텍처결정을 하는방식으로 보통 진행됨
  아키텍처특성분석에서는 작게시작해서 계속 개선해나간다는게 먹히지않음
  처음부터 확장성있게 설계되지않으면 확장성있게 만드는건 매우 어려움
  
  우리가 어떤 문제가 있고,이문제를 해결하기위해 소프트웨어를 개발하는데,이때 이 소프트웨어가 다루는걸 도메인이라고 하고,이걸 설계하는덴 많은 노력이 필요함
  즉 도메인은 소프트웨어를 만드는 이유임
  그런데 도메인만이 모든건 아니고,아키텍처특성도 분석해야함
  아키텍처특성은 도메인이 서로 달라도 일부 겹칠수있음(은행과 경매는 확장성이라는측면에서 겹치는등)
  
  아키텍트의 업무중 하나는 구조설계임
  이는 크게 논리적 컴포넌트와 아키텍처 특성 두부분으로 구분되고,논리적 컴포넌트는 어플리케이션 영역을 나타내고,소프트웨어를 만드는 이유를 설명함
  아키텍처특성은 도메인과 관련없이 중요한 내용임,이건 운영능력,내부구조결정,다른 필요한 특성들을 나타냄
  이건
    명시적:비도메인 설계 고려사항을 명시
	암묵적:아키텍처구조에 영향을줌
	아키텍처특성:어플리케이션의 성공에 핵심적이고 중요(필터링용도)
  로 구성됨
  
  명시적은 얘가 뭘 반드시 달성해야하는지를 명시함,즉 비도메인 설계 고려사항,즉 성능과 확장성등 반드시 갖춰야할걸 명시해두고 그걸 실현하는것
  암묵적은 프로젝트상에서는 드러나지않지만 반드시 갖춰야하는(보안등)걸 나타냄
  아키텍처특성은,이게 반드시 필요한건지를 나타냄,아키텍처특성은 늘어날수록 복잡성을 더하게되고,하나의 특성은 다른 특성에 영향을줘서 개발속도가 느려짐
  즉 오버엔지니어링을 피해야함,모든 소프트웨어가 확장성을 가질수는없음
  
  어떤건 명시적으로 명확하게 표현되고,어떤건 맥락이나 다른지식에 기반해서 추측할수있으므로 암묵적임
  명시적인 아키텍처특성은 어플리케이션 요구사항에 명시되어있고,
  암묵적인 아키텍처특성은 요구사항에 명시적으로 나타나지않음
  특히 보안같은게 주로 그럼
  그리고 도메인에 따라 이런게 있을수있음
  고빈도트레이딩회사는 거래가 밀리초로 완료되는게 너무 당연해서, 얼마나 중요한지 명시하지않을수도있지만,해당 도메인 아키텍트라면 이게 얼마나 중요한지 알고있음
  
  아키텍처특성은 스펙트럼이 넓고 보편적목록이 없음
  또한 용어에 따른 실제기준도 없음
  대략적으로 자주 사용되는것들을 분류해보자면
    프로젝트 아키텍처 특성:개발프로세스와 아키텍처가 만나는곳,소프트웨어를 만드는방법에 대한 결정이 반영됨
	  모듈성:소프트웨어가 개별구성요소로 구성되는정도,어떻게 행동을 분할하고 논리적구성요소를 구성할지
	  테스트용이성:테스트가 완전하고 만들기쉬운지
	  배포용이성:얼마나 배포가 쉽고효율적인지
	  신장성:얼마나 시스템을 확장하기 쉬운지(여러카테고리포함됨)
	  민첩성:테스트용이성,배포용이성,모듈성등을 합쳐서 부름
	  비결합성:얼마나 커플링이 적은지(결합도가 낮은지)
	구조적 아키텍처 특성:소프트웨어의 내부구조에 영향을 미치고,결합정도나 통합지점간의 관계등이 포함됨
	  보안:시스템이 얼마나 안전한지
	  유지보수성:얼마나 쉽게 변경사항을 반영할수있는지
	  이식성:얼마나 쉽게 다른플랫폼에서 실행할수있는지
	  신장성:얼마나 시스템을 확장하기 쉬운지(여러카테고리포함됨)
	  국제화:다국어를 얼마나 잘 지원하고있는지
	운영아키텍처특성:아키텍처결정이 운영팀구성원의 작업에 어떻게 영향을 미치는지
	  가용성:시스템이 장애가 발생했을때 얼마나 빠르게 정상화되는지
	  복구성:재난상황에서 얼마나 빠르게 시스템이 다시 정상화되고 비즈니스연속성을 유지하는지
	  견고성:시스템이 실행중에 하드웨어가 고장났을때 오류 및 경계조건을 잘 처리하는지
	  성능:가용한 자원을 사용해서 시스템이 얼마나 시간요구사항을 잘 충족하는지
	  신뢰성:시스템이 페일세이프하거나,사람의 생명에 영향을 미치는정도로 임무가 중요한지
	  확장성:사용자의 수 혹은 요청이 증가할때 얼마나 시스템이 잘 동작하는지
	아키텍처 공통 특성:분류하기어려운것
	  보안:시스템이 얼마나 안전한지
	  인증/권한:보안의 다른측면,시스템에서 사용자가 본인인지 확인하고 해당권한이 있는지 확인
	  합법성:지역법을 잘 지키는지
	  프라이버시:운영자가 시스템의 내부를 회사내에서 보기힘들게 얼마나 잘 숨기는지
	  접근성:색맹,청각손실등의 사용자를 포함해서 얼마나 시스템에 쉽게 접근하는지
	  사용성:사용자가 목적을 달성하는게 얼마나 쉬운지,교육이 필요한지
  이런것들이 있고,이게 당연히 전부가 아님
  이런 아키텍처 특성들을 찾는건
    문제 도메인:많은 구조적설계 결정은 문제도메인에서 직접 나옴
	환경인식:우리가 운영중인 환경을 잘 이해하면(스타트업,대기업등)많은 요구사항이 나옴
	전체적인 도메인지식:해당 도메인에 대한 넓은지식과 규제,소비자의 습관을 알고있으면 특성을 찾기쉬움
  이런것들로부터 찾아낼수있음
  
  문제도메인에서 아키텍처특성을 찾는건,요구사항문서에 명시되어있는 항목들을 아키텍처특성으로 변환하는걸 의미함
  즉 얼마나 많은 사용자가 예상되는지,동시접속자는 얼마나될지,얼마나 빠르게 사용자가 증가할지를 알아야함
  
  환경인식에서 아키텍처특성을 찾는건,현재 조직의 우선순위를 이해하고 이에 맞는 특성을 찾는것
  급하게 만들어야하거나,임시로 쓰려고 만드는건 단순성을 선택할수있고,다른회사와의 협업이 예상된다면 표준프로토콜을 사용하는걸 생각해볼수있음
  
  전체적인 도메인지식에서 아키텍처특성을 찾아내는건,요구사항에는 명시되어있지만 도메인의 중요한측면에 대해 암묵적으로 이해하고있는 정보를 구체화시키는것
  즉 수강신청의 경우 서버시작시에 매우 트래픽이 몰릴걸 예상하고 이에 맞는 아키텍처특성을 선택하는등이 있음
  
  또한 사용자는 요구사항보다 해결책을 가지고 오는경우가 있는데,이때도 이게 왜 필요한지를 되물어서 해결책에 숨겨진 실제 요구사항을 찾아내야함
  
  복합아키텍처특성도 있는데,이건 두개이상의 아키텍처특성이 결합된것
  예를들어 신뢰성은 가용성과 사용자 인터페이스의 일관성,데이터무결성등이 종합된것
  이걸 식별할땐,이 특성을 객관적으로 어떻게 측정하나요?라고 질문을 던져보면됨
  
  모든 우선순위는 맥락을 따르고,모든 프로젝트에서 같은 특성을 선택하는건 불가능함
  모든건 맥락에 맞게 달라져야함
  
  또한 아키텍처특성을 해석하는것도 아키텍트의 역할임
  보통 비즈니스전문가의 요구사항은 평범한 언어속에 숨겨져있고,여기서 숨겨진 요구사항을 찾아내고 이를 아키텍처 특성으로 바꾸어야함
  보통 사용자들은 모든 특성을 다 넣어달라고하지만,이러면 시너지가 나서 설계가 더 복잡해짐
  
  아키텍처특성은 최종결과물의 역량을 나타내고,논리적컴포넌트는 시스템의 설계,즉 행동을 나타냄
  아키텍트는 특성과 논리적컴포넌트 사이에서 적절한 아키텍처 스타일을 결정해야함
  아키텍처특성은 최대 7개로 제한하는게 좋음
  또한 거기서 가장 중요한 3개를 선택하고 순위를 매기고,암묵적특성(서브라고 생각해도됨)도 따로 나열해보는게좋음
	  
3.트레이드오프	  
  특성을 정할땐,이게 프로젝트 성공에 반드시 필요한지 아니면 있으면 좋은정도인지를 진지하게 따져봐야함
  또한 일부특성들은 충돌하는 경향이 있음(암호화와 성능등)
  
  메시징을 사용할때는 크게 큐와 토픽이 있음
  큐는 서비스에서 보낼 큐리스트를 만들고,여기에다가 하나하나 다 던져주는것
  즉 발신자는 수신자가 누군지 알고있음
  토픽은 브로드캐스트,즉 토픽에 글을 올리면 그걸 구독하고있던애들이 알아서 가져가는것
  발신자는 수신자를 신경쓰지않아도됨(약결합)
  
  이 두가지의 트레이드오프는,
  큐는
    장점
      각 소비자에 맞는 정보를 커스텀으로 지원할수있음
	  모니터링과 스케일링이 독립적(확장성)
	  더 안전(보안)
	단점
	  결합도가 높음(신장성 -)
	  서비스가 다수의 큐와 연결되어야함
	  추가적인 인프라가 필요
  즉 신장성을 포기하고 보안과 모니터링이 좀 편해짐
  
  토픽은
    장점
	  결합도가 낮음(신장성)
	  서비스는 한곳에만 메시지를 발행하면됨
	단점
	  각 소비자마다 정보를 커스텀할수없음
	  토픽을 독립적으로 모니터링하거나 확장할수없음(확장성 -)
	  덜안전함(보안 -)
  즉 신장성을 챙기고(추가로 받아갈곳이 생겨도 바꿀거없음),보안(아무나 구독하면 받아가니까)과 확장성을 좀 포기하는형태임
  
  현재 소프트웨어의 상황에 따라 우선순위를 가지고 결정하면됨
  핵심은 트레이드오프의 균형을 맞추는것
  소프트웨어의 모든것은 트레이드오프임
  
  모든 장점에는 단점이 따라오고,해당 장점이 성공적인 어플리케이션 구현에 도움이 되는가?와 단점을 감수할수있는가?를 고려해야함
  모든 결정엔 트레이드오프를 생각한다음에 결과가 나와야함
  
  어느시점에서는 반드시 아키텍처를 결정해야함
  이때 모든 결정이 아키텍처 결정이 되는건 아니고,시스템의 구조에 영향을 미치는 모든 선택은 아키텍처 결정임
  즉
    캐시를 사용해서 db의 부하를 줄이고 성능을 향상시킴->아키텍처결정
	모듈러 모놀리스로 서비스를 만듬->아키텍처결정
	서비스사이에 비동기통신용 큐를 사용할거임->아키텍처결정
  임
  
  
  아키텍처결정은 영구적으로 기록되어야함
  또한 결정 자체도 중요하지만 왜 그런 결정을 내렸는지도 중요함
  이게 기록되어있어야 이미 합당한 이유로 거부한 해결책을 탐색하느라 시간을 들이지 않음
  
  이때 사용되는게 ADR(아키텍처 결정 기록)임
  이건 특정 아키텍처 결정을 설명하는 문서임
  즉 결정을 내릴때마다 하나씩 작성함
  이건
    제목:번호(순서대로증가)와 명사형으로 짧은 제목을 사용,상세내용은 밑에서하면됨
	상태:팀이 이 결정에 대해 어떻게 선택했는지,승인이 된 이후엔 대체가 아니면 adr은 변경할수없음
	  의견요청:추가자문이 필요할때(응답기한이 있어야함)
	  제안:승인을 기다리는중
	  승인:의견이 받아들여짐
	  대체:새로운 상황으로 기존 ADR을 대체해야할때 사용
	    042: 고객 설문조사 서비스를 위해 관계형 저장소를 사용  상태:승인 068로 대체됨
		068: 고객 설문조사 서비스를 위해 문서 저장소를 사용   상태: 승인, 042를 대체함
	맥락:상세내용을 설명,결정에 영향을 미친 모든 요소를 기록해야함,결정을 기록하는건 아니고 배경과 선택지등을 설명하는곳
	결정:내린 결정을 명확하게 표현,결정과 그 결정을 왜 내렸는지를 포함함(+정당화),결정을 승인한 다른사람들을 나열하기도 좋음
	결과:좋든 나쁘든 결정에 대한 결과를 이해하고 투명하게 표현,다른사람들과 같이하는게 좀 더 좋음
	거버넌스:현재와 미래에 걸쳐 이 결정에서 벗어나지않게 보장하는 방법을 기술
	노트:adr에 대한 메타데이터(원저자,승인날짜,승인한사람,마지막수정날짜,수정한사람,마지막수정)
  로 구성됨
  
  adr은 깃으로 저장하거나 위키로 저장하면좋음
  또한 adr은 한프로젝트에만 속할수도,여러프로젝트,회사전체에 속할수도있음
  
  adr은 길고 힘들지않게 작성하는게 제일 중요함
  그래서 섹션을 늘리면 복잡해지니까 가급적 간단하게 작성하는게 좋음
  
  
4.논리적 컴포넌트  
  논리적 컴포넌트는 아키텍처의 한 차원으로,문제도메인을 구성하는 시스템의 기능적 구성요소임
  디렉터리별로 보면
    app //도메인
	  order  //하위도메인
	    tracking  //논리적 컴포넌트
		  소스코드1
		  소스코드2
  이런식으로 구성됨
  보통 디렉토리는 아키텍처의 일부고,소스코드는 설계의 일부임
  그래서 아키텍처적으로 볼땐 디렉토리만 가지고 접근할수있음
  
  논리적 아키텍처는 시스템의 모든 논리적 구성요소와 그것들이 서로 상호작용하는방식(결합)을 보여줌
  물리적 아키텍처는 아키텍처스타일,서비스,프로토콜,db,사용자 인터페이스와 api게이트웨이등을 보여줌
  논리적아키텍처는 물리적아키텍처와 독립적이고,물리적아키텍처를 신경쓰지않음
  즉 도메인 영역까지도 신경쓰지않고 실제로 어떤식으로 서로 상호작용하는지만 표현함
  
  논리적 컴포넌트를 식별할땐
    1.초기핵심컴포넌트를 식별하기
	2.요구사항을 컴포넌트에 할당하기
	3.역할과책임을 분석하기
	4.아키텍처특성을 분석하기->요구사항을 컴포넌트에 할당하기 반복
  순서로 진행함
  이건 시스템이 살아있는한 계속 반복됨
  시스탬에 변경을 가하거나 새 기능을 추가할때마다 논리적컴포넌트가 적절한 크기이고 본래역할을 잘 수행하는지를 확인하기위해 저걸 반복해야함
  
  초기 핵심 컴포넌트의 식별은 많은경우 추측게임에 가깝고,보통 다른것으로 리팩터링할 확률이 큼
  그래서 많은시간을 쓰지않는게 좋음
  이걸 할때 좋은 접근 방법은,워크플로우 접근법이랑 액터/액션 접근법이 있음
  
  워크플로우 접근법은 시스템의 주요 워크플로우,즉 사용자가 시스템을 이용하는 과정을 중심으로 초기 핵심 컴포넌트를 식별하는 방법임
  모든단계를 다 기록할 필요는 없고,주요처리단계를 먼저 시작하고 세부단계로 들어가면됨
  이때 각 워크플로우의 단계가 항상 단일 논리적 컴포넌트에 매핑되지는 않을수있다는걸 염두에둬야함
  이때 중요한건 핵심컴포넌트의 이름을 잘 지어야함
  컴포넌트가 무엇을 하는지를 간결하게 설명하는 이름을 지어야함(관리자 이런거 들어가면 안됨)
  
  액터/액션 접근법은 시스템에 여러 액터가 있을때 유용함
  이건 먼저 다양한 액터를 식별하는것부터 시작함
  그후 주요한 행동 몇가지를 확인하고,각행동을 새 컴포넌트나 기존 컴포넌트에 할당함
  
  즉 액터를 먼저 식별하고(강의등록자,교습자),각 액터가 필요한 액션(강의등록자:강의등록,강의삭제,댓글 교습자:강의구매,강의보기,댓글)을 식별한 후에
  여기서 논리적 컴포넌트를 식별해내는식임(강의관리,강의전송,댓글)
  이때 자동적으로 발생하는건 시스템 액터를 사용할수있음(결제등)
  이때 액터가 할수있는 주요 행동을 위주로 하면되고,과도한 세부사항이 들어가지않게 해야함
  
  이렇게 행동들을 식별하고나서 밟을수있는 함정이 있는데,이건 모든걸 단일 컴포넌트에 넣고싶어지는거임
  이걸 엔티티함정이라고 부름
  보통 이걸 밟으면 관리자,슈퍼바이저 같은 이름을 사용하게되는데 이러면 일단 주의해야함
  컴포넌트의 이름만 보고 무슨일을 하는지를 알수있어야하고,컴포넌트의 책임은 하나가 되어야지,너무 많으면 확장이 어려워짐
  이미 잘 정의된 엔티티가 있더라도 엔티티함정에 빠지면 안됨
  
  보통 워크플로우는 한가지 유형의 사용자가 있을때 사용하면좋고,액터/액션은 여러종류의 사용자가 있을때 사용하면 좋음
  또한 액터액션으로 시작해서 행동을 식별하고 워크플로우로 순서대로 정리하는것도 괜찮음
  
  
  초기 핵심 컴포넌트를 식별했으면,해당 논리적 컴포넌트들에 요구사항을 할당해야함
  이건 기능 사용자스토리나 요구사항을 검토하고,각컴포넌트가 어떤 기능을 담당할지를 결정함
  각 컴포넌트는 디렉터리구조로 표현되고 소스코드는 그 디렉터리에 있고 요구사항을 구현함
  
  기능(요구사항)을 논리적 컴포넌트에 할당하기 시작하면,각 컴포넌트의 역할과 책임이 자연스럽게 커짐
  그러니까 기능을 할당받은 컴포넌트들이 실제로 그 기능을 담당하고,너무 많은일을 하지않게 역할과 책임을 분석해서 다른곳으로 옮겨야함
  즉 컴포넌트의 동작들은 응집력이 있어야함
  컴포넌트가 이상치나 너무 많은 일을 하고있는 컴포넌트를 발견한다면,책임의 일부를 다른 컴포넌트로 옮기는게 좋음
  
  마지막으로는 각 컴포넌트가 현재 아키텍처특성과 일치하는지를 확인해야함
  대부분 확장성,탄력성,가용성을 위해 컴포넌트를 분리하게되지만,응집도때문에 결합하는경우도 있음
  
  컴포넌트들 끼리 서로 상호작용을 한다면 컴포넌트들은 결합되어있는거임
  컴포넌트들이 더 많이 상호작용할수록 시스템은 더 밀접하게 결합되지만,유지보수는 더 어려워짐
  
  만약 a,c컴포넌트가 b컴포넌트를 의존하고있다면 b컴포넌트에 대해서의 내부결합임(즉 사용되어지는측면)
  반대로 a컴포넌트의 입장에선 b컴포넌트를 의존하고있고,이때 a컴포넌트는 b컴포넌트에 대해 외부결합임
  
  이렇게 내부결합과 외부결합을 합쳐서 결합도를 낼수있고,이걸 다 더해서 전체 시스템의 결합 수준도 알수있음
  결합도는 낮으면 좋고,이건 디미터의 법칙(최소지식원칙)을 사용해서 할수있음
  
  한컴포넌트가 다른 컴포넌트에 대해 더 많이 알수록 결합도는 올라감
  즉 지식을 줄이면 결합수준도 낮아짐
  이경우에는 다른쪽으로 책임을 옮기고,거기에 의존하는식으로 결합도를 분배할수있음
  이런식으로 특정 컴포넌트의 결합도가 높은걸 분배해서 총결합도는 유지하되,특정 컴포넌트의 결합도가 매우 높은걸 해결할수있음
  
  모든것은 트레이드오프고,강결합을 사용하면 이해는 편해지지만 수정이 어려워짐
  약결합을 사용하면 이해는 어려워지지만(절차를 이해하려면 여러 컴포넌트를 방문해야함),수정은 편해짐
  한 컴포넌트의 변화가 다른 컴포넌트를 변화시킨다면,둘은 결합된거
  시스템을 논리적 컴포넌트의 모음이라고 생각하면 전체구조와 작동방식을 알기 쉬워짐
  
  
5.아키텍처 스타일  
  아키텍처 스타일에는 대략
    레이어드    기술적,모놀리스
	마이크로 커널 기술적,모놀리스
	모듈러모놀리스 도메인,모놀리스
	이벤트기반    기술적,분산
	마이크로서비스  도메인,분산
  등이 있음
  
  여기서 기술과 도메인 관점이 있음
  기술은 코드가 기술적인 관심사(레이어드의 컨트롤러,서비스,레포지토리처럼)에 따라 나뉘는방식
  도메인은 시스템의 구조와 도메인이 일치되고,각 도메인 내에 해결하려는 문제에 맞게 코드가 들어가는방식(내부는 도메인이 알아서함)
  
  또한 배포형태로 모놀리스과 분산이 있음
  모놀리스는 모든 논리적 컴포넌트들이 하나의 단위로 배포되어서 전체 어플리케이션이 하나의 프로세스로 실행된다는것
  분산은 논리적컴포넌트를 다수의 단위로 나눠서 각각의 프로세스에서 실행되고,네트워크를 통해 서로 통신함
  
  모놀리스의 장점은
    단순성:개발과 이해가 쉬움
	타당성:개발코스트가 낮음
	비용:비용이 적게듬(구조가 간단함)
	신뢰성:네트워크호출을 거의 만들지않음
	디버깅용이성:스택트레이스따라가기가 쉬움
  단점은
    확장성:특정부분만 확장이 어려움
	진화성:커지면 변경이 어려워지고,도메인별 다른기술스택 사용이 불가능
	신뢰성:하나의 버그가 전체시스템에 영향을줌
	배포용이성:하나의 변경을 배포할때 전체 어플리케이션을 배포해야함
  가 있음
  
  분산의 장점은
    확장성:개별컴포넌트의 확장이 쉬움
	모듈성:서로 약결합을 해서 모듈성이 높음
	테스트용이성:각 컴포넌트별로 테스트하기쉬움
	배포용이성:cicd가 쉬움
	결함허용성:일부가 뻗어도 나머지는 동작할수있음
  단점은
    성능:네트워크작업 특성상 성능에 -임
	비용:여러단위를 배포하면 더많은 서버를 필요로함
	단순성:매우복잡함
	디버깅용이성:모든 서비스에서 오류가 발생할수있고,추적이 어려움
  이 있음
  
6.레이어드 아키텍처
  레이어드 아키텍처는 mvc 설계 패턴을 아키텍처 레벨로 올렸다고 봐도됨
  레이어드는 아키텍처를
    프레젠테이션	
	서비스
	워크플로우(도메인)(서비스와 합치기도함)
	퍼시스턴스
  로 나누어서 보는 방식임
  이러면 각 레이어마다 특정한 책임이 있게되고,아키텍처의 이해가 쉬워짐
  
  DDD와 레이어드를 같이쓸땐 각 도메인별로 분리한후 그 안에서 레이어로 분리하는 형태를 취하게됨
  즉 레이어드 아키텍처는 도메인과 상관없이,기술적 능력에 따라 분리하는 아키텍처고,DDD같은건 도메인 관점에서 분리하는 아키텍처임
  즉 그래프를 그렸을떄 기술적이 x축이라면 도메인관점은 y축으로,다른 차원이라고 볼수있음
  
  레이어드 아키텍처의 장점은
    전문화:회사에서 분야별로 전문가를 나누고,이들을 프로젝트에서 능력을 공유하게할수있음
	기술적 재사용용이성:코드를 재사용할 기회가 많아짐(근처에있으니 중복찾기쉬움)
	물리적 분리와 매칭:논리적 컴포넌트가 물리적인 분할과 매칭됨(서로 다른 언어같이)
	mvc와 비슷:mvc같은 설계패턴적용이 쉽고,단순함
  가 있음
  
  레이어드 아키텍처는 레이어드 모놀리스로 설명되지만,이는 다양한 물리적 아키텍처로 구현할수있음
  2티어는 프레젠테이션,비즈니스규칙,퍼시스턴스 레이어를 하나의 배포단위로 묶는것(일반적인 구조)
  3티어는 프레젠테이션을 따로 떼고,비즈니스규칙과 퍼시스턴스를 묶어서 각각 따로 배포하는것(웹기반 어플리케이션이나 앱등)
  임베디드나 모바일에서는 db까지 포함해서 하나로 묶어서 배포하는경우도 있음
  
  각각 물리적 아키텍처마다 트레이드오프가 있는데
  2티어는
    장점
      풍부한 사용자 인터페이스
	  고성능
	  단순함
	단점
	  확장성 중간
	  커지면서 복잡해짐
	  신뢰성 중간:db접근시 네트워크의존
	  
  3티어는
    장점
	  UI분할
	  높은확장성
	  분산아키텍처의 이점
	단점
	  적은신뢰성
	  더 복잡함
	  분산아키텍처의 단점
	  
  임베디드/모바일은
    장점
	  자가포함
	  단일기술스택
	  하드웨어기기에 높은 튜닝
	단점
	  낮은확장성
	  자원제약
	  구현플랫폼에 종속됨
  이런 장단점이 있음
  
  레이어드 아키텍처에서 레이어는 필요하면 추가할수있음
  서비스 레이어나 통합레이어는 보통 추가되고,사용자인터페이스 레이어의 경우에도 그럼(모바일 지원 등)
  
  레이어드 아키텍처의 가장 큰 장점은 고립시켜 변경할수있는 능력임
  단점은 아키텍처에서 문제 도메인이 여러 레이어에 걸쳐 퍼져있다는것
  즉 특정 논리적 컴포넌트는 여러 레이어를 전부 필요로하는 경우가 많음
  그래서 레이어드 아키텍처는 기술적인 능력은 쉽게 변경할수있지만(같은 축으로 분류하니까),도메인변경은 여러계층에 걸쳐 영향을 줘서 변경이 쉽지않음
  
  그래서 계속적이고 중요한 도메인변경이 예상되거나 더 높은 우선순위라면 다른 아키텍처를 고려해야함
  
  레이어드 아키텍처의 장점은
    타당성
	성능
	기술적분할:공통역량을 재사용하기 쉽게 만들기좋음
	빠른구축
	데이터집약적:네트워크 통신횟수를 줄일수있어서
	간결하고 효율적
  단점은
    확장성
	탄력성
	배포용이성
	테스트용이성
	진흙잡탕:모든게 연결되어있어서 신중하게 관리하지않으면 혼란스러워지기쉬움
  
7.모듈러 모놀리스  
  레이어드 아키텍처에 도메인차원의 추가 및 변경이 있으면 변경이 어려움
  그래서 사용되는게 모듈러 모놀리스임
  이건 기술적인 관심사로 분할하는 대신,비즈니스 도메인으로 분할한후 그안에서 레이어드로 분할하는형태
  
  즉 배포를 한덩어리로 가져가는건 같지만(모놀리스),그안에서 분리를 도메인단위로 모듈형태로 분리하는거임
  즉 모듈러 모놀리스의 모듈은 하위도메인을 나타내고,각 모듈은 특정 하위도메인의 모든 비즈니스기능성을 포함함
  또한 여기서 모듈이란,단순히 패키지단위분리가 아닌 모듈간의 관심사를 분리하고,모듈간 상호작용도 약결합으로 하는거
  레이어드의 레이어도 모듈이라고 볼수있음,단지 도메인단위가 아닌 기술단위로 분리되어있을뿐
  
  레이어드에서는 도메인 변경이 여러 레이어에 걸쳐 퍼짐(기술이 x축이라면 도메인은 y축이기때문)
  그래서 레이어드에서 모듈러모놀리스로 아키텍처를 변경하는건 자주 나오는 리팩터링임
  그리고 모듈을 팀단위로 배분하면 변경조율도 더 쉬움(책임을 가진사람이 적어지니까)
  
  기본적으로는 각 모듈이 레이어로 구성되어있는경우가 많지만,도메인으로 일단 먼저 잘린후에 구성되어있다는게 중요(x와 y축이 둘다 형성)
  애초에 모듈러 모놀리스에서 레이어는 구현세부사항으로,아키텍처의 관심사가 아니고,하위도메인안에서 어떻게짜든 신경쓰지않음
  
  물론 모듈러 모놀리스고 뭐고 서로간에 통신은 일어나야함,그렇다고 모듈간 무작정 호출을 허용하면 모든 경계가 사라짐
  여기서 핵심은 모놀리식 배포모델 안에서 도메인을 기준으로 나누는것,하나의 모듈을 변경해도 다른 모듈에 영향을 주지않게 결합을 느슨하게 만들어야함
  
  코드설계관점에서는 각 모듈을 별도의 서비스로 생각하고,각 서비스는 내부구현을 다른 모듈로 부터 보호하면서 공개 api를 제공해야함
  즉 세부구현을 감추고 공개할거만 공개해야함
  
  물론 모든 모듈이 db를 공유한다면 데이터수준에선 여전히 결합되어있음
  여기서 db를 모듈화하는것도 고려할수있지만 부담이 클 가능성이 있음
  상황을 보고 그게 필요하다고 판단되었을때 하는게 좋음
  
  이렇게 db를 모놀리스로 할땐,단일 db를 사용한후 각 모듈마다 자기만의 테이블을 사용하는식으로 처리함
  또한 이때 만약 다른 모듈을 저장해야한다면,id만 저장하면됨
  이후에 해당 모듈에다가 id를 가지고 질의를 하면되는거임
  조인도 생각해볼수있지만,조인을 하면 강결합이 되기때문에 주의해야함(이것도 트레이드오프긴할듯,상황따라서 n+1때문에 이렇게해야할수도있을거같음)
  즉 데이터를 기록하거나 가져올때 모듈을 실수로 결합하지않게 조심해야함
  
  모듈러모놀리스의 장점은
    도메인분할
	도메인기반정렬
	성능
	유지보수성
	테스트용이성
  단점은
    코드재사용이 어려움:공통기능을 모듈간 공유하려면 별도의존성으로 분리해야하고,결합도도 높아짐
	전체앱에 대해 하나의 아키텍처특성
	모듈성이 깨질수있음
	탄력성과 결함허용성같은 운영특성을 챙기기어려움(일단 모놀리스구조니까)

  대략적으로 레이어드에서 단순성을 약간내리고 비용을 약간올리고 나머지를 많이챙긴형태임 
  
  
8.마이크로커널 아키텍처  
  마이크로커널 아키텍처는 변동이 거의 없는 커널을 만들어두고,여기에 플러그인을 붙여서 구현하는식으로 구성됨
  커널은
    최소한의 기능성만 제공
	초기구현이후엔 거의 변경되지않음
	사용자정의동작을 구현하지않음
  플러그인은
    모든 사용자 정의 동작을 구현
	서로 독립적으로 작동
	독립적으로 배포
  이런 특징을 가짐
  
  그렇다고 모든 플러그인이 존재하는 아키텍처가 전부 마이크로커널은 아님
  마이크로커널은 플러그인없이 코어가 얼마나 잘 작동하는지와,코어가 얼마나 변동성이 큰지로 판단함
  만약 플러그인없이 혼자서 잘 동작할수있다면 마이크로커널이 아닐 가능성이 높음
  즉 기능성과 변동성이 낮으면 마이크로커널,높으면 그냥 플러그인사용임
  
  마이크로커널은 프로그래밍방식의 맞춤설정을 제공할때 쓰기좋음(데코레이터의 구현방식이라고 생각해도됨)
  플러그인은 보통 모놀리스 아키텍처내의 컴포넌트로 구현되는경우가 많지만,필요하다면 분산플러그인으로 구축할수도있음
  
  플러그인은 코어가 만들어둔 인터페이스를 구현하고,코어는 그 인터페이스를 통해 해당 컴포넌트를 지원함
  모놀리스에선 인터페이스를 통해 각 플러그인을 코어에 연결하는 컴포넌트로 구현함
  분산시스템에선 플러그인이 웹 엔드포인트,이벤트큐등으로 분산되고,플러그인을 동기호출할지 비동기호출할지도 결장할수있음
  
  코어와 플러그인간 실제 호출방식은 물리적 아키텍처에 따라 달라짐
  모놀리스에선 핵심기술과 동일한 스택으로 구현하고,네이티브로 배포함
  분산에선 동기 또는 비동기호출로 호출하고,언어에 제약받지않음
  
  보통 마이크로커널에선 ui를 모놀리스의 경우엔 코어에,분산의 경우엔 다른부분에서 처리함
  마이크로커널은 데코레이터를 구현하는 한가지 방법임
  코어의 내부구조는 기능분리를 하려면 레이어드를 사용하고,모듈러모놀리스처럼 경계가 있는 컨텍스트를 중심으로 설계할수도있음
  
  플러그인들은 코어를 통해 서로 통신할수있지만,가급적이면 하지않는게 좋음
  이건 코어와 플러그인간에 일관된 계약을 필요로하고,전이적 의존성등으로 서로간에 버전의존성을 만들수있음
  또한 가용성문제도 생김(모든 필요한 플러그인이 런타임에 존재해야함)
  
  코어는 플러그인을 호출할때 항상 계약(주로 인터페이스)을 사용함
  만약 플러그인끼리 통신이 필요하다면 코어가 중재자역할을 해야하고,서로간의 변경이 서로에 영향을 주고,코어의 중재레이어의 변경도 양쪽에 영향을 주게됨
  
  마이크로커널의 장점은
    맞춤형 동작
	적응성:기존기능(기존컴포넌트)를 유지하면서 새 기능을 추가하기 쉬움
	진화성:이전의 동작방식에서 점진적으로 벗어나기쉬움
	단순한구조
	분할:코어와 플러그인이 명확히 분리됨
  단점은
    변동성의 불일치:코어가 자주 바뀌면 잘못선택했거나 잘못된걸 플러그인으로 만든것(보통 잦은 도메인변경으로 인한 코어의 과도한 변동성)
	플러그인간 공유:플러그인간에 의존성공유를 하게되면 결합과 배포에 문제가 생김
	수다쟁이플러그인:서로 통신을 하고싶어하면 트레이트오프가 세게 생김
	성능:분산을 사용하면 정보의 양과 프로토콜에 따라 성능에 영향을 줄수있음
  대략적으로 단순해서 비용은 낮지만,확장성과 탄력성,결함허용성이 낮고,단순성,진화성,배포용이성,테스트용이성등이 높음
    

9.직접해보기  
  프로젝트를 시작할때 가장 먼저 해야하는건 요구사항문서를 만드는것
  만들어진 요구사항문서를 바탕으로 워크플로우를 만들어보고,
  이후에 아키텍처를 기획해야함
  무슨일이 있어도 이걸 스킵할수는없음
  
  아키텍처구축의 순서는
    1.아키텍처 특성 찾기
	2.논리적 컴포넌트 찾기
	3.아키텍처 스타일 고르기
	4.아키텍처 결정 문서화
  순서로 진행하면됨
  
  가장 먼저 요구사항을 가지고 아키텍처특성들을 찾아야함
  여기서 주요특성과 암묵적특성을 뽑아보고,제일 우선시되는거 3개는 따로 표시해두는게 좋음
  
  아키텍처특성이 나왔다면,요구사항과 워크플로우를 참고해서 액터액션이나 워크플로우로 논리적 컴포넌트를 식별하면됨
  이떈 워크플로우를 일단 뽑아보고,거기서 액터와 액션을 식별하는게 잘먹힘
  
  논리적 컴포넌트가 나왔다면,현재 아키텍처특성에서 필요로 하는것들과 아키텍처들의 장단점을 비교해서 가장 잘 맞는걸 선택하면됨
  이때,눈에 띄는 기술적,비즈니스적 관심사를 찾을수있다면 레이어드나 모듈러 모놀리스가 좋을수있고,
  서로 구별되는 논리의 통합지점이 많다면 마이크로커널이 좋은 선택이 될수있음
  
  이렇게 아키텍처를 선택했다면,이걸 왜 선택했는지를 설명하고 이걸 문서화해야함
  모든 결정은 결과를 초래하고(비용문제,보안을 위한 성능희생등),찾을수없다면 계속 찾아보면나옴
  
  이제 대략적인 그림이 다 나왔으니까 고수준에서의 물리적 뷰를 간단하게 그려보면됨
  
10.마이크로서비스 아키텍처  
  msa는 각 기능마다 서비스를 분리하고,서비스간의 통신을 통해서 큰 결과물을 만들어내는 방식임
  즉 각 서비스마다 작은 하나의 목적을 가지고,하나의 일을 수행하고,이 서비스들을 묶어서 호출해서 큰 기능을 구현함
  
  또 다른 특징으로는,각 서비스는 자신의 db를 소유하고,해당 db는 자신만 접근가능함
  이래야 데이터의 변경관리가 쉬워짐(자신의 이유로만 변경하면되니까 변경이 퍼져나가지않음)
  즉 물리적 경계 컨텍스트를 만들어두는것
  그래서 다른애의 데이터가 필요하다면,그걸 소유한서비스한테 요청해야함
  
  마이크로서비스의 크기를 결정하는건 쉽지않음
  단일목적이라는게 애매하기때문
  그래서 세분화를 해야하는데,이때 세분화분해인자와 세분화 결합인자를 사용해서 붙이고 분리하면됨
  msa가 지나치게 세분화되면 더 많은 통신이 필요하고,이는 높은 결합도,성능저하,신뢰성문제로 이어짐
  또한 msa가 너무 크면 유지보수,테스트,확장비용이 증가해서 msa를 사용하는 이유가없어짐
  
  분해인자가 분해를 하는 이유는
    응집력:해당 서비스내의 모든 기능은 단일목적을위해 밀접하게 연관되어야함
	결함허용성과 가용성:특정기능에서 오류가 자주 발생하는경우,해당부분때문에 모든 기능이 사용불가능해질수있으니 분리를 생각할수있음
	코드변동성:일부기능이 다른부분보다 자주 변경될경우,해당부분을 분리해볼수있음
	확장성과 처리량:일부가 더 많은 확장성을 필요로할경우 분리해볼수있음
	접근제어:민감한정보에 접근하는부분을 분리해서 접근을 쉽게 제어할수있음
  결합인자가 결합을 하는 이유는
    db트랜잭션:다수의 마이크로서비스가 관여하는 트랜잭션을 할땐,단일커밋이나 롤백을 할수없음,
	  즉 일관성과 무결성이 분해인자보다 더 중요하면 결합해서 한트랜잭션에 넣을수있음
	워크플로우와 코레오그래피:하나의 요청을 처리하기위해 여러 마이크로서비스가 통신해야하면 결합도가 높은거,높은결합도는 성능,확장성,결함허용성에서 부정적인 영향을 줌
	  워크플로우가 여러 마이크로서비스간 협력을 필요로하고 저 부정적인 영향을 받는애들이 중요하다면 결합할수있음
	데이터종속성:마이크로서비스를 분리할땐 해당 마이크로서비스가 소유한 데이터도 분리해야하는데,데이터결합도가 높다면 분리하는게 어려움
	  보통 외래키나,엔티티가 여러테이블에 걸쳐 분산되었을때 주로 그럴수있음
	  데이터결합도가 높고 기능들이 그 데이터를 공유해야한다면 그냥 범위를 늘리는게 나을수있음
  가 있음
  다 균형을 잡기위한거고,어떤 트레이드오프가 더 중요한지를 결정해야함
  
  마이크로서비스간에서도 서로 코드를 공유할수있음
  이떄 옵션이 두가지가 있는데,공유서비스와 공유라이브러리가 있음
  
  공유서비스는 공통되는 기능을 서비스로 분리해두는것(알림같은거를 내용만 알아서 채우게해서 서비스호출해서 보내는식)
  이거의 장점은
    어떤 언어든 상관없이 구현가능
	공유서비스에서 공통코드를 변경하면 다른애들은 신경쓰지않아도됨
  단점은
    공유서비스의 변경은,해당 서비스를 의존하는 모든 서비스들에 영향을 줌
	공유기능이 원격에 있어서 성능이 느려질수있음
	공유서비스가 뻗으면,해당서비스를 의존하는 모든 서비스들이 작동할수없음
	공유서비스를 호출하는 다른 마이크로서비스들이 확장되면,공유서비스도 확장되어야함
  가 있음
  
  공유라이브러리는 독립적인 라이브러리를 만들어서,그걸 각 서비스들이 공유해서 사용하는것(import)
  장점은
    성능,가용성,확장성에서 유리
	공유라이브러리의 코드를 변경하는게 덜 위험함(버전선택가능)
	버전을 관리할수있어서 하위호환성을 제공하고 더 유연함
  단점은
    마이크로서비스들이 서로 다른 언어를 사용하면 다수의 공유라이브러리가 필요할수있음
	마이크로서비스들이 많다면 공유라이브러리와의 종속성관리가 어려울수있음
	공유기능이 변경되면 해당기능을 사용하는 마이크로서비스들은 다시 테스트후 배포해야함
  가 있음
  
  
  두개이상의 마이크로서비스가 필요한 비즈니스요청을 처리할땐 워크플로우가 필요함
  즉 순서대로 마이크로서비스들을 호출할 방법이 필요함
  이때 사용되는건 오케스트레이션과 코레오그래피가 있음
  
  오케스트레이션은 모든걸 호출하는 전용 서비스임
  얘는 호출하는걸 책임으로 갖고,오류를 처리하고 통합데이터를 호출자에게 전달함
  장점은
    중앙집중화된 워크플로우:이해와 관리가 편함
	워크플로우상태확인:상태확인이 간단하고,오류발생시에도 요청재처리가 쉬움(해당단계만 반복)
	오류처리:오류처리를 오케스트레이터가 다 하기떄문에,각 서비스들은 신경쓰지않아도됨
	워크플로우의 변경:변경이 쉬움
  단점은
    성능:워크플로우상태가 변경될때마다 db에 저장하기때문에 처리속도가 느려질수있음
	확장성:모든요청이 오케스트레이터로 와서 요청이 증가할수록 병목이 일어나기쉬움
	강결합:오케스트레이터와 마이크로서비스간 통신으로 인한 결합
	가용성:오케스트레이터가 뻗으면 요청처리가 불가능해짐(spof),단 보통 인스턴스를 여러개생성하면 해결됨

  코레오그래피는 각 마이크로서비스들이 다음 마이크로서비스를 알고,그걸 호출하는식으로 만들어짐
  단 이때 하나가 전부 호출하는게 아닌,각자 다음거만 알고 호출한다는게 중요함
  단순한작업일수록 코레오그래피가 더 맞을 확률이 높고,복잡하면 오케스트레이션이 더 나을확률이 높음
  장점은
    응답성:오케스트레이터와의 지속적통신이 필요없어서 응답성과 성능이 더 좋음
	느슨한결합:오케스트레이터와 의존하지않아서 결합이 느슨함
	확장성:자신의 처리량에 맞게 늘리거나 줄이기 쉬움
  단점은
    오류처리:오류가 발생하면 자신이 직접 오류처리에 대한 워크플로우를 관리해야함
	상태관리:워크플로우의 상태파악이 어려움,보통 첫호출대상이 상태소유자가 되는데,얘가 자신의 상태를 해당서비스에게 전달함
	복구성:실패한요청이나 진행중인 요청을 다시시도할때 어디서부터 해야하는지에 대한 파악이 어려움
  가 있음
  
  msa는 복잡하지만 강력함
  얘는 민첩성에 특화되어있음
  msa의 장점은
    유지보수성
	테스트용이성
	배포용이성
	진화성:기능추가가 쉬움
	확장성
	결함허용성:특정 서비스가 실패해도 전체가 중단되지않음
  단점은
    복잡성
	성능:네트워크통신
	복잡한 워크플로우
	단일db:각 서비스는 자신의 db를 소유해야함
	기술적팀일경우 적합하지않음
  가 있음
  
  대략적으로 유지보수성,테스트용이성,배포용이성,진화성,확장성을 가져간다음,비용,단순성등을 희생한 패턴임
  
  
11.이벤트 기반 아키텍처 
  이벤트는 기본적으로 비동기로 동작을 시키기위해 사용됨
  즉 모든작업을 순서대로 처리하는게 아닌,이벤트를 발생시키고 다음거로 넘어가는식
  메시지와 이벤트의 차이는,메시지는 무슨 행위를 요청하던가 하는거고(결과를 기다려서 받던가 해야함)
  이벤트는 그냥 발생했다는거만 알리고 끝남(절대 기다리지않음)
  또한 이벤트는 토픽을 사용하여서 브로드캐스트할수있고,메시지는 큐를 사용하여서 단일서비스에 전송됨
  또한 이벤트는 이미 발생한 일을 브로드캐스트하고,메시지는 해야할일을 요청함
  
  여기서 이벤트란,특정 작업을 시키는게 아닌,특정 행위가 발생했다는걸 알리기만 함
  즉 이벤트를 받는쪽에서 그 이벤트로 뭘 해야할지를 알아서 생각해서 동작하는거
  이벤트엔 보통 데이터가 포함되어있음(최소한 id정도는 있는편)
  이 데이터를 페이로드라고 보통 부름
  
  이벤트도 분류가 있는데,고객이나 최종사용자가 발생시키는 이벤트는 시작이벤트라고 부름
  이는 비즈니스프로세스를 시작하는 특별한 유형의 이벤트임
  또한 서비스가 시작이벤트에 응답하면,그 범위내에서 시스템의 나머지부분에 뭘했는지 브로드캐스트하는데,이때 발생하는 이벤트를 파생이벤트라고 함
  이벤트는 그 이벤트를 받는애가 아무도 없을수도있음,이런 이벤트들은 아키텍처 신장성을 위해,즉 나중에 그부분에 새로운 기능을 추가하기 쉽게하기위해 공개됨
  
  이벤트는 보통 비동기로 동작하는데,기본적으로 파이어 앤드 포겟(던지고 잊어버림)방식으로 동작함
  
  비동기의 장점은
    응답성:속도가 빠름
	가용성:반대편 서비스가 뻗어도 일단 다 받을수있음(나중에 처리하면됨)
  단점은
    오류처리:문제가 생겼을때 처리가 복잡해짐
  이 있음
  
  eda에서 데이터베이스를 다룰떈 모놀리틱,도메인분할,서비스별 db등이 있음
  
  모놀리틱은 모든 서비스가 단일db를 공유하는거
  장점은 서비스가 소유하지않은 데이터가 필요할때도 직접 db에 접근할수있다는거
  그래서 다른 서비스에 동기호출을 할필요가 없음
  단점으로는 변경할때,하나의 테이블을 변경하면 그 변경에 영향을 받는 서비스들식별이 어려움
  또한 단일장애점이 되기도 쉬움
  
  도메인분할은 각 도메인별로 자체 db를 가지고,그 범위를 넘어가면 해당도메인에 요청해서 받아야함
  즉 서비스별 db와 모놀리틱의 딱 중앙임
  즉,같은 도메인서비스는 약결합되지만,도메인밖의 데이터를 가져올땐 동기호출이라 강결합되고,
  같은도메인안에선 db직접접근이라 빠르지만,다른도메인이라면 동기접근이라 느려짐
  구조변경시엔 같은도메인안에선 영향을 주지만,수가 제한적임
  
  서비스별 db는 각 서비스별로 자체db를 가짐
  단점은 서비스에 추가 데이터가 필요하다면 동기호출을 해야한다는거고,여기서 결합과 통신이 많이 생기고 성능이 느려짐
  장점은 변경에 영향을 다른애들이 안받음
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  