1.시작하기
  아키텍처는 소프트웨어의 구조(사용자인터페이스,서비스,db,통신프로토콜등)를 정의함
  이건 최종결과를 가시화하고 지침과 제약을 제공함
  
  아키텍처는 4개의 차원으로 구성됨
    아키텍처특성:아키텍처가 지원할 시스템의 측면,즉 확장성,가용성,테스트용이성등
	아키텍처결정:시스템에 시사점을 갖는 중요한결정,db의 종류,서비스갯수,서비스통신방식 등
	논리적 컴포넌트:시스템기능의 구성요소와 그것들이 어떻게 상호작용하는지,즉 어떤 컴포넌트(재고관리,결제등)를 사용하고 어떻게 통신할건지
	아키텍처스타일:물리적구조와 형태를 정의(헥사고날,레이어드등)
  모든 차원은 서로 연계됨
  예를들어 아키텍처스타일은 특성만이 아닌 결정과도 일치해야하고,
  유사하게 정의된 논리적 컴포넌트는 특성과 스타일,결정과 일치해야함
  
  아키텍처를 세울땐 4가지 모든 차원이 다 필요하고,어떤것도 생략할수없음
  즉 내 아키텍처는 MSA야 하는걸로는 아키텍처 스타일만 설명하고,그외의 많은것들을 답하지않은 상태로 두는것
  즉 어떤 특성이 있어야하고,어떤 컴포넌트들이 있고,어떤 결정이 있었는지도 대답에 있어야함
  
  아키텍처특성은 아키텍처의 기반을 형성함
  이게 없다면 아키텍처 관련 결정을 내리거나,트레이드오프를 분석할수없음
  즉 여기서 필요한,즉 확장성,가용성등을 기준으로 트레이드오프의 결정을 내릴수있음
  
  아키텍처결정은 시스템의 구조적측면에 관한 선택으로 장기적으로 중요한 영향을 미침
  이런 결정들은 일종의 제약사항이 되어서,시스템 기획,구축에 도움을 줌
  예를들면 사용자인터페이스가 db와 직접 통신하지않고,서비스를 거쳐서야만 데이터를 조회,갱신할수있다고 하는것
  이건 제약이 되고,다른 개발자들이 어떤식으로 접근하고 갱신해야하는지에 대한 지침을 제공함
  
  논리적 컴포넌트는 시스템의 구성요소로,집으로 치면 방에 해당하는 특정 기능을 수행함
  보통 디렉터리나 네임스페이스로 표현됨
  논리적컴포넌트는 함께 작용하는 블록임(애그리거트)
  논리적 컴포넌트는 항상 시스템에서 잘 정의된 역할과 책임을 가져야함
  다른말로 하면 그것이 무엇을 하느냐에 대한 명확한 정의가 필요함
  즉 주문처리 컴포넌트라면
    이 컴포넌트는 ‘선택과 포장’을 담당합니다.
	창고에 물건을 위치시키는 것은 ‘선택’이고, 그물건에 맞는 정확한 박스 크기를 결정하여 발송될 수 있도록 하는것은 ‘포장’입니다.
  이런식으로 명확한 정의가 있어야함
  
  아키텍처스타일은 각기 다른 고유한 특성들로,전반적인 모습과 구조를 정의함
  msa는 확장성이 좋고,민첩성이 높고,레이어드는 덜복잡하고 비용이 적게듬
  이벤트기반은 높은확장성을 제공하고,매우 빠르고 응답성이 좋음
  이건 시스템의 전반적인 모습과 특성을 정의하기때문에 처음부터 올바른 선택을 하는게 중요함
  이걸 바꾸는건 큰작업이기때문
  
  
  아키텍처와 설계는 다름
  아키텍처는 구조에 중점을 두고,설계는 외관에 중점을 둠
  아키텍처가 전략이라면 설계는 전술임
  즉 아키텍처는 어떤식으로 크게 구성될것인지고,설계는 어떻게 필드를 배치할지,어떤 패턴을 사용할지같은 세부사항에 가까움
  
  설계관점에서는 클래스파일이 어떻게 상호작용하는지를 uml등으로 나타낼수있음
  즉 order이 PaymentMethod와 어떤식의 관계가 있고 이런것들을 다룸
  단 소스의 물리적인 구조(배포,조직등)는 나타내지않음
  아키텍처관점에선 서비스,db등이 다른 서비스나 사용자인터페이스와 어떻게 통신하는지를 다룸
  즉 주문배치서비스가 결제대행서비스와 어떤식으로 통신하는지,어떤 db를 사용하는지등을 다룸
  
  어떤 결정은 아키텍처와 확실히 관련된거지만,다른결정은 분명히 설계와 관련된거임
  보통 대부분의 결정은 이 사이에 있음
  이걸 신경쓰는건 중요함
  이건 누가 이 결정을 내려야하는지를 결정하는데도 도움이 됨(개발팀,아키텍트,함께등)
  
  보통 전략적인 결정(장기적이고 미래의 행동에 영향을 주는)이면 아키텍처,전술적인 결정(단기적이고 일반적으로 다른 행동들에 독립적)이면 설계의 비율이 높음
  또한 변경에 많은 노력이 든다면 아키텍처에 가깝고,적은 노력이 든다면 설계에 가까움
  그리고 중대한 트레이드오프라면 아키텍처,적은 트레이드오프라면 설계에 가까움
  
  즉 결정하는데 많은 생각과 계획이 필요하다면 전략적이고 아키텍처적임
  또한 많은 사람이 참여해야한다면 전략적이고 아키텍처적임
  결정을 위해 장기적인 비전이 필요하다면 전략적이고 아키텍처적임
  또한 나중에 변경할때 높은수준의 노력이 필요하다면 전략적이고 아키텍처적임
  중대한 트레이드오프라면 전략적이고 아키텍처적임
  
  이런것들로 각각 1~10으로 점수를 매긴다음에 평균을 내보면됨
  
2.아키텍처 특성
  어플리케이션을 개발할때 가장 먼저 해야할건 요구사항문서 작성임
  이 요구사항문서를 가지고 아키텍처특성과 논리적 컴포넌트를 분석한후,이걸 기준으로 아키텍처 스타일을 고르면서 아키텍처결정을 하는방식으로 보통 진행됨
  아키텍처특성분석에서는 작게시작해서 계속 개선해나간다는게 먹히지않음
  처음부터 확장성있게 설계되지않으면 확장성있게 만드는건 매우 어려움
  
  우리가 어떤 문제가 있고,이문제를 해결하기위해 소프트웨어를 개발하는데,이때 이 소프트웨어가 다루는걸 도메인이라고 하고,이걸 설계하는덴 많은 노력이 필요함
  즉 도메인은 소프트웨어를 만드는 이유임
  그런데 도메인만이 모든건 아니고,아키텍처특성도 분석해야함
  아키텍처특성은 도메인이 서로 달라도 일부 겹칠수있음(은행과 경매는 확장성이라는측면에서 겹치는등)
  
  아키텍트의 업무중 하나는 구조설계임
  이는 크게 논리적 컴포넌트와 아키텍처 특성 두부분으로 구분되고,논리적 컴포넌트는 어플리케이션 영역을 나타내고,소프트웨어를 만드는 이유를 설명함
  아키텍처특성은 도메인과 관련없이 중요한 내용임,이건 운영능력,내부구조결정,다른 필요한 특성들을 나타냄
  이건
    명시적:비도메인 설계 고려사항을 명시
	암묵적:아키텍처구조에 영향을줌
	아키텍처특성:어플리케이션의 성공에 핵심적이고 중요(필터링용도)
  로 구성됨
  
  명시적은 얘가 뭘 반드시 달성해야하는지를 명시함,즉 비도메인 설계 고려사항,즉 성능과 확장성등 반드시 갖춰야할걸 명시해두고 그걸 실현하는것
  암묵적은 프로젝트상에서는 드러나지않지만 반드시 갖춰야하는(보안등)걸 나타냄
  아키텍처특성은,이게 반드시 필요한건지를 나타냄,아키텍처특성은 늘어날수록 복잡성을 더하게되고,하나의 특성은 다른 특성에 영향을줘서 개발속도가 느려짐
  즉 오버엔지니어링을 피해야함,모든 소프트웨어가 확장성을 가질수는없음
  
  어떤건 명시적으로 명확하게 표현되고,어떤건 맥락이나 다른지식에 기반해서 추측할수있으므로 암묵적임
  명시적인 아키텍처특성은 어플리케이션 요구사항에 명시되어있고,
  암묵적인 아키텍처특성은 요구사항에 명시적으로 나타나지않음
  특히 보안같은게 주로 그럼
  그리고 도메인에 따라 이런게 있을수있음
  고빈도트레이딩회사는 거래가 밀리초로 완료되는게 너무 당연해서, 얼마나 중요한지 명시하지않을수도있지만,해당 도메인 아키텍트라면 이게 얼마나 중요한지 알고있음
  
  아키텍처특성은 스펙트럼이 넓고 보편적목록이 없음
  또한 용어에 따른 실제기준도 없음
  대략적으로 자주 사용되는것들을 분류해보자면
    프로젝트 아키텍처 특성:개발프로세스와 아키텍처가 만나는곳,소프트웨어를 만드는방법에 대한 결정이 반영됨
	  모듈성:소프트웨어가 개별구성요소로 구성되는정도,어떻게 행동을 분할하고 논리적구성요소를 구성할지
	  테스트용이성:테스트가 완전하고 만들기쉬운지
	  배포용이성:얼마나 배포가 쉽고효율적인지
	  신장성:얼마나 시스템을 확장하기 쉬운지(여러카테고리포함됨)
	  민첩성:테스트용이성,배포용이성,모듈성등을 합쳐서 부름
	  비결합성:얼마나 커플링이 적은지(결합도가 낮은지)
	구조적 아키텍처 특성:소프트웨어의 내부구조에 영향을 미치고,결합정도나 통합지점간의 관계등이 포함됨
	  보안:시스템이 얼마나 안전한지
	  유지보수성:얼마나 쉽게 변경사항을 반영할수있는지
	  이식성:얼마나 쉽게 다른플랫폼에서 실행할수있는지
	  신장성:얼마나 시스템을 확장하기 쉬운지(여러카테고리포함됨)
	  국제화:다국어를 얼마나 잘 지원하고있는지
	운영아키텍처특성:아키텍처결정이 운영팀구성원의 작업에 어떻게 영향을 미치는지
	  가용성:시스템이 장애가 발생했을때 얼마나 빠르게 정상화되는지
	  복구성:재난상황에서 얼마나 빠르게 시스템이 다시 정상화되고 비즈니스연속성을 유지하는지
	  견고성:시스템이 실행중에 하드웨어가 고장났을때 오류 및 경계조건을 잘 처리하는지
	  성능:가용한 자원을 사용해서 시스템이 얼마나 시간요구사항을 잘 충족하는지
	  신뢰성:시스템이 페일세이프하거나,사람의 생명에 영향을 미치는정도로 임무가 중요한지
	  확장성:사용자의 수 혹은 요청이 증가할때 얼마나 시스템이 잘 동작하는지
	아키텍처 공통 특성:분류하기어려운것
	  보안:시스템이 얼마나 안전한지
	  인증/권한:보안의 다른측면,시스템에서 사용자가 본인인지 확인하고 해당권한이 있는지 확인
	  합법성:지역법을 잘 지키는지
	  프라이버시:운영자가 시스템의 내부를 회사내에서 보기힘들게 얼마나 잘 숨기는지
	  접근성:색맹,청각손실등의 사용자를 포함해서 얼마나 시스템에 쉽게 접근하는지
	  사용성:사용자가 목적을 달성하는게 얼마나 쉬운지,교육이 필요한지
  이런것들이 있고,이게 당연히 전부가 아님
  이런 아키텍처 특성들을 찾는건
    문제 도메인:많은 구조적설계 결정은 문제도메인에서 직접 나옴
	환경인식:우리가 운영중인 환경을 잘 이해하면(스타트업,대기업등)많은 요구사항이 나옴
	전체적인 도메인지식:해당 도메인에 대한 넓은지식과 규제,소비자의 습관을 알고있으면 특성을 찾기쉬움
  이런것들로부터 찾아낼수있음
  
  문제도메인에서 아키텍처특성을 찾는건,요구사항문서에 명시되어있는 항목들을 아키텍처특성으로 변환하는걸 의미함
  즉 얼마나 많은 사용자가 예상되는지,동시접속자는 얼마나될지,얼마나 빠르게 사용자가 증가할지를 알아야함
  
  환경인식에서 아키텍처특성을 찾는건,현재 조직의 우선순위를 이해하고 이에 맞는 특성을 찾는것
  급하게 만들어야하거나,임시로 쓰려고 만드는건 단순성을 선택할수있고,다른회사와의 협업이 예상된다면 표준프로토콜을 사용하는걸 생각해볼수있음
  
  전체적인 도메인지식에서 아키텍처특성을 찾아내는건,요구사항에는 명시되어있지만 도메인의 중요한측면에 대해 암묵적으로 이해하고있는 정보를 구체화시키는것
  즉 수강신청의 경우 서버시작시에 매우 트래픽이 몰릴걸 예상하고 이에 맞는 아키텍처특성을 선택하는등이 있음
  
  또한 사용자는 요구사항보다 해결책을 가지고 오는경우가 있는데,이때도 이게 왜 필요한지를 되물어서 해결책에 숨겨진 실제 요구사항을 찾아내야함
  
  복합아키텍처특성도 있는데,이건 두개이상의 아키텍처특성이 결합된것
  예를들어 신뢰성은 가용성과 사용자 인터페이스의 일관성,데이터무결성등이 종합된것
  이걸 식별할땐,이 특성을 객관적으로 어떻게 측정하나요?라고 질문을 던져보면됨
  
  모든 우선순위는 맥락을 따르고,모든 프로젝트에서 같은 특성을 선택하는건 불가능함
  모든건 맥락에 맞게 달라져야함
  
  또한 아키텍처특성을 해석하는것도 아키텍트의 역할임
  보통 비즈니스전문가의 요구사항은 평범한 언어속에 숨겨져있고,여기서 숨겨진 요구사항을 찾아내고 이를 아키텍처 특성으로 바꾸어야함
  보통 사용자들은 모든 특성을 다 넣어달라고하지만,이러면 시너지가 나서 설계가 더 복잡해짐
  
  아키텍처특성은 최종결과물의 역량을 나타내고,논리적컴포넌트는 시스템의 설계,즉 행동을 나타냄
  아키텍트는 특성과 논리적컴포넌트 사이에서 적절한 아키텍처 스타일을 결정해야함
  아키텍처특성은 최대 7개로 제한하는게 좋음
  또한 거기서 가장 중요한 3개를 선택하고 순위를 매기고,암묵적특성(서브라고 생각해도됨)도 따로 나열해보는게좋음
	  
3.트레이드오프	  
  특성을 정할땐,이게 프로젝트 성공에 반드시 필요한지 아니면 있으면 좋은정도인지를 진지하게 따져봐야함
  또한 일부특성들은 충돌하는 경향이 있음(암호화와 성능등)
  
  메시징을 사용할때는 크게 큐와 토픽이 있음
  큐는 서비스에서 보낼 큐리스트를 만들고,여기에다가 하나하나 다 던져주는것
  즉 발신자는 수신자가 누군지 알고있음
  토픽은 브로드캐스트,즉 토픽에 글을 올리면 그걸 구독하고있던애들이 알아서 가져가는것
  발신자는 수신자를 신경쓰지않아도됨(약결합)
  
  이 두가지의 트레이드오프는,
  큐는
    장점
      각 소비자에 맞는 정보를 커스텀으로 지원할수있음
	  모니터링과 스케일링이 독립적(확장성)
	  더 안전(보안)
	단점
	  결합도가 높음(신장성 -)
	  서비스가 다수의 큐와 연결되어야함
	  추가적인 인프라가 필요
  즉 신장성을 포기하고 보안과 모니터링이 좀 편해짐
  
  토픽은
    장점
	  결합도가 낮음(신장성)
	  서비스는 한곳에만 메시지를 발행하면됨
	단점
	  각 소비자마다 정보를 커스텀할수없음
	  토픽을 독립적으로 모니터링하거나 확장할수없음(확장성 -)
	  덜안전함(보안 -)
  즉 신장성을 챙기고(추가로 받아갈곳이 생겨도 바꿀거없음),보안(아무나 구독하면 받아가니까)과 확장성을 좀 포기하는형태임
  
  현재 소프트웨어의 상황에 따라 우선순위를 가지고 결정하면됨
  핵심은 트레이드오프의 균형을 맞추는것
  소프트웨어의 모든것은 트레이드오프임
  
  모든 장점에는 단점이 따라오고,해당 장점이 성공적인 어플리케이션 구현에 도움이 되는가?와 단점을 감수할수있는가?를 고려해야함
  모든 결정엔 트레이드오프를 생각한다음에 결과가 나와야함
  
  어느시점에서는 반드시 아키텍처를 결정해야함
  이때 모든 결정이 아키텍처 결정이 되는건 아니고,시스템의 구조에 영향을 미치는 모든 선택은 아키텍처 결정임
  즉
    캐시를 사용해서 db의 부하를 줄이고 성능을 향상시킴->아키텍처결정
	모듈러 모놀리스로 서비스를 만듬->아키텍처결정
	서비스사이에 비동기통신용 큐를 사용할거임->아키텍처결정
  임
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  