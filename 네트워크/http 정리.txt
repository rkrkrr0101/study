1.인터넷 네트워크
	ip프로토콜(하위레벨 프로토콜)로는 패킷대상의 상황을 알수없고,못받는상태여도 그냥보냄
	그리고 패킷이 사라지거나 순서가 틀리면->tcp
	
	소켓의경우,7계층에 있고,tcp는 6계층이니까,정확히 tcp=소켓이라기보단 tcp를 싸둔거라고 봐야할듯
	
	ip패킷엔 출발지ip,목적지ip등이 있고,ip패킷안에 tcp세그먼트가 있는데
	tcp세그먼트엔 출발지포트,목적지포트,전송제어,순서,검증정보 등이 있음
	ip패킷(tcp세그먼트(내가보내는데이터))같은느낌
	
	tcp는 
		연결지향(3웨이 핸드쉐이크)
		순서보장
		전달보증(all or nothing)
	가 있다..(보통 스트리밍말곤 다 tcp사용함)
	뭐 다 아는거긴하지만
	udp는,그냥 막 던짐,ip와 거의같은데 port와 체크섬정도만 있음
	
2.uri와 웹브라우저 요청 흐름
	uri와 url,url의 차이는
		uri가 기본,리소스 판별자
		url=uri+로케이터 ,즉 리소스 위치
		urn=uri+name ,즉 리소스 이름
	
	uri는
		U:리소스 식별하는 통일된 방식
		R:리소스,uri로 식별할수있는 모든것(제한없음,파일이나 웹사이트나)
		I:다른항목과 구분할때 필요한정보(파일의 위치라던가,도메인네임(ip포트))
	
	url의 L은 Locator,즉 리소스가 있는 위치를 지정
		foo://abcd.com:3000/over/there?name=abcd#nose
		
	urn의 N은 name,즉 리소스의 이름을 부여
		urn:example:animal:ferret:nose
		
	위치는 변할수있지만 이름은 변하지않음(그래서 책 isbn같은건 urn임)
		
	보통 url을 사용하게됨
	url은,scheme://userinfo@host:port/path?query#fragment 구성임
		https://www.google.com/search?q=hello&hi=ko
		
		프로토콜 https:
		호스트명 www.google.com
		패스(라우트) /search
		쿼리 ?q=hello&hi=ko
	
	유저인포는 거의 사용하지않고,포트는 80,443은 생략
	path는 리소스의 경로,라우트할때 그거맞음
	쿼리는
		key=value형태
		?로 시작하고,&로 추가가능(q=hello&hi=ko)
		쿼리 파라메터,쿼리스트링으로 불림,웹서버에 제공하는 파라미터
		
	fragment는 거의 사용하지않음,보통 위키같은데서 내부에서 이동할떄 #로 이동할때 사용함,서버로 전송하지않음	
		
		
	브라우저에서 접속을하면,
		1.http요청메시지를 생성함
			get /search?q=hello&hi=ko HTTP/1.1  //라우트와 쿼리,http버전정보
			Host:www.google.com                 //도메인정보
		2.이 메시지는	소켓 라이브러리를 통해 os계층의 tcp/ip로 전달함 
		3.os의 tcp는 해당서버와 연결하고(3웨이핸드쉐이크),데이터를 전달함(여기에 http메시지가 들어있음)
		
	받을땐,
		tcp패킷을 까서,
		http메시지를 꺼낸다음에,그걸 해석하고,
		http응답메시지를 만들어서 전달함(위랑같음)
		
	그리고 content-type는,컨텐츠의 타입	
	

3.http 기본
	요즘은 모든걸 http로 전송함
	tcp직접쓰는거도 게임서버?같은경우나 쓰고

	http는 아직도 1.1이 제일 많이쓰임,2나 3은 성능개선
	1.1과 2는 tcp를 사용하고,3은 udp를 사용함(3way핸드쉐이크 하기싫어서)
	
	http의 특징은
		클라이언트 서버 구조
		무상태 프로토콜,비연결성
		http메시지
		단순함,확장가능
		
	클라이언트와 서버구조는,클라이언트와 서버를 분리함,
	그래서 request와 response구조가 됐고
	클라이언트는 서버에 요청을 보내고 응답을 대기하고,서버는 요청에 대한 결과를 만들어서 응답하는식
	
	이 구조가 중요한건,비즈니스로직과 데이터같은걸 서버에 다 밀어넣고,클라이언트는 사용성에 집중함
	이래서 서로 독립적으로 진화를 할수있었음
	
	그리고 스테이스리스는,서버가 클라이언트의 상태를 보존하지않는다는것(파라메터 저장을 하지않는다는것,물론 db같은 외부저장을 통하면 할수있긴한데..)
	이래서 서버가 스케일아웃이 쉬워졌음(스티키세션같은거로 붙일수있긴한데 별로 좋진않긴하지,서버터져버리면 스티키붙은거 다 개판나고..그래서 레디스쓰긴하지만)

	비연결성은,연결모델은 계속 연결을 유지하고있지만(서버자원소모) 
	http는 딱 리퀘스트받은걸 바로 리턴을 보내고 연결을 끊어버림
	이래서 실제로 동시처리하는 요청을 최대한 줄일수있음
	단점으로,핸드쉐이크 비용이 계속 들어간다는거랑,html말고도 js,css이미지등도 같이 다운로드받아진다는거
	(연결하면 그냥 한번에 받으면되는데 이경우엔 html,js,이미지등 하나하나마다 핸드쉐이크를 다시해야함)
	이건 http지속연결(퍼시스턴트 커넥션)로 문제가 해결됨
	보통 20초 뭐 이렇게 연결하고 끊는식으로 구현된거
	
	그래서 최대한 스테이스리스로 짜야하는건,같은시간에 맞춰서 발생하는 대용량 트래픽일경우
		선착순이벤트,수강신청
		
	http메시지는
		스타트라인
		헤더
		공백라인
		메시지보디
	로 구성됨(요청 응답 모두)그리고 공백라인도 필수임,저거로 바디랑 구분하는 구분자임
	요청은
		get /search?q=hello&hi=ko HTTP/1.1  //시작라인
		Host:www.google.com                 //헤더
		                                    //공백라인
		리퀘스트바디들..                         //메시지바디
	응답은
		http/1.1 200 OK                      //시작라인
 		Content-type:text/html;charset=utf-8 //헤더
		content-length:3423                  //헤더
		                                     //공백라인
		<html>								 //메시지바디
			<body>...</body>                 //메시지바디
		</html>                              //메시지바디
	이런식으로 구성됨
	
	스타트라인은 리퀘스트라인과 스테이터스 라인으로 구분됨(각각 요청,응답시에 나감)
		리퀘스트라인은
			메소드 리퀘스트타겟(요청대상,라우트경로) http버전 crlf (엔터)
		메소드는 http 메소드(get,post 등)
		리퀘스트타겟은 /로 시작하는 절대경로+쿼리
		http버전은 http버전
		
		스테이터스라인은
			http버전 스테이터스코드 상태코드설명 crlf
		http버전은 http버전
		스테이터스코드는 200,404 500같은거
		보통
			200:성공
			400:클라이언트 요청오류
			500:서버 내부 오류
		상태코드설명은 현재 상태가 나온이유에 대한 간단한 설명
	헤더는
		필드네임: 필드밸류 //대소문자구분없고,yaml처럼 필드네임과 :는 붙여야하고 밸류랑은 띄우든가말든가 상관없음
	헤더는 http전송에 필요한 모든 부가정보가 다 들어있음
		메시지바디의 내용
		바디크기
		압축여부
		인증
		요청클라이언트 정보
		서버애플리케이션 정보(응답)
		캐시관리정보
	즉 바디뺴고 메타데이터는 다 들어있음
	필요하면 임의의 헤더도 추가할수있음
	
	메시지바디는 실제 전송할 데이터
	바이트표현되는 모든 데이터를 전송가능

4.http 메서드
	api의 이름에서 가장 중요한건,리소스식별을 할수있냐임
	그래서 회원조회에선 회원이 리소스임
	그러니까
		get /members    //전체조회
		get /members/id //id조회
		/members/id
		/members/id
		/members/id
	즉,리소스와 행위를 분리하고,메소드를 구분하는식으로 만드는게 좋음
	그래서 리소스는 명사,행위는 동사임
	
	보통
		get 리소스조회
		post 요청데이터처리,보통등록에 사용
		put 리소스를 대체하거나 리소스가 없으면 생성(업데이트)
		patch 리소스 부분 변경
		delete 리소스 삭제
	를 주고쓰고
		head get과 같은데,메시지뺴고 헤더와 상태만 반환
		options cors에서 사용
	정도가 있음
	
	get은 리소스를 조회함,이때 파라메터는 쿼리를 통해 전달함
	메시지바디를 사용할수있긴한데,지원안하는곳이 많아서 권장하지않음
		요청예제 
			GET /members/100 HTTP/1.1
			Host: localhost:8080
		응답예제
			HTTP/1.1 200 OK
			Content-Type: application/json
			Content-Length: 34
			
			{
				"username": "abcd"
				"age": 20
			}
	post는 요청데이터를 처리함,post는 보통 메시지바디를 통해(리퀘스트바디) 요청데이터를 전달함
	주로 전달된 데이터로 신규리소스 등록이나 프로세스처리에 사용
		요청예제
			POST /members HTTP/1.1
			Content-Type: application/json
			
			{
				"username": "abcd"
				"age": 20
			}
		응답예제
			HTTP/1.1 201 Created
			Content-Type: application/json
			Content-Length: 34
			Location: /members/100  //get위치
			
			{
				"username": "abcd"
				"age": 20
			}	
		//201말고 200으로 보내도되는데,201로보낼땐 location을 붙여주고,200은 안붙임
	post는 진짜 get말고 모든걸 이거로 보내도 될정도로,모든용도로 사용됨(정해진것이 없음)
	보통은
		새 리소스 생성(등록)
		데이터생성이나 변경을 넘어서,프로세스를 처리해야하는경우
		post의 결과로 새 리소스가 생성되지않을수도있음(컨트롤 url,즉 저기로 던지면 무슨 일을 시작하는 트리거로 쓸때,이경우엔 리소스중심은 아니지만..)
		다른메서드로 처리하기 애매할때(만능)
			만약 메시지바디를 써야하는데(json으로 넘겨야하는데),서버가 get에서 메시지바디를 안읽어줄떄
			뭔가 이거도 저거도 아닌거같고 애매할때
	일때 사용함,애매하면 그냥 post쓰면 절반은 가는듯
	
	put은 리소스를 대체함,리소스가 있으면 대체,없으면 생성
	폴더에 파일넣는거 생각하면됨(덮어쓰기)
	post와 차이는,클라이언트가 리소스를 식별하고(클라이언트가 리소스위치를 알고 url을 지정해야함)
	post는 그냥 데이터만 던지면되는데(insert),put은 where가 필요함
		요청예제
			PUT /members/100 HTTP/1.1
			Content-Type: application/json
			
			{
				"username": "abcd"
				"age": 20
			}
	
	주의점은,리소스를 완전히 대체해서,update가 아닌,delete를 하고 insert를 함
	
	patch는 리소스를 업데이트함(이걸 지원안하는경우가 있는데,이경우엔 post써야함)
	그래서
			{
				"username": "abcd"
				"age": 20
			}	//id는 100
	이거를
			PATCH /members/100 HTTP/1.1
			Content-Type: application/json
			
			{
				
				"age": 30
			}
	보내면
			{
				"username": "abcd"
				"age": 30
			}		
	이렇게 업데이트가 됨
	delete는 그냥 삭제임

		DELETE /members/100 HTTP/1.1
		Host: localhost:8080
	
	http 메서드들의 속성은
		안전  //호출해도 변경이 일어나지않음,단 서버부하나 로그에러같은건 고려하지않고 리소스단위로만 고려함
		멱등성 //두번이상 같은걸 던져도,한번던졌을때와 결과가 같음,get이나 where이 있는 put,delete같은건 여러번던져도 같은데,post는 다를수있으니
		캐시가능//응답결과 리소스를 캐시해도 사용해도되는가?(get,head정도만 사용,post,patch도가능하긴한데 어려워서안함)
	멱등성은,타임아웃등으로 정상응답을 못줬을때 클라이언트가 다시 같은요청을 해도 되는지에 대한 판단근거가 됨
	이 메서드 종류마다 다르게 있음
		get은 안전,멱등성,캐시가능
		post는 사실상 다 불가능
		put는 멱등
		delete는 멱등
		patch는 사실상 다 불가능
		option은 안전,멱등


5.http 메서드 활용
	일반적으로 쿼리파라미터는 get에서 정렬이나 필터,즉 검색어로 많이사용
	메세지바디는 post,put,patch에서 리소스등록,리소스변경등에서 사용
	
	정적데이터 조회시엔,그냥 경로를 적는걸로
		GET /static/abcd.jpg HTTP/1.1
	해결됨
	동적데이터 조회시엔
		GET /search?q=abcd&hl=ko HTTP/1.1
	이런식으로 매개변수받아서 처리함(결과가 동적으로 생성됨)

	post전송시엔 form태그를 던질수있음
	이때 타입이 서밋인걸 누르면(버튼),form의 action(url)과 method대로,
	폼태그내에있는 name값을 키로,적은값을 value형태로 바꿔서 서버에 던짐(쿼리파라미터랑 생긴건 같음)
	이때 컨텐츠타입은
		Content-Type: application/x-www-form-urlencoded //url인코드라서 한글같은거들어가면 %20이렇게나옴 맨날보던거
	키값은
		키1=값1&키2=값2
	이때 폼태그의 메서드를 get으로 바꾸면,저걸 쿼리파라미터로 바꿔서 넣어버림,
	물론 get을 리소스변경이 나타나는곳에서 사용하면안됨
	저게 save가 아니라 조회였으면 상관없지만
	
	그리고 파일같은걸 전송할땐 multipart/form-data임
	위에 폼이랑 같지만,
		<form action="/save" method="post" enctype="multipart/form-data">
	이렇게 폼에 enctype이 저거이고
		<input type="file" name="file1/>
	이렇게 인풋타입 파일인게 있으면
	컨텐츠타입을
		Content-Type: multipart/form-data;boundary=----XXX
	이런식으로 하고,----XXX경계로 자르는거
	이경우 키값과 파일과 모든걸 이렇게 잘라서 보냄
	보통 바이너리데이터를 보낼때 사용함
	얘는 다른종류의 여러파일과 폼의 내용을 같이보낼수있음(어짜피 바이너리니까)
	
	그리고 html form전송은 get과 post만 지원함
	
	http api를 전송할땐(서버2서버)
	그냥 뭐 신경쓸필요없이 던지면됨(라이브러리 있으니까 그냥 그거쓰면 알아서해줌)
	이떄 컨텐츠타입은 application/json을 주로 씀,사실상 표준
	또 ajax같은거로 통신할때도 사용함

	httpapi 설계는
	기본적으로 경로에는 리소스만
		/members
		/data
		/log
		/user
	전체조회는 get,등록은 post,부분조회도 get/{id},수정은 patch,put,post,삭제는 delete
	수정은 내가 하고싶은 작업에따라 선택하면됨,애매하면 post
	제일좋은건 patch로 업데이트긴 함
	put은 게시글수정같은경우엔 사용하긴함(전체를 덮어야할때)
	
	post기반 등록은,클라이언트가 등록될 리소스의 url을 몰라도됨,데이터만 있어도됨(애초에 신규등록이니)
	리소스식별자를 생성하는건 서버가 할일임
	
	보통
		파일 목록 /files get
		파일 조회 /files/{filename} get
		파일 등록 /files/{filename} put //파일이니까 덮어쓰기라서 사용할수있음
		파일 삭제 /files/{filename} delete 
		파일 대량 등록 /files post //멀티포트로 등록
	put을 쓰려면,클라이언트가 리소스의 url을 알고있어야함(파일의경우 파일명,회원의경우 id)
	그래서 클라이언트가 이걸 아는게 자연스러운경우(파일명같은경우)엔 쓸수있는데,아닐경우엔 쓰기힘듬
	보통은 post를 사용함 신규등록은..

	html form은 get이랑 post밖에 지원안함(물론 ajax로 다른거 쓸수있긴함)
	이경우엔
		회원목록 /members get
		회원등록폼/members/new get            //회원등록 폼을 띄우는거,저장이 아님
		회원등록 /members/new,/members post  //폼을 사용하면,폼이랑 경로를 맞추는게 벨리데이션(등록실패시 클라에 다시 값돌려주는거)이 편함
		회원조회 /members/{id} get
		회원수정폼/members/{id}/edit get //회원수정폼을 띄우는거
		회원수정/members/{id}/edit,/members/{id} post
		회원삭제/members/{id}/delete post
	이런식으로 설계를 많이함
	그리고 delete의 경우엔 delete같은걸 못쓰니까
	리소스에 따른 동사를 붙이는식으로 컨트롤url을 써야함
	컨트롤url은 애매하면 이렇게쓸수밖에없음
	
	http네이밍 참고
		https://restfulapi.net/resource-naming
	대충
		단일개념(파일,db row):문서
		서버가 관리하는 리소스뭉치(멤버같은):컬렉션
		클라이언트가 관리하는 자원저장소(파일같은):스토어
		저 3가지외에 애매한것들,이경우엔 동사를 직접 사용:컨트롤러,컨트롤url
	대부분 컬렉션이고,게시판이나 파일정도만 스토어사용함




6.http상태코드
	기본적으로
		1--:요청이 수신됐고 처리중 //안씀
		2--:요청 정상 처리
		3--:요청을 완료하려면 추가행동이 필요
		4--:클라이언트오류,잘못된 문법등으로 서버가 요청을 수행할수없음
		5--:서버오류,서버가 정상요청을 처리하지못함
	
	상태코드는 상위에 하위가 포함됨(231은 클라이언트가 모르면 200이라고 처리하면됨)
	
	2xx는 성공임
		200 ok       //성공
		201 created  //post로 생성했을때 던지면됨,얘는 location헤더가 있을수있음
		202 accepted //요청이 접수됐는데 처리는 안됨(배차처리같은거,미래에 추가작업을 해야할때) 잘안씀
		204 no content //요청은 성공했는데 데이터가 없을때(save버튼같은거)
	보통 200만 사용하고,201정도까지만 사용함
	3xx은 뭔가 추가작업이 필요하다고 클라이언트에 돌려보내는거,300은 잘안씀
		301 moved permanetly 
		302 Found
		303 See Other
		304 not modified
		307 Temporay Redirect
		308 permanent Redirect
	그리고 웹브라우저는,3xx응답결과에 location이 있으면,그위치로 자동 이동함(리다이렉트)
	이건,만약 url이 새로운경로로 옮겼을때,301번넣고 location으로 해당경로를 넣으면 거기로 리다이렉트됨
	
	이 리다이렉션엔
		영구 리다이렉션:특정 리소스의 url이 영구적으로 바뀌었을때
		일시 리다이렉션:일시적인 변경,주문완료시 주문내역화면으로 이동하는 그런거(prg패턴)
		특수 리다이렉션:결과대신 캐시사용,클라에서 캐시기간이 만료됐는지 확인하는거

	301,308은 영구리다이렉션임
	url이 영구적으로 이동,검색봇에서도 인지함
		301은 리다이렉트시 요청메서드가 get으로 변하고,본문(메시지바디)이 제거될수있음(해도되고 안해도되는데 보통 함)
		308은 301과 거의같은데,요청메서드와 본문을 유지함(알아서 바꿔서 알아서처리함 서버에서)
	근데 보통 301을 쓰는게 좋음,api가 바뀌었으면 거기맞춰서 다시 처리하는게 맞기때문..
	사실 301도 잘 안쓰고,일시 리다이렉션을 사용함
	
	302,307,303은 일시 리다이렉션임
	리소스의 url이 일시적으로 변경됐을때 사용됨,그래서 검색봇에서 url을 바꾸지않음
		302는 리다이렉트시 요청메서드가 get으로 변하고,본문(메시지바디)이 제거될수있음(해도되고 안해도되는데 보통 함)
		307은 302와 거의같은데,강제적으로 요청메서드와 본문을 유지함
		303은 302와 거의같은데,강제적으로 요청메서드가 get으로 변경되고,본문이 제거됨
	307,303쓰는게 좋긴한데 302쓰는경우도 많음
	
	이 일시적 리다이렉션은,prg(post/redirect/get)에서 잘 쓰임
		post로 주문후에 200을보내고 웹브라우저를 새로고침하면?->새로고침은 다시요청->중복주문이 될수있음
		post를 보내고 302로 get으로 리다이렉트를 걸어버리면?->get 새로고침은 멱등성이 유지됨->중복주문이 되지않음
	
	304는 캐시 리다이렉션임
		캐시를 목적으로 사용,클라이언트에 리소스가 수정되지않았음을 알려줌,이걸받으면 클라는 로컬pc에 저장된 캐시를 재사용함
		304는 응답에 메시지바디를 넣으면안됨(로컬캐시를 사용해야하니)
		조건부 get,head요청시 사용됨


	4xx는 클라이언트가 잘못한거라,새로고침을 해도 같은실패가 계속나옴(무슨일이있어도 똑같이실패임)
		400 bad request 클라이언트가 잘못된 요청을해서(파라미터틀림,api스펙이 틀림) 처리할수없음
		401 unauthorized클라이언트가 해당 리소스에 대한 인증이 필요함,얘는 res에 WWW-Authenticate헤더에 인증방법을 설명해야함
		403 Forbidden 서버가 요청을 이해했지만,승인을 거부함(인가,즉 권한이 없을때)
		404 not found 서버에 그런 리소스가 없거나,그런 리소스가 있다는걸 권한이 부족한 사용자에게 숨기고싶을때
	5xx는 서버문제로 오류가 발생,재시도하면 성공할수도 있음(db접근불가했던게 풀렸을때)
		500 internal Server Error 서버내부문제로 오류발생,애매하면 이거
		503 service unavailable 서버가 일시적과부하나 예정된 작업으로 요청을 처리할수없음,retry-after헤더로 얼마뒤에 복구되는지 보낼수있음

	백엔드에선 이런걸 철저하게 잡아서,각각 맞는 코드로 보내줘야 나중에 수정이 쉬움
	그리고 왠만하면 500대에러를 만들면 안됨,잔고부족이나 뭐 이런걸 500에러로 내면안됨(블리자드코리아..)
	비즈니스 로직상 예외케이스일경우엔 거기맞춰서 처리해야함,null예외나 뭐 이런거만 500으로 받아야함
	나머지는 400이나 200으로 해결해야함

7.http 헤더-일반헤더
	헤더의 필드네임은 대소문자구분없음
	헤더의 용도는,http전송에 필요한 모든 부가정보가 들어있고,
	필요시 임의의 헤더 추가 가능
	
	content-type이나 content-length는 메시지 본문의 데이터를 해석할수 있는 정보,즉 표현 헤더임(본문을 표현데이터나 페이로드라고도 부름)
	표현=표현헤더+표현데이터
	표현 헤더에는
		content-type:표현데이터의 형식
		content-Encoding:표현데이터의 압축방식
		content-language:표현데이터의 자연언어
		content-length:표현데이터의 길이
	이 표현헤더는 전송(req)과 응답(res) 둘다 사용함
	content-type은,바디에 들어가는 데이터의 형식설명
		content-type: text/html;charset=utf-8
		content-type: application/json
		content-type: image/png
	이런식
	content-Encoding은 표현데이터를 압축할때,압축후 인코딩헤더 추가후 받는데서 해제
		content-Encoding:gzip
	content-language는 표현데이터의 자연언어를 표현
		content-language: ko
	content-length는 표현데이터의 길이,바이트단위고 transfer-encoding를 사용할땐 이걸 넣으면안됨
		content-length:1323

	컨텐츠 협상은,클라이언트가 선호하는 타입을 요청하는것
		Accept:선호하는 미디어타입
		Accept-Charset:선호하는 문자 인코딩
		Accept-Encoding:선호하는 압축인코딩
		Accept-Language:선호하는 자연언어
	클라이언트의 선호니까 요청(req)시에만 사용
	즉,accepted-Language를 사용해서 클라이언트가 위치를 파악한 후에,그걸 저기 담아보내면 서버에서 거기맞춰서 언어를 맞춰주는거임
	만약 해당 언어가 없을경우에,기본세팅이 독일어같은 이런거면 독일어를 보내게됨
	그래서 우선순위를 여러개 지정할수있음
		Accept-Language: ko-KR,ko:q=0.9,en-US;q=0.8,en;q=0.7  //q=1은 생략가능
	이런식으로 지정하면,우선순위따라 순서대로 체크하고 줘야함
	만약 저안에 하나도없으면 기본설정을 주는거
	
	그리고 이 우선순위에선 따로 점수를 매기지않았을땐,구체적인게 우선함
		Accept:text/*,text/plain,text/plain;format=flowed,*/*
		1.text/plain;format=flowed
		2.text/plain
		3.text/*
		4.*/*
	이건 자체적으로 q값을 알아서 매겨서 처리하는식임
	
	전송은
		단순전송
		압축전송
		분할전송
		범위전송
	이 있음
	단순전송은 content-length를 넣고,단순하게 전송하는것
	압축전송은 content-Encoding까지 넣고 압축해서 전송하는것(랭스에 추가로)
	분할전송은 Transfer-Encoding을 넣고(Transfer-Encoding:chunked) 전송하는것,이경우 content-length넣으면 안됨
	이경우 메시지바디는
		5
		hello
		4
		hihi
	이런식으로 분할돼서 전송됨
	범위전송은 content-Range를 넣어서,만약 절반을 못받았을경우 절반을 잘라서 거기부터 요청하는것
	
	일반적인 헤더로는 
		From은 유저에이전트의 이메일정보
		잘안씀
		
		Referer는 이전 웹 페이지 주소(현재 요청페이지 전에 갔던 페이지 주소)
		a->b로 이동할경우 b를 요청할때 referer:A를 포함해서 요청함
		referer를 사용해서 유입경로분석가능
		요청(req)에서 사용
		
		User-Agent는 내 웹브라우저의 정보나 클라이언트의 애플리케이션 정보
		보통 특정브라우저에서 장애가 발생하는지 파악하거나,통계정보를 내거나 할때사용
		
		Server는 요청을 처리하는 origin서버(실제 요청을 받는 서버)의 소프트웨어정보
		응답(res)에서 사용
		
		Date는 메시지가 발생한 날짜와 시간
		응답에서 사용
	가 있고,
	특별한 헤더로는
		host는 요청한 호스트의 정보임
		req에서 사용
		필수임
		하나의 서버가 여러 도메인을 처리해야할때(k8s에서 한 노드에 여러 컨테이너 들어가거나 하는거처럼),어디로 보냈는지 구분하기위해 사용함
	
		location은 3xx의 결과에 location이 있으면,그 위치로 리다이렉션시킴
		201에서의 location값은 요청에 의해(post)생성된 리소스url
		3xx에서의 location값은 요청을 리다이렉션하기위한 대상 리소스
		
		Allow는 허용가능한 http메서드
		만약 get만 열어뒀는데 post가 들어왔을때 405를 주면서 이 헤더를 넣어두고 인식을 할수있는데
		잘안씀
		
		Retry-After은 503던졌을때 서비스가 언제까지 뻗었는지 말해주는거
		잘안씀
	가 있음
	
	인증 헤더에는
		Authorization은 클라이언트의 인증 정보를 서버에 전달함
		각 인증 방법(Oauth같은)에 따라 값은 다 다름
			Authorization: Basic xxxxxx //이런식
		
		
		WWW-Authenticate는 리소스 접근시 필요한 인증 방법 정의(401에러)
		401을 던지면서 저 헤더를 넣어주고 인증방법을 넣어줘야함


	쿠키 헤더는
		set-Cookie:서버에서 클라로 쿠키 전달(res)
		Cookie:클라가 서버에서 받은 쿠키를 저장하고,http요청시 서버로 전달
	
	http는 무상태 프로토콜이라서,상태값을 사용하려면 모든 요청에 사용자정보를 포함하는게 가장 무식한 방법(안좋은방법)
	그래서 나온게 쿠키임
	만약 로그인을 하면,서버에서 쿠키(uuid같은거라고 보면됨)를 생성해서,쿠키저장소에 넣고(uuid와 아이디같은거로 구성됨)쿠키를 클라에 전달함
	이러면 클라는 다음요청부터 무조건 쿠키를 모든 요청에 넣어서 보내는거(자동으로 포함함)
	
	보통 쿠키는
		set-cookie: sessionId=abcd123;expired=Sat,26-Dec-2020 00:00:00 GMT;path=/;domain=.google.com;Secure
	이런식으로 구성되고
	사용처는
		사용자 로그인세션관리
		광고 정보 트래킹
	그리고 쿠키정보는 항상 서버에 전송되니까 트래픽이 추가로 유발되므로,최소한의 정보만 사용해야함
	그리고 쿠키에는 보안에 민감한 데이터(주민번호,신용카드번호등)은 저장하면안됨,저장소에 접근할수있는 키값(세션키)만 가지고있는게 좋음

	쿠키에서 expired시간이 지나면 쿠키가 삭제됨
	그리고 세션쿠키는 만료일자를 생략하면 브라우저 종료하면 만료됨
	영속쿠키는 만료날짜를 입력하면 해당 날짜까지 유지됨
	
	그리고 쿠키에 도메인을 명시해서,그 도메인에서만 작동함
	만약 도메인을 명시하면,서브도메인을 포함하고,생략하면 현재도메인에만 적용됨
	
	그리고 path를 명시하면,이 경로를 포함한 하위경로(/home면 /home와 /home/local은 되는데 /hello는 안됨)만 접근가능함
	일반적으로 path는 / 이렇게 루트로 지정함
	
	쿠키의 보안에는
		Secure를 넣으면,https인 경우에서만 전송함(http전송하지 않음)
		HttpOnly는 xss공격방지용인데,이걸넣으면 js에서 접근불가능해짐(document.cookie),http전송에서만 사용
		SameSite는 XSRF공격방지용인데,요청도메인과 쿠키도메인이 같을경우에만 쿠키가 전송됨(즉 생성한 서버에서만 쿠키를 전송함)


8.http 헤더-캐시와 조건부 요청
	캐시가 없으면 새로고침마다 똑같은 데이터를 다운로드받아야함
	캐시를 적용할땐,
	서버 헤더에
		cache-control: max-age=60 //60초
	를 넣어두면 그걸 브라우저에서 저장해서 캐시로 쓸수있음
	
	만약 캐시시간이 초과되면,서버에 요청을 다시 보내는데,만약 그 사이에 변화가 없었으면 서버가 그거 계속쓰라고 할수있음
	이때 쓰는게 검증헤더와 조건부 요청임
	만약 기존데이터가 변경됐으면,새로 보내줘야하는데,
	아니라면 그대로쓸수있음
	이때 필요한게 검증방법임(두개가 같다는)
	이때 사용하는 검증헤더가
		Last-Modified: 2020년 11월 10일 10:00:00 //utc표기법으로 적으면됨
	즉 마지막에 수정된 시간을 넣어서 캐시에 넣어두고(캐시유효값,마지막수정시간,데이터 3개를 저장)
	캐시시간이 지나면 마지막수정시간을 요청에 넣어서 같이 보내고,서버에서 그걸보고 판단하는거
		if-modified-since:2020년 11월 10일 10:00:00  //클라->서버
	이경우 변경이 없었으면 서버에서 304 not modified를 보내는데,
		Last-Modified: 2020년 11월 10일 10:00:00
		cache-control: max-age=60
	을 넣어서 보내는데,중요한건 http 바디가 없음(데이터안보내려고 이러는거니까..)
	
	즉,시간이 지났을때 다운로드가 필요하긴한데,헤더만 받을수있으니까 네트워크코스트가 매우 줄어듬
	
	last-modified,if-modified-since는 단점이,1초미만으로 캐시조정이 불가능하고,날짜기반로직이라는 단점이 있음
	그리고 작은변경의경우 캐시를 유지하고싶을때가 있음(캐시로직을 서버에서 관리하고싶을때)
	ETag는 if-None-Match를 사용해서,캐시로직을 서버가 담당할수있음
	이건 캐시데이터에 해시값같은 버전명을 붙여서,해시값이 다르면 바꾸고,같으면 그대로 쓰는식으로 사용함
		ETag:"abcd"  //서버->클라
		if-None-Match: "abcd"//클라->서버
	일치시 304,다르면 200으로 새로보냄
	
	이경우 캐시제어로직은 서버에서 완전히 관리하게됨,클라에서 알방법이 없음(단순히 받은값 다시주는거니까)

	캐시제어헤더에는 Cache-Control을 사용
	여기엔
		cache-control: max-age=60  //60초캐시
		cache-control: no-cache    //캐시해도되는데,항상 원서버에 검증받고 사용
		cache-control: no-store    //캐시자체를 하면안됨(개인정보)
	가 있음
	
	프록시캐시는,실제 서버 앞에 프록시 캐시서버(cdn서버)를 둬서,거기로 접근하게 하는 방법임
	이때,프록시서버의 캐시를 퍼블릭캐시,로컬캐시를 프라이빗캐시라고 함
	이거때문에 cache-control에 몇개가 추가됨
		cache-control: public //응답이 퍼블릭에 있어도됨
		cache-control: private//응답이 프라이빗에만 있어야함(기본값)
		cache-control: s-maxage//프록시캐시에만 적용되는 max-age
		Age:60 //오리진서버에서 응답하고,프록시서버에 잇던 시간,몰라도됨

	
	캐시를 확실하게 못하게 하는법은(웹브라우저가 지맘대로 캐시하는경우가 있음)
		cache-control: no-store,no-cache,must-revalidate
		Pragma:no-cache
	하면 어지간하면 캐시안함 하면지잘못임(Pragma는 http1.0하위호환임,둘다 헤더에넣으면됨)
	must-revalidate는,캐시만료후 최초조회시 원서버에 검증해야함
	원서버 접근실패하면 반드시 504에러가 발생해야함
	캐시유효시간이면 캐시를사용함
	
	no-cache랑 must-revalidate를 같이쓰는이유는,
	no-cache는 원서버 접근이 불가능할때 캐시서버설정에 따라 예전데이터라도 보여주게할수있기때문(Error보다는 나을수도있으니까)
	그래서 must-revalidate로 강제로 에러띄워버리는거





9.다음
	스킵





















