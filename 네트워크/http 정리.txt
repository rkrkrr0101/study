1.인터넷 네트워크
	ip프로토콜(하위레벨 프로토콜)로는 패킷대상의 상황을 알수없고,못받는상태여도 그냥보냄
	그리고 패킷이 사라지거나 순서가 틀리면->tcp
	
	소켓의경우,7계층에 있고,tcp는 6계층이니까,정확히 tcp=소켓이라기보단 tcp를 싸둔거라고 봐야할듯
	
	ip패킷엔 출발지ip,목적지ip등이 있고,ip패킷안에 tcp세그먼트가 있는데
	tcp세그먼트엔 출발지포트,목적지포트,전송제어,순서,검증정보 등이 있음
	ip패킷(tcp세그먼트(내가보내는데이터))같은느낌
	
	tcp는 
		연결지향(3웨이 핸드쉐이크)
		순서보장
		전달보증(all or nothing)
	가 있다..(보통 스트리밍말곤 다 tcp사용함)
	뭐 다 아는거긴하지만
	udp는,그냥 막 던짐,ip와 거의같은데 port와 체크섬정도만 있음
	
2.uri와 웹브라우저 요청 흐름
	uri와 url,url의 차이는
		uri가 기본,리소스 판별자
		url=uri+로케이터 ,즉 리소스 위치
		urn=uri+name ,즉 리소스 이름
	
	uri는
		U:리소스 식별하는 통일된 방식
		R:리소스,uri로 식별할수있는 모든것(제한없음,파일이나 웹사이트나)
		I:다른항목과 구분할때 필요한정보(파일의 위치라던가,도메인네임(ip포트))
	
	url의 L은 Locator,즉 리소스가 있는 위치를 지정
		foo://abcd.com:3000/over/there?name=abcd#nose
		
	urn의 N은 name,즉 리소스의 이름을 부여
		urn:example:animal:ferret:nose
		
	위치는 변할수있지만 이름은 변하지않음(그래서 책 isbn같은건 urn임)
		
	보통 url을 사용하게됨
	url은,scheme://userinfo@host:port/path?query#fragment 구성임
		https://www.google.com/search?q=hello&hi=ko
		
		프로토콜 https:
		호스트명 www.google.com
		패스(라우트) /search
		쿼리 ?q=hello&hi=ko
	
	유저인포는 거의 사용하지않고,포트는 80,443은 생략
	path는 리소스의 경로,라우트할때 그거맞음
	쿼리는
		key=value형태
		?로 시작하고,&로 추가가능(q=hello&hi=ko)
		쿼리 파라메터,쿼리스트링으로 불림,웹서버에 제공하는 파라미터
		
	fragment는 거의 사용하지않음,보통 위키같은데서 내부에서 이동할떄 #로 이동할때 사용함,서버로 전송하지않음	
		
		
	브라우저에서 접속을하면,
		1.http요청메시지를 생성함
			get /search?q=hello&hi=ko HTTP/1.1  //라우트와 쿼리,http버전정보
			Host:www.google.com                 //도메인정보
		2.이 메시지는	소켓 라이브러리를 통해 os계층의 tcp/ip로 전달함 
		3.os의 tcp는 해당서버와 연결하고(3웨이핸드쉐이크),데이터를 전달함(여기에 http메시지가 들어있음)
		
	받을땐,
		tcp패킷을 까서,
		http메시지를 꺼낸다음에,그걸 해석하고,
		http응답메시지를 만들어서 전달함(위랑같음)
		
	그리고 content-type는,컨텐츠의 타입	
	

3.http 기본
	요즘은 모든걸 http로 전송함
	tcp직접쓰는거도 게임서버?같은경우나 쓰고

	http는 아직도 1.1이 제일 많이쓰임,2나 3은 성능개선
	1.1과 2는 tcp를 사용하고,3은 udp를 사용함(3way핸드쉐이크 하기싫어서)
	
	http의 특징은
		클라이언트 서버 구조
		무상태 프로토콜,비연결성
		http메시지
		단순함,확장가능
		
	클라이언트와 서버구조는,클라이언트와 서버를 분리함,
	그래서 request와 response구조가 됐고
	클라이언트는 서버에 요청을 보내고 응답을 대기하고,서버는 요청에 대한 결과를 만들어서 응답하는식
	
	이 구조가 중요한건,비즈니스로직과 데이터같은걸 서버에 다 밀어넣고,클라이언트는 사용성에 집중함
	이래서 서로 독립적으로 진화를 할수있었음
	
	그리고 스테이스리스는,서버가 클라이언트의 상태를 보존하지않는다는것(파라메터 저장을 하지않는다는것,물론 db같은 외부저장을 통하면 할수있긴한데..)
	이래서 서버가 스케일아웃이 쉬워졌음(스티키세션같은거로 붙일수있긴한데 별로 좋진않긴하지,서버터져버리면 스티키붙은거 다 개판나고..그래서 레디스쓰긴하지만)

	비연결성은,연결모델은 계속 연결을 유지하고있지만(서버자원소모) 
	http는 딱 리퀘스트받은걸 바로 리턴을 보내고 연결을 끊어버림
	이래서 실제로 동시처리하는 요청을 최대한 줄일수있음
	단점으로,핸드쉐이크 비용이 계속 들어간다는거랑,html말고도 js,css이미지등도 같이 다운로드받아진다는거
	(연결하면 그냥 한번에 받으면되는데 이경우엔 html,js,이미지등 하나하나마다 핸드쉐이크를 다시해야함)
	이건 http지속연결(퍼시스턴트 커넥션)로 문제가 해결됨
	보통 20초 뭐 이렇게 연결하고 끊는식으로 구현된거
	
	그래서 최대한 스테이스리스로 짜야하는건,같은시간에 맞춰서 발생하는 대용량 트래픽일경우
		선착순이벤트,수강신청
		
	http메시지는
		스타트라인
		헤더
		공백라인
		메시지보디
	로 구성됨(요청 응답 모두)그리고 공백라인도 필수임,저거로 바디랑 구분하는 구분자임
	요청은
		get /search?q=hello&hi=ko HTTP/1.1  //시작라인
		Host:www.google.com                 //헤더
		                                    //공백라인
		리퀘스트바디들..                         //메시지바디
	응답은
		http/1.1 200 OK                      //시작라인
 		Content-type:text/html;charset=utf-8 //헤더
		content-length:3423                  //헤더
		                                     //공백라인
		<html>								 //메시지바디
			<body>...</body>                 //메시지바디
		</html>                              //메시지바디
	이런식으로 구성됨
	
	스타트라인은 리퀘스트라인과 스테이터스 라인으로 구분됨(각각 요청,응답시에 나감)
		리퀘스트라인은
			메소드 리퀘스트타겟(요청대상,라우트경로) http버전 crlf (엔터)
		메소드는 http 메소드(get,post 등)
		리퀘스트타겟은 /로 시작하는 절대경로+쿼리
		http버전은 http버전
		
		스테이터스라인은
			http버전 스테이터스코드 상태코드설명 crlf
		http버전은 http버전
		스테이터스코드는 200,404 500같은거
		보통
			200:성공
			400:클라이언트 요청오류
			500:서버 내부 오류
		상태코드설명은 현재 상태가 나온이유에 대한 간단한 설명
	헤더는
		필드네임: 필드밸류 //대소문자구분없고,yaml처럼 필드네임과 :는 붙여야하고 밸류랑은 띄우든가말든가 상관없음
	헤더는 http전송에 필요한 모든 부가정보가 다 들어있음
		메시지바디의 내용
		바디크기
		압축여부
		인증
		요청클라이언트 정보
		서버애플리케이션 정보(응답)
		캐시관리정보
	즉 바디뺴고 메타데이터는 다 들어있음
	필요하면 임의의 헤더도 추가할수있음
	
	메시지바디는 실제 전송할 데이터
	바이트표현되는 모든 데이터를 전송가능




	
