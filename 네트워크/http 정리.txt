1.인터넷 네트워크
	ip프로토콜(하위레벨 프로토콜)로는 패킷대상의 상황을 알수없고,못받는상태여도 그냥보냄
	그리고 패킷이 사라지거나 순서가 틀리면->tcp
	
	소켓의경우,7계층에 있고,tcp는 6계층이니까,정확히 tcp=소켓이라기보단 tcp를 싸둔거라고 봐야할듯
	
	ip패킷엔 출발지ip,목적지ip등이 있고,ip패킷안에 tcp세그먼트가 있는데
	tcp세그먼트엔 출발지포트,목적지포트,전송제어,순서,검증정보 등이 있음
	ip패킷(tcp세그먼트(내가보내는데이터))같은느낌
	
	tcp는 
		연결지향(3웨이 핸드쉐이크)
		순서보장
		전달보증(all or nothing)
	가 있다..(보통 스트리밍말곤 다 tcp사용함)
	뭐 다 아는거긴하지만
	udp는,그냥 막 던짐,ip와 거의같은데 port와 체크섬정도만 있음
	
2.uri와 웹브라우저 요청 흐름
	uri와 url,url의 차이는
		uri가 기본,리소스 판별자
		url=uri+로케이터 ,즉 리소스 위치
		urn=uri+name ,즉 리소스 이름
	
	uri는
		U:리소스 식별하는 통일된 방식
		R:리소스,uri로 식별할수있는 모든것(제한없음,파일이나 웹사이트나)
		I:다른항목과 구분할때 필요한정보(파일의 위치라던가,도메인네임(ip포트))
	
	url의 L은 Locator,즉 리소스가 있는 위치를 지정
		foo://abcd.com:3000/over/there?name=abcd#nose
		
	urn의 N은 name,즉 리소스의 이름을 부여
		urn:example:animal:ferret:nose
		
	위치는 변할수있지만 이름은 변하지않음(그래서 책 isbn같은건 urn임)
		
	보통 url을 사용하게됨
	url은,scheme://userinfo@host:port/path?query#fragment 구성임
		https://www.google.com/search?q=hello&hi=ko
		
		프로토콜 https:
		호스트명 www.google.com
		패스(라우트) /search
		쿼리 ?q=hello&hi=ko
	
	유저인포는 거의 사용하지않고,포트는 80,443은 생략
	path는 리소스의 경로,라우트할때 그거맞음
	쿼리는
		key=value형태
		?로 시작하고,&로 추가가능(q=hello&hi=ko)
		쿼리 파라메터,쿼리스트링으로 불림,웹서버에 제공하는 파라미터
		
	fragment는 거의 사용하지않음,보통 위키같은데서 내부에서 이동할떄 #로 이동할때 사용함,서버로 전송하지않음	
		
		
	브라우저에서 접속을하면,
		1.http요청메시지를 생성함
			get /search?q=hello&hi=ko HTTP/1.1  //라우트와 쿼리,http버전정보
			Host:www.google.com                 //도메인정보
		2.이 메시지는	소켓 라이브러리를 통해 os계층의 tcp/ip로 전달함 
		3.os의 tcp는 해당서버와 연결하고(3웨이핸드쉐이크),데이터를 전달함(여기에 http메시지가 들어있음)
		
	받을땐,
		tcp패킷을 까서,
		http메시지를 꺼낸다음에,그걸 해석하고,
		http응답메시지를 만들어서 전달함(위랑같음)
		
	그리고 content-type는,컨텐츠의 타입	
	

3.http 기본
	요즘은 모든걸 http로 전송함
	tcp직접쓰는거도 게임서버?같은경우나 쓰고

	http는 아직도 1.1이 제일 많이쓰임,2나 3은 성능개선
	1.1과 2는 tcp를 사용하고,3은 udp를 사용함(3way핸드쉐이크 하기싫어서)
	
	http의 특징은
		클라이언트 서버 구조
		무상태 프로토콜,비연결성
		http메시지
		단순함,확장가능
		
	클라이언트와 서버구조는,클라이언트와 서버를 분리함,
	그래서 request와 response구조가 됐고
	클라이언트는 서버에 요청을 보내고 응답을 대기하고,서버는 요청에 대한 결과를 만들어서 응답하는식
	
	이 구조가 중요한건,비즈니스로직과 데이터같은걸 서버에 다 밀어넣고,클라이언트는 사용성에 집중함
	이래서 서로 독립적으로 진화를 할수있었음
	
	그리고 스테이스리스는,서버가 클라이언트의 상태를 보존하지않는다는것(파라메터 저장을 하지않는다는것,물론 db같은 외부저장을 통하면 할수있긴한데..)
	이래서 서버가 스케일아웃이 쉬워졌음(스티키세션같은거로 붙일수있긴한데 별로 좋진않긴하지,서버터져버리면 스티키붙은거 다 개판나고..그래서 레디스쓰긴하지만)

	비연결성은,연결모델은 계속 연결을 유지하고있지만(서버자원소모) 
	http는 딱 리퀘스트받은걸 바로 리턴을 보내고 연결을 끊어버림
	이래서 실제로 동시처리하는 요청을 최대한 줄일수있음
	단점으로,핸드쉐이크 비용이 계속 들어간다는거랑,html말고도 js,css이미지등도 같이 다운로드받아진다는거
	(연결하면 그냥 한번에 받으면되는데 이경우엔 html,js,이미지등 하나하나마다 핸드쉐이크를 다시해야함)
	이건 http지속연결(퍼시스턴트 커넥션)로 문제가 해결됨
	보통 20초 뭐 이렇게 연결하고 끊는식으로 구현된거
	
	그래서 최대한 스테이스리스로 짜야하는건,같은시간에 맞춰서 발생하는 대용량 트래픽일경우
		선착순이벤트,수강신청
		
	http메시지는
		스타트라인
		헤더
		공백라인
		메시지보디
	로 구성됨(요청 응답 모두)그리고 공백라인도 필수임,저거로 바디랑 구분하는 구분자임
	요청은
		get /search?q=hello&hi=ko HTTP/1.1  //시작라인
		Host:www.google.com                 //헤더
		                                    //공백라인
		리퀘스트바디들..                         //메시지바디
	응답은
		http/1.1 200 OK                      //시작라인
 		Content-type:text/html;charset=utf-8 //헤더
		content-length:3423                  //헤더
		                                     //공백라인
		<html>								 //메시지바디
			<body>...</body>                 //메시지바디
		</html>                              //메시지바디
	이런식으로 구성됨
	
	스타트라인은 리퀘스트라인과 스테이터스 라인으로 구분됨(각각 요청,응답시에 나감)
		리퀘스트라인은
			메소드 리퀘스트타겟(요청대상,라우트경로) http버전 crlf (엔터)
		메소드는 http 메소드(get,post 등)
		리퀘스트타겟은 /로 시작하는 절대경로+쿼리
		http버전은 http버전
		
		스테이터스라인은
			http버전 스테이터스코드 상태코드설명 crlf
		http버전은 http버전
		스테이터스코드는 200,404 500같은거
		보통
			200:성공
			400:클라이언트 요청오류
			500:서버 내부 오류
		상태코드설명은 현재 상태가 나온이유에 대한 간단한 설명
	헤더는
		필드네임: 필드밸류 //대소문자구분없고,yaml처럼 필드네임과 :는 붙여야하고 밸류랑은 띄우든가말든가 상관없음
	헤더는 http전송에 필요한 모든 부가정보가 다 들어있음
		메시지바디의 내용
		바디크기
		압축여부
		인증
		요청클라이언트 정보
		서버애플리케이션 정보(응답)
		캐시관리정보
	즉 바디뺴고 메타데이터는 다 들어있음
	필요하면 임의의 헤더도 추가할수있음
	
	메시지바디는 실제 전송할 데이터
	바이트표현되는 모든 데이터를 전송가능

4.http 메서드
	api의 이름에서 가장 중요한건,리소스식별을 할수있냐임
	그래서 회원조회에선 회원이 리소스임
	그러니까
		get /members    //전체조회
		get /members/id //id조회
		/members/id
		/members/id
		/members/id
	즉,리소스와 행위를 분리하고,메소드를 구분하는식으로 만드는게 좋음
	그래서 리소스는 명사,행위는 동사임
	
	보통
		get 리소스조회
		post 요청데이터처리,보통등록에 사용
		put 리소스를 대체하거나 리소스가 없으면 생성(업데이트)
		patch 리소스 부분 변경
		delete 리소스 삭제
	를 주고쓰고
		head get과 같은데,메시지뺴고 헤더와 상태만 반환
		options cors에서 사용
	정도가 있음
	
	get은 리소스를 조회함,이때 파라메터는 쿼리를 통해 전달함
	메시지바디를 사용할수있긴한데,지원안하는곳이 많아서 권장하지않음
		요청예제 
			GET /members/100 HTTP/1.1
			Host: localhost:8080
		응답예제
			HTTP/1.1 200 OK
			Content-Type: application/json
			Content-Length: 34
			
			{
				"username": "abcd"
				"age": 20
			}
	post는 요청데이터를 처리함,post는 보통 메시지바디를 통해(리퀘스트바디) 요청데이터를 전달함
	주로 전달된 데이터로 신규리소스 등록이나 프로세스처리에 사용
		요청예제
			POST /members HTTP/1.1
			Content-Type: application/json
			
			{
				"username": "abcd"
				"age": 20
			}
		응답예제
			HTTP/1.1 201 Created
			Content-Type: application/json
			Content-Length: 34
			Location: /members/100  //get위치
			
			{
				"username": "abcd"
				"age": 20
			}	
		//201말고 200으로 보내도되는데,201로보낼땐 location을 붙여주고,200은 안붙임
	post는 진짜 get말고 모든걸 이거로 보내도 될정도로,모든용도로 사용됨(정해진것이 없음)
	보통은
		새 리소스 생성(등록)
		데이터생성이나 변경을 넘어서,프로세스를 처리해야하는경우
		post의 결과로 새 리소스가 생성되지않을수도있음(컨트롤 url,즉 저기로 던지면 무슨 일을 시작하는 트리거로 쓸때,이경우엔 리소스중심은 아니지만..)
		다른메서드로 처리하기 애매할때(만능)
			만약 메시지바디를 써야하는데(json으로 넘겨야하는데),서버가 get에서 메시지바디를 안읽어줄떄
			뭔가 이거도 저거도 아닌거같고 애매할때
	일때 사용함,애매하면 그냥 post쓰면 절반은 가는듯
	
	put은 리소스를 대체함,리소스가 있으면 대체,없으면 생성
	폴더에 파일넣는거 생각하면됨(덮어쓰기)
	post와 차이는,클라이언트가 리소스를 식별하고(클라이언트가 리소스위치를 알고 url을 지정해야함)
	post는 그냥 데이터만 던지면되는데(insert),put은 where가 필요함
		요청예제
			PUT /members/100 HTTP/1.1
			Content-Type: application/json
			
			{
				"username": "abcd"
				"age": 20
			}
	
	주의점은,리소스를 완전히 대체해서,update가 아닌,delete를 하고 insert를 함
	
	patch는 리소스를 업데이트함(이걸 지원안하는경우가 있는데,이경우엔 post써야함)
	그래서
			{
				"username": "abcd"
				"age": 20
			}	//id는 100
	이거를
			PATCH /members/100 HTTP/1.1
			Content-Type: application/json
			
			{
				
				"age": 30
			}
	보내면
			{
				"username": "abcd"
				"age": 30
			}		
	이렇게 업데이트가 됨
	delete는 그냥 삭제임

		DELETE /members/100 HTTP/1.1
		Host: localhost:8080
	
	http 메서드들의 속성은
		안전  //호출해도 변경이 일어나지않음,단 서버부하나 로그에러같은건 고려하지않고 리소스단위로만 고려함
		멱등성 //두번이상 같은걸 던져도,한번던졌을때와 결과가 같음,get이나 where이 있는 put,delete같은건 여러번던져도 같은데,post는 다를수있으니
		캐시가능//응답결과 리소스를 캐시해도 사용해도되는가?(get,head정도만 사용,post,patch도가능하긴한데 어려워서안함)
	멱등성은,타임아웃등으로 정상응답을 못줬을때 클라이언트가 다시 같은요청을 해도 되는지에 대한 판단근거가 됨
	이 메서드 종류마다 다르게 있음
		get은 안전,멱등성,캐시가능
		post는 사실상 다 불가능
		put는 멱등
		delete는 멱등
		patch는 사실상 다 불가능
		option은 안전,멱등


5.http 메서드 활용
	일반적으로 쿼리파라미터는 get에서 정렬이나 필터,즉 검색어로 많이사용
	메세지바디는 post,put,patch에서 리소스등록,리소스변경등에서 사용
	
	정적데이터 조회시엔,그냥 경로를 적는걸로
		GET /static/abcd.jpg HTTP/1.1
	해결됨
	동적데이터 조회시엔
		GET /search?q=abcd&hl=ko HTTP/1.1
	이런식으로 매개변수받아서 처리함(결과가 동적으로 생성됨)

	post전송시엔 form태그를 던질수있음
	이때 타입이 서밋인걸 누르면(버튼),form의 action(url)과 method대로,
	폼태그내에있는 name값을 키로,적은값을 value형태로 바꿔서 서버에 던짐(쿼리파라미터랑 생긴건 같음)
	이때 컨텐츠타입은
		Content-Type: application/x-www-form-urlencoded //url인코드라서 한글같은거들어가면 %20이렇게나옴 맨날보던거
	키값은
		키1=값1&키2=값2
	이때 폼태그의 메서드를 get으로 바꾸면,저걸 쿼리파라미터로 바꿔서 넣어버림,
	물론 get을 리소스변경이 나타나는곳에서 사용하면안됨
	저게 save가 아니라 조회였으면 상관없지만
	
	그리고 파일같은걸 전송할땐 multipart/form-data임
	위에 폼이랑 같지만,
		<form action="/save" method="post" enctype="multipart/form-data">
	이렇게 폼에 enctype이 저거이고
		<input type="file" name="file1/>
	이렇게 인풋타입 파일인게 있으면
	컨텐츠타입을
		Content-Type: multipart/form-data;boundary=----XXX
	이런식으로 하고,----XXX경계로 자르는거
	이경우 키값과 파일과 모든걸 이렇게 잘라서 보냄
	보통 바이너리데이터를 보낼때 사용함
	얘는 다른종류의 여러파일과 폼의 내용을 같이보낼수있음(어짜피 바이너리니까)
	
	그리고 html form전송은 get과 post만 지원함
	
	http api를 전송할땐(서버2서버)
	그냥 뭐 신경쓸필요없이 던지면됨(라이브러리 있으니까 그냥 그거쓰면 알아서해줌)
	이떄 컨텐츠타입은 application/json을 주로 씀,사실상 표준
	또 ajax같은거로 통신할때도 사용함

	httpapi 설계는
	기본적으로 경로에는 리소스만
		/members
		/data
		/log
		/user
	전체조회는 get,등록은 post,부분조회도 get/{id},수정은 patch,put,post,삭제는 delete
	수정은 내가 하고싶은 작업에따라 선택하면됨,애매하면 post
	제일좋은건 patch로 업데이트긴 함
	put은 게시글수정같은경우엔 사용하긴함(전체를 덮어야할때)
	
	post기반 등록은,클라이언트가 등록될 리소스의 url을 몰라도됨,데이터만 있어도됨(애초에 신규등록이니)
	리소스식별자를 생성하는건 서버가 할일임
	
	보통
		파일 목록 /files get
		파일 조회 /files/{filename} get
		파일 등록 /files/{filename} put //파일이니까 덮어쓰기라서 사용할수있음
		파일 삭제 /files/{filename} delete 
		파일 대량 등록 /files post //멀티포트로 등록
	put을 쓰려면,클라이언트가 리소스의 url을 알고있어야함(파일의경우 파일명,회원의경우 id)
	그래서 클라이언트가 이걸 아는게 자연스러운경우(파일명같은경우)엔 쓸수있는데,아닐경우엔 쓰기힘듬
	보통은 post를 사용함 신규등록은..

	html form은 get이랑 post밖에 지원안함(물론 ajax로 다른거 쓸수있긴함)
	이경우엔
		회원목록 /members get
		회원등록폼/members/new get            //회원등록 폼을 띄우는거,저장이 아님
		회원등록 /members/new,/members post  //폼을 사용하면,폼이랑 경로를 맞추는게 벨리데이션(등록실패시 클라에 다시 값돌려주는거)이 편함
		회원조회 /members/{id} get
		회원수정폼/members/{id}/edit get //회원수정폼을 띄우는거
		회원수정/members/{id}/edit,/members/{id} post
		회원삭제/members/{id}/delete post
	이런식으로 설계를 많이함
	그리고 delete의 경우엔 delete같은걸 못쓰니까
	리소스에 따른 동사를 붙이는식으로 컨트롤url을 써야함
	컨트롤url은 애매하면 이렇게쓸수밖에없음
	
	http네이밍 참고
		https://restfulapi.net/resource-naming
	대충
		단일개념(파일,db row):문서
		서버가 관리하는 리소스뭉치(멤버같은):컬렉션
		클라이언트가 관리하는 자원저장소(파일같은):스토어
		저 3가지외에 애매한것들,이경우엔 동사를 직접 사용:컨트롤러,컨트롤url
	대부분 컬렉션이고,게시판이나 파일정도만 스토어사용함




6.http상태코드
	기본적으로
		1--:요청이 수신됐고 처리중 //안씀
		2--:요청 정상 처리
		3--:요청을 완료하려면 추가행동이 필요
		4--:클라이언트오류,잘못된 문법등으로 서버가 요청을 수행할수없음
		5--:서버오류,서버가 정상요청을 처리하지못함
	
	상태코드는 상위에 하위가 포함됨(231은 클라이언트가 모르면 200이라고 처리하면됨)
	
	2xx는 성공임
		200 ok       //성공
		201 created  //post로 생성했을때 던지면됨,얘는 location헤더가 있을수있음
		202 accepted //요청이 접수됐는데 처리는 안됨(배차처리같은거,미래에 추가작업을 해야할때) 잘안씀
		204 no content //요청은 성공했는데 데이터가 없을때(save버튼같은거)
	보통 200만 사용하고,201정도까지만 사용함
	3xx은 뭔가 추가작업이 필요하다고 클라이언트에 돌려보내는거,300은 잘안씀
		301 moved permanetly 
		302 Found
		303 See Other
		304 not modified
		307 Temporay Redirect
		308 permanent Redirect
	그리고 웹브라우저는,3xx응답결과에 location이 있으면,그위치로 자동 이동함(리다이렉트)
	이건,만약 url이 새로운경로로 옮겼을때,301번넣고 location으로 해당경로를 넣으면 거기로 리다이렉트됨
	
	이 리다이렉션엔
		영구 리다이렉션:특정 리소스의 url이 영구적으로 바뀌었을때
		일시 리다이렉션:일시적인 변경,주문완료시 주문내역화면으로 이동하는 그런거(prg패턴)
		특수 리다이렉션:결과대신 캐시사용,클라에서 캐시기간이 만료됐는지 확인하는거

	301,308은 영구리다이렉션임
	url이 영구적으로 이동,검색봇에서도 인지함
		301은 리다이렉트시 요청메서드가 get으로 변하고,본문(메시지바디)이 제거될수있음(해도되고 안해도되는데 보통 함)
		308은 301과 거의같은데,요청메서드와 본문을 유지함(알아서 바꿔서 알아서처리함 서버에서)
	근데 보통 301을 쓰는게 좋음,api가 바뀌었으면 거기맞춰서 다시 처리하는게 맞기때문..
	사실 301도 잘 안쓰고,일시 리다이렉션을 사용함
	
	302,307,303은 일시 리다이렉션임
	리소스의 url이 일시적으로 변경됐을때 사용됨,그래서 검색봇에서 url을 바꾸지않음
		302는 리다이렉트시 요청메서드가 get으로 변하고,본문(메시지바디)이 제거될수있음(해도되고 안해도되는데 보통 함)
		307은 302와 거의같은데,강제적으로 요청메서드와 본문을 유지함
		303은 302와 거의같은데,강제적으로 요청메서드가 get으로 변경되고,본문이 제거됨
	307,303쓰는게 좋긴한데 302쓰는경우도 많음
	
	이 일시적 리다이렉션은,prg(post/redirect/get)에서 잘 쓰임
		post로 주문후에 200을보내고 웹브라우저를 새로고침하면?->새로고침은 다시요청->중복주문이 될수있음
		post를 보내고 302로 get으로 리다이렉트를 걸어버리면?->get 새로고침은 멱등성이 유지됨->중복주문이 되지않음
	
	304는 캐시 리다이렉션임
		캐시를 목적으로 사용,클라이언트에 리소스가 수정되지않았음을 알려줌,이걸받으면 클라는 로컬pc에 저장된 캐시를 재사용함
		304는 응답에 메시지바디를 넣으면안됨(로컬캐시를 사용해야하니)
		조건부 get,head요청시 사용됨


	4xx는 클라이언트가 잘못한거라,새로고침을 해도 같은실패가 계속나옴(무슨일이있어도 똑같이실패임)
		400 bad request 클라이언트가 잘못된 요청을해서(파라미터틀림,api스펙이 틀림) 처리할수없음
		401 unauthorized클라이언트가 해당 리소스에 대한 인증이 필요함,얘는 res에 WWW-Authenticate헤더에 인증방법을 설명해야함
		403 Forbidden 서버가 요청을 이해했지만,승인을 거부함(인가,즉 권한이 없을때)
		404 not found 서버에 그런 리소스가 없거나,그런 리소스가 있다는걸 권한이 부족한 사용자에게 숨기고싶을때
	5xx는 서버문제로 오류가 발생,재시도하면 성공할수도 있음(db접근불가했던게 풀렸을때)
		500 internal Server Error 서버내부문제로 오류발생,애매하면 이거
		503 service unavailable 서버가 일시적과부하나 예정된 작업으로 요청을 처리할수없음,retry-after헤더로 얼마뒤에 복구되는지 보낼수있음

	백엔드에선 이런걸 철저하게 잡아서,각각 맞는 코드로 보내줘야 나중에 수정이 쉬움
	그리고 왠만하면 500대에러를 만들면 안됨,잔고부족이나 뭐 이런걸 500에러로 내면안됨(블리자드코리아..)
	비즈니스 로직상 예외케이스일경우엔 거기맞춰서 처리해야함,null예외나 뭐 이런거만 500으로 받아야함
	나머지는 400이나 200으로 해결해야함









