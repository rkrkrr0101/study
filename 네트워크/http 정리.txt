1.인터넷 네트워크
	ip프로토콜(하위레벨 프로토콜)로는 패킷대상의 상황을 알수없고,못받는상태여도 그냥보냄
	그리고 패킷이 사라지거나 순서가 틀리면->tcp
	
	소켓의경우,7계층에 있고,tcp는 6계층이니까,정확히 tcp=소켓이라기보단 tcp를 싸둔거라고 봐야할듯
	
	ip패킷엔 출발지ip,목적지ip등이 있고,ip패킷안에 tcp세그먼트가 있는데
	tcp세그먼트엔 출발지포트,목적지포트,전송제어,순서,검증정보 등이 있음
	ip패킷(tcp세그먼트(내가보내는데이터))같은느낌
	
	tcp는 
		연결지향(3웨이 핸드쉐이크)
		순서보장
		전달보증(all or nothing)
	가 있다..(보통 스트리밍말곤 다 tcp사용함)
	뭐 다 아는거긴하지만
	udp는,그냥 막 던짐,ip와 거의같은데 port와 체크섬정도만 있음
	
2.uri와 웹브라우저 요청 흐름
	uri와 url,url의 차이는
		uri가 기본,리소스 판별자
		url=uri+로케이터 ,즉 리소스 위치
		urn=uri+name ,즉 리소스 이름
	
	uri는
		U:리소스 식별하는 통일된 방식
		R:리소스,uri로 식별할수있는 모든것(제한없음,파일이나 웹사이트나)
		I:다른항목과 구분할때 필요한정보(파일의 위치라던가,도메인네임(ip포트))
	
	url의 L은 Locator,즉 리소스가 있는 위치를 지정
		foo://abcd.com:3000/over/there?name=abcd#nose
		
	urn의 N은 name,즉 리소스의 이름을 부여
		urn:example:animal:ferret:nose
		
	위치는 변할수있지만 이름은 변하지않음(그래서 책 isbn같은건 urn임)
		
	보통 url을 사용하게됨
	url은,scheme://userinfo@host:port/path?query#fragment 구성임
		https://www.google.com/search?q=hello&hi=ko
		
		프로토콜 https:
		호스트명 www.google.com
		패스(라우트) /search
		쿼리 ?q=hello&hi=ko
	
	유저인포는 거의 사용하지않고,포트는 80,443은 생략
	path는 리소스의 경로,라우트할때 그거맞음
	쿼리는
		key=value형태
		?로 시작하고,&로 추가가능(q=hello&hi=ko)
		쿼리 파라메터,쿼리스트링으로 불림,웹서버에 제공하는 파라미터
		
	fragment는 거의 사용하지않음,보통 위키같은데서 내부에서 이동할떄 #로 이동할때 사용함,서버로 전송하지않음	
		
		
	브라우저에서 접속을하면,
		1.http요청메시지를 생성함
			get /search?q=hello&hi=ko HTTP/1.1  //라우트와 쿼리,http버전정보
			Host:www.google.com                 //도메인정보
		2.이 메시지는	소켓 라이브러리를 통해 os계층의 tcp/ip로 전달함 
		3.os의 tcp는 해당서버와 연결하고(3웨이핸드쉐이크),데이터를 전달함(여기에 http메시지가 들어있음)
		
	받을땐,
		tcp패킷을 까서,
		http메시지를 꺼낸다음에,그걸 해석하고,
		http응답메시지를 만들어서 전달함(위랑같음)
		
	그리고 content-type는,컨텐츠의 타입	
	

3.http 기본
	요즘은 모든걸 http로 전송함
	tcp직접쓰는거도 게임서버?같은경우나 쓰고

	http는 아직도 1.1이 제일 많이쓰임,2나 3은 성능개선
	1.1과 2는 tcp를 사용하고,3은 udp를 사용함(3way핸드쉐이크 하기싫어서)
	
	http의 특징은
		클라이언트 서버 구조
		무상태 프로토콜,비연결성
		http메시지
		단순함,확장가능
		
	클라이언트와 서버구조는,클라이언트와 서버를 분리함,
	그래서 request와 response구조가 됐고
	클라이언트는 서버에 요청을 보내고 응답을 대기하고,서버는 요청에 대한 결과를 만들어서 응답하는식
	
	이 구조가 중요한건,비즈니스로직과 데이터같은걸 서버에 다 밀어넣고,클라이언트는 사용성에 집중함
	이래서 서로 독립적으로 진화를 할수있었음
	
	그리고 스테이스리스는,서버가 클라이언트의 상태를 보존하지않는다는것(파라메터 저장을 하지않는다는것,물론 db같은 외부저장을 통하면 할수있긴한데..)
	이래서 서버가 스케일아웃이 쉬워졌음(스티키세션같은거로 붙일수있긴한데 별로 좋진않긴하지,서버터져버리면 스티키붙은거 다 개판나고..그래서 레디스쓰긴하지만)

	비연결성은,연결모델은 계속 연결을 유지하고있지만(서버자원소모) 
	http는 딱 리퀘스트받은걸 바로 리턴을 보내고 연결을 끊어버림
	이래서 실제로 동시처리하는 요청을 최대한 줄일수있음
	단점으로,핸드쉐이크 비용이 계속 들어간다는거랑,html말고도 js,css이미지등도 같이 다운로드받아진다는거
	(연결하면 그냥 한번에 받으면되는데 이경우엔 html,js,이미지등 하나하나마다 핸드쉐이크를 다시해야함)
	이건 http지속연결(퍼시스턴트 커넥션)로 문제가 해결됨
	보통 20초 뭐 이렇게 연결하고 끊는식으로 구현된거
	
	그래서 최대한 스테이스리스로 짜야하는건,같은시간에 맞춰서 발생하는 대용량 트래픽일경우
		선착순이벤트,수강신청
		
	http메시지는
		스타트라인
		헤더
		공백라인
		메시지보디
	로 구성됨(요청 응답 모두)그리고 공백라인도 필수임,저거로 바디랑 구분하는 구분자임
	요청은
		get /search?q=hello&hi=ko HTTP/1.1  //시작라인
		Host:www.google.com                 //헤더
		                                    //공백라인
		리퀘스트바디들..                         //메시지바디
	응답은
		http/1.1 200 OK                      //시작라인
 		Content-type:text/html;charset=utf-8 //헤더
		content-length:3423                  //헤더
		                                     //공백라인
		<html>								 //메시지바디
			<body>...</body>                 //메시지바디
		</html>                              //메시지바디
	이런식으로 구성됨
	
	스타트라인은 리퀘스트라인과 스테이터스 라인으로 구분됨(각각 요청,응답시에 나감)
		리퀘스트라인은
			메소드 리퀘스트타겟(요청대상,라우트경로) http버전 crlf (엔터)
		메소드는 http 메소드(get,post 등)
		리퀘스트타겟은 /로 시작하는 절대경로+쿼리
		http버전은 http버전
		
		스테이터스라인은
			http버전 스테이터스코드 상태코드설명 crlf
		http버전은 http버전
		스테이터스코드는 200,404 500같은거
		보통
			200:성공
			400:클라이언트 요청오류
			500:서버 내부 오류
		상태코드설명은 현재 상태가 나온이유에 대한 간단한 설명
	헤더는
		필드네임: 필드밸류 //대소문자구분없고,yaml처럼 필드네임과 :는 붙여야하고 밸류랑은 띄우든가말든가 상관없음
	헤더는 http전송에 필요한 모든 부가정보가 다 들어있음
		메시지바디의 내용
		바디크기
		압축여부
		인증
		요청클라이언트 정보
		서버애플리케이션 정보(응답)
		캐시관리정보
	즉 바디뺴고 메타데이터는 다 들어있음
	필요하면 임의의 헤더도 추가할수있음
	
	메시지바디는 실제 전송할 데이터
	바이트표현되는 모든 데이터를 전송가능

4.http 메서드
	api의 이름에서 가장 중요한건,리소스식별을 할수있냐임
	그래서 회원조회에선 회원이 리소스임
	그러니까
		get /members    //전체조회
		get /members/id //id조회
		/members/id
		/members/id
		/members/id
	즉,리소스와 행위를 분리하고,메소드를 구분하는식으로 만드는게 좋음
	그래서 리소스는 명사,행위는 동사임
	
	보통
		get 리소스조회
		post 요청데이터처리,보통등록에 사용
		put 리소스를 대체하거나 리소스가 없으면 생성(업데이트)
		patch 리소스 부분 변경
		delete 리소스 삭제
	를 주고쓰고
		head get과 같은데,메시지뺴고 헤더와 상태만 반환
		options cors에서 사용
	정도가 있음
	
	get은 리소스를 조회함,이때 파라메터는 쿼리를 통해 전달함
	메시지바디를 사용할수있긴한데,지원안하는곳이 많아서 권장하지않음
		요청예제 
			GET /members/100 HTTP/1.1
			Host: localhost:8080
		응답예제
			HTTP/1.1 200 OK
			Content-Type: application/json
			Content-Length: 34
			
			{
				"username": "abcd"
				"age": 20
			}
	post는 요청데이터를 처리함,post는 보통 메시지바디를 통해(리퀘스트바디) 요청데이터를 전달함
	주로 전달된 데이터로 신규리소스 등록이나 프로세스처리에 사용
		요청예제
			POST /members HTTP/1.1
			Content-Type: application/json
			
			{
				"username": "abcd"
				"age": 20
			}
		응답예제
			HTTP/1.1 201 Created
			Content-Type: application/json
			Content-Length: 34
			Location: /members/100  //get위치
			
			{
				"username": "abcd"
				"age": 20
			}	
		//201말고 200으로 보내도되는데,201로보낼땐 location을 붙여주고,200은 안붙임
	post는 진짜 get말고 모든걸 이거로 보내도 될정도로,모든용도로 사용됨(정해진것이 없음)
	보통은
		새 리소스 생성(등록)
		데이터생성이나 변경을 넘어서,프로세스를 처리해야하는경우
		post의 결과로 새 리소스가 생성되지않을수도있음(컨트롤 url,즉 저기로 던지면 무슨 일을 시작하는 트리거로 쓸때,이경우엔 리소스중심은 아니지만..)
		다른메서드로 처리하기 애매할때(만능)
			만약 메시지바디를 써야하는데(json으로 넘겨야하는데),서버가 get에서 메시지바디를 안읽어줄떄
			뭔가 이거도 저거도 아닌거같고 애매할때
	일때 사용함,애매하면 그냥 post쓰면 절반은 가는듯
	
	put은 리소스를 대체함,리소스가 있으면 대체,없으면 생성
	폴더에 파일넣는거 생각하면됨(덮어쓰기)
	post와 차이는,클라이언트가 리소스를 식별하고(클라이언트가 리소스위치를 알고 url을 지정해야함)
	post는 그냥 데이터만 던지면되는데(insert),put은 where가 필요함
		요청예제
			PUT /members/100 HTTP/1.1
			Content-Type: application/json
			
			{
				"username": "abcd"
				"age": 20
			}
	
	주의점은,리소스를 완전히 대체해서,update가 아닌,delete를 하고 insert를 함
	
	patch는 리소스를 업데이트함(이걸 지원안하는경우가 있는데,이경우엔 post써야함)
	그래서
			{
				"username": "abcd"
				"age": 20
			}	//id는 100
	이거를
			PATCH /members/100 HTTP/1.1
			Content-Type: application/json
			
			{
				
				"age": 30
			}
	보내면
			{
				"username": "abcd"
				"age": 30
			}		
	이렇게 업데이트가 됨
	delete는 그냥 삭제임

		DELETE /members/100 HTTP/1.1
		Host: localhost:8080
	
	http 메서드들의 속성은
		안전  //호출해도 변경이 일어나지않음,단 서버부하나 로그에러같은건 고려하지않고 리소스단위로만 고려함
		멱등성 //두번이상 같은걸 던져도,한번던졌을때와 결과가 같음,get이나 where이 있는 put,delete같은건 여러번던져도 같은데,post는 다를수있으니
		캐시가능//응답결과 리소스를 캐시해도 사용해도되는가?(get,head정도만 사용,post,patch도가능하긴한데 어려워서안함)
	멱등성은,타임아웃등으로 정상응답을 못줬을때 클라이언트가 다시 같은요청을 해도 되는지에 대한 판단근거가 됨
	이 메서드 종류마다 다르게 있음
		get은 안전,멱등성,캐시가능
		post는 사실상 다 불가능
		put는 멱등
		delete는 멱등
		patch는 사실상 다 불가능
		option은 안전,멱등










