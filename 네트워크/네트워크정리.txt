1.네트워크

1.네트워크 구성도
	홈의 네트워크는 인터넷-모뎀-공유기-단말을 거치지만,데이터센터에선 안정적이고 빠른 서비스제공을 해야하기때문에
	예전엔 3계층구성을 했지만,요즘은 2계층 스파인-리프 구조를 쓴다고함
	스파링리프는 서버간 통신이 늘어나는 요즘에 적합하대
	
2.프로토콜
	프로토콜은 예전엔 bit단위로 진짜 세밀하게 쪼개서썻지만,요즘은 그냥 문자프로토콜로 대충막보냄,http같은거
	보통 tcp/ip는 프로토콜이라고 부르지않고 프로토콜스택이라고 부름
	tcp와 ip는 서로 다른층에서 동작하는 프로토콜인데,그렇게 두개이상을 묶어서쓸떄 프로토콜스택이라고 부름
	실제로 tcp/ip말고 udp,http,ftp등 여러 애플리케이션 레이어 프로토콜이 있음
	
	tcp/ip는 4개부분으로 나눠짐
	물리부분인 이더넷
	데이터가 목적지를 찾아가게해주는 네트워크층
	잘린패킷을 데이터형태로 조립하게 도와주는 전송계층과 애플리케이션계층
	
	
3.osi7계층과 tcp/ip
	osi7계층은 그 피지컬계층부터 애플리케이션계층까지있는 그 네트워크시간에 했던 그거임
	이렇게 각 계층마다 동작하는 방식으로 네트워크를 이해할수있고,각 계층별 프로토콜로 네트워크 구성요소를 모듈화할수있음
	
	osi7계층은 상위계층과 하위계층으로 나뉘는데
	상위계층(애플리케이션계층)은 애플리케이션부터 세션까지
	하위계층(데이터플로계층)은 피지컬부터 트랜스포트까지로 나눠짐
	
	의미하는대로 하위계층은 데이터를 잘 전달하는 역할을 하고,상위계층에선 하위계층을 신경쓰지않고 데이터를 표현하는데 초점을 맞춤
	그래서 앱개발자들은 하위계층을 신경쓰지않고,네트워크엔지니어는 상위계층을 신경쓰지않음
	
	근데 요즘은 tcp/ip과 이더넷으로 네트워크가 이루어져있어서,tcp/ip모델도 있음
	tcp/ip모델은 네트워크액세스,인터넷,트랜스포트,애플리케이션 계층으로 이루어져있는데
		네트워크액세스:피지컬과 데이터링크층
		인터넷:네트워크층
		트랜스포트:트랜스포트층
		애플리케이션:세션,프레젠테이션,애플리케이션 층
	이라고 보면됨
	
	
4.osi7계층 이해
	피지컬층(1):
		피지컬층은 물리계층으로 물리적으로 전기신호를 전달하는데 초점이 맞추어져있음
		얘가 하는일은 들어온 전기신호를 잘 전달하는게 목적이고,전기신호가 들어오면 그걸 재생성해서 내보냄,주소같은개념도 없어서 모든 포트에 같은신호를 전달함
		여기에 속하는 장비는,허브,리피터,케이블,커넥터,트랜시버,탭등이 있음
		허브와 리피터는 통신중재장비이고,케이블,커넥터는 케이블,트랜시버는 랜카드와 케이블연결장치,탭은 전기신호를 복제해줌
		
	데이터링크층(2):
		데이터링크층은 전기신호를 모아서 데이터형태로 바꿈,얘는 전기신호의 전달보다,주소정보를 정의하고 정확한 주소로 통신이 되게하는게 목표임
		얘는 출발지와 도착지주소를 확인하고 내게보낸게 맞는지,내가처리해야하는지에 대해 검사하고 데이터처리를 수행함
		여기서 주소는 ip가 아니라 맥주소임
		
		여기선 전기신호를 모아 데이터형태로 처리하므로,데이터에러를 탐지할수있음
		그리고 데이터전송시엔,주소체계가 생긴다는건 누가보낸건지 알수있다는거니까,
		무작정 데이터를 던지지않고,쟤가 받을수있는지부터 먼저 보내고 응답받고 데이터를 보냄,이걸 플로컨트롤이라고 함
		여기에 속하는 장비는 랜카드와 스위치임
		두장비 모두 맥주소를 이해할수있고,스위치는 맥주소를 보고 통신할 포트를 지정해 내보냄
		
		즉 순서는
			전기신호를 데이터형태로 만들고,목적지출발지 맥주소를 확인후,목적지주소와 내맥주소가 같으면 처리하고 다르면 폐기
		랜카드에는 고유맥주소가 있는데 이걸로 목적지를 처리함
		aa맥주소에 3포트면 aa:3으로 보내는식
		스위치는 단말이 어떤맥주소인지,연결된포트는 어느것인지를 알수있음,이데이터를 통해 단말이 통신할때 적절한단말과 포트로 포워딩해줌
		1계층이랑 다른건 1계층이였으면 브로드캐스트로 전역에 뿌렸을거임,그러면 전장비에서 동시에 하나의통신밖에 처리못함
		얘는 대신 한군데만 보내니까 여러장비에서 동시에 처리가능
		
	네트워크층(3):
		얘는 ip주소를 정의함
		통신을할땐 두가지 주소가 사용되는데,물리적인 mac주소와 논리적인 ip주소임
		맥주소와 달리 ip주소는 사용자가 환경에맞게 변경해 사용할수있고,네트워크주소와 호스트주소로 나뉨
		3계층을 이해할수있는 단말은 네트워크주소정보로 자기가 속한 네트워크와 원격지 네트워크를 구분할수있고,원격지를 어떻게가는지 경로지정이 가능
		ip주소는 앞2자리와 뒷2자리로 구분되는데,앞이 네트워크 뒤가 호스트주소임
		
		3계층의 장비는 라우터임
		라우터는 3계층에서 정의한 ip주소를 이해하고 그 주소로 최적의 경로를 찾아주고 그경로로 패킷을 전송함
		
	트랜스포트층(4):
		여기는 상위층이나 하위층으로 갈때,여기서 패킷이 다 왔는지,아니면 보낼때 빼먹은게 없는지를 확인함
		여기서 tcp와 udp가 나눠짐
		얘가 패킷을 분할할때 패킷헤더에 보내는순서와 받는순서를 적어서 통신하므로 패킷이 유실되면 다시보내라고 요청할수있고,순서가 바뀌어도 바로잡을수있음
		보내는순서가 시퀸스번호고 받는순서가 ack번호,그리고 장치내 앱을 구별하는 포트번호로 상위 앱을 구분함
		
		여기서 동작하는 장비로,로드밸런서와 방화벽이 있음
		이장비들은 포트와 시퀸스,ack번호정보로 부하를 분산하거나 보안정책을 수립해 패킷을 통과,차단하는 기능을 수행함
	
	세션층(5):
		얘는 양 끝단의 프로세스가 연결을 성립하도록 도와주고,연결이 안정적으로 유지되도록 관리하고 다끝나고 연결을 끊는 역할을 함
		우리가 말하는 세션을 관리하는게 역할인데,얘가 tcp/ip세션을 만들고 없애는 책임을 짐
	프레젠테이션층(6):
		얘는 표현방식이 다른 앱이나 시스템간의 통신을 돕기위해(무슨 cpu마다 전치하고 머시기해서 데이터저장하던걸 합치던 그거)
		그걸 하나의 통일된구문으로 변환함,번역기라고 보면됨,그래서 앱층에서 이런걸 신경쓸필요가없게해줌
	애플리케이션계층(7):
		얘는 직접적인 ui나 사용자입출력,http같은 프로토콜이라고 보면됨
		
	
	
	계층별 주요 프로토콜로는
		애플리케이션:http,telnet,ftp
		프레젠테이션:tls,afp,ssh
		세션:pptp,l2tp,ssh
		트랜스포트:tcp,udp,sctp
		네트워크:ipv4,ipv6,nat,vrrp,라우팅 프로토콜
		데이터링크:ieee
		피지컬:케이블들 통신프로토콜
	이 있음
	
	
	
5.인캡슐레이션 디캡슐레이션
	보통 상위-하위,하위-상위로 보낼때,데이터를 쪼개서 캡슐(패킷)에 넣고 보내고,그캡슐을 열어서 데이터형태로 다시 만드는데
	이걸 인캡슐레이션(보낼때),디캡슐레이션(받을때)라고 함
	
	현대 네트워크는 대부분 패킷기반 네트워크임
	그래서 데이터를 패킷으로 쪼개서 보내는데,그래서 하나의 통신이 회선전체를 점유하지않고,
	모든패킷이 동일한 취급을 받으며 여러단말들이 동시에 통신할수있게 해줌
	그래서 데이터를 패킷으로 쪼개고,패킷을 다시 합쳐서 결합하는걸 하는거임
	
	앱에서 데이터를 데이터플로층으로 내려보내면서 패킷에 데이터를 넣을수있게 분할하는데,이걸 인캡슐레이션이라고 함
	네트워크 상황에 따라 적당한크기로 쪼개고,4계층부터 4,3,2층은 자기층에서 필요한 헤더를 붙여넣는데,이건 문자가 아닌 비트로 적음
	그리고 피지컬층에서 전기신호로 바꿔서 보내는거임
	
	그리고 받는측에선 디캡슐레이션을 하는데,전기신호를 데이터로 바꾸어서 2층으로 올리고,
	2층에서 헤더를 확인해 맥주소를 보고 자기꺼가 맞는지 확인하고 맞으면 3층으로올림,이때 2층정보는 필요없으니 제거하고 올림
	3층에선 2층처럼 헤더를확인해 ip를 확인하고 맞으면 헤더를 제거하고 4층으로 올림
	4층도 똑같이 데이터를 상위층으로 헤더를 제거하고 올려보냄
	
	이건 2가지흐름으로 볼수있는데,
		인캡슐레이션 디캡슐레이션으로 데이터전송과정
		각게층헤더를 통해 송신자와 수신자간에 같은계층에서의 통신
	각 계층에서 인캡슐레이션 과정에서 수행했던거처럼,현재계층에서 추가하는 헤더는,반대편 같은층에서 확인할 정보임
	
	헤더들은 넣는정보가 많은데,다알긴 어렵고 제일중요한건
		현재층에서 정의하는 정보
		상위프로토콜 지시자
	임
	현재층에서 정의하는 정보는 앞에서 말했던 그층에서 쓸 정보고,
	상위프로토콜 지시자는,디캡슐레이션과정에선 상위프로토콜이 뭔지 모르면 어떤 프로토콜로 해석해야할지를 모름
	그래서 인캡슐레이션과정에서,자기보다 한단계상위단의 프로토콜을 현재단에 기입하고,디캡슐레이션에서 그걸 해석해서 그쪽으로 올려줌
	
	여기서 유명한게
	tcp포트번호들임
		20,21:ftp
		22:ssh
		80:http
		443:https
	리눅스에서 기본포트들임,http쪽으로 맨날 통신하던거
	
	층마다 가지고있는건
		4층: 포트번호
		3층:프로토콜번호
		2층:이더타입
	을 가지고있음,보면알겠지만 현재단보다 한단계높은정보들
	
	
	
	
	
	
	
2.네트워크 연결과 구성요소
1.네트워크 연결 구분
	네트워크는 lan(사용자내부네트워크)와 wan(광역네트워크)로 나뉘어짐
	근데어짜피 이더넷기반에선 의미없긴함
2.네트워크 회선
	뭐 통신사에 전용회선을 깔아달라고 할수있고,저속 통신기술기반은 안정성이뛰어나지만 요즘은 다 고속이더넷으로 바뀌었다 이런거
	llcf를 쓰면,이더넷에서도 반대쪽에서 문제생겨서 세션끊긴걸 알수있다고함
	
	그리고 통신사쪽에서의 vpn은 하나의망에 여러명이 접속하는데,가입자를 구분할수있어서 전용선처럼 사용할수있다고함
	그리고 개인vpn은 인터넷망으로 vpn터널을 만드는거
3.네트워크 구성요소
	랜카드의 역할은,전기신호를 데이터신호로 변환,또는 그반대(직렬화),맥주소보유하고 2계층처리,플로컨트롤,즉 1,2계층에서할일을 처리함
	케이블은 케이블이고
	허브는,1계층허브는 요즘은 안씀(모든포트에 다 복제해넣어서 부하가심함)
	
	대신 스위치를 씀
	스위치는 허브랑 똑같이 여러장비를 연결하고 통신을 중재하는데,얘는 맥주소를 보고 그 도착지점의 서버포트에만 데이터를 보냄
	그래서 여러 서버들이 동시에 통신을 진행할수있음
	
	라우터는 3계층에서 동작하고,ip주소로,
	원격지로 필요없는패킷이 전송되지않게 브로드캐스트하고 멀티캐스트를 컨트롤하고 이상한데로 통신시도하면 버림
	정확한방향으로 패킷전송되게 경로를 지정하고 최적의경로로 패킷을 포워딩함
	보통은 통신사같은데 있지만,l3스위치나 공유기같은데도 소형으로 들어있긴함
	
	로드밸런서는 4계층에서 동작함,얘는 4계층포트주소를 확인하는 동시에 ip주소를 변경할수있음
	즉,얘의 ip주소로 보내면,얘가 부하에 맞춰서 가장 적절한곳으로 분산을 시켜줌
	이걸위해서 ip변환,서비스헬스체크,대용량세션처리기능등이 있음
	
	보안장비로는 방화벽과 ips가 있음
	얘들도 4계층인데 패킷의 3,4계층정보를 확인하고 정책과 비교해서 버리거나 포워딩함
	
	공유기는 2층스위치,3층라우터,4층nat와 방화벽을 한곳에 모아둔장비임
	공유기는 스위치부분,무선부분,라우터부분으로 나뉨
	
	
	
	
	
3.네트워크 통신
1.유니,멀티,브로드,애니캐스트
	유니캐스트:출발지와 목적지가 1대1통신
	멀티캐스트:1대다 통신,하나의 출발지에서 다수의 목적지로 전송,인방같은거할때 이런느낌임
	브로드캐스트:1:모든포트,동일네트워크상의 모든호스트로 통신
	애니캐스트:1:1통신,같은그룹내에 가장 가까운 호스트에서 응답,dns등에서 사용
	
	유니캐스트는 말그대로 1대1로 제일많이쓰는거
	멀티캐스트는 그룹주소와 그 그룹내 여러호스트로 통신,iptv같은거에서 이걸사용함
	브로드캐스트는 자기가 통신할수있는 모든곳에 통신함,보통 유니캐스트를 하기 전 위치알아내려고 함,기본적으론 로컬내에서 모든호스트에 던짐
	애니캐스트는 주소가 같은 호스트중에서 가장 통신비용이 싼(가까운)곳에 통신함,보통 dns서버를 찾을때 사용하거나,가장가까운 게이트웨이찾을떄 씀
			유니캐스트와 다른점은,유니는 목적지가 한군데고,얘는 목적지후보가 여러개임
	
	여기서 주의할점은,데이터 전달출발지가 기준이 아니라,목적지주소를 기준으로 구분한다는것,출발지는 무조건 1개일수밖에없음
	
	
	트래픽종류를 다룰떄,bum트래픽이라는게 있는데
	이건 브로드캐스트,언노운 유니캐스트,멀티캐스트를 칭함
	이건 서로 다른 종류의 트래픽이지만 동작방식은 비슷함
	언노운 유니캐스트는 유니캐스트여서 목적지주소는 명확히 명시되어있지만,동작은 브로드캐스트일때를 가리킴
	얘는 목적지는 있지만,스위치가 목적지주소를 학습하지못해서(스위치입장에서 언노운)패킷을 모든포트로 전송하는데 이걸 언노운 유니캐스트라고함
	
	이게 중요한건,유니캐스트이지만 겉으로보이는건 브로드캐스트에 가깝기때문,물론 다른랜카드에선 받은걸 확인하고 버리지만,네트워크자원을 많이잡아먹음
	그래서 이더넷환경에서는 arp로 먼저 확인을하고 시작해서 크게 트래픽이 안생김
	
	
2.mac주소
	맥주소는 변경할수 없는(사실있지만)하드웨어 주소임
	맥주소의 앞3덩어리는 제조사코드,뒷3덩어리는장비코드임
	막 자기맘대로 바꿀수있어서,유일하진 않음
	
	랜카드는 자신의 맥주소를 가지고있고,전기신호가 들어오면 자기거인지 확인하고 아니면 버림
	이때,자기꺼거나,브로드캐스트,멀티캐스트같은 그룹주소면 일단 위로 올리고 보는데,
	그래서 브로드캐스트같은거의경우 네트워크가 전부 브로드캐스트로 가득차서 모든단말이 브로드캐스트를 처리하느라 cpu가 가득차는경우도있음
	그리고 보통은 랜카드가 자기꺼아니면 버리지만,패킷을 전부확인해야할떄(와이어샤크) 그런프로그램이 무차별모드를 키면,모든걸 메모리에 올려서 처리할수있게함
	
	
3.ip주소
	osi7계층에서 주소를 갖는건 2층과 3층임,맥과 ip두개
	대부분의 네트워크가 tcp/ip이므로 ip는 중요함
	
	ip는 4덩이로 나눠지고,각 덩어리는 8비트=1바이트로 구성됨
	그리고 네트워크주소와 호스트주소로 나눠지는데,기본적으론 abc클래스로 한덩어리씩 잘라서 썼지만,요즘은 서브넷팅으로 비트단위로 잘라서 네트워크주소로 사용함
	abc는 구분할떄,맨앞이 0이면 a 10이면 b 110이면 c 이렇게 구분하고,각각 한덩어리 두덩어리 세덩어리를 네트워크로 사용했음
	십진수로는 1~127이면 a 128~191이면 b 192~223이면 c였음
	근데 저러니까 애들이 다 a받아가고 안써서 ip가 심하게 낭비되니까 걍 비트단위로 잘라서 그렇게 알아서 부여하는식으로 서브넷팅함
	이런걸 클래스리스(클래스가없음)네트워크 라고 함
	
	클래스리스는 ip와 서브넷마스크 두개로 네트워크와 호스트를 구분함
	서브넷마스크가 네트쿼크가 차지하고있는 자리수를 보여주는거
	ip와 서브넷마스크를 and하면 호스트주소만 남는거임
	그리고 거기서 가장 작은 주소는(192.168.0.0)네트워크주소고,가장 큰주소는 브로드캐스트주소임
	
	사용자입장에서는,서브넷마스크로 내가 사용할수 있는 ip주소의 범위를 파악해야 함
	그래서 그거로 외부와 내부를 구분해야함
	기본적으로는,첫주소와 마지막주소를 알아내고(호스트주소를 전부0으로했을때와 전부1로했을때),그사이값이 내가 사용할수있는 ip임
	
	즉 서브넷이 가지고있는 비트수를 계산하고,만약 6개면(2^6=64)
	0~63,64~127,128~191,192~255중 어디에 속해있나를 확인하고 거기에 속해있으면 그 극단값이 네트워크 브로드캐스트값임
	7이면
	0~127,128~255하면됨
	
	설계자입장에선 서브넷팅을 얼마나 할것이냐(네트워크에 얼마나 기기가 들어올것이냐)를 고민해야함
	현재가진게 /24면(1이 24개,즉 c클래스)256개이므로 각 서브넷별로 기기가 12개쯤필요하면 16개쯤을 주면되니까,/28쯤 주면  16개임(16-2=14)
	그럼 네트워크단에서 1이 4개생기니까,네트워크 14개가 생김(단순나누기하면 15갠데,처음네트워크의 주소랑브로드캐스트를 빼서 1개가빠짐)
	
	그리고 네트워크를 설계할땐,가능하면 사설ip를 사용하는게 좋음
	사설ip는 내부적으로 따로 ip를 쓰고(192.168.0.1같은거),
	외부로 나갈땐 현재 접속해있는 기기만 따로 번호를 할당해서 통신하게해줌
	
	네트워크를 설계할떈,단계적으로 큰거자르고 거기서 또자르고 하는식으로 되는게 관리하기 편함
	그러면 라우터가 알아야하는 경로도 적어짐(즉,책임을 밑으로 분할하는게 편함 각기 하나씩 위에서 잘라주기보다)
	
	사설ip를 쓸때 공인ip로 변경해서 외부와 통신할수있는데,이때쓰는게 nat임
	이걸쓰면 ip두개를 매핑해서 외부에나갈땐 그걸로 덮어씌워서 나가고,들어올땐 다시 사설ip로 덮어씌움(공유기가 하는일)
	
	그래서 공유기가 맨날 192168쓰는거임
	
	여기서 중요한건,사설ip를 써도,외부에서 쓰는 영역을 쓰면,만약 그쪽으로 통신할때 사설인지 외부인지 헷갈려서 그쪽으로 접근을 못하게 될수있으니까
	원래 안쓰던 rfc에 명시된 ip대역을 써야함
	
	
4.tcp와 udp
	4계층에서 동작하는건 tcp/udp임
	얘는 패킷이 순서가 바뀌지않게하고,유실된패킷이 없게함(있으면 다시받음)
	
	4층에서 쓰는 헤더정보로는 시퀸스번호,ack번호가 있고,상위프로토콜지시자로는 포트번호가 있음,조립끝났으니 무슨포트로 넣어줄지 알아야하니까
	보통 유명한 포트로는 80(http),443(https)등이 있음
	얘가쓰는 프로토콜은 tcp/udp를 씀
	
	이때 tcp에서 쓰는게 seq,ack인데
	이거로 tcp는 유실없는통신을 보장함
	tcp는 분할된 패킷을 잘 분할하고,수신측이 잘 조합하도록 응답번호를 부여함
	패킷에 순서를 부여하는걸 시퀸스번호,응답번호를 부여하는걸 ack번호라고 함
	이 두개로 순서가 바뀌거나 패킷이 손실된걸 파악할수있음
	
	기본적으로 패킷을 하나 보내고,그럼 받는쪽에서 다음번호를 부르면서 이거달라고 하고를 끝까지 반복함
	근데 이렇게 하나하나보내면 엄청오래걸리니까,그냥 대량으로 한번에 보내고,
	받은만큼 번호받았다고 답변하면,그게 맞으면 다음거보내고 아니면 다시보내는식으로 함
	이때 보내는 사이즈를 윈도사이즈라고 하는데,이거만큼 보냄,그리고 이 윈도사이즈를 조절하는걸 슬라이딩윈도라고 함
	기본적인 최대값은 2^16인데,요즘은 너무작아서 그냥 애스크의숫자를 무시하는식으로 사용함
	이떄 만약 못받았으면,윈도사이즈를 반으로 줄이고,정상적으로 들어가면 1씩올리는식으로 사용함
	
	tcp에선 유실없는통신을 위해 통신시작전에 사전연결을 함,이걸 3방향 핸드셰이크라고 함
	클라이언트가 서버에 통신가능하냐고 물어보고,서버쪽에서 답변이오면 클라이언트 준비완료,거기서 다시 서버로 답변보내면 서버준비완료되고 서로통신함
	처음시작할땐 syn을 보내고,서버-클라처음시엔 ack랑syn을 같이 보냄,그리고 연결이끝나면 fin을 보냄
	이건 미리 정해진6비트를 어떤걸 키고끄는지로 구분함 키면 on 끄면 off
	
	udp는 이런게 다 없고,그냥 막 던짐
	어디로 가냐만 있고(포트번호)나머진 데이터밖에 없어서 그냥 되는데로 던짐,그래서 스트리밍같은데서 사용함
	얘는 처음에 연결시작을 첫데이터로 인터럽트를 걸고 유실시킨후에 그냥 막 던지는데,이렇게하지않고,
	연결확립은 tcp로 하고 데이터던지는거만 udp로 하는게 대부분임
	
	
	
	
5.arp
	실제 통신은 ip기반으로 일어나고,사실 mac은 ip주소를 알고 그거로 네트워크에 있는 정보로 알아내는데,이떄사용하는게 arp임
	ip는 논리적주소고,맥은 물리적주소인데 두개는 전혀 연관성이 없음
	
	만약 서버에 처음 연결을 시도하면,ip주소는 알고있지만 mac주소는 라우터거칠때마다 바뀌기때문에 알수없음,
	그래서 그쪽으로 가는걸 전체 네트워크에 브로드캐스트해서 그쪽가는 맥주소(라우터주소)가 뭔지를 질의해야함
	그쪽으로 가는 라우터는 그걸듣고 자기맥주소를 응답하면 거기로 적고 그 라우터로 보냄
	이걸 도착할때까지 반복함
	
	이때 arp가 저장되는테이블을 arp테이블이라고 함(매번 브로드캐스트하면 부하엄청심하니까 저장해두고함)
	이건 논리주소-물리주소 저장이라 논리주소는 자주바뀌니까,안쓰면(일정시간통신없으면)지워버림
	
	arp는 cpu작업이라서,이거로 해커들이 해킹 자주해서 네트워크회사들은 수동으로 업그레이드하거나 정적으로 테이블을 유지함
	그래서 네트워크장비가 바뀌면 이걸알려줘야함
	
	arp패킷은,송신자 맥,ip주소 대상자 맥,ip주소 이 4개가 제일 중요함
	만약 도착지mac주소를 ffffffffffff로 해두고 아이피는넣고,
	출발지맥은 자기자신으로 해두고 아이피는넣고 대상자맥은 000000000000넣고 브로드캐스트하면
	라우터로 가서(송신자),자기꺼넣고 다음으로 반복함
	즉 맥주소가 출발지,도착지,송신자 이 3개가 있는거임
	
	garp는 자신의 ip-mac을 알릴목적으로 사용함
	이건 ip충돌,상대방의(동일서브넷상의 다른)arp테이블 갱신,고가용성용도의 클러스터링
	에 사용됨
	
	ip는 일반적으로 유일해야하지만,여러이유로 충돌나는경우가 있는데,garp로 이걸 확인할수있음
	
	그거말곤 고가용성 솔루션에서,두개의 서버가 하나의 가상ip로 서비스하는데 두대의 db중 한대만 동작하고 한대는 대기하는데,
	이때 액티브상태인 서버가 가상ip로 응답해 처리하지만 맥주소는 진짜맥주소를 사용함
	이때 액티브가 바뀌어서 맥주소가 바뀌면,그래도 라우터는 전맥주소쪽으로 던지니까 이걸 바꾸기위해 garp로 바뀌었다는걸 알림
	
	또 클러스터링에서는,가상mac을 사용하는데 얘는 네트워크에 있는 스위치의 mac테이블 갱신이 목적임
	클러스터링에서 가상mac주소를 사용할땐 단말은 arp정보를 가상mac로 학습하므로 단말의 arp를 갱신할필요가 없음
	대신 중간의 스위치mac테이블은 마스터가 바뀌면 다르게찾아가야하니까 마스터가 바뀔때 mac테이블을 갱신해야함
	(즉 특정포트에 맥주소가 매핑되어있는데,그걸 바꿔서 찾아갈곳을 바꿔야함)
	클러스터에 문제가 생겨서 장애극복이 안될수도있지만,스위치가 이걸 제떄못바꿔서 이상한데다 계속통신을 할때도있음
	
	rarp는 리버스arp임
	얘는 맥주소를가지고 ip를 알아낼때사용함
	요즘은안씀
	
6.서브넷과 게이트웨이
	게이트웨이는 원격지장비와의 통신에 사용하는 장비를 게이트웨이라고 부르고,3계층장비(라우터와 l3스위치)가 이역할을 할수있음(공유기)
	로컬에서는 arp로 도착지를 학습할수있고,이거로 직접통신할수있지만 원격에서는 네트워크를넘어 브로드캐스트를 할수없어서 장비의 도움이 필요함
	이때 필요한 장비를 게이트웨이라고 함
	
	목적지가 로컬인지 외부인지 확인하는건 서브넷마스크로 하고,이거안이면 내부에서 브로드캐스트,외부면 게이트웨이로 던지는게 기본작동방식
	여기서 내부에서 도는건 레이어2통신,외부로도는건 레이어3통신이라고 함
	
	같은네트워크안이면 arp브로드캐스트를 직접던지고,알아내자마자 통신이 시작되고
	외부네트워크면 직접보낼수없다고 판단하고,게이트웨이의 ip주소로 요청함
	게이트웨이에서 응답받은 단말은 도착지맥에 기본게이트웨이맥주소를 넣고 통신을 함(게이트웨이가 대신통신)
	로컬에선 도착지맥과 도착지ip가 같지만,원격지는 도착지맥과 도착지ip가 다름
	도착지맥은 게이트웨이의 맥주소,ip는 실제도착지
	

	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	