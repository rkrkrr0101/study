1.네트워크

1.네트워크 구성도
	홈의 네트워크는 인터넷-모뎀-공유기-단말을 거치지만,데이터센터에선 안정적이고 빠른 서비스제공을 해야하기때문에
	예전엔 3계층구성을 했지만,요즘은 2계층 스파인-리프 구조를 쓴다고함
	스파링리프는 서버간 통신이 늘어나는 요즘에 적합하대
	
2.프로토콜
	프로토콜은 예전엔 bit단위로 진짜 세밀하게 쪼개서썻지만,요즘은 그냥 문자프로토콜로 대충막보냄,http같은거
	보통 tcp/ip는 프로토콜이라고 부르지않고 프로토콜스택이라고 부름
	tcp와 ip는 서로 다른층에서 동작하는 프로토콜인데,그렇게 두개이상을 묶어서쓸떄 프로토콜스택이라고 부름
	실제로 tcp/ip말고 udp,http,ftp등 여러 애플리케이션 레이어 프로토콜이 있음
	
	tcp/ip는 4개부분으로 나눠짐
	물리부분인 이더넷
	데이터가 목적지를 찾아가게해주는 네트워크층
	잘린패킷을 데이터형태로 조립하게 도와주는 전송계층과 애플리케이션계층
	
	
3.osi7계층과 tcp/ip
	osi7계층은 그 피지컬계층부터 애플리케이션계층까지있는 그 네트워크시간에 했던 그거임
	이렇게 각 계층마다 동작하는 방식으로 네트워크를 이해할수있고,각 계층별 프로토콜로 네트워크 구성요소를 모듈화할수있음
	
	osi7계층은 상위계층과 하위계층으로 나뉘는데
	상위계층(애플리케이션계층)은 애플리케이션부터 세션까지
	하위계층(데이터플로계층)은 피지컬부터 트랜스포트까지로 나눠짐
	
	의미하는대로 하위계층은 데이터를 잘 전달하는 역할을 하고,상위계층에선 하위계층을 신경쓰지않고 데이터를 표현하는데 초점을 맞춤
	그래서 앱개발자들은 하위계층을 신경쓰지않고,네트워크엔지니어는 상위계층을 신경쓰지않음
	
	근데 요즘은 tcp/ip과 이더넷으로 네트워크가 이루어져있어서,tcp/ip모델도 있음
	tcp/ip모델은 네트워크액세스,인터넷,트랜스포트,애플리케이션 계층으로 이루어져있는데
		네트워크액세스:피지컬과 데이터링크층
		인터넷:네트워크층
		트랜스포트:트랜스포트층
		애플리케이션:세션,프레젠테이션,애플리케이션 층
	이라고 보면됨
	
	
4.osi7계층 이해
	피지컬층(1):
		피지컬층은 물리계층으로 물리적으로 전기신호를 전달하는데 초점이 맞추어져있음
		얘가 하는일은 들어온 전기신호를 잘 전달하는게 목적이고,전기신호가 들어오면 그걸 재생성해서 내보냄,주소같은개념도 없어서 모든 포트에 같은신호를 전달함
		여기에 속하는 장비는,허브,리피터,케이블,커넥터,트랜시버,탭등이 있음
		허브와 리피터는 통신중재장비이고,케이블,커넥터는 케이블,트랜시버는 랜카드와 케이블연결장치,탭은 전기신호를 복제해줌
		
	데이터링크층(2):
		데이터링크층은 전기신호를 모아서 데이터형태로 바꿈,얘는 전기신호의 전달보다,주소정보를 정의하고 정확한 주소로 통신이 되게하는게 목표임
		얘는 출발지와 도착지주소를 확인하고 내게보낸게 맞는지,내가처리해야하는지에 대해 검사하고 데이터처리를 수행함
		여기서 주소는 ip가 아니라 맥주소임
		
		여기선 전기신호를 모아 데이터형태로 처리하므로,데이터에러를 탐지할수있음
		그리고 데이터전송시엔,주소체계가 생긴다는건 누가보낸건지 알수있다는거니까,
		무작정 데이터를 던지지않고,쟤가 받을수있는지부터 먼저 보내고 응답받고 데이터를 보냄,이걸 플로컨트롤이라고 함
		여기에 속하는 장비는 랜카드와 스위치임
		두장비 모두 맥주소를 이해할수있고,스위치는 맥주소를 보고 통신할 포트를 지정해 내보냄
		
		즉 순서는
			전기신호를 데이터형태로 만들고,목적지출발지 맥주소를 확인후,목적지주소와 내맥주소가 같으면 처리하고 다르면 폐기
		랜카드에는 고유맥주소가 있는데 이걸로 목적지를 처리함
		aa맥주소에 3포트면 aa:3으로 보내는식
		스위치는 단말이 어떤맥주소인지,연결된포트는 어느것인지를 알수있음,이데이터를 통해 단말이 통신할때 적절한단말과 포트로 포워딩해줌
		1계층이랑 다른건 1계층이였으면 브로드캐스트로 전역에 뿌렸을거임,그러면 전장비에서 동시에 하나의통신밖에 처리못함
		얘는 대신 한군데만 보내니까 여러장비에서 동시에 처리가능
		
	네트워크층(3):
		얘는 ip주소를 정의함
		통신을할땐 두가지 주소가 사용되는데,물리적인 mac주소와 논리적인 ip주소임
		맥주소와 달리 ip주소는 사용자가 환경에맞게 변경해 사용할수있고,네트워크주소와 호스트주소로 나뉨
		3계층을 이해할수있는 단말은 네트워크주소정보로 자기가 속한 네트워크와 원격지 네트워크를 구분할수있고,원격지를 어떻게가는지 경로지정이 가능
		ip주소는 앞2자리와 뒷2자리로 구분되는데,앞이 네트워크 뒤가 호스트주소임
		
		3계층의 장비는 라우터임
		라우터는 3계층에서 정의한 ip주소를 이해하고 그 주소로 최적의 경로를 찾아주고 그경로로 패킷을 전송함
		
	트랜스포트층(4):
		여기는 상위층이나 하위층으로 갈때,여기서 패킷이 다 왔는지,아니면 보낼때 빼먹은게 없는지를 확인함
		여기서 tcp와 udp가 나눠짐
		얘가 패킷을 분할할때 패킷헤더에 보내는순서와 받는순서를 적어서 통신하므로 패킷이 유실되면 다시보내라고 요청할수있고,순서가 바뀌어도 바로잡을수있음
		보내는순서가 시퀸스번호고 받는순서가 ack번호,그리고 장치내 앱을 구별하는 포트번호로 상위 앱을 구분함
		
		여기서 동작하는 장비로,로드밸런서와 방화벽이 있음
		이장비들은 포트와 시퀸스,ack번호정보로 부하를 분산하거나 보안정책을 수립해 패킷을 통과,차단하는 기능을 수행함
	
	세션층(5):
		얘는 양 끝단의 프로세스가 연결을 성립하도록 도와주고,연결이 안정적으로 유지되도록 관리하고 다끝나고 연결을 끊는 역할을 함
		우리가 말하는 세션을 관리하는게 역할인데,얘가 tcp/ip세션을 만들고 없애는 책임을 짐
	프레젠테이션층(6):
		얘는 표현방식이 다른 앱이나 시스템간의 통신을 돕기위해(무슨 cpu마다 전치하고 머시기해서 데이터저장하던걸 합치던 그거)
		그걸 하나의 통일된구문으로 변환함,번역기라고 보면됨,그래서 앱층에서 이런걸 신경쓸필요가없게해줌
	애플리케이션계층(7):
		얘는 직접적인 ui나 사용자입출력,http같은 프로토콜이라고 보면됨
		
	
	
	계층별 주요 프로토콜로는
		애플리케이션:http,telnet,ftp
		프레젠테이션:tls,afp,ssh
		세션:pptp,l2tp,ssh
		트랜스포트:tcp,udp,sctp
		네트워크:ipv4,ipv6,nat,vrrp,라우팅 프로토콜
		데이터링크:ieee
		피지컬:케이블들 통신프로토콜
	이 있음
	
	
	
5.인캡슐레이션 디캡슐레이션
	보통 상위-하위,하위-상위로 보낼때,데이터를 쪼개서 캡슐(패킷)에 넣고 보내고,그캡슐을 열어서 데이터형태로 다시 만드는데
	이걸 인캡슐레이션(보낼때),디캡슐레이션(받을때)라고 함
	
	현대 네트워크는 대부분 패킷기반 네트워크임
	그래서 데이터를 패킷으로 쪼개서 보내는데,그래서 하나의 통신이 회선전체를 점유하지않고,
	모든패킷이 동일한 취급을 받으며 여러단말들이 동시에 통신할수있게 해줌
	그래서 데이터를 패킷으로 쪼개고,패킷을 다시 합쳐서 결합하는걸 하는거임
	
	앱에서 데이터를 데이터플로층으로 내려보내면서 패킷에 데이터를 넣을수있게 분할하는데,이걸 인캡슐레이션이라고 함
	네트워크 상황에 따라 적당한크기로 쪼개고,4계층부터 4,3,2층은 자기층에서 필요한 헤더를 붙여넣는데,이건 문자가 아닌 비트로 적음
	그리고 피지컬층에서 전기신호로 바꿔서 보내는거임
	
	그리고 받는측에선 디캡슐레이션을 하는데,전기신호를 데이터로 바꾸어서 2층으로 올리고,
	2층에서 헤더를 확인해 맥주소를 보고 자기꺼가 맞는지 확인하고 맞으면 3층으로올림,이때 2층정보는 필요없으니 제거하고 올림
	3층에선 2층처럼 헤더를확인해 ip를 확인하고 맞으면 헤더를 제거하고 4층으로 올림
	4층도 똑같이 데이터를 상위층으로 헤더를 제거하고 올려보냄
	
	이건 2가지흐름으로 볼수있는데,
		인캡슐레이션 디캡슐레이션으로 데이터전송과정
		각게층헤더를 통해 송신자와 수신자간에 같은계층에서의 통신
	각 계층에서 인캡슐레이션 과정에서 수행했던거처럼,현재계층에서 추가하는 헤더는,반대편 같은층에서 확인할 정보임
	
	헤더들은 넣는정보가 많은데,다알긴 어렵고 제일중요한건
		현재층에서 정의하는 정보
		상위프로토콜 지시자
	임
	현재층에서 정의하는 정보는 앞에서 말했던 그층에서 쓸 정보고,
	상위프로토콜 지시자는,디캡슐레이션과정에선 상위프로토콜이 뭔지 모르면 어떤 프로토콜로 해석해야할지를 모름
	그래서 인캡슐레이션과정에서,자기보다 한단계상위단의 프로토콜을 현재단에 기입하고,디캡슐레이션에서 그걸 해석해서 그쪽으로 올려줌
	
	여기서 유명한게
	tcp포트번호들임
		20,21:ftp
		22:ssh
		80:http
		443:https
	리눅스에서 기본포트들임,http쪽으로 맨날 통신하던거
	
	층마다 가지고있는건
		4층: 포트번호
		3층:프로토콜번호
		2층:이더타입
	을 가지고있음,보면알겠지만 현재단보다 한단계높은정보들
	
	
	
	
	
	
	
2.네트워크 연결과 구성요소
1.네트워크 연결 구분
	네트워크는 lan(사용자내부네트워크)와 wan(광역네트워크)로 나뉘어짐
	근데어짜피 이더넷기반에선 의미없긴함
2.네트워크 회선
	뭐 통신사에 전용회선을 깔아달라고 할수있고,저속 통신기술기반은 안정성이뛰어나지만 요즘은 다 고속이더넷으로 바뀌었다 이런거
	llcf를 쓰면,이더넷에서도 반대쪽에서 문제생겨서 세션끊긴걸 알수있다고함
	
	그리고 통신사쪽에서의 vpn은 하나의망에 여러명이 접속하는데,가입자를 구분할수있어서 전용선처럼 사용할수있다고함
	그리고 개인vpn은 인터넷망으로 vpn터널을 만드는거
3.네트워크 구성요소
	랜카드의 역할은,전기신호를 데이터신호로 변환,또는 그반대(직렬화),맥주소보유하고 2계층처리,플로컨트롤,즉 1,2계층에서할일을 처리함
	케이블은 케이블이고
	허브는,1계층허브는 요즘은 안씀(모든포트에 다 복제해넣어서 부하가심함)
	
	대신 스위치를 씀
	스위치는 허브랑 똑같이 여러장비를 연결하고 통신을 중재하는데,얘는 맥주소를 보고 그 도착지점의 서버포트에만 데이터를 보냄
	그래서 여러 서버들이 동시에 통신을 진행할수있음
	
	라우터는 3계층에서 동작하고,ip주소로,
	원격지로 필요없는패킷이 전송되지않게 브로드캐스트하고 멀티캐스트를 컨트롤하고 이상한데로 통신시도하면 버림
	정확한방향으로 패킷전송되게 경로를 지정하고 최적의경로로 패킷을 포워딩함
	보통은 통신사같은데 있지만,l3스위치나 공유기같은데도 소형으로 들어있긴함
	
	로드밸런서는 4계층에서 동작함,얘는 4계층포트주소를 확인하는 동시에 ip주소를 변경할수있음
	즉,얘의 ip주소로 보내면,얘가 부하에 맞춰서 가장 적절한곳으로 분산을 시켜줌
	이걸위해서 ip변환,서비스헬스체크,대용량세션처리기능등이 있음
	
	보안장비로는 방화벽과 ips가 있음
	얘들도 4계층인데 패킷의 3,4계층정보를 확인하고 정책과 비교해서 버리거나 포워딩함
	
	공유기는 2층스위치,3층라우터,4층nat와 방화벽을 한곳에 모아둔장비임
	공유기는 스위치부분,무선부분,라우터부분으로 나뉨
	
	
	
	
	
3.네트워크 통신
1.유니,멀티,브로드,애니캐스트
	유니캐스트:출발지와 목적지가 1대1통신
	멀티캐스트:1대다 통신,하나의 출발지에서 다수의 목적지로 전송,인방같은거할때 이런느낌임
	브로드캐스트:1:모든포트,동일네트워크상의 모든호스트로 통신
	애니캐스트:1:1통신,같은그룹내에 가장 가까운 호스트에서 응답,dns등에서 사용
	
	유니캐스트는 말그대로 1대1로 제일많이쓰는거
	멀티캐스트는 그룹주소와 그 그룹내 여러호스트로 통신,iptv같은거에서 이걸사용함
	브로드캐스트는 자기가 통신할수있는 모든곳에 통신함,보통 유니캐스트를 하기 전 위치알아내려고 함,기본적으론 로컬내에서 모든호스트에 던짐
	애니캐스트는 주소가 같은 호스트중에서 가장 통신비용이 싼(가까운)곳에 통신함,보통 dns서버를 찾을때 사용하거나,가장가까운 게이트웨이찾을떄 씀
			유니캐스트와 다른점은,유니는 목적지가 한군데고,얘는 목적지후보가 여러개임
	
	여기서 주의할점은,데이터 전달출발지가 기준이 아니라,목적지주소를 기준으로 구분한다는것,출발지는 무조건 1개일수밖에없음
	
	
	트래픽종류를 다룰떄,bum트래픽이라는게 있는데
	이건 브로드캐스트,언노운 유니캐스트,멀티캐스트를 칭함
	이건 서로 다른 종류의 트래픽이지만 동작방식은 비슷함
	언노운 유니캐스트는 유니캐스트여서 목적지주소는 명확히 명시되어있지만,동작은 브로드캐스트일때를 가리킴
	얘는 목적지는 있지만,스위치가 목적지주소를 학습하지못해서(스위치입장에서 언노운)패킷을 모든포트로 전송하는데 이걸 언노운 유니캐스트라고함
	
	이게 중요한건,유니캐스트이지만 겉으로보이는건 브로드캐스트에 가깝기때문,물론 다른랜카드에선 받은걸 확인하고 버리지만,네트워크자원을 많이잡아먹음
	그래서 이더넷환경에서는 arp로 먼저 확인을하고 시작해서 크게 트래픽이 안생김
	
	
2.mac주소
	맥주소는 변경할수 없는(사실있지만)하드웨어 주소임
	맥주소의 앞3덩어리는 제조사코드,뒷3덩어리는장비코드임
	막 자기맘대로 바꿀수있어서,유일하진 않음
	
	랜카드는 자신의 맥주소를 가지고있고,전기신호가 들어오면 자기거인지 확인하고 아니면 버림
	이때,자기꺼거나,브로드캐스트,멀티캐스트같은 그룹주소면 일단 위로 올리고 보는데,
	그래서 브로드캐스트같은거의경우 네트워크가 전부 브로드캐스트로 가득차서 모든단말이 브로드캐스트를 처리하느라 cpu가 가득차는경우도있음
	그리고 보통은 랜카드가 자기꺼아니면 버리지만,패킷을 전부확인해야할떄(와이어샤크) 그런프로그램이 무차별모드를 키면,모든걸 메모리에 올려서 처리할수있게함
	
	
3.ip주소
	osi7계층에서 주소를 갖는건 2층과 3층임,맥과 ip두개
	대부분의 네트워크가 tcp/ip이므로 ip는 중요함
	
	ip는 4덩이로 나눠지고,각 덩어리는 8비트=1바이트로 구성됨
	그리고 네트워크주소와 호스트주소로 나눠지는데,기본적으론 abc클래스로 한덩어리씩 잘라서 썼지만,요즘은 서브넷팅으로 비트단위로 잘라서 네트워크주소로 사용함
	abc는 구분할떄,맨앞이 0이면 a 10이면 b 110이면 c 이렇게 구분하고,각각 한덩어리 두덩어리 세덩어리를 네트워크로 사용했음
	십진수로는 1~127이면 a 128~191이면 b 192~223이면 c였음
	근데 저러니까 애들이 다 a받아가고 안써서 ip가 심하게 낭비되니까 걍 비트단위로 잘라서 그렇게 알아서 부여하는식으로 서브넷팅함
	이런걸 클래스리스(클래스가없음)네트워크 라고 함
	
	클래스리스는 ip와 서브넷마스크 두개로 네트워크와 호스트를 구분함
	서브넷마스크가 네트쿼크가 차지하고있는 자리수를 보여주는거
	ip와 서브넷마스크를 and하면 호스트주소만 남는거임
	그리고 거기서 가장 작은 주소는(192.168.0.0)네트워크주소고,가장 큰주소는 브로드캐스트주소임
	
	사용자입장에서는,서브넷마스크로 내가 사용할수 있는 ip주소의 범위를 파악해야 함
	그래서 그거로 외부와 내부를 구분해야함
	기본적으로는,첫주소와 마지막주소를 알아내고(호스트주소를 전부0으로했을때와 전부1로했을때),그사이값이 내가 사용할수있는 ip임
	
	즉 서브넷이 가지고있는 비트수를 계산하고,만약 6개면(2^6=64)
	0~63,64~127,128~191,192~255중 어디에 속해있나를 확인하고 거기에 속해있으면 그 극단값이 네트워크 브로드캐스트값임
	7이면
	0~127,128~255하면됨
	
	설계자입장에선 서브넷팅을 얼마나 할것이냐(네트워크에 얼마나 기기가 들어올것이냐)를 고민해야함
	현재가진게 /24면(1이 24개,즉 c클래스)256개이므로 각 서브넷별로 기기가 12개쯤필요하면 16개쯤을 주면되니까,/28쯤 주면  16개임(16-2=14)
	그럼 네트워크단에서 1이 4개생기니까,네트워크 14개가 생김(단순나누기하면 15갠데,처음네트워크의 주소랑브로드캐스트를 빼서 1개가빠짐)
	
	그리고 네트워크를 설계할땐,가능하면 사설ip를 사용하는게 좋음
	사설ip는 내부적으로 따로 ip를 쓰고(192.168.0.1같은거),
	외부로 나갈땐 현재 접속해있는 기기만 따로 번호를 할당해서 통신하게해줌
	
	네트워크를 설계할떈,단계적으로 큰거자르고 거기서 또자르고 하는식으로 되는게 관리하기 편함
	그러면 라우터가 알아야하는 경로도 적어짐(즉,책임을 밑으로 분할하는게 편함 각기 하나씩 위에서 잘라주기보다)
	
	사설ip를 쓸때 공인ip로 변경해서 외부와 통신할수있는데,이때쓰는게 nat임
	이걸쓰면 ip두개를 매핑해서 외부에나갈땐 그걸로 덮어씌워서 나가고,들어올땐 다시 사설ip로 덮어씌움(공유기가 하는일)
	
	그래서 공유기가 맨날 192168쓰는거임
	
	여기서 중요한건,사설ip를 써도,외부에서 쓰는 영역을 쓰면,만약 그쪽으로 통신할때 사설인지 외부인지 헷갈려서 그쪽으로 접근을 못하게 될수있으니까
	원래 안쓰던 rfc에 명시된 ip대역을 써야함
	
	
4.tcp와 udp
	4계층에서 동작하는건 tcp/udp임
	얘는 패킷이 순서가 바뀌지않게하고,유실된패킷이 없게함(있으면 다시받음)
	
	4층에서 쓰는 헤더정보로는 시퀸스번호,ack번호가 있고,상위프로토콜지시자로는 포트번호가 있음,조립끝났으니 무슨포트로 넣어줄지 알아야하니까
	보통 유명한 포트로는 80(http),443(https)등이 있음
	얘가쓰는 프로토콜은 tcp/udp를 씀
	
	이때 tcp에서 쓰는게 seq,ack인데
	이거로 tcp는 유실없는통신을 보장함
	tcp는 분할된 패킷을 잘 분할하고,수신측이 잘 조합하도록 응답번호를 부여함
	패킷에 순서를 부여하는걸 시퀸스번호,응답번호를 부여하는걸 ack번호라고 함
	이 두개로 순서가 바뀌거나 패킷이 손실된걸 파악할수있음
	
	기본적으로 패킷을 하나 보내고,그럼 받는쪽에서 다음번호를 부르면서 이거달라고 하고를 끝까지 반복함
	근데 이렇게 하나하나보내면 엄청오래걸리니까,그냥 대량으로 한번에 보내고,
	받은만큼 번호받았다고 답변하면,그게 맞으면 다음거보내고 아니면 다시보내는식으로 함
	이때 보내는 사이즈를 윈도사이즈라고 하는데,이거만큼 보냄,그리고 이 윈도사이즈를 조절하는걸 슬라이딩윈도라고 함
	기본적인 최대값은 2^16인데,요즘은 너무작아서 그냥 애스크의숫자를 무시하는식으로 사용함
	이떄 만약 못받았으면,윈도사이즈를 반으로 줄이고,정상적으로 들어가면 1씩올리는식으로 사용함
	
	tcp에선 유실없는통신을 위해 통신시작전에 사전연결을 함,이걸 3방향 핸드셰이크라고 함
	클라이언트가 서버에 통신가능하냐고 물어보고,서버쪽에서 답변이오면 클라이언트 준비완료,거기서 다시 서버로 답변보내면 서버준비완료되고 서로통신함
	처음시작할땐 syn을 보내고,서버-클라처음시엔 ack랑syn을 같이 보냄,그리고 연결이끝나면 fin을 보냄
	이건 미리 정해진6비트를 어떤걸 키고끄는지로 구분함 키면 on 끄면 off
	
	udp는 이런게 다 없고,그냥 막 던짐
	어디로 가냐만 있고(포트번호)나머진 데이터밖에 없어서 그냥 되는데로 던짐,그래서 스트리밍같은데서 사용함
	얘는 처음에 연결시작을 첫데이터로 인터럽트를 걸고 유실시킨후에 그냥 막 던지는데,이렇게하지않고,
	연결확립은 tcp로 하고 데이터던지는거만 udp로 하는게 대부분임
	
	
	
	
5.arp
	실제 통신은 ip기반으로 일어나고,사실 mac은 ip주소를 알고 그거로 네트워크에 있는 정보로 알아내는데,이떄사용하는게 arp임
	ip는 논리적주소고,맥은 물리적주소인데 두개는 전혀 연관성이 없음
	
	만약 서버에 처음 연결을 시도하면,ip주소는 알고있지만 mac주소는 라우터거칠때마다 바뀌기때문에 알수없음,
	그래서 그쪽으로 가는걸 전체 네트워크에 브로드캐스트해서 그쪽가는 맥주소(라우터주소)가 뭔지를 질의해야함
	그쪽으로 가는 라우터는 그걸듣고 자기맥주소를 응답하면 거기로 적고 그 라우터로 보냄
	이걸 도착할때까지 반복함
	
	이때 arp가 저장되는테이블을 arp테이블이라고 함(매번 브로드캐스트하면 부하엄청심하니까 저장해두고함)
	이건 논리주소-물리주소 저장이라 논리주소는 자주바뀌니까,안쓰면(일정시간통신없으면)지워버림
	
	arp는 cpu작업이라서,이거로 해커들이 해킹 자주해서 네트워크회사들은 수동으로 업그레이드하거나 정적으로 테이블을 유지함
	그래서 네트워크장비가 바뀌면 이걸알려줘야함
	
	arp패킷은,송신자 맥,ip주소 대상자 맥,ip주소 이 4개가 제일 중요함
	만약 도착지mac주소를 ffffffffffff로 해두고 아이피는넣고,
	출발지맥은 자기자신으로 해두고 아이피는넣고 대상자맥은 000000000000넣고 브로드캐스트하면
	라우터로 가서(송신자),자기꺼넣고 다음으로 반복함
	즉 맥주소가 출발지,도착지,송신자 이 3개가 있는거임
	
	garp는 자신의 ip-mac을 알릴목적으로 사용함
	이건 ip충돌,상대방의(동일서브넷상의 다른)arp테이블 갱신,고가용성용도의 클러스터링
	에 사용됨
	
	ip는 일반적으로 유일해야하지만,여러이유로 충돌나는경우가 있는데,garp로 이걸 확인할수있음
	
	그거말곤 고가용성 솔루션에서,두개의 서버가 하나의 가상ip로 서비스하는데 두대의 db중 한대만 동작하고 한대는 대기하는데,
	이때 액티브상태인 서버가 가상ip로 응답해 처리하지만 맥주소는 진짜맥주소를 사용함
	이때 액티브가 바뀌어서 맥주소가 바뀌면,그래도 라우터는 전맥주소쪽으로 던지니까 이걸 바꾸기위해 garp로 바뀌었다는걸 알림
	
	또 클러스터링에서는,가상mac을 사용하는데 얘는 네트워크에 있는 스위치의 mac테이블 갱신이 목적임
	클러스터링에서 가상mac주소를 사용할땐 단말은 arp정보를 가상mac로 학습하므로 단말의 arp를 갱신할필요가 없음
	대신 중간의 스위치mac테이블은 마스터가 바뀌면 다르게찾아가야하니까 마스터가 바뀔때 mac테이블을 갱신해야함
	(즉 특정포트에 맥주소가 매핑되어있는데,그걸 바꿔서 찾아갈곳을 바꿔야함)
	클러스터에 문제가 생겨서 장애극복이 안될수도있지만,스위치가 이걸 제떄못바꿔서 이상한데다 계속통신을 할때도있음
	
	rarp는 리버스arp임
	얘는 맥주소를가지고 ip를 알아낼때사용함
	요즘은안씀
	
6.서브넷과 게이트웨이
	게이트웨이는 원격지장비와의 통신에 사용하는 장비를 게이트웨이라고 부르고,3계층장비(라우터와 l3스위치)가 이역할을 할수있음(공유기)
	로컬에서는 arp로 도착지를 학습할수있고,이거로 직접통신할수있지만 원격에서는 네트워크를넘어 브로드캐스트를 할수없어서 장비의 도움이 필요함
	이때 필요한 장비를 게이트웨이라고 함
	
	목적지가 로컬인지 외부인지 확인하는건 서브넷마스크로 하고,이거안이면 내부에서 브로드캐스트,외부면 게이트웨이로 던지는게 기본작동방식
	여기서 내부에서 도는건 레이어2통신,외부로도는건 레이어3통신이라고 함
	
	같은네트워크안이면 arp브로드캐스트를 직접던지고,알아내자마자 통신이 시작되고
	외부네트워크면 직접보낼수없다고 판단하고,게이트웨이의 ip주소로 요청함
	게이트웨이에서 응답받은 단말은 도착지맥에 기본게이트웨이맥주소를 넣고 통신을 함(게이트웨이가 대신통신)
	로컬에선 도착지맥과 도착지ip가 같지만,원격지는 도착지맥과 도착지ip가 다름
	도착지맥은 게이트웨이의 맥주소,ip는 실제도착지
	

	
4.2층-스위치
1.스위치 동작
	스위치는 네트워크중간에서 패킷을받아 필요한곳에 보내주는 네트워크의 중재자임
	스위치는 맥주소를 인식하고 패킷을 전달하는 스위치의 기본동작외에도,
	한대의장비에서 논리적으로 네트워크를 분리하는 vlan과,
	네트워크의 루프를 방지하는 스패닝트리프로토콜(stp)를 가지고있음
	
	스위치는 네트워크에서 통신중재하는장비인데,얘는 패킷경합을 없애고 서로 간섭없이 통신하게 도와줌
	이건 스위치가 맥주소를 이해하고,그 주소가 있는 포트로만 던져줘서 가능함(그리고 맥테이블도 있어서)
	
	이걸 수행하기위해,스위치는 맥주소와 포트가 매핑된 맥주소테이블이 필요함
	테이블에 없는 도착지주소를 가진 패킷이 들어오면 전체로 브로드캐스트하는데,이걸 플러딩이라고함
	
	이론적으론 스위치가 부팅하면 네트워크관련정보가 아예없음
	이떈 허브처럼 동작하면서 모든포트에 패킷을 흘림
	이떄 스위치가 맥테이블을 학습하는건 어드레스러닝이라고 하는데,이건 각 포트에서 나온 패킷에 적힌 출발지mac주소를 이용함
	일단 그쪽에서 던진거니까 확실히 그쪽에 그맥이 있다는거니까 출발지맥주소와 포트를 매핑해서 적어둠
	(물론 실제로는,연결시작하면 미리 광역으로 맥주소달라고해서 받아둬서 플러딩할일이없지만)
	
	스위치의 기본동작은,가야할포트에 던지고(포워딩) 다른덴 못가게 막음(필터링)
	스위치는 이 두작업이 여러포트에서 동시에 수행될수있음(다른포트에 영향을 안주니까 통신이)
	스위치는 일반적인 유니캐스트에 대해서만 포워딩필터링을 하고,bum트래픽은 그냥 플러딩해버림
	
	
2.VLAN
	VLAN은 랜을 논리적으로 분할해서 서로 다른네트워크처럼 만드는기술임
	이렇게하면 스위치단에선,유니캐스트나 브로드캐스트나 둘다 불가능하고 3계층통신으로 밖에나갔다와야 가능함
	
	보통 이건 포트기반vlan(특정포트는 1네트워크 얘는 2네트워크 이런식으로 나누는거)를 부르고,mac기반vlan도 있긴함
	
	vlan에서 각 포트에 각각 사용할 vlan을 설정하는데,같은스위치라도 다른vlan끼리는 통신할수 없음
	그리고 여러스위치간 같은네트워크로 연결하려면(1스위치에도 1네트워크 2스위치에도 1네트워크),
	기본적으론 각 네트워크당 하나의 포트로 서로 스위치끼리 연결되어야하는데
	이러면 포트낭비가 심해서 요즘은 한포트를 전송포트로 써서 스위치하나당 포트하나로 네트워크갯수상관없이 전부 보내버림
	이걸 태그포트,혹은 트렁크포트라고 부름
	
	이떈 이더넷프레임 중간에 vlan id를 끼워넣어 이정보를 이용함
	그리고 네트워크가 여러개면 태그포트,하나를 연결하는거면 언태그포트라고 부른대
	언태그로 값이 들어오면 같은vlan으로만 패킷을 전송하고,태그포트로 들어오면 태그를 벗기고 태그된 vlan으로 패킷을 전송함
	
	스위치간의 연결이 아닌,가상화서버(vm)과 연결되어도 언태그가 아닌 태그로 설정해야함
	
	
3.STP
	it환경에선 spof(단일장애점)으로 인한 장애를 피하기위해 노력함
	이건 한군데펑크나서 나머지 다죽어버리는(중간에 선잘린다거나)일을 말함
	
	네트워크를 스위치하나로 연결했을때 스위치가 뻗으면 다 뻗어버림
	그렇다고 두대이상으로 디자인하면,기본적으론 패킷이 무한루프돌아서 네트워크를 마비시킬수있음
	
	이거때문에 이걸해결하는게 stp임
	
	루프는 네트워크에 연결된게 서로 순환구조일때 발생하고,
	루프로 문제가 발생하면 대부분 브로드캐스트스톰임
	브로드캐스트스톰은 루프구조로 네트워크가 연결된상태에서,
	단말이 브로드캐스트를 발생시키면,이게 모든포트로 플러딩되고 이게 다른데를 거쳐서 다시 나한테 돌아오는 이걸 브로드캐스트스톰이라고 함
	3계층부턴 ttl이 있어서 몇번반복하면 날려버리면되지만,2층엔 그게없음
	브로드캐스트스톰이 발생하면 패킷하나가 모든대역폭을 사용하고(계속 증식하니까 전체네트워크로)네트워크가 멈춤
	
	이게 발생하면
		네트워크속도가 느려짐
		네트워크 접속단말 속도가 느려짐(브로드캐스트처리해야하니까)
		스위치의 모든 led가 빠른속도로 깜빡임
	이렇게됨
	
	루프구조상태에선 브로드캐스트뿐아니라 유니캐스트도 문제가 일어남
	같은 패킷이 루프를 돌아 도착지에서 중복수신될수도 있고,
	중간지맥에서 계속 포트가 갱신이되며 정상적으로 동작하지 않음,이걸 맥어드레스 플래핑이라고 함
	이러면 계속 특정 맥주소에 대한 포트번호가 바뀌면서 패킷을 플러딩함
	이걸 해결하기위해 맥주소는 특정주기로만 학습하게 하거나 그럼
	
	애초에 네트워크에 루프가 없으면되는데
	그럼 spof문제가 생기니까 그래서 쓰는게 스페닝 트리 프로토콜
	
	stp는 루프를 확인하고 적절히 포트를 사용못하게해서 루프를 예방함
	이걸쓰려면 전체 스위치가 어떻게 연결하는지 알아야함,즉 스위치끼리 정보전달방법이 필요함
	이걸위해 스위치는 bpdu라는 프로토콜로 정보전달을 함,이거로 루프가 생긴곳을 알아내서 거길 막아버림
	
	stp가 동작중인 스위치에선 루프를 막기위해 신규스위치가 연결되면 일단 트래픽을 막고 bpdu로 확인부터 함
	이게 한 50초걸림
	
	동작은
		blocking로
			패킷을 차단하고 상대방의 bpdu를 기다림
			못받거나 후순위bpdu를 받으면 다음단계로 넘어감
			2x10 20초
		listening
			해당포트가 전송상태로 변경되는걸 결정하고 준비함,이떄 기존bpdu를 상대방에게 전송
			15초
		learning
			해당포트를 포워딩하기로 이미 결정하고,패킷포워딩이 일어날때 바로동작하게 mac주소를 학습함
			15초
	
	총 50초쯤 걸림
	이건 스위치를 연결했을때만 아니라,뭘연결하든 일단 50초가 걸림
	
	stp는 루프를 없애려고,가장 높은 기기번호를 가지고있는애를 루트스위치라고 해서 걔기준으로 동작함
		처음엔 연결된 모든스위치가 자신을 루트라고 하고,그정보를 사방에 뿌림
		그리고 통신이 들어오면 자기기기번호랑 비교해서 상대가 더크면 상대를 루트라고하고 그걸 뿌려서 네트워크 전역에 도달하면 루트가 선정됨
		루트가 선정되면 루트로가는 경로가 가장 짧은포트를 루트포트로 정하고,이건 루트에서 bpdu를 받는 포트임
		그리고 연결된 스위치별로 각각 포트하나씩을 정해서 그걸 대체포트로 사용함
		이건 양쪽에서 한쪽은 뚫려있고 한쪽은 막혀있어서,문제가생기면 이걸 뚫어서 사용함
	
	이게 너무오래걸려서 tcp최대시간을 넘겨서 세션이 끊기니까 대안들이 나온게 rstp같은거임
	tcp세션연결이 30초니까 그안에 처리하는거
	얘는 3초면 끝나는데
	기본 stp가 메세지2개만 있었다면,얘는 8비트를 사용해 다양한정보를 주위스위치와 주고받음
	기존 stp가 밑에서부터 순서대로 올라왔으면,얘는 스위치 자신이 모든네트워크에 바로 알림
	즉 루트를 거치지않고 여러스위치가 연결되어있으면,브로드캐스트해버림
	
	또 다른건 mst가 있는데
	일반 스패닝트리프로토콜은 vlan갯수와 상관없이 스패닝트리 하나만 동작함
	이러면 관리부하가 적긴한데,루프가 생기는곳에서 한개의포트와 회선만 활성화되니까 효율적이지 않고,vlan마다 최적경로가 다를수있는데
	그걸 무시하니 멀리돌아가야할수도 있음
	
	그래서 생긴게 pvst인데 이건 vlan마다 다른 스패닝트리가 동작함,즉 각기 최적화된 경로와 트리를 만들수있음(vlan끼린 브로드캐스트안하니까)
	근데 이거자체가 부하가 심해서 나온게 mst임
	얘는 여러 vlan을 그룹으로 묶고,그룹별로 스패닝트리 하나씩을 부여하는거
	이러면 로드셰어링도 어느정도되고,스패닝트리도 갯수가 작아짐
	
	
	그리고 쓸데없는이야긴데,스위치도 ip가 부여되어있긴함,이건 관리목적으로 할당된거(스위치자체가 컴퓨터라고봐도되니까)
	
	


5.3계층 라우터
	라우터는 3계층에서 ip로,자기가 가진 라우팅테이블로 패킷을 포워딩하는 장치임
	라우터가 하는일은,경로지정,브로드캐스트컨트롤,프로토콜변환이 있음
	
1.라우터의 동작방식
	라우터에서 가장 중요한 역할은 경로지정임
	경로정보를 모아 라우팅테이블을 만들고,라우터로 들어오는 패킷의 도착지 ip를 확인해 빠른경로로 포워딩함
	이떄 ip주소는 네트워크주소와 호스트주소로 나뉜걸 구분할수있고,네트워크주소를 기반으로 경로를 찾아감
	
	라우터는 경로를 지정해서 패킷을 포워딩하는걸 두개로 구분함
	경로정보를 얻는것과,경로를 확인하고 패킷을 포워딩하는것
	라우터는 자신이 가지고있는 경로정보에 포함되는거만 포워딩하므로(없으면 기본적으론 버려짐)정확한경로를 얻는게 중요함
	
	라우터가 경로정보를 얻는건,관리자가 수동으로적는것,주변라우터로부터 경로정보를 받아오는것,패킷의 ip주소를 통해 정보를 얻는것 3개가 있음
	
	브로드캐스트컨트롤은,스위치는 브로드캐스트가 들어오면 전부 보내지만(플러딩포함),라우터는 대역폭으로 나가니까 절대 멀티캐스트나 브로드캐스트를 하지않음
	이걸 브로드캐스트 컨트롤이라고 함
	
	프로토콜 변환은 서로 다른 프로토콜로 구성된 네트워크를,얘가 통일된값으로 바꿔주는거임
	예전엔 랜이란 웬이랑 프로토콜이 달랐는데,그 2층헤더를 벗기고,얘가 2층헤더를 다시적어줬었음

2.경로지정-라우팅/스위칭
	경로지정은 경로정보얻기랑,그쪽으로 패킷보내기 2개로 나눠짐
	라우터는 기본적으론 자신이 적어둔주소에 없으면 패킷을 버리니까,경로정보를 충분히 알고있어야 라우터가 정상적으로 동작함
	근데 경로는 클래스리스의 도입이후 엄청나게 늘어났음(서브네팅)
	그래서 원하는 목적지와 정확히 일치하지않는경우가 더 많음
	
	라우터는 서브넷단위로 정보를 습득하고 정보를 최적화하기위해 서머리로 여러 서브넷을 묶어서 전달함
	그래서 라우터에 들어온 패킷목적지주소와 라우터가 갖고있는 라우팅테이블 정보가 정확히 일치하지않아도,가장 가까운거로 패킷을 포워딩함
	
	라우터는 경로로 바로 보내는게 아니라(다이렉트로 연결되어있으면 보내겠지만),홉바이홉으로,그쪽으로 가는 라우터로 보냄(택배랑 비슷함)
	인접한 라우터를 넥스트홉이라고 부름
	
	이떄 넥스트홉을 지정할땐,다음라우터의 ip를 지정하거나,라우터의 나가는 인터페이스를 지정,혹은 둘다 중에 선택할수있음
	일반적으론 ip를 지정함
	그래서 라우팅테이블을 만들땐,목적지정보만 수집하고 패킷이 들어오면 그것만 확인해서 넥스트홉으로 포워딩함
	라우팅테이블엔
		목적지주소
		넥스트홉ip주소
	만 적혀있음
	
	그리고 막 무한히 살아가는 패킷을 방지하기위해 패킷의 수명인 ttl이 있는데,이건 한번 홉을 뛸떄마다 1씩감소해서 0이되면 사라짐
	
	라우터가 경로를 얻는거는
		다이렉트 커넥트
		스태틱 라우팅(사람이적는거)
		다이나믹 라우팅(라우터가 주는거)
	가 있고,이순서대로 우선순위가 매겨짐
	위2개는 생각하는그대로고
	
	다이나믹 라우팅은,주변의 라우터로부터 걔의 라우팅테이블을 받아서,자신이 가지고있지않은 ip대역을 갱신하는거임
	그쪽으로부터 받으면 그쪽에다 던지면되니까
	이때 두군데이상에서 같은걸 받으면,둘을 비교해서 더 코스트가 낮은거로 적음
	이거로 라우터에 문제생겼을때 대응이 가능함(문제생기면 바로 주변에다가 라우팅테이블갱신해서)
	
	다이나믹 라우팅에선,자신이 광고할 네트워크를 선언해줘야함
	
	여기까지가 경로얻기고
	경로를 얻었으면 패킷을 적절한 경로로 보내는게 스위칭임
	이건 패킷을 라우팅테이블을 참고해서 그쪽경로로 포워딩해주는것
	이때도 중요한건,완전히 일치하지않는 ip를,조건에따라(롱기스트 프리픽스 매치) 가장 가까운경로로 매핑하는것
	이건,네트워크주소에서 현재패킷이랑 가장 앞에서부터 비슷한걸 찾아서 그거로 보냄(네트워크주소라서,만약 서브넷갯수가 다르면 우선순위가 떨어짐/24,/32)
	이건 부하가 심하기때문에,한번 계산한걸 캐시에 넣어서 거기서부터 찾고 없으면 계산하는식으로 처리함(보통 패킷하나요청들어오면 계속들어올거니까)
	
	라우팅테이블은 가장 좋은 경로만 모아둔 핵심정보임
	거기서 로우데이터를 모아둔 테이블이 토폴로지테이블인데,여기서 가장좋은걸 빼간게 라우팅테이블
	이 토폴로지테이블엔 그쪽으로 가는 코스트도 적혀있는데,이걸 네트워크 광고할때 사용함
	받는쪽에선 동시에 들어오면 이걸비교해서 더 작은쪽으로 선택함
	
	
3.라우팅 설정 방법
	다이렉트 커넥티드는,직접 연결된거,라우터에 pc ip,서브넷을 직접 입력한것,일단 여기가 최우선으로 들어감
	만약 목적지가 다이렉트면,라우터는 l2통신으로 던져버림
	목적지가 외부인데,다이렉트커넥트 라우팅테이블정보만 있으면,통신이 불가능함
	그리고 외부네트워크 정보가 있어도,다이렉트커넥트 정보를 잘못입력하면 외부와 통신할수없음(ip나 서브넷틀리면 당연히 pc에선 외부통신안됨)
	
	스태틱라우팅은 관리자가 수동으로 라우팅테이블 적어둔거
	이거로 경로관리를 할수있음
	얘는 목적지로 가려면 패킷을 이 넥스트 홉에 보낸다로
		ip route 목적지 서브넷 넥스트홉
	이렇게 적음
	
	기본적으로 소형라우터들은(작은회사들)빡빡하게 할필요없고 디폴트라우팅으로,받은걸 전부 인터넷사업자쪽으로 돌리면됨
		ip route 0.0.0.0 0.0.0.0 1.1.1.1(목적지,kt같은데 라우터)
	이렇게하면 모든 패킷을 목적지로 보냄
	서브넷마스크가 모두 0이니까,and하면 뭐든간에 연산결과가 0이므로 뭐든 목적지로 보냄
	이걸 디폴트 라우팅이라고 함
	
	간단한구조에선 스태틱라우팅으로 처리가 가능하지만,보통 it환경에선 spof때문에 2개이상경로를 유지하고싶어하는데,
	이떄 대체경로에 대한 고민이 필요함
	이런 대체경로가 필요한 네트워크를 스태틱만으로 구성하면,문제생기면 바로 뛰어나와서 수정해야하기때문
	그래서 다이나믹 라우팅을 쓰면,문제생기면 바로 주변에 알리고 다른길을 찾아서 그쪽으로 길을 뚫음
	
	다이나믹 라우팅에서 쓰는 프로토콜은
		내부에서 쓰는 igp
		외부끼리 통신하는 egp
	로 나눠짐
	egp는 알필요없을거같고
	igp는
		인접한 라우터에서 경로정보를 습득하는 디스턴스벡터
		라우터에 연결된 링크상태를 서로 교환하고 네트워크맵을 그리는 링크스테이트
	로 나눠짐
	
	디스턴스벡터는 다른 연결된애의 라우팅테이블을 받는거,이건 코스트가 낮긴한데(이미계산끝난거 받으니까)
	어디 문제생겼을때 처리가 느려짐(라우팅테이블은 간접적으로 2칸이상떨어진데를 받으니까 오는데 시간이오래걸림)
	
	링크 스테이트는 라우터에 연결된 링크상태를 교환함
	이건 로우데이터라 직접적인 상태정보를 받아볼수있음
	이걸로 가장 빠른 최단경로 트리를 만들수있는데,계산을 해야하니까 부하가 좀걸림
	
	그래서 네트워크를 지역단위로 분리하고,그내부에서만 링크정보를 교환함
	
	즉 내부에선 링크스테이트,외부로갈땐 국경지는 디스턴스벡터를 사용함
	


6.4층-로드밸런서/방화벽
1.4층장비의 특징
	4층장비는 tcp와 같은 4계층 헤더에 있는 정보를 이해하고,이걸 기반으로 동작함
	4층 프로토콜 동작에 대한 이해없이 4층장비를 운용하면 여러문제가 발생함
	여기서 제일 중요한게,세션테이블과 세션정보고,그래서 4층이상에서 동작하는 로드밸런서/방화벽같은걸 세션장비라고 부르기도함
	
	세션장비에서 고려해야할건
		세션테이블
			세션장비는 세션테이블기반으로 운영됨
			세션정보를 저장,확인하는 전반에대한 이해가 필요함
			세션정보는 세션테이블에 남아있는 라이프타임이 존재함
		시메틱(대칭)경로 요구
			인바운드와 아웃바운드 경로가 일치해야함(1번통로로 나가고 2번통로로 들어올수없음)
		정보변경(로드밸런서)
			ip주소가 변경되며,l7로드밸런서는 애플리케이션 프로토콜 정보도 변경시킴

2.로드밸런서
	로드밸런서는 리버스프록시로 얘에 통신을 걸면,자기뒤에 있는 서비스중 부하가 제일적거나 적합한곳으로 연결시켜주는 장비임
	즉 트래픽을 분산시켜줌
	
	로드밸런서는 l4와 l7로 나뉨
	l4는
		일반적인 로드밸런서
		tcp/udp정보(특히 포트넘버)를 기반으로 로드밸런싱을 수행함
		보통 요즘은 l4,l7기능을 모두다 지원함
	l7은
		http,ftp등 애플리케이션 프로토콜을 기반으로 로드밸런싱을 함
		http헤더정보나 url같은 정보를 기반으로 프로토콜을 이해하고 부하를 분산할수있음,이런걸 adc라고 부르며,프록시역할을 수행함
		리버스프록시와 유사
	
	l4스위치는 용어그대로 4층에서 동작하면서 로드밸런서기능이 있는 스위치임
	내부동작방식은 4층로드밸런서지만,외형은 스위치처럼 여러포트가 있음
	얘는 부하분산,성능최적화,리다이렉션기능을 제공함
	
	얘가 동작하려면 가상서버,가상ip,리얼서버,리얼ip를 설정해야함
	가상서버는 사용자가 바라보는서비스,가상ip는 사용자가 접근하는ip(로드밸런서 서비스의 주소)
	리얼서버는 실제 동작하는서버,리얼ip는 실제 서버의 ip
	여기서 l4스위치는 가성ip를 실제ip로 바꿔주는 역할을 함
	여기서 부하를 어떻게 분산할지 결정할수있음
	
	adc는 애플리케이션계층에서 동작하는 로드밸런서임
	l4스위치와 달리,앱프로토콜 헤더를 이해하므로,다양한 부하분산,정보수정,정보필터링이 가능함
	그래서 얘는 상세한동작을 위해 프록시로 동작함
	
	대부분의 adc는 l4스위치의 기능을 포함하고 있음
	얘들은 4층에서 앱계층까지 로드밸런싱기능을 제공하고,페일오버(장애극복),리다이렉션기능도 같이 수행함
	이외에도 캐싱,압축,인코딩변환등이 가능하고,앱프로토콜 최적화기능도 제공함
	
	플러그인형태로 보안강화기능을 추가로 제공해,waf기능이라 html,xml검증과 변환을 수행할수 있음
	
	l4스위치는 4층에서 동작하고 tcp/udp를 기반으로 부하를 분산하고,tcp계층에서의 최적화와 보안기능도 함께 제공함
	이레벨의 간단한 dos공격을 막거나,서버부하를 줄이기위해 tcp세션 재사용같이 보안,성능을 높여주는기능도 함께 제공함
	
	adc는 앱프로토콜을 이해하고 앱내용에 대한 분산,리다이렉션,최적화를 제공해 l4스위치보다 더 다양한 기능을 사용할수있음
	adc는 최적화를위해 서버에서 수행하는것중 부하가 많이걸리는작업을 별도로 수행함,그중하나가 이미지나 정적콘텐츠 캐싱임
	웹서버에는 콘텐츠압축기능이 있지만,adc에서 이걸 수행해서 서버부하를 줄임
	그리고 ssl프로토콜을 얘가 대신수행해서,얘만 ssl로 통신하게하면 서버마다 일일히 안해도되게 할수있음
	
	
3.방화벽
	방화벽은 네트워크중간에서 해당장비를 통과하는 트래픽을 정책에 맞춰 허용하거나 차단하는 장비임
	일반적으로 3,4층에서 동작하고,세션을 인지,관리하는 spi엔진을 기반으로 동작하는걸 방화벽이라고 부름
	
	얘는 nat동작방식과 유사하게,세션정보를 저장하고,패킷이 외부로 나갈때 정보를 저장하고,
	패킷이 들어오거나 나갈때 저장했던 세션정보를 먼저 참조해,패킷이 외부에서 시작됐는지,내부의 요청에 응답한거인지를 가려내고
	외부에서 시작된거면 차단함
	
4.4층장비 통과시 유의점
	세션은 일반적인 2,3층 장비들과 달리,세션을 이해하고 세션테이블을 유지함
	세션테이블정보를 이용해 패킷을 변경하거나,앱성능을 최적화하고 보안을 강화하기위해,패킷을 포워드하거나 드롭할수있음
	
	이런 기능을 활용하려면,앱과 세션장비간 세션정보를 동일하게 유지해주거나,
	앱을 제작할때 네트워크 중간에 있는 장비를 고려해 기능을 추가해주어야 함
	특히 앱세션시간과 서비스 방향성을 고려하고,비대칭경로가 나오면안됨
	보통 문제생기면 여기서생김
	
	종단장비에서 통신을 시작하면,중간에있는 세션장비는 해당세션을 테이블에 기록함
	통신이 없어도 통신이 정상적으로 종료되지않으면,일정기간 유지함
	하지만 이건 메모리에 저장되므로,일정시간지나면 삭제됨
	그리고 과도한세션을 발생시켜 세션테이블생성을 방해하는 세션공격도 있음
	
	하지만 일부앱은 세션을 한번 연결해놓고,다음통신이 시도될때까지 세션이 끊기지않도록 세션타임아웃값을 길게 설정하기도 함
	이러면 얘들은 통신할때,세션테이블에서 사라졌는데 세션통신을 하려고해서 통신에 문제가 생김
	세션장비의 세션테이블에 세션이 없는데 syn이 아닌 ack를 보내니까 뭐지하고 드롭해버림
	
	순서는
		3방향핸드셰이크로 세션설정
		세션테이블을 참조해 방화벽 패킷통과
		일정시간 통신없음
		세션타임아웃으로 세션테이블 만료
		세션만료후 앱통신시작
		세션만료되어 방화벽에서 패킷 드롭
	이렇게 됨
	
	이건 세션장비와,앱에서 각각 설정으로 해결할수있음
	
	세션장비입장에선,세션만료시간을 늘리면 됨
	이경우엔 앱의 세션유지시간보다 방화벽 세션유지시간이 길어야함
	보통 세션장비는 포트번호나 ip주소마다 별도의 세션만료시간을 설정할수있어,
	전체 세션 유지시간이 길어져서 시스템메모리가 고갈되는걸 예방할수있음
	하지만 그러려면 앱개발자가 미리 이걸 말해주고,따로 적용시켜야함
	
	또는 세션시간을 그대로 둔채로 ack를 받을수도 있긴한데,비추천함,전체적인 보안이떨어짐
	
	또는 세션장비에서 타임아웃시 양쪽에 세션종료를 통보하는것
	
	개발자입장에선,앱에서 주기적으로 패킷을 날리면됨
	그러면 계속 세션시간이 갱신이됨,보통은 이렇게 해결함
	
	
	네트워크의 안정성을 높이기위해,회선과 장비를 이중화하면 spof는 해결되지만,
	인바운드와 아웃바운드의 경로가 같을수도,다를수도 있어짐
	이러면 다른경로로 들어오니까,방화벽에선 처음보는거라 생각하고 드롭해버림
	
	해결방법은,두개가 있는데
	세션테이블을 동기화하거나,일단 드롭하지않고,자신이아닌 다른방화벽으로 던져버리고,거기서도 아니면 드롭함
	
	동기화는 문제가 두 경로상의 두 장비의 세션을 동기화하는시간보다 패킷응답이 빠르면,정상적으로 동작하지않을수있음
	그래서 보통은 이걸 안씀
	두번째는 자신이 모르던게 들어오면 일단 다른애한테 던지는건,이걸위해 방화벽끼리 통신링크가 필요하고,mac주소를 변경하는 mac리라이팅이나
	기존패킷에 mac주소를 한번 더 인캡슐레이션하는 터널링으로 경로를 보정함
	
	그리고 하나의 통신에 두개이상의 세션이 사용될때(대표적으로 ftp)
	하나의 세션만 끊겨도 양쪽가 문제가생김
	
	ftp는 두가지 통신모드를 가지고있는데
	액티브와 패시브임
	
	액티브는 클라이언트가 서버로 요청을 보내면,서버가 클라이언트에 접속해서 거기로 데이터를 넣음
	이러면 요청이랑 데이터 방향도 반대고(컨트롤은 클라->서버 데이터프로토콜은 서버->클라) 데이터와 컨트롤이 분리되어있음
	그래서 발전한게 패시브임
	얘도 컨트롤과 데이터가 분리된건 같지만 클라이언트에서 서버쪽으로 요청해서 받음
	이경우엔 클라이언트에 방화벽이나 세션장비가 있어도 상관없지만(클라이언트에서 먼저 요청을했으니까)
	서버쪽에서 방화벽이 있으면 그 포트를 열어줘야함
	
	
7.통신네트워크 주요기술
1.nat/pat
	넷은 공유기에서 사설ip를 공인ip로 바꾸는 그런일을 할때 사용하는 기술임
	즉 네트워크 주소를 변환하는 기술
	이건 1대1이 기본이지만 여러아이피를 하나의 ip로 바꿀수도있음(대표ip),이걸 pat라고 함
	
	이걸 사용하면 여러장점이 있는데,ip주소를 아낄수있고,내부ip를 외부에 공개하지않을수 있음
	그리고 사설ip를 쓰는 여러 장비에서 서로 통신할수있고,
	외부에서 시작한 통신을 막을수도있음
	
	물론 유일한ip라는 장점이 사라지긴하지만,과도기적형태로(ipv6)현재는 사용하고있음
	
	
	넷은 게이트웨이에서 왔다갔다하는 패킷의 목적지,출발지가 넷테이블에 있으면 그걸 치환하는형태로 사용됨
	팻은 넷과 똑같은데,이건 패킷의 ip뿐만 아니라,포트까지 치환할수있음
	이때 팻은 구분하는게 포트뿐이라서,포트가 꽉차면 정상적으로 동작하지않음,그래서 공인ip주소를 주소하나가 아닌 풀형태로 구성해야함
	팻은 patip가 목적지일떈 어떤ip에 바인딩되는지 알수없어서 사용할수없음,즉 내부에서 외부로 나가고,거기에 따른 응답만 받을수있음(외부에서 시작하는건 못받음)
	
	
	nat은 출발지 주소를 바꾸는 snat와 목적지 주소를 바꾸는 dnat가 있음
	이건 트래픽이 출발하는 시작점을 기준으로 구분함,즉 트래픽 시작지점만 고려해서 snat설정을 하면됨,
	기본적으로 안에서 출발하면 nat테이블이 있어서 역nat를 할수있기때문
	
	snat는 사설에서 공인으로 통신할때 많이 사용함
	내부가 시작점이니까,사설에서 공인으로 바꾸는거임(공유기)
	이거말고는 보안상으로 snat가 필요할때,내부ip주소를 감추고싶을때 사용함
	
	dnat는 로드밸런서에서 많이 사용함
	사용자가 요청을하면,조건에따라 자기에 연결된 서비스의 ip로 dnat해서 보내는거
	그거말곤 사내가 아닌 대외망네트워크 구성에도 사용함
	대외망에선 ip주소가 사설ip일수있기때문에,그걸 라우팅해서 바꿔줘야함,이경우 대외망에 nat장비를 이용해서 특정ip대역으로 nat함
	
	
	출발지와 목적지의 ip가 미리 정해진걸 정적 nat,
	둘중 하나이상이 정해지지않은걸 동적nat이라고함
	
	동적넷은 출발지와 목적지가 모두 정의된게 아니라 일정 ip풀에서 정해지므로,최소한 출발지나 목적지중 하나가 ip풀이나 레인지로 되어있음
	nat를 하는 시점에 nat테이블을 만들어 관리하고,이건 일정시간지나고 통신없으면 사라짐(공유기에서 하는거)
	
	정적넷은 그냥 출발지목적지를 매핑시켜둔거,당연히 타임아웃이 없음


2.dns
	dns는 문자열을 ip주소로 바꾸는것
	dns는 뒤에서부터 앞으로 밀어내면서 찾음,맨뒤가 루트고(보통생략됨) 그뒤가 .com같은거,그뒤가 이름 그뒤가 www
	
	도메인을 ip주소로 바꾸려면,dns서버에 도메인쿼리하는 과정을 거쳐야함,dns서버없이 할수도있긴한데(hosts파일을 사용)테스트용 말곤 쓰기힘듬
	
	dns서버에 쿼리하면,dns서버는 자기캐시안에 쿼리가 있나 확인하고 없으면 다른dns서버에 걔가 쿼리해서,재귀적으로 동작함
	클라이언트에선 자기가 지정한 dns서버가 응답이 없으면 반복적으로 쿼리함(같은데 여러번날려보고 다른데날리고)
	
	dns서버는 마스터서버와 슬레이브서버로 나누어짐
	둘중 우선순위가 나누어지는건 아니고 두 서버 모두 도메인쿼리에 응답함
	둘의 차이는 도메인에 대한 존파일을 직접 관리하는지 아닌지로 나눠짐
	마스터가 존파일을 직접 관리하면 슬레이브는 그걸 복사해서 사용함,이걸 영역전송이라고 함
	
	슬레이브는 정기적으로 마스터서버 도메인을 복제하는데,그러기위해서 마스터서버정보를 입력해야하고,
	마스터는 자신이 가진 도메인정보를 정해둔 슬레이브에서만 가져가도록,슬레이브를 지정해야함
	지정하지않으면 무제한복제가능이돼서 보안상문제가됨
	
	이 마스터-슬레이브는 이중화에서 일반적으로 쓰는,액티브-액티브나 액티브-스탠바이형태로 구성되지않음(마스터에 대한 의존성때문)
	그래서 마스터가 터지고나서,슬레이브의 존파일 유효기간동안만 정상동작하고,그뒤론 같이터지니 그안에 dns서버를 고쳐야함
	
	
	dns의 주요 레코드는
		A:도메인과 ipv4
		AAAA:도메인과 ipv6
		CNAME:도메인의 별칭
		SOA:이데이터의 관리권한
		NS:이 영역의 네임서버
	가 있음
	A는 도메인과 IP를 매핑한거고
	
	CNAME은 NAVER.COM을 NA.COM으로 들어갈수있게 해주는거(별명을 특정 도메인으로 넘김)
	이건 재귀적으로 동작함,CNAME-A-IP순
	
	SOA는 도메인영역의 권한을 나타냄,이 영역에 있는건 다른데다 쿼리하지않고 직접 응답함,이건 필수항목이라서 반드시 만들어야함
	
	NS는 도메인에 대한 권한이 있는 네임서버정보를 설정함
	NS레코드의 경우,권한이있는 정보를 해당 도메인에 설정하는 역할말고도 하위도메인에 대한 권한을 다른네임서버로 위임할때 많이사용함
	
	
	
	
	도메인 위임은 DNS서버에서 그거에 특화된 DNS서버를 정해두고,그쪽쿼리가 들어오면 그쪽으로 던지고 리턴을 받음
	이걸 사용해서 특정 영역별로 DNS서버를 분리할수있음
	
	도메인엔 TTL값이 있어서,거기있는시간동안만 로컬에 저장함
	이걸 크게잡으면 부하가 줄지만,값이 변경되었을때의 로스시간이 길어지고
	짧게잡으면 부하가 커짐
	
	그래서 서비스변경이있을땐 짧게잡고,보통땐 길게잡으면됨
	
	화이트도메인은 대량발송이메일이 스팸으로 처리되는걸 막기위해 kisa에 등록하는거임
	필요해지면보면됨




3.gslb
	gslb는 도메인을 통한 로드밸런싱 구현을 도와줌
	dns로 기본으로 그냥 같은도메인에 ip두개박으면 두개중 랜덤으로 던지는데,
	이경우엔 로드밸런싱은 되지만 한쪽서버가 터지면 패킷의 절반이 날아감
	이경우엔 헬스체크를 하면 되는데,이걸해주는게 gslb임
	
	얘는 dns로부터 로드밸런싱한거의 도메인을 위임받아서,
	그도메인전부에 헬스체크를 한다음에 자기의 알고리즘으로 선택해서 보냄

	gslb를 사용한 도메인설정엔 두방법이 있는데
	도메인자체를 gslb로사용하거나
	도메인내의 특정레코드만 gslb로 사용할수있음
	
	도메인자체를 gslb로 사용할땐,불필요한애들까지 전부 헬스체크를 해서 부하가걸림
	그래서 특정 레코드만 떼서 gslb로 넘겨주는걸 잘 사용함
	이경우엔 cname을 사용해서 넘겨주거나,위임을 해버림
	이때 gslb는 외부사업자의걸 사용하거나,자기가 엄청크면 자기가 사서쓰면됨
	
	gslb를 사용하면 사용자트래픽을 분산하고,지역적으로 가까운곳에 연결시켜주는등의 일을 할수있음
	
	
4.dhcp
	dhcp는 사용자가 따로 설정을 안하고 네트워크에 들어가면,네트워크가 알아서 설정정보를 주는거,즉 동적할당임
	
	dhcp는 사용자가 네트워크에 들어가서 discover메세지를 브로드캐스팅하면(dhcp discover),
	서버는 그걸받고 걔한테 ip주소,서브넷,게이트웨이,dns정보,leasetime(임대시간)을 포함한 dhcp메세지를 전송함(dhcp offer)
	그럼 클라이언트는 받은ip와 서버정보를 포함한 요청메세지를 브로드캐스팅함(dhcp request)
	클라이언트로 부터 ip주소를 사용하겠다는 요청을 받으면,해당 ip가 어떤 클라이언트를 언제부터 사용했는지 정보를 기록하고 정상수신응답을 전송함(ack)
	
	처음에 자기ip를 모를땐 출발지ip를 0.0.0.0으로 표시하고,목적지는 브로드캐스트(255.255.255.255,68포트)로 보냄
	이떄 udp인 68을 사용하는건,자기ip를 몰라서 tpc핸드세이크를 할수없기때문
	
	그리고 임대시간이 다 지나면 기본적으론 ip를 뺏기는데,
	이때 임대시간의 50%가 지나면,유니캐스트로 클라이언트가 연장요청을하면,서버가 응답을하는식으로 연장을 할수있음(ip가있으니까 서로만통신하면됨)
	만약 이떄 갱신에 실패하면,75%일때 한번더 연장시도를하고,이떄도 실패하면 짤없이 뺐기고 처음부터 다시리스해야함
	
	이거도 풀이 있으니까,좀 오래남아있는데면 리스기간을 길게잡고,공용공유기같은거면 짧게짧게잡아서 빨리쳐내서 회전율올려야함
	
	
	dhcp를 계속 할당받아서 풀을 바닥내는 공격도 있음
	
	그리고 만약 서버가 여러개면(여러스위치와 라우터조합)브로트캐스트를 해봐야 스위치 안에서만 도는데,
	이럴땐 dhcp 릴레이 에이전트를 사용하면 dhcp서버한대로 여러 네트워크의 ip풀을 관리할수있음
	dhcp 릴레이 에이전트가, 클라이언트와 서버가 다른대역에 있어도 패킷을 중계해주기때문
	얘는 브로드캐스트로 전달되는 dhcp패킷을 유니캐스트로 출발지나 도착지에 꽂아줘서 가능
	(브로드캐스트하면 유니캐스트로 전달하고,이걸 다시 브로드캐스트로 클라에 뿌리는식)
	
	이떈 보통 라우터(에이전트기능포함)와 dhcp서버를 연결하고,라우터와 스위치들을 연결하는식으로 동작함
	이때,스위치와 라우터가 l2에서 같이있어야하고,dhcp서버의 ip를 알고있어야함 에이전트가
	
	
	

8.서버네트워크기본
1.윈도우,리눅스 네트워크설정
	필요하면보자
	리눅스에서 설정값 바꾼거 즉시적용하려면 
		systemctl restart network.service
	이건 네트워크서비스 전체재시작
		ifdown ifcfg-eth0
		ifup ifcfg-eth0
	이건 특정인터페이스 재시작
2.서버의 라우팅테이블
	서버에서도 외부네트워크와 통신하기위해 라우팅테이블을 가지고있음
	이때 별도로 설정하지않으면 디폴트라우팅을 잡게되는데,만약 네트워크어댑터를 두개이상 사용할떈 여러 고려사항이 생김
	만약 1번으로 들어오고 3번으로 나갈경우,통신이 안됨(내가 시작하지않은통신 들어오니까)
	
	
	서버의 라우팅테이블은
		   목적지   서브넷 게이트웨이   인터페이스  우선순위
		0.0.0.10  24  0.0.0.1    eth1    10
	이런식으로 구성됨
	목적지네트워크와 서브넷을보고,넥스트홉을 정하고 그쪽으로 던짐(우선순위에 따라),인터페이스는 네트워크카드를 말하고,어떤 물리적경로로 패킷을 던질지설정함
	
	리눅스에선 ip route로 볼수있음
	거기 안나오는건 netstat로 볼수있음
	
	리눅스에서 라우팅테이블을 추가할땐
		route add (-host나 -net) 목적지ip (gw(ip)나 dev(네트워크카드)) gw->넥스트홉ip dev->네트워크카드이름 gw시 metric 숫자(메트릭값설정)
	으로 추가하면됨
	호스트는 특정ip고,넷은 ip대역임(10.10.10.0/24 이런거)
	라우팅테이블을 삭제할땐
		route del (-host나 -net) 목적지ip (gw(ip)나 dev(네트워크카드)) gw->넥스트홉ip dev->네트워크카드이름 gw시 metric 숫자(메트릭값설정)
	이렇게 똑같이써서 삭제하면됨
	
	근데 이렇게 추가한 라우팅정보는,서버가 재부팅하면 사라짐
	영구적으로 남기고싶으면  각 os별로 다른식으로
		centos
			(/etc/sysconfig/network-scripts/route-장치명 에 어드레스,넷마스크,게이트웨이 추가)
		우분투
			up route add 호스트넷 목적지ip...똑같이 쓰면됨
	하면됨
	이렇게하면 서버를 재부팅하거나,네트워크서비스를 다시 시작하면 적용됨
	
	
	윈도우에선
		route print  조회
		route add    추가 
		route delete 삭제 
		route change 변경
	으로 할수있음
	이때 조회할때
		route print 10.10.10.1
	이런식으로 조건걸수있고
		route print 10.10.*
		route print 10.10.??.1
	이런식으로 와일드카드랑 특정문자대체도 가능함
	추가할땐
		route add      목적지   mask     서브넷마스크    게이트웨이
		route add 192.168.1.0 mask  255.255.255.0 10.0.0.1
	이렇게 하면됨
	삭제도 똑같음
		route delete 192.168.1.0 mask  255.255.255.0 10.0.0.1
	변경도 똑같이,추가하는거처럼 전부 나열하면 apply됨
	

3.네트워크 확인을 위한 명령어
	ping:핑임
	tcping:ping을 막아둔곳도 확인할수있는 핑임(서비스포트가 열려있는지 확인할수있음,기본명령은아니라서 깔아야함)
	traceroute(리눅스)/tracert(윈도우):출발지부터 목적지까지 라우트경로를 보여줌,만약 차단한라우터가있으면,***만료로 뜸
								  그리고 양쪽에서 비대칭경로가 있을경우,출발지목적지 둘다에서 해야 정확히나옴(루트가 2개이상일경우나 보안장비등)
	
	tcptraceroute:이건 포트확인가능한 traceroute,tcping같은거임,윈도우리눅스 둘다있음
	netstat:네트워크상태 확인,보통 서비스포트확인할떄 가장 많이 사용함
			보통 쭈루룩나오니까 grep으로 필터링해서 찾음
	ss:소켓정보를 확인함
	nslookup:dns서버에 도메인을 질의해서 리턴을 받아오는거
	telnet:ssh처럼 그ip에 접근하는 초고대프로토콜,요즘은 ssh로 대체함(평문전달이라서 안씀)
	ipconfig:네트워크 설정을 확인하는 명령,ip와 서브넷같은 기본적인거 표시됨
	tcpdump:패킷을 캡쳐하는명령어,와이어샤크같은거라고 보면됨,이렇게 덤프한걸 와이어샤크에서 열어볼수도있음
	
	



9.보안
1.보안의 개념과 정의
	보안은
		기밀성
		무결성
		가용성
	을 지켜야함
	
	기밀성은 인가되지않은 사용자가 정보에 접근하지못하게하는것
	무결성은 정보가 변경되었을때 그걸 파악해서 전달되지않게하는것,즉 정보변경시 알아채는것(해시)
	가용성은 정보가 필요할때 접근을 허락하는 작업
	
	요즘 공격은 네트워크 자체를 공격대상으로 삼는경우가 많음,물론 id패스워드노리는거도 당연히 남아있지만
	
	네트워크 보안의 목표는,외부네트워크로부터 내부네트워크를 보호하는것
	이때 보호받아야할 네트워크를 트러스트 네트워크,신뢰할수없는 외부네트워크를 언트러스트네트워크라고 부르고,
	내부지만 외부에 공개해야하는 네트워크를 dmz네트워크라고 부름
	
	이때 보안을 분류하면
		인터넷시큐어 게이트웨이:트러스트나 dmz에서 언트러스트로 통신을 통제
		데이터센터 시큐어 게이트웨이:언트러스트에서 트러스트나 dmz로의 통신을 통제
	임,즉 어디서 시작했냐기준
	
	보통 인터넷시큐어의경우엔,좀 낮게잡고 인터넷관련정보를(통신에필요한) 많이넣음
	데이터센터의경우엔 외부의 직접적인 공격을 막아야하니까,통신관련보다 공격관련 정보를 더 많이넣고,중요하게생각함
	
	인터넷 시큐어의경우 방화벽,swg,웹필터,앱컨트롤,샌드박스등이 포함되고
	데이터센터의경우 방화벽,ips,dcsg,waf,anti-ddos등이 포함됨
	
	네트워크 보안정책에 따라,두개로 나눌수있는데,화이트리스트와 블랙리스트임
	화이트리스트는 방어에 문제없는거만 허용하는거임
	이건 b2c에선 사용불가능하고,b2b같이 서로 확신이 있는상대끼리 통신할때나,회사내부에서 사용할수있음
	블랙리스트는 공격이라고 판단되거나,문제있던 ip리스트나 패킷리스트를 공유해서 db를 만들고,거기를 기반으로 차단하는형태
	각종 패턴으로 공격을 방어하는 네트워크장비들은 블랙리스트 기반으로 제공함
	이때 사용되는 데이터베이스를 시그니쳐(공격패턴)이라고 함
	
	보통은 화이트리스트 블랙리스트 둘다 사용할수있는데(보안장비에서),둘중 하나만 목표로 만들때도 있음
	ips나 안티바이러스같은건 시그니처를 만들고 이걸 업데이트받아 동작하니까 블랙리스트 기반장비임
	
	그냥 다막아두고 한두개만 열어두면 화이트리스트,해킹시도했던 ip기반차단은 블랙리스트임
	
	요즘은 화이트리스트기반이 많이 사용되는추세긴한데,이건 통신정보를 상세히 알아야하고 세부통제가 필요해서 인력이 많이필요함
	블랙리스트는 그냥열어두고 차단이라서 쉬움
	
	보안쪽에서도 컨퓨전매트릭스(혼동행렬)을 사용하는데
	tp나 fn은 정상이니까 상관없고
	tn이나 fp중에서 뭘 우선시할지 정해야함,물론 둘다 줄이긴 해야겠지만
	fp(오탐)의경우엔 이경우를 예외처리하는 튜닝이 필요하고
	tn의경우엔,너무 과도하게 예외처리됐거나 업데이트되지않았나 확인,제로데이일때도 날수있음
	
	
2.보안솔루션의 종류
	보통 보안장비는 병렬적으로 패킷이 오는길에 디펜스하듯이 배치하고,거기서 하나하나 걸러내는식임
	보통 ddos-방화벽-ips-웹방화벽 순으로 배치함
	
	ddos는 부하거는거기때문에 제일 앞에 배치해야함
	ddos의 경우엔 데이터센터 외부와 내부의 경계에서 공격을 방어하는데,이건 볼류메트릭공격을 우선 막기위해서
	볼류메트릭의 경우는 회선사용량을 먹는애라서 회선공급해주는 isp나 네트워크isp와 연결되는 가장 바깥에 둬서 이걸 완화해야함
	
	방화벽은 4층기반 패킷필터링임
	3,4층 정보(ip와 tcp,udp)를 기반으로정책을 세우고,해당 정책과 맞지않는 패킷을 드롭해버림
	이건 보통 ddos바로 안에 놓는데,그렇게 코스트도 안먹고 성능도 우수해서 싸고 좋게처리가능
	
	
	ips는 침입을 탐지하고,방지하는 장비임
	얘는 db(시그니쳐)를 받아서 거기에 들어있는 패킷일경우에 차단하고 모니터링프로그램에 공격시도를 알림
	원래는 블랙리스트기반만 제공했지만,요즘은 앱컨트롤기능이 추가되어서 화이트리스트기반도 적용할수있게되었음
	
	
	waf는 웹서버를 보호하는 전용방화벽으로,http나 https처럼 웹서버에서 동작하는 웹프로토콜의 공격을 방어함
	얘는 ips보다 범용성이 떨어지지만,웹프로토콜에 대해선 더 세밀히 방어할수 있음
	
	얘는 여러형태가 있는데,전용네트워크장비,웹서버의 플러그인,adc플러그인,프록시장비 플러그인 등으로 있음
	아예 장비도있고,소프트웨어로도 제공됨
	
	waf는 ips에서 방어할수없는 ips회피공격을 방어할수있음
	ips를 회피하기위해 데이터를 쪼개서 패킷여러개로 보내는식으로(a,t,t,a,c,k)보내면 이건 ips가 막을수없는데,
	waf는 데이터를 조합해서 처리하기때문에 이런걸 막을수있음
	
	샌드박스는 그냥 가상머신임,관리자를 노려서 바이러스를 심는공격에 샌드박스에서 파일을 실행시켜서 막을수있다는소리
	
	nac는 네트워크에 접속하는 장치를 제어하기위해 개발됨
	네트워크에 접속할때 인가된 사용자만 내부망에 접속할수있고,인가받기 전이나 승인에 실패한 사용자는 접속할수없게 제어됨(쿠버네티스 rbac)
	
	ip제어솔루션은 nac랑 비슷한데,국내에서 잘쓰임,보안사고 추적이 쉡게 고정ip사용권고가 내려와서 고정ip를 할당하는 솔루션이 필요해졌고,
	이 ip가 아니면 거르게하는게 필요해져서 나옴
	
	접근통제는 일단 서버접근을 완전히 막고,배스천호스트를 둬서,걔만 서버와 통신할수있게 하는것
	그래서 배스천호스트의 보안,감사를 올리면 보안을 강화할수있음
	요즘의 접근통제솔루션등은 단순접근제어뿐 아니라 감사,보안이슈대응을 위해 사용자가 작업한 모든이력을 저장하고,
	윈도우는 화면레코딩,cli는 전체 키보드타이핑을 저장함,그리고 서버에 접근하면 그에대한  로그도 전부저장함
	그리고 권한제어를 통해 사용명령어도 통제가능
	
	vpn은 vpn임,ipsec는 네트워크연결에 사용되고ssl은 사용자가 내부망에 연결할때 쓰임,보통 요즘은 라우터나 방화벽에 다들어있음
	
3.방화벽
	초기방화벽은 상태기반엔진이 없이,패킷필터식으로 동작했는데,인터넷에 연결하기는 부적합해서 spi엔진이 나옴
	spi엔진은 세션기반으로 동작함
	이쪽에서 먼저 시작했냐 저쪽에서 먼저 시작했냐를 가지고,보안단계를 다르게 적용하는식
	여기에 블랙리스트를 적용하고,보통은 외부에서 시작된걸 전부 차단하고,특정ip만 화이트리스트 추가하는식으로 동작됨
	이떄 입력과 출력이 다른패킷이 있을수있으니까,포워딩테이블을 두고,거기에 포워딩할 값을 적어둔뒤 거기있으면 포워딩함
		세션테이블확인하고 ok이면 포워딩보고 포워딩하거나 폐기,
		ng면 정책보고 x면 폐기,o면 세션테이블에 기록하고 포워딩테이블보고 포워딩하거나 폐기
	이때 방화벽은 tcp컨트롤플래그에 따라 동작방식이 변하거나 시퀸스ack값이 갑자기 변하는것도 인지해 이상하다싶으면 폐기함
	그리고 세션을 인지하고 세션테이블에 저장해서,로깅도 쉬움
	
	alg는 방화벽이 3,4층에서만 놀아서 애플리케이션헤더를 인지할수없어서 생김
	세션방화벽 이전에 개발된 프로토콜들은 방화벽같은걸 고려하지못해 통신이 불가능한경우가 생김(ftp같은)
	ftp패시브모드로 하면되지만,그걸못하는애들때문에 그 프로토콜을 확인하면,그 포트를 열어주는 기능이 alg임
	근데 보안상문제도있고,완벽한 해결책은 아니라서(모든프로토콜을 적을순없으니)요즘은 잘 사용하지않음
	
	방화벽은 구조상 탈취계열은 막을수있는데 ddos계열을 막을수없고,웜계열도 막을수없음(바이러스탐지도 불가능하니까)
	그리고 취약점이 애플리케이션영역일경우엔 대응이 불가능함
	
	그래서 나온게 ips
	그래서 요즘은 방화벽도 다른 장비들의 기능을 흡수해서,애플리케이션 영역까지 확장한 장비들도 많음
	
4.ips
	방화벽은 네트워크 보안을 위해 구축되어야하는 필수솔루션이지만,앱계층을 막을수없음
	웹서비스를 제공하려면 80포트를 열어야하는데 이경우 아파치나 iis서버의 취약점을 이용한 공격은 방화벽이 막을수없는식
	이경우를 막기위해 ips가 나옴
	
	ips는 3층부터 7층까지가 영역임
	ips는 기본적으로 네트워크기반이고 여러 제약사항때문에 클라우드에선 호스트기반을 사용했지만,불편한점이 많아서 네트워크기반으로 바뀌는추세
	
	ips는 기본적으로 db를 사용한 패턴매칭방식으로 사용되지만,프로토콜 어노말리,프로파일 어노말리같은 다른기법으로 공격을 방어함
	
	패턴매칭에서 제일 중요한건,큰 db를 가져야하고,업데이트가 빨라야함
	문제는 패턴매칭방식은 약간의 변형만 생겨도 대응이 안돼서 나온게 화이트리스트기반인 어노말리임
	
	이건 프로파일과 프로토콜로 나뉨
	
	프로파일은 관리자가 정해놓은 기준이나 ips장비가 모니터링해 정해진 기준과 다른 행위가 일어나면 공격으로 판단함
	즉 프린트서버에 1mb미만의 트래픽이 평소에 발생했는데,갑자기 1gb가 들어오면 공격으로 판단하는식
	
	이건 나중에 강화되어서 ddos방어장비로 진화함
	
	프로토콜 어노말리는 해당 프로토콜용 포트에서 동작하지만,해당 프로토콜이 하는게 아닌 다른 프로토콜을 사용하려고하면 그걸 차단하는식
	
	
	ips는 빠른속도로 앱영역까지 확인하기위해 플로엔진을 사용하는데,이건 패킷을 모아 데이터형태로 바꿔서보는게 아니라,흐르는거만 보는거라 우회가 쉬움
	그리고 ips는 오탐이 많이 발생해서,환경에 맞는 튜닝작업을 오래 해줘야하며 별도의 관제인력이 장비를 모니터링하고 환경에 맞는 최적화작업을 계속해줘야함
	그리고 너무 많은 오탐과 알람때문에 장비가 공격을 정상적으로 못막거나 정상서비스가 차단될수있음
	이거때문에 ips를 설치만하고 사용못하는거도 흔함
	
	이거때문에 요즘은 ngips같은게 출시됨
	이건 앱을 인지하거나 시스템과 연동할수있고,apt공격을 방어하는 기능이 있고 그럼
	요즘은 ips도 여러장비들이 합쳐지고있고,단독ips는 잘 안나옴
	
5.ddos방어장비
	디도스방어장비는 보통 볼류메트릭공격을 막기위해 트래픽 프로파일링기법을 주로 사용하고,db를 사용하기도 함
	디도스 방어방법은,클라우드서비스,회선사업자의 방어서비스,직접ddos방어장비 설치하는 방법이 있음 
	
	보통 디도스는 대규모공격이 많아서,가장 쉬운방어방법은 디도스 탐지장비와 방어장비를 구분해,탐지장비로 ip를 따고,방어장비로 전부 드롭하는게 가장흔한방식 
	
	디도스의 공격타입으로는,회선을 가득채우는 볼류메트릭공격,3,4계층 취약점과 리소스고갈을 노리는 프로토콜공격,앱취약점을 노리는 애플리케이션공격이 있음
	보통 디도스방어장비의 목표는,볼류메트릭과 프로토콜 공격임
	
	볼류메트릭공격은 그냥 f5누르는식의 공격임,
	이건 회선쪽에서 막아주는것도 필요해서,isp와 공조해서 방어할 필요도 있음(혼자 다못막음)
	이건 증폭공격이라는 방식으로 주로 나오는데,중간에 리플렉터라는곳에서 패킷을 뻥튀기해서 공격대상에 던지는식
	이건 클라우드쪽에서 막아주니까 클라우드쓰자,아니면 클라우드기반 방어서비스도 있으니까 그거라도쓰자
	
	프로토콜공격은 네트워크보안장비를 과부하걸리게해서 서비스를 막는방식임(보안장비의 cpu,메모리를 바닥냄),3,4계층의 취약점을 사용함
	
	애플리케이션공격은 연결을 하고나서 프로세스와 트랜잭션을 독점해서 자원을 소모함,7계층의 취약점을 사용함(플랫폼취약점이나 프로토콜의 취약점)


6.vpn
	vpn은 터널링만 제공하면 vpn이라고 할순있지만,보통은 암호화까지 같이 있음
	보통 본사-지사 이런네트워크는 ipsec를 사용하고,개인사용자가 회사네트워크접속시엔 ssl이 사용됨
	
	ipsec은 양쪽다 ipsec지원장비가 필요하고
	ssl은 본사쪽에서만 있으면되고,개인은 필요없음
	
	vpn은 패킷을 터널링프로토콜로 감싸 통신하는데,이때 패킷을 암호화하거나 무결성을 체크하는기능을 이용해서 패킷갈취나 감청을 막음
	
	vpn은 3가지로 나뉘는데
		호스트 2 호스트
		네트워크 2 네트워크
		호스트 2 네트워크
	h2h는 잘 쓰지않음
	n2n은 본사-지사같은경우에 사용하고
	h2n은 워링우회할때같은 외부에서 접속해야할때 사용함




10.서버의 방화벽 설정/동작
1.리눅스
	만약 핑을 날렸는데  내부-외부는 되는데 외부-내부가 안되면,보통 서버방화벽문제임
	서버에 운영체제를 설치하면,최소한의 포트만 열어두고 나머지는 다닫는데,여기 걸린거임
	
	서버방화벽은 끄고사용할때도 있지만,반드시 써야할떄도 있음
	만약 db서버의경우엔,접근통제 솔루션(베스천호스트)를 사용할땐 걔의 아이피와포트를 제외한 모든걸 차단해야함
	
	리눅스에선 호스트방화벽으로 iptables를 많이사용하는데,centos7이상에선 firewalld를 사용하고,우분투는 ufw를 사용함
	그래도 iptables이 제일 많이 사용됨
	
	iptables은 netfilter를 사용할때 테이블역할을 하는 프로그램임,firewalld,ufw도 같음
	
	아이피테이블을 통해 시스템관리자는 서버에서 허용하거나 차단할 ip나 포트에 대한 정책을 세움
	이 정책들은 정책그룹으로 관리함
	이건 트래픽구간으로 나누는데,인풋,아웃풋,포워드(서버를 통과하는구간)등을 말함
	이렇게 만들어진 방향성그룹은,각 정책의 역할에 따라 상위역할그룹에 속함
	
	즉 방향성그룹으로 분류하고,이걸 역할그룹으로 다시묶음 
	iptables에서 개별정책의 방향성에 따라 구분한그룹을 체인이라고하고,체인을 역할별로 구분한 그룹을 테이블이라고함
	즉 개별정책의 그룹이 체인,체인그룹이 테이블
	iptables에선 필터테이블,nat테이블,맹글테이블,raw테이블,시큐리티테이블 이렇게 5개테이블이 있음
	
	필터테이블은 패킷을 허용하거나 차단할때 사용하는 테이블,호스트방화벽이 사용하는테이블임
	여기선 인풋체임,아웃풋체인,포워드체인에 따라 방화벽정책을 다르게함
	각 정책에는 정책을 적용할패킷과 상태,일치여부조건,허용및폐기(타깃)으로 구성됨
	
	리눅스 방화벽 키고끄는건 10.1.2보고(service iptables start 이런식으로 쿠브렛확인하는거처럼 함)
	
	정책확인은 iptables -L 로 확인할수있음
	보면 인풋의경우
		일단 세션이 있으면,모든출발지나 목적지에 대해 허용하고
		icmp를 허용하고
		ssh를 허용하고 
		나머지를 리젝트 하는식
	
	
	여기에 추가하려면
		iptables -A INPUT -p tcp --dport 80 -j ACCEPT
	이런식으로 넣으면됨
		iptables -A 체인 -p 프로토콜 --dport 포트 -j 엑셉트나 리젝트
	삭제는 
		iptables -D 체인 -p 프로토콜 --dport 포트 -j 엑셉트나 리젝트
	위치지정삽입은
		iptables -I 체인 숫자 -p 프로토콜 --dport 포트 -j 엑셉트나 리젝트
	
	
	방화벽 로그확인은 /var/log/messages에 있음
	근데 여긴 iptables로그말고 다른로그들도 있어서,iptables만 확인하려면 
		rsyslog.conf에
			kern.* /var/log/iptables.log
		추가
		systemctl restart rsylog.service
		
		iptables -I 체인 -j LOG --log-level 4 --log-prefix '## ZIGI-Log##'(구분자)
	하면됨
	
	
2.윈도서버 방화벽
	그거임 스팀차단할떄 쓰던 인바운드 아웃바운드
	
	
11.이중화기술
1.목적
	이중화의 목적은,spof를 없애는게 목적임
	단일장애점이 있으면 거기만뻗어도 네트워크 전체가 가버리니까 네트워크 전체에서 단일장애점이 있으면 안됨
	
	이때 이중화를 액티브-액티브로 할건지,액티브-스탠바이로 할건지 나뉘는데,
	액티브액티브에서 주의할점은 하나가뻗으면 대역폭이 절반으로 줄어드는데,그렇게돼서 네트워크에 부하걸려서 뻗으면안됨(즉 하나뻗어도 잠시는 버틸수있게 설계해야함)
2.LACP
	lacp는 두개이상의 물리인터페이스를 논리인터페이스로 묶어서,모든 물리인터페이스를 액티브상태로 사용하는 프로토콜
	즉,로드밸런서같은거임
	
	lacp를 사용할땐,대역폭이 1.5g가 필요하면,각각 인터페이스가 2g이상을 수용할수 있게 구성되어야함
	그리고 모든 인터페이스들은 속도가 같아야함,서로속도가 다르면 lacp를 사용할수없음
	
	lacp는 그안에 속해있는 모든 물리인터페이스를 묶어서,가상의 하나의 논리인터페이스로 취급함
	이때 논리인터페이스를 구성하기위해 사용하는게 lacpdu인데,여긴 출발지,목적지,타입,서브타입,버전정보등이 들어있고,이걸 매초마다 주고받음
	
	기본적으론 lacp를 구성하는 두개이상의 물리인터페이스가 하나의 장비에 연결되어있어야함(이건 mc-lag로 개선할수있음)
	그리고 lacpdu를 주고받으려면,양쪽에서 다 lacp를 지원해야함
	보통 액티브모드(먼저송신하고 수신도함)를 씀(패시브가 양쪽다이면 안돌아가니까)
	
	그리고 lacp는 운영체제를 설치해야 동작할수있음,그래서 운영체제 설치전에 lacpdu를 받으면 응답을 할수없는데,
	만약 송신을했는데 수신을 못받으면 pxe로 다시 날리고,그리고 응답이있으면 운영체제 설치를 기다렸다가 다시 lacp를 날림
	pxe는 단일인터페이스로 송신함
3.서버의 네트워크이중화설정
	lacp는 윈도는 티밍,리눅스는 본딩이라고 부름
	
	리눅스의 본딩은 액티브스탠바이(1번)과 액티브액티브(4번,lacp)를 사용함
	
	액티브 스탠바이는 액티브로만 패킷을 전달하다가 액티브가 죽으면 스탠바이가 살아나서 패킷을 전송함
	그리고 설정에따라 액티브가 다시살아나면 자동으로 돌리던가,수동으로 하던가 할수있음
	lacp를 쓰고싶으면 4번을 넣으면됨
	
	윈도우에 티밍은
	스위치 독립구성(액티브스탠바이)와 lacp가 사용됨
	
	리눅스에서 본딩을 할떈 11.3.3을 보고 하자
	대충 본딩파일만들고 있던인터페이스 수정해서 엮어주는거임
	이때 모드에 1이나 4넣으면되는거
	
	윈도서버도 똑같이 보고하자
	
4.mc-lag
	mc-lag는 lacp가 하나의 맥주소를 가져야한다는걸 벗어나서,각 네트워크카드별로 맥을 사용하지않고,전체네트워크중 대표맥만 사용하는식으로 돌아가서
	여러 스위치를 묶어서 가상으로 동작시킬수있음
	
	이땐 스위치끼리의 물리적 연결이 필요함
	
	mc-lag을 구성할떈
		구성장비(피어장비)
		mc-lag도메인(영역id):두개이상의 피어를 하나의 논리장비로 구성하기위한 영역id,peer은 이걸통해 상대방장비가 피어를 맺으려는건지 판단함
		피어링크:두 피어장비간 데이터트래픽을 전송하는 링크
	로 구성됨
	
	즉 피어끼리 서로 통신하며,죽었나 살았나 체크하다가 죽으면 다 자기가 받아가는거
	이때,스위치로 보내는애는,전체의 ip를 전부 알고있고,거기서 값을 보내는식임,중간에 로드밸런서를 두는게 아니라
	
	
5.게이트웨이 이중화
	게이트웨이도 하나만있으면 단일장애점이 될수있음,두개이상있어도 호스트는 하나의 게이트웨이만 보기때문
	이걸 해결하는게 fhrp임(표준프로토콜은 vrrp)
	fhrp를 사용하면 라우터는 실제ip외에 가상ip와 가상맥주소를 동일하게 갖음
	이떈 실제ip가 문제가 생기면,가상ip로 보내는데,이때 가상ip는 스탠바이중인 라우터들이 담당하는 주소임
	즉,실제로 담당하는게 하나씩있고,문제생겼을때 땜빵용 가상ip를 하나 가지고있는것
	
	이때 게이트웨이 자체의문제뿐아니라,외부네트워크사이의 문제도 알수있어서,그쪽에서 문제생겨도 스탠바이로 보냄
	
	그리고 아예 실제ip없이,로드밸런서식으로 모든패킷을 가장 가까운애가 처리하는식으로 구성할수도있음(hsrp)
	
	fhrp에서 가상ip의 우선순위는 값을 줘서 설정할수있음,그리고 장비끼리 1초마다 헬로패킷을 날려서 살아있나 확인하고,
	3번이상 응답없으면 나가리시키고 자신을 마스터로 올림,이때 우선순위따라 제일높은애가 마스터됨,그리고 이걸 멀티캐스트로 광고함
	이떄 가상ip와 맥은 바뀌지않고,윗단에서만 처리하기때문에 아래쪽에선 영향이 없음
	
	그리고 vrrp에서 서로 같은그룹이라는걸 확인하는게 vrid인데,이건 같은네트워크상에 두개이상의 vrrp가 있으면,겹치면안됨
	vrid를 가지고 가상맥을 만들기때문
	
	그리고 vrrp는 기본적으론 액티브-스탠바이식으로 동작하는데,이때 스탠바이쪽으로 보태면 걔가 그냥 액티브에 던져버림
	그래서 액티브액티브를 쓰고싶으면,mclag를 사용해서 하면됨
	
	그리고 그냥 가장 가까운애가 처리하게하려면 애니캐스트게이트웨이를 사용하면됨
	
	
	
12.로드밸런서
1.부하분산
	로드밸런서는 서비스 여러개를 둬서 대역폭을 늘리고,헬스체크를계속 해서 서비스가 죽었나 안죽었나를 확인하면서 트래픽을 분산하는 장치임
	트래픽분산외에도 방화벽을 액티브-액티브로 하기위해 사용하기도 함
	이경우엔 로드밸런서가 한번 지나간쪽으로 다시 지나가게해서,세션을 일정하게 유지시킴
2.부하분산방법
	로드밸런서는 자신의 ip를 가지고,서비스들의 ip를 가진다음,자기쪽으로 들어오는 통신을 밑의 서비스쪽으로 보내줌
	여기서 로드밸런서의 ip를 vip(버추얼 ip)라고 하고,서비스의ip를 rip(리얼 ip)라고 함
	로드밸런서로 통신이 들어오면,자기알고리즘에 따라 밑의 해당되는 rip로 던지는식임
	
	보통은 4계층이라서 l4로드밸런서지만,l7로드밸런서도 있고,이게더 좋음
	
3.헬스체크
	로드밸런서는 헬스체크방식으로 서버의 서비스가 살아있는지 확인하는데,여기에 쓰이는 방법으론
		ICMP:단순핑으로 서버가 살아있나를 확인함,서버가 살아있나 죽었나밖에 확인못해서 잘안씀
		TCP서비스포트:해당ip의 포트로 syn을 보내서 응답하는지를 확인함(tcp 핸드쉐이크),좀더 단순하게 syn-ack-rst로 단축한걸 사용하기도함
		http상태코드:tcp로 똑같이한다음,http를 요청해서 정상코드를 응답하는지까지 체크해서 헬스체크를할수있음(readnessprobe라고보면됨)
		콘텐츠확인:http랑 똑같은데,상태코드가 아니라 진짜웹페이지가 정상적으로 들어왔는지를 확인함
	
	헬스체크의 방법말고,다른고려사항으론
		주기:헬스체크를 하는주기
		응답시간:타임아웃시간
		시도횟수:몇번까지 기다려줄거냐(이거넘어가면 죽은거로간주),응답성공하면 초기화
		타임아웃:실제서버쪽에서 패킷전송후 대답없이 이시간지나면 다운으로 간주
		다운시 주기:죽고나서 갱신시간동안 좀 길게잡아서 부하줄일수있음
	가 있음
	
	이떄 주의점은,헬스체크주기를 응답시간보다 크게잡아야함,안그러면 타임아웃되기도전에 다음거들어와서 개판됨
	
4.부하분산 알고리즘
	부하분산 알고리즘엔
		라운드로빈:순서대로하나씩
		최소접속방식:가장 활성화세션 적은거
		가중치기반 라운드로빈:라운드로빈인데 가중치를 넣을수있음 서버에,처리량높은서버있을때 쓸수있음
		가중치기반 최소접속방식:최소접속인데 가중치를넣을수있음 서버에,처리량높은서버있을때 쓸수있음
		해시:해시알고리즘써서 그쪽에넣음
	
	여기서 해시는,서버의 부하를 고려하지않고,클라이언트가 특정서버에 지속적으로 접속하게하기위해 사용됨
	대충 분산되긴하는데 한곳에 몰릴수있음,이걸 사용하는 이유는 서버가 달라졌을때 초기화되는값이 있을떄,이걸방지하기위해(장바구니같은거)사용됨
	
	아예 라운드로빈이나 최소접속을 섞어서,거기에 스티키를 줘서 한번 붙은데에 계속 붙게 하는방법도 있긴한데,
	세션테이블에 타임아웃이 있어서 세션테이블이 끝나고나면 얄짤없이 다른데로 가버림
	그래서 이걸쓸떈 앱사용패턴같은거를 고려해서,그안에 끝날수있으면 사용하면됨
	
	
5.로드밸런서 구성방식
	로드밸런서는 원암방식과 인라인방식이 있음
	원암방식은 특정 패킷만 받아서 로드밸런서가 처리를 하는거고,인라인은 모든패킷을 로드밸런서가 처리하는거임
	이건 물리적인 연결과는 상관없이,논리적으로 그쪽을 전부거치냐 안거치냐에 따라 결정됨
	
	인라인방식은 그냥 로드밸런서가 모든걸 받는거임,이건 직관적인대신에 로드밸런서의 부하가 올라감
	
6.로드밸런서 동작모드
	로드밸런서의 모드는,
		트랜스패런트:로드밸런서가 l2스위치처럼 동작함,즉 로드밸런서에서 서비스하는 vip와 실제서버가 동일한 네트워크를 사용하게됨
		이경우엔 로드밸런서가 단 하나의 ip만 가지고 처리하기떄문에,그 ip를 전달만 하는 역할을 하게됨
		
		라우티드모드:로드밸런서가 라우팅역할을 하는것,로드밸런서로 던지면,그걸 실제ip로 바꿔서 전달함,그리고 서버-로드밸런서에도
		출발지를 로드밸런서의 ip로 바꿔서,방화벽에서 안걸리게함
		
		dsr:이건 로드밸런서를 거쳐서 들어간다음,서버에서 로드밸런서를 거치지않고 바로 클라이언트와 통신하는것
		이건 로드밸런서의 부하가 감소하지만,따로 설정을 안하면 무조건 방화벽에걸리니까,추가적인 설정이 필요함
		이때 필요한 설정은,
			루프백 인터테이스설정
			리눅스 커널 파라미터수정,윈도 네트워크설정 변경
		임,이건 필요하면보자
			
7.로드밸런서 유의사항
	로드밸런서의 원암구성때,서비스ip와 서버의 대역이 같을경우엔 서버가 로드밸런서를 안거치고 dsr처럼 보내버리는경우가 있음
	
	이경우엔 서버의 게이트웨이를 원암으로 사용하거나(대신 부하감소효과가 줄어듬)
	
	source nat를 사용하거나(이건 로드밸런서가 목적지뿐 아니라 출발지를 자기자신으로 바꿔서,로드밸런서한테 보내게함)
	단점으론 서버입장에선 모든통신이 같은ip라서 문제발생시 사용자구분이 어려워져서,따로 헤더를써서 원본ip를 저장함
	
	dsr모드를 사용할수있음
	
	
	로드밸런서 의 두번쨰 유의사항으론,동일네트워크 내에서 서비스ip를 호출하는경우임
	이경우엔 출발할땐 로드밸런서를 거치는데,도착할땐 그냥 바로 통신해서,서버에서 공격으로 간주하고 드롭함
	이경우도 앞에서랑 같은방법으로 소스넷을 쓰거나 dsr로 응답하면됨

8.haproxy
	이건 소프트웨어 로드밸런서임,그 쿠버네티스 실습할때 로드밸런서 깔아서 하던거랑 같음
	
	
	
	

	
	
	
	
	