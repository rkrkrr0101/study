컨테이너는 가상머신과 비슷하지만,같은 os내에서 울타리치고 차단건거라는거 설명
그리고 윈도우에서 리눅스컨테이너 실행시키면,리눅스 가상머신으로 돌리고 실행시킨대


기본적으로
	docker run ansible
이런식으로 컨테이너를 실행시킬수있음
이미지는 로컬에 있으면 있는거쓰고,없으면 도커허브나 연결된 레지스트리로 가서 받아옴
그리고 이미지명은,
	docker run 업로더이름/이미지이름
으로 구성되는데,인증받은이미지는 그냥 이미지이름만 써도됨

이미지에 이름붙여서 생성할땐
	docker run --name 붙일이름 이미지이름
하면됨
	
현재 실행중인 도커컨테이너를 보려면
	docker ps 
그리고 이전에 중지되거나 종료된 컨테이너까지 모두 보려면
	docker ps -a
	
실행중인 컨테이너를 멈추고싶으면
	docker ps  //컨테이너id나 컨테이너이름 뽑기
	docker stop 컨테이너id나이름

중지한 컨테이너를 삭제하고싶으면
	docker rm 컨테이너id나이름

다운받은 이미지를 삭제하고싶으면
	docker image //받은도커이미지 검색
	docker rmi 이미지명
이러면 이미지와 태그횟수가 0이된 레이어(각 이미지마다 겹치는레이어는 공유하니까,안겹치는거만 삭제하려면 이미지지울떄 태그1줄이면됨)를 삭제함

이미지를 다운받으려면(실행은안하고)
	docker pull 이미지명

그리고 도커는 os를 호스팅하기위한게 아니라 단순 프로그램실행이기때문에,컨테이너내부에서 자체적으로 종료되면 컨테이너도 종료됨

그리고 도커에 커맨드넣고싶으면
	docker run 이미지명 sleep 5
이런식으로 넣을수있음

그리고 도커 컨테이너내에 커맨드를 날릴려면(컨테이너에 내부파일본다던가)
	docker exec 컨테이너명 명령
	docker exec 컨테이너면 cat /etc/hosts
이런식임 


그리고 그냥 docker run을 하면,만약 컨테이너가 계속 대기를 하는경우(웹서버같은),계속 잡혀있어야됨
그럴떈
	docker run -d 이미지명
을 하면 분리모드로 백그라운드에서 돌아감
저기에 다시 연결하려면
	docker attach 컨테이너id
하면 연결됨

그리고 도커실행할때 bash명령을 실행하고 자동로그인을 하려면
	docker run -it centos bash
해야함
이러면 centos를 실행하고 그 os의 배쉬로 넘어감

그리고 정상적으로 종료되면 종료코드가(status의) 0이고,stop로 정지하면 137임

기본적으로 docker ps -a로 나오면,삭제된건아니고 정지된거임,지우려면 rm으로 지워야함

그리고 당연하지만 이미지가 이미 사용중이면,rmi로 삭제할수없음


그리고 슬립걸린 컨테이너에 접근할땐
	docker exec id 명령
하면됨,슬립이랑 상관없이 들어가짐

그리고 모든 도커이미지 삭제할땐
	docker rmi $(docker images -aq)
해서 이미지서치한거 전부지우면됨


이미지 실행이나 떙길때,버전선택하는건 :로하면됨
	docker run redis:4.0
태그없으면 latest,즉 최신버전을 잡음
어지간하면 태그달아서 하는게좋음,안그러면 이유모르게 달라져서 문제생길수있음

도커는 기본적으로 표준입력을 받지않음(도커 컨테이너는)
그래서 입력을 넣으려면,
	docker run -i 입력값(경로라든가)
해야함
근데 -i는 단순 입력만하고 서로 의사소통을 할수없음(대화형이아님)
그래서
	docker run -it 입력값
하면 대화형으로 사용할수있음


컨테이너의 포트를 매핑하는방법은
	docker run -p 외부포트:내부포트 이미지명
	docker run -p 80:5000 redis
이러면 포트포워딩이 됨(컴퓨터포트:컨테이너포트)
외부에서 접근할떈 포트포워딩을 해야 접근할수있음,아니면 접근불가능

컨테이너는 사라지면,안에 데이터가 다 날아감
그래서 외부랑 매핑을 해서 저장할수있음
컨테이너에 볼륨을 매핑하는방법은
	docker run -v 외부볼륨경로:컨테이너내부볼륨위치 이미지명
으로 외부의 폴더와 내부의 폴더를 일치시킬수있음

그리고 컨테이너의 상세정보를 보려면
	docker inspect 컨테이너id
하면 나옴
이거로 ip볼수있음,즉 접근주소찾기쉬움

로그를 보려면
	docker logs 컨테이너id
하면 나옴

그리고 docker run 이미지 커맨드 로 실행시킨 커맨드의 리턴은 바로 출력됨






도커에서 이미지를 만드려면,기본적으로
	os레이어
	소스레포지터리 업데이트
	기본 종속성 설치(파이썬의 종속성)
	파이썬(실행할수있는 프로그램)설치
	소스코드 복사
	소스코드내 종속성 설치(pip)
	웹서버 실행
을 순서대로 해야함,이걸 단위별로 묶어둔게 레이어고,레이어를 묶은게 이미지임
이때 이미지를 만드는 레시피가 dockerfile임
여기다가 이미지 설정 지침을 적으면됨
	FROM ubuntu //os레이어 선택,무조건 맨위엔 from이 와야함
	RUN apt-get update && apt-get -y install python python-pip //파이썬의 종속성(패키지설치툴)과 파이썬설치,pip설치
	RUN pip install flask flask-mysql  //파이썬라이브러리설치
	COPY . /opt/sourcecode //소스코드 위치로 복사(.(현재폴더)에서 이미지내의 /opt/sourcecode로 복사)
	ENTRYPOINT FLASK_APP=/opt/sourcecode/app.py flask run  //실행

그리고
	docker build . -f Dockerfile -t 내이름/이미지이름 
하면 됨
.은 현재폴더에 있는거 사용하라는거고,-f는 도커파일의 이름, -t는 이미지이름,태그
이미지를 올리고싶으면
	docker push 내이름/이미지이름
하면 레지스트리에 올라감
이떄는 내이름/이미지이름 이렇게 꼭해야함,아니면 실패남(오피셜로 던지기떄문에 당연히 실패남)
그리고 로그인도 해야함
	docker login
으로 할수있음

이런식으로 레이어로 하니까,만약 실패했을때 어디서 실패했는지 명확히 보임
그리고 겹치는레이어 있으면 그냥 그거있으니까 따로 안만들고 추가된레이어만 생성함(변경시도 같음)


이미지를 만들땐,직접 os run하고 그위에 설치 다해보고 정상적으로 동작하면,그뒤에 이미지를 만들면됨
이떄 history를 쓰면,내가 쳤던 명령어들을 다 볼수있으니까,그거보고 기록하면됨

그리고 파이썬내에서 환경변수를 받아서 쓰려면
	color = os.environ.get('환경변수이름1')
으로 선언하고

	docker run -e 환경변수이름1=환경변수값 이미지명 
으로 줄수있음
그리고 inspect로 컨테이너의 환경변수를 볼수있음
밑에 env안에 들어있음


도커파일에서 뭘 실행할떄(진입할때),entrypoint와 cmd를 사용함
cmd는
	CMD ["nginx"]
이런식으로 사용함
근데 cmd를 사용하면 바로 터미널에 연결하지 않음,그래서 -it로 터미널에 연결해야하는거(cmd명령만 수행하고 따로 뭐 더하는건없음)
그리고 
	CMD sleep 5
이런식 말고,괄호로 쌀떄는 맨처음인자는 온전한 실행파일이어야함
	CMD ["sleep","5"]
이렇게

그리고 sleep를 영구적으로 하길원하면 ubuntu-sleeper 이미지를 사용하면됨
ubuntu-sleeper는 entrypoint를 사용함
	ENTRYPOINT ["sleep"]
entrypoint는 기본적으로 cmd와 같은데,cmd는 만약 추가명령을 주면(docker run 이미지 sleep 10),전체가 덮어씌워지는데 반해
entrypoint는 거기있던 명령에 추가로 적힌명령이 실행됨(최하단에)
그래서
	docker run ubuntu-sleeper 10
하면 sleep 10과 같아짐

만약 기본값을 정하고싶으면
	ENTRYPOINT ["sleep"]
	CMD ["5"]
이렇게하면 됨,cmd만 덮어씌워짐 이러면

그리고 entrypoint를 덮어씌우고싶으면
	docker run --entrypoint 덮어씌울명령 이미지명 커맨드
	docker run --entrypoint sleep2.0 ubuntu-sleeper 10
이렇게 할수있음

그리고 보통 이미지에 특정이름에(특정컨테이너이름) 연결시킬수 있는데,이럴땐
	docker run --name=abc -p 5000:80 --link redis:redis 이미지명
으로 --link로 안에서 정의한이름과 연결할 생성된 컨테이너이름과 연결할수있음
근데 뭐 없어졋다그러고 있는지없는지 모르겟음,보통 도커스웜이나 네트워크로하나봄

도커컴포즈는,도커명령을 yaml로 바꿔서 실행시키는거
근데 쿠버네티스있는데 쓸까(기본적으로 스테이트풀로 실행하는거같긴함)
도커컴포즈는 기본으로 설치안되니까,따로설치해야함

도커컴포즈에선,각각의 이름을 가지고 이미지를 지정하고 설정을 넣음
	version:"2"
	services:
		db:
			image:이미지명
			ports:
			-  5000:80
			links:
			-  redis
			-  db

그리고 이미지를 가져오는대신,빌드를 하고 실행시키려면
	db:
		build: ./vote
이렇게 이미지대신 빌드를넣고 경로지정해주면됨


이렇게 생성시키면(version2),저안에 있는 모든 컨테이너는 같은네트워크에 연결되고,서로의 서비스네임으로 통신할수있음
그래서 링크는 필요없어짐
	version:"2"
	services:
		db:
			image:이미지명
			ports:
			-  5000:80
			environment:
				env이름:env값

그리고 저기서 시작순서를 정하려면
	version:"2"
	services:
		db:
			image:이미지명
			ports:
			-  5000:80
		
		vote:
			image:vating
			depends_on:
			-  db
이런식으로 의존성을 추가할수있음
그리고 서로 분리된 네트워크를 만드려면
	version:"2"
	services:
		각종컨테이너1:
			networks:
			-  front
		각종컨테이너2:
			networks:
			-  back		
		각종컨테이너3:
			networks:
			-  front
			-  back
		각종컨테이너4:
			networks:
			-  front
			-  back		
	networks:
		front:
		back:
이런식으로 네트워크만들수있음

그리고 버전3은,네트워크관련기능이 추가됨

그리고 docker run에서 환경변수추가는 docker run -e 이름=값 으로 할수있음

그리고 도커컴포즈 적용시키려면
	docker-compose up //파일명은 docker-compose.yaml
하면됨
그리고 이렇게 만들면,컨테이너앞에 프로젝트_컨테이너명 이런식으로 앞에 뭐가붙음,프로젝트명은 up할때 바꿀수있음


그리고 이미지를 레지스트리에서 가져올때,
	유저네임/이미지이름
하면 기본값인 도커허브에서 가져오고
	레지스트리/유저네임/이미지이름
이렇게하면 저 레지스트리에서 가져옴

그리고 프라이빗레지스트리에서 가져올땐,
	docker login 레지스트리주소
로 로그인하면 거기서 가져올수있음

그리고 개인레지스트리도 도커에 컨테이너로 띄울수있고,
거기에 푸시할떈
	docker push localhost:포트/이미지명
으로 푸시할수있음
물런 저 로컬호스트에 ip넣으면 거기로푸시함



도커엔진은,도커의 기본이 되는 기능임
	도커데몬
	restapi
	docker cli
3개로 구성되어있음

도커데몬은 이미지와 컨테이너와 볼륨,네트워크등을 관리함
restapi는 프로그램이 데몬과 대화하고 제공하는데 사용할수있는 api임(그거맞음 겟포스트)
도커cli는 그냥 커맨드라인임

즉,도커cli는 restapi를 사용해 도커데몬과 상호작용함,
그러니까 도커cli는 다른컴퓨터에있어도,ip지정해서 restapi만 건드릴수있으면 상호작용이 가능함

이때 다른컴퓨터에서 건드릴곳 지정할땐
	docker -H=ip:포트
하면됨

명령하나만 날릴땐
	docker -H=ip:포트 run nginx
이렇게하면됨


도커는 네임스페이스를 사용해서 만든컨테이너의 pid를 사용해서 네트워크에서 분리함
이때 통신마운트와 타임쉐어링은 자체네임스페이스에도 생성되니까 컨테이너간 격리가 가능함

작동방식을 자세히보면,메인시스템이 있고,거기서 자식시스템이 분리해나가는식으로 사용됨
그래도 결국은 메인시스템에 pid가 존재해야하고,
그게 겹치면 안되기때문에,메인에 해당되는것과 자식에 해당되는 pid2개를 가지게됨
즉 pid5번이 컨테이너의 pid1번이고(컨테이너자체의 유지를담당),pid6번이 컨테이너의 pid2번(컨테이너에서 실행중인 프로세스)
이런식임
이걸  보는법은
	docker exec 컨테이너명 ps -eaf
하면 볼수있음


정확히말하자면,논리적으로 분리되어있는거지 물리적으로는 다 같은공간을 사용한다는거임,그래서 가상머신과 다르게 부하도 덜한거고

그리고 기본값으론 cpu나 메모리제한이 없는데,제한걸수있음(쿠버네티스에잇던 그거)
사용법은
	docker run --cpus=.5 nginx
	docker run --memory=100m nginx
이런식



도커에서 기본적으로 저장은 /var/lib/docker에 폴더를 생성해서 저장함(aufs,containers,image,volumes)
기본값으로 볼륨쓰면,저 볼륨폴더밑에 저장됨

기본적으로 저 폴더밑에 새로운 폴더를 생성하고 그밑에 저장함



그리고 이미지레이어는 기본적으로 읽기전용이라,컨테이너가 여기서 뭘 바꿀순없고,따로 컨테이너레이어가 주어지고 거기에 뭐가 저장됨
정확히는 컨테이너 실행시 이미지레이어에 있는 모든걸 컨테이너레이어로 복사하고,거기서 모든일이 일어남
그리고 여기저장된건 컨테이너가 삭제되면 사라짐,이걸 저장하고싶으면 볼륨을 써야함(퍼시스턴트볼륨)
이 퍼시스턴트볼륨은
	docker volume create 볼륨명1
으로 생성하고(볼륨폴더밑에 생성됨)
	docker run -v 볼륨명1:컨테이너내에저장경로 mysql
이렇게 사용할수있음
이건 따로 create안하고 바로 볼륨명붙여서 run해도 자동으로 생성됨


그리고 이미 다른데 존재하는데이터폴더를 볼륨으로 쓰고싶으면
	docker run -v 진짜경로:컨테이너내부경로 mysql
하면 됨
이걸 바인드 마운팅이라고함

그리고 저거보다 나은,명확히 명시하는방식은
	docker run --mount type=bind,source=진짜경로,target=컨테이너내부경로 mysql
로 전부 명시해서할수있음

도커는 스토리지드라이버를 사용해서 컨테이너레이어에 데이터를 생성함
이거는 기본값은 os마다 달라짐,그리고 도커가 자동으로 선택함

docker history 이미지id를 쓰면,해당 이미지로 컨테이너를 만들때 수행할 단계목록(cmd같은)게 다 나옴

그리고 기본적으로 docker images하면,겹치는레이어도 포함해서 용량을 계산하기때문에,뻥튀기가됨
그래서 실제로 차지하고있는 용량을 보고싶으면
	docker system df
로 볼수있음
이미지별로 보려면
	docker system df -v
하면됨,이러면 이미지와 볼륨까지 볼수있음

도커 네트워크는































