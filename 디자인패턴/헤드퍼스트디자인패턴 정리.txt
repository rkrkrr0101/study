1.전략패턴
	그냥 단순히 상속의 슈퍼클래스에 새로운 메소드를 추가하면,거기에 하위 모든 피상속대상(서브클래스)이 영향을 받으니까 하나하나 일일히 봐야하고,
	하나하나 다 일일히 오버라이드해서 지워주던가 해야함
	그래서 소스의 중복이 생기고,미처 확인하지못한 서브클래스가 있으면 그대로 버그행,그리고 실행시에 특징변화도 힘듬(setter가 없으니)
	
	그래서 인터페이스를 만들고,거기에 해당하는 추상메소드를 선언해두고(캡슐화),
	거기에 맞춰서 인터페이스를 구현하고,자기가 쓸 옵션을 붙여서 객체를 생성하는식으로 할수있음
	이게 전략패턴임
	
	이때,바뀌지 않을부분은 그대로 두고,바뀌는 부분만 캡슐화해서 바꿔가면서 사용하면됨
	이떄 세터를 둬서 세터로 적용하는식으로 하고,생성자를 둬서 그떄 매개변수받아서 생성하는식으로 동작하면될듯
	이때는 원래 슈퍼클래스와,그 슈퍼클래스의 추상메소드인터페이스들,슈퍼클래스의 메소드로 구성이 되고,추상메소드인터페이스를 구현하고,
	객체를 만들때 필요한 구현된 인터페이스를 가져다 세팅하는식으로 하면됨
	
	이렇게 사용하면,이 추상메서드들은 단순히 특정 행동을 표현하는거니까 이걸 또 다른데서 가져다쓸수도있음
	(서로 의존성이 올라갈거같긴하지만 메소드가 딱 그행동만 표현할수있으면 상관없을거같긴함)


2.옵저버 패턴
	옵저버패턴은 주제-구독(옵저버)모델로,주제에 변화가 생기면 그걸 관측해서,구독을 신청한 객체들에게 알림을(값도 줘도되는데,보통 알림만 보냄)보내서
	값이 필요한애들이 계속 감시안해도 되고,이벤트발생하면 그때맞춰서 값을 가져오게 하는식으로 동작하는 패턴임
	즉 db감시자는 계속 감시만 하고,변경점있을때 알림만 하고,옵저버들은 알림이 들어오면 거기에 맞춰서 대응을 하는식
	
	구현할땐,주제 인터페이스엔,옵저버추가,옵저버제거,옵저버에게알림 3가지가 꼭 있어야하고
	옵저버 인터페이스엔 업데이트메소드만 있으면 됨
	옵저버가 될 가능성이 있는 객체들은 전부 옵저버인터페이스를 구현해야하고,주제역할을 하는애는 주제인터페이스를 구현해야함
	
	주제는 옵저버가 옵저버인터페이스를 구현했다는 사실만 알고,다른건 관심없음
	그리고 옵저버는 얼마든지 추가,삭제할수있고(어짜피 리스트에 넣었다뺐다밖에 안함,알림도 for문돌리니까)
	주제와 옵저버가 달라져도 서로에게 영향을 주지않음


3.데코레이터 패턴
















