1.전략패턴
	그냥 단순히 상속의 슈퍼클래스에 새로운 메소드를 추가하면,거기에 하위 모든 피상속대상(서브클래스)이 영향을 받으니까 하나하나 일일히 봐야하고,
	하나하나 다 일일히 오버라이드해서 지워주던가 해야함
	그래서 소스의 중복이 생기고,미처 확인하지못한 서브클래스가 있으면 그대로 버그행,그리고 실행시에 특징변화도 힘듬(setter가 없으니)
	
	그래서 인터페이스를 만들고,거기에 해당하는 추상메소드를 선언해두고(캡슐화),
	거기에 맞춰서 인터페이스를 구현하고,자기가 쓸 옵션을 붙여서 객체를 생성하는식으로 할수있음
	이게 전략패턴임
	
	이때,바뀌지 않을부분은 그대로 두고,바뀌는 부분만 캡슐화해서 바꿔가면서 사용하면됨
	이떄 세터를 둬서 세터로 적용하는식으로 하고,생성자를 둬서 그떄 매개변수받아서 생성하는식으로 동작하면될듯
	이때는 원래 슈퍼클래스와,그 슈퍼클래스의 추상메소드인터페이스들,슈퍼클래스의 메소드로 구성이 되고,추상메소드인터페이스를 구현하고,
	객체를 만들때 필요한 구현된 인터페이스를 가져다 세팅하는식으로 하면됨
	
	이렇게 사용하면,이 추상메서드들은 단순히 특정 행동을 표현하는거니까 이걸 또 다른데서 가져다쓸수도있음
	(서로 의존성이 올라갈거같긴하지만 메소드가 딱 그행동만 표현할수있으면 상관없을거같긴함)


2.옵저버 패턴
	옵저버패턴은 주제-구독(옵저버)모델로,주제에 변화가 생기면 그걸 관측해서,구독을 신청한 객체들에게 알림을(값도 줘도되는데,보통 알림만 보냄)보내서
	값이 필요한애들이 계속 감시안해도 되고,이벤트발생하면 그때맞춰서 값을 가져오게 하는식으로 동작하는 패턴임
	즉 db감시자는 계속 감시만 하고,변경점있을때 알림만 하고,옵저버들은 알림이 들어오면 거기에 맞춰서 대응을 하는식
	
	구현할땐,주제 인터페이스엔,옵저버추가,옵저버제거,옵저버에게알림 3가지가 꼭 있어야하고
	옵저버 인터페이스엔 업데이트메소드만 있으면 됨
	옵저버가 될 가능성이 있는 객체들은 전부 옵저버인터페이스를 구현해야하고,주제역할을 하는애는 주제인터페이스를 구현해야함
	
	주제는 옵저버가 옵저버인터페이스를 구현했다는 사실만 알고,다른건 관심없음
	그리고 옵저버는 얼마든지 추가,삭제할수있고(어짜피 리스트에 넣었다뺐다밖에 안함,알림도 for문돌리니까)
	주제와 옵저버가 달라져도 서로에게 영향을 주지않음


3.데코레이터 패턴
	데코레이터패턴은 원래클래스의 인터페이스를 만들고,추가적으로 더해지는거도 다 같은 인터페이스를 사용해서,자기 내부에 그 인터페이스변수를 만들고
	a+@+@ 이런식으로 재귀함수처럼 데코레이터가 그 내부를 콜하고 자기자신이 할 행동을 더하는식으로 구성됨
	즉 뎁스 0에 도달할때까지(데코레이터가 아닌 원래클래스에 도달할때까지) return myinterface.할일+할일() 이런식으로 돌림
	즉 데코레이터를 래퍼객체라고 생각하면됨
	
	데코레이터에서 사용되는 상속은,메소드등을 주는게 목적이 아니라 인터페이스를 사용해서 형식을 맞추는게 목적임
	그래서 데코레이터 내부에 원본객체를 보관하고,같은메소드를 반복콜해서 재귀처럼 돌리려는거임
	보통 구조는,기본슈퍼클래스와 슈퍼클래스를 상속한 기본인스턴스와 데코레이터 인터페이스(추상클래스도 ㄱㅊ),데코인터페이스 하위의 구현된 데코레이터로 이루어짐
	
	데코레이터인터페이스는 그 상위클래스나 인터페이스를 상속했기때문에,그걸 내부에 선언할수있음
	
	데코레이터의 단점은,단순히 원본에 더하는식으로 만들어지기때문에,클래스수가 엄청나게 늘어서 처음 코드를 보는사람이 보면 엄청나게 많음,
	모든 잡다한일에 다 하나씩 클래스가 들어가기때문임
	
	데코레이터를 적용할땐,특정 형식에 의존하는 코드에 적용하면 안됨,데코레이터를 쓰는 이유는 데코레이터를 써도 클라이언트는 그걸 알필요가 없다는거인데,
	만약 매개변수같은거로 조건맞춰서 특정값을 넣어야하면 서로간에 의존성때문에 경직도가 너무높아짐


4.팩토리 패턴
	팩토리패턴은 기본적으로 생산을 대행하는 역할임
	기본적으로 조건에 따라 분기돼서 생산하는걸 분리한다는 역할(ocp,생산내용이 추가돼도 변경에 닫혀있게됨)만 하면 심플 팩토리
	
	슈퍼클래스를 추상클래스로 바꾸고,추상클래스내의 추상메소드를 사용해서 생산을 하면 팩토리메소드(이 추상클래스를 상속해서,각각 자신의 구현클래스를 만들면됨),
	팩토리 메소드는 부산공장 서울공장 이런식으로,아예 다르게 작업해야할경우 유용하게 사용됨(그안에서 생산하는 전체에 공통된 차이점이 있을경우)
	이경우엔,추상클래스 내의 구현메소드에서 추상메소드를 호출하는식으로,어디를 가든 상관없이 같은방식으로 사용하면서,컴파일시점에서 변경점을 줄수있게됨
	즉 서브클래스선택에 따른 분기가 가능해짐
	이때도 생산제품에도 추상클래스가 있고,거기에 따른 구현클래스가 나오게됨
	
	그리고 상위가 하위구현체에 의존하면 안되고,추상화된것에 의존해야함(dip,의존성 역전 원칙)
	즉 제품 하나하나에 의존하면 안되고,인터페이스나 추상클래스를 만들고,그걸 구현하는식으로 하위개체들을 만들고
	상위는 인터페이스 하나에만 의존해야함
	만약 구현체에 의존하면,구현체 하나를 바꾸면 상위를 바꿔야하지만,
	인터페이스에 의존하면 인터페이스가 바뀌지않는한 하위에서 무슨짓을 해도 상위는 건드리지않아도됨
	
	추상팩토리는 기본적인 팩토리 인터페이스를 생성하고,그 팩토리 인터페이스를 구현하면서 각 구현클래스에 맞는 제품을 생산하게함(이때 제품에도 추상클래스가 있음)
	그리고 제품에도 그 추상클래스를 넣어서,팩토리메소드처럼 구분하지않고 그냥 팩토리에 따라 안에 다르게 들어가는식으로 처리됨
	즉 제품에서 팩토리의 제품생산메소드를 눌러서 생산을 받으니,거기서 뭘주냐는 신경쓰지않고 진행함
	그리고 이거도 팩토리에 따라 제품이 갈리는데,구현클래스에서 팩토리를 선택해서 분기를 나누게되고,다른 팩토리끼리도 같은제품을 생산할수도있음
	
	기본적으로 둘의 차이는,팩토리메소드는 상속을 사용하고,추상팩토리는 인터페이스를 사용하게됨
	보통 팩토리메소드는 적은수의 제품이 여러분기로 나눠질때 잘 사용되고,추상팩토리는 많은수의 제품을 생산할때 사용하게됨
	그리고 추상팩토리 내에서 제품을 생산하는 메소드를 팩토리메소드로 구현할떄도 종종 있음
	

5.싱글턴
	싱글톤은 전역적으로 단 하나만 생성되길 보장하는 객체임,주로 db나 그런 두개이상 생겼을때 정합성문제가 생기거나,생성코스트가 비싼곳에 주로 사용됨
	기본적으로 정적메소드(객체를 생성하지 않아도 사용할수있는 메소드)에 생성자를 프라이빗으로 담고,그걸 콜해서 없으면 생성,있으면 그거 반환하는식으로 사용됨
	
	단 그냥 이렇게만 만들면,멀티스레딩에서 둘다 동시에 if문을 넘어간경우,객체가 2개 생기는 드문경우가 발생할수있음
	그래서 세마포같은거로 동기화를 시키거나(성능떨어지는걸 감수하고 \),프로그램 시작부터 미리 생성하고 들어가거나,dcl을 사용하거나 할수있음
	
	그리고 자바같은경우,enum을 사용하면 이런 문제들을 다 해결할수있음


6.커맨드
	커맨드패턴은 인터페이스를 만들어서,그 클래스를 실행시키는 추상메소드를 생성하고,그걸 구현해서 무슨 클래스를 실행시키든 같은 메소드로 실행되게 하는 패턴임
	이렇게되면 실행주체는 무슨메소드를 실행시켜야하는지를 알필요가 없어지고,인터페이스의 추상메소드만 알면 실행시킬수 있게됨,즉 리모컨같은것
	이때 특정 대상이 필요하면(거실 조명같은,이걸 리시버라고 함),그걸 커맨드에서 매개변수로 받아서 그걸 눌러주면됨
	즉 커맨드는 실제대상의 행동을 캡슐화해서 execute로 바꿔주는거만 하고,
	실제 행동은 커맨드객체안의 리시버객체의 메소드를 execute안에 정의하는거로 동작하게됨
	
	그리고 실제구현에선,커맨드를 상속한 no커맨드를 기본값으로 넣어서,설정전엔 아무일도 일어나지않게 하는게 균일한 동작에 좋음(그냥 빈 execute를 구현)
	
	이때 언두를 넣고싶으면,언두메소드를 넣어서 그렇게 되돌리면됨(그 결과적 트랜잭션처럼 내가한일을 알고있으니 그거만 되돌리는거임)
	그리고 상태가 필요하면,커맨드객체내에 이전작업시의 상태를 저장하는식으로 구성하면됨
	
7.어댑터와 퍼사드






