1.전략패턴
	그냥 단순히 상속의 슈퍼클래스에 새로운 메소드를 추가하면,거기에 하위 모든 피상속대상(서브클래스)이 영향을 받으니까 하나하나 일일히 봐야하고,
	하나하나 다 일일히 오버라이드해서 지워주던가 해야함
	그래서 소스의 중복이 생기고,미처 확인하지못한 서브클래스가 있으면 그대로 버그행,그리고 실행시에 특징변화도 힘듬(setter가 없으니)
	
	그래서 인터페이스를 만들고,거기에 해당하는 추상메소드를 선언해두고(캡슐화),
	거기에 맞춰서 인터페이스를 구현하고,자기가 쓸 옵션을 붙여서 객체를 생성하는식으로 할수있음
	이게 전략패턴임
	
	이때,바뀌지 않을부분은 그대로 두고,바뀌는 부분만 캡슐화해서 바꿔가면서 사용하면됨
	이떄 세터를 둬서 세터로 적용하는식으로 하고,생성자를 둬서 그떄 매개변수받아서 생성하는식으로 동작하면될듯
	이때는 원래 슈퍼클래스와,그 슈퍼클래스의 추상메소드인터페이스들,슈퍼클래스의 메소드로 구성이 되고,추상메소드인터페이스를 구현하고,
	객체를 만들때 필요한 구현된 인터페이스를 가져다 세팅하는식으로 하면됨
	
	이렇게 사용하면,이 추상메서드들은 단순히 특정 행동을 표현하는거니까 이걸 또 다른데서 가져다쓸수도있음
	(서로 의존성이 올라갈거같긴하지만 메소드가 딱 그행동만 표현할수있으면 상관없을거같긴함)


2.옵저버 패턴
	옵저버패턴은 주제-구독(옵저버)모델로,주제에 변화가 생기면 그걸 관측해서,구독을 신청한 객체들에게 알림을(값도 줘도되는데,보통 알림만 보냄)보내서
	값이 필요한애들이 계속 감시안해도 되고,이벤트발생하면 그때맞춰서 값을 가져오게 하는식으로 동작하는 패턴임
	즉 db감시자는 계속 감시만 하고,변경점있을때 알림만 하고,옵저버들은 알림이 들어오면 거기에 맞춰서 대응을 하는식
	
	구현할땐,주제 인터페이스엔,옵저버추가,옵저버제거,옵저버에게알림 3가지가 꼭 있어야하고
	옵저버 인터페이스엔 업데이트메소드만 있으면 됨
	옵저버가 될 가능성이 있는 객체들은 전부 옵저버인터페이스를 구현해야하고,주제역할을 하는애는 주제인터페이스를 구현해야함
	
	주제는 옵저버가 옵저버인터페이스를 구현했다는 사실만 알고,다른건 관심없음
	그리고 옵저버는 얼마든지 추가,삭제할수있고(어짜피 리스트에 넣었다뺐다밖에 안함,알림도 for문돌리니까)
	주제와 옵저버가 달라져도 서로에게 영향을 주지않음


3.데코레이터 패턴
	데코레이터패턴은 원래클래스의 인터페이스를 만들고,추가적으로 더해지는거도 다 같은 인터페이스를 사용해서,자기 내부에 그 인터페이스변수를 만들고
	a+@+@ 이런식으로 재귀함수처럼 데코레이터가 그 내부를 콜하고 자기자신이 할 행동을 더하는식으로 구성됨
	즉 뎁스 0에 도달할때까지(데코레이터가 아닌 원래클래스에 도달할때까지) return myinterface.할일+할일() 이런식으로 돌림
	즉 데코레이터를 래퍼객체라고 생각하면됨
	
	데코레이터에서 사용되는 상속은,메소드등을 주는게 목적이 아니라 인터페이스를 사용해서 형식을 맞추는게 목적임
	그래서 데코레이터 내부에 원본객체를 보관하고,같은메소드를 반복콜해서 재귀처럼 돌리려는거임
	보통 구조는,기본슈퍼클래스와 슈퍼클래스를 상속한 기본인스턴스와 데코레이터 인터페이스(추상클래스도 ㄱㅊ),데코인터페이스 하위의 구현된 데코레이터로 이루어짐
	
	데코레이터인터페이스는 그 상위클래스나 인터페이스를 상속했기때문에,그걸 내부에 선언할수있음
	
	데코레이터의 단점은,단순히 원본에 더하는식으로 만들어지기때문에,클래스수가 엄청나게 늘어서 처음 코드를 보는사람이 보면 엄청나게 많음,
	모든 잡다한일에 다 하나씩 클래스가 들어가기때문임
	
	데코레이터를 적용할땐,특정 형식에 의존하는 코드에 적용하면 안됨,데코레이터를 쓰는 이유는 데코레이터를 써도 클라이언트는 그걸 알필요가 없다는거인데,
	만약 매개변수같은거로 조건맞춰서 특정값을 넣어야하면 서로간에 의존성때문에 경직도가 너무높아짐
















