2.주피터명령어
	%run으로 외부파이썬프로그램을 실행시킬수있음(.py)
	%timeit로 실행시간체크가능(1000회루프평균)
	%time은 단일실행시간체크
	1.매트랩
		%matplotlib inline:아웃풋에 plt.plot로 바로출력가능
	
3.파이썬명령어	
	속성과 메서드는 getattr(객체,'메서드명')으로 스트링으로 접근할수도잇음
	
	만약 순회가 가능한(for문으로 집어넣어서 뺼수잇는)거면 iter(객체)해서 확인가능
	
	임포트할땐 그냥 같은디렉터리안에있으면 import abc 해서(abc.py파일)사용가능
	
	두참조변수가 같은값가리키는지 확인하려면 a is b하면 tf로 뱉음
	즉,딥카피했을때 ==로 같은게 a is b 하면 false가 나올수있음
	a is None는 변수비어있는지 확인할때 자주씀

	문자열과 튜플은 변경불가능한(상수)객체임
	
	만약 문자열에 역슬래시같은 특수기호 많이들어가면 문자열앞에 r붙여서 (r'\'fds') 그냥 생으로 처리가능
	
	문자열.format은'a{0:s}{1:1f}{2:d}'이건 뒤에 나오는 변수를 저기대입하라는거(순서:형식)
	문자열.format('a',1,1)하면 aa11리턴됨
	즉 문자열파싱해서 저거대입함
	
	날짜와 시간쓸떈 datetime임포트해서 쓰면됨
	그냥 date()time()쓰면 datetime객체로 리턴되고,strftime()하면 스트링으로 리턴되는데 그냥 date로받아서 스트링으로 변환해도됨
	strptime는 스트링을 datetime객체로 변형시켜줌
	timedelta객체를 datetime에 더하거나 빼거나해서 변형시킬수있음
	
	pass는 if문이나 그런 블럭안에 비어있을때 넣어두면 그냥스킵하고지나감(비워두면 블록에러뜸 공백문자땜에)
	
	range는 마지막숫자 바로앞까지(range(8)이면 0~7까지)반복
	
	삼항표현식은 a=트루값 if 조건 else 펠스값
	으로 if문 좀 편하게적게해줌
	
4.자료구조등
	튜플:상수화시킨 리스트
		튜플을 한번확정하면 거기에 추가나 제거불가능
		단 내부개체가 리스트처럼 객체일경우 참조하고있는곳에 추가제거는 가능
		튜플을 곱하면 튜플의 복사본이 반복되어 늘어남
		
		튜플과 같은표현의 변수의 갯수를 맞춰서 =해주면,튜플이 분리되서 변수에 들어감
		ex) a=(1,2,3)
			b,c,d=a
			print(b,c,d)#1 2 3
		중첩된튜플의경우
		ex) a=(1,2,(3,4))
			b,c,(d,e)=a
			print(b,c,d,e)#1 2 3 4	
		
		스왑도 그냥
			a,b=b,a
		하면 스왑됨
		
		for문같은거도(중첩된리스트나 튜플 순회할때)
		저렇게 한덩어리씩 빼서 내부값 사용가능
		ex) a=[(1,2),(3,4),(5,6)]
			for b,c in a:
			...
		
		만약 *변수를해서 꺼내면,뒤에있는값 전부를 받아옴     ☆
		ex) a=(1,2,3,4,5,6,7)
			b,c,*d=a
			print(b,c,d)#1 2 [3,4,5,6,7]	
			
		튜플.count('a') a갯수세기
	리스트:크기내용변경이 가능한 참조객체
		append로 맨뒤에추가,insert(위치,내용)으로 원하는위치에 추가(값은 인서트가 더 비싸니까 어지간하면 어펜드(순서안중요하면))맨앞에추가하려면 deque쓰자
		remove로 맨앞삭제 pop(위치)로 원하는위치삭제
		
		in으로 리스트에 어떤값 있는지 확인가능 (TF로 리턴)
		리스트.extend()로 여러값 추가가능(기존리스트에 추가)
		리스트를 +로 이어붙이면 새 리스트를 생성하고 값을복사하니까,코스트생각해야되면 extend로 기존값 추가하는게 더 쌈
	
	사전(dict):키 밸류로 이루어진 해시객체
		리스트처럼 값에 접근하거나 값을 넣을수있고,추가할수있음
		밸류는 기본적으로 하나지만,리스트같은 참조객체가 들어간경우 그안엔 여러개가 들어갈수있음
		삭제는 del이나 pop메서드로 함
		update로 사전을 합칠수있음(만약 같은키가 있으면 이거로 덮어씌워짐)
		그냥 인서트는 사전[키]=밸류 하면 추가됨
		
		사전.keys와 사전.values는 키이터레이터와 밸류이터레이터를 반환하니까,리스트캐스팅해서 보면됨
		정렬은 안되어있긴한데,keys와 values의 순서는 같음
		
		리스트2개를 사전으로 합치려면 for문돌려도되지만,a=dict(키배열,값배열)하면 사전나옴
		
		안에서 값 뽑을때는 get하면 안의값이 안사라지고 리턴되고(a.get(키))pop하면 안의값이 사라지고 리턴됨(a.pop(키))
		
		만약 키가 없으면 get은 none리턴,pop는 예외발생시킴
		
		내장 collections모듈에 defaultdict(int,list등 자료형)을쓰면 쉽게만들수있음
			a=defaultdict(list) #이러면 기본값이 리스트인 사전생성
			for word in 다른리스트:
				a[word[0]].append(word)#워드맨앞걸 키로 그거 추가
	
		사전의 값은 뭐든되는데,키는 바뀔수없는값(해시가능한값)이어야함(정수,실수,문자열,튜플(내부도 리스트같은거있으면안됨))즉 리스트안됨
	
	집합(set):
	집합은 원소만담은 정렬되지않은 자료형
	생성은 {}쓰거나 set()하면됨
	집합은 합집합,교집합,차집합등을 지원함
	집합|집합은 합집합
	집합&집합은 교집합
	집합-집합은 차집합
	집합^집합은 대칭차집합(합집합-교집합)
	add pop 지원하고 clear은 전체삭제 remove(x)는 x제거
	
	집합원소들도 사전처럼 내부에서 변경이 일어나면안됨(리스트 사용불가)참조객체필요하면 튜플로 전환해서넣어야함
	
	어떤집합이 부분집합인지 확대집합인지 알고싶으면
	a.issubset()
	a.issuperset()
	하면 tf로 나옴
	
	리스트 표기법:
	리스트를 반복문돌려서 새리스트를 만드는거
	a=[b(넣을값,함수적용가능) for b in 리스트 if 조건  ]
	ex) a=[b+1 for b in range(5) if b<3]
	리스트에서 인덱스,벨류로(enumerate써서)사전만들기같은거도 가능
	ex)a=[b:c for b,c in enumerate(리스트)]
	
	2중첩이상 리스트쓸땐 for문 두번쓰면됨
	a=[b for c in list for b in c if 조건]
	
		
	정렬:객체.sort() 객체.sorted()하면 정렬된게 리턴됨
	
	이진탐색:import bisect
		bisect는 정렬된 리스트에만 써야함(이진탐색이니),정렬체크는 안하고 이진탐색하니까(오류없이돌아가니까 정렬안해도) 정렬된거에만 쓰자
		bisect.bisect(객체,추가할값)으로 추가가능
		
	
	슬라이싱:리스트나 그런거[1:3]이런식으로 자르는것
		슬라이싱은 start에서 시작해 end-1까지 동작함
		[1:3]하면 리턴은 1과 2 2개 [2:3]하면 2 1개(0,1,2,3,4일때)
		슬라이싱된거에 리스트를 대입하는거도 가능함
		생략하면 맨앞,혹은 맨뒤[3:]이면 3번부터끝까지 [:3]이면 맨앞부터2번까지
		음수색인은 뒤에서부터 시작함
		[-1:]이면 맨뒤하나
		[-5:-2]면 맨뒤부터 5번째부터 맨뒤부터 2번째까지(역순은 0부터시작안하니까 그대로 2번째까지임)
		
		두번째콜론뒤에 숫자는 간격
		[::2]이면 하나걸러 하나씩 고르라는소리
		ex) a=[1,2,3,4,5,6,7,8]
			b=a[::2]
			print(b)#[1,3,5,7]
			
		기본리스트에선 2차원배열이상의 슬라이싱을 지원하지않고,넘파이를 써야함
		
	
	내장순차자료형함수
		enumerate:순차자료형에서 현재아이템의 인덱스를 같이뱉는함수
		for문에서 
			for value,index in enumerate(객체):
		하면 값과 인덱스를 같이뱉음
		
		zip:여러리스트를 하나로 합치거나(a=zip(b,c)),
		한리스트의 컬럼로우를 바꿀수있음(a,b=zip(*리스트) [[1,2],[3,4],[5,6]]을 [1,3,5][2,4,6]으로)
		
		reversed:reversed(a)하면 리스트 역순으로 생성해서 리턴함
		
	
	함수
		함수에선 리턴값이 몇개가되든 상관없음
		return a,b,c 된다는말
		
		기본적으로 함수내에선 지역스코프를 보지만,global로 전역으로 선언된변수는 참조가능
		함수내에서도 전역으로 선언하면 외부에서도 참조가능(정확히는 함수가 끝나고 사라지지않음)
	
		함수도 파이썬에선 객체취급이니까,리스트에 담아서 사용할수있음 
			fun=[함수1,함수2,함수3]
			for function in fun:
				v=fun()
		이런식으로사용가능
		
		람다:짧게 함수를 만드는거
			(lambda x:x*2 )이런식으로 씀,저거 하나가 함수객체하나(x를 받아서 x*2를 리턴)
			그냥 어렵게생각하지말고 함수 짧게만들고,맨앞에있는거만 받아서 연산후 바로리턴한다생각하자
		
		커링:람다를 써서 기존함수에서 특정패러미터를 상수로 바꾸는거
				add_five=lambda a:add_number(5,a)
			이렇게 특정값을 고정으로 바꿀수있음
		
			functool의 partial을쓰면 더쉽게할수잇대
		
		제너레이터:
			이터레이터를 나태하게 만드는 방식
			콜이 들어와야 다음으로 넘어감
			제너레이터를 생성하려면 return대신 yield씀
			
			더쉽게 만드려면 리스트표현식에서 괄호를쓰면 제너레이터가 생성됨(리스트표현식)
			제너레이터는 리스트를 받는 모든곳에서 사용가능
			
			
			itertools에 다양한 제너레이터함수들이 있음
			
			combinations(반복가능객체,길이) 객체에서 순서를 고려하지않고 길이가 k인 모든조합생성
			permutations(반복가능객체,길이) 객체에서 순서를 고려해서 길이가 k인 모든조합생성
			groupby(반복가능객체,[,키함수]) 객체에서 키에따라 그륩생성
			product(반복가능객체,repeat) 객체에서 카테시안곱(두개를 모두 곱함,sql조인에서 조건없을때 나오는거)을 리턴 
	
	
		예외처리:
			try except finally로 처리
			
	
	
	
	파일처리
		f=open(패스(상대경로나 절대경로))로 열어서
		f.close()로 닫아줘야함
		open(패스,'w')하면 쓰기모드
		
		이미지열거면 import Image로 열면됨
	
	
5.numpy
	넘파이배열에서 스칼라값(정수 실수등 값하나)를 연산하면,배열전체에 같은연산을 하고
	배열끼리 곱하거나 더하거나 하면 같은위치의 원소끼리 연산함
	그두개의 크기(shape)는 같아야함
	
	배열생성은 np.array()에 리스트같은거 넣거나,np.zeros,np.ones,np.full(인자로 채울거받아서 그거로채움)등으로 생성
	
	배열.dtype로 타입볼수있음
	넘파이 타입은 알아서 추론하는데,타입이 하위레벨에 맞춰져있어서 c같은거랑 연동쉽고 하드에서 받아올때도 코스트가낮음
	
	배열.astype(np.int32)이런식으로 배열전체의 형변환 가능,실수를 정수로바꾸면 소수점 다 버려짐
	숫자문자열('1.0')을 숫자로 바꿀수도있음
	
	만약 변환실패하면 valueerror예외발생함
	
	
	벡터화
		넘파이배열은 for문을 쓰지않고 데이터를 일괄처리할수있음
		이렇게쓰면 연산도 엄청빠름
		
		배열에 스칼라값하면 전체에 연산,배열끼리연산하면 그위치에 연산,같은크기배열끼리 비교하면 불리언배열 반환
		
		
	슬라이싱
		넘파이는 2차원이상의슬라이싱[:,:]이 가능
		그리고 넘파이에서 슬라이싱한건 뷰이기때문에,슬라이싱한걸 수정하면 그게 원본에도 동일하게 적용됨(데이터가 복사되지않음)
		데이터를 복사하고싶으면 arr[5:8].copy()해야함
		
		
	불리언값 선택
		배열의 인덱스[]에 불리언배열을 넣으면,그거에 해당하는거만 리턴해줌
		배열에 다른배열비교식 value[name>0] 넣으면 불리언배열로 T인거만 리턴함
		단 이러면,배열크기가 서로 달라도 에러안뜨니 주의해야함
		
		그리고 2차원이상에서 value[name>0,:2]이런식으로 선택된거 슬라이스하는거도 가능
		
		만약 이차원배열에서 value[value<3]이런식으로 넣으면,만족하는값 전부 일차원배열로 바꿔서 나옴
			123
			456  -> d[d>3] ->  array([4, 5, 6, 7, 8, 9])
			789
		
		그리고 and와 or예약어는 못쓰고,&과|써야함
		
		
	팬시색인
		팬시색인은 배열에서 여러줄을 선택할때 쓰는방법
		arr[3,4,2,8]
		하면 3번4번2번8번순으로 배열이 나옴
		
		그리고 2차원이상을 팬시색인쓰려면
		arr[[1,3,2,4],[2,1,3,4]]이렇게하면 (1,3),(3,1),(2,3),(4,4)원소가 나오고,
		슬라이싱하려면
		arr[[1,3,2,4]]][:,[2,1,3,4]]
		이런식으로 슬라이싱해야함
		
		팬시색인은 슬라이싱과 다르게 뷰가아니라 복사함
		
		
	배열전치
		배열의 모양을 바꿈
		arr.reshape()는 배열요소 전체를 1차원으로 푼다음에 그걸 다시 묶는느낌으로 동작함
		arr.T()는 배열의 가로세로를 돌림
			123	   147
			456 -> 258
			789	   369
		배열곱연산칠때 사용됨(np.dot())
		
		다차원배열은 arr.transpose()로 돌릴수있음
		배열의 축번호를 앞에서부터 순서대로 넣으면 됨(3차원일떄 (0,1,2)가 원본 ->(2,1,0))
		
	
	유니버셜함수
		유니버셜함수는 배열안에있는 원소별로 연산하는함수
		배열내 최대값,배열제곱근씌우기등
		
		유니버셜함수중 인자가 두개면(배열2개를가져가면)이항 유니버셜함수,하나면 단항유니버셜함수
		
		np.sqrt()같은게 대표적 단항유니버셜함수
		np.maximum(배열두개비교해서 둘중 큰원소 리턴,크기다르면 있는거리턴)이 대표적 이항유니버셜함수
		
		대표적으로 쓸만한게 
		np.maximum
		np.mininum
		np.mod(나머지)
		np.copysign(첫배열원소의 기호를 두번째배열원소의 기호로 바꿈)
		
	배열지향 프로그래밍
		순수파이썬쓰는거보다 배열연산으로 하는게(벡터화) 훨씬빠름
		
		배열연산으로 조건문쓰고싶으면 np.wrere쓰면됨
		np.wrere(tf배열,통과시,실패시)
		
		
		mean이나 sum엔 축을받아서 그축에대한 통계를 적을수있음
			123
			456  ->a.sum(1)= [6,15,24] a.sum(0)=[12,15,18]
			789
		
		cumsum은 0,0부터 끝까지의 누적합
			1 3 6
			101521
			283645
		cumprod는 끝까지 누적곱
		
		그리고 배열로 불리언배열로 만든상태(arr>0)에서 sum같은 메서드를 쓸수있음
			(arr>0).sum()
		any는 t가 하나이상있으면 트루 all은 전부트루면 트루
		any,all은 불리언배열이 아니라도 동작하는데,0이면 flase 0이아니면 true
		
		정렬은 arr.sort()로 할수있음
		arr.sort(axis= )axis로 축으로 정렬할수있음
		2차원에서 0넣으면 세로축끼리 비교해서 정렬함
			
	
		np.unique(배열)하면 배열내 있는 값 하나씩 정렬해서 리턴함 
		np.in1d(x,y)하면 x의 원소가 y에 포함되어있는지 불리언배열을 리턴함 
		
		
	배열 파일입출력
		np.save와 np.load로 배열데이터를 디스크에 저장하고 불러올수있음
		배열은 압축되지않은 바이너리형식으로 저장됨
		
		
	선형대수
		행렬곱하려면 x.dot(y)이런식으로 할수있음
	
	난수생성
		난수는 np.random으로 만들수있음
		np.random.normal((4,4))는 4,4크기의 표준정규분포 배열을생성 
		만약 시드를 바꾸고싶으면 np.random.seed()로 바꿀수있음
		
		기본적으로 모든난수는 동일시드값을 사용하는데,지역시드값으로 만들고싶으면
		numpy.random.RandomState(시드)로 격리된 난수 생성기를 만들수잇음
	
	
	
	
6.pandas
1.기본자료구조
	1.series
		판다스의 딕셔너리구조
		색인이있고 값이 있음
		
		색인으로 검색할때['a'] 여러개를 묶어도되고['a','b','c'] 
		슬라이스도 됨['a':'c']이땐 a부터 c까지 전부 출력됨
		불리언값도 됨arr[arr>0]
		
		색인의 순서를 바꾸고싶으면,원하는순서대로 pd.series(데이터, index=[,,])에 넣으면됨
		만약 데이터에 색인이 있으면,인덱스 순서대로 들어가고,인덱스에 없는값은 제거됨,인덱스엔있는데 데이터엔 없으면 nan됨
		
		널값 찾으려면 isnull이나 notnull으로 찾으면됨(pd.isnull(시리즈))
		
		색인은 대입하여 변경할수있음 arr.index=['q','w','e','r']
		0 a      q a
		1 b   -> w b
		2 c      e c
		3 d      r d
		
		시리즈는 name속성이 있는데 대입해서 바꿀수있음
		
	2.dataframe
		시리즈를 여러개 묶어둔,db같은느낌임
		로우와 컬럼이 있는 2차원배열
		
		생성할때 명시적으로 인덱스를 안주면,앞에서부터 묶어서 한로우씩으로 처리함
		dataframe.head()는 앞에서부터 5개만 출력하는거
		
		원하는 순서대로 컬럼 지정하면,컬럼순서를 바꿀수있음(pd.dataframe(data,columns=['a','c','b']))
		데이터에 없는값을 지정하면 nan으로 저장됨
		
		데이터를 받을땐,['year']이렇게 컬럼을 받을수도있고(인덱스랑 컬럼으로 나옴 ),frame.year 이렇게 받을수도있음
		이렇게 받으면 시리즈객체로 리턴되게되고,네임에 컬럼명이 적힘
		로우를 받고싶으면,frame.loc(인덱스명)으로 받을수있음
		
		컬럼은 대입이 가능함,대입하면 그줄 전체가 같은값이되고,이터레이터값을 주면 위부터 순서대로 들어감
		대입을할때는 대입하려는 길이가 데이터프레임의 길이와 같아야함
		시리즈를 대입하면 데이터프레임의 색인에따라 값이 대입되고(서로같은색인에 대입),존재하지않는 색인은 nan이 대입됨
		존재하지않는 컬럼을 대입하면 컬럼을 추가함,삭제는 del로 삭제
		당연하지만 컬럼에 값넣을떈 불리언값도(frame.state=='abcd')가능함,이러면 그줄의 스테이트값을 보고 tf결정함
		
		중첩된 사전으로 데이터프레임을 만들땐,밖에있는키가 컬럼이되고,안에있는키가 인덱스가 되는데,frame.T로 바꿀수있음
		묵시적으로 두면 안쪽에있는값에서 같은색인끼리 묶지만,명시적으로 색인주면 없는거무시하고 빈거 nan넣음
		
		만약 name속성을 지정하면(컬럼인덱스 모두)표시할때 그거도 같이표시됨
		
		frame.value하면 2차원배열로 저장된데이터 전부 리턴함
		만약 컬럼이 서로 다른데이터타입을 가지고있으면,배열로 리턴함
	
	3.색인객체
		색인객체는 시리즈나 데이터프레임에서,인덱스이름과 컬럼이름,name등 메타데이터를 모아둔객체임
		얘는 직접 변경이 불가능함(대입같은거안됨)
		
		그리고 판다스의 인덱스는,중복되는값이 허용됨
		중복되는값으로 선택을하면 해당값의 모든항목이 선택됨


2.핵심기능
	1.재색인
		재색인을 하면 새로운 색인배열에 맞게 객체를 새로 생성함
			frame2=frame.reindex([색인배열])
		여기서 프레임에 있는색인에 따른 값을 색인배열의 순서대로 재배열하고,존재하지않는 색인값이 있으면 nan을넣음
		
		만약 nan을 특정값으로 채우고싶으면 매개변수 method=''에 값을넣으면됨 ffill넣으면 이전값으로 채우기 bfill은 다음값으로채우기 등
		재색인 함수 인자는 여러개있으니 찾아보자(200P)
		
		reindex는 인덱스와 컬럼 둘다 변경이 가능함
		그냥 매개변수 명시하지않고 넣으면 인덱스를 재색인함
		
	2.하나의 로우나 컬럼 삭제
		로우는 frame.drop('a')로 삭제가능 여러개는 frame.drop(['a','b'])
		컬럼삭제는 frame.drop('컬럼명',axis=1)주면됨
		drop나 이런 크기나 형태변경하는 함수는,새로운 객체를 반환하는게 아닌,기존원본객체를 변경함
		
		만약 inplace옵션을 true로 주면 버려지는값을 모두 삭제함(즉각적으로 반영됨)
		
	3.색인선택
		색인선택은 조건줄수도있고,색인명선택,색인위치선택,슬라이스 다됨
		데이터프레임에서 컬럼으로 슬라이스해서 가져올수도있음
		
		색인과 컬럼을 둘다선택할수도있는데 frame.loc나 frame.iloc쓰면됨
		loc는 스트링으로 선택 iloc는 정수로 선택
			frame.loc[로우,[컬럼]]
			frame.iloc[1,[3,0,1]]
		당연히 슬라이스도 되고 단일라벨등 다됨
	
	4.정수색인
		판다스에서 색인검색할때,숫자로찾으면 라벨검색하고 그다음 정수검색하니까 버그생길수있으니까,loc나 iloc쓰자
		
	5.산술연산과 정렬
		두 시리즈나 데이터프레임끼리 연산을(+같은)하면
		두개 공통으로 가지고있는 색인에 대해서 연산을하고,한쪽이 없는건 nan으로 추가됨 
		sql에서 조건없이 join한느낌
		즉,공통되는게 아무것도없는 두 프레임을 더하면 전부 nan이됨
		
		만약 nan값을 특정값으로 채워넣고싶으면
		frame1.add(frame2,fill_value=0) 저렇게 fill_value를 넣어주면됨
		재색인할때도 fill_value를 넣을수있음
		add sub mul div floordiv 등이 있음 기본사칙연산+mod
		
		데이터프레임과 시리즈끼리 연산을 하면 로우나 컬럼중 한군데씩 잡고 쭉 밀어버림
		축선택은 프레임.sub(시리즈,axis=축선택)저렇게하면됨
		
	6.함수적용과 매핑
		판다스에도 넘파이의 유니버셜함수를 적용할수있음
			np.abs(frame) 이런식
		
		그리고 각 컬럼과 로우의 1차원배열에 함수를 적용할수도 있음
		dataframe의 apply쓰면됨
			frame.apply(적용람다함수,axis=적용축)
		
		여기서 리턴값은 스칼라값이 아니라 시리즈를 반환해도됨(배열리턴해도 된다는소리)
		
		그리고 각 원소마다 적용하고싶으면(부호바꾼다던지) 
			frame.applymap(람다함수)쓰면됨
		
	7.정렬과 순위
		정렬은 sort_index쓰면됨
			frame.sort_index(axis=정렬축,ascending=False 내림차순 오름차순 기본값 오름차순)
		하면 숫자,알파벳으로 정렬됨
		
		만약 시리즈객체를 밸류에따라 정렬하고싶으면
			sort_value()쓰면됨
		데이터프레임에서 밸류정렬하고싶으면 by=컬럼이름 주면됨
		
		기본적으로 nan은 맨 마지막에 위치함
		
		순위는 처음부터 끝까지의 순위를 리턴해줌
		처음부터 끝까지중 숫자 가장 작은거부터 큰거까지 순위매기는거(그인덱스값에 순위매겨서 리턴)
		동점일때 기본적으론 평균값인데 나타나는순서에 따라 매기려면 매개변수 method='first'하면됨

		
	8.중복색인	
		중복색인값인지 체크하려면 frame.index.is_unique()하면 중복이 있는지아닌지 리턴해줌
		그리고 중복값이 아닌걸 데이터에 접근하면 스칼라값리턴하지만,중복인걸 접근하면 시리즈객체 리턴함
		
		
		
3.통계와 요약
	판다스는 기본적으로 통계메서드가 있음
	프레임.sum하면 각 컬럼에 합을담은 시리즈를 반환하고
	axis=1주면 각 로우의 합을 반환함
	
	기본적으로 nan값은 무시되고,skipna로 무시하지 않을수있음
	
	idxmin이나 idxmax같은 메서드는,최솟값,혹은 최대값을 가지고있는 인덱스를 리턴함
	
	그외엔 cumsum(순서대로더하기)등이 있음
	
	그거말곤 describe()가 있는데,이건 여러 통계결과를 리턴함
	수치데이터일경우 카운트 평균 맥스 민 25% 50% 등등
	수치데이터가 아니면 카운트 유니크 탑 freq 등
	
	여러개있으니까 찾아보자
	
	
	pandas_datareader로 웹데이터 받아올수있음
	
	corr로 각 컬럼별 상관관계를 계산할수있고,cov로 공분산을 계산할수있음
	
	unique메서드는 중복값을 제거하고 유일값만 담은 시리즈를 반환함
	이건 정렬안되어있지만 알아서 나중에정렬하면됨
	pd.value_counts()는 그 값이 몇개있는지 내림차순으로 정렬함
	
	frame.isin([배열])은배열안의값이 프레임에 있는지없는지에 따라 불리언배열을 리턴함 
	
	
	
7.데이터입출력,파일형식
	read_csv
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	