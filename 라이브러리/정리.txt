2.주피터명령어
	%run으로 외부파이썬프로그램을 실행시킬수있음(.py)
	%timeit로 실행시간체크가능(1000회루프평균)
	%time은 단일실행시간체크
	1.매트랩
		%matplotlib inline:아웃풋에 plt.plot로 바로출력가능
	
3.파이썬명령어	
	속성과 메서드는 getattr(객체,'메서드명')으로 스트링으로 접근할수도잇음
	
	만약 순회가 가능한(for문으로 집어넣어서 뺼수잇는)거면 iter(객체)해서 확인가능
	
	임포트할땐 그냥 같은디렉터리안에있으면 import abc 해서(abc.py파일)사용가능
	
	두참조변수가 같은값가리키는지 확인하려면 a is b하면 tf로 뱉음
	즉,딥카피했을때 ==로 같은게 a is b 하면 false가 나올수있음
	a is None는 변수비어있는지 확인할때 자주씀

	문자열과 튜플은 변경불가능한(상수)객체임
	
	만약 문자열에 역슬래시같은 특수기호 많이들어가면 문자열앞에 r붙여서 (r'\'fds') 그냥 생으로 처리가능
	
	문자열.format은'a{0:s}{1:1f}{2:d}'이건 뒤에 나오는 변수를 저기대입하라는거(순서:형식)
	문자열.format('a',1,1)하면 aa11리턴됨
	즉 문자열파싱해서 저거대입함
	
	날짜와 시간쓸떈 datetime임포트해서 쓰면됨
	그냥 date()time()쓰면 datetime객체로 리턴되고,strftime()하면 스트링으로 리턴되는데 그냥 date로받아서 스트링으로 변환해도됨
	strptime는 스트링을 datetime객체로 변형시켜줌
	timedelta객체를 datetime에 더하거나 빼거나해서 변형시킬수있음
	
	pass는 if문이나 그런 블럭안에 비어있을때 넣어두면 그냥스킵하고지나감(비워두면 블록에러뜸 공백문자땜에)
	
	range는 마지막숫자 바로앞까지(range(8)이면 0~7까지)반복
	
	삼항표현식은 a=트루값 if 조건 else 펠스값
	으로 if문 좀 편하게적게해줌
	
4.자료구조등
	튜플:상수화시킨 리스트
		튜플을 한번확정하면 거기에 추가나 제거불가능
		단 내부개체가 리스트처럼 객체일경우 참조하고있는곳에 추가제거는 가능
		튜플을 곱하면 튜플의 복사본이 반복되어 늘어남
		
		튜플과 같은표현의 변수의 갯수를 맞춰서 =해주면,튜플이 분리되서 변수에 들어감
		ex) a=(1,2,3)
			b,c,d=a
			print(b,c,d)#1 2 3
		중첩된튜플의경우
		ex) a=(1,2,(3,4))
			b,c,(d,e)=a
			print(b,c,d,e)#1 2 3 4	
		
		스왑도 그냥
			a,b=b,a
		하면 스왑됨
		
		for문같은거도(중첩된리스트나 튜플 순회할때)
		저렇게 한덩어리씩 빼서 내부값 사용가능
		ex) a=[(1,2),(3,4),(5,6)]
			for b,c in a:
			...
		
		만약 *변수를해서 꺼내면,뒤에있는값 전부를 받아옴     ☆
		ex) a=(1,2,3,4,5,6,7)
			b,c,*d=a
			print(b,c,d)#1 2 [3,4,5,6,7]	
			
		튜플.count('a') a갯수세기
	리스트:크기내용변경이 가능한 참조객체
		append로 맨뒤에추가,insert(위치,내용)으로 원하는위치에 추가(값은 인서트가 더 비싸니까 어지간하면 어펜드(순서안중요하면))맨앞에추가하려면 deque쓰자
		remove로 맨앞삭제 pop(위치)로 원하는위치삭제
		
		in으로 리스트에 어떤값 있는지 확인가능 (TF로 리턴)
		리스트.extend()로 여러값 추가가능(기존리스트에 추가)
		리스트를 +로 이어붙이면 새 리스트를 생성하고 값을복사하니까,코스트생각해야되면 extend로 기존값 추가하는게 더 쌈
	
	사전(dict):키 밸류로 이루어진 해시객체
		리스트처럼 값에 접근하거나 값을 넣을수있고,추가할수있음
		밸류는 기본적으로 하나지만,리스트같은 참조객체가 들어간경우 그안엔 여러개가 들어갈수있음
		삭제는 del이나 pop메서드로 함
		update로 사전을 합칠수있음(만약 같은키가 있으면 이거로 덮어씌워짐)
		그냥 인서트는 사전[키]=밸류 하면 추가됨
		
		사전.keys와 사전.values는 키이터레이터와 밸류이터레이터를 반환하니까,리스트캐스팅해서 보면됨
		정렬은 안되어있긴한데,keys와 values의 순서는 같음
		
		리스트2개를 사전으로 합치려면 for문돌려도되지만,a=dict(키배열,값배열)하면 사전나옴
		
		안에서 값 뽑을때는 get하면 안의값이 안사라지고 리턴되고(a.get(키))pop하면 안의값이 사라지고 리턴됨(a.pop(키))
		
		만약 키가 없으면 get은 none리턴,pop는 예외발생시킴
		
		내장 collections모듈에 defaultdict(int,list등 자료형)을쓰면 쉽게만들수있음
			a=defaultdict(list) #이러면 기본값이 리스트인 사전생성
			for word in 다른리스트:
				a[word[0]].append(word)#워드맨앞걸 키로 그거 추가
	
		사전의 값은 뭐든되는데,키는 바뀔수없는값(해시가능한값)이어야함(정수,실수,문자열,튜플(내부도 리스트같은거있으면안됨))즉 리스트안됨
	
	집합(set):
	집합은 원소만담은 정렬되지않은 자료형
	생성은 {}쓰거나 set()하면됨
	집합은 합집합,교집합,차집합등을 지원함
	집합|집합은 합집합
	집합&집합은 교집합
	집합-집합은 차집합
	집합^집합은 대칭차집합(합집합-교집합)
	add pop 지원하고 clear은 전체삭제 remove(x)는 x제거
	
	집합원소들도 사전처럼 내부에서 변경이 일어나면안됨(리스트 사용불가)참조객체필요하면 튜플로 전환해서넣어야함
	
	어떤집합이 부분집합인지 확대집합인지 알고싶으면
	a.issubset()
	a.issuperset()
	하면 tf로 나옴
	
	리스트 표기법:
	리스트를 반복문돌려서 새리스트를 만드는거
	a=[b(넣을값,함수적용가능) for b in 리스트 if 조건  ]
	ex) a=[b+1 for b in range(5) if b<3]
	리스트에서 인덱스,벨류로(enumerate써서)사전만들기같은거도 가능
	ex)a=[b:c for b,c in enumerate(리스트)]
	
	2중첩이상 리스트쓸땐 for문 두번쓰면됨
	a=[b for c in list for b in c if 조건]
	
		
	정렬:객체.sort() 객체.sorted()하면 정렬된게 리턴됨
	
	이진탐색:import bisect
		bisect는 정렬된 리스트에만 써야함(이진탐색이니),정렬체크는 안하고 이진탐색하니까(오류없이돌아가니까 정렬안해도) 정렬된거에만 쓰자
		bisect.bisect(객체,추가할값)으로 추가가능
		
	
	슬라이싱:리스트나 그런거[1:3]이런식으로 자르는것
		슬라이싱은 start에서 시작해 end-1까지 동작함
		[1:3]하면 리턴은 1과 2 2개 [2:3]하면 2 1개(0,1,2,3,4일때)
		슬라이싱된거에 리스트를 대입하는거도 가능함
		생략하면 맨앞,혹은 맨뒤[3:]이면 3번부터끝까지 [:3]이면 맨앞부터2번까지
		음수색인은 뒤에서부터 시작함
		[-1:]이면 맨뒤하나
		[-5:-2]면 맨뒤부터 5번째부터 맨뒤부터 2번째까지(역순은 0부터시작안하니까 그대로 2번째까지임)
		
		두번째콜론뒤에 숫자는 간격
		[::2]이면 하나걸러 하나씩 고르라는소리
		ex) a=[1,2,3,4,5,6,7,8]
			b=a[::2]
			print(b)#[1,3,5,7]
			
		기본리스트에선 2차원배열이상의 슬라이싱을 지원하지않고,넘파이를 써야함
		
	
	내장순차자료형함수
		enumerate:순차자료형에서 현재아이템의 인덱스를 같이뱉는함수
		for문에서 
			for value,index in enumerate(객체):
		하면 값과 인덱스를 같이뱉음
		
		zip:여러리스트를 하나로 합치거나(a=zip(b,c)),
		한리스트의 컬럼로우를 바꿀수있음(a,b=zip(*리스트) [[1,2],[3,4],[5,6]]을 [1,3,5][2,4,6]으로)
		
		reversed:reversed(a)하면 리스트 역순으로 생성해서 리턴함
		
	
	함수
		함수에선 리턴값이 몇개가되든 상관없음
		return a,b,c 된다는말
		
		기본적으로 함수내에선 지역스코프를 보지만,global로 전역으로 선언된변수는 참조가능
		함수내에서도 전역으로 선언하면 외부에서도 참조가능(정확히는 함수가 끝나고 사라지지않음)
	
		함수도 파이썬에선 객체취급이니까,리스트에 담아서 사용할수있음 
			fun=[함수1,함수2,함수3]
			for function in fun:
				v=fun()
		이런식으로사용가능
		
		람다:짧게 함수를 만드는거
			(lambda x:x*2 )이런식으로 씀,저거 하나가 함수객체하나(x를 받아서 x*2를 리턴)
			그냥 어렵게생각하지말고 함수 짧게만들고,맨앞에있는거만 받아서 연산후 바로리턴한다생각하자
		
		커링:람다를 써서 기존함수에서 특정패러미터를 상수로 바꾸는거
				add_five=lambda a:add_number(5,a)
			이렇게 특정값을 고정으로 바꿀수있음
		
			functool의 partial을쓰면 더쉽게할수잇대
		
		제너레이터:
			이터레이터를 나태하게 만드는 방식
			콜이 들어와야 다음으로 넘어감
			제너레이터를 생성하려면 return대신 yield씀
			
			더쉽게 만드려면 리스트표현식에서 괄호를쓰면 제너레이터가 생성됨(리스트표현식)
			제너레이터는 리스트를 받는 모든곳에서 사용가능
			
			
			itertools에 다양한 제너레이터함수들이 있음
			
			combinations(반복가능객체,길이) 객체에서 순서를 고려하지않고 길이가 k인 모든조합생성
			permutations(반복가능객체,길이) 객체에서 순서를 고려해서 길이가 k인 모든조합생성
			groupby(반복가능객체,[,키함수]) 객체에서 키에따라 그륩생성
			product(반복가능객체,repeat) 객체에서 카테시안곱(두개를 모두 곱함,sql조인에서 조건없을때 나오는거)을 리턴 
	
	
		예외처리:
			try except finally로 처리
			
	
	
	
	파일처리
		f=open(패스(상대경로나 절대경로))로 열어서
		f.close()로 닫아줘야함
		open(패스,'w')하면 쓰기모드
		
		이미지열거면 import Image로 열면됨
	
	
	
	
	
	
	
	
	
	