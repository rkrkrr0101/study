2.주피터명령어
	%run으로 외부파이썬프로그램을 실행시킬수있음(.py)
	%timeit로 실행시간체크가능(1000회루프평균)
	%time은 단일실행시간체크
	1.매트랩
		%matplotlib inline:아웃풋에 plt.plot로 바로출력가능
	
3.파이썬명령어	
	속성과 메서드는 getattr(객체,'메서드명')으로 스트링으로 접근할수도잇음
	
	만약 순회가 가능한(for문으로 집어넣어서 뺼수잇는)거면 iter(객체)해서 확인가능
	
	임포트할땐 그냥 같은디렉터리안에있으면 import abc 해서(abc.py파일)사용가능
	
	두참조변수가 같은값가리키는지 확인하려면 a is b하면 tf로 뱉음
	즉,딥카피했을때 ==로 같은게 a is b 하면 false가 나올수있음
	a is None는 변수비어있는지 확인할때 자주씀

	문자열과 튜플은 변경불가능한(상수)객체임
	
	만약 문자열에 역슬래시같은 특수기호 많이들어가면 문자열앞에 r붙여서 (r'\'fds') 그냥 생으로 처리가능
	
	문자열.format은'a{0:s}{1:1f}{2:d}'이건 뒤에 나오는 변수를 저기대입하라는거(순서:형식)
	문자열.format('a',1,1)하면 aa11리턴됨
	즉 문자열파싱해서 저거대입함
	
	날짜와 시간쓸떈 datetime임포트해서 쓰면됨
	그냥 date()time()쓰면 datetime객체로 리턴되고,strftime()하면 스트링으로 리턴되는데 그냥 date로받아서 스트링으로 변환해도됨
	strptime는 스트링을 datetime객체로 변형시켜줌
	timedelta객체를 datetime에 더하거나 빼거나해서 변형시킬수있음
	
	pass는 if문이나 그런 블럭안에 비어있을때 넣어두면 그냥스킵하고지나감(비워두면 블록에러뜸 공백문자땜에)
	
	range는 마지막숫자 바로앞까지(range(8)이면 0~7까지)반복
	
	삼항표현식은 a=트루값 if 조건 else 펠스값
	으로 if문 좀 편하게적게해줌
	
4.자료구조등
	튜플:상수화시킨 리스트
		튜플을 한번확정하면 거기에 추가나 제거불가능
		단 내부개체가 리스트처럼 객체일경우 참조하고있는곳에 추가제거는 가능
		튜플을 곱하면 튜플의 복사본이 반복되어 늘어남
		
		튜플과 같은표현의 변수의 갯수를 맞춰서 =해주면,튜플이 분리되서 변수에 들어감
		ex) a=(1,2,3)
			b,c,d=a
			print(b,c,d)#1 2 3
		중첩된튜플의경우
		ex) a=(1,2,(3,4))
			b,c,(d,e)=a
			print(b,c,d,e)#1 2 3 4	
		
		스왑도 그냥
			a,b=b,a
		하면 스왑됨
		
		for문같은거도(중첩된리스트나 튜플 순회할때)
		저렇게 한덩어리씩 빼서 내부값 사용가능
		ex) a=[(1,2),(3,4),(5,6)]
			for b,c in a:
			...
		
		만약 *변수를해서 꺼내면,뒤에있는값 전부를 받아옴     ☆
		ex) a=(1,2,3,4,5,6,7)
			b,c,*d=a
			print(b,c,d)#1 2 [3,4,5,6,7]	
			
		튜플.count('a') a갯수세기
	리스트:크기내용변경이 가능한 참조객체
		append로 맨뒤에추가,insert(위치,내용)으로 원하는위치에 추가(값은 인서트가 더 비싸니까 어지간하면 어펜드(순서안중요하면))맨앞에추가하려면 deque쓰자
		remove로 맨앞삭제 pop(위치)로 원하는위치삭제
		
		in으로 리스트에 어떤값 있는지 확인가능 (TF로 리턴)
		리스트.extend()로 여러값 추가가능(기존리스트에 추가)
		리스트를 +로 이어붙이면 새 리스트를 생성하고 값을복사하니까,코스트생각해야되면 extend로 기존값 추가하는게 더 쌈
	
	사전(dict):키 밸류로 이루어진 해시객체
		리스트처럼 값에 접근하거나 값을 넣을수있고,추가할수있음
		밸류는 기본적으로 하나지만,리스트같은 참조객체가 들어간경우 그안엔 여러개가 들어갈수있음
		삭제는 del이나 pop메서드로 함
		update로 사전을 합칠수있음(만약 같은키가 있으면 이거로 덮어씌워짐)
		그냥 인서트는 사전[키]=밸류 하면 추가됨
		
		사전.keys와 사전.values는 키이터레이터와 밸류이터레이터를 반환하니까,리스트캐스팅해서 보면됨
		정렬은 안되어있긴한데,keys와 values의 순서는 같음
		
		리스트2개를 사전으로 합치려면 for문돌려도되지만,a=dict(키배열,값배열)하면 사전나옴
		
		안에서 값 뽑을때는 get하면 안의값이 안사라지고 리턴되고(a.get(키))pop하면 안의값이 사라지고 리턴됨(a.pop(키))
		
		만약 키가 없으면 get은 none리턴,pop는 예외발생시킴
		
		내장 collections모듈에 defaultdict(int,list등 자료형)을쓰면 쉽게만들수있음
			a=defaultdict(list) #이러면 기본값이 리스트인 사전생성
			for word in 다른리스트:
				a[word[0]].append(word)#워드맨앞걸 키로 그거 추가
	
		사전의 값은 뭐든되는데,키는 바뀔수없는값(해시가능한값)이어야함(정수,실수,문자열,튜플(내부도 리스트같은거있으면안됨))즉 리스트안됨
	
	집합(set):
	집합은 원소만담은 정렬되지않은 자료형
	생성은 {}쓰거나 set()하면됨
	집합은 합집합,교집합,차집합등을 지원함
	집합|집합은 합집합
	집합&집합은 교집합
	집합-집합은 차집합
	집합^집합은 대칭차집합(합집합-교집합)
	add pop 지원하고 clear은 전체삭제 remove(x)는 x제거
	
	집합원소들도 사전처럼 내부에서 변경이 일어나면안됨(리스트 사용불가)참조객체필요하면 튜플로 전환해서넣어야함
	
	어떤집합이 부분집합인지 확대집합인지 알고싶으면
	a.issubset()
	a.issuperset()
	하면 tf로 나옴
	
	리스트 표기법:
	리스트를 반복문돌려서 새리스트를 만드는거
	a=[b(넣을값,함수적용가능) for b in 리스트 if 조건  ]
	ex) a=[b+1 for b in range(5) if b<3]
	리스트에서 인덱스,벨류로(enumerate써서)사전만들기같은거도 가능
	ex)a=[b:c for b,c in enumerate(리스트)]
	
	2중첩이상 리스트쓸땐 for문 두번쓰면됨
	a=[b for c in list for b in c if 조건]
	
		
	정렬:객체.sort() 객체.sorted()하면 정렬된게 리턴됨
	
	이진탐색:import bisect
		bisect는 정렬된 리스트에만 써야함(이진탐색이니),정렬체크는 안하고 이진탐색하니까(오류없이돌아가니까 정렬안해도) 정렬된거에만 쓰자
		bisect.bisect(객체,추가할값)으로 추가가능
		
	
	슬라이싱:리스트나 그런거[1:3]이런식으로 자르는것
		슬라이싱은 start에서 시작해 end-1까지 동작함
		[1:3]하면 리턴은 1과 2 2개 [2:3]하면 2 1개(0,1,2,3,4일때)
		슬라이싱된거에 리스트를 대입하는거도 가능함
		생략하면 맨앞,혹은 맨뒤[3:]이면 3번부터끝까지 [:3]이면 맨앞부터2번까지
		음수색인은 뒤에서부터 시작함
		[-1:]이면 맨뒤하나
		[-5:-2]면 맨뒤부터 5번째부터 맨뒤부터 2번째까지(역순은 0부터시작안하니까 그대로 2번째까지임)
		
		두번째콜론뒤에 숫자는 간격
		[::2]이면 하나걸러 하나씩 고르라는소리
		ex) a=[1,2,3,4,5,6,7,8]
			b=a[::2]
			print(b)#[1,3,5,7]
			
		기본리스트에선 2차원배열이상의 슬라이싱을 지원하지않고,넘파이를 써야함
		
	
	내장순차자료형함수
		enumerate:순차자료형에서 현재아이템의 인덱스를 같이뱉는함수
		for문에서 
			for value,index in enumerate(객체):
		하면 값과 인덱스를 같이뱉음
		
		zip:여러리스트를 하나로 합치거나(a=zip(b,c)),
		한리스트의 컬럼로우를 바꿀수있음(a,b=zip(*리스트) [[1,2],[3,4],[5,6]]을 [1,3,5][2,4,6]으로)
		
		reversed:reversed(a)하면 리스트 역순으로 생성해서 리턴함
		
	
	함수
		함수에선 리턴값이 몇개가되든 상관없음
		return a,b,c 된다는말
		
		기본적으로 함수내에선 지역스코프를 보지만,global로 전역으로 선언된변수는 참조가능
		함수내에서도 전역으로 선언하면 외부에서도 참조가능(정확히는 함수가 끝나고 사라지지않음)
	
		함수도 파이썬에선 객체취급이니까,리스트에 담아서 사용할수있음 
			fun=[함수1,함수2,함수3]
			for function in fun:
				v=fun()
		이런식으로사용가능
		
		람다:짧게 함수를 만드는거
			(lambda x:x*2 )이런식으로 씀,저거 하나가 함수객체하나(x를 받아서 x*2를 리턴)
			그냥 어렵게생각하지말고 함수 짧게만들고,맨앞에있는거만 받아서 연산후 바로리턴한다생각하자
		
		커링:람다를 써서 기존함수에서 특정패러미터를 상수로 바꾸는거
				add_five=lambda a:add_number(5,a)
			이렇게 특정값을 고정으로 바꿀수있음
		
			functool의 partial을쓰면 더쉽게할수잇대
		
		제너레이터:
			이터레이터를 나태하게 만드는 방식
			콜이 들어와야 다음으로 넘어감
			제너레이터를 생성하려면 return대신 yield씀
			
			더쉽게 만드려면 리스트표현식에서 괄호를쓰면 제너레이터가 생성됨(리스트표현식)
			제너레이터는 리스트를 받는 모든곳에서 사용가능
			
			
			itertools에 다양한 제너레이터함수들이 있음
			
			combinations(반복가능객체,길이) 객체에서 순서를 고려하지않고 길이가 k인 모든조합생성
			permutations(반복가능객체,길이) 객체에서 순서를 고려해서 길이가 k인 모든조합생성
			groupby(반복가능객체,[,키함수]) 객체에서 키에따라 그륩생성
			product(반복가능객체,repeat) 객체에서 카테시안곱(두개를 모두 곱함,sql조인에서 조건없을때 나오는거)을 리턴 
	
	
		예외처리:
			try except finally로 처리
			
	
	
	
	파일처리
		f=open(패스(상대경로나 절대경로))로 열어서
		f.close()로 닫아줘야함
		open(패스,'w')하면 쓰기모드
		
		이미지열거면 import Image로 열면됨
	
	
5.numpy
	넘파이배열에서 스칼라값(정수 실수등 값하나)를 연산하면,배열전체에 같은연산을 하고
	배열끼리 곱하거나 더하거나 하면 같은위치의 원소끼리 연산함
	그두개의 크기(shape)는 같아야함
	
	배열생성은 np.array()에 리스트같은거 넣거나,np.zeros,np.ones,np.full(인자로 채울거받아서 그거로채움)등으로 생성
	
	배열.dtype로 타입볼수있음
	넘파이 타입은 알아서 추론하는데,타입이 하위레벨에 맞춰져있어서 c같은거랑 연동쉽고 하드에서 받아올때도 코스트가낮음
	
	배열.astype(np.int32)이런식으로 배열전체의 형변환 가능,실수를 정수로바꾸면 소수점 다 버려짐
	숫자문자열('1.0')을 숫자로 바꿀수도있음
	
	만약 변환실패하면 valueerror예외발생함
	
	
	벡터화
		넘파이배열은 for문을 쓰지않고 데이터를 일괄처리할수있음
		이렇게쓰면 연산도 엄청빠름
		
		배열에 스칼라값하면 전체에 연산,배열끼리연산하면 그위치에 연산,같은크기배열끼리 비교하면 불리언배열 반환
		
		
	슬라이싱
		넘파이는 2차원이상의슬라이싱[:,:]이 가능
		그리고 넘파이에서 슬라이싱한건 뷰이기때문에,슬라이싱한걸 수정하면 그게 원본에도 동일하게 적용됨(데이터가 복사되지않음)
		데이터를 복사하고싶으면 arr[5:8].copy()해야함
		
		
	불리언값 선택
		배열의 인덱스[]에 불리언배열을 넣으면,그거에 해당하는거만 리턴해줌
		배열에 다른배열비교식 value[name>0] 넣으면 불리언배열로 T인거만 리턴함
		단 이러면,배열크기가 서로 달라도 에러안뜨니 주의해야함
		
		그리고 2차원이상에서 value[name>0,:2]이런식으로 선택된거 슬라이스하는거도 가능
		
		만약 이차원배열에서 value[value<3]이런식으로 넣으면,만족하는값 전부 일차원배열로 바꿔서 나옴
			123
			456  -> d[d>3] ->  array([4, 5, 6, 7, 8, 9])
			789
		
		그리고 and와 or예약어는 못쓰고,&과|써야함
		
		
	팬시색인
		팬시색인은 배열에서 여러줄을 선택할때 쓰는방법
		arr[3,4,2,8]
		하면 3번4번2번8번순으로 배열이 나옴
		
		그리고 2차원이상을 팬시색인쓰려면
		arr[[1,3,2,4],[2,1,3,4]]이렇게하면 (1,3),(3,1),(2,3),(4,4)원소가 나오고,
		슬라이싱하려면
		arr[[1,3,2,4]]][:,[2,1,3,4]]
		이런식으로 슬라이싱해야함
		
		팬시색인은 슬라이싱과 다르게 뷰가아니라 복사함
		
		
	배열전치
		배열의 모양을 바꿈
		arr.reshape()는 배열요소 전체를 1차원으로 푼다음에 그걸 다시 묶는느낌으로 동작함
		arr.T()는 배열의 가로세로를 돌림
			123	   147
			456 -> 258
			789	   369
		배열곱연산칠때 사용됨(np.dot())
		
		다차원배열은 arr.transpose()로 돌릴수있음
		배열의 축번호를 앞에서부터 순서대로 넣으면 됨(3차원일떄 (0,1,2)가 원본 ->(2,1,0))
		
	
	유니버셜함수
		유니버셜함수는 배열안에있는 원소별로 연산하는함수
		배열내 최대값,배열제곱근씌우기등
		
		유니버셜함수중 인자가 두개면(배열2개를가져가면)이항 유니버셜함수,하나면 단항유니버셜함수
		
		np.sqrt()같은게 대표적 단항유니버셜함수
		np.maximum(배열두개비교해서 둘중 큰원소 리턴,크기다르면 있는거리턴)이 대표적 이항유니버셜함수
		
		대표적으로 쓸만한게 
		np.maximum
		np.mininum
		np.mod(나머지)
		np.copysign(첫배열원소의 기호를 두번째배열원소의 기호로 바꿈)
		
	배열지향 프로그래밍
		순수파이썬쓰는거보다 배열연산으로 하는게(벡터화) 훨씬빠름
		
		배열연산으로 조건문쓰고싶으면 np.wrere쓰면됨
		np.wrere(tf배열,통과시,실패시)
		
		
		mean이나 sum엔 축을받아서 그축에대한 통계를 적을수있음
			123
			456  ->a.sum(1)= [6,15,24] a.sum(0)=[12,15,18]
			789
		
		cumsum은 0,0부터 끝까지의 누적합
			1 3 6
			101521
			283645
		cumprod는 끝까지 누적곱
		
		그리고 배열로 불리언배열로 만든상태(arr>0)에서 sum같은 메서드를 쓸수있음
			(arr>0).sum()
		any는 t가 하나이상있으면 트루 all은 전부트루면 트루
		any,all은 불리언배열이 아니라도 동작하는데,0이면 flase 0이아니면 true
		
		정렬은 arr.sort()로 할수있음
		arr.sort(axis= )axis로 축으로 정렬할수있음
		2차원에서 0넣으면 세로축끼리 비교해서 정렬함
			
	
		np.unique(배열)하면 배열내 있는 값 하나씩 정렬해서 리턴함 
		np.in1d(x,y)하면 x의 원소가 y에 포함되어있는지 불리언배열을 리턴함 
		
		
	배열 파일입출력
		np.save와 np.load로 배열데이터를 디스크에 저장하고 불러올수있음
		배열은 압축되지않은 바이너리형식으로 저장됨
		
		
	선형대수
		행렬곱하려면 x.dot(y)이런식으로 할수있음
	
	난수생성
		난수는 np.random으로 만들수있음
		np.random.normal((4,4))는 4,4크기의 표준정규분포 배열을생성 
		만약 시드를 바꾸고싶으면 np.random.seed()로 바꿀수있음
		
		기본적으로 모든난수는 동일시드값을 사용하는데,지역시드값으로 만들고싶으면
		numpy.random.RandomState(시드)로 격리된 난수 생성기를 만들수잇음
	
	
	
	
6.pandas	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	