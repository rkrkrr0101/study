리턴html은 무조건 하나로 나가야됨
jsx내부에서 자바스크립트표현식 쓸려면 {}로 감싸면됨 {name}
jsx내부에서 표현식써도 if를 쓸순없고
a===b?( //맞을떄
): ( //else

)
이렇게써야함
뒤에 아무것도 안보여줄려면 :null하면됨
jsx내부에서 인라인으로 css건드릴떄는 -사라지고 그다음자 대문자해서 주고 문자열이아닌 객체로 줘야함
background-color은
backgroundColor:'black' 이런식

style은 밖에서 만들어가도되고 안에서 인라인으로 적어도되는데 인라인은
<div style={{
backgroundColor:'black'
...
}}
>
이런식으로 괄호2개치고 안에다적으면됨

밖에 css파일을 사용할떄는 
import'./a.css ' 하고나서
css파일에서 .classname{}했을떄 저 클래스이름과 같은거를 따라감

셀프클로저하고싶으면 <input/>

jsx안에서 주석은 {/*abc*/}

vscode 
eslint:문법검사도구
prettier:코드정렬도구

기본적으로 함수형 클래스형중에 es6들어오고나서는 함수형이 표준으로됐음

es6에서 화살표 함수가 생겼는데 화살표함수는 함수 자체의 this가 없기떄문에 스코프상 가장 가까운 생성자의 this를 가리키게됨
일반함수는 자기자신의 this가 있으니까 자기자신걸 가르킴

그래서 화살표함수는 메서드에 사용하면 안될거같음
기본적으로 함수랑 메서드가 .가지고 구분하는데 거기서 this가 객체냐 인스턴스냐 나눠지니까 그냥 함수로 통일하는게맞을거같음
(객체는 var tico=new car() 할떄 tico를 가르키고(선언시 객체) new car()해서 생성자로 할당되면 인스턴스)
(객체를 선언하고 객체를 인스턴스화 시키는게 var tico=new car()임)
(인스턴스는 객체에 포함되서 그냥보통 객체라고 부르는데 가끔 나눠불러야할떄가 있음 this나)

props는 매개변수
2.프롭타입설명
<mycompo name='abc'/>하면 name이 prop

받을때는
Mycompo=props =>{
	return{
			<div>
				{props.name}
			</div>

	}	

}
mycompo.defaultProps={{/* 디폴트설정*/}
	name:'default'

}

이렇게받고 쓰면됨

컴포넌트 따로 빼뒀는데 <mycompo>abc</mycompo>
저 중간값이 필요하면 props.children (예약어)쓰면됨

그리고 맨날 props붙이기 귀찮으니까
리턴 위에

const{name,children}=props
return(
...
)
하면 그냥 name만 쳐도됨(비구조화할당)

proptype 고정하려면 
import PropTypes from 'prop-types' 임포트하고

mycompo.propTypes={
	name:propTypes.string

}
이런식으로 지정받아서 만약 틀리면 에러메세지 개발자도구 콘솔창에 띄울수있음

mycompo.propTypes={
	name:propTypes.string
	a:propTypes.number.isRequired
}
isRequired하면 설정을 안했을때 (비어있을떄) 에러를띄움

그러니까 
propTypes.자료형은 들어오는지 안들어오는지는 체크안하지만 들어왔을때 자료형체크
propTypes.number.isRequired는 들어왔는지 안들어왔는지 체크 후 자료형체크
둘다 에러메세지만 띄우고 동작은됨 잘못넣어도

클래스에서 비구조화할당은 랜더밑 리턴위에 하면되고
proptypes는 똑같이 클래스밖에하면됨
3.스테이트 깊은복사
리액트에서는 얕은복사때문에 변수를쓸떄 값을 바꿀때 무조건 덮어씌우는식으로 해야해서 
함수형은 usestate처럼 후크로하고
클래스는 this.state={
	number:1
}
this.setState({number:number+1})이런식으로 스테이트 에 바뀐값 덮어씌우는식으로 함

단 
this.setState({number:number+1})
this.setState({number:number+1})
이렇게 2번있다고 2가 올라가는게 아니라 동기화전이라 1만올라가기때문에

this.setState((prevState,props)=>{
	return{
		업데이트내용
		number:prevState.number+1 
	}

}
이렇게 화살표함수를 인자로 넣어서 함수리턴값을 덮어씌우면됨

함수형에서는 
const[name,setname]=useState(초기값)
이렇게하는데 이게
array=[1,2]
const[a,b]=array
같은거라서 앞에거가 변수값 뒤에거가 상태변경으로 덮어씌우는식으로 동작함

useState는 클래스처럼 막 저렇게할필요없고 한번하면 바로 동기화됨

state는 얉은복사 막기위해서 쓰는거라 name=1이런거하면안되고 무조건 setname써야함
배열이나 객체같은경우 복사본을 만들고 그걸 변경시킨다음에 그걸 set해서 보내줘야함
4.이벤트
이벤트는 프롭에 onclick같은거에(예약어)함수형태객체집어넣으면됨
이벤트는 버튼이나 인풋같은 원래있는거는 예약어설정이 되어있지만,직접만든컴포넌트에는 당연히 설정안됐으니까 받은거로 내부이벤트만들어서 돌리면됨

onChange={
	(e)=>{
		console.log(e.target.value) 
	}
}
e는 이벤트가 끝나면 사라지니까 오래들고있고싶으면
e.persist()쓰면 고정되는듯

클래스형에서 스테이트에 담을때도 
onChange={
	(e)=>{
		this.setState({(name=e.target.value) })
	}
이렇게하면됨
onChange=
	(e)=>{
		console.log(e.target.value) 
		this.setState({(name=e.target.value) })
	}
당연히 이렇게도됨

일반적으로 이렇게 인라인으로는 한두줄은 대충적고치우는데 
길어지면 onClick={this.nameclick}이렇게 함수선언해두고 그거가져다씀 당연하지만
단 이떄는 기본적으로는 생성자에 미리 바인드시켜둬야하는데
그냥 nameclick=(e)=>{...}이렇게 화살표함수를쓰면 화살표함수는 스코프가없어서 바로 밖에거 가르키니까 바로처리가능해짐
 
onkeypress는
haKeyPress=
	(e)=>{
		if e.key==='Enter'{
			this.haClick()//클릭이벤트함수
		}
		
	}
	이런식으로해서 프롭연결시켜주면됨
	
함수형에서는 
const onChange=e=>{
	const nextform={
		...form,
		[e.target.바꿀값]:e.target.value
	};
	setForm(nextForm)

}
함수형은 hook써야하니까 객체는 저렇게 바꾸고하면됨

5.dom에 ref달기
레퍼런스를 사용하는 이유는 레퍼런스를 써야하는 특정작업(포커스넘겨준다던가)이 있음
그거말고는 그냥 클래스네임에 if문쓰던가해서 css파일 불러오는식으로 처리할수있는데 저런거처리는 불가능함

ref를 만드는법에는 2개가있는데

콜백함수로 만드는법과 createRef로 만드는게 있는데 createRef로 보통 만듬

콜백함수는 <아무거나 ref={(ref)=>{this.ref이름(뭘넣어도됨)=ref}}/>
여기에 포커스옮길떄는 this.ref이름.focus();하면됨 이벤트에

createRef는 
abc=React.createRef();

handleFocus=()=>{
	this.abc.current.focus();

}
render(){
<input ref={this.abc}/>

}
이렇게 함수로 만든다음에 거기다가 포커스같은거(ref쓸요소를 ref props로) 엮어주고 그거 ref에 연결하면됨

그냥 레퍼런스가 어디든 레퍼런스에 포커스든 뭐든 준다고보면되는듯

리액트에서는 dom말고 컴포넌트에도 ref를 달수있음

사용방법은 

<mycompo ref={(ref)=>{this.ref이름(뭘넣어도됨)=ref}}/>
로 똑같음

이렇게하면 컴포넌트 내부의 메서드랑 멤버변수,내부의 ref에도 접근할수있음

<div> 
	ref={(ref)=>{this.box=ref}}
/div>
해서 box만들고
sc=()=>{
	const {scrollHeight,clienyHeight}=this.box/*비구조화문법
	const scrollHeight=this.box.scrollHeight
	const clienyHeight=this.box.clienyHeight
	랑 같은거임
	
	*/
	this.box.scrollTop=scrollHeight-clienyHeight
}
이렇게 컴포넌트만들고
메인에서
<sc ref=ref={(ref)=>{this.sc=ref}}/>
<button onClick={()=>this.sc.sc()}/>해서 불러올수가있음 ref에서의 메서드를

근데 이렇게 막 주고받는건 권장하는방식은 아닌듯 전역변수같은건가봄

6.컴포넌트 반복

map은 배열의 내장함수인데 배열의 처음부터 끝까지 콜백함수대로 처리해줌
arr.map(callback(현재요소,인데스값,원본배열),[arg])arg는옵션

arr=[1,2,3]
arr.map(function(num)/*현재요소*/{
	return num*num
}
하면 1 4 9가 리턴됨

이렇게 arr.map(num=><div>{num}</div>)
이런식으로 둘러싸서처리할수있게됨 여러줄일떄

단 map쓸때는 키값도 같이주는게 좋은데
arr.map((num,index)=><div key=index>{num}</div>)
이런식으로 인덱스값 넣을수도있고 그렇지만 이런건 절대 중복되지않을때나 할수있고 왠만하면 프라이머리키같은거로 잡아줘야함(게시물번호같은거)
배열에 id랑 값 둘다 넣은다음에  id값을 키로잡는식으로

이렇게 값2개있을때 추가는 값2개넣고 num.concat으로 num에 합쳐서 넣어준다음에 그거 setnum하는식으로

제거는 num.filter(callback(현재요소,인데스값,원본배열))
num.filter(x=>z!==1)하면 [2,3]만 나옴

키가 필요한 이유는 리랜더링할때 리액트에선 바뀐거만 하고싶은데 그거확인을 키로잡고 하는데 없거나 중복이면 직접돌아야해서 성능떨어짐

7.컴포넌트의 라이프사이클 매서드(클래스용) 함수는 hook

컴포넌트는 4가지경우에 업데이트됨
props가 바뀌거나,state가 바뀌거나 부모컴포넌트가 리렌더링되거나,강제로 렌더링트리거하거나

getDerivedStateFromProps:마운트과정과 업데이트 시작하기전에 호출,
props가 바뀔때 state에도 변화주고싶을때(동기화시키고싶을떄) 사용
getDerivedStateFromProps(nextProps,prevState){
	if(nextProps.value!==prevState.value){
		return{value(/*밖에전역으로있는값*/):nextProps.value}
	}
}
이런식으로사용

shouldComponentUpdate:컴포넌트가 리렌더링할지말지 결정하는 메서드(True Flase리턴으로)
만약 this.forceUpdate()(강제렌더링트리거)를 쓰면 이거 스킵하고 넘어감
따로안건드리면 무조건 true나오고 
현재prop랑 state는 this.props this.state로 접근할수있고 새로설정할값은 nextProps nextState로 접근할수있음

render:컴포넌트 리렌더링

getSnapshotBeforeUpdate:컴포넌트 변화 반영 직전에 호출하는메서드 전에 사용하던값 받아서 적용시킬때(스크롤바위치유지)사용

componentDidMount:컴포넌트만들고 첫렌더링시 호출 여기다가 네트워크요청같은거 넣으면됨

componentWillUnmount:컴포넌트를 dom에서 제거할떄 실행
여기서 이벤트 타이머 직접생성한dom이 있으면 제거해줘야함

componentDidUpdate:컴포넌트 업데이트 끝나고나서 호출하는메서드
업데이트끝났으니까 dom관련처리해도됨

constructor:컴포넌트 생성자로 초기state정할수있음

componentDidCatch:렌더링도중 에러났을때 오류ui를 보여줌
componentDidCatch(error,info){
	this.setState({
		error:true
	}
	console.log({error,info})
}
이렇게사용

8.hook
함수에서 상태관리하거나,렌더링후 작업(클래스의 라이프사이클)을 함수형에서 하는방법

usestate:앞에서 맨날쓰던 상태관리(변수덮어쓰기)hook

const [abc,setabc]=useState(기본값)
abc가 읽기 setabc가 덮어쓰기

만약 관리해야할 값이 여러개라면 그냥 useState여러개만들면됨

useEffect:컴포넌트 렌더링될때마다 특정작업 수행하게 하는거
componentDidMount+componentDidUpdate라고 보면됨

useEffect(()=>{
		console.log('abc')

	}
)
return(


)
저렇게 리턴위에 쓰면됨

만약 마운트될때(처음실행될때)만 실행하고싶으면
useEffect(()=>{
	console.log('abc')

},[])
이렇게 2번쨰인자로 빈배열 넣어주면 마운트할떄만 실행됨

특정값이 업데이트될떄만 실행하고싶으면 
useEffect(()=>{
	console.log('abc')

},[name])
이렇게 검사할값을 배열안에 넣어주면됨(usestate나 prop나 아무거나)

컴포넌트가 언마운트하기전이나 업데이트직전에 실행하고싶으면 useState에서 cleanup함수를 반환해줘야함
useEffect(()=>{
		console.log('abc')

	}

	return()=>{
		
	
	}


	
)
그냥 이렇게 useEffect속에서 함수리턴하면 그걸 클린업이라고 부르고 
이건 업데이트직전이랑 언마운트되기전에 호출됨(함수만(따로쓸수있는거같음 그냥렌더링이랑 클린업이랑))
언마운트떄만 호출하고싶으면 아까 마운트때처럼 뒤에 빈배열넣으면됨

usereducer:useState랑 비슷한앤데 더 다양한상황에따라 다양하게 업데이트하고싶을떄 사용
function reducer(state,action(케이스문처럼 그렇게 구분하는거) ){
	return{...}
}
const [state,dispatch]=usereducer(reducer(사용할함수),{초기값})
<button onClick={()=>dispatch({type:'inc'})}
이게 기본형이고 보통 케이스문처럼 사용하고그럼
function reducer(state,action ){
	switch(action.type){
	case 'inc':
		return{...}
	case 'dec':
		return{...}
	default:
		return{...}
	}
}
const [state,dispatch]=usereducer(reducer,{value:0})
이런식으로 쓰는듯

얘의 가장 큰 장점은 함수를 받으니까 업데이트 로직을 다른곳으로 뺄수있게됨
함수를 딴데서 만든다음에 임포트해서 함수 인자에넣으면되니까

그리고 useState 여러개쓸필요도없이 그냥 리듀서안에 다 넣어서 처리하고 리듀서 하나만가지고 써도됨

onChange=e=>{
	dispatch(e.target)

}
이렇게해서 타겟데이터 다긁어와서 처리

usememo:컴포넌트 내부에서 발생하는 연산을 최적화할수있음
보통때는 렌더링할때마다 계속 연산하는데 usememo를 쓰면 인풋내용이 바뀔때만 렌더링했을때 다시계산하고 그대로면 바로랜더링함
const avg=useMemo(()=>연산함수(abc),[abc(인풋값)])
abc가 바뀌면 다시연산하고(배열속에 든게 바뀌면)아니면 바로렌더링

usecallback:useMemo랑 비슷하게 최적화할때 사용
얘는 함수를 조건따라서 다시연산하게 하는애임
usecallback(함수(),[체크할배열])
배열속이 빈배열일경우([])처음 한번만 생성하고
배열이 [name]이면 name이 바뀌면 다시생성함

결국 useMemo로 함수반환하려면 좀 길어지니까
정수,문자열,배열같은거 재사용은 useMemo
함수 재사용은 usecallback
근데 보통 극한상황아니고 함수까지 저렇게 쌀필요는없는거같긴함

useref:함수형에서 ref를 쉽게 사용하게해줌
const iref=useref(null)
...
a=function(e=>iref.current.focus())
return(
	<input ref={iref}/>
	<button onClick={a}/>
)
이러면 iref를 만든다음에 리턴에서 ref를 묶고 a를 누르면 iref가 가리키고있는 ref를 찾아서 포커스를 넘겨줌

이거도 그때 ref랑 똑같이 로컬변수 가져다쓸수있는데 
const refsam=()=>{
	const id=useref(1)
	const setid=(n)=>{
		id.current=n
	}//내부 ref를 수정
	const getid=()=>{
		console.log(id.current)
	}//내부ref 조회
}
이걸 가져다가 밖에서 메서드 호출하는식으로 써서 로컬변수를 조정,조회할수있음(클로저처럼 사용,아니 같은건가?)

usereducer같은거 잘 조합해서 따로 밖으로 빼서 커스텀hook만들어서 쓸수도있음

9.컴포넌트스타일링

일반css:그냥 일반적으로 css쓰는방식
이름은 기본규칙은 .컴포넌트의클래스네임{}인데(.app,.)
보통 .app-header이런식으로 컴포넌트의 어떤부분에 한정시켜서사용

아니면 css selector을 쓰는데 css클래스가 특정 클래스 내부에 있을때만 적용할수있음
앱안의 로고클래스네임에 적용하려면 .app .logo{}이런식으로 쓰면됨
jsx에서는 <img className='logo'/>에 적용됨
말고 그태그전체에 적용하려면 .app a{}이런식으로 점떼고 붙이면됨

sass:css전처리기로 보통 scss를 사용 sass랑 문법이 좀 다름
$a->변수 $red:#fa5252 빨간색변수생성
@mixin a(인자){...} 함수
.app{ 특정컴포넌트에서
	.abc{  특정 클래스네임에
		background:red
		cursor:pointer;
		transition:all 0.3s ease
		&.ac{ ac와 abc가 동시사용되었을때(abc랑 ac가 있을때) ex <div className='abc ac'/>
			#include a(1) 함수사용할때
		
		}
		&.ad{ ad와 abc가 동시사용되었을때
			
		
		}
		&:hover{ abc에 마우스를 올렸을떄
		
		}
		
	}
}
이것도 변수랑 함수 모듈화시켜서 불러올수있는데
@import './abc' 이렇게불러오면됨
저거 깊이 너무깊어지면 줄일수도있는데 그건 필요할떄찾아보자

@import '~abc'는 node_modules에 있는 abc찾기

css module:이건 css를 불러와서 쓸때 클래스이름에 해시값붙여서 이름중첩을 막아줌
사용법은 a.module.css 이렇게 .module를 붙여주면됨
scss도 똑같이 a.module.scss하면알아서인식함

.head{...} 이렇게 대충적어도 알아서 고유값됨

글로벌로 하고싶으면 :global .a{} 하면됨
jsx에서는 
<div className={임포트이름.head}/> .head사용법
<div className=a/> 글로벌사용법
그냥 함수불러오는거처럼 가져다쓰면되는듯 글로벌은 전역이고
만약 2개이상 가져다쓰려면
<div className=`${styles.head} ${styles.tail}`/>
이런식으로 붙이면됨 양쪽에 어퍼스트로피붙이고 앞에 $붙이고 

`abc${name}dcd`이러면 abc이름변수dcd 이렇게나오는데
문자열속에 자바스크립트내용넣을때 'abc'+name+'dcd'랑 같은데 좀 줄일수있음

classnames:클래스네임은 css를 조건부로 줄때 유용한 라이브러리
import cn from 'classnames'
임포트해준다음

classNames(a:true,b:false)// a
classNames(a:true,b:true)// ab
이런식으로 사용
const a='qwe'
classNames('s',a)//sqwe

<div className={classNames('abc',a)}/>이런식으로사용

그리고 cssmodule쓸때는 미리 변수에 바인드를 시켜두면 매번 styles.클래스이름 칠필요없이
const cx=classNames.bind(css파일)
<div className={cx('abc','ac')}/>이런식으로 css파일에있는거 가져올수있음

그리고 cssmodule이 아닌파일에서도 
:local .a{}
:local{
	.q{}
	.w{}
}
이런식으로 모듈로쓸수있음

styled-components:js안에서 인라인으로 cs쓸떄 사용하는 라이브러리
import styled,{css} from 'styled-components'  
임포트해주고
const box=styled.div`
	background:${props=>props.color||'blue'}//파란색이나 props로 받아온색
`
const Button= styled.button`
	&:hover{//자기자신에 마우스올렸을때
	}
	&를써서 자기자신선택가능

	${props=>props.abc&&css` props로 abc가 true인 애들만 적용
		background='blue'
	`
	&+button{자기자신이 버튼이면
		margin-left:1rem
	}
`
tagged 템플릿 리터럴:``을 사용해서 만든 문자열에 스타일정보 넣어주는것
이렇게쓰면 템플릿안에 js객체나 함수를 전달할때 온전히 추출됨

`hello ${{abc:'qwe'}} ${()=>'ewew'}`바로 이렇게하면
hello [object Object] ()=>'ewew'
이렇게나오는데 

function tagged(...args){
	console.log(args);
}
tagged`hello ${{abc:'qwe'}} ${()=>'ewew'}`
이렇게하면 
1 hello
2 {abc:'qwe'}
3 ()=>'ewew'
이렇게 내용만 제대로 추출됨

사용하는방법은 
const mycom=styled('태그타입(div같은거)')`
	background:gray
`
이건 태그타입 보내주는거고

const mycom=styled(컴포넌트)`
	background:gray
`
이건 아예 컴포넌트를 넣어줌

이걸로 내부props값에 따라 다르게 스타일을 적용할수있음(조건따라서 이거넣을지 저거넣을지해서 prop값 존재여부,tf여부로)

이거로 @media를 써서 사이즈따라 반응형웹 만들기도 편함(365페이지 코드넘길다)
미리 함수빼둔다음에 불러다가 사이즈확인하고 다르게 적용하는식

