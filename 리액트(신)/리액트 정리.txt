리턴html은 무조건 하나로 나가야됨
jsx내부에서 자바스크립트표현식 쓸려면 {}로 감싸면됨 {name}
jsx내부에서 표현식써도 if를 쓸순없고
a===b?( //맞을떄
): ( //else

)
이렇게써야함
뒤에 아무것도 안보여줄려면 :null하면됨
jsx내부에서 인라인으로 css건드릴떄는 -사라지고 그다음자 대문자해서 주고 문자열이아닌 객체로 줘야함
background-color은
backgroundColor:'black' 이런식

style은 밖에서 만들어가도되고 안에서 인라인으로 적어도되는데 인라인은
<div style={{
backgroundColor:'black'
...
}}
>
이런식으로 괄호2개치고 안에다적으면됨

밖에 css파일을 사용할떄는 
import'./a.css ' 하고나서
css파일에서 .classname{}했을떄 저 클래스이름과 같은거를 따라감

셀프클로저하고싶으면 <input/>

jsx안에서 주석은 {/*abc*/}

vscode 
eslint:문법검사도구
prettier:코드정렬도구

기본적으로 함수형 클래스형중에 es6들어오고나서는 함수형이 표준으로됐음

es6에서 화살표 함수가 생겼는데 화살표함수는 함수 자체의 this가 없기떄문에 스코프상 가장 가까운 생성자의 this를 가리키게됨
일반함수는 자기자신의 this가 있으니까 자기자신걸 가르킴

그래서 화살표함수는 메서드에 사용하면 안될거같음
기본적으로 함수랑 메서드가 .가지고 구분하는데 거기서 this가 객체냐 인스턴스냐 나눠지니까 그냥 함수로 통일하는게맞을거같음
(객체는 var tico=new car() 할떄 tico를 가르키고(선언시 객체) new car()해서 생성자로 할당되면 인스턴스)
(객체를 선언하고 객체를 인스턴스화 시키는게 var tico=new car()임)
(인스턴스는 객체에 포함되서 그냥보통 객체라고 부르는데 가끔 나눠불러야할떄가 있음 this나)

props는 매개변수
2.프롭타입설명
<mycompo name='abc'/>하면 name이 prop

받을때는
Mycompo=props =>{
	return{
			<div>
				{props.name}
			</div>

	}	

}
mycompo.defaultProps={{/* 디폴트설정*/}
	name:'default'

}

이렇게받고 쓰면됨

컴포넌트 따로 빼뒀는데 <mycompo>abc</mycompo>
저 중간값이 필요하면 props.children (예약어)쓰면됨

그리고 맨날 props붙이기 귀찮으니까
리턴 위에

const{name,children}=props
return(
...
)
하면 그냥 name만 쳐도됨(비구조화할당)

proptype 고정하려면 
import PropTypes from 'prop-types' 임포트하고

mycompo.propTypes={
	name:propTypes.string

}
이런식으로 지정받아서 만약 틀리면 에러메세지 개발자도구 콘솔창에 띄울수있음

mycompo.propTypes={
	name:propTypes.string
	a:propTypes.number.isRequired
}
isRequired하면 설정을 안했을때 (비어있을떄) 에러를띄움

그러니까 
propTypes.자료형은 들어오는지 안들어오는지는 체크안하지만 들어왔을때 자료형체크
propTypes.number.isRequired는 들어왔는지 안들어왔는지 체크 후 자료형체크
둘다 에러메세지만 띄우고 동작은됨 잘못넣어도

클래스에서 비구조화할당은 랜더밑 리턴위에 하면되고
proptypes는 똑같이 클래스밖에하면됨
3.스테이트 깊은복사
리액트에서는 얕은복사때문에 변수를쓸떄 값을 바꿀때 무조건 덮어씌우는식으로 해야해서 
함수형은 usestate처럼 후크로하고
클래스는 this.state={
	number:1
}
this.setState({number:number+1})이런식으로 스테이트 에 바뀐값 덮어씌우는식으로 함

단 
this.setState({number:number+1})
this.setState({number:number+1})
이렇게 2번있다고 2가 올라가는게 아니라 동기화전이라 1만올라가기때문에

this.setState((prevState,props)=>{
	return{
		업데이트내용
		number:prevState.number+1 
	}

}
이렇게 화살표함수를 인자로 넣어서 함수리턴값을 덮어씌우면됨

함수형에서는 
const[name,setname]=useState(초기값)
이렇게하는데 이게
array=[1,2]
const[a,b]=array
같은거라서 앞에거가 변수값 뒤에거가 상태변경으로 덮어씌우는식으로 동작함

useState는 클래스처럼 막 저렇게할필요없고 한번하면 바로 동기화됨

state는 얉은복사 막기위해서 쓰는거라 name=1이런거하면안되고 무조건 setname써야함
배열이나 객체같은경우 복사본을 만들고 그걸 변경시킨다음에 그걸 set해서 보내줘야함
4.이벤트
이벤트는 프롭에 onclick같은거에(예약어)함수형태객체집어넣으면됨
이벤트는 버튼이나 인풋같은 원래있는거는 예약어설정이 되어있지만,직접만든컴포넌트에는 당연히 설정안됐으니까 받은거로 내부이벤트만들어서 돌리면됨

onChange={
	(e)=>{
		console.log(e.target.value) 
	}
}
e는 이벤트가 끝나면 사라지니까 오래들고있고싶으면
e.persist()쓰면 고정되는듯

클래스형에서 스테이트에 담을때도 
onChange={
	(e)=>{
		this.setState({(name=e.target.value) })
	}
이렇게하면됨
onChange=
	(e)=>{
		console.log(e.target.value) 
		this.setState({(name=e.target.value) })
	}
당연히 이렇게도됨

일반적으로 이렇게 인라인으로는 한두줄은 대충적고치우는데 
길어지면 onClick={this.nameclick}이렇게 함수선언해두고 그거가져다씀 당연하지만
단 이떄는 기본적으로는 생성자에 미리 바인드시켜둬야하는데
그냥 nameclick=(e)=>{...}이렇게 화살표함수를쓰면 화살표함수는 스코프가없어서 바로 밖에거 가르키니까 바로처리가능해짐
 
onkeypress는
haKeyPress=
	(e)=>{
		if e.key==='Enter'{
			this.haClick()//클릭이벤트함수
		}
		
	}
	이런식으로해서 프롭연결시켜주면됨
	
함수형에서는 
const onChange=e=>{
	const nextform={
		...form,
		[e.target.바꿀값]:e.target.value
	};
	setForm(nextForm)

}
함수형은 hook써야하니까 객체는 저렇게 바꾸고하면됨

5.dom에 ref달기
레퍼런스를 사용하는 이유는 레퍼런스를 써야하는 특정작업(포커스넘겨준다던가)이 있음
그거말고는 그냥 클래스네임에 if문쓰던가해서 css파일 불러오는식으로 처리할수있는데 저런거처리는 불가능함




