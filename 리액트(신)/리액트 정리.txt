리턴html은 무조건 하나로 나가야됨
jsx내부에서 자바스크립트표현식 쓸려면 {}로 감싸면됨 {name}
jsx내부에서 표현식써도 if를 쓸순없고
a===b?( //맞을떄
): ( //else

)
이렇게써야함
뒤에 아무것도 안보여줄려면 :null하면됨
jsx내부에서 인라인으로 css건드릴떄는 -사라지고 그다음자 대문자해서 주고 문자열이아닌 객체로 줘야함
background-color은
backgroundColor:'black' 이런식

style은 밖에서 만들어가도되고 안에서 인라인으로 적어도되는데 인라인은
<div style={{
backgroundColor:'black'
...
}}
>
이런식으로 괄호2개치고 안에다적으면됨

밖에 css파일을 사용할떄는 
import'./a.css ' 하고나서
css파일에서 .classname{}했을떄 저 클래스이름과 같은거를 따라감

셀프클로저하고싶으면 <input/>

jsx안에서 주석은 {/*abc*/}

vscode 
eslint:문법검사도구
prettier:코드정렬도구

기본적으로 함수형 클래스형중에 es6들어오고나서는 함수형이 표준으로됐음

es6에서 화살표 함수가 생겼는데 화살표함수는 함수 자체의 this가 없기떄문에 스코프상 가장 가까운 생성자의 this를 가리키게됨
일반함수는 자기자신의 this가 있으니까 자기자신걸 가르킴

그래서 화살표함수는 메서드에 사용하면 안될거같음
기본적으로 함수랑 메서드가 .가지고 구분하는데 거기서 this가 객체냐 인스턴스냐 나눠지니까 그냥 함수로 통일하는게맞을거같음
(객체는 var tico=new car() 할떄 tico를 가르키고(선언시 객체) new car()해서 생성자로 할당되면 인스턴스)
(객체를 선언하고 객체를 인스턴스화 시키는게 var tico=new car()임)
(인스턴스는 객체에 포함되서 그냥보통 객체라고 부르는데 가끔 나눠불러야할떄가 있음 this나)

props는 매개변수
2.프롭타입설명
<mycompo name='abc'/>하면 name이 prop

받을때는
Mycompo=props =>{
	return{
			<div>
				{props.name}
			</div>

	}	

}
mycompo.defaultProps={{/* 디폴트설정*/}
	name:'default'

}

이렇게받고 쓰면됨

컴포넌트 따로 빼뒀는데 <mycompo>abc</mycompo>
저 중간값이 필요하면 props.children (예약어)쓰면됨

그리고 맨날 props붙이기 귀찮으니까
리턴 위에

const{name,children}=props
return(
...
)
하면 그냥 name만 쳐도됨(비구조화할당)

proptype 고정하려면 
import PropTypes from 'prop-types' 임포트하고

mycompo.propTypes={
	name:propTypes.string

}
이런식으로 지정받아서 만약 틀리면 에러메세지 개발자도구 콘솔창에 띄울수있음

mycompo.propTypes={
	name:propTypes.string
	a:propTypes.number.isRequired
}
isRequired하면 설정을 안했을때 (비어있을떄) 에러를띄움

그러니까 
propTypes.자료형은 들어오는지 안들어오는지는 체크안하지만 들어왔을때 자료형체크
propTypes.number.isRequired는 들어왔는지 안들어왔는지 체크 후 자료형체크
둘다 에러메세지만 띄우고 동작은됨 잘못넣어도

클래스에서 비구조화할당은 랜더밑 리턴위에 하면되고
proptypes는 똑같이 클래스밖에하면됨
3.스테이트 깊은복사
리액트에서는 얕은복사때문에 변수를쓸떄 값을 바꿀때 무조건 덮어씌우는식으로 해야해서 
함수형은 usestate처럼 후크로하고
클래스는 this.state={
	number:1
}
this.setState({number:number+1})이런식으로 스테이트 에 바뀐값 덮어씌우는식으로 함

단 
this.setState({number:number+1})
this.setState({number:number+1})
이렇게 2번있다고 2가 올라가는게 아니라 동기화전이라 1만올라가기때문에

this.setState((prevState,props)=>{
	return{
		업데이트내용
		number:prevState.number+1 
	}

}
이렇게 화살표함수를 인자로 넣어서 함수리턴값을 덮어씌우면됨

함수형에서는 
const[name,setname]=useState(초기값)
이렇게하는데 이게
array=[1,2]
const[a,b]=array
같은거라서 앞에거가 변수값 뒤에거가 상태변경으로 덮어씌우는식으로 동작함

useState는 클래스처럼 막 저렇게할필요없고 한번하면 바로 동기화됨

state는 얉은복사 막기위해서 쓰는거라 name=1이런거하면안되고 무조건 setname써야함
배열이나 객체같은경우 복사본을 만들고 그걸 변경시킨다음에 그걸 set해서 보내줘야함
4.이벤트
이벤트는 프롭에 onclick같은거에(예약어)함수형태객체집어넣으면됨
이벤트는 버튼이나 인풋같은 원래있는거는 예약어설정이 되어있지만,직접만든컴포넌트에는 당연히 설정안됐으니까 받은거로 내부이벤트만들어서 돌리면됨

onChange={
	(e)=>{
		console.log(e.target.value) 
	}
}
e는 이벤트가 끝나면 사라지니까 오래들고있고싶으면
e.persist()쓰면 고정되는듯

클래스형에서 스테이트에 담을때도 
onChange={
	(e)=>{
		this.setState({(name=e.target.value) })
	}
이렇게하면됨
onChange=
	(e)=>{
		console.log(e.target.value) 
		this.setState({(name=e.target.value) })
	}
당연히 이렇게도됨

일반적으로 이렇게 인라인으로는 한두줄은 대충적고치우는데 
길어지면 onClick={this.nameclick}이렇게 함수선언해두고 그거가져다씀 당연하지만
단 이떄는 기본적으로는 생성자에 미리 바인드시켜둬야하는데
그냥 nameclick=(e)=>{...}이렇게 화살표함수를쓰면 화살표함수는 스코프가없어서 바로 밖에거 가르키니까 바로처리가능해짐
 
onkeypress는
haKeyPress=
	(e)=>{
		if e.key==='Enter'{
			this.haClick()//클릭이벤트함수
		}
		
	}
	이런식으로해서 프롭연결시켜주면됨
	
함수형에서는 
const onChange=e=>{
	const nextform={
		...form,
		[e.target.바꿀값]:e.target.value
	};
	setForm(nextForm)

}
함수형은 hook써야하니까 객체는 저렇게 바꾸고하면됨

5.dom에 ref달기
레퍼런스를 사용하는 이유는 레퍼런스를 써야하는 특정작업(포커스넘겨준다던가)이 있음
그거말고는 그냥 클래스네임에 if문쓰던가해서 css파일 불러오는식으로 처리할수있는데 저런거처리는 불가능함

ref를 만드는법에는 2개가있는데

콜백함수로 만드는법과 createRef로 만드는게 있는데 createRef로 보통 만듬

콜백함수는 <아무거나 ref={(ref)=>{this.ref이름(뭘넣어도됨)=ref}}/>
여기에 포커스옮길떄는 this.ref이름.focus();하면됨 이벤트에

createRef는 
abc=React.createRef();

handleFocus=()=>{
	this.abc.current.focus();

}
render(){
<input ref={this.abc}/>

}
이렇게 함수로 만든다음에 거기다가 포커스같은거(ref쓸요소를 ref props로) 엮어주고 그거 ref에 연결하면됨

그냥 레퍼런스가 어디든 레퍼런스에 포커스든 뭐든 준다고보면되는듯

리액트에서는 dom말고 컴포넌트에도 ref를 달수있음

사용방법은 

<mycompo ref={(ref)=>{this.ref이름(뭘넣어도됨)=ref}}/>
로 똑같음

이렇게하면 컴포넌트 내부의 메서드랑 멤버변수,내부의 ref에도 접근할수있음

<div> 
	ref={(ref)=>{this.box=ref}}
/div>
해서 box만들고
sc=()=>{
	const {scrollHeight,clienyHeight}=this.box/*비구조화문법
	const scrollHeight=this.box.scrollHeight
	const clienyHeight=this.box.clienyHeight
	랑 같은거임
	
	*/
	this.box.scrollTop=scrollHeight-clienyHeight
}
이렇게 컴포넌트만들고
메인에서
<sc ref=ref={(ref)=>{this.sc=ref}}/>
<button onClick={()=>this.sc.sc()}/>해서 불러올수가있음 ref에서의 메서드를

근데 이렇게 막 주고받는건 권장하는방식은 아닌듯 전역변수같은건가봄

6.컴포넌트 반복

map은 배열의 내장함수인데 배열의 처음부터 끝까지 콜백함수대로 처리해줌
arr.map(callback(현재요소,인데스값,원본배열),[arg])arg는옵션

arr=[1,2,3]
arr.map(function(num)/*현재요소*/{
	return num*num
}
하면 1 4 9가 리턴됨

이렇게 arr.map(num=><div>{num}</div>)
이런식으로 둘러싸서처리할수있게됨 여러줄일떄

단 map쓸때는 키값도 같이주는게 좋은데
arr.map((num,index)=><div key=index>{num}</div>)
이런식으로 인덱스값 넣을수도있고 그렇지만 이런건 절대 중복되지않을때나 할수있고 왠만하면 프라이머리키같은거로 잡아줘야함(게시물번호같은거)
배열에 id랑 값 둘다 넣은다음에  id값을 키로잡는식으로

이렇게 값2개있을때 추가는 값2개넣고 num.concat으로 num에 합쳐서 넣어준다음에 그거 setnum하는식으로

제거는 num.filter(callback(현재요소,인데스값,원본배열))
num.filter(x=>z!==1)하면 [2,3]만 나옴

키가 필요한 이유는 리랜더링할때 리액트에선 바뀐거만 하고싶은데 그거확인을 키로잡고 하는데 없거나 중복이면 직접돌아야해서 성능떨어짐

7.컴포넌트의 라이프사이클 매서드(클래스용) 함수는 hook

컴포넌트는 4가지경우에 업데이트됨
props가 바뀌거나,state가 바뀌거나 부모컴포넌트가 리렌더링되거나,강제로 렌더링트리거하거나

getDerivedStateFromProps:마운트과정과 업데이트 시작하기전에 호출,
props가 바뀔때 state에도 변화주고싶을때(동기화시키고싶을떄) 사용
getDerivedStateFromProps(nextProps,prevState){
	if(nextProps.value!==prevState.value){
		return{value(/*밖에전역으로있는값*/):nextProps.value}
	}
}
이런식으로사용

shouldComponentUpdate:컴포넌트가 리렌더링할지말지 결정하는 메서드(True Flase리턴으로)
만약 this.forceUpdate()(강제렌더링트리거)를 쓰면 이거 스킵하고 넘어감
따로안건드리면 무조건 true나오고 
현재prop랑 state는 this.props this.state로 접근할수있고 새로설정할값은 nextProps nextState로 접근할수있음

render:컴포넌트 리렌더링

getSnapshotBeforeUpdate:컴포넌트 변화 반영 직전에 호출하는메서드 전에 사용하던값 받아서 적용시킬때(스크롤바위치유지)사용

componentDidMount:컴포넌트만들고 첫렌더링시 호출 여기다가 네트워크요청같은거 넣으면됨

componentWillUnmount:컴포넌트를 dom에서 제거할떄 실행
여기서 이벤트 타이머 직접생성한dom이 있으면 제거해줘야함

componentDidUpdate:컴포넌트 업데이트 끝나고나서 호출하는메서드
업데이트끝났으니까 dom관련처리해도됨

constructor:컴포넌트 생성자로 초기state정할수있음

componentDidCatch:렌더링도중 에러났을때 오류ui를 보여줌
componentDidCatch(error,info){
	this.setState({
		error:true
	}
	console.log({error,info})
}
이렇게사용

8.hook
함수에서 상태관리하거나,렌더링후 작업(클래스의 라이프사이클)을 함수형에서 하는방법

usestate:앞에서 맨날쓰던 상태관리(변수덮어쓰기)hook

const [abc,setabc]=useState(기본값)
abc가 읽기 setabc가 덮어쓰기

만약 관리해야할 값이 여러개라면 그냥 useState여러개만들면됨

useEffect:컴포넌트 렌더링될때마다 특정작업 수행하게 하는거
componentDidMount+componentDidUpdate라고 보면됨

useEffect(()=>{
		console.log('abc')

	}
)
return(


)
저렇게 리턴위에 쓰면됨

만약 마운트될때(처음실행될때)만 실행하고싶으면
useEffect(()=>{
	console.log('abc')

},[])
이렇게 2번쨰인자로 빈배열 넣어주면 마운트할떄만 실행됨

특정값이 업데이트될떄만 실행하고싶으면 
useEffect(()=>{
	console.log('abc')

},[name])
이렇게 검사할값을 배열안에 넣어주면됨(usestate나 prop나 아무거나)

컴포넌트가 언마운트하기전이나 업데이트직전에 실행하고싶으면 useState에서 cleanup함수를 반환해줘야함
useEffect(()=>{
		console.log('abc')

	}

	return()=>{
		
	
	}


	
)
그냥 이렇게 useEffect속에서 함수리턴하면 그걸 클린업이라고 부르고 
이건 업데이트직전이랑 언마운트되기전에 호출됨(함수만(따로쓸수있는거같음 그냥렌더링이랑 클린업이랑))
언마운트떄만 호출하고싶으면 아까 마운트때처럼 뒤에 빈배열넣으면됨

usereducer:useState랑 비슷한앤데 더 다양한상황에따라 다양하게 업데이트하고싶을떄 사용
function reducer(state,action(케이스문처럼 그렇게 구분하는거) ){
	return{...}
}
const [state,dispatch]=usereducer(reducer(사용할함수),{초기값})
<button onClick={()=>dispatch({type:'inc'})}
이게 기본형이고 보통 케이스문처럼 사용하고그럼
function reducer(state,action ){
	switch(action.type){
	case 'inc':
		return{...}
	case 'dec':
		return{...}
	default:
		return{...}
	}
}
const [state,dispatch]=usereducer(reducer,{value:0})
이런식으로 쓰는듯

얘의 가장 큰 장점은 함수를 받으니까 업데이트 로직을 다른곳으로 뺄수있게됨
함수를 딴데서 만든다음에 임포트해서 함수 인자에넣으면되니까

그리고 useState 여러개쓸필요도없이 그냥 리듀서안에 다 넣어서 처리하고 리듀서 하나만가지고 써도됨

onChange=e=>{
	dispatch(e.target)

}
이렇게해서 타겟데이터 다긁어와서 처리

usememo:컴포넌트 내부에서 발생하는 연산을 최적화할수있음
보통때는 렌더링할때마다 계속 연산하는데 usememo를 쓰면 인풋내용이 바뀔때만 렌더링했을때 다시계산하고 그대로면 바로랜더링함
const avg=useMemo(()=>연산함수(abc),[abc(인풋값)])
abc가 바뀌면 다시연산하고(배열속에 든게 바뀌면)아니면 바로렌더링

usecallback:useMemo랑 비슷하게 최적화할때 사용
얘는 함수를 조건따라서 다시연산하게 하는애임
usecallback(함수(),[체크할배열])
배열속이 빈배열일경우([])처음 한번만 생성하고
배열이 [name]이면 name이 바뀌면 다시생성함

결국 useMemo로 함수반환하려면 좀 길어지니까
정수,문자열,배열같은거 재사용은 useMemo
함수 재사용은 usecallback
근데 보통 극한상황아니고 함수까지 저렇게 쌀필요는없는거같긴함

useref:함수형에서 ref를 쉽게 사용하게해줌
const iref=useref(null)
...
a=function(e=>iref.current.focus())
return(
	<input ref={iref}/>
	<button onClick={a}/>
)
이러면 iref를 만든다음에 리턴에서 ref를 묶고 a를 누르면 iref가 가리키고있는 ref를 찾아서 포커스를 넘겨줌

이거도 그때 ref랑 똑같이 로컬변수 가져다쓸수있는데 
const refsam=()=>{
	const id=useref(1)
	const setid=(n)=>{
		id.current=n
	}//내부 ref를 수정
	const getid=()=>{
		console.log(id.current)
	}//내부ref 조회
}
이걸 가져다가 밖에서 메서드 호출하는식으로 써서 로컬변수를 조정,조회할수있음(클로저처럼 사용,아니 같은건가?)

usereducer같은거 잘 조합해서 따로 밖으로 빼서 커스텀hook만들어서 쓸수도있음

9.컴포넌트스타일링

일반css:그냥 일반적으로 css쓰는방식
이름은 기본규칙은 .컴포넌트의클래스네임{}인데(.app,.)
보통 .app-header이런식으로 컴포넌트의 어떤부분에 한정시켜서사용

아니면 css selector을 쓰는데 css클래스가 특정 클래스 내부에 있을때만 적용할수있음
앱안의 로고클래스네임에 적용하려면 .app .logo{}이런식으로 쓰면됨
jsx에서는 <img className='logo'/>에 적용됨
말고 그태그전체에 적용하려면 .app a{}이런식으로 점떼고 붙이면됨

sass:css전처리기로 보통 scss를 사용 sass랑 문법이 좀 다름
$a->변수 $red:#fa5252 빨간색변수생성
@mixin a(인자){...} 함수
.app{ 특정컴포넌트에서
	.abc{  특정 클래스네임에
		background:red
		cursor:pointer;
		transition:all 0.3s ease
		&.ac{ ac와 abc가 동시사용되었을때(abc랑 ac가 있을때) ex <div className='abc ac'/>
			#include a(1) 함수사용할때
		
		}
		&.ad{ ad와 abc가 동시사용되었을때
			
		
		}
		&:hover{ abc에 마우스를 올렸을떄
		
		}
		
	}
}
이것도 변수랑 함수 모듈화시켜서 불러올수있는데
@import './abc' 이렇게불러오면됨
저거 깊이 너무깊어지면 줄일수도있는데 그건 필요할떄찾아보자

@import '~abc'는 node_modules에 있는 abc찾기

css module:이건 css를 불러와서 쓸때 클래스이름에 해시값붙여서 이름중첩을 막아줌
사용법은 a.module.css 이렇게 .module를 붙여주면됨
scss도 똑같이 a.module.scss하면알아서인식함

.head{...} 이렇게 대충적어도 알아서 고유값됨

글로벌로 하고싶으면 :global .a{} 하면됨
jsx에서는 
<div className={임포트이름.head}/> .head사용법
<div className=a/> 글로벌사용법
그냥 함수불러오는거처럼 가져다쓰면되는듯 글로벌은 전역이고
만약 2개이상 가져다쓰려면
<div className=`${styles.head} ${styles.tail}`/>
이런식으로 붙이면됨 양쪽에 어퍼스트로피붙이고 앞에 $붙이고 

`abc${name}dcd`이러면 abc이름변수dcd 이렇게나오는데
문자열속에 자바스크립트내용넣을때 'abc'+name+'dcd'랑 같은데 좀 줄일수있음

classnames:클래스네임은 css를 조건부로 줄때 유용한 라이브러리
import cn from 'classnames'
임포트해준다음

classNames(a:true,b:false)// a
classNames(a:true,b:true)// ab
이런식으로 사용
const a='qwe'
classNames('s',a)//sqwe

<div className={classNames('abc',a)}/>이런식으로사용

그리고 cssmodule쓸때는 미리 변수에 바인드를 시켜두면 매번 styles.클래스이름 칠필요없이
const cx=classNames.bind(css파일)
<div className={cx('abc','ac')}/>이런식으로 css파일에있는거 가져올수있음

그리고 cssmodule이 아닌파일에서도 
:local .a{}
:local{
	.q{}
	.w{}
}
이런식으로 모듈로쓸수있음

styled-components:js안에서 인라인으로 cs쓸떄 사용하는 라이브러리
import styled,{css} from 'styled-components'  
임포트해주고
const box=styled.div`
	background:${props=>props.color||'blue'}//파란색이나 props로 받아온색
`
const Button= styled.button`
	&:hover{//자기자신에 마우스올렸을때
	}
	&를써서 자기자신선택가능

	${props=>props.abc&&css` props로 abc가 true인 애들만 적용
		background='blue'
	`
	&+button{자기자신이 버튼이면
		margin-left:1rem
	}
`
tagged 템플릿 리터럴:``을 사용해서 만든 문자열에 스타일정보 넣어주는것
이렇게쓰면 템플릿안에 js객체나 함수를 전달할때 온전히 추출됨

`hello ${{abc:'qwe'}} ${()=>'ewew'}`바로 이렇게하면
hello [object Object] ()=>'ewew'
이렇게나오는데 

function tagged(...args){
	console.log(args);
}
tagged`hello ${{abc:'qwe'}} ${()=>'ewew'}`
이렇게하면 
1 hello
2 {abc:'qwe'}
3 ()=>'ewew'
이렇게 내용만 제대로 추출됨

사용하는방법은 
const mycom=styled('태그타입(div같은거)')`
	background:gray
`
이건 태그타입 보내주는거고

const mycom=styled(컴포넌트)`
	background:gray
`
이건 아예 컴포넌트를 넣어줌

이걸로 내부props값에 따라 다르게 스타일을 적용할수있음(조건따라서 이거넣을지 저거넣을지해서 prop값 존재여부,tf여부로)

이거로 @media를 써서 사이즈따라 반응형웹 만들기도 편함
const 사이즈={
데탑:1024
타블렛:768
}
const media= object.keys(사이즈).reduce((a,label)=>{
	a[label]=(...args)=>css'
		@media (max-width:${사이즈[label]/16em) {
			${css(...args)}
		}
		
		}
	'
}
이걸 box=styled.div`
#media.데탑`width:768px;`
#media.타블렛`width:100%;`
`
이런식으로 조건따라서(크기따라)다른값을 적용시킬수있음


미리 함수빼둔다음에 불러다가 사이즈확인하고 다르게 적용하는식으로 보통사용

10.일정관리 프로젝트

import{아이콘이름(mdadd같은 정해진이름)} from 'react-icons/md'
하면 아이콘불러올수있음

객체를 props로 받아서 그거 map한뒤에 태그로 감싸주면 동적으로 생성가능

객체는 그냥 객체통째로 보내는게 성능면에서 유리

e.preventDefault() 사용하면 새로고침 막을수있음

onsummit와 onClick의 차이는 onsummit은 엔터로도 발생함

11.컴포넌트 최적화

매번 리렌더링하는건 비효율적이므로 바뀐거만 리렌더링해야함

개발자도구에 performance에 들어가면 녹화버튼있는데 그거눌러서 시간잴수있음

리렌더링 하는 작업은
	자신이받은 props가 바뀔때
	자신의 state가 바뀔때
	부모컴포넌트가 리렌더링될떄
	forceUpdate가 실행될떄

todo앱에선 할일1을 토글하면 할일1이 리렌더링되는건 맞는데 나머지 2~2500은 리렌더링되면 느려짐
이걸 막는건 react.memo()
react.memo는 마지막에 export하는부분에
export default todolistitem
이걸
export default react.memo (todolistitem)
해버리면 적용됨
이러면 자신이 받은(보통 최하단에는 같은걸 여러개쓰니까 바꾼거말고 나머지애들) props가 바뀌지않으면 적어둔값을 그대로뱉고 리랜더링을 안함

저거만 해도 todo에서는 배열이 업데이트되면 리무브랑 토글도 새롭게 바뀌기떄문에 처리해줘야함
방법은 2갠데

useState에서 새로운 상태를 넣지말고 업데이트함수를 넣으면(=>로 함수형태로 넣어버리면)처음 렌더링될떄,그리고함수가 실행될떄만 렌더링됨
(lazy initialization)
그냥 setstate안에 사용할값=>만 넣어주면됨 (ex settodos(todos=> ...))

다른방법은 usereducer를 사용하는거임
reducer로 밖으로 함수를 다 빼고 
usecallback(id=>{dispatch({type:'abc',id}))
이런식으로 넘겨주면 실행될때 리듀서가서 찾기때문에 중간에 렌더링이 안됨

그리고 usereducer에서 usereducer(리듀서함수,초기값)인데 usereducer(리듀서함수,undefined,생성함수)하면 처음에 렌더링될떄
생성함수 호출해서 렌더링하고 그뒤엔 렌더링 안하니 초기값대신 함수있을떈 저렇게쓰면됨

리액트에서는 불변성지키는게 엄청 중요함
리액트에서는 객체 내부의 값이 바뀌어서 그걸 확인하고 그거만 리렌더링할때 값을보고 확인하는데 
자바스크립트는 anc=array이렇게하면 그냥 참조값복사가 되버리기때문에 개판나게됨
그래서 abc=[...array]이렇게 전개스프레드로 하면 복사가 하긴하는데 얇은복사라서 1차원배열이면 복사가 되지만 2차원이면 복사가 안됨
그래서 함수만들어서 dps로 복사해줘야하는데 귀찮으니까 immer라이브러리 쓰자

react-virtualized는 렌더링 갯수 제한해서 최적화하는 라이브러리임
배열이 2500개인데 화면에 9개만 표시한다면 9개만 렌더링하고 스크롤할때 렌더링해서 보여주는식
그래서 각 항목의 크기랑 전체크기를 확인한다음(수동으로해야함)
import {list} from react-virtualized 하고 
렌더링할거 적는 함수를 만들어준다음
리턴에서 
	<list
	className=클래스네임
	width=전체크기
	height=전체높이
	rowCount=항목갯수 todos.length이렇게 랭스가져다써도됨
	rowheight=항목높이
	rowrenderer=렝더링할때 쓸 함수 위에 만들어둔거
	list=배열
	style=스타일 추가적용 책에선 {{outline:'none'}}해서 list기본스타일 제거해줬음
	/>
이렇게 높이정해주고 전체갯수랑 사용할배열 함수 넣어주면 알아서 전체높이/항목높이 만큼 뱉어줌

이러면 밑에가 깨지면 todolistitem에 가서 저기 list의 스타일을 받아서 전체감싸는 div만든다음에 거기 적용시켜주면 됨
<div style={style}>
...
</div>

12.immer써서 불변성유지하기

immer는 불변성 유지할때 편하게해주는 라이브러리 

import produce from 'immer' 임포트해주고
const nextstate=produce(원래값,상태업데이트함수) 이렇게 쓰면됨
예시로 

const nextstate=produce(state,draft=>{draft.somwhere.deep.inside=5})

const nextstate=produce(state,draft=>{
	const todo=draft.find(t=>t.id===2); todo에 state에서 id 2인값 찾아서 
	todo.checked=true 그거 수정
	
	draft.push({ 드래프트에 추가 
		id:1
		text:'3sfs'
		checked:false
	})
	
	draft.splice(draft.findindex(t=>t.id===1),1) 1인거 삭제
}
이런식으로 사용
a=draft.find하면 그값인거 찾아서 주고 a를 수정하면 리턴에도 수정됨 
draft.push하면 그값을 추가함
draft.splice하면 그값을 제거
draft.findindex하면 그인덱스를 찾아서 위치잡아줌

12.라우터
라우터는 일단 미리 무슨페이지가 있는지 자바스크립트에 다 적어둔다음에(싱글 페이지 어플리케이션 SPA)
 그 페이지로 넘어가면 필요한부분만 업데이트해줌(클라이언트단에서 업데이트)
 그래서 바꿀부분만 리렌더링하면서 다른곳 인터페이스 그대로 고정시킬려고 뭐할필요도없고 편함
필요하면 서버를 호출해서 데이터 불러와서 쓸수도 있음
이렇게 서버 부담을 처음1회와 가끔가다 한두번 호출로 줄일수있음
단점은 코드크기가 커지고 js가 실행되기전에 페이지가 비어보일수있다는건데 서버사이드렌더링써서 해결가능

사용법은
react-router-dom 프로젝트에 추가하고

import {BrowserRouter} from 'react-router-dom' 임포트해주고
index.js에 <app/>를 <BrowserRouter>로 감싸줘야함 이러면 app 기본으로 spa로 동작함

보통  임포트에서 {}안에 있는건 키워드임 

그리고 app.js에 

import {Route} from 'react-router-dom'; 임포트해주고 

<Route path='주소규칙' component={보여줄 컨포넌트} exact(정확히 일치해야하는지)=true/> 해서 넣으면됨
컴포넌트 대신 render={()=><div></div>}해서 대충적고치울수도 있음 오류페이지같은거
ex 
  <Route path='/' component={Home} exact/>

그리고 라우터를쓸때는 a태그 쓰면안되고 
<Link to='주소' (이뒤는옵션) activeClassName='css적용할이름' exact=(정확히 일치) >내용</Link> 이거써야함
ex
  <Link to='/About'>소개</Link> http://localhost:3002/About를 가리킴 
 
라우터 하나에 주소를 여러개쓸수도 있는데(이름은 여러개고 사용컴포넌트는 같을때) 그냥 패스안에 {[ '/a','/b']}이렇게 배열로넣어주면됨
ex
	<Route path={['/About','/info']} component={About}/>

라우터에서 뭐 값을 받아봐야할때는 파라미터랑 쿼리를 쓰는데  
파라미터는 /abc/rkrk 이런식으로 쓰고 
쿼리는 /abc?details=true 이런식으로 씀
근데 쿼리는 숫자를보내든 True false를 보내든 다 문자열로 보내지니까 받을때 문자열을 tf나 그런걸로 알아서바꿔야함

파라미터는 match로 받아서 match.params를 변수에 넣어서 사용
ex
	const data={
		rkrk:{
			name:'rr',
			desc:'abcd'
		},
		qwer:{
			name:'lol',
			desc:'wow'
		},    
	}
	const Profile = ({match}) => {     match는 키워드
		const {username}=match.params; profile를 부른거중에 파라미터랑 변수명이랑 같은걸찾음									   
									   이부분은 Route path의 /:변수명이랑 일치해야함  	
										
		const profi=data[username]     그걸 data에서 확인해서 일치하는 객체값를 가져옴 
	}
	
<Route path="/profile/:username" component={Profile}></Route>
localhost:3000/profile/rkrk(이부분)

쿼리는 location으로 받아서 location.search에서 조회할수있음
쿼리는 문자열형태로 주는데 이걸 객체로 바꿔야 쓰기편하니까 qs라이브러리를 설치하고
import qs from 'qs' 임포트해서 사용

사용법은const query= qs.parse(location.search,{
		ignoreQueryPrefix:true  맨앞의 물음표 제거
	});
이렇게 query에 객체로 넣고
query.찾을변수이름 으로 사용 
  ex
    const showDetail=query.detail==='true'; detail이 true면 true리턴
  
서브 라우트는 라우트안에 라우트를 넣는거	
그냥 사용하고있는 컴포넌트 속에 라우트를 넣어서 쓰면됨
ex
	profiles.js
		         <li>
                    <Link to='/profiles/rkrk'>rkrk</Link>
                </li>
                <li>
                    <Link to='/profiles/qwer'>qwer</Link>  링크 걸어두고 
                </li> 
				<Route path="/profiles/:username" component={Profile}></Route>
				이렇게 컴포넌트 속에서 라우트써서 더 작은 부위만 리렌더링하는거
				
history는 match랑 location같은 props인데(라우트로 사용된 컴포넌트가 받는 props)
이 객체로 라우터 api(뒤로가기나 어디 정해진곳으로 가기,알림띄우기)를 호출할수있음

사용법은 
  버튼이벤트나 마운트이벤트 함수에 
	뒤로가기 this.props.history.goBack();
	특정위치로 가기 this.props.history.push('/about')
	알림 띄우기(그동작 할건지 안할건지 확인) this.unblock=this.props.history.block('적을텍스트');
								        if (this.unblock){ 알림 해제
											this.unblock();
										}
										
withRouter은 라우트로 사용된 컴포넌트가 아니라도 match랑 location history를 사용할수 있게 해줌 

사용법은 
import {withRouter} from 'react-router-dom' 임포트하고 
...
export default withRouter(withRouterSam); 그냥 내보낼때 withRouter로 감싸주면됨

그런데 withRouter를 쓰면 현재 라우트 되고있는곳을 기준으로 파라메터를 받아오기때문에 
서브라우트가 되어있으면 자기가 데이터 받아올 최하단에 가서 데이터를 받아야함

스위치는 여러 라우트를 감싸서 그중 일치하는 단 하나만 렌더링시켜줌
오류페이지같은거 만들어둘떄 편함
사용법은 그냥 라우트 감싸두면됨
  ex 
	import {Route,Link,Switch} from 'react-router-dom';임포트해주고
	<Switch>
      <Route path='/' component={Home} exact/>
      <Route path='/history' component={HistorySam}/>
      <Route render={({location})=>( 오류페이지
        <div>
          <h2>이페이지는 없습니다</h2>
          <p>{location.pathname}</p>
        </div>
      )}
      />
    </Switch>	

navlink는 link에 css를 적용시킬수있는 컴포넌트
링크가 활성화 되어있을때 스타일을 적용하려면(인라인) activeStyle값을 넣어주면되고
css로 받아올때는 activeClassName값을 props로 넣어주면 됨
  ex 
	import {NavLink,Route} from 'react-router-dom' 임포트해주고
	
	<NavLink to='/profiles/rkrk' activeStyle={activeStyle}>rkrk</NavLink> 
	그냥 link랑 그대로쓰고 액티브스타일,클래스명만 넣어주면됨
	
14.외부api연동 뉴스뷰어
웹을 만들다보면 서버에서 시간이 걸리는작업을 할때 비동기로 처리해야할때가있음(로그인같은거)

베이직한 비동기콜백함수로는 n초뒤에 함수를 실행하는 setTimeout(()=>{...},1000(시간)}이 있음

기본적으로는 콜백함수를 만들어서 하는데 그러면 콜백함수를 여러번콜해야하면 콜백이 겹쳐지면서 개판나게됨
callbackinc(0,result=>
	callbackinc(0,result=>
		callbackinc(0,result=>
		...

그래서 보통 promise를 사용하거나 async/await	를 사용하는데
promise는
function inc(num){
	const promise=new Promise((resolve(성공),reject(실패)=>{
		setTimeout(()=>{ 그냥 비동기라는거 보여주려고 setTimeout썼음
			const result=num+10 처리내용
			if (result>50){ 어디까지처리할건지 50넘기면 에러발생
				const e= new Error('에러명')
				return reject(e) 실패에 에러명넣고 리턴
			}
			resolve(result) 성공에 값넣으면 기본적으로 이거리턴함
		},1000(타임아웃시간))
		return promise; promise실행
	}
}					
프로미스 이렇게작용한다음에 받을때는 inc(매개변수).then 해서 받아올수있고,then을 여러번해서 반복처리도 가능
inc(0).then(number=>{
	console.log(number)
	return (inc(num)) 리턴을하면 이값을 줘서 다시돌려서 then을 여러번처리가능
})
.then(number=>{
	console.log(number)
	return (inc(num)) 리턴을하면 then을 여러번처리가능
})
...
.catch(e=>{   도중에 에러발생하면 여기로 넘어와서 에러받아볼수있음
	console.log(e) 
}

async/await는 promise를 더 편하게 사용하는 문법

콜백함수는 그대로 쓰고 밑에 then하는 부분을 편하게쓸수있음
함수앞에 async를 붙이고 promise를 사용하는 부분에 await를 붙이면됨

function inc(num){
...
}

async function runTasks(){
	try{
		let result= await inc(0)  이렇게 await붙이고 함수콜하면 비동기로 실행한다음에 비동기끼리 동기적으로 순서대로실행
		result= await inc(result)
		result= await inc(result)
		result= await inc(result)
		result= await inc(result)
		result= await inc(result)
	}catch(e){
		console.log(e)
	}

}

axios는 http클라이언트 라이브러리로 url을 줘서 json데이터 받을수있음

사용법은
const [data,setData]=useState(null)데이터담을그릇
axios.get('url').then(response=>setData(response.data))
이렇게 get뒤에 then에 익명함수로 데이터 넣으면됨
이걸 비동기로 고치면

onClick=async()=>{
	try{
		const response= await axios.get('url').then(response=>setData(response.data))
		setData(response.data)
	}
}
그냥 async 익명함수앞에 붙이고 내부 비동기처리할곳에서 await붙이면됨

보통 데이터 받으면 json에 필드명:{텍스트 or 객체} 이렇게있는데 
const 컴포넌트=({데이터props})=>{
	const{필드명1,필드명2,필드명3,필드명4}=데이터props  
}
이렇게하면 필요한 필드만 가져다쓸수있음

컴포넌트가 화면에 보이는시점에서 api콜하려면 useEffect사용하면 되는데,useEffect에 등록하는함수에 바로 async를 붙이면안됨
useEffect가 반환해야하는값은 클린업함수기 때문
그래서 
useEffect(()=>{ 이게 클린업함수 여기다가 async붙이면안됨
	[loading,setloading]=useState(false)
	[articles,setarticles]=useState(null)
	const 내부함수=async(){
		setloading(true) 로딩키고
		const response= await axios.get('url')
		setarticles(response.data.articles) 변수명.data.내부데이터명
		setloading(false) 로딩끄고
	}
	
	내부함수();
	
},[]) 마운트할때만 할거라 빈배열넣어줌

그리고 밑에

if (loading){ 로딩중일떄 이거띄우고 로딩값이 비동기로 false로 바뀌면 넘어감
	return <div>로딩중</div>
}
if (!articles){ 비동기쓸때 map쓸거면 중간에 null인상태가 있기떄문에 map이 null먹으면 에러뜨니까 거기못가게 앞에서막아줘야함
	return null
}
return(
div
	articles.map(article=> (<newsitem key={url같은키} article(보내줄prop)={데이터}/>   )
div
)

카테고리따라 바꾸고싶으면 ``이거써서 url문자열중간에 동적으로처리해주면됨 라우트로 파라미터받아서 적어주는식으로

라우트안쓸거면 상위컴포넌트에서 함수만들어서 그거 하위에서 실행시켜서 위쪽usestate에 들고간다음에 그거 다시 다른하위로 보내줘서 그거넣어서
실행

<Route path="/:props명?">이러면prop이 있을수도있고 없을수도 있다는거
하위에서도
const category=match.params.category||'all' 이렇게 카테고리없으면 all선택하게 쓸수있음(둘다true면 앞에거선택)

위에 useEffect안에 비동기함수같은거 커스텀hook만들어다가 가져다쓰면 간결해짐
그냥 useEffect를하고 비동기처리만 책임지고  동작함수는 가져다쓰는곳에서 콜백으로 넣어주는식으로만해도 간결해짐

15.context api
context api는 예전엔 usestate로 계속 내려가면서 귀찮게 계속 props로 주면서 끌어올려야 되는걸 전역변수처럼 관리할수있게해줌
context가 업데이트되면 그걸 가지고있는 모든곳에서 리렌더링이 일어남

따로 전역변수용 js파일만든다음에
import {createContext} from 'react';해주고
const varContext(변수명아무거나)=createContext({abc:'black'})

export default varContext

하면 만들어짐

사용할때는 렌더링할때에 
<varContext.Consumer(context자체컴포넌트)>
	{value=>(   이런식으로 사이에 함수를넣어서 사용
		<div
		style={{
			background:value.abc 화살표함수의 첫매개변수에 context가 등록되니까 거기서 필요한변수 가져다쓰면됨
	)
	}
</varContext.Consumer>
원래 js에서는 render props라고 컴포넌트 사이에 함수를넣어서 쓰기도함

값을 context를 건드리지않고 지금쓸때만 바꿀때는  
<varContext.Provider value={{abc:'red'}}> value안넣으면 에러남 안쓸거면 그냥 지우자<varContext.Provider>이러면에러
</varContext.Provider>
이렇게 Provider를 써서 value프롭에 바꿀필드명에 바꿀값 넣어주면 됨
기존에 크리에이트했을때 적은 value값은 provider를 안썼을떄 뱉는 디폴트값임

그러니까 값을 그대로쓰고싶으면 consumer쓰면되고 값을 여기서만 바꾸고싶으면 provider쓰면됨

context의 디폴트값을 바꾸고싶으면(전역변수를 바꾸고싶으면)
context js파일에 usestate로 상태랑 바꾸는액션 선언한다음에 setstate 콜하는방식으로 바꾸면됨

const ColorCOntext=createContext({ 스테이트 액션 선언해주고 
	state:{color:'red'},
	action:{
		setColor:()=>{}
	}

})
provider 생성
const ColorProvider=({children})=>{ 사잇값받아서
	const[color,setColor]=useState('red')
	const value={  value에 스테이트액션넣어주고
		state:{color},   
		action:{setColor}
	}
	return(
		<ColorContext.Provider value={value}>{children}</ColorCOntext.provider>
	)원래 provider사용하는식으로 만들어서 보내주고


}

const{Consumer:ColorConsumer}=ColorContext ColorConsumer에 Counsumer 같은거라고 처리해주고
											(안해도됨 그냥통일성때문 그냥 consumer써도됨)

export{ColorProvider,ColorConsumer} 함수2개 내보내주고
export default ColorCOntext   값도 보내주고

consumer는 그대로
<ColorConsumer>
	<div background:{value.state.color}/>이런식으로 똑같이가져다쓰면되고
<ColorConsumer>
provider도 그대로 쓰고 (대신 value안적어줘도 안에서 적어줬기떄문에 에러안남)

값을 바꾸고싶으면
<ColorConsumer>
	<button onClick={()=>action.setColor('white')  />이렇게 그냥 setcolor콜하면됨
<ColorConsumer>

근데 함수형이나 클래스에서 저거너무귀찮으니까 함수형은 useContext hook쓰면 엄청편함

import React,{useContext} from 'react'
import 컨텍스트변수명 from './컨텍스트파일주소'

const {state}=useContext(컨택스트변수명)  이렇게 받아와서

<div background= {state.color}/> 그냥바로 이렇게쓰면됨 수정도 setColor불러와서 바로하면됨

클래스에선 
class sc extends component{
	static contextType(키워드)=컨텍스트변수명
	해주고 밑에서 바로
	background= {color} 이렇게 받아쓰면되는데

클래스는 하나당 하나씩밖에 못받아서 보통 함수형으로 다 씀 권장되는게 함수형이기도하고

16.리덕스
리덕스는 context api처럼 전역관리할때 쓰는 라이브러리임,근데 이게 좀 더 체계적으로 관리할수있고,
미들웨어라는 비동기작업하는 기능도 제공하고 개발자도구도 지원해서 좀 덩치큰 프로젝트다 싶으면 다 이거쓰는듯

리덕스에서 상태에 변화가 필요하면 리듀서 함수에 액션을 넣어서 변화를 만드는데,usereducer랑 똑같이 생각하면됨

액션은 type이 필수로 들어가야하고,상태변화에 필요한 값들을 추가로 넣어둘수있음

{
	type:'desc'
	data:{
		id:1
		text:'abc'
	}
}
결국 이런식으로 객체만 나오면 되니까 액션을 생성하는 함수를 만들어서 써도됨

function 액션생성함수(text){
	return{
		type:'insc',
		text
	}
}
or
const 화살표함수=text=>({
	type:'abc',
	text

})
이런식으로 함수나 화살표함수로 만들어서 안에 내용물이랑 타입 받아다가 넣을수도있음

리듀서는 변화를 일으키는 함수
액션을 만들고 리듀서에 넣어서 실행시키면 새로운 상태를 만들어서 리턴함
사용법은 usereducer랑 같음

const initstate={ 초기값 
	counter:1
}
function reducer(state=initstate,action){초기값 넣어줌
	switch(action.type){
		case insc:
		return counter:state.counter+1
		default return state
	}
} 
이런식으로 usereducer랑 똑같이 case문으로 action.type으로 구분해서 함수진입한다음 그거실행시키면됨
주의사항으로는 리듀서는 상태의 불변성을 유지해야하고(리액트에서 맨날 useState써서 유지하는거처럼 여기도 새거만들어서 덮어씌우는식으로해야함)
여기도 ...써서 return{...state,바꿀값:'abc'} 이런식으로 해야함
...은 얉은복사라서 객체에서 배열등으로 안으로 파고들면 딥카피못하니까 최대한 1차원에서만 만들어야함
정안된다싶으면 immer 써서 불변성관리해줘야함

프로젝트에 리덕스를 적용하려면 스토어를 만들면됨,한프로젝트에는 한 스토어만 들어갈수있음
스토어에는 현재 상태(전역변수들)과 리듀서가 들어가있고,
디스패치(액션을 발생시킴 즉 리듀서에 액션넣어서 사용하는함수),
구독(액션이 디스패치해서 상태가 업데이트되면 호출되는함수)
등이 있음

스토어를 넣을땐
import {createStore} from 'redux'

const store=createStore(reducer)
하면됨
이건 바닐라 자바스크립트에서 기본리덕스 쓸때 이렇게함

리덕스는
단일스토어를 지켜야하고
읽기전용상태여야하고(불변성유지해서 바꿀때는 ...써서 덮어씌우기로)
리듀서는 순수한 함수(인풋이랑 아웃풋이 항상 같아야하고 외부에 아무것도 의존하면안됨,랜덤같은거 안에다가 넣거나 date같은거 넣으면안됨)

17.리액트리덕스

리액트에서 리덕스를 사용할떄 자주사용되는 패턴은 컨테이너와 프레젠테이션을 분리하고  
컨테이너에 프레젠테이션과 스토어(리덕스)가 연결된식을 많이씀(mvc패턴 m 리덕스 v프레젠테이션 c컨테이너)

이러면 v를 보고 v에 이어진c로 인풋을 넣은다음 m에서 반응해서 아웃풋을 v로 넘기는식

보통 리덕스 코드 나누는건 두방식이 있는데
액션,액션타입,리듀서를 각각 폴더만든다음에 하나씩 넣는방식이고
액션 액션타입 리듀서를 각각 컴포넌트같은 기능하나단위로 한파일에 넣는방식 두개가 일반적으로 쓰임

액션타입을 정의할때 increase같은건 중복날수있으니까 
const INCREASE='모듈명/increase'이런식으로적어두는게 좋음

액션생성함수는 export const increase=()=>({type:INCREASE})
이렇게 만들어주면 import {increase} from './counter'이렇게 함수로 불러올수있음

리듀서는 기본적으로 똑같이 switch-case문으로 적는게 기본임

function cou(state=기본값,action){
	switch(action.type){
		case INCREASE:
			return{
				함수처리할거
			}
	}
}
이런식

만약 액션에서 파라미터가 필요하면 액션생성함수에서
export const increase=text=>(
	{
		type:INCREASE,
		text
	})
이런식으로 가져다쓰면됨

여기도 객체에 한개이상의 값이 들어가면 불변성유지를 해줘야함
function cou(state=기본값,action){
	switch(action.type){
		case INCREASE:
			return{
				...state,
				input:action.input
			}
	}
}
이렇게 안깊으면 ...으로 처리가능

이렇게 리듀서파일이 여러개라도 스토어는 하나만 등록가능하니까 combineReducers를 써서 리듀서를 합친다음에 스토어등록을 해야함
모듈디렉터리에 index.js를 만들면 불러올떄 디렉터리까지만 적으면 바로 인덱스를 읽기때문에 줄 줄일수있음

import {combineReducers} from 'redux'
import 사용할모듈1
import 사용할모듈2

const rootreducer=combineReducers({
	모듈1,모듈2
})

export default rootreducer

그다음엔 스토어를 만들어줘야하는데 
src/index/js에 스토어를 만든뒤 react-redux에서 주는 provider에 스토어를넣고 <app/>를 감싸주면됨

const store=createStore(rootreducer)

reactdom.render(
<provider store={store}>
<app/>
</provider>,
도큐어쩌구저쩌구관심없음)

그리고 리덕스데브툴을 쓰면 스토어값이랑 액션호출을 바로 볼수있으니까 그거도 적용하면좋음
yarn으로 설치하고 
import {composeWithDevTool} from 'redux-devtools-extension'

const store=createStore(rootreducer,composeWithDevTool())
이거만해주면됨

컨테이너를 스토어에 연동하려면 export default 컨테이너 를 
export default connect(스테이트프롭,디스패치프롭)(컨테이너) 이렇게 바꿔주면됨


위에 사용할 스테이트랑 액션들
import {사용할액션} 모듈에서 불러오고

const container=({넘버,액션1,액션2})=>{
 return(
	<div 넘버={넘버} 온클릭={액션1}
 )
}
export default connect(
	스테이트=>{
		넘버:스테이트.사용할리듀서.사용할값
	}
	, dispatch=>({ 액션1:()=>dispatch(사용할액션() ),액션2:()=>dispatch(사용할액션2() ) })(컨테이너)

이렇게 스테이트값이랑 액션이랑 리듀서와 뷰를 연결시켜주면됨

그리고 그냥 dispatch도 귀찮으니까 
export default connect(
	스테이트=>{
		넘버:state.사용할리듀서.사용할값
	}
	, { 사용할액션,사용할액션2}, )(컨테이너)
	
이렇게하면 connect가 자동적으로 사용할액션이라는 글자로 액션을 만들어줌
(저기쓴함수명이랑(사용할액션) 위에 container=({넘버,액션1,액션2})  여기의 함수명이랑(액션1) 같아야 저기에 커넥트됨)

reduce-action을 쓰면 좀 편하게 쓸수있음

export const increase=()=>({type:INCREASE})이거를
export const increase=createAction(INCREASE)이렇게 넣어서 만들수있음

그리고 리듀서 함수는

const 리듀서=handleActions(
	{
		[INCREASE]:(state,action)=>({number:state.number+1 }),
		[DECREASE]:(state,action)=>({number:state.number-1 })
	}
)
이런식으로 switch-case문을 빼버리고 줄일수있음
그리고 여기서 추가적인 매개변수가 필요할경우 
액션생성함수에서 
export const increase=createAction(INCREASE,text=>text) 이런식으로 준다음에
action.payload를 받으면 준값이 나옴

handleActions(
	{
		[INCREASE]:(state,action)=>({text:action.payload }),
		
	}
)
근데 이러면헷갈리니까 
[INCREASE]:(state,{payload:input})=>({text:input }),
이런식으로 이름붙여서 명명할수있음

여기도 모듈이 복잡해지면 ...으로 해결이 안되니까 immer를 써야하는데 불변성유지떄문에

[INCREASE]:(state,{payload:input})=>produce(state,draft=>{draft.input:input+1 })
이런식으로 함수 받을때 produce써서 immer 평상시쓰는거처럼 쓰면됨

connect너무 귀찮다싶으면 useSelector이랑 useDispatch써서 커넥트시킬수도있는데

그냥 const 컨테이너 =()=>{
	const number=useSelector(state=>state.모듈명.사용할값)
	const dispatchaa=useDispatch();
	const change=usecallback({()=>dispatchaa(사용할함수받아온거)},[dispatchaa])
	
	return<counter number={number} onChange={change} />
}
export default 컨테이너
이렇게 그냥 내부에서 처리해버릴수도있음
useDispatch는 숫자가 바뀌어서 리렌더링할때마다 함수가 렌더링되기떄문에 반드시 usecallback을써서 묶는 습관들여야함

https://react-redux.js.org/next/api/hooks#recipe-useactions 여기가면 useActions있는데
원래 react-redux에 넣을라다 만건데 저거 가져와서 가져다쓰면

그냥 const 컨테이너 =()=>{
	const number=useSelector(state=>state.모듈명.사용할값)
	const [a,b,c,d]=useActions([모듈a,모듈b,모듈c,모듈d],[])
	
	return<counter number={number} ona={a} onb={b} ona={b} ona={b}/>
}
이렇게 배열로 한번에 커넥트시켜줄수있음

 connect를 사용해서 만들었을때는 컨테이너의 부모컴포넌트가 리렌더링될떄 바뀐게없으면 렌더링이 자동으로 안되는데
useSelector나 useDispatch를 사용했으면 렌더링될때마다 같이렌더링되니 react.memo()를 써서 렌더링막아야함

export default react.memo(컨테이너)
이렇게

18.리덕스 미들웨어

리덕스 미들웨어는 액션과 리듀서 사이에서 액션이 들어오면 액션을 처리하거나 무시하거나,다른액션으로 바꿔치기하거나 추가적인액션을 하거나
할수있게 중간에 끼워넣는 중간자임

미들웨어에서 next를 해주지않으면 리듀서나 다음미들웨어로 넘어가지 못하게되면서 액션을 무시하게됨

미들웨어의 기본구조는
const 미들웨어=store=>next=>action{
...
}
임
미들웨어에서 store.getState()하면 상태를 받아올수있는데
next전에 하면 이전상태를 받아오고 next이후에하면 업데이트된상태를 받아옴
action을 로그로 출력하면 무슨액션인지도 받아올수있음

미들웨어를 적용하는방법은 
createStore(rootreducer,applyMiddleWare(적용할미들웨어1,적용할미들웨어2))
리덕스데브툴을 쓰고싶으면 
import { composeWithDevTools } from 'redux-devtools-extension';임포트한뒤에
createStore(rootreducer,composeWithDevTools(applyMiddleWare(적용할미들웨어1,적용할미들웨어2)))
이렇게 감싸주면됨

보통 많이 사용하는 미들웨어에는 redux-thunk와 redux-saga가 있는데
redux-thunk는 비동기작업을 할떄 가장 많이 사용되고,객체가 아닌 함수형태의 액션을 디스패치하게해줌

만약 const a=x=>x+1하면 a(1)하자마자 바로 연산이되는데
a(1)
function b(x){
	const thunk=()=>a(x)
	return thunk
	
}
이렇게 만들어두고 가져다쓸땐
const fn=b(1)
settimeout(()=>{
	value=fn();이시점에 연산하기때문에 비동기처리할때 타이밍잡기 좋음
}
)

사용법은 yarn add하고 스토어 미들웨어에 적용시켜준뒤(index.js)

모듈파일에서(리듀서파일) 액션생성함수에서 함수를 리턴할수있게됐으니까 settimeout같은 비동기로 처리할수있어짐
export const incrAsync=()=>dispatch=>{
	setTimeout(()=>{
		dispatch(incr())
	},1000)
}
이런식으로 객체가 아닌 함수를 리턴할수있음

보통 리듀서에서 api를 호출할때는 promise기반인 axios를 설치해서 사용함

임포트하고
axios.get('주소나 api')를 쓰면됨

api를 쓸때는 서로 로딩 있으니까 로딩중인지 로딩끝났는지 알려주는 값을 initstate에 넣어두고 로딩시작하면 켜고 끝나면 끄고하는식으로
해야함

여기서 데이터를 불러와서 랜더링할때(컴포넌트단에서) 유효성 검사를 해줘야함
{loading&&'로딩중'}으로 로딩이 트루면 로딩중이 뜨게하고
{!loading&&data&&( 이런식으로 로딩이 끝나고 데이터값이 있을때만 랜더링을 시작해서 값을 넣도록해야함
	<div>
	...
	</div>
)}
안그러면 map같은거는 배열로 들어올거라고 생각하고 받는데 null이 들어오면 에러를뱉음

그리고 액션생성함수를 분리해서 사용할때 
export default function abcThunk(type,request){
...
return param=>async dispatch=>
}
여기서 type,request는 바로 위에서 받아오고(모듈)
param은 모듈의 상위에서 받아옴(컨테이너)
컨테이너에서 모듈의 함수를콜(파라미터a)->모듈에서 분리한함수를 콜(파라미터b) 
그러면 바로콜한데는 파라미터b 상위파라미터는 리턴에서 받을수있음

redux-saga는 thunk보다 까다로운 상황에서 잘 사용됨

기존요청을 취소해야하거나(중복실행방지)
특정액션에 체인해서 다른액션을 발생시키거나
웹소켓을 쓰거나
api 실패시 재요청해야할때

redux-saga는 제너레이터를 쓰는데

제너레이터 함수는 
function* a(){
}
이렇게 만들고 
function* a(){
	yield 1;
	yield 2;
}
yield 사이를 generrator.next()가 들어와야 다음걸로 넘어감(비동기)

redux-saga의 사용법은 
yarn add하고 import해준후

export const incr=createAction(incr,()=>undefined) 뒤에()=>undefined는 마우스클릭이벤트 들어오는거방지
값받고싶으면 createAction(incr,id=>id)이렇게 받으면됨

function* incrSaga(){
	yield delay(1000);
	yield put(incr());
}
export function* counterSaga(){
	yield takeEvery(액션,incrSaga);
}
이런식으로 사용
yield로 다음 액션까지 기다리고(위에서는 1초)
incr을 풋해줌(디스패치)

delay는 지정시간 기다리기
put는 디스패치(파라미터로 액션을 받아오면 액션의 정보를 볼수있음)
select(state=>state.값) 값을 받을수있음 액션이나,상태같은거
call은 call(함수,함수에 넣을인수들 콤마로 계속) api같은거 쓰거나 함수분리했을때 사용
	call(api.getpost,action.payload)이런식
takeEvery는 들어오는 모든액션에대해 처리
takeLatest는 기존에 진행되던작업을 취소하고 마지막거만 처리
throttle는 n초에 한번만 처리(맨앞에거만 처리하고 n초동안 들어오는거무시)

이거도 리듀서처럼 하나로 합치고
export function* rootSaga(){
	yield all([counterSaga()])
}
인덱스에 
const sagamiddle=createSagaMiddleware()
store=createStore(rootreducer,applyMiddleWare(sagamiddle))
sagamiddle.run(루트사가)
하면 적용됨

saga는 액션의 두번쨰 파라미터로 넣은값을(컨테이너에서 넣은값) action.payload로 받아볼수있음
createAction(incr,id=>id)이랬으면 
call(api.getpost,action.payload)이렇게 받으면 action.payload는 id임
함수분리 했을때도 똑같이 action.payload조회하면 같은값임

19.코드스플리팅

리액트를 빌드하면 임포트한 모든값을 다 가져와서 집어넣어서 한파일로 만들기때문에 경우에따라 사용하는 컴포트들도 그냥 임포트하게되면
파일용량이 늘어나서 처음방문했을때 대기시간이 길어지게 되니까 사용할때 임포트해서 사용하는방법

React.lazy와 Suspense를 사용해서 하는방법이랑 loadable Components를 사용해서 하는방법 2개가 있는데
loadable Components가 서버사이드 렌더링을 지원해서 보통이거쓰는듯
사용방법도 똑같음 loadable components에는 suspense가 안들어간다는거빼면

yarn add  @loadable/component해주고

import loadable from '@loadable/component'임포트한다음
sp=loadable(()=>import('./파일명')) 이렇게 임포트하는거처럼 쓰면됨

로딩중에 로딩중이라고 알려주고싶으면
sp=loadable(()=>import('./파일명'),{fallback:<div>로딩중<div> })
이렇게 html fallback에 담아서 2번째 매개변수에 넣어주면됨

만약 클릭해야 하는데 클릭하기이전(마우스오버라든가)그럴때 미리 로드하고싶으면
const on mouseover=()=>{
	sp.preload()
}
하고 이벤트에 넣어주면 이벤트실행될때 프리로드함

20.서버사이드렌더링










