도메인관련만 보고 넘어가자
1.서장
	스킵
2.msa의 이해
	스킵
3.마이크로서비스 어플리케이션 아키텍처
  1.관심사의 분리
	기술과 비즈니스로직은 관심사의 분리가 돼있어야함
	sql에 비즈니스로직이 몰려버리면 db가 병목지점이 돼버림
	
	어플리케이션의 유지보수성이 높다는 의미는,특정 개인이 아닌 어느 누구라도 애플리케이션을 이해하고 유지보수할수있다는걸 의미함
	
	db중심의 아키텍쳐의 문제는,간단한경우엔 편하지만,복잡해지면 점점 복잡성을 제어할수없어짐
	또한 업무개념이 db테이블로 표현되고,복잡해질수록 업무규칙이 sql과 섞여 표현됨
	그리고 저장기술과 비즈니스로직이 강결합되기때문에,저장소변경도 힘들고,대부분의 성능을 db에 의존해서,
	성능튜닝할곳이 마땅치않고 스케일아웃을 하기힘듬
	
	db는 단순히 데이터입출력만 하고 진짜 일을 하는건 어플리케이션이어야 여러가지로 이득을 볼수있음
	또한 어플리케이션 자체 성능보단 확장성과 유연함이 더 중요하기도 하고

  2.핵사고날 아키텍처와 클린 아키텍처
	레이어드 아키텍처는 의존성역전원칙을 지킬순있지만,개방폐쇄원칙을 지키기 어려움
	이걸 해결하기위해 인터페이스를 만들고 상위에 넘겨준다고 하더라도,
	저수준계층인 db와 웹계층 말고도 다양한 인터페이스를 비즈니스계층에선 필요로하고,레이어드는 이런걸 해결하기힘듬
	그래서 사용되는게 핵사고날임
	
	헥사고날은 포트어댑터 아키텍처로,고수준의 비즈니스로직인 내부와,인터페이스처리를 담당하는 외부로 나눠짐
	내부는 순수한 비즈니스로직을 표현하는 기술독립적인 영역이고,외부와 연계되는 포트(인터페이스)를 가지고있음
	외부는 외부에서 들어오는걸 처리하는 인바운드어댑터와 비즈니스로직에 의해 호출되어 외부와 연계되는 아웃바운드 어댑터로 구성됨
	
	헥사고날의 가장 큰 특징은,내부가 외부의 구체어댑터에 전혀 의존하지않는다는것,이걸 가능하게하는게 포트임
	포트는 인바운드와 아웃바운드로 구분되고,
	인바운드는 내부영역의 사용을 위해 표출된 api고 외부영역의 인바운드 어댑터가 호출함
	아웃바운드는 내부가 외부의 호출방법을 정의함
	여기서 중요한건 아웃바운드 어댑터가 아웃바운드 포트에 의존해서 구현된다는것
	
	클린아키텍처는 구조중 선택할수있는걸 가능한 오래 열어두는것,즉 중요하지않은 세부사항을 가능한 오래 열어두는걸 목표로함
	이건 중앙부터
		엔티티//비즈니스로직
		유스케이스//어플리케이션 로직
		컨트롤러,프레젠터,게이트웨이//인터페이스 어댑터
		웹,ui,외부인터페이스//프레임워크 & 디바이스
	로 이루어짐
	엔티티는 도메인이라고 보면되고,여기에 비즈니스로직이 다 들어감
	유스케이스(애그리거트)는 자동화된 시스템을 사용하는 처리절차고,어플리케이션의 기능단위로 로직을 표현함
	이때 엔티티는 유스케이스에 의존하면안됨,유스케이스가 엔티티에 의존해야하고,엔티티는 pojo여야하고 유스케이스를 통해서만 조작해야함
	여기까지가 핵심이고,나머지는 전부 세부사항임

  3.마이크로서비스의 내부구조 정의
	좋은 구조는
		지향하는 관심사에 따라 응집도를 높이고 관심사가 다른영역과는 의존도가 낮아야함
		비즈니스로직과 다른기술영역을 분리해야함
		세부기술이자 저수준인 외부와 핵심업무규칙이자 고수준인 내부로 구분해야함
		고수준은 저수준에 의존하면안되고,저수준이 고수준에 의존해야함
		저수준은 언제든지 교체,확장가능해야하고,이런 변화가 고수준에 영향을 주면 안됨
		저수준의 구체클래스가 고수준의 추상인터페이스에 의존해야함
		인터페이스는 고수준의 안정된 영역에 존재해야하고,저수준의 어댑터가 이를 구현해야함
	이런 원칙을 지켜야함
	
	내부영역에서는 맨 안에 도메인이 존재하고,이걸 서비스가 감쌈
	도메인엔 비즈니스로직을 구현하고,서비스는 도메인을 호출해서 업무를 처리하는 절차를 기술함
	또한 외부와 연계하기위해 서비스인터페이스를 만들고,이 인터페이스는 외부에서 내부를 사용할수있게 api를 제공해야하고,서비스가 이를 구현해야함
	
	내부의 또다른 인터페이스는 레포지토리 인터페이스임,
	이건 외부가 아닌 내부에 속하는데,얘로 비즈니스를 처리하는데 필요한 기본적인 저장소처리사항을 추상화해 정의함
	그러면 외부의 저장소어댑터는 이 인터페이스를 각 db에 맞게 구현하면됨
	이런식으로 레포지토리말고도 다양한 기술들(restapi,이벤트메시지)등도 이런식으로 의존성역전으로 구성하면됨
	
	
	내부영역에는 서비스인터페이스,서비스구현체,도메인,리포지토리 인터페이스,도메인이벤트 인터페이스,api프록시 인터페이스가 존재함
	서비스인터페이스는 외부가 내부에대해 너무 많이 알지못하게 하고,추이종속성을 막아주고
	리포지토리,도메인이벤트,api프록시 인터페이스는 dip를 지원함
	내부의 핵심은 서비스와 도메인임,이건 유스케이스와 엔티티와 역할이 같음
	도메인은 비즈니스개념을 표현하고,서비스는 도메인을 활용해 시스템흐름처리를 수행함
	
	트랜잭션스크립트는 이때 도메인이 행동을 가지고있지않고,행동을 수행하는 책임을 서비스가 가지고있는것
	서비스는 유스케이스의 처리단위인데,비슷한 유스케이스의 경우 서비스에 중복되는 코드가 계속 생겨나고,
	간단히 만들긴 좋지만,복잡해지면 코드가 늘어나는등 단점이 있음
	
	도메인모델은 행동을 도메인이 가지고있고,서비스는 도메인에서 처리하기힘든것과,조합을 담당하게됨
	그래서 서비스메서드가 단순해짐
	
	애그리거트패턴은 최상위 엔티티를 중심으로 개념집합을 분리한것
	그래서 애그리거트를 한단위로 일관되게 처리하기위해 규칙을 사용하는데
		애그리거트 루트만 참조
		애그리거트 내의 상세클래스를 바로 참조하지않고 루트를 통해 참조해야함,수정도 마찬가지
		애그리거트간 참조는 객체를 직접참조하지않고 기본키를 사용
		기본키를 사용하면 약결합이 되고,수정이 필요하지않은 애그리거트가 같이 수정되지않음
		하나의 트랜잭션으로 하나의 애그리거트만 생성 및 수정함
	임
	
	
	외부영역은 내부의 서비스인터페이스를 사용하는 인바운드어댑터와,내부에서 선언한 아웃바운드인터페이스를 구현하는 다양한 어댑터로 구성됨
	어댑터는 언제든지 교체 또는 확장가능해야하고,그래서 내부를 먼저 정의하고 외부의 세부사항을 늦게 정의해야함(구현순서를 이렇게잡아야함)
	
	이때 각 어댑터들의 구현메커니즘과 고려사항은
		api퍼블리싱어댑터:restapi를 발행하는 인바운드어댑터,내부의 서비스인터페이스를 호출해서 api로 제공,dto로 전달하는게 좋음
		api프락시 어댑터:다른서비스의 api를 호출하는 아웃바운드어댑터,내부의 프락시 인터페이스를 구현하고,api는 rest일지 soap일지 모름
		레포지토리 어댑터:orm과 sqlm이 있음
		도메인이벤트 발행 어댑터:서비스간 비동기메시지통신에 사용되는 아웃바운드 어댑터(msa),도메인이벤트는 내부에서 생산하고,얘는 발행만 맡음
		도메인이벤트 핸들러:도메인이벤트를 수신하는 인바운드어댑터,외부도메인이벤트를 구독하고 내부영역으로 전달함
	등이 있음
	
	
4.마이크로서비스와 애자일개발 프로세스	
	
	
	
	
	
	
	
	
	
	
	
	
	