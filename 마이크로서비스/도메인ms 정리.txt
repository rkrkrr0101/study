1.서론
	스킵
2.msa의 이해
	기본적으로 msa는 탄력성과 유연성을 가져야하고,그러기위한 방법으로 메시지기반을 채택함
	msa에선 각 요소들은(코드언어,오케스트레이션,컨테이너화,프로비저닝 등) 여러개중에 하나를 택하는 블럭식으로 구성할수있음
	
	msa의 구성요소로는,인프라,플랫폼,앱이 있고,
	인프라는 컨테이너나 vm선택과 aws같은 클라우드선택이 있고
	플랫폼에선 젠킨스같은 파이프라인선택,메시지버스,로깅과 모니터링,구성관리,git등이 있고
	앱에선 채널(모바일,웹등 선택),프론트엔드,백엔드(마이크로서비스 내부아키텍쳐들),db가 있음
	
	ci/cd는 기본적인 템플릿은 가져가되,각 마이크로서비스는 각각 파이프라인을 가져야하고,자기의 필요에맞게 테스트등을 변경할수있음
	
	기본적으로 ms들은,나눠졌을때 서로간의 로드밸런싱이 필요한데,이건 k8s의 서비스가 해결하고,
	ip뒤에 /a /b같이 나눠지는거 처리는 인그레스가,
	외부설정주입은 컨피그맵이 해결함(내부에 설정두면 다른노드에 파드뿌렸을때 동작안할수있으니)
	
	그리고 서비스 파드가 뻗으면,대체하는 다른 파드나 컨테이너로 트래픽을 옮기는건,서킷브레이커패턴이라고 하고 k8s기본기능
	로깅과 모니터링은 프로메테우스같은거로 메트릭수집해서 그라파나같은거로 모니터링
	
	앱에선,기본적으로는 모노리스프론트엔드에 백엔드ms를 붙일수있는데,이러면 또 둘간에 결합이 단단해지니까 프론트엔드도 ms로 만들어서,
	백엔드와 프론트엔드를 합쳐서 하나의 ms로 구성하고,그걸 블록으로 생각하고 폼에 추가하는식으로 구성하는게 좋음
	즉 백엔드와 프론트엔드끼리는 어쩔수없이 결합이 단단해지니까,그렇게 묶은걸 하나로보고 한팀에서 처리하는거
	
	이떄 통신방식으로는,단일진입점을 사용한 동기통신과,이벤트브로커를 사용한 비동기통신(그거맞음 이벤트기반ms)이 있음
	
	동기통신은 웹이든 앱이든 둘다 단일진입점에 있는 api게이트웨이를 타고,걔가 인그레스처럼 명령을 전달해주는(restapi로)거임
	이때 만약 서비스끼리 통신이 필요하면,다시 api게이트웨이로 서비스에서 요청을 보내면 게이트웨이가 전달을 해줌
	즉 오케스트레이션과 비슷함
	이때 만약 답이 오지않고 계속 시간끌리면(해당서비스에 문제가생겨서),문제가 없던 서비스까지 문제가 생기는,연쇄장애가 발생할수있음
	즉 통신하는 두 서비스간엔 의존도가 높다는거라서 ms에선 별로 추천되지못함
	
	그래서 나온게 이벤트기반ms(비동기통신)임
	얘는 그냥 프로듀서가 이벤트스트림에 데이터를 생산하고,컨슈머가 거기를 계속 감시하면서(브로커가 감시하다 뜨면 알려주지만 이론적으론)이벤트를 기다리는거임
	여기는 브로커가 할일이 많으니까,브로커에 부하가 생길수있는데,그러면 브로커를 확장해주면됨
	이벤트기반ms는 서로 통신하는 서비스들이 물리적으로 같은데있을필요도없고,동일한시간대에 있을필요도없음(어짜피 펜팔비스무리한거니까)
	
	
	그리고 ms는 각각 서비스마다 저장소를 가짐
	만약 통합저장소를 사용하게되면,저장소를 기반으로 서로간에 관계성이 생겨서,문제가 생기거나 새기능을 추가할떄 유지보수가 매우어려워짐
	그래서 각 ms는 각각 저장소를 가지고,그 저장소를 외부에 노출하지 않고,공개할일이 있으면 자신이 생성한 api를 통해서만 노출이 가능하게 만들어야함
	이러면 저장소도 서비스의 특성에맞춰서 알아서만들수있고,데이터스키마변경에 따른 파급효과가 줄어서 변경이 쉽고  서비스가 독립적이 됨
	
	물론 문제점으론,각 데이터끼리 정합성과 일관성이 안맞을수있어짐
	그래서 트랜잭션처리등이 필요함
	이거도 일반적인 트랜잭션으론 처리하기가 힘들어서(연관된 모든 서비스의 저장소에 동시에 트랜잭션을 걸어야하니),
	방금 처리한 이벤트의 보상트랜잭션코드를 정의해두고,문제가 생기면 그걸 호출해서 처리함
	물론 일반트랜잭션처럼 완전한처리는 안되지만,그정도의 정합성은 보통 필요없는경우가 많아서 이정도로도 충분함
	여기에서 코레오그래피와 오케스트레이션이 있는데,둘다햇으니까 넘어가자
	이거의 장점은(코레오그래피),기본적으로 동작한곳까지만 트랜잭션이 발동하니까,아직 도착하지 않은곳에선 부하가 안걸린다는것
	
	그리고 가용성을 높이가져가기위해 할수있는 패턴들이 있는데,대표적으로는 읽기와 쓰기를 분리하는(데이터저장소를 2개사용하는),cqrs라는 방법이 있음
	보통은 읽기가 부하가 많이걸리고,쓰기가 덜걸리니까, 쓰기를 좀 작게만들고 읽기를 크게만든다음,쓸때 쓰고나서 적당한시간동안 모으던가해서 한번에던져서
	조회모델의 성능을 보장하는 방식임
	이러면 쓰기모델에서는 부하가 거의없어지고,읽기모델도 부하가 줄어듬(트랜잭션이 덜걸리니까)
	물론 짧은시간동안(쓰기모델에서 읽기모델 가는동안)은 일관성이 깨질수가 있는데,이게 그렇게 중요하지않을떄만 사용가능함
	그래서 이벤트브로커를 사용함,어짜피 일정시간이 지나면 결과적으론 정합성이 맞아지니까
	
	그리고 cqrs를 사용하면,여러 서비스에서 리턴을 받아야하는 게이팅패턴도 쉽게 처리가 가능해짐
	순서에 상관없이 다쌓이면 리턴하면되니까(상위api를 만들수도있지만,그러면 아래에 하나라도바뀌면 다수정해야하니까 결합도가 높음)
	
	그리고 아예 객체의 상태를 저장하지않고,로그만 저장해서 상태를 추론하는 이벤트소싱도 가능함
	이러면 이벤트브로커와 데이터저장소가 합쳐지고,다른과정이 없으니 쓰기가 빨라짐
	현재상태추론할떈 처음부터 모든데이터대로 행동하면되고,너무많으면 스냅샷따서 거기를 출발점으로잡으면됨
	그리고 업데이트와 삭제가 일어나지않으니,입력과 조회만 체크하면되니까 쓰기성능이 올라가고,로깅이 따로필요없음(다기록하고 안지우니까)
	트랜잭션도 그냥 예전으로 돌리면되고
	
	
3.ms 앱 아키텍쳐
1.관심사의 분리
	마이크로서비스는 기술경계가 아닌,비즈니스로직경계에 맞추어야함
	비즈니스로직은 기술보다 바뀌는 횟수가 적기때문에,그래야 변경횟수가 줄어듬
	
	그리고 db sql문을 기반으로 한 데이터베이스 중심 아키텍쳐의 문제점은,데이터베이스 성능저하로 데이터베이스가 병목점이 되었을때
	그걸 해결할수 있는 방법이 sql튜닝뿐임
	이패턴은 구현이 편하지만,점점커지면 복잡성이 엄청나게늘어남
	그리고 결합도도 높아서,db를 변경한다던가 하는건 엄청큰일임

2.헥사고날 아키텍쳐와 클린 아키텍쳐
	1.레이어드 아키텍쳐
		레이어드 아키텍쳐의 레이어는,논리적으로 프레젠테이션,비즈니스로직,데이터엑세스 3계의 층으로 나눠서 분류하는것
		대충 
			화면표현과 전환처리는 프레젠테이션,
			비즈니스개념,규칙,흐름제어는 비즈니스로직
			데이터처리는 데이터엑세스
		여기서 기본규칙은
			상위계층이 하위계층을 호출하는 단방향성(프레젠테이션이 데이터처리에 보낼수없음)
			상위계층은 바로밑계층만 활용함
			상위계층이 하위계층에 영향받으면안됨
			하위계층은 누가 불렀는지 알필요없음
			계층간의 호출은 인터페이스쓰는게좋음
		이 레이어드 아키텍쳐는,의존성 역전 원칙(의존성이 추상에 의존하고,구체적인거에 의존하면안됨(인터페이스쓰라는소리))는 만족하지만,
		개방폐쇄의 원칙(개체에 메소드를 추가할수는있지만 개체자체가 바뀌면안됨)에는 어긋남
		모든 계층이 자신이 제공하는 기능에 대한 인터페이스를 직접 정의하고 소유하고 있기 때문
		추상 인터페이스를 사용해서 인터페이스의 구현체를 달리하는방법으로 의존성을 줄이고,다형성을 유지할순 있지만 추상특성의 한계를 넘진못함
		
		앱에선 비즈니스 로직이 핵심영역이라서,다른 영역의 변경이나 확장에 영향을 받지않아야함
		그래서 의존관계의 역전이 필요함
		데이터엑세스계층에서 정의했던 인터페이스를,비즈니스 로직계층으로 옮기면 데이터액세스구현체는 그걸 바라볼수밖에 없음
		
		즉 비즈니스로직에서 자기가 필요한거 발주하고,다른 층에서 그거보고 구현하는거
		
	2.헥사고날 아키텍쳐
		저걸 적용해도 한계가 있는게,보통 요즘앱들은 프레젠테이션과 데이터액세스말고도 다양한 인터페이스들이 필요하기때문
		단방향 계층구조에선 이런걸 지원하기가 힘들어서 나온게 헥사고날임
		
		헥사고날은 포트 앤드 어댑터 아키텍쳐라고도 함
		내부 비즈니스 로직을 두고,거기서 인바운드 아웃바운드 포트들을 둬서 io를 처리하는것
		이러면 내부영역이 외부의 구체어댑터에 전혀 의존하지않음(어짜피 포트로 들어오는거만 받으니)
		
		포트는 인바운드포트와 아웃바운드포트로 구분되는데,
		인바운드는 내부영역의 사용을 위해 표출된 api이고,외부영역의 인바운드 어댑터가 호출함
		아웃바운드는 내부영역이 외부를 호출하는 방법을 정의함
		여기서 아웃바운드포트가 외부의 아웃바운드어댑터를 호출하는게 아니라,어댑터가 포트에 의존함(어댑터가 기다리다가 들어오면 던짐)
		
		인바운드어댑터엔 restapi,아웃바운드 어댑터엔 데이터액세스용 dao(room에서 그거인듯),이벤트메시지발행 클래스,외부서비스호출 프락시등이 있음
		
	3.클린 아키텍쳐
		클린 아키텍쳐는,헥사고날에서 선택할수 있는걸 가능한 오래 열어두는것,특히 중요하지 않은 세부사항같은걸 오래열어두는거임
		
		정중앙엔 엔티티가 있고,엔티티는 핵심 업무 규칙과 거기에 따른 데이터(핵심업무규칙의 데이터는 둘이 서로 결합되어있을테니)를 묶어서 객체로 만드는데
		이걸 엔티티객체라고 함
		
		그리고 엔티티를 감싸는 객체는 유스케이스임
		얘는 자동화된 시스템을 사용하는 처리절차를 기술함
		유스케이스는 앱에 특화된 업무규칙을 표현하고,엔티티 내부의 핵심업무규칙을 호출하고 시스템을 사용하는 흐름을 담음
		이때 엔티티같은 고수준에선 이쪽영역을 알면 안됨
		엔티티는 간단한 객체여야하고,프레임워크,데이터베이스같은 복잡한거에 의존하면 안되고,유스케이스를 통해 조작해야함
		즉 엔티티안에 유스케이스의 메소드를 호출하는 메소드가 있고,그걸 통해서만 접근할수있음
		
		그리고 유스케이스를 감싸는 나머지 모든게 세부사항임
		입출력,저장소,웹시스템,서버,프레임워크,통신프로토콜등
		세부사항과 유스케이스의 관계를 의존성역전해서(인터페이스를 유스케이스로 땡겨와서),플러그인처럼 처리해야함
		이렇게 결합을 명확히 분리하면,테스트가 편하고 개발독립성,배포독립성을 강화할수있음
		
	
3.ms 내부구조 정의
	1.클린ms
		헥사고날이나 클린아키텍쳐같은건,굳이 ms만을 위한 아키텍쳐는 아니고,모놀리스쪽에서도 잘 쓸수있음
		
		마이크로서비스는 각각 내부구조가 다양할수있음,입출력만 제대로해주면 팀에서 알아서 만들기때문
		즉 언어,db,아키텍쳐 전부 자기맘대로 할수있음 restapi만 사용하면
		
		그래서 간단한거의경우엔 헥사고날같은걸 쓸필요없지만,좀 커진다싶으면 헥사고날이나 클린아키텍쳐구조를 기반으로 정의하는게 좋음
		
		이때 원칙은
			지향하는 관심사에 따라 응집성을 높이고,관심사가 다른영역과는 의존도가 낮아야함
			업무규칙을 정의하는 비즈니스로직영역을 다른 기술기반영역으로부터 분리해야함
			세부기술중심,저수준의 외부영역과 핵심업무규칙이 정의된 고수준의 내부영역으로 구분
			고수준영역은 저수준에 의존하면안되고,저수준이 고수준에 의존해야함(내부 인터페이스)
			저수준영역은 언제든 교체확장 가능해야하고,이게 고수준에 영향을주면안됨
			인터페이스와 추상클래스를 지원하는언어는,저수준의 구체클래스가 고수준의 추상인터페이스에 의존하게하면 쉬움
			인터페이스는 고수준의 안정된 영역에 존재해야하고,저수준의 어댑터가 이를 구현함
		
		구현은 내부영역의 맨안에 도메인이 존재하고,도메인을 서비스가 감싸고있음
		
		도메인은 핵심비즈니스개념과 규칙,서비스는 도메인을 호출해서 업무를 처리하는 절차와 외부와의 연계를 위해 서비스인터페이스를 보유
		
		서비스 인터페이스는 외부에서 내부를 사용할수있게 api를 제공하고 서비스가 이를 구현함
		
		내부영역의 또 다른 인터페이스는 저장소처리를 위한 인터페이스임
		이건 비즈니스를 처리하는데 필요한 기본 저장소 처리사항을 추상화해 정의함
		그러면 외부영역의 저장소어댑터는,이 리포지터리 인터페이스를 각 저장소에 맞는 세부기술로 구현하게됨
		
		이거말고도 다양한 인아웃바운드 어댑터들이 존재하는데,모든 아웃바운드어댑터는 의존성역전되어야함
	
	2.내부영역
		내부영역구현에는 서비스인터페이스,서비스구현체,도메인,리포지터리 인터페이스,도메인 이벤트 인터페이스,api프락시 인터페이스등이 존재함
		서비스 인터페이스는 외부가 내부에대해 알기 어렵게 하고,추이종속성을 막을수있음
		리포지터리,도메인,api프락시인터페이스는 의존관계역전이 되어야함
		핵심인 서비스와 도메인은,클린아키텍쳐의 유스케이스와 엔티티와 역할이 같음
		이걸 구현할때 쓸수있는게 트랜잭션 스크립트패턴과 도메인 모델 패턴임
		
		트랜잭션 스크립트 패턴은,도메인객체가 메소드를 가지지않고,모든 행동책임을 서비스에 맞기고 엔티티는 값만 가지고있음
		이러면 서비스는 점점 커지고,도메인은 점점 정보묶음역할만 하게됨
		그리고 서비스는 유스케이스 처리의 단위고,대부분의 로직처리가 서비스에서 일어나니까 비슷한유스케이스의 경우 서비스에 중복되는코드가 계속 생겨나서
		유지보수가 어려워질수있음
		일단 처음에 짤땐 간단하니까,가벼운프로그램같은경우 쓸수있음
		
		
		도메인 모델 패턴은,도메인 객체가 데이터뿐아니라 비즈니스메소드를 가지고있으며,도메인 객체가 소유한 데이터는 도메인객체가 제공하는 메소드에 의해 은닉됨
		도메인객체는 각 비즈니스 개념과 메소드에 책임을 가지고,
		서비스는 비즈니스 유스케이스를 구현하기위해 서비스의 메소드를 도메인객체에 일부분 위임해서 처리함
		즉 서비스에서 엔티티메소드를 콜해서 비즈니스를 처리함
		
		이러면 서비스의 책임이 도메인으로 적절히 분산되니까,서비스가 엄청커지지않고 서비스메서드는 단순해짐
		이건 객체지향설계의 객체모델임
		거대한 서비스대신 각자 적절한 책임을 가진 여러클래스로 구성되니,이해가 쉽고 관리,테스트가 쉬움
		
		도메인 주도설계에선,애그리거트 패턴이라는 패턴이 있음
		이건 점점 복잡해지는 객체모델링의 단점을 보완한 패턴임
		도메인모델링을 하다보면,객체간의 관계를 참조로 표현하게되는데,이러면 일대다관계의 객체를 쉽게사용할수있음
		그런데 업무가 복잡해지면 참조로 인한 다단계 계층구조가 생기고,점점 참조가 복잡해지고 무거워짐
		
		또한,이런 복잡한 도메인모델은 모델 내부의 경계가 불명확함
		만약 다측에 있는 클래스갯수를 일측에서 집계해야할때,다측에 클래스가 추가되면 일측에서는 집계한값을 수정해야함
		그런데 만약 수정을하지 않으면 비즈니스 일관성이 깨지게됨
		이런 문제들이 복잡해지고 꼬일수 있어서 이걸 개선하는패턴이,
		최상위에 존재하는 엔티티를 중심으로 개념집합을 분리한 애그리거트패턴
		
		애그리거트는 1개이상의 엔티티과 값객체로 구성되는데,
		규칙은
			애그리거트 루트만 참조가능
			애그리거트내 상세클래스를 바로참조하지않고,루트를 통해 참조해야함,수정할떄도 마찬가지
			애그리거트간 참조는 객체를 직접 참조하지않고,기본키를 사용
			기본키를 사용하면 느슨하게 연관되고,수정이 필요하지않은 애그리거트를 함께 수정하는걸 막을수있음
			하나의 트랜잭션으로 하나의 애그리거트만 생성 및 수정함
	
	
	3.외부영역
		외부영역은,내부영역의 서비스 인터페이스를 사용하는 인바운드어댑터와,내부영역에서 선언한 아웃바운드 인터페이스를 구현하는 다양한 어댑터로 구성됨
		어댑터는 플러그인처럼 언제든지 교체되거나 확장될수있어야함
		내부영역이 먼저 정의된후에 외부영역의 세부사항은 늦게정의되어도 상관없도록 해야함
		
		api퍼블리싱 어댑터는,restapi를 발행하는 인바운드어댑터임
		내부의 서비스인터페이스를 호출해서,restapi로 제공함
		명시적인 rest리소스명칭을 정의하고,각 rest메서드가 의도에 맞게 서비스인터페이스를 호출함
		엔티티를 직접 제공하지않고,api에 필요에맞는 dao를 생성해서 엔티티를 변환 및 매핑해서 전달하는게 좋음
	
		api 프락시 어댑터는,다른서비스의 api를 호출하는 아웃바운드 어댑터임
		내부영역에 정의된 프락시 인터페이스를 구현하고,restapi등으로 던지면됨
		
		저장소 처리 어댑터를 구현할땐,데이터 처리 메커니즘을 선택해야함
		sql과 or매핑이 있는데,내부영역과는 상관없이 둘다 사용할수있음
		근데 보통 트랜잭션스크립트를 사용하면 sql,
		도메인모델을 사용하면 or매핑을 사용함
		sql매핑을 하면,sql질의를 수동으로 작성해야해서 세밀한 sql제어가 필요할경우 유용함
		
		or매핑은,or매퍼가 런타임시 저장소에 따라 자동으로 질의문을 생성
		그래서 sql작성을 할필요가 없고,설정에 따라 쉽게 저장소를 변경할수있음
		
		도메인 이벤트 발행 어댑터는,그 이벤트 발행하는 어댑터임
		이벤트를 발행하고 브로커에 올려서 컨슈머에 전달함
		애그리거트 패턴을 적용하면,도메인이벤트는 애그리거트에서 발생한 이벤트가 됨
		실제로 도메인이벤트가 생성되는건 내부영역이고,도메인 이벤트 발행 어댑터는 이걸 아웃바운드로 특정 메시지큐나 스트림저장소에 발행하는역할만 함
		
		도메인 이벤트 핸들러는,이벤트를 수신하는 인바운드어댑터임
		얘는 외부에서 발행된 도메인 이벤트를 구독해서,내부로 전달하는일을 수행함
		이벤트 상태에 따라 적절한 서비스인터페이스를 호출해서 내부에 이벤트를 전달함
		
4.ms와 애자일	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	