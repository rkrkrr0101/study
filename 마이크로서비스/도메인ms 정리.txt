1.서론
	스킵
2.msa의 이해
	기본적으로 msa는 탄력성과 유연성을 가져야하고,그러기위한 방법으로 메시지기반을 채택함
	msa에선 각 요소들은(코드언어,오케스트레이션,컨테이너화,프로비저닝 등) 여러개중에 하나를 택하는 블럭식으로 구성할수있음
	
	msa의 구성요소로는,인프라,플랫폼,앱이 있고,
	인프라는 컨테이너나 vm선택과 aws같은 클라우드선택이 있고
	플랫폼에선 젠킨스같은 파이프라인선택,메시지버스,로깅과 모니터링,구성관리,git등이 있고
	앱에선 채널(모바일,웹등 선택),프론트엔드,백엔드(마이크로서비스 내부아키텍쳐들),db가 있음
	
	ci/cd는 기본적인 템플릿은 가져가되,각 마이크로서비스는 각각 파이프라인을 가져야하고,자기의 필요에맞게 테스트등을 변경할수있음
	
	기본적으로 ms들은,나눠졌을때 서로간의 로드밸런싱이 필요한데,이건 k8s의 서비스가 해결하고,
	ip뒤에 /a /b같이 나눠지는거 처리는 인그레스가,
	외부설정주입은 컨피그맵이 해결함(내부에 설정두면 다른노드에 파드뿌렸을때 동작안할수있으니)
	
	그리고 서비스 파드가 뻗으면,대체하는 다른 파드나 컨테이너로 트래픽을 옮기는건,서킷브레이커패턴이라고 하고 k8s기본기능
	로깅과 모니터링은 프로메테우스같은거로 메트릭수집해서 그라파나같은거로 모니터링
	
	앱에선,기본적으로는 모노리스프론트엔드에 백엔드ms를 붙일수있는데,이러면 또 둘간에 결합이 단단해지니까 프론트엔드도 ms로 만들어서,
	백엔드와 프론트엔드를 합쳐서 하나의 ms로 구성하고,그걸 블록으로 생각하고 폼에 추가하는식으로 구성하는게 좋음
	즉 백엔드와 프론트엔드끼리는 어쩔수없이 결합이 단단해지니까,그렇게 묶은걸 하나로보고 한팀에서 처리하는거
	
	이떄 통신방식으로는,단일진입점을 사용한 동기통신과,이벤트브로커를 사용한 비동기통신(그거맞음 이벤트기반ms)이 있음
	
	동기통신은 웹이든 앱이든 둘다 단일진입점에 있는 api게이트웨이를 타고,걔가 인그레스처럼 명령을 전달해주는(restapi로)거임
	이때 만약 서비스끼리 통신이 필요하면,다시 api게이트웨이로 서비스에서 요청을 보내면 게이트웨이가 전달을 해줌
	즉 오케스트레이션과 비슷함
	이때 만약 답이 오지않고 계속 시간끌리면(해당서비스에 문제가생겨서),문제가 없던 서비스까지 문제가 생기는,연쇄장애가 발생할수있음
	즉 통신하는 두 서비스간엔 의존도가 높다는거라서 ms에선 별로 추천되지못함
	
	그래서 나온게 이벤트기반ms(비동기통신)임
	얘는 그냥 프로듀서가 이벤트스트림에 데이터를 생산하고,컨슈머가 거기를 계속 감시하면서(브로커가 감시하다 뜨면 알려주지만 이론적으론)이벤트를 기다리는거임
	여기는 브로커가 할일이 많으니까,브로커에 부하가 생길수있는데,그러면 브로커를 확장해주면됨
	이벤트기반ms는 서로 통신하는 서비스들이 물리적으로 같은데있을필요도없고,동일한시간대에 있을필요도없음(어짜피 펜팔비스무리한거니까)
	
	
	그리고 ms는 각각 서비스마다 저장소를 가짐
	만약 통합저장소를 사용하게되면,저장소를 기반으로 서로간에 관계성이 생겨서,문제가 생기거나 새기능을 추가할떄 유지보수가 매우어려워짐
	그래서 각 ms는 각각 저장소를 가지고,그 저장소를 외부에 노출하지 않고,공개할일이 있으면 자신이 생성한 api를 통해서만 노출이 가능하게 만들어야함
	이러면 저장소도 서비스의 특성에맞춰서 알아서만들수있고,데이터스키마변경에 따른 파급효과가 줄어서 변경이 쉽고  서비스가 독립적이 됨
	
	물론 문제점으론,각 데이터끼리 정합성과 일관성이 안맞을수있어짐
	그래서 트랜잭션처리등이 필요함
	이거도 일반적인 트랜잭션으론 처리하기가 힘들어서(연관된 모든 서비스의 저장소에 동시에 트랜잭션을 걸어야하니),
	방금 처리한 이벤트의 보상트랜잭션코드를 정의해두고,문제가 생기면 그걸 호출해서 처리함
	물론 일반트랜잭션처럼 완전한처리는 안되지만,그정도의 정합성은 보통 필요없는경우가 많아서 이정도로도 충분함
	여기에서 코레오그래피와 오케스트레이션이 있는데,둘다햇으니까 넘어가자
	이거의 장점은(코레오그래피),기본적으로 동작한곳까지만 트랜잭션이 발동하니까,아직 도착하지 않은곳에선 부하가 안걸린다는것
	
	그리고 가용성을 높이가져가기위해 할수있는 패턴들이 있는데,대표적으로는 읽기와 쓰기를 분리하는(데이터저장소를 2개사용하는),cqrs라는 방법이 있음
	보통은 읽기가 부하가 많이걸리고,쓰기가 덜걸리니까, 쓰기를 좀 작게만들고 읽기를 크게만든다음,쓸때 쓰고나서 적당한시간동안 모으던가해서 한번에던져서
	조회모델의 성능을 보장하는 방식임
	이러면 쓰기모델에서는 부하가 거의없어지고,읽기모델도 부하가 줄어듬(트랜잭션이 덜걸리니까)
	물론 짧은시간동안(쓰기모델에서 읽기모델 가는동안)은 일관성이 깨질수가 있는데,이게 그렇게 중요하지않을떄만 사용가능함
	그래서 이벤트브로커를 사용함,어짜피 일정시간이 지나면 결과적으론 정합성이 맞아지니까
	
	그리고 cqrs를 사용하면,여러 서비스에서 리턴을 받아야하는 게이팅패턴도 쉽게 처리가 가능해짐
	순서에 상관없이 다쌓이면 리턴하면되니까(상위api를 만들수도있지만,그러면 아래에 하나라도바뀌면 다수정해야하니까 결합도가 높음)
	
	그리고 아예 객체의 상태를 저장하지않고,로그만 저장해서 상태를 추론하는 이벤트소싱도 가능함
	이러면 이벤트브로커와 데이터저장소가 합쳐지고,다른과정이 없으니 쓰기가 빨라짐
	현재상태추론할떈 처음부터 모든데이터대로 행동하면되고,너무많으면 스냅샷따서 거기를 출발점으로잡으면됨
	그리고 업데이트와 삭제가 일어나지않으니,입력과 조회만 체크하면되니까 쓰기성능이 올라가고,로깅이 따로필요없음(다기록하고 안지우니까)
	트랜잭션도 그냥 예전으로 돌리면되고
	
	
3.ms 앱 아키텍쳐
1.관심사의 분리
	마이크로서비스는 기술경계가 아닌,비즈니스로직경계에 맞추어야함
	비즈니스로직은 기술보다 바뀌는 횟수가 적기때문에,그래야 변경횟수가 줄어듬
	
	그리고 db sql문을 기반으로 한 데이터베이스 중심 아키텍쳐의 문제점은,데이터베이스 성능저하로 데이터베이스가 병목점이 되었을때
	그걸 해결할수 있는 방법이 sql튜닝뿐임
	이패턴은 구현이 편하지만,점점커지면 복잡성이 엄청나게늘어남
	그리고 결합도도 높아서,db를 변경한다던가 하는건 엄청큰일임

2.헥사고날 아키텍쳐와 클린 아키텍쳐
	1.레이어드 아키텍쳐
		레이어드 아키텍쳐의 레이어는,논리적으로 프레젠테이션,비즈니스로직,데이터엑세스 3계의 층으로 나눠서 분류하는것
		대충 
			화면표현과 전환처리는 프레젠테이션,
			비즈니스개념,규칙,흐름제어는 비즈니스로직
			데이터처리는 데이터엑세스
		여기서 기본규칙은
			상위계층이 하위계층을 호출하는 단방향성(프레젠테이션이 데이터처리에 보낼수없음)
			상위계층은 바로밑계층만 활용함
			상위계층이 하위계층에 영향받으면안됨
			하위계층은 누가 불렀는지 알필요없음
			계층간의 호출은 인터페이스쓰는게좋음
		이 레이어드 아키텍쳐는,의존성 역전 원칙(의존성이 추상에 의존하고,구체적인거에 의존하면안됨(인터페이스쓰라는소리))는 만족하지만,
		개방폐쇄의 원칙(개체에 메소드를 추가할수는있지만 개체자체가 바뀌면안됨)에는 어긋남
		모든 계층이 자신이 제공하는 기능에 대한 인터페이스를 직접 정의하고 소유하고 있기 때문
		추상 인터페이스를 사용해서 인터페이스의 구현체를 달리하는방법으로 의존성을 줄이고,다형성을 유지할순 있지만 추상특성의 한계를 넘진못함
		
		앱에선 비즈니스 로직이 핵심영역이라서,다른 영역의 변경이나 확장에 영향을 받지않아야함
		그래서 의존관계의 역전이 필요함
		데이터엑세스계층에서 정의했던 인터페이스를,비즈니스 로직계층으로 옮기면 데이터액세스구현체는 그걸 바라볼수밖에 없음
		
		즉 비즈니스로직에서 자기가 필요한거 발주하고,다른 층에서 그거보고 구현하는거
		
	2.헥사고날 아키텍쳐
		저걸 적용해도 한계가 있는게,보통 요즘앱들은 프레젠테이션과 데이터액세스말고도 다양한 인터페이스들이 필요하기때문
		단방향 계층구조에선 이런걸 지원하기가 힘들어서 나온게 헥사고날임
		
		헥사고날은 포트 앤드 어댑터 아키텍쳐라고도 함
		내부 비즈니스 로직을 두고,거기서 인바운드 아웃바운드 포트들을 둬서 io를 처리하는것
		이러면 내부영역이 외부의 구체어댑터에 전혀 의존하지않음(어짜피 포트로 들어오는거만 받으니)
		
		포트는 인바운드포트와 아웃바운드포트로 구분되는데,
		인바운드는 내부영역의 사용을 위해 표출된 api이고,외부영역의 인바운드 어댑터가 호출함
		아웃바운드는 내부영역이 외부를 호출하는 방법을 정의함
		여기서 아웃바운드포트가 외부의 아웃바운드어댑터를 호출하는게 아니라,어댑터가 포트에 의존함(어댑터가 기다리다가 들어오면 던짐)
		
		인바운드어댑터엔 restapi,아웃바운드 어댑터엔 데이터액세스용 dao(room에서 그거인듯),이벤트메시지발행 클래스,외부서비스호출 프락시등이 있음
		
	3.클린 아키텍쳐
		클린 아키텍쳐는,헥사고날에서 선택할수 있는걸 가능한 오래 열어두는것,특히 중요하지 않은 세부사항같은걸 오래열어두는거임
		
		정중앙엔 엔티티가 있고,엔티티는 핵심 업무 규칙과 거기에 따른 데이터(핵심업무규칙의 데이터는 둘이 서로 결합되어있을테니)를 묶어서 객체로 만드는데
		이걸 엔티티객체라고 함
		
		그리고 엔티티를 감싸는 객체는 유스케이스임
		얘는 자동화된 시스템을 사용하는 처리절차를 기술함
		유스케이스는 앱에 특화된 업무규칙을 표현하고,엔티티 내부의 핵심업무규칙을 호출하고 시스템을 사용하는 흐름을 담음
		이때 엔티티같은 고수준에선 이쪽영역을 알면 안됨
		엔티티는 간단한 객체여야하고,프레임워크,데이터베이스같은 복잡한거에 의존하면 안되고,유스케이스를 통해 조작해야함
		즉 엔티티안에 유스케이스의 메소드를 호출하는 메소드가 있고,그걸 통해서만 접근할수있음
		
		그리고 유스케이스를 감싸는 나머지 모든게 세부사항임
		입출력,저장소,웹시스템,서버,프레임워크,통신프로토콜등
		세부사항과 유스케이스의 관계를 의존성역전해서(인터페이스를 유스케이스로 땡겨와서),플러그인처럼 처리해야함
		이렇게 결합을 명확히 분리하면,테스트가 편하고 개발독립성,배포독립성을 강화할수있음
		
	
3.ms 내부구조 정의
	1.클린ms
		헥사고날이나 클린아키텍쳐같은건,굳이 ms만을 위한 아키텍쳐는 아니고,모놀리스쪽에서도 잘 쓸수있음
		
		마이크로서비스는 각각 내부구조가 다양할수있음,입출력만 제대로해주면 팀에서 알아서 만들기때문
		즉 언어,db,아키텍쳐 전부 자기맘대로 할수있음 restapi만 사용하면
		
		그래서 간단한거의경우엔 헥사고날같은걸 쓸필요없지만,좀 커진다싶으면 헥사고날이나 클린아키텍쳐구조를 기반으로 정의하는게 좋음
		
		이때 원칙은
			지향하는 관심사에 따라 응집성을 높이고,관심사가 다른영역과는 의존도가 낮아야함
			업무규칙을 정의하는 비즈니스로직영역을 다른 기술기반영역으로부터 분리해야함
			세부기술중심,저수준의 외부영역과 핵심업무규칙이 정의된 고수준의 내부영역으로 구분
			고수준영역은 저수준에 의존하면안되고,저수준이 고수준에 의존해야함(내부 인터페이스)
			저수준영역은 언제든 교체확장 가능해야하고,이게 고수준에 영향을주면안됨
			인터페이스와 추상클래스를 지원하는언어는,저수준의 구체클래스가 고수준의 추상인터페이스에 의존하게하면 쉬움
			인터페이스는 고수준의 안정된 영역에 존재해야하고,저수준의 어댑터가 이를 구현함
		
		구현은 내부영역의 맨안에 도메인이 존재하고,도메인을 서비스가 감싸고있음
		
		도메인은 핵심비즈니스개념과 규칙,서비스는 도메인을 호출해서 업무를 처리하는 절차와 외부와의 연계를 위해 서비스인터페이스를 보유
		
		서비스 인터페이스는 외부에서 내부를 사용할수있게 api를 제공하고 서비스가 이를 구현함
		
		내부영역의 또 다른 인터페이스는 저장소처리를 위한 인터페이스임
		이건 비즈니스를 처리하는데 필요한 기본 저장소 처리사항을 추상화해 정의함
		그러면 외부영역의 저장소어댑터는,이 리포지터리 인터페이스를 각 저장소에 맞는 세부기술로 구현하게됨
		
		이거말고도 다양한 인아웃바운드 어댑터들이 존재하는데,모든 아웃바운드어댑터는 의존성역전되어야함
	
	2.내부영역
		내부영역구현에는 서비스인터페이스,서비스구현체,도메인,리포지터리 인터페이스,도메인 이벤트 인터페이스,api프락시 인터페이스등이 존재함
		서비스 인터페이스는 외부가 내부에대해 알기 어렵게 하고,추이종속성을 막을수있음
		리포지터리,도메인,api프락시인터페이스는 의존관계역전이 되어야함
		핵심인 서비스와 도메인은,클린아키텍쳐의 유스케이스와 엔티티와 역할이 같음
		이걸 구현할때 쓸수있는게 트랜잭션 스크립트패턴과 도메인 모델 패턴임
		
		트랜잭션 스크립트 패턴은,도메인객체가 메소드를 가지지않고,모든 행동책임을 서비스에 맞기고 엔티티는 값만 가지고있음
		이러면 서비스는 점점 커지고,도메인은 점점 정보묶음역할만 하게됨
		그리고 서비스는 유스케이스 처리의 단위고,대부분의 로직처리가 서비스에서 일어나니까 비슷한유스케이스의 경우 서비스에 중복되는코드가 계속 생겨나서
		유지보수가 어려워질수있음
		일단 처음에 짤땐 간단하니까,가벼운프로그램같은경우 쓸수있음
		
		
		도메인 모델 패턴은,도메인 객체가 데이터뿐아니라 비즈니스메소드를 가지고있으며,도메인 객체가 소유한 데이터는 도메인객체가 제공하는 메소드에 의해 은닉됨
		도메인객체는 각 비즈니스 개념과 메소드에 책임을 가지고,
		서비스는 비즈니스 유스케이스를 구현하기위해 서비스의 메소드를 도메인객체에 일부분 위임해서 처리함
		즉 서비스에서 엔티티메소드를 콜해서 비즈니스를 처리함
		
		이러면 서비스의 책임이 도메인으로 적절히 분산되니까,서비스가 엄청커지지않고 서비스메서드는 단순해짐
		이건 객체지향설계의 객체모델임
		거대한 서비스대신 각자 적절한 책임을 가진 여러클래스로 구성되니,이해가 쉽고 관리,테스트가 쉬움
		
		도메인 주도설계에선,애그리거트 패턴이라는 패턴이 있음
		이건 점점 복잡해지는 객체모델링의 단점을 보완한 패턴임
		도메인모델링을 하다보면,객체간의 관계를 참조로 표현하게되는데,이러면 일대다관계의 객체를 쉽게사용할수있음
		그런데 업무가 복잡해지면 참조로 인한 다단계 계층구조가 생기고,점점 참조가 복잡해지고 무거워짐
		
		또한,이런 복잡한 도메인모델은 모델 내부의 경계가 불명확함
		만약 다측에 있는 클래스갯수를 일측에서 집계해야할때,다측에 클래스가 추가되면 일측에서는 집계한값을 수정해야함
		그런데 만약 수정을하지 않으면 비즈니스 일관성이 깨지게됨
		이런 문제들이 복잡해지고 꼬일수 있어서 이걸 개선하는패턴이,
		최상위에 존재하는 엔티티를 중심으로 개념집합을 분리한 애그리거트패턴
		
		애그리거트는 1개이상의 엔티티과 값객체로 구성되는데,
		규칙은
			애그리거트 루트만 참조가능
			애그리거트내 상세클래스를 바로참조하지않고,루트를 통해 참조해야함,수정할떄도 마찬가지
			애그리거트간 참조는 객체를 직접 참조하지않고,기본키를 사용
			기본키를 사용하면 느슨하게 연관되고,수정이 필요하지않은 애그리거트를 함께 수정하는걸 막을수있음
			하나의 트랜잭션으로 하나의 애그리거트만 생성 및 수정함
	
	
	3.외부영역
		외부영역은,내부영역의 서비스 인터페이스를 사용하는 인바운드어댑터와,내부영역에서 선언한 아웃바운드 인터페이스를 구현하는 다양한 어댑터로 구성됨
		어댑터는 플러그인처럼 언제든지 교체되거나 확장될수있어야함
		내부영역이 먼저 정의된후에 외부영역의 세부사항은 늦게정의되어도 상관없도록 해야함
		
		api퍼블리싱 어댑터는,restapi를 발행하는 인바운드어댑터임
		내부의 서비스인터페이스를 호출해서,restapi로 제공함
		명시적인 rest리소스명칭을 정의하고,각 rest메서드가 의도에 맞게 서비스인터페이스를 호출함
		엔티티를 직접 제공하지않고,api에 필요에맞는 dao를 생성해서 엔티티를 변환 및 매핑해서 전달하는게 좋음
	
		api 프락시 어댑터는,다른서비스의 api를 호출하는 아웃바운드 어댑터임
		내부영역에 정의된 프락시 인터페이스를 구현하고,restapi등으로 던지면됨
		
		저장소 처리 어댑터를 구현할땐,데이터 처리 메커니즘을 선택해야함
		sql과 or매핑이 있는데,내부영역과는 상관없이 둘다 사용할수있음
		근데 보통 트랜잭션스크립트를 사용하면 sql,
		도메인모델을 사용하면 or매핑을 사용함
		sql매핑을 하면,sql질의를 수동으로 작성해야해서 세밀한 sql제어가 필요할경우 유용함
		
		or매핑은,or매퍼가 런타임시 저장소에 따라 자동으로 질의문을 생성
		그래서 sql작성을 할필요가 없고,설정에 따라 쉽게 저장소를 변경할수있음
		
		도메인 이벤트 발행 어댑터는,그 이벤트 발행하는 어댑터임
		이벤트를 발행하고 브로커에 올려서 컨슈머에 전달함
		애그리거트 패턴을 적용하면,도메인이벤트는 애그리거트에서 발생한 이벤트가 됨
		실제로 도메인이벤트가 생성되는건 내부영역이고,도메인 이벤트 발행 어댑터는 이걸 아웃바운드로 특정 메시지큐나 스트림저장소에 발행하는역할만 함
		
		도메인 이벤트 핸들러는,이벤트를 수신하는 인바운드어댑터임
		얘는 외부에서 발행된 도메인 이벤트를 구독해서,내부로 전달하는일을 수행함
		이벤트 상태에 따라 적절한 서비스인터페이스를 호출해서 내부에 이벤트를 전달함
		
4.ms와 애자일	
	애자일에서도 당연히 설계및 산출물들을 작성하면서 진행해야하지만,너무 빡빡하게 완벽하게 할필요는없고,
	얼개만 잡아가면서 빨리 진행하는게 더 효율이 높다는 방식임
	즉 우선순위잡아서 최우선꺼부터 만들어서 뼈대만 세워두고,그걸 테스트하면서 살을 붙여나가는 방식
	기본적으로 2~3주정도 잡고 이걸 n회 반복하며(이거도 미리정해둬야함) 완성시킴
	
1.도메인주도 설계와 마이크로서비스
	도메인주도설계(DDD)는 마이크로서비스의 설계와 개발을 위한 중심가이드임
	DDD에는 전략적설계와 전술적설계라는 설계영역이 있음
	
	전략적설계는 도메인전문가 및 기술팀이 모여 도메인지식을 공유 및 이해하고,
	이를기준으로 개념과 경계를 식별해 바운드 컨텍스트를 정의하고,
	경계의 관계를 컨텍스트맵으로 정의하는 활동임(거시적인관점에서 설계)
	
	전술적 설계는 식별된 컨텐스트내의 도메인개념인 도메인모델을 구성하는 모델링구성요소를 설명함(세부적관점에서 설계)
	
2.기민한 설계/개발 프로세스	
	애자일에서의 개발 프로세스는
		제품백로그
		스프린트계획수립
		스프린트백로그
		스프린트,스크럼미팅  (n회반복)
		완료
	순임
	
	스크럼의 기본생명주기는 스프린트를 활용함
	스프린트는 스크럼의 점진,반복적인 생명주기로써,보통 1~4주동안 실행됨
	백로그라는 일감목록을 기반으로,각 스프린트마다 일감이 배분되어 진행되며,매 스프린트마다 실제로 동작하는 소프트웨어를 시연하고 피드백을 얻음
	
	스크럼의 주요 개념및 공정으로는
		스크럼팀은 스프린트가 진행되는팀,스크럼팀은 필요한 모든 직군이 한명이상모여서 구성되고,그안에서 완결적이어야함
		
		스크럼미팅은 스크럼팀이 매일아침 진행사항을 공유하는 간단한회의
		
		스프린트 계획 수립은,시스템의 모든 요구사항은 제품백로그에 담기는데,그걸보고 일정에 맞게 스프린트를 몇번 반복할지 결정하고,
		횟수를 보고 각 스프린트에 얼마나 구현할지 제품백로그를 스프린트백로그에 분할함,여기서 팀의 생산성이 결정됨
		그리고 이때 우선순위대로 나눠서,어짜피 기간은 정해져있으니까 우선순위가 낮은건 그렇게 쳐내지게됨
		
		시연은 스프린트가 끝나고 돌려보면서 피드백받는거
		회고는 좋았던거와 안좋았던거 피드백하면서 개선점찾아서 다음스프린트에 적용하는거
		
	구현스프린트를 본격적으로 진행하기위해선,준비하고 계획하는 활동이 필요한데
	이게 아키텍쳐 정의와 마이크로서비스 도출임
		아키텍쳐 정의는,ms 외부/내부아키텍쳐를 정의하는 공정임
		기술 세부사항은 늦게 결정할수있어야하니까,세부사항말고 비즈니스적으로만 표현하고,그걸 구현할때 무슨언어를쓸지같은건 나중에 결정해도됨
		그러나 이런 유연성을 유지하면서,최소한의 개발 및 테스트환경을 먼저 준비하는건 효과적임,그래야 실제 돌아가는앱을 시연할수있음
		이떄 도커,쿠버네티스등 ms개발환경을 미리 결정해두면,개발환경구축이 빨라져서좋음
		
		마이크로서비스도출은 본격적으로 개발로 들어가기전에,개발할 전체 마이크로서비스를 파악하는작업
		모든 마이크로서비스를 하나의스크럼팀이 개발할순없으니,전략적설계로 마이크로서비스를 도출하고,그것간의 매핑관계를 정의하고
		개발우선순위에 근거해 스크럼팀들에게 배분해서 스프린트를 진행함
		ms도출의 최종결과물은 컨텍스트맵임
		
		
	스프린트 내의 공정은,스크림팀 멤버인 백엔드,프런트엔드 개발자의 역할대로 공정이 나뉨
	두 영역의 접목은 api설계를 통해 진행되고,나머지활동은 각자 내부적으로 진행됨
	
	백엔드설계의 시작은 api설계임,api설계는 각 백엔드와 프런트엔드에 제공할 서비스명세임
	초기에 api설계를 해서 프런트엔드영역과 협의및 조정을 해야 프런트엔드도 진행을 할수있음
	다음진행은 ms내부구조에 따라 도메인모델과 데이터모델을 설계하는것
	
	도메인 모델을 작성하는활동은 도메인모델링이라고 하는데,그냥 간단히 도메인모델을 화이트보드같은데 그리고 바로 소스를 짜는거임
	그러다가 필요한거생기면 덧붙이고
	
	프런트엔드 영역의 설계는,ui레이아웃을 정의하고 백엔드의 api를 호출해서,api가 보내준 데이터를 기반으로 ui에 어떻게 표현할것인가를 정의함
	사용자가 접근하는채널(모바일웹,데스크탑,앱)에 따라 레이아웃정의가 다양할수있고,프런트아키텍쳐에 따라 설계수준및 방식이 모두 다를수있음
	여기서 할건
		ui흐름정의:비즈니스흐름에 따른 ui흐름을 정의함
		ui레이아웃정의:사용자인터페이스를 정의함,디자인을 고려하지않고 사용자경험을 고려해서 설계함
		ui이벤트 및 액션 정의:ui레이아웃의 구성요소인 컨트롤을 클릭하거나 터치했을때 발생하는 이벤트 및 액션을 정의함,여기서 백엔드api와의 연계를 정의함
		ui개발:레이아웃및 이벤트의 의도에 맞춰 프런트엔드 앱을 개발함,프런트아키텍쳐에서 정의한 ui프레임워크나 도구를 사용함
		
	
	기민한 개발을 위해선,백엔드와 프런트엔드의 개발이 진행되면서 지속적으로 빌드되고 자동으로 배포되어야함(ci/cd)
	스크럼팀의 구성원은 언제라도 현재 진행된만큼의 실제 돌아가는 소프트웨어를 확인할수있어야함
	그래서 데브옵스 인프라가 이걸 지원하고,백엔드및 프론트엔드는 매일 통합빌드하고 배포되는환경에 익숙해져야함
	즉 빌드가 안되거나 배포가 안되는상황을 방치하면안됨
	이때 cicd파이프라인이 구성된상태에서 개발자가 해야할일은
		소스코드 리포지터리 구성:git같은거로 레포를 만들어야함
		통합빌드잡 구성:레포에 있는 소스를 통합해서 바이너리를 만드는활동을 자동화함,젠킨스를 사용할수있음
		컨테이너 생성파일 작성:dockerfile을 작성해서,컨테이너이미지를 생성할수있음
		배포스크립트 작성:자동으로 배포하는 스크립트를 작성,배포타깃에 맞춰 스크립트를 작성하면됨,젠킨스쓸거면 거기에 배포도할수있음
	
	
	
	
	
	
5.ms설계	
	ms를 포함한 소프트웨어 설계에서 중요한건,응집성높게,의존도낮게 임
	
1.ms도출방법
	마이크로서비스가 비즈니스변화속도를 지원하면서 독립적으로 변경,배포되려면 각 ms가 다른서비스에 의존하지않게 도출되어야함
	그래서 시스템의 어떤 비즈니스기능들을 묶어서 독립적인 ms로 도출할것인가 결정하는게 중요
	
	가장 쉬운방법은 경험적원칙을 적용하는것
	비즈니스능력에 따라 서비스로 식별할수있고,또 비즈니스 능력은 비즈니스 가치를 생산하기위해 하는일이라고 정의하고 곧 조직이 하는일이라고 말함
	즉 각 도메인에는 비즈니스가 규정하는 일의 방식,조직,부서체계가 이미 정의되어있고,이런 부서는 이미 업무에서의 응집성을 가지고있고 타부서의존도가 낮으니,
	이거대로 자른다는게 업무기능분해임
	즉 주문-주문관리-주문처리,주문이력
	이렇게 분해하는것
	단 이건 전체적인 비즈니스를 이해할떈 유용하지만,서비스간의 관계나 서비스의 구체기능과 연관된 독립적데이터를 식별하기엔 미흡해서 이를 보완해야함
	
	업무기능분해의 서비스도출한계를 보완하기위해,ddd의 전략적 설계를 적용할수있음
	ms는 각 저장소를 독립적으로 보유하고,각 데이터는 다른서비스에서 직접 참조할수 없는 특성이 있음
	그래서 서비스를 독립적으로 수정,배포할수 있는것
	
	그래서 ms를 도출할때 서비스가 소유권을 가진 데이터를 독립적으로 식별하는게 중요함,즉 서비스가 보유한 기능에 의해서만 접근가능한 데이터를 파악해야함
	여기서 기능분해방식은,소유데이터식별에 적합하지않고,기능과 데이터가 분리되고 하나의 통합데이터가 여러 기능에서 사용되도록 모델링되는 방식이라서
	비즈니스기능과 기능에영향을 받는 데이터가 분리되는 경향이 있음
	
	그렇지만 ddd는 데이터를 기능과 분리해서 식별하지않고,문제영역인 하위도메인마다 별도의 도메인모델로 정의하고,
	도메인모델은 각 업무에 특화된 유비쿼터스 언어로 정의되고,그업무에 특화된 개념으로 구성됨
	그래서 ddd로 도메인모델을 만들고,컨텍스트를 중심으로 ms를 도출하는것
	
2.ddd에서의 설계
	ddd의 전략적 설계에서는 응집성있는 컨텍스트를 구분하고,이를 바운디드컨텍스트라고 하는데,이 단위가 ms를 식별하는 훌륭한 단위임
	또 전략적 설계를 통해 식별된 ms 내부구조를 정의하고,상세히 설계하기위해 ddd의 객체 설계 기법인 전술적설계를 사용할수있음
	
	ddd에선 하나의 큰 도메인을 전략적으로 중요한것들을 찾아 중요도에 따라 도메인을 나누고,각 도메인을 각각 하나씩 해결하는 방법을 기본으로 삼음
	이렇게하면,즉 도메인을 논리적으로 구분되는 개념으로 나누면 문제가 되는영역을 쉽게 이해할수있음,
	즉 많은 개념들이 하나로 엮인 복잡한 도메인을 논리적으로 구분되는 여러 하위영역으로 분리해야한다는 뜻으로,이게 서브도메인임
	
	서브도메인은 중요도에따라 핵심서브도메인,지원서브도메인,일반서브도메인 3개로 나눠짐
	
	핵심서브도메인은 다른 경쟁자와 차별화를 만들 비즈니스영역이라,높은우선순위를 가지고 가장 큰 투자가 필요한곳
	지원서브도메인은 비즈니스에 필수적이지만,차별화를 만들필요는 없는곳,즉 핵심서브도메인다음으로 중요
	일반서브도메인은 비즈니스에 필수는 아니지만,비즈니스 전체에는 필요한것으로,기존제품을 구매해서 대체가능한곳(클라우드같은거)
	
	전략설설계는 ms를 도출하는방법이자,비즈니스상 전략적으로 중요한것을 찾아 중요도에 따라 일을 나누기위해 사용할수 있음
	이때 중요한개념 2개가 있는데
		도메인의 주요개념을 정의하고 도메인간 경계를 식별하는 바운디드컨텍스트
		도메인의 모든 구성원이 공통으로 사용하는 유비쿼터스 언어
	임
	
	유비쿼터스 언어는,특정 도메인에서의 의도를 명확히 반영하고,도메인의 핵심 개념을 잘 전달할수있는 언어임
	이걸 사용해서 이해관계자 모두가 공통의 언어를 사욯하면,용어에 따른 오해를 없앨수 있게 됨
	유비쿼터스 언어는 특정 도메인의 업무개념을 표현하는 언어로,도메인이 바뀌면 같은단어라도 뜻이 달라짐
	즉,단어의 뜻이 바뀌는 지점을 바운디드 컨텍스트라고 부름(도메인간의 경계)
	
	그리고 도메인 모델은 도메인과 관련된 업무를 수행하는 모든 구성원이 업무를 이해하는 기본 모형이 됨
	같은 컨텍스트를 다루는 이해관계자들은 도메인 모델에 정의된 언어로 업무협의를 진행하고 개념을 발전시켜나감
	또 이 모델의 언어를 그대로 사용해 설계산출물을 표현하고,소스코드에도 사용함
	
	이러면 새 팀원이 와도 소스코드에 존재하는 도메인모델을 이해하고 이 모델로 도메인전문가와 무리없이 소통할수있으면,
	도메인과 서비스에 대한 같은비전을 공유할수있고,서비스는 지속적으로 민첩하게 개발,유지될수있음
	
	바운디드 컨텍스트를 식별할때, 각 컨텍스트는 내부적으로는 응집성이 높고,다른컨텍스트와는 의존관계가 낮아야함
	그렇다고 컨텍스트끼리 아예 관계가 없을순 없고,하나의 비즈니스수행을위해 여러 컨텍스트가 연계해야하는 경우가 발생함
	이런관계를 컨텍스트매핑이라고 하고,컨텍스트사이에 선을그려서 표시함
	이때 컨텍스트간의 매핑관계를 표시한걸 컨텍스트맵이라고함
	
	이 매핑관계에는
		공유커널:같은 모델을 공유하는관계,두팀에서 작은 같은모델을 공유함,보통 공통라이브러리등이 해당되는데,이 공통라이브러리가 수정되면
		연관된 모든 컨텍스트에 영향을 미치므로,공유모델을 관리하는건 한팀이 맡아야하고,가급적 추천하지않음
		
		소비자와 공급자:프로듀서와 컨슈머관계로,프로듀서가 공급하면 소비자가 사용함,반대는 지원하지않으니 상류의 변화가 있으면 하류가 직격타맞기때문에,
		공급자쪽에서 소비자가 원하는 기능을 제공해야함
		
		준수자:프로듀서컨슈머와 비슷하지만,이건 프로듀서가 하라는대로만 하는 컨슈머임,프로듀서에 영향을 끼치지못함
		
		충돌방지계층(ACL):컨슈머가 프로듀서의 영향을 받을때,컨슈머의 고유모델을 지키기위해 번역계층을 만들어서(어댑터임)그걸 거쳐서 받아오는거
		이건 ms아키텍쳐와 레거시시스템을 통합할때 주로 사용됨
		레거시에서 restapi를 사용하지못할때,그걸 번역해서 레거시에 맞게 넣어주는식
		이걸 사용하면 레거시가 클라우드 환경에 이전될떄도,이미 만들어둔 프로듀서를 건드릴필요없이 acl만 제거하고 서로 직접연동하게 주소만바꾸면됨
		
		공개호스트서비스(OHS):바운디드컨텍스트에 대한 접근을 제공하는 프로토콜이나 인터페이스임,
		이프로토콜은 하류의 컨텍스트가 상위컨텍스트에서 제공하는 기능을 쉽게 사용하게 공개되어있음
		보통 다른 콘텍스트에서 사용할수있게 공개된 api가 여기해당됨
		
		발행된언어(PL):이건 하류가 상류의 기능을 이해하기위해 api를 설명해둔거임,보통 xml이나 json으로 만들고,ohs랑 짝으로 나옴
	
	이런 컨텍스트들과 서로간의 관계를 묶어서 컨텍스트맵을 만들수있음
	이렇게 큰틀로 컨텍스트맵을 만들고,그때부터 세부적으로 뭐쓸건지정하고 구현하면됨
	
	
	
3.이벤트 스토밍을 통한 ms도출
	이건 그 예전에 본 벽에다 포스트잇붙여서 하던 그거임
	사람들 다모여서 각 엔티티와 액션같은 종류마다 다른색의 포스트잇을 붙이는식
	
	먼저 도메인이벤트를 찾기위해,시간의 흐름에 따라 시스템의 동작을 의미하는 도메인이벤트를 도출함
	이때 데이터의 흐름이 아닌,비즈니스흐름에서 발생한 이벤트에 초점을 두어야함
	이걸 왼쪽부터 오른쪽으로 시간순으로 노란색을 대충 붙이고(동시에발생하면 밑에붙여서붙임),종류가 아예다르면 다른줄로 붙임
	
	여기에 외부시스템이나 레거시시스템같은 외부연동이 필요하면 그 이벤트 위에 핑크색을 붙이고 화살표를 그림
	
	그리고 도메인이벤트를 찾았으면 이 이벤트를 동작하게 하는 커멘드를 찾아서 파란색으로 붙임,이벤트 왼쪽에 붙이면됨
	회원가입됨 이벤트면 회원가입 커맨드 이런식
	하나의 커멘드로 여러다른이벤트가 발생할수있음에 유의해야함
	
	그리고 모르겠는거나 결정못하는거 생기면 보라색으로 붙이고 나중에 해결함
	
	커맨드까지 찾았으면 커맨드를 실행하는 액터를 도출하는데,
	이건 사용자,조직,역할자같은 특정 비즈니스를 실제로 수행하는 판매자,구매자,상품관리자,배송관리자 같은 명확한 역할자를 도출해내야함
	이걸하면서 커맨드와 도메인이벤트를 찾았으면 다시 붙이면됨
	액터는 작은 노란색포스트잇으로 커맨드의 왼쪽아래에 붙이면됨
	그리고 액터를 도출하면서 액터가 한 일을 문장으로 만들어(판매자가 상품을 등록하면 상품등록됨이라는 이벤트가 발생해서 시스템이 동작)
	말이 되는지 확인,아니면 커맨드와 도메인이벤트를 변경하거나 새로 도출함
	
	여기까지 끝났으면 전체그림은 다 그렸고,설계를 해야함
	
	이제 애그리거트를 정의해야하는데,에그리거트는 커맨드와 도메인이벤트가 영향을 주는 데이터요소로,도메인의 실체개념을 표현하는 객체인 엔티티가 됨
	애그리거트는 노란색포스트잇으로 커맨드와 도메인이벤트 사이의 상단에 붙여서붙임
	애그리거트도 구체적표현으로 도출하는게 좋은데,애그리거트를 구체적으로 식별할수록 컨텍스트의 경계를 식별하는데 유용하기때문
	
	여기서 같은 애그리거트(회원,상품등)을 가진애들끼리 묶어서 바운디드 컨텍스트로 만들고 그걸 구분해서 경계를 그림
	각 컨텍스트엔 이름을 붙이는데,애그리거트의 이름으로 정의하면됨,만약 여러개일경우 전체를 아우르는 대표이름으로 정하면됨
	
	만약 애그리거트들이 흩어져있으면,많이있는데로 다 옮기면됨(모듈화)
	
	여기까지 했으면 외부시스템과 컨텍스트간의 관계를 그릴수있어짐
	이제 할일은 정책(콜)도출임
	정책은 
		도메인이벤트 할때는 항상 커맨드 한다
	이런식으로 특정 이벤트에 붙이고(프로듀서쪽에) 컨슈머쪽으로 화살표를 연결하면됨(연결되는커맨드에)
	
	이렇게되면 컨텍스트맵이 완성됐으니,저걸 보기편하게 컴퓨터로 정리해서 만들면됨
	이때 호출할때 호출방식,즉 동기냐 비동기냐를 고려해야함
	항상 일관된 데이터가 필요하면 동기,결과적 일관성만 있어도되면 비동기로 처리하면됨
	즉 일관데이터필요한거아니면 다 비동기처리하면됨,동기처리하면 의존도가 올라가기때문
	
	동기처리면 실선,비동기면 점선으로 그리면됨
	이렇게 생성된 바운디드컨텍스트는 ms후보가 되고,다음조건을 만족시키면 ms로 정의하면됨
		비즈니스프로세스를 수행하기위한 하나의 맥락단위로 구분될수있는가
		마이크로서비스별로 분리된 데이터를 정의할수있는가
		하나의 팀이 독립적으로 운영가능한단위인가
		독립적배포가 가능한단위인가
		변경시 영향을 받는 ms가 존재하는가
		도입을 통한 기대효과가 충분한가
	이걸 모두 만족하면 ms로 식별하고,아니라면 분리하거나 통합해서 ms로 만들면됨
	
	이벤트 스토밍 결과는 상세설계의 출발점이 됨
	서비스별로 커맨드,도메인이벤트,애그리거트,서비스연계및정책,핫스팟(리스크),api,데이터,등으로 정리할수있고,이건 프론트엔드,백엔드 모델링에 활용됨
	
	
5.ms상세설계
	ms도출이 끝났으면 스프린트가 시작됨
	ms는 프론트엔드,백엔드로 나눠져서 개발됨
	그래서 크게 프런트엔드 서비스 설계와 개발,백엔드 서비스설계와 개발로 구분되어 스프린트내에 개발되고,ci/cd로 통합되고 배포됨
	1.프론트엔드 설계
		프론트엔드의 설계에는
			프론트아키텍쳐정의:요건에 맞는 아키텍쳐를 사용해야함,요즘은 보통 리액트,뷰를 많이씀
			표준레이아웃 정의:목적과 기능을 고려해서 화면의 표준레이아웃을 정의해야함 (입출력폼,표준버튼등)
			ui레이아웃 설계:표준유형을 기반으로 개별 ui레이아웃정의,각 기능을 만족할 ui를 정의하는과정으로,
			화면에 입출력될 속성정보를 식별하고,기능수행버튼을 정의
			ui디자인및 레이아웃 반영:표준유형환경에 맞는 ui디자인을 정의함,웹디자이너가 할일이고,프런트엔드엔지니어와 협의해야함
			이벤트 설계:화면의 이벤트 변화에 따라 백엔드 api호출방식을 정의
	2.백엔드설계
		백엔드 모델링은,헥사고날을 적용해서 외부와 내부로 구분해서 진행함
		스토밍결과를 반영해서,내부를 헥사고날구조로 정의하고 매핑할수있고 이를기반으로 발전시키면됨
		즉,커맨드는 인바운드어댑터인 restapi가 되고,애그리거트는 헥사고날의 내부영역의 도메인모델이 되고,
		도메인이벤트는 외부영역의 아웃바운드메시지어댑터의 처리대상이 되고,외부시스템은 아웃바운드어댑터가 호출할 외부시스템으로 매핑됨
		
		이렇게 백엔드모델링의 출발점을 잡고나선,구현을 위해 좀더 구체적설계가 필요함
		외부영역설계는 프론트엔드와 연계되는 api설계로,내부영역은 비즈니스로직을 구현하는 도메인모델링,데이터모델링으로 구체화해서 진행
		
		ms팀은 서비스가 제공하는 기능에 대한 프론트엔드,백엔드 구현을 모두 책임지며,프론트,백 둘다 하나의팀에서 긴밀하게 협업해야함
		이걸위해 프런트와 백엔드간의 계약이 필요한데,이게 api설계임
		api는 백엔드에 존재하지만 프론트의 요구사항을 충족하도록 정의해야함
		
		api는  헥사고날의 외부영역으로,인바운드어탭터로 어떤 호출방식도 허용되지만,요즘은 보통 restapi를 사용함
		restapi는 자원,행위,표현으로 구성됨
		행위에서
			get은 가져오기(조회)
			post는 인서트
			put은 업데이트
			delete는 삭제
		여기서 get http://abc.com/users/ 하면 user 전체를 가져오라는거
		get http://abc.com/users/01 하면 users의 01id를 가져오라는거
		post할땐
			post http://abc.com/users/{"users":{"name:"qwer""}}
		이런식으로 json포멧으로 던져줘야함
		put도 똑같이 json던져줘야하고,delete는 get처럼 지정만하면됨
		
		보통 get,post를 주로쓰고,put,delete는 잘 안쓰긴하는데 쓰는게낫대
		get,post만 쓰는건 1단계고,2단계가 전부 다 쓰고,api기본사용방법대로 사용하는거
		
		그리고 이렇게 api를 설계했으면,설계산출물을 만들어서 공개해야함
		이때
			서비스명,api명,리소스(url)
			요청매개변수,요청샘플
			응답매개변수,응답샘플
		은 무조건있어야함
		이때도 그냥 엑셀식으로 정리하는게 편함,책참조
	
	
	
6.도메인 모델링
	ms내부구조는 폴리글랏하게(다형성) 접근할수있음
	여기서,폴리글랏은 언어나 db의 선택뿐아니라,도메인모델로 할건지 트랜잭션스크립트로 할건지도 선택할수있다는것
	보통 좀 크다싶으면 도메인모델이 낫고,작고 추가할거없으면 트랜잭션스크립트도 괜찮음
	단 좀 큰데 스크립트로 하면,서비스가 엄청나게 커지는 문제가있음
	
	1.ddd의 전술적 설계
		기존 객체모델링 방식은 자유도가 높아서,문제영역을 파고들수록 여러층의 복잡한 계층구조를 만들가능성이 높음
		그래서 이를 정리하기위해 객체들의 역할에 따른 유형을 정의하고,이거에따라 모델링하면 편해지는데,이걸 ddd의 전술적설계에서 제공함
		
		엔티티는 다른 엔티티와 구별할수있는 식별자를 가진,도메인의 실체 개념을 표현하는 객체임
		식별자는 고유하지만,속성과 상태는 계속변할수있음
		고유식별자와 변화가능성이 엔티티와 값객체를 구분하는 차이임
		즉,프라이머리키가 있는 로우한줄에,다른줄은 계속 수정될수있어야함(마크에서 엔티티랑 똑같이생각하면됨)
		
		값 객체는,각 속성이 개별적으로 변화하지않는 개념적완전성(택배수취자의 이름,주소,우편번호를 묶어서 한 값 객체로 치는거처럼)을 모델링함
		이 값객체는 엔티티에 속하고,거기서 서로 관련있는거끼리 묶어서 배열로 엔티티가 받아봄(어짜피 저거3개는 묶어서 받아야하니까)
		즉,하나하나 독립적으로 수정되지않고,변경점이있으면 전체객체가 삭제되고 새로 생성됨
		
		표준타입은 대상의 타입을 나타내는 서술적객체임,그냥 0,1,2를 silver,gold,vip 이런식으로 한눈에 알아보기쉽게 구분하기위해 사용함
		즉 실골빕등을 코드가 아닌 유비쿼터스 언어로 표현하는것,어짜피 내부적구현으로는 똑같으니까(const로 받으면 똑같으니)
		
		애그리거트는 엔티티와 값객체를 모델링했을때,이 연관된 엔티티와 값객체의 집합이 애그리거트임
		보통 애그리거트는 1~2개의 엔티티,값객체,표준타입등으로 구성되는데,이들간에는 의존관계가 있고,정합성을 맞춰야함
		그래서 이 애그리거트가 트랜잭션의 기본단위가 됨
		
		애그리거트 내에 있는 엔티티중 가장 상위의 엔티티를 애그리거트 루트로 정하고,이걸통해서만 애그리거트 내의 엔티티나 값객체를 변경할수있음
		
		보통 하나의 컨텍스트내에 여러 애그리거트가 존재할수있는데,이경우 다른애그리거트를 참조해야할때,직접참조하지않고 루트의 식별자를 통해 참조해야함
		만약 직접참조하면 의존관계가 복잡해지고 트랜잭션처리도 머리아파짐
		
		또한 보통 컨텍스트를 ms로 식별하게되는데,애그리거트또한 별도의 ms후보가 될수있음
		그런데 같은 컨텍스트내에 여러애그리거트가 존재할때,다른애그리거트클래스를 직접참조하면 별도의 ms로 분리가 힘드니,루트의 식별자로 참조하는게좋음
		
		그리고 각 애그리거트는 트랜잭션을 사용하지만,
		다른애그리거트끼리 일관성이 필요할땐 도메인이벤트와 똑같이 결과적일관성으로 다른애그리거트를 갱신해서 일관성을 유지
		
		도메인서비스는,도메인의 로직처리가 엔티티나 값객체에 속하지않을때,단독객체를 만들어서 처리하게되는데 이걸 도메인서비스라고 함
		얘는 상태를 관리하지않고,행위만 존재함,즉 로직을 처리할때 엔티티나 값객체와 함께 특정작업을 처리하고 엔티티나 값객체에 결과값을 전달함
		
		도메인이벤트는 서비스간 정합성을 일치시키기위해 단위애그리거트의 주요값을 담아 전달하게 모델링되어야함(구매완료이벤트는 주문번호,주문상품목록,금액,주소)
		이건 주문처리트랜잭션과 묶어서 실행되어야함,실패시 돌려야하니까,
		이떄 이벤트는 메시지메커니즘으로 다른서비스에 전달하고,이걸로 배송서비스에서 배송처리를 수행할수있음
	
	
	
6.사례연구-ms도출과 아키텍쳐구성	
	ms를 도출하고 아키텍쳐를 구성할때 순서는
		요구사항정의
		이벤트스토밍을 통한 ms도출
		외부아키텍쳐정의
		내부아키텍쳐정의
		jhipster을 사용한 아키텍쳐 구성
	순서대로 진행하면됨
	
1.요구사항정의
	만들고자하는 시스템 전체의 기능요건을 받음
2.스토밍을 통한 ms도출
	요구사항을 기반으로 워크샵을 통해 비즈니스흐름을 파악하고,컨텍스트식별을 통해 ms후보를 찾아내고 서비스간의 관계를 정의해야함
	
	요구사항을 분야별로 나누고(사용자관리,대출,배송,이메일등)
		왼쪽에서 오른쪽으로 업무처리흐름별로 도메인이벤트를 붙이고
		이벤트대응커맨드를 이벤트오른쪽에 붙임
		액터를 통해 이벤트와 커맨드를 검증하고,커맨드왼쪽아래에 붙임
		이벤트와 연관된 외부인터페이스 식별(이메일같은)
		이벤트와 커맨드에 영향을받는 데이터요소인 애그리거트를 찾음
		마지막으로 이벤트발생시 타영역의 커맨드를 트리거하는 정책을 도출
		
	이벤트 스토밍이 끝났으면,그걸보고 경계를 그려 컨텍스트를 구분해야함
	여기서 대충은 같은액터끼리 묶으면 일단 되고(애그리거트),그다음에 너무작고,옆에 연관관계가 있는게있으면 거기로 붙여서 크기를 맞춰나가는식으로 컨텍스트를 짬
	이때 빈번하게 사용되면 분리하는식으로 구분할수도있음
	
	그리고 컨텍스트끼리 이벤트가 있으면(정책)선으로 긋고 화살표그림
	
	그리고 조회와 생성,변경이 빈도수의 차이가 많으면,조회를 분리한뒤에 cqrs(이벤트브로커방식)으로 해도됨
	
	컨텍스트를 다그렸으면,구체적인 상황을 생략하고 컨텍스트끼리의 관계도를 그린 컨텍스트다이어그램을 작성하면됨
	컨텍스트와 컨텍스트간의 동기/비동기호출 방식만 표현
	여기서 식별된 컨텍스트가 ms의 후보가 됨,후보인 이유는 배포,운영효율성등으로 여기서 분할되거나 병합될수있기때문
	
	그리고 스토밍결과를 헥사고날로 표현하면됨
		커맨드는 외부영역의 인바운드어댑터-api후보
		이벤트는 외부영역의 아웃바운드어댑터로 전송되는 메시지이벤트 후보
		애그리거트는 내부영역의 도메인모델후보
		인터페이스는 외부영역의 아웃바운드로 연결될 대외인터페이스 후보
		정책은 내부영역의 로직구현규칙과,그외로 외부영역의 아웃바운드어댑터로 연결될 서비스방향결정에 도움을 줌
	
	
3.외부 아키텍쳐 정의
	식별한 ms중심으로 외부 아키텍쳐를 정의하고,각 ms에 쓰일 기술들을 정해야함(서로 통신해야할경우 통신방식(비동기면 카프카같은)도 정해야하고)
4.내부아키텍쳐 정의
	단순한 업무에선 sql도 sql매퍼쓰고,로직도 트랜잭션스크립트사용하면되고,
	주요업무에선 도메인모델과 or매퍼를 사용하는게 좋음
	
	ms내부 패키지 구조는,내부영역패키지와 외부영역패키지를 분리하고
	도메인모델의 패키지 구조 및 패키지,클래스명명규칙,역할,작성기준은
	내부영역
		domain/클래스/도메인모델:비즈니스개념및로직표현,애그리거트,엔티티,값,표준타입패턴으로 구현/애그리거트단위
		service(인터페이스)/서비스인터페이스:서비스파사드역할/애그리거트당 1개
		service(클래스)/서비스구현체:업무처리흐름구현/서비스인터페이스당 1개
		레포지터리(인터페이스)/리포지터리:저장소처리/엔티티당1개
		
	외부영역
		web.rest/클래스/rest컨트롤러:restapi발행,인바운드요청처리
		adaptor/클래스/클라이언트/rest클라이언트:동기아웃바운드처리,다른서비스를 동기호출/호출할 타서비스당1개
		adaptor/클래스/컨슈머/컨슈머어댑터:비동기메시지 인바운드수신처리
		adaptor/인터페이스/프로듀서/비동기메시지인터페이스:비동기 아웃바운드 메시지 전송정의하는 인터페이스/호출타서비스당 1개
		adaptor/클래스/프로듀서/비동기메시지구현체:비동기 아웃바운드메시지 구현/프로듀서인터페이스에 의존
		dto/클래스/데이터전송객체:동기호출시 데이터전송객체로 사용/api에 의존
	
	트랜잭션스크립트의 패키지구조같은건 책보자,도메인모델과 비슷한데 내부영역이 좀다름
	
	
	
5.jhipster를 활용한 아키텍쳐구성	
	제이힙스터는 ms를 빠르게 적용,개발,배포할수있게 도와주는 플랫폼임
	프론트엔드에선 앵귤러,리액트,뷰를 지원하고
	백엔드에선 스프링부트,노드js,닷넷등을 지원하고
	배포영역에선 도커/쿠버네티스 for aws,azure등을 지원함
	
	얘는 광범위한 테스트를 커버할수있는 강력한 서버스택을 가지고있고,
	웹팩,메이븐,그래들을 이용해서 앱을 빌드할수있고
	클라우드에 빠르게 배포할수있는 iac가 있음
	
	얘는 설치가쉽고,디렉토리를 생성하고 옵션을 선택하면 바로 실행가능한 웹앱을 만들어주고,그과정에서 모놀리스,ms등을 선택할수있고,
	도커,카프카등을 환경을 구축하고 라이브러리를 자동으로 설치해줌
	또 기본인증처리및 restapi를 이용한통신을 지원함
	
	jhipster를 설치할땐 자바11,nodejs,jhipster를 설치하면됨
	
	제이힙스터를 이용하면 쉽게 내외부및 개발환경을 구축할수있음
	제이힙스터가 만들어주는 레지스트리는,유레카와 스프링클라우드컨피그를 사용해서 레지스트리 및 컨피그서비스를 제공함
	게이트웨이는 줄 기반이고,프런트엔드서비스도 통합해서 제공함
	따라서 게이트웨이를 만들어주는거만으로도 사용자관리 및 로그인은 사용할수있음
	개발순서는
		게이트웨이생성
		레지스트리생성
		ms생성
		ms에 엔티티생성
		엔티티를 게이트웨이가 인식할수있게 게이트웨이에 등록
		
	게이트웨이 생성은
		게이트웨이폴더를 생성
		폴더를 프로젝트로 설정
		옵션선택(여기서 앱타입과 이름과 포트등을 설정해야함,책보자)
	이러면 레지스트리와 게이트웨이가 생성됨
	그리고 도커컴포즈나 쿠버네티스로 실행시키면(기본적으로 컨테이너로 제공됨) 출력을 받아볼수있음(로컬호스트:지정포트)
	
	ms생성도 똑같이
		폴더생성
		프로젝트설정
		옵션선택
	하면됨
	
	그리고 백엔드를 생성했으면,각 서비스 내부에서 기능을 제공할 객체모델을 만들어야함,
	즉 서비스마다 내부아키텍쳐구조를 정의하고,이에맞게 비즈니스를 표현할 도메인모델과 restapi로 서비스를 제공하기위한 객체를 생성해야함
	제이힙스터를 사용하면,엔티티만 정의하면 나머지를 자동으로 만들고,프론트엔드서비스까지 자동으로 연결해줌
	
	엔티티생성은 웹에서 하거나,cmd에서 할수있음
	cmd에서하려면 
		그 디렉터리에 들어가서(cd)
		jhipster entity book //이렇게 엔티티 생성명령날리고
		시키는대로 필드추가하면됨(속성이름,타입등)
		
	그리고 생성한 엔티티를 게이트웨이에 등록하면됨
		cd gateway
		jhipster entity 엔티티명
	그리고 재실행해서 테스트해보면됨
	
	일단 이렇게하면 자동으로 만들어는 주는데,자기가 설계한 구조에따라 적당히 리팩토링(그냥 폴더위치바꾸는정도)해서 쓰는게 나중에보기편함
	이떄 내외부영역을 따로두는게 좋음
	
	그리고 외부영역은 타서비스에 영향을 받을수있는 형태여도되지만,내부는 로직을 명확히 다룰수있는 고운입자의 모델을 사용하는게 좋음
	
	
	
	
7.사례연구-백엔드 ms 구현
1.도서대출 ms 개발
	1.구현기능소개
		일단 기능별로 나눠서 구현기능을 적어두고
	2.내부 아키텍쳐 결정
		내부아키텍쳐는 서비스마다 폴리글랏하니까 각 서비스별로 다르게 아키텍쳐를 결정해야함
		보통 큰거는 도메인모델+or매퍼(db)를 쓰고,비동기통신엔 카프카를 쓰는듯(동기는 페인)
		or매퍼는 그 코틀린 room처럼 sql을 함수처럼쓰고 dto(데이터오브젝트)를 쓰는방식
	3.api설계
		api는 api명,리소스url,메서드(get,post같은),요청매개변수,예시,응답결과,응답예시를 나열하면됨
	4.도메인모델링
		여기선 스토밍으로 식별한 애그리거트들이 구체적으로 모델링됨
		이때 데이터모델링처럼 비즈니스를 테이블화하고 정규화하는게 아님
		도메인모델링은 누구라도 이해하기쉽게 객체 모델을 만드는것
		
		이 객체는 각 엔티티를 소유하고있음
		
		즉,도메인모델은 비즈니스개념을 표현하고,이 개념은 객체로 표현되고,애그리거트,엔티티,값객체,표준타입등이 적용됨
		
	5.유스케이스 흐름
		이런 모델링을 했으면,시퀸스다이어그램같은거로 이벤트순서를 그려보면좋음
	
	6.내부영역-도메인모델개발
		일단 도메인모델내에서 수행할수있는 로직은 도메인객체가 갖게,즉 도메인객체에 적절한 책임을 부여해야함
		room에서 dto생성한거처럼 생성하고
		메소드를 넣어서 그 아이디(프라이머리키)에 대한 커맨드를 만들고(도서대출이면 대출생성,반납,연체메서드)
		하위엔티티를 만들어야함(대출아이템,반납아이템등)
	7.내부-서비스개발
		내부로직의 책임은 도메인객체에 있으니,서비스구현체에선 핵심로직외에 비즈니스흐름을 처리함
		즉 도메인모델의 책임범위에서 벗어나,모델에서 직접할수없는 저장소처리,다른서비스와 연계처리등을 구현체에서 구현함
		
		도메인주도 설계는 서비스를 도메인서비스와 앱서비스로 구분하는데,도메인서비스는 엔티티객체나 값객체에서 수행하기 부자연스러운걸 처리함
		주로 여러 도메인모델에 걸친 규칙이나 개념등을 처리함
		앱서비스는 업무처리흐름을 의미하는 유스케이스 흐름임,보통 서비스라고하면 이걸말함
		
		서비스에서 인터페이스와 메서드를 만들어두고,도메인에서 확인하고 던져주면됨
		이때 실제로직은 도메인에 있고,여기서 함수불러쓰는거처럼 쓰면되는거
		이때 비동기처리가 필요하면,아웃바운드 어댑터를 호출해서(이때 직접호출이 아닌 인터페이스클래스에 의존)해야함
	8.내부-리포지터리 개발
		여기서 dao를 넣어서,이걸 함수처럼 불러다쓰는식으로 사용하면됨,즉 sql하나를 메서드로 바꿔서 콜해서 사용함
		이렇게하면 특정기술이 개입되지않고,함수명만 보고 사용할수있어서 이해가쉬움
	9.외부-rest컨트롤러 개발
		대충 내부는 저렇게 개발하고,이렇게 개발된 내부를 외부로 공개해야하는데,이떄 rest컨트롤러가 필요함
		rest컨트롤러는 구현된 서비스의 restapi를 발행함
		얘는 프런트엔드에 제공할 api를 내부영역의 도메인기능을 활용해 적절히 제공해야함
		
		rest컨트롤러는 그 api에 맞는 적절한 리소스명과 표준메서드(get,post,delete등)를 사용해서 선언하고 제공해야함
		이때 방식은,
			post로 매개변수를 받고
			동기호출해서 매개변수가 적절한지확인하고
			액션을 수행하고
			변경된 객체를 dto로 변환해 http로 반환
	10.외부-아웃바운드어댑터 개발(동기호출)
		동기호출할때 페인을 사용하면 쉽게할수있음
		일단 application.yml을 수정하고 페인클라이언트를 작성하면됨
		그리고 통신용 dto를 양쪽에 만들고,그걸 던져가면서 통신하면됨
	11.외부-아웃바운드어댑터 개발(비동기호출 EDA)
		이건 그 카프카써서 브로커에 프로듀서가 던지면,그걸 구독한애들이 알아서 그거보고 액션하는 그 이벤트기반 그거맞음
		이때 큐로 카프카쓰면됨
		서비스의 하위패키지로 adaptor패키지를 생성하고,그안에 인터페이스와 구현체를 두고 거기서 던지면됨
		컨슈머쪽에선 계속대기하고있다가 맞는거 들어오면 반응해서,들어온데이터를 변환해서 내부로 던짐
	
	12.내부-도메인모델개발(다른모델들)
		이런식으로 다른모델도 개발하면됨
	
	
2.사용자 ms 개발
	1.기능소개
		제이힙스터를 사용해서 게이트웨이를 생성하면,자동으로 게이트웨이 ms내에 사용자기능을 구현함
		즉 회원가입,로그인,회원관리등을 기본적으로 보유하고,스프링시큐리티를 활용한 보안,권한관리도 제공하고 이메일인증도 제공함
	2.api설계
		여기도 똑같이 api를 설계하고 그걸호출하는식으로 커맨드전달이 이루어짐
	3.도메인모델링
		여기서 도메인모델은,사용자클래스와 권한클래스로 나눠짐
		사용자클래스는 애그리거트 루트이자 엔티티이고,권한클래스는 그냥엔티티임
		사용자와 권한은 다대다관계를 맺음
	4.유스케이스흐름
		특정 커맨드에 따른 행동을 그려보고,동기 비동기를 정함
	5.내부-도메인모델 개발
		엔티티를 만들고,권한은 다대다니까 객체를 매핑하는식으로 매핑함
	6.내부-서비스개발
		권한관리는 사용자정보수정(엔티티의 권한객체 수정)으로 이루어짐
		즉 여기서 엔티티를 불러와서 거기값을 바꾸고 다시 리턴하는식으로 만들면됨
	7.외부-레포지터리개발
		제이힙스터를 사용하면 레포지터리를 만들어주는데,그거그대로쓰면됨
		대부분 사용자관리에 관련된(로그인,이메일,리셋키등) 메서드들이 들어있음
	8.외부-rest컨트롤러개발
		사용자ms에서 사용자관리에 관련된 컨트롤러는 개인정보관리 컨트롤러와 관리자용 회원정보관리 컨트롤러 두개임
		개인정보관리는 회원가입,정보수정,사용자 본인의 비밀번호찾기등을 받고,
		회원정보관리는 관리자에 의한 사용자생성,정보수정,사용자삭제등을 처리함
		관리자툴은 요청을 보낸사람의 권한을 확인하고,권한이 admin일때만 요청을 허용해야함
	9.외부-아웃바운드 어댑터
		아웃바운드어댑터는 아이디정보를 받아서 이벤트를 생성하고,카프카를 통해 보내는식으로 비동기를 처리하면됨
	
3.사용자ms-포인트관리기능
	보통 적립같은경우엔 비동기로 처리하고,결제같은경우 ok,ng를 받아야하니까 동기로 처리해야함
	이거의 책임은 포인트관리ms에서 가지고있음(정확히는 호출은 대상ms,내부동작은 여기)
	결제같은경우 동기호출을 해야,결과에따라 다른로직을 실행시킬수있음
	
	
	
8.cqrs를 활용한 백엔드 ms개발	
	읽기전용 ms와 같이 즉시 일관성이 필요없는경우엔,cqrs같은 이벤트기반 아키텍쳐를 유용하게쓸수있음
1.도서ms개발
	여기도 똑같이 기능소개,아키텍쳐결정,api설계 등등등으로 쭉나감
	필요한거만 보자
	
	도메인에서,도서의 isbn같은 값은,그자체로 의미가 있기때문에,유효성검사로직이 필요함
	
	내부영역의 서비스는 애그리거트 루트단위로 생성함
	여기서 서비스는 일련번호로 도서를 조회해서 book을 반환하거나,재고도서이벤트를 이벤트브로커에 던지거나 같은걸 하면됨
	그리고 재고도서등록시 입고도서삭제같은 두 독립된 애그리거트 사이의 로직을 처리할떈,도메인서비스를 만들어서 처리하면됨(서비스같은데서 처리)
	
	이벤트기반도 똑같은데 그냥 카프카로 던지고,그거 구독해서 받고한다는거말곤 차이가없음
	
	
2.카탈로그 ms
	그냥똑같은데스킵하자

9.사례연구-시연
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	