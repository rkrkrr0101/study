1.서론
	스킵
2.msa의 이해
	기본적으로 msa는 탄력성과 유연성을 가져야하고,그러기위한 방법으로 메시지기반을 채택함
	msa에선 각 요소들은(코드언어,오케스트레이션,컨테이너화,프로비저닝 등) 여러개중에 하나를 택하는 블럭식으로 구성할수있음
	
	msa의 구성요소로는,인프라,플랫폼,앱이 있고,
	인프라는 컨테이너나 vm선택과 aws같은 클라우드선택이 있고
	플랫폼에선 젠킨스같은 파이프라인선택,메시지버스,로깅과 모니터링,구성관리,git등이 있고
	앱에선 채널(모바일,웹등 선택),프론트엔드,백엔드(마이크로서비스 내부아키텍쳐들),db가 있음
	
	ci/cd는 기본적인 템플릿은 가져가되,각 마이크로서비스는 각각 파이프라인을 가져야하고,자기의 필요에맞게 테스트등을 변경할수있음
	
	기본적으로 ms들은,나눠졌을때 서로간의 로드밸런싱이 필요한데,이건 k8s의 서비스가 해결하고,
	ip뒤에 /a /b같이 나눠지는거 처리는 인그레스가,
	외부설정주입은 컨피그맵이 해결함(내부에 설정두면 다른노드에 파드뿌렸을때 동작안할수있으니)
	
	그리고 서비스 파드가 뻗으면,대체하는 다른 파드나 컨테이너로 트래픽을 옮기는건,서킷브레이커패턴이라고 하고 k8s기본기능
	로깅과 모니터링은 프로메테우스같은거로 메트릭수집해서 그라파나같은거로 모니터링
	
	앱에선,기본적으로는 모노리스프론트엔드에 백엔드ms를 붙일수있는데,이러면 또 둘간에 결합이 단단해지니까 프론트엔드도 ms로 만들어서,
	백엔드와 프론트엔드를 합쳐서 하나의 ms로 구성하고,그걸 블록으로 생각하고 폼에 추가하는식으로 구성하는게 좋음
	즉 백엔드와 프론트엔드끼리는 어쩔수없이 결합이 단단해지니까,그렇게 묶은걸 하나로보고 한팀에서 처리하는거
	
	이떄 통신방식으로는,단일진입점을 사용한 동기통신과,이벤트브로커를 사용한 비동기통신(그거맞음 이벤트기반ms)이 있음
	
	동기통신은 웹이든 앱이든 둘다 단일진입점에 있는 api게이트웨이를 타고,걔가 인그레스처럼 명령을 전달해주는(restapi로)거임
	이때 만약 서비스끼리 통신이 필요하면,다시 api게이트웨이로 서비스에서 요청을 보내면 게이트웨이가 전달을 해줌
	즉 오케스트레이션과 비슷함
	이때 만약 답이 오지않고 계속 시간끌리면(해당서비스에 문제가생겨서),문제가 없던 서비스까지 문제가 생기는,연쇄장애가 발생할수있음
	즉 통신하는 두 서비스간엔 의존도가 높다는거라서 ms에선 별로 추천되지못함
	
	그래서 나온게 이벤트기반ms(비동기통신)임
	얘는 그냥 프로듀서가 이벤트스트림에 데이터를 생산하고,컨슈머가 거기를 계속 감시하면서(브로커가 감시하다 뜨면 알려주지만 이론적으론)이벤트를 기다리는거임
	여기는 브로커가 할일이 많으니까,브로커에 부하가 생길수있는데,그러면 브로커를 확장해주면됨
	이벤트기반ms는 서로 통신하는 서비스들이 물리적으로 같은데있을필요도없고,동일한시간대에 있을필요도없음(어짜피 펜팔비스무리한거니까)
	
	
	그리고 ms는 각각 서비스마다 저장소를 가짐
	만약 통합저장소를 사용하게되면,저장소를 기반으로 서로간에 관계성이 생겨서,문제가 생기거나 새기능을 추가할떄 유지보수가 매우어려워짐
	그래서 각 ms는 각각 저장소를 가지고,그 저장소를 외부에 노출하지 않고,공개할일이 있으면 자신이 생성한 api를 통해서만 노출이 가능하게 만들어야함
	이러면 저장소도 서비스의 특성에맞춰서 알아서만들수있고,데이터스키마변경에 따른 파급효과가 줄어서 변경이 쉽고  서비스가 독립적이 됨
	
	물론 문제점으론,각 데이터끼리 정합성과 일관성이 안맞을수있어짐
	그래서 트랜잭션처리등이 필요함
	이거도 일반적인 트랜잭션으론 처리하기가 힘들어서(연관된 모든 서비스의 저장소에 동시에 트랜잭션을 걸어야하니),
	방금 처리한 이벤트의 보상트랜잭션코드를 정의해두고,문제가 생기면 그걸 호출해서 처리함
	물론 일반트랜잭션처럼 완전한처리는 안되지만,그정도의 정합성은 보통 필요없는경우가 많아서 이정도로도 충분함
	여기에서 코레오그래피와 오케스트레이션이 있는데,둘다햇으니까 넘어가자
	이거의 장점은(코레오그래피),기본적으로 동작한곳까지만 트랜잭션이 발동하니까,아직 도착하지 않은곳에선 부하가 안걸린다는것
	
	그리고 가용성을 높이가져가기위해 할수있는 패턴들이 있는데,대표적으로는 읽기와 쓰기를 분리하는(데이터저장소를 2개사용하는),cqrs라는 방법이 있음
	보통은 읽기가 부하가 많이걸리고,쓰기가 덜걸리니까, 쓰기를 좀 작게만들고 읽기를 크게만든다음,쓸때 쓰고나서 적당한시간동안 모으던가해서 한번에던져서
	조회모델의 성능을 보장하는 방식임
	이러면 쓰기모델에서는 부하가 거의없어지고,읽기모델도 부하가 줄어듬(트랜잭션이 덜걸리니까)
	물론 짧은시간동안(쓰기모델에서 읽기모델 가는동안)은 일관성이 깨질수가 있는데,이게 그렇게 중요하지않을떄만 사용가능함
	그래서 이벤트브로커를 사용함,어짜피 일정시간이 지나면 결과적으론 정합성이 맞아지니까
	
	그리고 cqrs를 사용하면,여러 서비스에서 리턴을 받아야하는 게이팅패턴도 쉽게 처리가 가능해짐
	순서에 상관없이 다쌓이면 리턴하면되니까(상위api를 만들수도있지만,그러면 아래에 하나라도바뀌면 다수정해야하니까 결합도가 높음)
	
	그리고 아예 객체의 상태를 저장하지않고,로그만 저장해서 상태를 추론하는 이벤트소싱도 가능함
	이러면 이벤트브로커와 데이터저장소가 합쳐지고,다른과정이 없으니 쓰기가 빨라짐
	현재상태추론할떈 처음부터 모든데이터대로 행동하면되고,너무많으면 스냅샷따서 거기를 출발점으로잡으면됨
	그리고 업데이트와 삭제가 일어나지않으니,입력과 조회만 체크하면되니까 쓰기성능이 올라가고,로깅이 따로필요없음(다기록하고 안지우니까)
	트랜잭션도 그냥 예전으로 돌리면되고
	
	
3.ms 앱 아키텍쳐
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	