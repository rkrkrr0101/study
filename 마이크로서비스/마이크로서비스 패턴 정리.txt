-1.모놀리지옥에서 벗어나라
1.모놀리의 장점과 단점
	모놀리의 장점은,작은크기일땐
		개발이 간단함
		앱변경이 쉬움
		테스트가 쉬움
		배포가 쉬움
		확장이 쉬움
	이라는 장점이 있지만,커졌을때 문제가 됨
	커졌을때의 단점으로는
		전부 이해할수가 없을정도로 커짐
		한군데 건드렸을때의 사이드이펙트 상상이 안감
		ide실행시간이 너무길어짐
		테스트가 오래걸리고 신뢰성이 부족해짐(유닛테스트 안되는부분때문에 수동테스트해야하는영역이 많아짐)
		커밋부터 배포까지 너무오래걸림 (ci/cd파이프라인이 불가능함)
		확장이 어려움(각 모듈마다 필요한 리소스요건이 달라서 확장이 어려워짐)
		기술스택 변경이 어려움
		
2.마이크로서비스
	마이크로서비스아키텍쳐는,모놀리의 확장방식(파드복제해서 확장,데이터분할해서 확장)에 추가로 앱을 나누는 차원이 추가되는거임
	기본적인 모놀리식 확장방식을 사용하면,앱능력과 가용성은 확장되지만,앱의 복잡도증가는 해결되지않음
	그래서 기능분해가 필요해지는것
	이때 분해된 기능은,미니 앱이라고 보면 됨,서비스에 따라 복제확장등도 똑같이 가능함
	즉,msa는 고수준에서 바라보면,하나의 앱을 여러 서비스로 분해하는 스타일임
	여기서 중요한건 크기가 아니라,각 서비스가 응집된 책임을 가지고 있다는것
	
	마이크로서비스는 서비스를 모듈성의 단위로,그 선을 다른서비스가 들어오지 못하고,api를 통해서만 통신함
	그래서 독립성을 유지하기가 편하고,독립적으로 배포/확장할수있음
	
	그리고 각 서비스들은 각자 자신의 db테이블을 가지고있음,그래서 외부와 협의하지않고 자신의 스키마를 바꿀수있고,
	다른 서비스가 락을걸어서 나를 블로킹하는일이 없음
	만약 여러서비스가 한 db를 봐야한다면,그 db의 입출력을 담당하는 서비스를 만들고,api로 통신하면됨
	
	기본적으로 퍼사드패턴으로 api게이트웨이를 만들고,걔가 각 서비스의 api로 통신하는식으로 구성되게됨
	그리고 서비스에서 외부어댑터가 필요하면,자기껀 자기가 알아서 만들고,외부에 알리지만 않고 리턴값만 주면됨
	
3.마이크로서비스의 장단점
	마이크로서비스의 장점은
		크고 복잡한 앱을 지속적으로 전달/배포할수있음
		서비스규모가 작아 관리가 쉬움 
		서비스를 독립적으로 배포/확장할수있음
		팀들이 자율적으로 움직일수있음
		결함격리가 잘됨(한곳에서 메모리누수가 나도,그 서비스만 죽고끝남)
		새로운기술실험과 도입이 쉬움(서비스별로 따로니까,모든스택을 한번에바꿀필요가없음)
	
	마이크로서비스는 모놀리에 비해,유닛테스트등 자동화테스트가 쉽고(크기가 작아서),사이드이펙트가 적어서 버그도 적음
	그리고 배포도 독립적으로 할수있어서,개발자가 자신이 담당한 서비스변경분을 배포할때 다른개발자와 협의할필요가 없음
	작은팀이 여럿 결합된 식으로,가장 효율적인 크기로 기술조직을 굴릴수있음,즉 팀별로 서비스를 담당해서,외부영향을 안줄수있음
	
	즉 이래서 ci/cd가 가능해짐
	
	단점은
		딱맞는 서비스찾기가 어려움
		분산시스템을 공부해야함
		여러 서비스에 걸친 기능을 배포할땐 잘 조정해야함
		msa도입시점 결정이 어려움
	
	
4.마이크로서비스 패턴언어
	ms패턴언어는,전체 앱을 마이크로서비스로 구성할때 유용한 패턴의 모음집임
	패턴언어는 구조와 장단점을 기술하기때문에,무엇보다 지금 msa를 사용하는게 옳은일인지 결정할때 요긴함
	
	이 패턴들의 분류로는
		앱을 여러서비스로 분해하는 패턴
		통신패턴
		트랜잭션관리를 위한 데이터 일관성 패턴(사가)
		데이터쿼리패턴
		서비스배포패턴
		관측패턴
		서비스테스트자동화패턴
		횡단관심사처리패턴(공통관심사처리패턴)
		보안패턴
	
5.마이크로서비스 프로세스와 조직
		마이크로서비스는 8~12명정도에 애자일방식으로 스크럼같은걸 도입해서 하는게 좋음
	
	
	
	
	
	
-2.분해전략	
1.마이크로서비스 아키텍쳐란
	마이크로서비스의 핵심사상은 기능분해임
	하나의 큰 앱보단,작은 여러 서비스로 구성하는게 낫다는것
	
	소프트웨어 아키텍쳐는 4+1뷰모델로 볼수있음
		논리뷰:개발자가 작성한 소프트웨어 엘리먼트,클래스와 클래스의 상속같은것
		구현뷰:빌드의 결과물,모듈과 컴포넌트로 구성됨
		프로세스뷰:런타임 컴포넌트
		배포뷰:프로세스가 머신에 매핑되는 방법,이 뷰의 엘리먼트는 머신 및 프로세스고,머신간의 관계가 네트워킹임
			프로세스와 머신 사이의 관계도 이 뷰에서 기술됨
		시나리오:+1로,뷰를 구성시키는 시나리오임,각 시나리오는 특정뷰 내에서 얼마나 다양한 아키텍쳐요소가 협동해서 요청을 처리하는지를 기술함
	
	앱의 요건은,기능요건과 품질요건으로 나눠짐
	기능요건은 유스케이스같이 어떤 기능을 가지고있다는것,기능요건은 아키텍쳐와는 무관함
	품질요건은 확장성,신뢰성,관리성,테스트성,배포성처럼 아키텍쳐와 밀접한 품질의 요건임
	
	마이크로서비스는 육각형 아키텍쳐라고 볼수있음
	얘는 논리뷰를 비즈니스 로직 중심으로 구성하는데,앱에 표현계층대신 비즈니스로직을 호출해서 외부에서 들어온 요청을 처리하는 인바운드어댑터들과,
	비즈니스 로직에 의해 호출되고 외부 앱을 호출하는 아웃바운드 어댑터들을 둠
	비즈니스로직이 어댑터에 전혀 의존하지않는다는게 가장 큰 장점임,오히려 어댑터가 비즈니스로직에 의존함
	
	비즈니스로직엔 하나이상의 포트가 있음
	포트는 비즈니스로직이 외부세계와 상호작용하는 방법이 정의된 작업임
	기본적으로 인터페이스라고 생각하면됨
	포트는 인바운드 아웃바운드 두가지종류가 있고,
	인바운드포트는 비즈니스 로직이 표출된 api고,외부앱은 이 api를 통해 로직을 호출함
	아웃바운드포트는 비즈니스 로직이 외부시스템을 호출하는 방법에 관한것
	
	즉 중심엔 비즈니스로직이 있고,로직의 출입구로 포트들이 있으며,이 포트들에 어댑터들이 의존해서 외부와 출입을 함(의존성역전)
	
	기본적으로 인바운드 어댑터는 restapi,메시지브로커같은걸로 구현하고
	아웃바운드 어댑터는 dao,프록시같은걸로 구현함	
	아웃바운드 어댑터는 이벤트를 발행하기도 함
	
	이 육각형구조의 가장 큰 장점은,로직에 있던 표현/데이터접근로직이 어댑터와 분리되어서,비즈니스로직이 표현/데이터 접근로직 어디에도 의존하지않는다는것
	
	이렇게 분리를 하면,비즈니스로직만 따로 테스트하기쉽고,좀더 명확히 반영할수도있음
	제각기 특정한 api나 인바운드어댑터가 비즈니스로직을 호출하고,비즈니스로직은 아웃바운드 어댑터를 호출하는 구조
	
	별개로 모놀리식 아키텍쳐는,구현부를 단일컴포넌트로 구성한 아키텍쳐스타일이고,다른 뷰는 사용하지않음,얘도 육각형아키텍쳐로 구성한 논리뷰를 가질수있음
	마이크로서비스 아키텍쳐는 구현뷰를 다수의 컴포넌트로 구성함
	여기서 컴포넌트는 곧 서비스고,각 서비스는 자체 논리뷰 아키텍쳐를 가지고있음
	그리고 커넥터는,이런 서비스들이 서로 협동할수있게 해주는 통신 프로토콜임
	
	마이크로서비스의 핵심 제약조건은,서비스를 느슨하게 결합한다는것
	그래서 여러 서비스가 협동할때도 제약사항이 있음
	
	여기서 서비스란,어떤 기능이 구현되어 단독 배포가 가능한 소프트웨어 컴포넌트임
	서비스는 클라이언트가 자신이 서비스하는 기능에 접근할수있도록 커맨드,쿼리,이벤트로 구성된 api를 제공함
	서비스작업은 크게 커맨드,쿼리로 나뉘고,클라이언트가 소비하는 이벤트를 발행하기도 함
	
	서비스의 api는 내부구현상세를 캡슐화함
	모놀리스와 달리 이 api를 우회할수없기떄문에,모듈성은 보장됨
	
	각각의 ms는 자체 아키텍쳐를 가지고있어서 기술스택을 독자적으로 구축할수있지만,대부분 육각형 구조를 취함
	api는 서비스에 구현된 비즈니스로직과 소통하는 어댑터를 이용해 구현하고,작업어댑터는 로직을 호출하고,이벤트어댑터는 로직이 준 이벤트를 발행함
	서비스구현뷰는 스탠드얼론 프로세스,컨테이너의 웹앱,서버리스클라우드등 다양한 컴포넌트를 사용할수있음
	
	느슨하게 결합된 서비스는 msa의 주요 특성임
	서비스는 구현 코드를 감싼 api를 통해서만 상호작용하므로,클라이언트에 영향을 끼치지않고 서비스 내부 구현 코드를 바꿀수있음
	느슨하게 결합된 서비스는 유지보수성,테스트성을 높이고 개발시간을 줄여주고,
	서비스를 이해하고,변경하고,테스트하기 쉽게해줌
	
	서비스가 느슨하게 결합되고 api를 통해서만 동작하기때문에,서비스가 직접 db와 통신할수는 없음
	또 클래스필드같은 서비스의 영속적 데이터는 반드시 프라이빗으로 유지해야함
	이렇게해야 개발자가 자신이 맡은 서비스의 db스키마를 변경할때 다른사람과 조율할필요가 없고,
	서비스가 db를 공유하지않아서 런타임격리도 향상됨
	어떤 서비스가 db락을 획득해서 다른 서비스를 블로킹하는 일 자체가 불가능해짐
	단,여러 서비스에 걸쳐 데이터를 쿼리하고 일관성유지는 더 복잡해짐
	
	그리고 msa에서의 공유라이브러리는,만약 사용할경우 의도치않은 서비스간 결합이 생기지 않게 유의해야함
	그래서 변경가능성이 조금이라도 있으면 그냥 서비스로 구현하는게 낫고,진짜 절대안변하는거만 라이브러리로 사용해야함
	
	msa에서 서비스의 규모는 별로 중요하지않고,그냥 한 책임을 외부연결없이 시간내에 구현할수만 있으면됨
	
2.msa 정의
	msa의 시작은,도메인전문가가 문서로 정의한 요건들과 기존앱을 출발점으로
		시스템 작업식별(기능요건)
		서비스식별
		서비스api및 협동정의
	순으로 구성됨(그 객체지향에서 협동을 기준으로 객체를 붙여라 라는것과 비슷한듯)
	작업식별은,요건을 핵심요청으로 추출하는것,쿼리나 커맨드등이 해당되고,각 커맨드의 동작은 추상적 도메인모델관점에서 정의되고,이것도 요건에서 도출됨
	각 커맨드의 동작은 추상적도메인모델 관점에서 정의되고,이것도 요건에서 도출됨
	즉 여러 서비스가 서로 협동하는 방식을 표현한 아키텍쳐시나리오가 됨
	
	서비스식별은 어떻게 여러 서비스로 분해할지를 결정하는것,여러방법이 있는데
		비즈니스아키텍쳐의 시각에서 비즈니스능력에 따라 서비스를 정의
		ddd의 하위도메인별로 서비스를 구성
	등이 있음
	
	서비스api및 협동정의는,1단계에서 식별된 시스템작업을 각 서비스에 배정하고,서비스들이 협동하는 방식을 결정해야하는데,대부분 서비스에 추가지원작업을 두게됨
	api구현시 사용할 ipc도 정해야함
	
	분해과정에서는 장애물이 많은데,
		네트워크지연
		서비스간 동기통신으로 떨어지는 가용성
		데이터 일관성
		일관된 데이터뷰 확보
		만능클래스
	들이 있음
	동기통신은 자기완비형 서비스로,데이터일관성은 사가로 해결할수있지만,네트워크지연은 어쩔수없어서 다시 합치는경우도 있음
	일관된 데이터뷰는,전역범위에서 트랜잭션을 걸수없기때문에 생기는데,대부분 문제되진않음
	만능클래스는,중심이 되는 클래스를 분해할수없는현상인데,ddd를 적용해서 각각의 서비스속에 자신만의 그 클래스를 생성하는식으로 해결할수있음
	
	
	앱아키텍쳐를 정의하는 처음은 시스템작업을 정의하는것
	이건 고수준 도메인모델을 만들고,그 도메인모델관점에서 요건을 기술하면됨
	
	고수준 도메인모델을 정의할땐,대략적인 앱도메인모델을 그려보고,스토리에 포함된 명사를 분석해서 유스케이스로 확장시킬수있음
	이 유스케이스를 사용해서 클래스들을 도출해내고,그 클래스를 액터로하는 주요 시스템 커맨드,쿼리들을 표로 만들면됨
	
	그리고 서비스를 식별하고 분해해야하는데,두가지 방법이 있음
	첫번째는 비즈니스능력에 따라 분해하기
	비즈니스 능력을 보면 그 조직의 비즈니스가 보이고,대체적으로 비즈니스는 바뀌어도 비즈니스능력을 크게 바뀌지않기때문(예금을 폰으로하냐 직접가서하냐 이런느낌)
	
	한조직의 비즈니스능력은,조직의 목표,구조,비즈니스프로세스를 분석해서 식별할수있음
	기술보다 비즈니스위주라는 점만 제외하면 서비스라고 볼수도있음
	보통 이 비즈니스능력은 특정 비즈니스객체에 집중하고,여러하위능력으로 분해할수있음
	
	이 비즈니스능력을 식별한 후 능력에 따라 또는 연관된 능력 그룹에 따라 서비스를 정의함
	이때 분해는 알아서할문제지만,공급자가 다르면 분해하는게좋고,서비스가 밀접한연관이있으면 한 서비스로 묶으면됨
	이렇게하면 비즈니스요건이 달라져도 아키텍쳐는 그대로둔채 진화할수있음
	
	또 다른방법으로는,ddd로 하위 도메인을 식별하고,그 도메인별로 서비스를 정의하는방법이 있음
	각 도메인을 식별하는방법으로는,경계컨텍스트를 사용해서 식별할수있음
	걍계컨텍스트는 각 용어들이 달라지는 지점을 기준으로 삼으면됨
	
	이렇게 분해된 서비스는,단일책임원칙과 공동폐쇄원칙(두클래스가 같은이유로 변경되면 같은 패키지에 있어야한다는것)을 만족해야함
	
	이렇게 서비스분해를 했으면,각 서비스별 api를 정의해야함
	서비스api작업은 외부클라와 타 서비스가 호출하는 시스템작업과,서비스간협동을 지원하기위해 타서비스호출전용으로 만든작업 둘중 하나임
	서비스이벤트는 주로 타서비스와 협동하기위해 발행함,이벤트기반ms에서 옵저버패턴으로 주로 사용함
	
	일단 시스템작업을 서비스로 배정해야함
	제일먼저 어느 서비스가 요청의 진입점인지 결정해야함
	대부분의 시스템작업은 자연스레 서비스로 매핑되지만,그렇지않은것도 있음(정보와 필요한객체가 다른경우)
	
	일단 시스템작업을 서비스에 배정한 후 각 시스템작업을 처리하기위해 서비스가 어떻게 협동할지를 정해야함
	그리고 서비스 하나로 시스템작업이 전부 처리가능할수도 있지만,대부분은 여러서비스에 걸쳐있고,요청에 필요한 데이터가 흩어져있을수도 있음
	그래서 서비스끼리 어떻게 협동할지를 정해야함
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
-3.프로세스 간 통신	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	