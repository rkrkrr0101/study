-1.모놀리지옥에서 벗어나라
1.모놀리의 장점과 단점
	모놀리의 장점은,작은크기일땐
		개발이 간단함
		앱변경이 쉬움
		테스트가 쉬움
		배포가 쉬움
		확장이 쉬움
	이라는 장점이 있지만,커졌을때 문제가 됨
	커졌을때의 단점으로는
		전부 이해할수가 없을정도로 커짐
		한군데 건드렸을때의 사이드이펙트 상상이 안감
		ide실행시간이 너무길어짐
		테스트가 오래걸리고 신뢰성이 부족해짐(유닛테스트 안되는부분때문에 수동테스트해야하는영역이 많아짐)
		커밋부터 배포까지 너무오래걸림 (ci/cd파이프라인이 불가능함)
		확장이 어려움(각 모듈마다 필요한 리소스요건이 달라서 확장이 어려워짐)
		기술스택 변경이 어려움
		
2.마이크로서비스
	마이크로서비스아키텍쳐는,모놀리의 확장방식(파드복제해서 확장,데이터분할해서 확장)에 추가로 앱을 나누는 차원이 추가되는거임
	기본적인 모놀리식 확장방식을 사용하면,앱능력과 가용성은 확장되지만,앱의 복잡도증가는 해결되지않음
	그래서 기능분해가 필요해지는것
	이때 분해된 기능은,미니 앱이라고 보면 됨,서비스에 따라 복제확장등도 똑같이 가능함
	즉,msa는 고수준에서 바라보면,하나의 앱을 여러 서비스로 분해하는 스타일임
	여기서 중요한건 크기가 아니라,각 서비스가 응집된 책임을 가지고 있다는것
	
	마이크로서비스는 서비스를 모듈성의 단위로,그 선을 다른서비스가 들어오지 못하고,api를 통해서만 통신함
	그래서 독립성을 유지하기가 편하고,독립적으로 배포/확장할수있음
	
	그리고 각 서비스들은 각자 자신의 db테이블을 가지고있음,그래서 외부와 협의하지않고 자신의 스키마를 바꿀수있고,
	다른 서비스가 락을걸어서 나를 블로킹하는일이 없음
	만약 여러서비스가 한 db를 봐야한다면,그 db의 입출력을 담당하는 서비스를 만들고,api로 통신하면됨
	
	기본적으로 퍼사드패턴으로 api게이트웨이를 만들고,걔가 각 서비스의 api로 통신하는식으로 구성되게됨
	그리고 서비스에서 외부어댑터가 필요하면,자기껀 자기가 알아서 만들고,외부에 알리지만 않고 리턴값만 주면됨
	
3.마이크로서비스의 장단점
	마이크로서비스의 장점은
		크고 복잡한 앱을 지속적으로 전달/배포할수있음
		서비스규모가 작아 관리가 쉬움 
		서비스를 독립적으로 배포/확장할수있음
		팀들이 자율적으로 움직일수있음
		결함격리가 잘됨(한곳에서 메모리누수가 나도,그 서비스만 죽고끝남)
		새로운기술실험과 도입이 쉬움(서비스별로 따로니까,모든스택을 한번에바꿀필요가없음)
	
	마이크로서비스는 모놀리에 비해,유닛테스트등 자동화테스트가 쉽고(크기가 작아서),사이드이펙트가 적어서 버그도 적음
	그리고 배포도 독립적으로 할수있어서,개발자가 자신이 담당한 서비스변경분을 배포할때 다른개발자와 협의할필요가 없음
	작은팀이 여럿 결합된 식으로,가장 효율적인 크기로 기술조직을 굴릴수있음,즉 팀별로 서비스를 담당해서,외부영향을 안줄수있음
	
	즉 이래서 ci/cd가 가능해짐
	
	단점은
		딱맞는 서비스찾기가 어려움
		분산시스템을 공부해야함
		여러 서비스에 걸친 기능을 배포할땐 잘 조정해야함
		msa도입시점 결정이 어려움
	
	
4.마이크로서비스 패턴언어
	ms패턴언어는,전체 앱을 마이크로서비스로 구성할때 유용한 패턴의 모음집임
	패턴언어는 구조와 장단점을 기술하기때문에,무엇보다 지금 msa를 사용하는게 옳은일인지 결정할때 요긴함
	
	이 패턴들의 분류로는
		앱을 여러서비스로 분해하는 패턴
		통신패턴
		트랜잭션관리를 위한 데이터 일관성 패턴(사가)
		데이터쿼리패턴
		서비스배포패턴
		관측패턴
		서비스테스트자동화패턴
		횡단관심사처리패턴(공통관심사처리패턴)
		보안패턴
	
5.마이크로서비스 프로세스와 조직
		마이크로서비스는 8~12명정도에 애자일방식으로 스크럼같은걸 도입해서 하는게 좋음
	
	
	
	
	
	
-2.분해전략	
1.마이크로서비스 아키텍쳐란
	마이크로서비스의 핵심사상은 기능분해임
	하나의 큰 앱보단,작은 여러 서비스로 구성하는게 낫다는것
	
	소프트웨어 아키텍쳐는 4+1뷰모델로 볼수있음
		논리뷰:개발자가 작성한 소프트웨어 엘리먼트,클래스와 클래스의 상속같은것
		구현뷰:빌드의 결과물,모듈과 컴포넌트로 구성됨
		프로세스뷰:런타임 컴포넌트
		배포뷰:프로세스가 머신에 매핑되는 방법,이 뷰의 엘리먼트는 머신 및 프로세스고,머신간의 관계가 네트워킹임
			프로세스와 머신 사이의 관계도 이 뷰에서 기술됨
		시나리오:+1로,뷰를 구성시키는 시나리오임,각 시나리오는 특정뷰 내에서 얼마나 다양한 아키텍쳐요소가 협동해서 요청을 처리하는지를 기술함
	
	앱의 요건은,기능요건과 품질요건으로 나눠짐
	기능요건은 유스케이스같이 어떤 기능을 가지고있다는것,기능요건은 아키텍쳐와는 무관함
	품질요건은 확장성,신뢰성,관리성,테스트성,배포성처럼 아키텍쳐와 밀접한 품질의 요건임
	
	마이크로서비스는 육각형 아키텍쳐라고 볼수있음
	얘는 논리뷰를 비즈니스 로직 중심으로 구성하는데,앱에 표현계층대신 비즈니스로직을 호출해서 외부에서 들어온 요청을 처리하는 인바운드어댑터들과,
	비즈니스 로직에 의해 호출되고 외부 앱을 호출하는 아웃바운드 어댑터들을 둠
	비즈니스로직이 어댑터에 전혀 의존하지않는다는게 가장 큰 장점임,오히려 어댑터가 비즈니스로직에 의존함
	
	비즈니스로직엔 하나이상의 포트가 있음
	포트는 비즈니스로직이 외부세계와 상호작용하는 방법이 정의된 작업임
	기본적으로 인터페이스라고 생각하면됨
	포트는 인바운드 아웃바운드 두가지종류가 있고,
	인바운드포트는 비즈니스 로직이 표출된 api고,외부앱은 이 api를 통해 로직을 호출함
	아웃바운드포트는 비즈니스 로직이 외부시스템을 호출하는 방법에 관한것
	
	즉 중심엔 비즈니스로직이 있고,로직의 출입구로 포트들이 있으며,이 포트들에 어댑터들이 의존해서 외부와 출입을 함(의존성역전)
	
	기본적으로 인바운드 어댑터는 restapi,메시지브로커같은걸로 구현하고
	아웃바운드 어댑터는 dao,프록시같은걸로 구현함	
	아웃바운드 어댑터는 이벤트를 발행하기도 함
	
	이 육각형구조의 가장 큰 장점은,로직에 있던 표현/데이터접근로직이 어댑터와 분리되어서,비즈니스로직이 표현/데이터 접근로직 어디에도 의존하지않는다는것
	
	이렇게 분리를 하면,비즈니스로직만 따로 테스트하기쉽고,좀더 명확히 반영할수도있음
	제각기 특정한 api나 인바운드어댑터가 비즈니스로직을 호출하고,비즈니스로직은 아웃바운드 어댑터를 호출하는 구조
	
	별개로 모놀리식 아키텍쳐는,구현부를 단일컴포넌트로 구성한 아키텍쳐스타일이고,다른 뷰는 사용하지않음,얘도 육각형아키텍쳐로 구성한 논리뷰를 가질수있음
	마이크로서비스 아키텍쳐는 구현뷰를 다수의 컴포넌트로 구성함
	여기서 컴포넌트는 곧 서비스고,각 서비스는 자체 논리뷰 아키텍쳐를 가지고있음
	그리고 커넥터는,이런 서비스들이 서로 협동할수있게 해주는 통신 프로토콜임
	
	마이크로서비스의 핵심 제약조건은,서비스를 느슨하게 결합한다는것
	그래서 여러 서비스가 협동할때도 제약사항이 있음
	
	여기서 서비스란,어떤 기능이 구현되어 단독 배포가 가능한 소프트웨어 컴포넌트임
	서비스는 클라이언트가 자신이 서비스하는 기능에 접근할수있도록 커맨드,쿼리,이벤트로 구성된 api를 제공함
	서비스작업은 크게 커맨드,쿼리로 나뉘고,클라이언트가 소비하는 이벤트를 발행하기도 함
	
	서비스의 api는 내부구현상세를 캡슐화함
	모놀리스와 달리 이 api를 우회할수없기떄문에,모듈성은 보장됨
	
	각각의 ms는 자체 아키텍쳐를 가지고있어서 기술스택을 독자적으로 구축할수있지만,대부분 육각형 구조를 취함
	api는 서비스에 구현된 비즈니스로직과 소통하는 어댑터를 이용해 구현하고,작업어댑터는 로직을 호출하고,이벤트어댑터는 로직이 준 이벤트를 발행함
	서비스구현뷰는 스탠드얼론 프로세스,컨테이너의 웹앱,서버리스클라우드등 다양한 컴포넌트를 사용할수있음
	
	느슨하게 결합된 서비스는 msa의 주요 특성임
	서비스는 구현 코드를 감싼 api를 통해서만 상호작용하므로,클라이언트에 영향을 끼치지않고 서비스 내부 구현 코드를 바꿀수있음
	느슨하게 결합된 서비스는 유지보수성,테스트성을 높이고 개발시간을 줄여주고,
	서비스를 이해하고,변경하고,테스트하기 쉽게해줌
	
	서비스가 느슨하게 결합되고 api를 통해서만 동작하기때문에,서비스가 직접 db와 통신할수는 없음
	또 클래스필드같은 서비스의 영속적 데이터는 반드시 프라이빗으로 유지해야함
	이렇게해야 개발자가 자신이 맡은 서비스의 db스키마를 변경할때 다른사람과 조율할필요가 없고,
	서비스가 db를 공유하지않아서 런타임격리도 향상됨
	어떤 서비스가 db락을 획득해서 다른 서비스를 블로킹하는 일 자체가 불가능해짐
	단,여러 서비스에 걸쳐 데이터를 쿼리하고 일관성유지는 더 복잡해짐
	
	그리고 msa에서의 공유라이브러리는,만약 사용할경우 의도치않은 서비스간 결합이 생기지 않게 유의해야함
	그래서 변경가능성이 조금이라도 있으면 그냥 서비스로 구현하는게 낫고,진짜 절대안변하는거만 라이브러리로 사용해야함
	
	msa에서 서비스의 규모는 별로 중요하지않고,그냥 한 책임을 외부연결없이 시간내에 구현할수만 있으면됨
	
2.msa 정의
	msa의 시작은,도메인전문가가 문서로 정의한 요건들과 기존앱을 출발점으로
		시스템 작업식별(기능요건)
		서비스식별
		서비스api및 협동정의
	순으로 구성됨(그 객체지향에서 협동을 기준으로 객체를 붙여라 라는것과 비슷한듯)
	작업식별은,요건을 핵심요청으로 추출하는것,쿼리나 커맨드등이 해당되고,각 커맨드의 동작은 추상적 도메인모델관점에서 정의되고,이것도 요건에서 도출됨
	각 커맨드의 동작은 추상적도메인모델 관점에서 정의되고,이것도 요건에서 도출됨
	즉 여러 서비스가 서로 협동하는 방식을 표현한 아키텍쳐시나리오가 됨
	
	서비스식별은 어떻게 여러 서비스로 분해할지를 결정하는것,여러방법이 있는데
		비즈니스아키텍쳐의 시각에서 비즈니스능력에 따라 서비스를 정의
		ddd의 하위도메인별로 서비스를 구성
	등이 있음
	
	서비스api및 협동정의는,1단계에서 식별된 시스템작업을 각 서비스에 배정하고,서비스들이 협동하는 방식을 결정해야하는데,대부분 서비스에 추가지원작업을 두게됨
	api구현시 사용할 ipc도 정해야함
	
	분해과정에서는 장애물이 많은데,
		네트워크지연
		서비스간 동기통신으로 떨어지는 가용성
		데이터 일관성
		일관된 데이터뷰 확보
		만능클래스
	들이 있음
	동기통신은 자기완비형 서비스로,데이터일관성은 사가로 해결할수있지만,네트워크지연은 어쩔수없어서 다시 합치는경우도 있음
	일관된 데이터뷰는,전역범위에서 트랜잭션을 걸수없기때문에 생기는데,대부분 문제되진않음
	만능클래스는,중심이 되는 클래스를 분해할수없는현상인데,ddd를 적용해서 각각의 서비스속에 자신만의 그 클래스를 생성하는식으로 해결할수있음
	
	
	앱아키텍쳐를 정의하는 처음은 시스템작업을 정의하는것
	이건 고수준 도메인모델을 만들고,그 도메인모델관점에서 요건을 기술하면됨
	
	고수준 도메인모델을 정의할땐,대략적인 앱도메인모델을 그려보고,스토리에 포함된 명사를 분석해서 유스케이스로 확장시킬수있음
	이 유스케이스를 사용해서 클래스들을 도출해내고,그 클래스를 액터로하는 주요 시스템 커맨드,쿼리들을 표로 만들면됨
	
	그리고 서비스를 식별하고 분해해야하는데,두가지 방법이 있음
	첫번째는 비즈니스능력에 따라 분해하기
	비즈니스 능력을 보면 그 조직의 비즈니스가 보이고,대체적으로 비즈니스는 바뀌어도 비즈니스능력을 크게 바뀌지않기때문(예금을 폰으로하냐 직접가서하냐 이런느낌)
	
	한조직의 비즈니스능력은,조직의 목표,구조,비즈니스프로세스를 분석해서 식별할수있음
	기술보다 비즈니스위주라는 점만 제외하면 서비스라고 볼수도있음
	보통 이 비즈니스능력은 특정 비즈니스객체에 집중하고,여러하위능력으로 분해할수있음
	
	이 비즈니스능력을 식별한 후 능력에 따라 또는 연관된 능력 그룹에 따라 서비스를 정의함
	이때 분해는 알아서할문제지만,공급자가 다르면 분해하는게좋고,서비스가 밀접한연관이있으면 한 서비스로 묶으면됨
	이렇게하면 비즈니스요건이 달라져도 아키텍쳐는 그대로둔채 진화할수있음
	
	또 다른방법으로는,ddd로 하위 도메인을 식별하고,그 도메인별로 서비스를 정의하는방법이 있음
	각 도메인을 식별하는방법으로는,경계컨텍스트를 사용해서 식별할수있음
	걍계컨텍스트는 각 용어들이 달라지는 지점을 기준으로 삼으면됨
	
	이렇게 분해된 서비스는,단일책임원칙과 공동폐쇄원칙(두클래스가 같은이유로 변경되면 같은 패키지에 있어야한다는것)을 만족해야함
	
	이렇게 서비스분해를 했으면,각 서비스별 api를 정의해야함
	서비스api작업은 외부클라와 타 서비스가 호출하는 시스템작업과,서비스간협동을 지원하기위해 타서비스호출전용으로 만든작업 둘중 하나임
	서비스이벤트는 주로 타서비스와 협동하기위해 발행함,이벤트기반ms에서 옵저버패턴으로 주로 사용함
	
	일단 시스템작업을 서비스로 배정해야함
	제일먼저 어느 서비스가 요청의 진입점인지 결정해야함
	대부분의 시스템작업은 자연스레 서비스로 매핑되지만,그렇지않은것도 있음(정보와 필요한객체가 다른경우)
	
	일단 시스템작업을 서비스에 배정한 후 각 시스템작업을 처리하기위해 서비스가 어떻게 협동할지를 정해야함
	그리고 서비스 하나로 시스템작업이 전부 처리가능할수도 있지만,대부분은 여러서비스에 걸쳐있고,요청에 필요한 데이터가 흩어져있을수도 있음
	그래서 서비스끼리 어떻게 협동할지를 정해야함
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
-3.프로세스 간 통신
1.개요
	ipc는 restapi같이 통신메커니즘을 말함
	기본적으로
		동기:rest,gRPC
		비동기메시지:AAMQP,STOMP
	등이 있고,메시지포맷도 json,xml,yaml등 텍스트포멧과 이진바이너리포멧이 있음
	
	일단 내가 필요한 상호작용스타일이 일대일인지 일대다인지 확인하고,동기인지 비동기인지 확인하면 뭘 사용할지 알수있음
	일대일인경우 
		동기
		비동기
		단방향알림
	일대다인경우
		발행/구독
		발행/비동기응답
	인경우에 따라 다르게 선택하면됨
	
	
	msa에서는 api와 인터페이스는 똑같이 중요함
	서비스api는 서비스와 클라이언트에 약속이고,클라이언트가 호출 가능한 작업과,서비스가 발행하는 이벤트로 구성됨
	작업에는 이름,매개변수,반환형이 있고,타입과 필드를 가진 이벤트는 메시지채널에 발행됨
	
	문제는 서비스와 클라이언트가 같이 컴파일 되지않는다는것
	따라서 새 버전의 서비스가 호환되지않는 api에 맞물려 배포되어도,런타임때 실패해버림
	그래서 서비스api는 idl로 정확히 정의하고,그거에따라 정의된 입출력양식대로 정확히 입출력되어야함
	
	만약 api를 업데이트해야한다면,기본적으론 마이너메이저로 구분하고,신버전 구버전을 동시에 지원하다가 시간지나고 구버전을 지워야함
	그리고 가능하면 하위호환성을 보장해야함
	일반적으로 api에 뭔가를 추가하는건 대부분 하위호환됨
	단,견고성원칙(내가하는건 보수적으로,다른사람이하는건 관대하게 해석)을 지켜야함
	요청속성이 누락되어도 서비스는 기본값을 제공하고,서비스가 필요한것보다 많은 속성을 응답해도 클라이언트는 무시할수있어야함
	
	만약 기존변경과 호환안되는 변경점을 적용해야할땐,신/구버전을 모두 지원하면됨(v1,v2)
	
	ipc의 메시지포맷은,크게 텍스트와 이진포맷이 있고,여기서는 어떤 한 언어에 종속되는(자바직렬화같은)건 사용하면안됨
	텍스트엔 json,xml,yaml등이 있고,얘들은 사람이 읽을수있고,전체문서중 자기가 필요한것만 읽으면되니까 하위호환성이 보장됨,단점으론 메시지가 커진다는것
	이진포맷에는 프로토콜버퍼와 아브로등이 있고,이 포맷은 메시지구조정의에 필요한 타입idl을 제공하고,컴파일러는 메시지를 직렬화/역직렬화하는 코드를 생성함
	따라서 강제로 api우선접근방식으로 설계할수밖에 없고,정적타입언어로 클라를 작성하면 클라가 api를 올바르게 사용하는지 컴파일러로 확인할수있음
	
2.동기rpi패턴 응용통신
	rpi는 클라이언트가 서비스에 요청을 보내면,서비스가 처리후 응답을 회신하는 ipc임
	응답대기중에 블로킹하는 클라이언트도 있고,논블로킹하는 클라이언트도 있지만,어쨌든 응답이 제때 도착할거라고 가정함
	단,이때 타임아웃등으로 실패할수도 있으니,부분실패를 적절히 처리할수있어야함
	
	rest는 http로 소통하는 ipc고,현재 대세임
	rest는 http동사(get,post,put)를 사용해 url로 참조되는 리소스를 가공,조작함
	rest를 정의할땐,openapi를 사용해서 정의하면됨
	rest의 단점은,요청 한번으로 많은 리소스가져오기가 힘들고(동기라서 여러테이블조회하면 그만큼 대기시간이 길어짐),
	작업을 http동사에 매핑하기가 힘들고(그래서 그냥 post에 다 박아버리는듯),멱등성을 보장못하는것에선 put를 사용하기힘듬
	
	즉 rest의 장점은
		단순하고 익숙함
		포스트맨같은거로 테스트가쉬움
		요청/응답스타일의 통신을 직접 지원함
		http는 방화벽친화적
		중간브로커가 필요하지않아서 아키텍쳐가 단순해짐
	단점은
		요청/응답스타일만 지원함
		가용성이 떨어짐(중간브로커가 없이 직접통신해서 교환할떄 클라/서비스 둘다 실행중이어야함)
		요청한번으로 여러리소스가져오기힘듬
		다중업데이트작업을 http동사에 매핑하기어려울때가 많음
		
	gRPC는 이것도 동기rpi인데,rest의 업그레이드판임
	얘는 다양한 언어로 서버를 작성할수있는 프레임워크고,이진메시지기반이라서 강제적으로 서비스가 api우선방식으로 설계됨
	
	얘는 하나이상의 서비스와 요청/응답메시지 데피니션으로 구성됨
	이건 자바 인터페이스처럼 정적타입메서드를 모아둔것
	grpc는 요청/응답말고도 스트리밍rpc도 지원하므로,서버가 클라에 스트림을 응답하는것도 가능함
	
	grpc는 프로토콜버퍼 메시지포맷을 사용하는데,이건 각 필드마다 번호를 매기고,타입코드를 할당함
	메시지 수신자는 자신이 필요한 필드만 추출하고,모르는필드는 그냥 건너뛰어서 하위호환성을 유지하고 api를 발전시킬수 있음
	
	grpc의 장단점은
	장점
		다양한 업데이트작업이 포함된 api설계가 쉬움
		큰메시지교환할때 효율적임
		양방향스트리밍이 가능해서,rpi 메시징 둘다 사용가능함
		다양한언어로 작성된 클라/서버연동이 가능
	단점
		자바스크립트 클라이언트가 하는일이 rest보다 많음
		구형방화벽은 http/2를 지원하지않음
	단 이거도 동기통신이라서,부분실패문제는 해결방법을 찾아야함
	
	부분실패문제는 회로차단기 패턴을 사용할수있음
	분산시스템은 서비스가 다른서비스를 동기호출할때마다 실패할 가능성이 항상 존재함
	이때 서비스의 실패는 상위로 거슬러올라가면서,전체시스템의 중단이 될수도 있음
	
	그래서 연속실패횟수가 임계치를 넘기면,일정시간동안 호출을 즉시거부하는 rpi프록시를 설치하는게 회로차단기 패턴임
	즉,프록시에서 실패횟수가 쌓이면,즉시 거부응답을 날리고,서비스요청한거는 그걸 예외처리해서 서버가 바쁩니다 같은 메시지를 띄우는방식
	
	그리고 서비스가 다른서비스를 호출할때 자기자신을 방어하는방법은
		네트워크 타임아웃을 반드시 걸어둠
		미처리요청 갯수제한,큐에 제한을 걸어두고,넘기면 즉시실패처리
		회로차단기패턴
	을 다 해두는게 좋음
	자바면 넷플릭스 히스트릭스 라이브러리를 사용할수있음
	
	그리고 부분실패시 처리방법엔,에러를 던지던가,기본값을 던지던가,캐시된 응답을 던지던가 하는 방법들이 있음
	중요하지않을경우엔 그냥 대충던져도되는데,중요한거면 그냥 실패처리하는게좋음
	
	서비스디스커버리는,서비스들의 ip/포트들을 가지고,리턴해주는 객체임
	즉 쿠버네티스에서의 레이블-서비스라고 생각하면됨
	스킵함
	
	
3.비동기메시징패턴 응용통신	
	메시징은 서비스가 메시지를 서로 비동기적으로 주고받는 통신방식임 (옵저버패턴같은거)
	일반적으로 브로커가 있지만,없는거도 있음
	비동기라서 클라이언트가 응답을 기다리며 블로킹하지않고,클라는 응답을 바로 받지 못할거라는 전제하에 작성함
	
	메시지는 헤더와 바디로 구성되고,메시지종류엔
		문서:데이터만 포함된 메시지
		커맨드:호출할 작업과 매개변수가 지정된 메시지
		이벤트:송신자에게 이벤트가 발생했음을 알리는 메시지(옵저버패턴)
	등이 있음
	
	메시지는 채널을 통해 교환됨
	송신자의 비즈니스로직은, 하부통신메커니즘을 캡슐화한 송신포트인터페이스를 호출하고,이 인터페이스는 송신자어댑터클래스로 구현하며,
	이 클래스는 메시징 인프라를 추상한 메시지채널을 통해 수신자에게 메시지를 전달함
	수신자의 메시지핸들러 어댑터클래스는 메시지를 처리하기위해 호출되고,이 클래스는 컨슈머 비즈니스로직으로 구현된 수신포트인터페이스를 호출함
	
	이때 송신자와 수신자가 보내고받을수있는 메시지갯수는 무제한임
	
	채널의 종류는 점대점,발행구독 두종류가 있음
	점대점은 채널을 읽는 컨슈머중 딱 하나만을 지정해서 던지는것,보통 커맨드메시지에 사용
	발행구독은 같은 채널을 바라보는 모든 컨슈머에 메시지를 전달,일대다상호작용스타일 서비스가 이 채널을 사용함
	
	요청/응답,비동기 요청/응답 둘다 클라가 요청을 보내면 서비스가 응답을 반환함
	클라는 동기일경우 즉시 리턴이 올거라고 기대하지만,비동기는 그런 기대를 하지않음
	메시징은 원래성격자체가 비동기적이라서 비동기만 지원하지만,응답받기전까지 블로킹걸어버리면 동기로 사용할수도 있긴함
	
	클라이언트/서비스는 한쌍의 메시지를 주고받는 비동기스타일로 상호작용함
	클라는 작업과 매개변수가 담긴 커맨드를 서비스가 소유한 점대점 메시징채널에 보내고,서비스는 요청을 처리하고 결과를 클라가 소유한 점대점으로 돌려보냄
	
	클라는 서비스가 어디로 응답메시지를 보내야하는지를 알려주고,이렇게 받은 응답은 요청과 짝이맞아야함(헤더에 명시하면됨)
	
	단방향알림은 비동기메시지를 사용해서 그냥 클라이언트가 던지고 응답은 안받는식
	
	발행/구독은 클라이언트가 여러 컨슈머가 구독한 채널에 메시지를 발행하면,서비스는 그걸 감지하고 해당된 작업을 처리함(옵저버패턴)
	
	발행/비동기응답은 발행구독+요청/응답임
	클라는 응답채널헤더가 명시된 메시지를 발행/구독채널에 발행하고,컨슈머는 id가 포함된 응답메시지를 지정된 응답채널에 씀
	그러면 클라는 이 응답채널을 보고 응답메시지와 요청을 맞춰봄
	근데 이건 결합도생겨서 안쓸거같은데
	
	메시징기반서비스의 비동기 api명세엔 메시지채널명,각채넣을 통해 교환되는 메시지타입과 포맷을 명시하고,포맷은 표준포맷을 사용해야함
	서비스 비동기 api는 클라가 호출하는작업과 서비스에 의해 발행되는 이벤트로 구성됨,이 둘은 문서화하는 방법이 다름
	
	서비스작업은 
	요청/비동기 응답스타일 api:서비스의 커맨드메시지채널,메시지타입과 포맷,서비스가 반환하는 응답메시지의 타입과 포맷으로 구성됨
	단방향 알림 스타일 api:서비스의 커맨드메시지채널,서비스가 받는 커맨드메시지타입과 포맷으로 구성됨
	
	그리고 서비스는 발행/구독스타일로도 이벤트를 발행할수있음
	이럴때의 api명세는 이벤트채널,서비스가 채널에 발행하는 이벤트메시지와 타입,포멧으로 구성됨
	
	메시징기반의 앱들은 대부분 메시지브로커를 사용함
	브로커가 없으면 거리가 짧아져서 유용한경우도 있긴한데,대부분은 브로커있는게 나음
	
	메시지브로커는 모든 메시지가 지나가는 중간지점임
	송신자가 브로커에 메시지를 쓰면,브로커는 메시지를 수신자에게 전달함
	이거의 가장 큰 장점은,송신자가 수신자의 네트워크위치를 몰라도되고,수신자가 처리못하고있을땐 브로커가 버퍼할수있다는것
	
	브로커가 있을때
	장점
		느슨한결합:클라는 그냥 브로커에 던지면돼서,결합도가 낮아짐
		메시지버퍼링:수신자가 터져나갈때 버퍼링가능해짐
		유연한통신:모든 상호작용스타일을 지원
		명시적ipc:서비스가 같은로컬에 있는거처럼 사용할수있음
	단점
		운영복잡도증가:브로커가 생겨서 설치하고 운영할게늘어남
		
	메시지 순서를 유지한채 수신자를 스케일아웃하는건 어려움
	메시지를 순서대로 보내도,순서대로 도착한다는 보장이 없기때문
	
	그래서 요즘 메시지브로커는 샤딩된 채널을 사용해서,메시지 한묶음(특정 주문메시지같은)에 해시값을 사용해서,
	한덩어리는 한 채널에서 다 처리하게만들어서 이 문제를 해결했음
	
	또 중복메시지문제도 있는데,이건 멱등한 메시지를 만들거나,아니면 메시지를 추적하고 중복이 있을경우 취소하는 로직을 만들어야함
	
	서비스는 db를 업데이트하는 트랜잭션의 일부로 메시지를 발행함
	db업데이트와 메시지전송을 한 트랜잭션으로 묶지않으면 db업데이트 후 메시지는 전송되지않은상태에서 서비스가 중단될수있어서 문제가 됨
	분산트랜잭션을 사용하면 간편하지만,요즘은 그걸 사용하지않고,
	db테이블을 메시지큐로 활용하거나(rdbms 트랜잭션을 활용해 한번에 집어넣고,한번에 읽고 한번에 삭제하는식)
	계속 셀렉트를 날려서 새로생긴 메시지를 조회해서 브로커에 넣음(단 이건 db가 크면 부하가커짐)
	또는 트랜잭션로그를 읽어서 이걸사용해서 변경분을 알아내고 브로커에 넣는식(그 이벤트기반ms에서 본듯)
	
	서비스가 메시지를 주고받으려면 라이브러리가 필요함
	브로커에도 클라이언트라이브러리가 있지만,
	이걸 사용하면 
		브로커와 비즈니스로직이 결합됨
		브로커의 라이브러리는 저수준이라 반복이 심함
		고수준을 지원하지않음
	이런 단점이 있어서,고수준 라이브러리가 필요함
	
	이때 라이브러리가 지원해야하는건
		트랜잭셔널 메시징:메시지를 db트랜잭션의 일부로 발행해야함
		중복메시지감지:중복메시지를 처리할수있어야함
	이건 구현된거여야함
	
	
	
	
4.비동기 메시징으로 가용성 개선
	rest의 문제는 동기통신이라는거고,동기통신의 경우 가용성이 떨어지는 문제가 있음
	만약 서비스 3개가 동시에 작동할경우,세 서비스가 전부 가용성이 99.5면 전체가용성은 98.5가 되는 그런문제가 생김
	
	비동기 api만 있는 서비스를 정의해서 해결하는 방법도 있지만,일반적으로 동기가 필요한경우가 많음
	기본적으로 비동기로 짤수잇으면 비동기로 짜는게 좋고,동기도 양방향 옵저버패턴을 사용해서 비동기통신으로 바꿀수있음(요청/응답 둘다 채널에 적고 가져가는식)
	
	그런데 만약 외부api를사용해야하는데 그게 rest면,데이터를 복제해서 가용성을 높일수있음
	이건 api의 최신상태를 유지하는 서비스를 만들고,api를 사용해야하는 서비스들은 상태서비스를 구독해서 상태값을 받아오는식
	
	단 용량이 너무 큰경우엔 사용할수없고,이경우엔 클라에 응답전까지 다른서비스와의 상호작용을 지연시키는방법이 있음
	요청처리도중 동기통신을 제거하려면,
		로컬에 있는데이터로 요청을 검증하고
		메시지를 큐테이블에 삽입하는식으로 db를 업데이트하고
		클라이언트에 응답을 반환함
	이러면 서비스는 요청처리중에 다른서비스와 동기작용을 하지않고,다른서비스에 메시지를 비동기전송함으로써 서비스를 느슨하게결합할수있음(사가)
	
	
	
	
	
-4.사가
1.msa에서의 트랜잭션관리
	모놀리에서의 트랜잭션은 어렵지않은데,msa에서는 데이터가 여러 서비스에 흩어져있기때문에 어려움
	그래서 예전에 썼던게 분산트랜잭션인데,이건 2단계커밋을 활용해서,전체 트랜잭션 참여자가 커밋날때까지 대기하다가,다 커밋안나면 롤백하는식임
	이건 간단하긴하지만,현대 메시지브로커등은 지원하지않고,동기ipc라서 가용성이 떨어지게됨
	
	그래서 나온게 사가패턴임
	사가는 비동기메시징을 이용해서 편성한 일련의 로컬트랜잭션임
	사가는 기본적으로,자신이 커밋한걸 돌리는 보상트랜잭션을 반드시 작성하고,문제가 생겨서 돌려야하면 그걸 사용해서 롤백을 하는방식임
	그리고 비동기메시징을 사용하면,하나이상의 사가참여자가 일시불능이어도 사가의 전체단계를 확실히 실행시킬수있음
	
	사가는 acid중에 i(격리성)가 없는,acd트랜잭션임
	그리고 사가는 로컬 트랜잭션마다 변경분을 커밋하므로,보상트랜잭션으로 롤백해야함 
	
	사가가 동작할떄 서비스는 로컬트랜잭션이 완료되면 메시지를 발행하여,다음 사가 단계를 트리거함
	메시지를 통해 사가참여자를 느슨하게 결합하고,사가가 반드시 완료되도록 보장함
	만약 수신자가 일시불능일경우,브로커는 메시지를 전달할수있을때까지 메시지를 버퍼링함
	
	그리고 만약 실패했을경우,n+1번에서 롤백이 떨어지면,n번부터 1번까지의 보상트랜잭션을 전부 순서대로 가동시키는식
	
	그리고 사가에서,실패할가능성이 있는건 보상트랜잭션,절대실패하지않는단계 다음에있는건 피봇트랜잭션,항상성공하는건 재시도가능트랜잭션이라고 함
	
	
	
2.사가 편성	
	사가는
		코레오그래피:의사결정과 순서화를 사가참여자에게 맡김,주로 이벤트교환방식으로 통신
		오케스트레이션:사가편성로직을 오케스트레이터에 중앙화함,오케스트레이터는 참여자에 커맨드를 보내 수행할작업을 지시함
	
	
	코레오그래피는 중앙이없고,사가참여자가 자신의 다음이 특정이벤트채널을 구독하게 해서,이벤트를 발행해서 거기에 따라 반응하는방식 즉 발행/구독식임
	코레오그래피의 중요한점은,서로 확실하게 통신하려면 트랜잭셔널 메시징(그 db에 넣고 다넣어지면 가져가는거)를 사용해야하고,
	사가참여자는 자신이 수신한 이벤트와 자신의 데이터를 연관지어야하는데,그러면 id값같은게 이벤트에 포함되어야함
	
	코레오그래피의 장점은
		단순함:객체를 생성,수정,삭제할때 서비스가 이벤트를 발행함
		느슨한결합:참여자는 이벤트를 구독할뿐 서로를 직접 알지못함
	단점은
		이해어려움:사가를 모아둔게 아니라서,구현로직이 흩어지고,순서대로 일일히봐야함
		서비스간 순환의존성:참여자가 서로 이벤트를 구독하니까,순환의존성이 발생할수있음
		단단한결합 가능성:자신에게 영향주는 모든이벤트를 구독해야해서,거기에 발행하는애가 수정하면 나도 수정해야할 가능성이 높아짐
	
	보통 간단한거라면 코레오그래피를 사용하고,좀 커진다싶으면 오케스트레이션을 사용함
	
	오케스트레이션은,각 사가참여자는,자신의 입력채널과 출력채널을 각각두고(겹칠수도있음),
	오케스트레이터가 입력채널에 입력하면 일을 한후에 출력채널에 출력하면 오케스트레이터가 그걸보고 다음일시킬곳에 입력을 날리는,
	오케스트레이터가 처리순서를 관장하는 방식임
	
	기본적으로 오케스트레이터는 상태기계로 모델링할수있음,즉 상태패턴에서처럼 순서대로 상태를 받고,현재 상태에 따라 행동이 나가게 하는것
	
	오케스트레이션의 장점은
		의존관계 단순화:오케스트레이터는 참여자를 호출하지만,참여자는 오케스트레이터를 호출하지않아서 순환의존성이 발생하지않음
		낮은결합도:각 서비스는 오케스트레이터가 호출하는 api만 구현할뿐,다른 참여자의 이벤트는 몰라도됨
		관심사를 더 분리하고 비즈니스로직을 단순화:사가로직이 오케스트레이터에만 있으므로,객체는 단순해지고 자신이 참여한 사가에대해 알지못하게됨
	단점은
		생각없이 오케스트레이터에 중앙화를 너무많이하면,오케스트레이터가 일일히 다 세세하게 작업을 챙기는식이 돼서 복잡도가 높아짐
		그래서 오케스트레이터는 순서화만 담당하고 비즈니스로직은 가지고있으면안됨
		
3.비격리문제
	acid의 i는 여러 트랜잭션의 결과의 순서를 바꿔도 동일하다는걸 보장하는 속성임
	근데 사가에는 i가 빠져서,
		한 사가가 실행중에 접근하는데이터를 다른사가가 바꿔치기할수있음
		한 사가가 업데이트하기전에 이전데이터를 다른사가가 읽어서 일관성이 깨질수있음
	라는 문제가 있음
	
	이때 나타나는 문제는
		소실된업데이트:한사가의 변경분을 다른 사가가 미처 못읽고 덮어씀
		더티읽기:사가업데이트를 하지않은 변경분을 다른 트랜잭션이나 사가가 읽음
		퍼지/반복불가능한 읽기:한 사가의 상이한 두단계가 같은데이터를 읽었는데 값이 달라지는현상,다른 사가가 중간에 업데이트를 했을경우
	가 있음
	
	이 문제들을 해결할때 사용되는 방법은
		시맨틱락:앱수준 락
		교환적업데이트:업데이트의 순서상관없이 같은값나오게함
		비관적관점:사가단계순서를 재조정해서 리스크를 최소화
		값다시읽기:값을 두번읽어서 더티쓰기를 방지함
		버전파일:순서재조정가능하게 업데이트를 기록
		값에의한(바이밸류):요청별 비즈니스 위험성을 기준으로,동시성메커니즘을 동적선택
		
	사가의 트랜잭션 종류엔
		보상가능트랜잭션:보상트랜잭션으로 롤백가능한 트랜잭션
		피봇트랜잭션:사가의 진행/중단지점,이걸 넘어가면 사가는 완료될때까지 실행됨
		재시도가능트랜잭션:피봇트랜잭션이후의 트랜잭션,반드시성공
	
	
	시멘틱락은 보상가능트랜잭션이 생성/수정하는 레코드에 무조건 플래그를 세팅하는방법임
	레코드가 커밋되지않았다는표시를 하고,표시됐으면 접근하지않거나 조심하는것
	그리고 완료되면 커밋표시를 하는방법임
	즉 pending같은거임
	
	이걸 사용하면 acid의 격리성을 되살릴수있음,단 데드락이 걸릴수있어서 이거처리도 할수있게해야함
	
	교환적업데이트는,순서상관없이 업데이트해도 같은값이 나오게하는건데,가능한곳에선 사용하면되는데,안되는곳이 많음
	
	비관적관점은 더티읽기로 인한 리스크를 줄이기위해,값을 업데이트하는건 보상가능이 아닌 재시도가능트랜잭션에 최대한넣는것
	
	값 다시읽기는,그냥 끝나기전에 값한번 더읽어서 일치해야 ok날리는거
	
	버전파일은 레코드에 수행한 작업을 하나하나기억하는것,이벤트소싱
	
	바이밸류는 위험성을 기준으로 동시성메커니즘을 선택하는것
	
	

-5.비즈니스로직 설계
1.비즈니스로직 구성패턴
	서비스의 중간엔 비즈니스로직이 있고,인아웃바운드어댑터가 주변을 감싼 육각형구조임
	인바운드는 클라요청을받아 로직을 호출하고,로직은 아웃바운드를 호출해서 다른서비스나 앱을 실행함
	
	일반적으로 비즈니스로직은 서비스에서 가장 복잡한 부분임
	그래서 이 비즈니스로직을 어떻게 구성/개발할지를 고민해야함
	
	일반적으론 두가지 방법이 있음
	트랜잭션스크립트와 도메인모델
	
	트랜잭션스크립트는 절차지향방식으로,작은크기의 서비스가 변화가 없을것으로 예상될때만 사용할수있음
	얘는 객체지향설계를 하지않고,트랜잭션스크립트라는 메서드를 작성해서 표현계층에서 들어온 요청을 처리하는것
	이 방법은 동작클래스와 상태클래스가 따로 존재하는 중요한 특징이 있음(dao와 data)
	
	도메인모델은 객체지향방식임
	트랜잭션스크립트는 각 요청및 시스템작업마다 하나의 메서드를 갖게되지만,도메인모델을 사용하면 서비스메서드가 단순해짐
	서비스메서드가 항상 비즈니스로직이 잔뜩 포함된 영속화 도메인객체에 위힘하기때문
	서비스메서드는 db에서 도메인객체를 로드하고,메소드중 하나를 호출함
	따라서 동작/상태를 모두 가진 클래스의 상태값은,메서드를 통한 간접접근만 가능해짐
	
	이 도메인모델을 발전시킨게 DDD,도메인주도설계임
	ddd의 핵심은 하위도메인과 이와 연관된 경계컨텍스트임
	
	ddd에서의 주요 블록들은
		엔티티:영속적 신원을 가진 객체,두 엔티티가 속성이 같아도 다른객체임
		밸류객체:값을 모아둔 객체,속성값이 같으면 바꿔쓸수있음
		팩토리:생성자로 만들기 복잡한걸 따로 떼어둔 객체 혹은 메소드
		리포지터리:엔티티를 저장하는 db접근로직을 캡슐화한 객체
		서비스:엔티티,밸류객체에 속하지않은 로직구현객체
		애그리거트
	가 있음
2.DDD-애그리거트 패턴
	객체지향설계에 기반한 도메인모델은,클래스와 클래스간의 관계를 모아둔것
	클래스는 보통 패키지로 구성됨

	애그리거트는 한 단위로 취급 가능한 경계내부의 도메인 객체들임
	즉 하나의 루트엔티티와 하나이상의 기타엔티티+밸류 객체로 구성됨
	도메인모델 하나는 하나이상의 여러 애그리거트로 구성될수있음
	그리고 각 애그리거트는,도메인모델을 개별적으로 이해가 쉬운 덩어리로 분해하고,로드,수정,삭제같은 작업범위를 분명하게 설정함
	그리고 각 애그리거트에 접근할땐,무조건 애그리거트 루트를 통해야함,즉 직접접근은 불가능하고 간접접근만 허용함
	
	그리고 애그리거트를 업데이트할땐 부분이 아닌 전체 애그리거트단위로 업데이트를해서 애그리거트안에서의 일관성문제를 해소할수있음
	
	애그리거트에선 지켜야할 규칙이 있고,이걸지키면 자신의 불변값을 강제하는 자기완비형 단위가 될수있음
		애그리거트 루트만 참조
		애그리거트간 참조는 반드시 기본키를 사용(id값)
		하나의 트랜잭션으로는 하나의 애그리거트를 생성/수정해야함(사가를 사용),즉 사가의 한 단위를 애그리거트로 잡으면됨
	
	애그리거트는 작으면 작을수록 좋음
	애그리거트의 업데이트는 직렬화되므로,작으면 그만큼 앱이 동시처리가능한 요청갯수가 늘고 확장성이 좋아짐
	단,애그리거트자체가 트랜잭션의 범위라서,어떤 업데이트를 원자적으로 처리하려면 애그리거트를 크게잡아야할수도있음
	
	msa비즈니스로직은 대부분 애그리거트로 구성되고,나머지는 도메인서비스와 사가에 위치함
	사가는 로컬트랜잭션을 오케스트레이션하여 일관성을 맞추고,인바운드어댑터는 진입점인 서비스를 호출함
	서비스는 리포지터리로 db에서 애그리거트를 조회하거나,db에 애그리거트를 저장함 
	리포지터리는 각각 db에 접근하는 아웃바운드 어댑터로 구현됨
	
	이때 한서비스에 국한된 간단한 요청은,애그리거트로 직접 업데이트하고,여러서비스에 걸친 업데이트요청은 사가를 생성해서 처리하면됨
	
3.도메인이벤트 발행
	ddd에서 도메인 이벤트란 애그리거트에 발생한 사건임
	도메인 이벤트는 도메인모델에서는 클래스로 표현되고,대부분 어떤 상태변경을 나타냄
	애그리거트는 상태가 전이될떄마다 이에 관련된 컨슈머를 위해 이벤트를 발행함
	
	즉,db에서의 애그리거트 상태전이가 모든 상황에서 알림을 트리거하는 장본인임
	
	이벤트엔 의미를 부여하는 프로퍼티가 있고,프로퍼티는 원시값이나 값객체임(id값을 포함한 값들)
	그리고 대부분 이벤트id와 타임스탬프등 메타데이터를 넣고,변경을 일으킨 사용자 신원정보를 넣기도 함
	
	그리고 이런 도메인이벤트는,도메인이벤트 인터페이스를 만들고 이걸 상속받는게 좋음
	그리고 이벤트를 사용할때 반드시 서비스를 쿼리해야한다면,그냥 이벤트를 발행할때 필요한값들을 같이 넣어주는게 오버헤드가 적음
	단 컨슈머의 요건이 바뀌면 이벤트클래스도 바꿔야해서 안정성이 떨어지고 유지보수성이 낮아짐
	
	도메인이벤트는 여러방법으로 식별가능한데,보통 알림요건이 있으면 도메인이벤트가 필요하다는것
	요즘은 이벤트스토밍을 사용하는듯(딴책에 자세히나와잇으니까 그거보자)
	
	그리고 도메인이벤트는 비동기메시징형태를 취하지만 로직이 이벤트를 브로커에 발행하려면,먼저 이벤트를 생성해야함
	
	개념적으로 이벤트는 애그리거트가 발행함
	애그리거트는 자신의 상태변경시점과 그 결과 어떤 이벤트를 발행할지를 알고있음
	애그리거트가 메시징api를 직접호출할수도 있긴하지만,의존성주입을 할수없어서 api를 메서드인수로 전달해야하는 문제가 있어서,
	애그리거트와 호출하는 서비스의 책임을 분리함
	서비스는 의존성을 주입해서 메시징api를 가리키는 레퍼런스를 획득할수있어서 이벤트발행이 더 쉬움
	애그리거트는 상태전이시 이벤트를 생성하고,이 이벤트를 애그리거트 메서드반환값에 이벤트목록을 넣어서 반환하거나,
	애그리거트 루트의 특정필드에 이벤트를 쌓아두고,서비스가 이벤트를 가져다 발행할수도 있음
	
	도메인 이벤트를 확실하게 발행하는방법은,트랜잭셔널 메시징을 사용하면됨
	트랜잭션의 일부로 이벤트를 테이블에 삽입하고,전부삽입됐으면 커밋하는식
	
	
-6.이벤트 소싱	
1.이벤트소싱 응용비즈니스로직 개발
	이벤트 소싱은 상태를 사용하지않고,모든 이벤트에 로그를 저장해서,로그를 현재까지 진행시킨 값을 상태로 사용하는거임
	
	이벤트소싱의 장점은,이력이 보존돼서 감사/통제용도로 사용할수있고,도메인이벤트를 확실히 발행할수있음
	단점은 로직작성방법이 특이하고,이벤트저장소쿼리가 어려워서 cqrs를 적용해야함
	
	이벤트 소싱을 안쓰고 영속화를 할땐,애그리거트를 테이블에 매핑하고,하위클래스는 하위테이블에 매핑하고 인스턴스는 로우단위로 매핑하는식으로 저장함
	이거의 단점은
		객체-관계 임피던스 부정합
		애그리거트 이력이 없음
		감사로깅구현이 번거로움
		이벤트발행로직이 비즈니스로직에 추가됨
	임피던스부정합은,객체와 테이블간의 차이에 따른 부정합이고
	애그리거트 로그를 보고싶으면 따로 코드를 중복생성해야함
	감사로깅구현을 따로해야하고 버그가 날 확률이 높음(로직이 계속분화하니까)
	이벤트발행로직을 또 추가해야함
	
	이벤트소싱을 사용하면,이벤트를 이용해서 애그리거트를 이벤트테이블에 여러로우로 저장함
	즉 이벤트가 발생하면 로그를 저장하고,그 로그가 곧 상태임
	
	즉 애그리거트메서드의 관심사를 이벤트로 압축할수있고,커맨드메서드를 사용하면 반드시 이벤트를 발생시켜야함
	
	그리고 동시업데이트를 막기위해서,낙관적 잠금을 사용할수있음
	
	이벤트소싱은 애그리거트를 여러 이벤트로 저장하고,다시 이 이벤트를 가져와 현재 애그리거트의 상태를 구성함
	
	이벤트소싱은 일종의 확실한 이벤트발행장치로도 활용할수있음
	만약 이벤트소싱을 사용하지않고 트랜잭션을 쓰면서 이벤트를 추가로 발행한다고하면,트랜잭션 두개의 순서에 따라서 이벤트발행을 건너뛸수도있고
	원자적으로 db에 들어간다고 보장할수가 없음
	이런 문제를 해결하는 방법으론,이벤트테이블에 이벤트발행여부를 추적할수있는 컬럼을 추가하는것
	
	그리고 이벤트소싱을 사용할때,맨날 처음부터 끝까지 다읽으려면 힘드니까,중간중간마다 스냅샷을 만들어 사용할수있음
	
	그리고 이벤트소싱기반에선,메시지가 멱등하게 처리될수있게 처리해야함,쉬운방법으로는 같은메시지id가 있으면 중복으로 솎아내는것
	nosql기반이라면 메시지 처리결과 아무이벤트도 안생성되는것때문에(애그리거트가 업데이트되지않을경우),무한루프에 빠질수있음
	그래서 아무업데이트가 없어라도 가짜이벤트라도 발행을 해서,처리했을믈 알려야함
	
	이벤트소싱은 정확성을 담보로,유지보수성을 좀 갉아먹음
	앱은 잠재적으로 여러버전의 이벤트를 처리해야하는데,여기서 문제가 생길확률이 있음
	
	일반적으로 스키마,이벤트타입추가,새필드추가엔 열려있고,삭제,개명등엔 닫혀있음
	
	이벤트소싱의 장점은
		도메인이벤트의 확실한 발행
		애그리거트이력이 보존됨
		임피던스불일치문제를 대부분 해결가능
		타임머신기능(상태 전부저장하니까 원하는 어떤때든 그때로 돌아갈수있음)
	단점은
		배우는데시간이걸림
		메시징기반앱은 복잡함
		이벤트개량이 까다로움
		데이터삭제가 어려움
		이벤트저장소쿼리가 어려움
	
	데이터삭제는 개인정보같은걸 날려야할떄 필요한데,이건 암호화를통해 해결할수있음
	
2.이벤트저장소구현
	이벤트저장소는 db와 메시지브로커를 합친거임
	애그리거트의 이벤트를 기본키로 삽입/조회하는 api가 있어 db처럼 움직이면서,이벤트를 구독하는 api도 있어서 브로커처럼도 동작함
	
	기본적으론 db처럼 동작하고,거기에 계속 셀렉트하는 로직을 달아서 구독을 구현하는식임
	
	
3.사가와 이벤트소싱을 접목
	이벤트소싱에서 코레오그래피를 사용하는건 매우쉬움
	참여자가 자신의 애그리거트가 발생시킨 도메인이벤트를 교환하고,각 참여자의 애그리거트는 커맨드를 처리하고 새 이벤트를 발생시키는식으로 이벤트를 처리함
	
	단 오케스트레이션에 연계하는건 어려움
	이벤트 저장소의 트랜잭션개념이 제한적이기때문
	
	이벤트 저장소를 사용하는 앱은 애그리거트 하나만 생성/수정하고 결과이벤트를 발행하는데,사가에선 반드시 원자적으로 발행되어야하는
		사가 생성:사가시작했으면 원자적으로 애그리거트 생성/수정해야함
		사가오케스트레이션:원자적으로 응답을소비하고 상태업데이트후 커맨드전송해야함
		사가 참여자:원자적으로 메시지를 소비해야함
	때문에,rdbms의 acid에 의존할수밖에 없고,nosql을 사용하려면 좀 머리아파짐
	
	코레오그래피 이벤트소싱은 쉽지만 문제점이 하나 더 추가되는데,이벤트의 목적이 이원화됨
	이벤트가 상태변화때문에 사용되는것 말고도,상태변화가 없어도 무조건 이벤트를 발생시켜야하고 가장 큰 문제는 참여자가 애그리거트를 생성할수없는경우임
	그래서 오케스트레이션을 쓰는게 좋음
	
	오케스트레이션으로 할경우,rdbms를 사용하면 저장소를 업데이트하고 오케스트레이터를 생성하는걸 한 트랜잭션으로 묶을수있어서 쉬움
	nosql을 사용하면,이벤트의 유일한 속성으로 사가id를 추출하던가,이벤트id를 사가id로 사용하는식으로 중복을 막아야함
	
	이벤트소싱기반의 사가참여자는
		커맨드메시지를 멱등하게 처리
		응답메시지를 원자적전송
	이라는 이슈를 해결해야함
	멱등처리는 이벤트에 메시지id를 기록해서 이전에 이걸 처리한적있는지 확인하면되고,
	메시지 원자적전송은 메시지id를 멱등성키로 사용하고,가짜이벤트를 확인하고 그건 무시하는식으로 처리해야함
	
	사가오케스트레이터도 이벤트소싱으로 구현할수있음
	사가 오케스트레이터는 생성된다음부터는 사가참여자의 응답에 반응하며 계속 업데이트됨
	그래서 사가는 생성과 수정이벤트만 발생하면됨
	
	그리고 사가상태를 원자적으로 업데이트하고 커맨드를 전송하는건,전송할커맨드를나타낸 이벤트를 저장하는것
	이 이벤트를 구독한애들이 가져가서 알아서 작업하고 다시 오케스트레이터에 메시지를 날림
	
	그리고 얘도 중복메시지감지를 해서 중복일경우 솎아내기를 해야함
	
	
	
-7.마이크로서비스 쿼리 구현
1.api조합	
	api조합은 조합기가 필요한 서비스들을 한번에 쿼리해서 데이터를 모으고,모은데이터를 조인해서 리턴하는 방식임
	이걸할땐 restapi같은 api로 통신해서 받으면됨
	
	이때 조합기는,
		서비스클라를 조합기로(단,클라가 방화벽외부에있고 서비스네트워크가 느리면 비추천)
		앱의 외부api가 구현된 api게이트웨이를 조합기로
		api조합기를 스탠드얼론 서비스로 구현(가장많이쓰는듯)
	3가지방법이있음
	
	api조합의 장점은,쉽다는거고 단점은
		오버헤드증가
		가용성저하우려(많은서비스에 접근하기때문에)
		일관성결여(병렬적으로 접근하기때문에)
	가 있음
	단,cqrs도 만만찮게 단점이 있기때문에,가능하면 이거쓰는게 좋긴한듯
	
	
2.cqrs패턴
	일반적으로 앤터프라이즈앱은 대부분 rdbms에 트랜잭션을 걸어서 레코드를 관리하고,쿼리는 일래스틱서치같은걸 사용함
	아예 rdbms가 업데이트될때마다 복사해서 쿼리용db에 넣는식으로 동기화해서 사용하기도함
	이런 아키텍쳐로 구축하는이유는,트랜잭션과 텍스트검색db의 쿼리능력을 모두 사용하기위해서임
	
	cqrs는 이런종류의 아키텍쳐를 일반화한것
	즉 하나이상의 쿼리가 구현된 하나이상의 뷰db를 유지하는 기법
	
	api조합에서 사용이 힘든 쿼리일경우엔 cqrs를 사용해야하는데,대표적으로
		다건주문목록을 반환해야하는데 필터/정렬용도 속성이 없을경우,인메모리조인을 하거나,동기식으로 조회하거나,dbapi로 벌크조회해야함(지원안하는경우도있음)
		단일쿼리인데 효율적인쿼리가 불가능하거나(지리인덱스가 걸리지않는 nosql같은경우)
	
	그리고 단일서비스쿼리에서,데이터를 가진 서비스에 쿼리를 구현하면 안될때도 있고,이럴경우엔 api조합이 힘들어짐(관심사분리가 힘듬)
	
	
	cqrs는 커맨드와 쿼리를 서로 분리해서,관심사를 분리/구분함
	이 패턴을 따르면,영속적데이터모델과 그걸 사용하는모듈을 커맨드와 쿼리로 나누고
	crud중 r을 빼고 crd와 r모델로 나눈다음,r이 crd를 구독하는식으로 구성되게됨
	
	crd는 데이터가 바뀔때마다 도메인이벤트를 발행함
	
	cqrs는 서비스내부에 적용할수있을뿐아니라 이 패턴을 이용해서 쿼리서비스를 정의할수도있음
	쿼리서비스엔 커맨드작업이 전혀없는 쿼리작업만으로 구성된 api가 하나있고,
	하나이상의 다른서비스가 발행한 이벤트를 구독해서 최신상태로 유지하는로직이 구현되어있음
	
	쿼리쪽에서 여러 서비스가 발행한 이벤트를 구독해서,구축된뷰를 만들기좋고,이런 뷰는 특정서비스에 종속되지않아서 스탠드얼론으로 구현하는게 타당함
	
	cqrs의 장점은
		msa에서 쿼리를 효율적으로 구현할수있음(인메모리조인할필요가 없어짐(미리조인해둘수있음))
		다양한쿼리를 효율적으로 구현할수있음(nosql에서도 가능해짐)
		이벤트소싱에서도 쿼리가 가능해짐(이벤트소싱은 예외없이 cqrs써야함)
		관심사가 더 분리됨
	단점은
		아키텍쳐가 더 복잡해짐
		복제시차를 처리해야함(커맨드->쿼리시점에서 시차가 생기고,이걸 해결해야함)
	
	일반적으로 api조합으로 가능하면 그걸쓰고,안될거같으면 cqrs쓰는듯
	
	
	
3.cqrs뷰 설계
	cqrs뷰모듈은 하나이상의 쿼리작업으로 구성된 api가 있음
	하나이상의 서비스가 발행한 이벤트를 구독해서,최신상태로 유지된 db를 조회하는 쿼리api임
	뷰모듈은 뷰db와 이벤트핸들러,쿼리api,데이터접근모듈로 구성됨
	
	뷰모듈에서 중요한 설계결정은
		db선정과 스키마설계
		데이터접근모듈을 설계할때 멱등성/동시업데이트등 다양한문제를 고려해야함
		기존앱에 새 뷰를 구현하거나,기존스키마를 바꿀경우 뷰를 효율적으로 재빌드할수있어야함
		뷰클라에서 복제시차를 어떻게 처리할지 결정해야함
		
	db는 nosql과 rdbms가 있고,nosql과 cqrs는 잘 맞는편임
	근데 사실 최신거는 별차이없어서,자유로운 스키마가 필요한거아니면 아무거나써도될듯,그리고 지리정보가 들어가면 mysql같은게 좋음
	
	그리고 외래키를 이용한 수정/삭제에서 1대다관계일경우,기본키를 만들어줘야함
	
	그리고 이벤트핸들러와 쿼리api는 직접 db에 접근하지않고,dao나 헬퍼클래스로 이루어진 데이터접근모듈을 사용함
	그리고 dao가 여러이벤트핸들러에게 요청을받아,같은로우를 여러번 업데이트되지않게,낙관적/비관적 잠금같은게 추가되어야함
	이건 한 애그리거트만 구독할땐 상관없는데,여러종류의 애그리거트를 구독할때 발생할수있음
	이건 멱등한 이벤트핸들러나,비멱등한경우엔 처리한이벤트id를 기록해뒀다가 솎아내야함
	
	그리고 cqrs를 적용하면,커맨드를 업데이트한 직후 쿼리를 실행하는 클라이언트가 자신이 업데이트한 내용을 못찾을수도 있음(지연시간)
	그래서,자신이 마지막으로 한값을 들고있다가 없으면 다시셀렉트하는식으로 일관되게할수도있음
	
	cqrs뷰를 추가하거나 업데이트할떈,아카이빙된 이벤트를 이용해서 뷰를 구축하던가,스냅샷을 쓰던가 두 방법이 있음
	
	
	
	
-8.외부api패턴	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	