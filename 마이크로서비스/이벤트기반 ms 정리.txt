1.왜 이벤트기반 마이크로서비스인가
	이벤트기반ms는 시스템이 이벤트를 생산/소비하는식으로 서로 통신함
	이벤트를 소비해도 바로사라지진않고,같은 메세지를 필요로하는 다른 소비자들도 가져갈수있게 보존됨
	이거로인해 여러 패턴들이가능해짐
	
	서비스자체는 개발기간이 2주안에 끝나게,개념적으론 머리속에 한번에 들어갈정도
	서비스는 입력이벤트스트림에서 이벤트를 받아서,
	특정 비즈니스로직을 적용하고 출력이벤트를 내보내서 요청응답접근에 필요한데이터를 제공,혹은 서드파티api와 통신함
	
	서비스는 스테이트풀과 스테이트리스로 분류됨
	
	도메인주도 설계와 경계콘텍스트는
	하위도메인에 경계선을 최대한 비슷하게 잘라서,내부에서만 동작하고 외부로 영향을 주는걸 막는걸 말함
	경계콘텍스트는 비즈니스요건 중심으로 만들어져야함,그래야 변경사항이 있을때 변경점이 내부에만 영향을주고,
	한팀만 특정 ms를 소유해서,책임이 분산되지않음
	즉,비슷한 코드가 있어도 그냥 중복을 감수하고 서비스마다 따로 만듬(그냥복사해서 넣어도됨,서로 영향만안주면되니까)
	
	서비스의 통신은,실제 비즈니스통신과 어쩔수없이 비슷하게 나가게됨
	ms전까진,실제로 전화해서 정보전달하는거와,진짜 데이터를 넣는것과는 별개로(두개를 동시에)처리했음
	기본적으로 모놀리스식으로,db에서 정보를 다 받고,거기서 계속 받아가는식으로 처리하는경우가 많았음
	이거의 문제는,모든 서비스들이 하나의 db를 직접 접근하니까 db에 변경점이 있으면 모든 서비스들이 영향을 받게됨
	즉,접근은 쉬운데 변경은 어려움
	
	그래서 나온 패턴이 db에 어댑터붙이는패턴임
	db와 관련된 통신은 전부 한 서비스에서 맡고,그 서비스에 접촉해서 자기가 받을 데이터를 받는것
	이러면 올바른 통신을 할 책임은,db서비스에만 있고 다른서비스들은 처음에 했던인터페이스대로 그냥 받기만하면됨
	이게 이벤트 기반 통신임
	
	모든 데이터는 하나의 db안에 있는,단일 진실 공급원이고,각 이벤트는 사실진술서임
	즉 받은이벤트는 어디서 받아도 똑같은시간에 넣었으면 똑같이나옴
	
	그리고 소비자가 스스로 모델링과 쿼리를 수행함(자기가 필요한 인터페이스 만들어서 줘야함)
	이렇게되면 직접적으로 db접근하는건 서비스하나밖에 없고,다른데서도 동시에 필요한 이벤트는 공용이벤트로 발행해서
	데이터의 생산과 소유를 완전히 분리할수있음
		
	이벤트기반ms의 장점은
		세분성:서비스가 경계콘텍스트에 맞게 매핑되고,비즈니스요건이 바뀌어도 쉽게 재작성가능
		확장성:필요시 규모를 늘리거나 줄일수있음
		기술유연성:서비스마다 다른언어써도됨
		비즈니스요건유연성:소유권을 쉽게 넘겨줄수있음(인수인계에 들어가는게작음)
		느슨한결합:외부에 영향을 받지않음
		cd지원:쉽게 업데이트할수있음(외부에 영향을 안주고 안받아서)
		우수한시험성:테스트하기가 쉬움(의존성이 낮아서)
	
	그리고 또 중요한건,여기서의 통신은 비동기식이라는것
	동기식으로도 ms를 구현할수 있긴한데
	단점은 대규모환경에선 문제가 많음
		점대점결합이라 자신이 할일을 다른서비스에 의존해서 할수밖에 없고,이러면 어느 서비스가 어떤 비즈니스로직을 담당하는지 파악이 매우 어려워짐
		그리고 한 서비스의 확장 여부는 다른 서비스가 확장가능한지에 따라 달렸음
		서비스실패할때 처리하는거 생각하기가 힘듬,여러개가꼬리물려있어서
		api버저닝하기힘듬
		데이터접근이 구현체에 종속됨
	장점은 
		사용자인증,a/b테스트같은 데이터접근패턴은 이게더 쉽긴하고
		로그로 추적하기도 쉬움 
		그리고 사람들이 많이써봐서 접근이쉬움
	
	
	
2.이벤트기반 마이크로서비스 기초	
	이벤트기반 ms는 경계콘텍스트를 구현하기 위해 개발된 작은 앱임
	소비자ms는 하나이상의 입력이벤트스트림으로부터 이벤트를 소비하고
	프로듀서ms는 다른 서비스가 소비할수있게 이벤트스트림에 이벤트를 생산함
	
	일반적으로는 ms들은 소비자인 동시에 다른 출력중 하나의 프로듀서 역할을 함
	서비스는 스테이트리스와 스테이트풀이 있고,api가 포함된 서비스도 있음
	
	토폴로지는 ms토폴로지와 비즈니스 토폴로지가 있음
	
	ms토폴로지는 마이크로서비스 내부의 이벤트기반 토폴로지임
	변환,저장,방출등 이벤트에 수행할 데이터주도연산을 정의함(데이터의 저장,가공등을 알아보기쉽게 그린거)
	
	비즈니스 토폴로지는 비즈니스 로직을 처리하는 ms,이벤트스트림,api의 집합임
	이건 서비스를 임의로 그룹핑한거로 하나의 팀이 소유한 서비스나,복잡한 비즈니스기능의 상위집합을 수행하는 서비스를 나타냄
	마이크로서비스는 비즈니스 경계콘텍스트를 구현하고,이벤트스트림은 전체콘텍스트의 도메인데이터를 공유하기위해 필요한 통신수단
	
	그리고 이벤트는 뭐든지 이벤트가 될수있고(신입사원채용이나 뭐 커피마신횟수같은거도 됨),이걸 잘 쌓아두면 나중에 잘 활용할수있음
	
	이벤트는 키/값포맷으로 표현됨 보통
	이벤트의 세부정보는 값에,키는 식별,라우팅,집계에 사용하고,키는 필수는 아님
	
	키없는 이벤트는 로그처럼 키가 없이 단순 값의 나열임
	엔티티이벤트는 특정 엔티티가 수행한 일을 로그식으로 나열한것,특정엔티티만 뽑아서 어떻게 행동했냐를 알수있고,현재상태를 로그만가지고 알수있어서 제일중요
	키있는 이벤트는,키없는 이벤트에서 검색하기편하게 키를 넣어둔거
	
	엔티티이벤트에서 특정 엔티티의 행동들을 모아둔테이블(이벤트소싱 맞음)로 현재 엔티티의 상태를 알수있음
	같은방법으로 각 엔티티별로 행동횟수도 알수있고,이런 커맨드는 mysql의 바이너리로그나 외부이벤트스트림처럼 불변로그에 대한 이벤트로 생산할수있음
	
	키있는 이벤트는 값이 null인 키있는 이벤트(툼스톤이라고부름)를 만들어 삭제함
	이는 업스트림 프로듀서가 어떤 키를 가진 이벤트가 삭제대상이라고 알리는 관례임
	그리고 상태를 계속 나열하다보면 무한정 커지니,컴팩션을 해야함,이건 스냅샷으로 특정지점까지의 결과값을 계산해서,그걸 초기값으로 쓰는것
	만약 툼스톤이 박혀있으면 그건 삭제하는식으로 관리함
	
	그리고 이벤트데이터는 서비스간 통신수단을 비롯해서 구현체와 무관한 장기데이터 보관소역할을 하기때문에,
	프로듀서와 소비자가 데이터의 의미를 똑같이 이해하는게 중요함
	이걸위해서 아파치 아브로나 구글 프로토콜버퍼같은 스키마화 기술을 사용하면 쉽게 사용할수있음(스키마변경등이 자유로워짐)
	
	그리고 마이크로서비스는 단일소유니까,어떤 이벤트라도 데이터를 역순으로 보면 그 이벤트를 누가시작했나를 알수있음
	
	이벤트브로커는 프로덕션에서 바로 서비스가능한 이벤트 기반 마이크로서비스플랫폼의 핵심임
	얘는 이벤트를 받아서 큐나 스트림에 저장하고 이걸 다른 프로세스가 소비할수있게 제공함
	이벤트는 보통 여러 스트림으로 나뉘어(발행하는 논리적의미에따라) 발행하는데,이건 db에서 테이블을 여러개두는거와 비슷함
	
	이벤트 브로커는
		확장성:인스턴스를 추가하면 클러스터의 생산/소비및 데이터 스토리지를 늘릴수있어야함
		보존성:노드간에 이벤트데이터가 복제되므로 한 브로커에 장애가 발생해도 데이터는 보존되어야하고 서비스도 계속할수있어야함
		고가용성:클러스터링을 했을때,한군데가뻗어도 다른데로 접속할수있어서 가용성이 유지되어야함
		고성능:여러 브로커노드가 부하를 분담할수있어야함
	를 만족해야함
	브로커가 사용할 데이터스토리지의 최소요건은
		파티셔닝:스트림을 개별하위스트림으로 나눌수있어야함(테이블안에서 하위테이블로 나눌수있어야함)
		순서보장:순서를 보장해야 이벤트소싱이 가능해짐
		불변성:한번발행되면 바뀌거나 수정할수없어야함,수정하고싶을떈 새값을 추가해야함
		인덱싱:특정 엔티티의 마지막위치확인이 가능해야함
		무기한보존:이벤트를 무기한으로 보존할수있어야함
		재연성:어떤 소비자라도 필요한 데이터를 골라서 읽을수있어야함
		
	이거외에도 지원도구나,호스티드솔루션(외부도구)이 존재하는지등도 고려사항
	
	이벤트브로커와 메시지 브로커의 차이는,메시지브로커는 소비하면 삭제되고,이벤트브로커는 소비해도 계속 쌓임
	그리고 메시지브로커는 소비하면 삭제되니까,여러소비자가 동시에사용할수없는데,이벤트브로커는 안사라지니까 동시에사용할수있고
	메시지는 사라지니까 재현성이없음
	
	일반적으로 이벤트브로커는 붙임전용불변로그를 사용함,이벤트는 끝부분에 추가되고 자동증가인덱스id가 부여되는식
	이 인덱스id로 접근해서 소비하는것
	
	이벤트스트림으로 소비할떈,각 소비자는 자기가 마지막에 읽은 위치를 인덱스로 가지고있고,그걸써서 독립적으로 데이터를 소비하면서 진행사항을 추적할수있음
	큐로 소비할떈,각 이벤트는 오직 하나의 서비스만 소비할수있고,소비했으면 소비됨표시를 붙여서 다른인스턴스에 제공하지않음
	큐로 받은 이벤트는 순서가 보장되지않음(실패하면 나중에 처리하려고 반환할수있기때문)
	
	이벤트브로커가 단일진실공급원이 되려면,각 팀에선 sql을 쓸수없고,데이터를 받으려면 반드시 이벤트브로커로 발행해야함
	
	그리고 대규모 마이크로서비스를 관리할땐,마이크로서비스를 컨테이너에 넣어서 오케스트레이션하는게 좋음
	가상머신도 보안적인측면에선 좋지만,여러모로 코스트가비싸서 안쓰는듯
	
	
	
3.통신및 데이터규약
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	