1.왜 이벤트기반 마이크로서비스인가
	이벤트기반ms는 시스템이 이벤트를 생산/소비하는식으로 서로 통신함
	이벤트를 소비해도 바로사라지진않고,같은 메세지를 필요로하는 다른 소비자들도 가져갈수있게 보존됨
	이거로인해 여러 패턴들이가능해짐
	
	서비스자체는 개발기간이 2주안에 끝나게,개념적으론 머리속에 한번에 들어갈정도
	서비스는 입력이벤트스트림에서 이벤트를 받아서,
	특정 비즈니스로직을 적용하고 출력이벤트를 내보내서 요청응답접근에 필요한데이터를 제공,혹은 서드파티api와 통신함
	
	서비스는 스테이트풀과 스테이트리스로 분류됨
	
	도메인주도 설계와 경계콘텍스트는
	하위도메인에 경계선을 최대한 비슷하게 잘라서,내부에서만 동작하고 외부로 영향을 주는걸 막는걸 말함
	경계콘텍스트는 비즈니스요건 중심으로 만들어져야함,그래야 변경사항이 있을때 변경점이 내부에만 영향을주고,
	한팀만 특정 ms를 소유해서,책임이 분산되지않음
	즉,비슷한 코드가 있어도 그냥 중복을 감수하고 서비스마다 따로 만듬(그냥복사해서 넣어도됨,서로 영향만안주면되니까)
	
	서비스의 통신은,실제 비즈니스통신과 어쩔수없이 비슷하게 나가게됨
	ms전까진,실제로 전화해서 정보전달하는거와,진짜 데이터를 넣는것과는 별개로(두개를 동시에)처리했음
	기본적으로 모놀리스식으로,db에서 정보를 다 받고,거기서 계속 받아가는식으로 처리하는경우가 많았음
	이거의 문제는,모든 서비스들이 하나의 db를 직접 접근하니까 db에 변경점이 있으면 모든 서비스들이 영향을 받게됨
	즉,접근은 쉬운데 변경은 어려움
	
	그래서 나온 패턴이 db에 어댑터붙이는패턴임
	db와 관련된 통신은 전부 한 서비스에서 맡고,그 서비스에 접촉해서 자기가 받을 데이터를 받는것
	이러면 올바른 통신을 할 책임은,db서비스에만 있고 다른서비스들은 처음에 했던인터페이스대로 그냥 받기만하면됨
	이게 이벤트 기반 통신임
	
	모든 데이터는 하나의 db안에 있는,단일 진실 공급원이고,각 이벤트는 사실진술서임
	즉 받은이벤트는 어디서 받아도 똑같은시간에 넣었으면 똑같이나옴
	
	그리고 소비자가 스스로 모델링과 쿼리를 수행함(자기가 필요한 인터페이스 만들어서 줘야함)
	이렇게되면 직접적으로 db접근하는건 서비스하나밖에 없고,다른데서도 동시에 필요한 이벤트는 공용이벤트로 발행해서
	데이터의 생산과 소유를 완전히 분리할수있음
		
	이벤트기반ms의 장점은
		세분성:서비스가 경계콘텍스트에 맞게 매핑되고,비즈니스요건이 바뀌어도 쉽게 재작성가능
		확장성:필요시 규모를 늘리거나 줄일수있음
		기술유연성:서비스마다 다른언어써도됨
		비즈니스요건유연성:소유권을 쉽게 넘겨줄수있음(인수인계에 들어가는게작음)
		느슨한결합:외부에 영향을 받지않음
		cd지원:쉽게 업데이트할수있음(외부에 영향을 안주고 안받아서)
		우수한시험성:테스트하기가 쉬움(의존성이 낮아서)
	
	그리고 또 중요한건,여기서의 통신은 비동기식이라는것
	동기식으로도 ms를 구현할수 있긴한데
	단점은 대규모환경에선 문제가 많음
		점대점결합이라 자신이 할일을 다른서비스에 의존해서 할수밖에 없고,이러면 어느 서비스가 어떤 비즈니스로직을 담당하는지 파악이 매우 어려워짐
		그리고 한 서비스의 확장 여부는 다른 서비스가 확장가능한지에 따라 달렸음
		서비스실패할때 처리하는거 생각하기가 힘듬,여러개가꼬리물려있어서
		api버저닝하기힘듬
		데이터접근이 구현체에 종속됨
	장점은 
		사용자인증,a/b테스트같은 데이터접근패턴은 이게더 쉽긴하고
		로그로 추적하기도 쉬움 
		그리고 사람들이 많이써봐서 접근이쉬움
	
	
	
2.이벤트기반 마이크로서비스 기초	
	이벤트기반 ms는 경계콘텍스트를 구현하기 위해 개발된 작은 앱임
	소비자ms는 하나이상의 입력이벤트스트림으로부터 이벤트를 소비하고
	프로듀서ms는 다른 서비스가 소비할수있게 이벤트스트림에 이벤트를 생산함
	
	일반적으로는 ms들은 소비자인 동시에 다른 출력중 하나의 프로듀서 역할을 함
	서비스는 스테이트리스와 스테이트풀이 있고,api가 포함된 서비스도 있음
	
	토폴로지는 ms토폴로지와 비즈니스 토폴로지가 있음
	
	ms토폴로지는 마이크로서비스 내부의 이벤트기반 토폴로지임
	변환,저장,방출등 이벤트에 수행할 데이터주도연산을 정의함(데이터의 저장,가공등을 알아보기쉽게 그린거)
	
	비즈니스 토폴로지는 비즈니스 로직을 처리하는 ms,이벤트스트림,api의 집합임
	이건 서비스를 임의로 그룹핑한거로 하나의 팀이 소유한 서비스나,복잡한 비즈니스기능의 상위집합을 수행하는 서비스를 나타냄
	마이크로서비스는 비즈니스 경계콘텍스트를 구현하고,이벤트스트림은 전체콘텍스트의 도메인데이터를 공유하기위해 필요한 통신수단
	
	그리고 이벤트는 뭐든지 이벤트가 될수있고(신입사원채용이나 뭐 커피마신횟수같은거도 됨),이걸 잘 쌓아두면 나중에 잘 활용할수있음
	
	이벤트는 키/값포맷으로 표현됨 보통
	이벤트의 세부정보는 값에,키는 식별,라우팅,집계에 사용하고,키는 필수는 아님
	
	키없는 이벤트는 로그처럼 키가 없이 단순 값의 나열임
	엔티티이벤트는 특정 엔티티가 수행한 일을 로그식으로 나열한것,특정엔티티만 뽑아서 어떻게 행동했냐를 알수있고,현재상태를 로그만가지고 알수있어서 제일중요
	키있는 이벤트는,키없는 이벤트에서 검색하기편하게 키를 넣어둔거
	
	엔티티이벤트에서 특정 엔티티의 행동들을 모아둔테이블(이벤트소싱 맞음)로 현재 엔티티의 상태를 알수있음
	같은방법으로 각 엔티티별로 행동횟수도 알수있고,이런 커맨드는 mysql의 바이너리로그나 외부이벤트스트림처럼 불변로그에 대한 이벤트로 생산할수있음
	
	키있는 이벤트는 값이 null인 키있는 이벤트(툼스톤이라고부름)를 만들어 삭제함
	이는 업스트림 프로듀서가 어떤 키를 가진 이벤트가 삭제대상이라고 알리는 관례임
	그리고 상태를 계속 나열하다보면 무한정 커지니,컴팩션을 해야함,이건 스냅샷으로 특정지점까지의 결과값을 계산해서,그걸 초기값으로 쓰는것
	만약 툼스톤이 박혀있으면 그건 삭제하는식으로 관리함
	
	그리고 이벤트데이터는 서비스간 통신수단을 비롯해서 구현체와 무관한 장기데이터 보관소역할을 하기때문에,
	프로듀서와 소비자가 데이터의 의미를 똑같이 이해하는게 중요함
	이걸위해서 아파치 아브로나 구글 프로토콜버퍼같은 스키마화 기술을 사용하면 쉽게 사용할수있음(스키마변경등이 자유로워짐)
	
	그리고 마이크로서비스는 단일소유니까,어떤 이벤트라도 데이터를 역순으로 보면 그 이벤트를 누가시작했나를 알수있음
	
	이벤트브로커는 프로덕션에서 바로 서비스가능한 이벤트 기반 마이크로서비스플랫폼의 핵심임
	얘는 이벤트를 받아서 큐나 스트림에 저장하고 이걸 다른 프로세스가 소비할수있게 제공함
	이벤트는 보통 여러 스트림으로 나뉘어(발행하는 논리적의미에따라) 발행하는데,이건 db에서 테이블을 여러개두는거와 비슷함
	
	이벤트 브로커는
		확장성:인스턴스를 추가하면 클러스터의 생산/소비및 데이터 스토리지를 늘릴수있어야함
		보존성:노드간에 이벤트데이터가 복제되므로 한 브로커에 장애가 발생해도 데이터는 보존되어야하고 서비스도 계속할수있어야함
		고가용성:클러스터링을 했을때,한군데가뻗어도 다른데로 접속할수있어서 가용성이 유지되어야함
		고성능:여러 브로커노드가 부하를 분담할수있어야함
	를 만족해야함
	브로커가 사용할 데이터스토리지의 최소요건은
		파티셔닝:스트림을 개별하위스트림으로 나눌수있어야함(테이블안에서 하위테이블로 나눌수있어야함)
		순서보장:순서를 보장해야 이벤트소싱이 가능해짐
		불변성:한번발행되면 바뀌거나 수정할수없어야함,수정하고싶을떈 새값을 추가해야함
		인덱싱:특정 엔티티의 마지막위치확인이 가능해야함
		무기한보존:이벤트를 무기한으로 보존할수있어야함
		재연성:어떤 소비자라도 필요한 데이터를 골라서 읽을수있어야함
		
	이거외에도 지원도구나,호스티드솔루션(외부도구)이 존재하는지등도 고려사항
	
	이벤트브로커와 메시지 브로커의 차이는,메시지브로커는 소비하면 삭제되고,이벤트브로커는 소비해도 계속 쌓임
	그리고 메시지브로커는 소비하면 삭제되니까,여러소비자가 동시에사용할수없는데,이벤트브로커는 안사라지니까 동시에사용할수있고
	메시지는 사라지니까 재현성이없음
	
	일반적으로 이벤트브로커는 붙임전용불변로그를 사용함,이벤트는 끝부분에 추가되고 자동증가인덱스id가 부여되는식
	이 인덱스id로 접근해서 소비하는것
	
	이벤트스트림으로 소비할떈,각 소비자는 자기가 마지막에 읽은 위치를 인덱스로 가지고있고,그걸써서 독립적으로 데이터를 소비하면서 진행사항을 추적할수있음
	큐로 소비할떈,각 이벤트는 오직 하나의 서비스만 소비할수있고,소비했으면 소비됨표시를 붙여서 다른인스턴스에 제공하지않음
	큐로 받은 이벤트는 순서가 보장되지않음(실패하면 나중에 처리하려고 반환할수있기때문)
	
	이벤트브로커가 단일진실공급원이 되려면,각 팀에선 sql을 쓸수없고,데이터를 받으려면 반드시 이벤트브로커로 발행해야함
	
	그리고 대규모 마이크로서비스를 관리할땐,마이크로서비스를 컨테이너에 넣어서 오케스트레이션하는게 좋음
	가상머신도 보안적인측면에선 좋지만,여러모로 코스트가비싸서 안쓰는듯
	
	
	
3.통신및 데이터규약
	통신에서 제일 어려운건,프로듀서가 생산한 메시지의 컨텐츠와 의미를,소비자가 정확히 되살리도록 보장하는것
	그래서 둘은 똑같이 이해하고있어야하고,만약 아니면 개판이남
	이벤트기반시스템에서 이벤트는 무슨일이 일어났고,그 이유는 무엇인지 정확하게 기술하는 메시지이자,통신의 기본단위임
	이벤트는 사실진술서로서 시스템이 발행한 다른 이벤트와 조합해서,발생한 사건에 대한 완전한 이력이 되어야함
	
	1.이벤트기반 데이터 규약
		데이터 규약은,주고받을 데이터의 포맷과 생성로직을 정의함
		즉 프로듀서와 소비자가 모두 준수하는 계약(인터페이스)라고 보면됨
		이벤트 규약을 이용하면,이벤트가 생산되는 콘텍스트 이상의 의미를 부여할수있고,데이터사용성을 넓힐수있음
		
		데이터규약에는 데이터정의,즉 생산할것들(필드,타입등)과 트리거로직,즉 생산한이유(이벤트생성을 일으킨 트리거)이렇게 두개가 포함됨
		데이터 정의를 변경할땐,다운스트림에서 사용중인 필드를 삭제/변경하지않게 주의해야하고,
		트리거로직도 마찬가지로,트리거로직을 바꾸면 원래 이벤트정의에 담긴 의미가 깨지지않는지 확인해야해서 보통 데이터정의를 변경하는게 일반적임
		
		데이터규약을 강제하여 일관성을 유지하는 가장 좋은방법은,이벤트마다 스키마를 정의하는것
		프로듀서가 데이터정의와 트리거로직이 상술된 스키마를 명시적으로 정의하여,동일한 타입의 이벤트는 모두 해당포맷을 따르게함
		이렇게해서 모든 미래의 소비자에게 이벤트포맷을 전달하고,소비자는 스키마화 데이터를 받아 명확한 구현이 가능해짐
		
		소비자가 비즈니스처리를 할땐,필요한 데이터를 추출부터 해야함,근데 어떤 데이터가 필요할지 미리 스펙을 정해두지않으면 조정비용이 늘어나고
		감당이 힘들어지고,생산자와 소비자의 해석이 다를수있어서 리스크를 가지고가게됨
		그리고 프로듀서입장에서도,뭘 바꿀때 바꾸면 무슨일이 일어날지 모르니,바꾸는게 무서워지게됨
		그래서 명시적으로 나타나는게 중요한거
		
		스키마 정의에서 주석과 메타데이터는,이벤트의미를 제대로 전달하기위해 꼭 필요함
		이때 이벤트생산/소비에 관한 지식은,가능한 이벤트정의와 가깝게 붙어있는게 좋음
		주석은 
			이벤트의 트리거논리를 명시:이벤트가 생성된이유를 명확히 밝힘
			구조화한 스키마의 특정필드(날짜같은)에 콘텍스트를 부여해서 밝힘:시간의 포맷이 utc같은걸쓸지를 명확히명시
		할때 주로쓰임
		
		그리고 스키마포맷은 반드시 스키마 진화규칙의 전체범위를 지원해야함
		스키마진화를 잘 활용하면,소비자는 중단없이 이벤트를 계속 소비하면서 프로듀서가 출력포맷을 업데이트할수있음
		
		업무가 변경되면 보통 새필드를 추가하거나,옛필드를 사용하지않음으로 표시하거나,필드범위를 확장하는등의 작업이 필요함
		스키마 정의 프레임워크를 사용하면,이런변경사항을 안전하게 적용해서,소비자생산자 독립적으로 업데이트할수있게 보장함
		
		스키마진화없이는 업데이트비용이 너무 비싸짐
		스키마진화의 규칙은
			정방향호환성:새스키마로생성한걸 옛스키마로생성한거처럼 읽을수있음,즉 원래있던필드는 그대로읽을수있어서 새로추가된거 안가져다쓸거면 그대로쓰면됨
			역방향호환성:옛스키마데이터를 새스키마처럼 읽을수있음,즉 새스키마를 읽을걸로 원래데이터도 읽을수있음
			양방향호환성:정방향,역방향 둘다,즉 어떻게해도 읽어짐
		3개가 있음
		
		코드생성기는 이벤트스키마를 클래스정의처럼 그런형태로 변환시켜줌
		얘는 클래스정의를 이용해서 스키마의 데이터타입을 준수하는 이벤트 객체를 만들고,모든 널금지필드를 채워넣어서 이걸 변환시켜서 이벤트브로커에 전달함
		이걸 사용해서 컨슈머는 스키마버전을 직접 관리하고,그래서 프로듀서와 대부분 버전이 동일하지만 용도에따라 낮거나 높을수도있음
		양방향호환성일경우 양쪽다 읽을수있기때문
		
		소비자는 이벤트를 읽어서 그안에 인코딩된 스키마버전으로 이벤트를 역직렬화함
		이벤트포멧을 메시지안에 넣을수도있긴한데 규모가 커지면 비용이 많이드니,레지스트리에 보관하는식으로 함
		원래포맷으로 역직렬화한 이벤트는,소비자에서 지원되는 버전의 스키마로 바꿈(누락된필드는 기본값,미사용필드는 제거)
		이걸 사용하면,원하는 언어에 맞게 앱을 작성할수있는 큰 장점을 가지고있음
	
		
		그리고  스키마가 진화하는 흐름을 깰수밖에없는 비즈니스요건의 큰변화나,잘못된 설계들으로 인한 스키마변경이 있을경우,
		생산하는쪽은 별로 신경안써도되는데 소비자쪽은 많은 영향을 받으니 신중하게 살펴야함
		이런상황에서는 모든관련자가 다 알고있어야하고,모두다 준비된후에 바꿔야함
		이때 엔티티스키마의 데이터정의를 바꿀땐 두가지방법이 있음
			옛스키마와 새스키마를 함께두던지
			모든엔티티를 마이그레이션해서 새 스키마포맷으로 재생성하던지
		일반적으로 그냥같이두는게 편하긴하지만,이러면 나중에 부채가 너무커서 일반적으론 새스키마로 재생성하는쪽
		
		비엔티티이벤트는 그냥 새 이벤트스트림을 만들어서,새 이벤트를 이 스트림에 생산하게 하면됨
		가장 간단하겐,새 이벤트스트림을 만들어서 새이벤트를 여기서 생산하게하면됨(새테이블을 만들면된다는거)
		물론 소비자한테 여기서 받아가라고 알리긴해야함
		
	2.이벤트포맷선택
		이벤트데이터는 아브로,프로토콜버퍼처럼 엄격한 포맷을 사용하는게 좋음
		이런애들은 인코딩된 이벤트의 역직렬화와 직렬화를 지원함
		그래서 데이터저장으로 json을 사용하는건 권장되지않음(비구조텍스트도 동일)
	3.이벤트설계
		이벤트정의를 생성할때 하지 않아야할 안티패턴도 많음
		물론 완벽히 다 지켜야하는건아니지만(코스트따라서 어겨야할때도있음),어지간하면 지키는게 좋음
		
		잘 정의된 이벤트는 뭔가가 일어났음을 전하는게아닌,그이벤트가 발생한동안의 모든일을 빠짐없이 기술함
		즉, 입력데이터를 받아 나온 출력테이터를 전부 기술하고,이걸 가져다가 진실공급원으로 써야하고,
		이 이벤트에 대해 다른데서 뭐 찾을필요없이 이거하나로끝나야함
		
		스트림당 이벤트정의는 하나만 사용해야함,한 스트림에는 하나의 논리적 이벤트만 포함되어야함
		즉 한테이블에 여러 이벤트로 넣으면 안좋음
		
		가장 좁은범위의 데이터타입을사용,즉 문자열로 숫자넣고 그러면 직렬화같은거로 테스트하기가 힘들어짐
		
		이벤트는 하나의 목적만 가져야함,대표적으로 필드에 구분자를 추가해서 이벤트를 구분하려고하면,당시엔 쉬워도 나중에 엄청머리아파짐
		처음엔 비슷한거같지만 나중에 다른요구사항들어오면 머리아픔(영화대여시스템에 책대여시스템을 넣었는데,책갈피가 필요할경우 영화는 그냥 다null넣어야함)
		그냥 처음부터 다 분리하는게 편함 구분코드써야할거같으면
		특히 이벤트의 의미를 오버로드하는 타입필드는 절대사용하면안됨
		
		이벤트는 크기가 최소화되어야함,만약 몸집이 큰 이벤트일경우,데이터가 해당이벤트와 직접관련이 있는지 확인하고,
		마이크로서비스가 데이터에 직접 접근해야하는지 확인하고,너무 하는일이 많지않은지 확인해야함
		물론 뭐 이미지같은거 보내야하면 어쩔수없고
		
		미래의 소비자도 이벤트설계에 반영해야함,즉 소비자쪽팀과 협의해서 앞으로필요할기능같은걸 미리 들어둬서 일을 한번에끝내야함
		
		이벤트를 세마포나 시그널로 사용하면안됨,이벤트는 진실공급원이어야지,알림으로 사용하면안됨,
		두번이상의 접근이 필요해지면(진실공급원이 2개이상이면) 일관성에 문제가생김
		즉 알림으로 사용하는건괜찮은데,접근을 한번에 끝내야하니까 거기에 모든게 담겨있어야함
		
		
4.기존 시스템에 이벤트기반 아키텍쳐 통합
	기존 모놀리 아키텍쳐를 이벤트 기반 아키텍쳐로 바꾸는데는 데이터 해방 프로세스(데이터가 포함된 기존시스템및 상태저장소에서 데이터를 소싱하는것)이 필요함
	이렇게하면(데이터를 이벤트스트림에 생산하면)모든 시스템이 데이터에 접근할수있음
	
	1.데이터해방이란
		데이터해방은 교차도메인데이터셋을 식별해서,각 이벤트 스트림에 발행하는 마이그레이션의 일부임
		이떄 다른 외부시스템이 필요로하는 데이터 저장소에 저장된 모든 데이터역시 거기에 포함됨
		그래서 점대점디펜던시를 분석하면 해방시켜야할 데이터가 분명해짐
		
		기본적으로 데이터해방을 할땐,원래db를 그대로두고,데이터소싱어댑터를 붙여서 이벤트스트림에 넣고,이벤트스트림에서 시스템들이 가져가는식으로 설계하게됨
		이러면 이벤트스트림이 단일진실공급원이 되게되고,원래 db도 손그렇게 안대도됨
		
		이때 중요한건,데이터db와 이벤트스트림은 완전히 동기화되어야함,그리고 이벤트스트림은 반드시 복제한 소스테이블의 레플리카로 다시 구체화되어야하고,
		이런성질은 이벤트기반 ms에서 자주활용됨
		그리고 레거시시스템은 이 이벤트스트림에서 데이터셋을 재구성하지않음(다시 아무것도 읽어들이지않음)
		이게 제일 이상적이긴하지만,인력이 부족해서 이렇게까지 코스트 못붓겠다하면
		데이터해방으로 데이터저장소에서 데이터를 꺼내고,그데이터를 이벤트로 변환하고,새 앱만 거기에 접근하는것
		이때 가장 먼저 해방시킬데이터는 비즈니스전반에 걸쳐 연관성이 가장 많고 자주사용하는 데이터
		
	2.데이터 해방 패턴
		이때 데이터해방을 하는 패턴은 크게 3가지가 있음
		데이터해방하는건 결국 새로운 단일진실공급원을 만들겠다는것이니까,db에 있는 전체데이터셋을 담아야하고,계속 삽입수정삭제하면서 최신상태로 유지되어야함
		이떄 방법으론
			쿼리기반:쿼리를해서 데이터를 추출
			로그기반:로그로 데이터를 추출,일부db만 지원
			테이블기반:출력큐테이블에 데이터를 푸시하고 관련엔트리를 삭제
		세가지패턴 다 장단점이 있지만,공통적으로 소스레코드의 최근업데이트시간컬럼을 사용해서 이벤트를 타임스탬프대로 생산해야한다는것은 같음
		
		이때 데이터를 해방하는 가장쉬운 방법은,데이터를 이벤트스트림으로 추출하는 카프카커넥트,아파치고블린같은 프레임워크를 사용하는것
		물론 자기가 직접 만드는게 더 깔끔할수도있고,상황따라 그렇게해야할수도있음
		
	3.쿼리로 데이터해방
		쿼리기반으로 할땐,sql을 사용해서 벌크쿼리를 해서 전체 데이터를 로드하고,마지막 타임스탬프 이후거를 계속 로드해서 가져오는방식임(증분업데이트)
		이걸위해서 자동증가인덱스id가 필요함
		그리고 이렇게할땐,커스텀쿼리(함수로된쿼리,사용자가 직접 sql날리는걸 막음,룸에서 다오에서 query뺸거)로 제한해야함
		
		그리고 증분업데이트를 하려면,자동증가인덱스id를 설정하고,폴링빈도와 지연시간을 정하고,그 시간마다 쌓였던걸 다 푸시하고 인덱스를 다시 갱신함
		이때 너무 빠르면,앞쿼리가 로드중인데 계속 쿼리가 덮어씌워지는문제가 있을수있으니 적당히 길게잡아야함
		
		쿼리기반업데이트의 장점은
			맞춤성:모든db를 쿼리할수있고,클라이언트가 맘대로 쿼리옵션지정가능
			독립적인폴링주기:자기맘대로 폴링주기를 맞출수있음,일관성이 중요한건 최대한땡기고,나머지는 좀 풀어두는식으로 코스트조절가능
			내부데이터모델의 격리:뷰객체를 이용해서,내부데이터모델과 분리할수있음,즉 도메인모델정보를 숨길수있음
		단점은
			최종업데이트시간 타임스탬프가 필수
			하드삭제(delete쿼리날린거) 추적불가:소프트삭제(is_delete필드에 ox표시)만 추적가능
			데이터세트스키마와 출력이벤트스키마간의 취약한 의존관계:소비자이벤트포맷의 규칙과 호환되지않는방향으로 데이터셋스키마가 변경될가능성이 항상존재
			간헐적캡쳐:데이터가 일정주기마다 동기화되니까,같은레코드에대한 변경은 개별적인이벤트로만 보임
			생산리소스낭비:쿼리실행할땐 레거시시스템의 리소스를써야해서,생산시스템의 지연시간이 너무커질수있음
			데이터변경시 쿼리성능변화:계속 쿼리날려야하니까 그 변경규모에따라서 쿼리시간이 계속 왔다갔다함
		이 있음
	4.로그로 데이터해방
		이건 mysql같이 cdc로그를 뽑을수있으면,그걸활용해서 데이터해방을 할수있음
		모든 데이터세트에 발생한일의 로그를 뽑고,그걸기반으로 하는거임
		이때 테이블생성시부터 모든 로그를 뽑을순없기때문에(보통 주기적으로지우니까)현재상태를 스냅샷찍고,이 이후로부터 로그를 이용해 계속 갱신함
		이때 로그로부터 데이터소싱할땐 데베지움같은걸 쓰거나 할수있음
		
		로그의 장점은
			삭제추적이 가능:하드삭제도 상관없음
			db성능에 영향이 별로안감:로그만쓰니까
			저지연업데이트:이벤트가 로그에 적히면 바로 업데이트전파가능하니까 지연시간이 매우짧음
		단점은
			내부데이터모델 노출:로그쓰니까 완전노출됨
			저장소외부에서 반정규화:체인지로그에는 이벤트데이터만 있어서,db외부에서 반정규화가 일어나는데,
						    그래서 고도로 정규화한 이벤트스트림을 생산해야하게되면 소비자가 외래키조인과 반정규화를 처리해야함
			데이터세트 스키마와 출력이벤트 스키마간의 취약한 의존관계:db외부에서 데이터를 가져오기때문에,db스키마를 변경하는등의 일이생기는걸 막지못함
			
	5.아웃박스테이블로 데이터해방
		이건 cdc로그대상으로 지정한 데이터저장소에서 변경이 일어날때마다 해당 레코드를 아웃박스테이블에 발행하고,
		아웃박스소비자가 이벤트스트림에 기록하고 성공하면 아웃박스의 해당레코드를 삭제하는식
		각 로그대상마다 하나의 테이블을 두거나,모든걸 하나에 적을수있음
		
		내부테이블과 아웃박스테이블의 업데이트는 트랜잭션으로 묶어서,하나가 실패하면 다실패해야함,안그러면 단일진실공급원이 안되니까
		
		이패턴을 사용할땐 데이터저장소나 앱레이어중 하나는 직접 수정을 해야하는데,둘다 db개발자가 개입해야함
		아웃박스테이블에선 프라이머리키가 동일한 레코드가 짧은시간동안 여러번 업데이트될수있으므로,정렬식별자가 명확해야함
		이떄 주로 사용되는게 자동증가인덱스id,
		
		이패턴은 그 테이블이 위치한 db의 요청량이 2배가 된다는것이 단점임
		그리고 아웃박스테이블의 장점으론,아웃박스테이블을 내부테이블과 1대1로 맞출필요가 없고,아예 내부데이터모델과 달라도됨(좀더 단순화시켜도됨)
		여기서 내부데이터모델이 노출될일이 줄어듬
		그리고 스키마호환성도 보장할수있음,테이블에 이벤트가 기록되기 전후에 직렬화나 검증같은걸 수행하고,성공하면 진행,아니면 에러리턴하면됨
		그리고 아웃박스테이블에 쓰기전에 직렬화하면,모든 트랜잭션을 하나의 아웃박스테이블에 다 넣을수있음
		일반적으론 이렇게 많이쓰이는듯,이미 쓰고나서 출력때 직렬화실패하면,트랜잭션돌리기가 까다로워져서
		
		아웃박스의 장점은
			다수의언어지원
			사전스키마강화:삽입전 테스트로 스키마확인이 쉬움
			내부데이터모델 격리:db앱개발자가 아웃박스테이블의 어느필드에 쓸지 선택할수있어서 내부필드를 계속 격리할수있음
			반정규화:아웃박스테이블에 쓰기전에,필요한만큼 반정규화가능
		단점은
			앱코드변경이 필수
			비즈니스프로세스에 영향을미침(직렬화프로세스가 추가되니까)
			db에 영향을미침(2배로 작업량이 늘어나니까)
		
		이렇게 말고 트리거를 사용해서,변경된로우를 아웃박스테이블에 넣는거도 가능하긴함(자동으로 db에서 처리해줌 트랜잭션으로)
		이건 트리거실행중엔 이벤트스키마로 변경-검증이 불가능한경우가 많긴하고,비용도 비쌈
		트리거의 장점은
			대부분db가 지원
			규모가작을땐 오버헤드가 낮음
			맞춤로직이 가능함:특정필드의 하위세트만 노출시킬수있음
		단점은
			규모가커지면 리소스가 많이들어감
			변경관리가 복잡해짐(트리거수정이 필요할때 수정안하면 개판됨)
			확장성이 좋지않음(캡쳐할 데이터세트수만큼 트리거가 필요)
			사후스키마 강화:스키마강화는 아웃박스테이블에 발행후에만 발생시킬수있어서,문제있는레이블을 트랙잭션으로 돌리기가 힘들어짐
	
	
	6.데이터정의변경을 캡처대상데이터세트로
		관계형db에서 마이그레이션할땐,변경사항을 캡쳐해서 하는게 보통인데,이걸 이벤트스트림으로 생산할땐 문제가됨
		예를들어 양방향스키마호환성이 필요할땐,필드에 어떤값이 있을거라 기대하므로 기본값이 없는 널금지컬럼을 뺄수없어지고,이렇게 모호한상태가 됨
		이런경우엔(데이터규약을 깨야할땐) 반드시 새 데이터규약을 다시 체결해야함
		
		쿼리패턴은,쿼리시점에 스키마를 가져와서 이벤트 스키마를 추론할수있음
		새 이벤트스키마는 스키마호환성규칙을 이용해서 출력이벤트스트림의 스키마와 비교하면됨
		
		로그패턴은 데이터정의업데이트를 cdc로그의 일부로 캡쳐함,즉 로그에서 데이터정의변경을 추출해서 스키마표현형으로 추론하는것
		단 이건 지원하는db가 별로없음
		
		변경-데이터테이블캡쳐패턴은 내부상태스키마와 출력이벤트스트림 스키마를 연결하는 징검다리역할을 함
		앱검증코드나 db트리거중 하나라도 짝이 안맞으면 스택에 오류가쌓이고 데이터테이블에 데이터가 기록되지않음
		cdc테이블을 수정할땐 그에맞는 스키마호환성규칙에 따라 출력이벤트스트림과 호환되는 스키마를 정의해야함
		이걸로 예기치않은변경이 프로덕션에 스며들가능성을 줄일수있음
		
		
	7.이벤트데이터를 데이터저장소에 싱킹
		이벤트스트림데이터는 이벤트데이터를 소비해서 데이터저장소에 삽입하는 싱킹을 수행함
		일반적으로 싱킹은 중앙화프레임워크나 단독마이크로서비스를 사용해서 수행하고,엔티티,키없는이벤트,키있는이벤트 어느것도 다 저장할수있음
		이건 이벤트기반으로 개발되지않은 앱을 이벤트스트림과 통합할떄 유용함
		싱크 프로세스는 이벤트 브로커에서 스트림을 읽어서 특정 데이터저장소에 데이터를 삽입함
		또 앱과 독립적으로 작동하니,자신의 소비오프셋을 추적하고,데이터가 도착하는데로 db에 쓸수있음
		
		이건 보통 레거시시스템의 점대점결합을 대체할때 잘 쓰임
		또 배치기반의 빅데이터분석에도 자주 활용됨
		
		이걸 사용할때 주의해야할건
			소싱/싱킹은 책임이 팀간에 공유됨
			시스템이 프레임워크와 커넥터에 과도하게 의존하게됨
			
		이건 주로 더이상 개발할생각은없는데 유지보수만 하고있는거일때 주로 사용됨
		막 개발시작했으면 그냥 ms로가는게맞음
		
	
	
	
5.이벤트 기반 처리 기본	
	이벤트기반 마이크로서비스는
		입력이벤트스트림에서 이벤트를 소비
		이벤트를 처리
		출력이벤트를 생산
	최소한 이거 3개는 거쳐서 실행됨
	
	이벤트기반 ms인스턴스는 프로듀서/컨슈머클라이언트를 생성하거나,필요시 컨슈머그룹에 조인하고
	컨슈머클라이언트는 새 이벤트를 폴링해서 처리하고 필요출력이벤트를 내보내는걸 무한반복함
	
	1.상태비저장 토폴로지 구성
		마이크로서비스토폴로지를 설계할땐,사고방식이 이벤트기반으로 바뀌어야함
		여기는 소비자의 입력값으로 이벤트가 들어오면,거기에 반응해서 코드가 실행되는구조이기때문
		ms토폴로지는 본질적으로 이벤트에 수행하는 일련의 작업들이고,여기서 자기가 필요한 필터,변환등의 작업이벤트들을 선택해야함
		
		즉
			입력이벤트가 들어옴
			필터(값이 10보다 작으면 T 아니면 F)
			소수자리제거
			값출력
		이런식으로 돌아가게됨
		
		이 작업이벤트들의 종류는 변환과 분기,병합이 있는데
		변환은
			필터:기준을 충족하면 이벤트를 전파,0개이상의 이벤트를 리턴
			맵:이벤트키나 값,둘중 하나나 둘다를 변환해서 정확히 1개를 리턴,단순변환
			맵밸류:값만 변환해서 1개를 리턴
			맞춤변환:자기맘대로 로직을만들어서 변환해서 리턴
		분기는,조건에따라 조건에맞는 이벤트 스트림에 이벤트를 던지는것,에러가났을때 삭제하는게 아니라 에러스트림으로 던지는식
		병합은,여러 입력스트림에서 들어온 이벤트를 소비해서,하나의 출력스트림으로 보내는것
		
	2.이벤트 스트림 리파티션
		이벤트 스트림은 이벤트키와 이벤트 파티셔너로직에 의해 파티셔닝됨
		이벤트마다 파티셔너를 적용하면 이벤트가 기록될 파티션이 결정됨
		리파티션은 
			상이한 파티션수:다운스트림의 병렬도를 높이려고 파티션수를 늘이거나,코파티션을위해 다른스트림과 파티션수를 똑같이맞춤
			상이한 이벤트키:키가같은이벤트는 같은파티션에 배치되도록 이벤트키를 변경
			상이한 이벤트파티셔너:이벤트를 쓸 파티션선택로직을 변경
			
		중 하나이상을 이용해 새 이벤트스트림을 생산하는것
		
		보통 병렬도를 높이려고 파티션수를 늘이는거말곤,이걸할일이 거의없긴하지만,
		스테이트리스ms에선 소비자의 상태저장처리기가 소비할이벤트를 리파티션하는데 사용할수있음
		보통 파티셔너 알고리즘은 해시를써서 이벤트키기반으로 같은곳에 매핑함
	
	3.이벤트 스트림 코파티션
		코파티션은 어떤 이벤트스트림을 파티션수와 할당로직이 동일한 새로운 스트림으로 리파티션하는것
		이건 이벤트스트림의 키있는이벤트를,지역성을 추구하려고 다른스트림의 이벤트와 같은장소에 배치할때 필요함
		
		이건 출처가 어느스트림이든 상관없이,키가 동일한 이벤트를 동일한 노드에서 처리해야할때(상태저장작업등) 중요함
		즉
			8:a 9:s, 8:qw
			8:a,qw 9:s
			
			2:aa 2:bb , 2:y 3:r
			2:y,aa 2:y,bb
		이런식으로 키로 묶는것
		이렇게 서로 파티션수가 같고,같은키를 가진 레코드가 있을때,가장 키값의 갯수만큼 복사해서 값을 통일함
	
	4.컨슈머 인스턴스에 파티션 할당
		마이크로서비스는 각자 고유한 소비자그룹을 유지해서,자신이 소비하는 입력이벤트스트림의 오프셋을 집합으로 나타냄
		첫 소비자인스턴스는 해당 소비자그룹명으로 이벤트브로커에 등록되고,등록이끝나면 소비자인스턴스당 하나의 파티션을 할당함
		
		카프카같은 이벤트브로커는,그룹마다 첫등록클라이언트에 파티션할당임무를 맡기고,새인스턴스가 그룹에 조인하면 입력스트림의 파티션을 정확히할당함
		
		파티션을 다시할당해야할땐,경합을 방지하기위해 모든작업을 멈추고 다시 할당함
		
		스트림프레임워크를 쓰든,구현하든,대량데이터를 처리할떈 컨슈머ms를 여러 인스턴스로 실행해서 병렬처리해야함
		파티션 어사이너는 공평하고 안정된 방법으로 파티션을 여러 컨슈머인스턴스에 고루 분배함
		어사이너는 컨슈머그룹에 컨슈머인스턴스를 추가,삭제할때마다 파티션을 재할당함
		어사이너 컴포넌트는 브로커종류에 따라 클라이언트에 탑재되거나,브로커내부에서 관리함
		
		어사이너는 코파티션 요건을 모두 충족시키는 역할도 함
		코파티션된것으로 표시된 모든 파티션은,같은 하나의 컨슈머인스턴스에 할당되어야함
		그래야 어떤 로직을 수행할때 필요한 이벤트데이터하위집합이 정확히 할당되니까
		여러 이벤트스트림의 파티션수가 똑같은지 체크해서 그렇지않으면 예외를 던지는로직은 꼭 어사이너에 있는게좋음 
		
		파티션할당알고리즘의 목표는,파티션을 컨슈머 인스턴스 전체에 고루 분배하는것
		두번째는 리밸런스가 일어나는 도중에 재할당된 파티션수를 줄이는것,이건 샤딩을했을때 재할당떄문에 업데이트후 이상한샤드로 향할수있기때문에 중요함
		
		여기서 사용하는 전략은
			라운드로빈:전체파티션리스트를 만들고,인스턴스마다 라운드로빈으로 하나씩던져줌
					여기서 컨슈머인스턴스가 추가되면,부하분산을위해 다시 파티션할당을하는 리밸런스가 일어남
			정적할당:이건 특정파티션을 특정 컨슈머에 할당하는것,내부상태저장소에서 대용량데이터를 특정인스턴스에서 구체화할떄 유용함
				  만약 컨슈머인스턴스가 그룹을 떠나도,이거로하면 파티션이 재할당하지않은상태로 복귀할때까지 남아있음(설정할수있음)
			맞춤할당:외부에서 신호를 받거나,다른도구를 이용해 클라이언트요건에 최적화된 로직을 직접짤수도있음
			
		그리고 상태 비저장 처리인스턴스가 실패했을때 복구하는건,어짜피 상태저장안되니까 컨슈머그룹에 다시 인스턴스추가하면끝임
	
6.확정적 스트림 처리	
	스트림을 여러 파티션에서 소비할땐,순서대로 소비해야하기때문에 시간을 보려고 타임스탬프를 사용함
	그리고 이러다보면 가끔 순서가 뒤바뀌거나(비순차이벤트),아예 늦게오는경우(지각이벤트)도 있음
	
	이벤트기반 ms에선 두가지 주된 처리상태가 있음
		1.이벤트를 실시간에 가깝게 처리하는것(실행시간이 긴 ms가 주로함)
		2.과거부터 이벤트를 처리해서 현재를 따라잡는것(규모가 작은 신규서비스에서 주로함)
	둘다 확정적으로 처리를 하려면,ms가 동일한 출력을 내야함
	
	물론 외부영향을 받는(외부서비스를 처리한다던가)것들은 태생적으로 비확정적일수 있는데 이런걸 제외하고보면
	이론적으로는 가능한데 실제로는 네트워크이슈도 있을수있고,지연시간이 0이어야하고 그러니까 현실적으로 불가능함
	그래도 그에 가깝게는 할수있음
	
	1.타임스탬프
		이벤트는 언제 어디서나 발생할수있고,다른프로듀서가 생산한 이벤트와 조정이 필요한 경우가 많음
		그래서 일관성있고 동기화된 타임스탬프가 있어야함
		
		스트림에 저장된 이벤트는,오프셋과 타임스탬프를 둘다 가지고있음
		오프셋은 컨슈머가 이벤트를 어디까지 읽었는지,타임스탬프는 이벤트가 언제생성됐는지를 기록함
		타임스탬프를 사용하면 이벤트처리시점의 선후관계를 알수있어서,이벤트가 정확한 순서대로 처리됐는지를 알수있음
		이때 타임스탬프에서 중요한건
			이벤트시간:발생시점에 프로듀서가 이벤트에 할당한 로컬타임스탬프
			브로커인입시간:브로커가 이벤트에 할당한 타임스탬프,보통 이벤트시간을 사용해서 잘안씀
			컨슈머인입시간:컨슈머에 들어갈때의 시간,이벤트시간이나 월클럭(로컬)시간으로 설정함
			처리시간:컨슈머가 이벤트처리를 완료한 월클럭시간
		이렇게 사용됨
		이벤트가 발생하고,컨슈머에 들어가고,처리완료된시간을 전부 넣는식
		
		근데 저기서 로컬시간을 사용하니까,모든 컴퓨터들은 시간이 동기화되어야함
		완전히 동일할순없지만,대충 100ms라인까진 같으니까 그정도로 잡으면됨
		
		타임스탬프를 이용하면,여러 이벤트스트림과 파티션에 분산된 이벤트를 일관된 순서대로 처리할수있음
		대부분은 발생순서대로 정렬하고,스트림 처리시점과 무관하게 재연결과를 일관적으로 얻을수있으면됨
		오프셋으로 순서비교하는건 단일일땐 가능하지만,보통 여러스트림에서 이벤트받는경우가 많아서 사용되지않음
		
		막 스트림2개에서 예금과 인출을 받을때,
			예금:10(10초),20(20초)
			출금:-25(25)
		일때 순서대로보면 예금이 다일어나고 출금이니까 T가 나와야하는데,하나씩먹어서 10-25가돼면서 F가 나면 안되니까 타임스탬프가 필요한거
		
	2.이벤트 스케줄링과 확정적 처리
		이벤트를 일관되게 처리해야,나중에도 확정적 처리결과를 얻을수있음
		이벤트스케줄링은,여러 입력 파티션에서 이벤트를 소비할때,다음에 처리할 이벤트를 선택하는 프로세스임
		불변로그기반 이벤트스트림에선 오프셋순서대로 이벤트를 소비하는게 원칙이지만,정확한 결과를 얻기위해선 어느파티션에서 왔든 상관없이
		레코드에 기록된 이벤트시간에따라 처리순서를 정확히 바꿔야함
		
		이 이벤트스케줄링은 프레임워크의 기능중 하나지만,보통 컨슈머구현체에는 빠져있으니 넣어야함 쓰려면
		
		그리고 시간순서대로 이벤트를 처리하려면,타임스탬프로 사용할시점을 정해야하는데,보통 로컬이벤트시간을 사용하면됨
		생산-소비워크플로에서 한번씩만 발생하는데,월클럭이나 컨슈머인입은 앱실행시점에따라 달라지니까
		
		컨슈머는 이벤트 타임스탬프를 알아야 처리순서를 정할수있음,스탬프추출기를 사용해서 소비한이벤트에서 타임스탬프를 꺼내고,
		페이로드에서 키,값,메타데이터같은 정보를 획득할수있음
		추출기가 주어진 이벤트시간타임스탬프를 각 이벤트마다 세팅하면,컨슈머프레임워크는 이 타임스탬프를 이벤트처리내내 사용함
		
		그리고 이벤트기반토폴로지에서 비이벤트기반 요청을 외부시스템에 전달하면,비확정적 결과를 얻게될수있으니 조심
		
	3.워터마크
		워터마크는 처리토폴로지를 흐르면서,현재 ms의 처리이벤트시간을 추적하고,그 이전의 모든 데이터가 처리완료되었음을 선언하기위해 사용됨
		워터마크는 이벤트시간의 일정주기마다,혹은 몇개의 이벤트를 처리할때마다 갱신됨
		
		병렬적으로 이벤트를 받을때의 워터마크는,받은 전체 이벤트중 min을 적용하면됨,그러면 딱 그시간까지만 처리가 된거임
	
	4.스트림시간
		스트림처리기에서 시간을 유지하는 두번째방법은 스트림시간임
		이건 하나이상의 스트림에서 이벤트를 읽는 컨슈머가 처리된 이벤트중 가장 높은(최근의)타임스탬프를 유지하는것
		새로들어온 시간이 더 클경우 갱신하고,이건 절대 줄어들지않음
		그리고 각 이벤트를 그 다음이벤트가 처리되기전에 완전히 처리함으로서 시간을 유지함
		즉 2개이상을 지퍼처럼 하나로 묶어서 한줄로 만들고,맨마지막에 스트림시간이 제일큰게 오게 만듬
	
	5.비순차이벤트와 지각이벤트
		이벤트시간이 막 순서바뀌어서들어오면 비순차이벤트고,아예 엄청늦게오면 지각이벤트임
		만약 배치로 처리할경우엔 비순차라도 대충 받아서 순서바꿔주면되니까 상관없음,물론 지연시간이 늘어나는 트레이드오프는 있음
		근데 만약 무한히 업데이트되는 스트림의경우는,ms설계시 지연과 확장성요건을 고려해야함
		이건 기술요건만 아니라 비즈니스요건에까지 영향을 주니까,반드시 내 ms에서 비순차와 지각이벤트를 처리해야하나를 자문해야함
		
		이벤트를 지각으로 간주할지 여부는,자신을 소비하는 마이크로서비스관점에서만 판단할수있음
		
		워터마크에서 비순차이벤트는,t`가 w(t)이후에 들어오면 늦은것으로 간주,이건 해당노드에서 알아서처리
		스트림시간에서 비순차이벤트는,t`가 스트림시간이 t`만큼 증가한이후에 도착하면 늦은것으로 간주,이 이벤트는 하위토폴로지의 각 처리기가 알아서처리함
		
		비순차이벤트가 발생하는 이유는
			비순차데이터에서 소싱:애초에 이벤트만들때부터 순서가 틀렸을경우
			여러프로듀서가 여러파티션으로:즉 키가같은걸 여러ms에서 생산하고 그걸합칠경우,순서가 바뀌어서 들어올수있음(서로시간동기화를 하지않을경우엔)
			
		특정기간동안 발생한 이벤트를 취합하거나 일정시간이 경과하면 이벤트트리거하는 그런 로직에선,지각이벤트가 중요관심사임
		지각이벤트는 로직이 처리완료후에 들어온이벤트임
		
		윈도잉은 이벤트를 시간에따라 그룹핑하는것,특정시간동안 어떤키를 가진 이벤트를 대상으로 무슨일이 일어났는지알고싶을때 특히유용함
		윈도잉의 종류엔
			텀블링윈도:크기가 고정된윈도로,비는곳없이 시간별로 자름
			슬라이딩원도:크기는 고정되어있고,시간을 움직여서 자기맘대로 잡을수있음(시작시간을 정할수있음)
			세션윈도:크기가 맘대로 변하는,특정 이벤트(사용자가 행동을 멈춘)가 일어나면 거기서 끊김,그래서 중간에 갭이생길수있음
		이 윈도를 쓸땐,비순차이벤트를 반드시 고려해야하고,비순차이벤트를 얼마나 기다려야 지각으로 간주할지를 정해야함
		그러니까 지각의 발생률같은거와,얼마나 길게저장할지등을 고려해야함
		
	6.지각이벤트처리
		비순차,지각이벤트처리는 데이터중요도에 따라 달라짐
		금융거래같은건 언제들어와도 처리해야하고,온도나 힘같은 측정은 이미필요없어졌으니 폐기하면됨
		이건 어느정도까지 수용할수있을지도 요건에 명시해야함
		이벤트가 도착하길 기다릴수록,확정성은 올라가지만 지연시간은 길어져서 시간에 민감한 앱이나 sla가 빡빡한 앱에선 성능에 부정적영향을 줄수있음
		이때 이벤트처리방법은
			이벤트폐기:그냥 버림
			대기:일정시간동안 윈도결과출력을 늦춤,지연시간이 늘어나는만큼 확정성을 높이는것,시간이지날떄까진 윈도업뎃을 할수있음
			유예기간:윈도완료시 바로출력하고,일정기간동안 들어오면 업데이트하고 다시출력함(대기랑 똑같은데 일단 출력을한다는거)
	
	7.재처리 대 준실시간 처리
		불변이벤트스트림은,컨슈머그룹의 오프셋을 되감아서 특정시점부터 처리를 재연하는 재처리를 제공함
		이건 일반적으로 이벤트시간을 사용해서 이벤트를 처리하는 마이크로서비스에서만 수행하고,월클럭기반과 윈도잉에 의존하는ms에선 하지않음
		이벤트스케줄링은 이걸하기위해 아주중요함
		ms가 실시간에 가깝게 처리했던것과 동일한순서대로 이벤트가 처리되게 보장하기떄문
		
		스트림을 재처리해야할떈
			1.시작점 정하기
			2.어떤 컨슈머오프셋을 리셋할지 결정해야함
			3.데이터량확인,재처리해도 용량적으로 문제없을지 확인
			4.재처리시간확인,얼마나 리소스많이잡아먹을지(중단시간)확인
			5.영향도확인,만약 재처리과정에서 이메일 다시보낸다던가 그런거없는지확인
	
	8.간헐적실패와 지각이벤트
		실시간에 가깝게 처리할떈,이벤트가 늦게도착해서 폐기되거나했는데, 재처리할땐 스트림내부에서 원래 예상한대로 결과값이 나오는 경우가 있을수있음
		이건 이벤트를 생산하는 프로듀서중 한곳이 뻗어서,생산해야할 재고를 잔뜩안고 기절했다 일어나서 재생산을할떄,이미 쌓여있는 재고들을 생산할때나 이럴떄
		발생할수있음
		이러면 이벤트순서대로 발행하긴했지만,엄청늦었으니까 실시간에선 지각으로 표시되게됨,단 재처리할떈 일단 순서대로들어왔으니까 정상으로처리함
		이걸 해결하는방법은,뻗었을때 다 날리든가,이벤트처리전에 정해진기간동안 기다리든가,지각이벤트처리로직을 견고하게 컨슈머에 구현하든가로 처리할수있음
	
	
7.상태 저장 스트리밍
	보통 앱들은 요건상 상태를 어느정도 유지해야해서,상태저장스트리밍은 이벤트기반ms에서 가장 중요한 근간임
	
	구체화상태는 소스이벤트의 이벤트를 투영한것(불변)
	상태저장소는 서비스가 비즈니스의 상태를 저장하는곳(가변)
	
	둘다 상태저장ms에서 꼭 필요하고,폭넓게 활용되지만,둘을 구분해야함
	구체화상태는 ms에서 공통비즈니스엔티티로 사용할수있고,상태저장소에는 비즈니스상태 및 중간계산결과 저장을 할수있음
	
	ms를 설계할때 데이터를 어디저장할지 잘 생각해야함,상태를 저장/접근하는방법은
		처리기와 같은 메모리나 디스크에 저장(로컬)
		처리기외부의 스토리지에 네트워크로저장(s3버킷)
	가 있음,이건 클라우드랑 상관없이,논리적으로 어케구분되냐의문제
	
	이건 비즈니스역할과 기술요건에따라 선택하는데,그전에 체인지로그의 역할을 먼저 고려해야함
	
	체인지로그는 상태저장소에 담긴 데이터의 변경사항을 모두 기록한것,즉 이벤트기록이라고 봐도됨
	체인지로그가 변한 현재결과값이 상태저장소임
	체인지로그는 ms인스턴스 외부에 기록되는 영구적인 상태사본으로,상태를 재구성하고나 이벤트처리진행을 체크포인트하는데 사용됨
	체인지로그스트림은 최근 키/값 만 있어도 상태를 재구성할수있음
	이건 특히 내부상태저장소에서 높은성능으로 상태를 확장/복구할수있음
	확장/복구결과 새로 생성된 앱인스턴스는 자신에게 해당하는 체인지로그파티션에서 데이터를 로드하기만하면됨
	
	1.내부상태저장소에 상태 구체화
		내부상태저장소는 ms의 비즈니스로직과 같은컨테이너에 함께 둠
		이 상태저장소는 ms인스턴스가 있을떄만 의미가있고,둘다 같은기반하드웨어에서 실행됨
		
		각 인스턴스는 자신에게 할당된 파티션의 이벤트를 구체화하고,내부에서 각 파티션별 데이터를 논리적으로 분리함
		이렇게 논리적으로 나눠서 구체화해서,인스턴스는 컨슈머그룹 리밸런스후 회수된파티션상태를 그냥 삭제할수있음
		구체화상태는 파티션을 소유한 인스턴스에만 있어서,리소스누수가 생기고 진실공급원이 쪼개지는것도 막을수있음
		파티션이 새로 할당되면,스트림이나 체인지로그의 입력이벤트를 써서 재구성할수도있음
		
		보통 락스db같은걸 사용함
		
		전역상태저장소는 내부상태저장소의 특수한형태,할당된 파티션뿐아니라 해당 이벤트스트림의 모든 파티션데이터를 구체화해서,
		이벤트데이터 전체 사본을 각 마이크로서비스 인스턴스에 제공함
		즉,특정 스트림의 전역상태를 저장하는곳임(전체적인 상태값이 필요할때)
		
		이건 각 인스턴스에 전체 데이터셋이 필요한경우에 유용하고,자주쓰이면서도 변경될일이 별로없는 소규모데이터셋로 구성함
		각 인스턴스마다 전체데이터사본을 가지고있어,출력이 중복되거나 비확정적결과가 나올수있어서 트리거로는 적합하지않고,그냥 검색용으로 쓸때좋음
		
		내부상태를 사용하면 장점은
			개발자가 확장을 신경쓸필요가없음:모든 확장요건을 브로커나 리소스클러스터에 맡길수있음
			고성능디스크기반옵션:모든상태를 메모리에 올릴순없으니,싸게 ssd로 빼서 처리할수있음
			nas를 사용할수있음:nas를 로컬로 취급해서 사용할수있음,물론 통신량이 많으면 병목생기지만,
						  통신량이 많지않으면 컨테이너를 죽였다살려도 다시 붙이기편함
						  
		단점은
			런타임에 정의된디스크밖에 사용불가:디스크를 바꾸려면 껐다켜야하고,볼륨을 줄일수없음(이미차있으니까)
			디스크공간낭비:트래픽이 가장 몰릴때를 기준으로 잡을수밖에없음(껏다켜야하니까)
			
		가 있음
		
		내부상태에서 처리능력을 확장하고,실패한인스턴스를 복구하는건 상태복구관점에선 같은행위임
		새인스턴스나 복구된인스턴스나 새 이벤트를 처리하기전에,정의된상태를 전부 구체화해야함
		이걸하는 가장 빠른방법은,체인지로그를 다시 로드하는것
		
		그리고 구체화상태 레플리카는,파티션당 하나잡는게 보통이지만,두개이상잡아서 고가용성을 유지해서 인스턴스가 실패해도 상관없게할수도있음
		
		그리고 새로 생성된 인스턴스가 컨슈머그룹에 조인할떄,이 인스턴스에 할당된 모든 상태 저장파티션은,체인지로그에서 소비하면 다시 그대로 로그할수있음
		중요한건 로드하는시간동안은 새 이벤트를 처리할수없음(비확정적결과)
		
		체인지로그가 없으면,인스턴스에 할당된 입력이벤트스트림파티션의 맨 처음부터 쭉 올라가면서 복구해야함,시간은 더걸리겠지만 결과는같음
		이떄 주의점은,멱등적이벤트의경우엔 변화없게처리해야함
		
	2.외부상태저장소에 상태구체화
		외부상태저장소는 컨테이너외부에 존재하지만,보통 로컬네트워크안에 존재함(외부에있어도 상관없음 어짜피ip접근인데)
		이때 사용할수있는 기술은,관계형db,nosql,고가용성 분산키값저장소등을 사용함
		
		외부상태저장소를 공통 데이터스토리지 플랫폼에 둘수도있지만,데이터셋 자체는 다른 모든 마이크로서비스구현체와 논리적으로 당연히 분리되어야함
		마이크로서비스에서 구체화상태를 공유하는건,대표적인 안티패턴임,이렇게쓰면 상관없는제품과 특성이 단단하게 결합될수있음
		
		외부상태저장소의 장점은
			완전한 데이터 지역성:내부상태저장소와 달리,각 인스턴스가 접근 가능한 모든 구체화 데이터를 제공하기때문에,
						  많은요소간에 검색,외래키기반 쿼리등을 할떄 파티션지역성이 필요하지않음
			기술:이미 많이 사용하던 기술이라 따로 학습안해도됨,보통 faas나 프로듀서/컨슈머패턴을 사용
		외부상태저장소의 단점은
			여러기술을 관리해야함:기술의 갯수가 많아지고,서비스 소유자가 이걸 알아서 잘 관리해야함
			네트워크지연으로인한 성능저하:네트워크 지연이 발생하면 성능이 확떨어질수있음
			외부상태저장소 서비스이용료:보통 내부저장소보다 외부저장소가 더 비쌈,물론 유동적으로 용량조절은 가능하니까 계산기떄려봐야함
			완전한데이터지역성:외부저장소에 있는데이터는 처리량이 제각각인 여러 처리기와 파티션에서 비롯되어서,어떤 인스턴스가 얼마나 관여했는지 추론이어려움
						그리고 경합조건과 비확정적동작도 잘 살펴봐야함
		
		외부저장소에서 마이크로서비스를 확장,복구할떈 상태저장소접근에 필요한 인증정보만 새 인스턴스에 추가하면끝임,근데 이거랑다르게
		하부저장소를 복구/확장하는건 사용하는기술에 완전히 종속되게됨(mysql쓰면 거기서 하는대로 해야함)
		이때 사용할수있는 기술은,
			소스스트림:소스스트림의 이벤트를 초기부터 소비하면 상태저장소의 새로운 사본을 만들수있음,
				   중단시간은 길지만 재연하기쉽고,데이터만문제없으면 문제가없음
				   단 이건 앱전체리셋과 다름없어서,로직에따라 출력이벤트(이메일같은)거도 모두 재생성된다는것도 알고있어야함
			체인지로그:보통 외부저장소에선 안쓰지만,안쓸이유도없음,이거도 똑같이 저장소사본을 만들수있음,위랑똑같은데 좀 부하가적은거
			스냅샷:특정시점마다 계속 스냅샷을 찍어서 그값을 가지고가는것,상태가 멱등적일경우엔 오프셋과 구체화상태가 일치하는지 확인안해도됨
			     이때 오프셋을 스냅샷찍기 몇분전값으로 세팅할땐,유실되는 데이터가 없도록 주의해야함,그래야 이벤트의 적어도 한번이상이 만족됨
				 이게 불가능하면,컨슈머오프셋을 데이터안에 넣어 같이보관해야함(스냅샷에 같이보관)
				 
	3.재구성 대 상태저장소 마이그레이션
		새 비즈니스 요건을 반영하기위해,기존 상태저장소의 데이터구조를 변경하는경우가 많음
		기존이벤트에 새정보를 추가하거나,다른 구체화테이블을 조인하거나,새 데이터를 저장하는로직을 추가하거나
		이경우엔 재구성 또는 마이그레이션으로 데이터가 반영되도록 상태저장소를 업데이트해야함
	
		재구성은,마이크로서비스를 중지하고,입력스트림오프셋을 초기로 리셋하고,체인지로그나 외부상태저장소에 보관된 중간상태를 삭제하고,
		새버전을 시동하고 처음부터 입력스트림을 전부읽어서 상태를 재구성함
		이러면 로직에따라 새로운 상태가 정확히 구성되고,모든 새 출력이벤트도 만들어져서 이걸 구독하는 다운스트림 컨슈머에 전파됨
		이런 이벤트는 로직과 같이 출력포맷도 바뀌었을테니까,중복이벤트가 아니고 변경된 내용은 다운스트림으로 반드시 전파되어야함
		
		이걸위해선 입력이벤트스트림의 모든이벤트가 있어야함
		
		마이그레이션은,재구성이 너무 오래걸리고,영향에비해 너무 비싸니까,특정부분만 고치고 나머지는 그냥두자(db필드에 앞에건 null처리하고 그냥넣자)식임
		이건 시작코스트는 작고 변경도 쉽지만,바꿀때 영향을받는데는 없는지 잘 살펴야함(이건 비즈니스로직이 아니라서 비정합성이 있을수있음)
		
	4.트랜잭션과 실제로 한번 처리
		이벤트를 '실제로 한번 처리'하면,프로듀서와 컨슈머,브로커실패와 상관없이 단일진실공급원에 반영된 업데이트를 일관되게 적용할수있음
		실제로 한번 처리란,이벤트가 실패랑 상관없이,멱등적으로 한번만 적용되게하는것
		
		멱등적쓰기는 스트림에 이벤트를 한번만 쓰는기능으로,보통 다 지원함,
		이걸사용하면 중간에 실패해서 재시도해도 중복이벤트가 생기지않음
		
		트랜잭션을 지원하는 브로커도 있음,이거도 다수의 이벤트를 다수의 개별이벤트스트림에 원자적으로 묶어서,하나라도 실패하면 되돌리는식으로 지원함
		이걸 지원하지않는 브로커를 사용할땐,클라이언트에서 구현해야함
		
		직접 구현할떈,중복이벤트에 조심해야함,그리고 그냥 멱등적쓰기를 지원하는 브로커와 클라이언트를 쓰면 편해짐
		그리고 중복이벤트를 식별하고(이벤트id같은거로)그걸 폐기하는식으로 처리를해줘야함
	
	
8.마이크로서비스 워크플로 구축	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	