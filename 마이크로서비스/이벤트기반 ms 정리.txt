1.왜 이벤트기반 마이크로서비스인가
	이벤트기반ms는 시스템이 이벤트를 생산/소비하는식으로 서로 통신함
	이벤트를 소비해도 바로사라지진않고,같은 메세지를 필요로하는 다른 소비자들도 가져갈수있게 보존됨
	이거로인해 여러 패턴들이가능해짐
	
	서비스자체는 개발기간이 2주안에 끝나게,개념적으론 머리속에 한번에 들어갈정도
	서비스는 입력이벤트스트림에서 이벤트를 받아서,
	특정 비즈니스로직을 적용하고 출력이벤트를 내보내서 요청응답접근에 필요한데이터를 제공,혹은 서드파티api와 통신함
	
	서비스는 스테이트풀과 스테이트리스로 분류됨
	
	도메인주도 설계와 경계콘텍스트는
	하위도메인에 경계선을 최대한 비슷하게 잘라서,내부에서만 동작하고 외부로 영향을 주는걸 막는걸 말함
	경계콘텍스트는 비즈니스요건 중심으로 만들어져야함,그래야 변경사항이 있을때 변경점이 내부에만 영향을주고,
	한팀만 특정 ms를 소유해서,책임이 분산되지않음
	즉,비슷한 코드가 있어도 그냥 중복을 감수하고 서비스마다 따로 만듬(그냥복사해서 넣어도됨,서로 영향만안주면되니까)
	
	서비스의 통신은,실제 비즈니스통신과 어쩔수없이 비슷하게 나가게됨
	ms전까진,실제로 전화해서 정보전달하는거와,진짜 데이터를 넣는것과는 별개로(두개를 동시에)처리했음
	기본적으로 모놀리스식으로,db에서 정보를 다 받고,거기서 계속 받아가는식으로 처리하는경우가 많았음
	이거의 문제는,모든 서비스들이 하나의 db를 직접 접근하니까 db에 변경점이 있으면 모든 서비스들이 영향을 받게됨
	즉,접근은 쉬운데 변경은 어려움
	
	그래서 나온 패턴이 db에 어댑터붙이는패턴임
	db와 관련된 통신은 전부 한 서비스에서 맡고,그 서비스에 접촉해서 자기가 받을 데이터를 받는것
	이러면 올바른 통신을 할 책임은,db서비스에만 있고 다른서비스들은 처음에 했던인터페이스대로 그냥 받기만하면됨
	이게 이벤트 기반 통신임
	
	모든 데이터는 하나의 db안에 있는,단일 진실 공급원이고,각 이벤트는 사실진술서임
	즉 받은이벤트는 어디서 받아도 똑같은시간에 넣었으면 똑같이나옴
	
	그리고 소비자가 스스로 모델링과 쿼리를 수행함(자기가 필요한 인터페이스 만들어서 줘야함)
	이렇게되면 직접적으로 db접근하는건 서비스하나밖에 없고,다른데서도 동시에 필요한 이벤트는 공용이벤트로 발행해서
	데이터의 생산과 소유를 완전히 분리할수있음
		
	이벤트기반ms의 장점은
		세분성:서비스가 경계콘텍스트에 맞게 매핑되고,비즈니스요건이 바뀌어도 쉽게 재작성가능
		확장성:필요시 규모를 늘리거나 줄일수있음
		기술유연성:서비스마다 다른언어써도됨
		비즈니스요건유연성:소유권을 쉽게 넘겨줄수있음(인수인계에 들어가는게작음)
		느슨한결합:외부에 영향을 받지않음
		cd지원:쉽게 업데이트할수있음(외부에 영향을 안주고 안받아서)
		우수한시험성:테스트하기가 쉬움(의존성이 낮아서)
	
	그리고 또 중요한건,여기서의 통신은 비동기식이라는것
	동기식으로도 ms를 구현할수 있긴한데
	단점은 대규모환경에선 문제가 많음
		점대점결합이라 자신이 할일을 다른서비스에 의존해서 할수밖에 없고,이러면 어느 서비스가 어떤 비즈니스로직을 담당하는지 파악이 매우 어려워짐
		그리고 한 서비스의 확장 여부는 다른 서비스가 확장가능한지에 따라 달렸음
		서비스실패할때 처리하는거 생각하기가 힘듬,여러개가꼬리물려있어서
		api버저닝하기힘듬
		데이터접근이 구현체에 종속됨
	장점은 
		사용자인증,a/b테스트같은 데이터접근패턴은 이게더 쉽긴하고
		로그로 추적하기도 쉬움 
		그리고 사람들이 많이써봐서 접근이쉬움
	
	
	
2.이벤트기반 마이크로서비스 기초	
	이벤트기반 ms는 경계콘텍스트를 구현하기 위해 개발된 작은 앱임
	소비자ms는 하나이상의 입력이벤트스트림으로부터 이벤트를 소비하고
	프로듀서ms는 다른 서비스가 소비할수있게 이벤트스트림에 이벤트를 생산함
	
	일반적으로는 ms들은 소비자인 동시에 다른 출력중 하나의 프로듀서 역할을 함
	서비스는 스테이트리스와 스테이트풀이 있고,api가 포함된 서비스도 있음
	
	토폴로지는 ms토폴로지와 비즈니스 토폴로지가 있음
	
	ms토폴로지는 마이크로서비스 내부의 이벤트기반 토폴로지임
	변환,저장,방출등 이벤트에 수행할 데이터주도연산을 정의함(데이터의 저장,가공등을 알아보기쉽게 그린거)
	
	비즈니스 토폴로지는 비즈니스 로직을 처리하는 ms,이벤트스트림,api의 집합임
	이건 서비스를 임의로 그룹핑한거로 하나의 팀이 소유한 서비스나,복잡한 비즈니스기능의 상위집합을 수행하는 서비스를 나타냄
	마이크로서비스는 비즈니스 경계콘텍스트를 구현하고,이벤트스트림은 전체콘텍스트의 도메인데이터를 공유하기위해 필요한 통신수단
	
	그리고 이벤트는 뭐든지 이벤트가 될수있고(신입사원채용이나 뭐 커피마신횟수같은거도 됨),이걸 잘 쌓아두면 나중에 잘 활용할수있음
	
	이벤트는 키/값포맷으로 표현됨 보통
	이벤트의 세부정보는 값에,키는 식별,라우팅,집계에 사용하고,키는 필수는 아님
	
	키없는 이벤트는 로그처럼 키가 없이 단순 값의 나열임
	엔티티이벤트는 특정 엔티티가 수행한 일을 로그식으로 나열한것,특정엔티티만 뽑아서 어떻게 행동했냐를 알수있고,현재상태를 로그만가지고 알수있어서 제일중요
	키있는 이벤트는,키없는 이벤트에서 검색하기편하게 키를 넣어둔거
	
	엔티티이벤트에서 특정 엔티티의 행동들을 모아둔테이블(이벤트소싱 맞음)로 현재 엔티티의 상태를 알수있음
	같은방법으로 각 엔티티별로 행동횟수도 알수있고,이런 커맨드는 mysql의 바이너리로그나 외부이벤트스트림처럼 불변로그에 대한 이벤트로 생산할수있음
	
	키있는 이벤트는 값이 null인 키있는 이벤트(툼스톤이라고부름)를 만들어 삭제함
	이는 업스트림 프로듀서가 어떤 키를 가진 이벤트가 삭제대상이라고 알리는 관례임
	그리고 상태를 계속 나열하다보면 무한정 커지니,컴팩션을 해야함,이건 스냅샷으로 특정지점까지의 결과값을 계산해서,그걸 초기값으로 쓰는것
	만약 툼스톤이 박혀있으면 그건 삭제하는식으로 관리함
	
	그리고 이벤트데이터는 서비스간 통신수단을 비롯해서 구현체와 무관한 장기데이터 보관소역할을 하기때문에,
	프로듀서와 소비자가 데이터의 의미를 똑같이 이해하는게 중요함
	이걸위해서 아파치 아브로나 구글 프로토콜버퍼같은 스키마화 기술을 사용하면 쉽게 사용할수있음(스키마변경등이 자유로워짐)
	
	그리고 마이크로서비스는 단일소유니까,어떤 이벤트라도 데이터를 역순으로 보면 그 이벤트를 누가시작했나를 알수있음
	
	이벤트브로커는 프로덕션에서 바로 서비스가능한 이벤트 기반 마이크로서비스플랫폼의 핵심임
	얘는 이벤트를 받아서 큐나 스트림에 저장하고 이걸 다른 프로세스가 소비할수있게 제공함
	이벤트는 보통 여러 스트림으로 나뉘어(발행하는 논리적의미에따라) 발행하는데,이건 db에서 테이블을 여러개두는거와 비슷함
	
	이벤트 브로커는
		확장성:인스턴스를 추가하면 클러스터의 생산/소비및 데이터 스토리지를 늘릴수있어야함
		보존성:노드간에 이벤트데이터가 복제되므로 한 브로커에 장애가 발생해도 데이터는 보존되어야하고 서비스도 계속할수있어야함
		고가용성:클러스터링을 했을때,한군데가뻗어도 다른데로 접속할수있어서 가용성이 유지되어야함
		고성능:여러 브로커노드가 부하를 분담할수있어야함
	를 만족해야함
	브로커가 사용할 데이터스토리지의 최소요건은
		파티셔닝:스트림을 개별하위스트림으로 나눌수있어야함(테이블안에서 하위테이블로 나눌수있어야함)
		순서보장:순서를 보장해야 이벤트소싱이 가능해짐
		불변성:한번발행되면 바뀌거나 수정할수없어야함,수정하고싶을떈 새값을 추가해야함
		인덱싱:특정 엔티티의 마지막위치확인이 가능해야함
		무기한보존:이벤트를 무기한으로 보존할수있어야함
		재연성:어떤 소비자라도 필요한 데이터를 골라서 읽을수있어야함
		
	이거외에도 지원도구나,호스티드솔루션(외부도구)이 존재하는지등도 고려사항
	
	이벤트브로커와 메시지 브로커의 차이는,메시지브로커는 소비하면 삭제되고,이벤트브로커는 소비해도 계속 쌓임
	그리고 메시지브로커는 소비하면 삭제되니까,여러소비자가 동시에사용할수없는데,이벤트브로커는 안사라지니까 동시에사용할수있고
	메시지는 사라지니까 재현성이없음
	
	일반적으로 이벤트브로커는 붙임전용불변로그를 사용함,이벤트는 끝부분에 추가되고 자동증가인덱스id가 부여되는식
	이 인덱스id로 접근해서 소비하는것
	
	이벤트스트림으로 소비할떈,각 소비자는 자기가 마지막에 읽은 위치를 인덱스로 가지고있고,그걸써서 독립적으로 데이터를 소비하면서 진행사항을 추적할수있음
	큐로 소비할떈,각 이벤트는 오직 하나의 서비스만 소비할수있고,소비했으면 소비됨표시를 붙여서 다른인스턴스에 제공하지않음
	큐로 받은 이벤트는 순서가 보장되지않음(실패하면 나중에 처리하려고 반환할수있기때문)
	
	이벤트브로커가 단일진실공급원이 되려면,각 팀에선 sql을 쓸수없고,데이터를 받으려면 반드시 이벤트브로커로 발행해야함
	
	그리고 대규모 마이크로서비스를 관리할땐,마이크로서비스를 컨테이너에 넣어서 오케스트레이션하는게 좋음
	가상머신도 보안적인측면에선 좋지만,여러모로 코스트가비싸서 안쓰는듯
	
	
	
3.통신및 데이터규약
	통신에서 제일 어려운건,프로듀서가 생산한 메시지의 컨텐츠와 의미를,소비자가 정확히 되살리도록 보장하는것
	그래서 둘은 똑같이 이해하고있어야하고,만약 아니면 개판이남
	이벤트기반시스템에서 이벤트는 무슨일이 일어났고,그 이유는 무엇인지 정확하게 기술하는 메시지이자,통신의 기본단위임
	이벤트는 사실진술서로서 시스템이 발행한 다른 이벤트와 조합해서,발생한 사건에 대한 완전한 이력이 되어야함
	
	1.이벤트기반 데이터 규약
		데이터 규약은,주고받을 데이터의 포맷과 생성로직을 정의함
		즉 프로듀서와 소비자가 모두 준수하는 계약(인터페이스)라고 보면됨
		이벤트 규약을 이용하면,이벤트가 생산되는 콘텍스트 이상의 의미를 부여할수있고,데이터사용성을 넓힐수있음
		
		데이터규약에는 데이터정의,즉 생산할것들(필드,타입등)과 트리거로직,즉 생산한이유(이벤트생성을 일으킨 트리거)이렇게 두개가 포함됨
		데이터 정의를 변경할땐,다운스트림에서 사용중인 필드를 삭제/변경하지않게 주의해야하고,
		트리거로직도 마찬가지로,트리거로직을 바꾸면 원래 이벤트정의에 담긴 의미가 깨지지않는지 확인해야해서 보통 데이터정의를 변경하는게 일반적임
		
		데이터규약을 강제하여 일관성을 유지하는 가장 좋은방법은,이벤트마다 스키마를 정의하는것
		프로듀서가 데이터정의와 트리거로직이 상술된 스키마를 명시적으로 정의하여,동일한 타입의 이벤트는 모두 해당포맷을 따르게함
		이렇게해서 모든 미래의 소비자에게 이벤트포맷을 전달하고,소비자는 스키마화 데이터를 받아 명확한 구현이 가능해짐
		
		소비자가 비즈니스처리를 할땐,필요한 데이터를 추출부터 해야함,근데 어떤 데이터가 필요할지 미리 스펙을 정해두지않으면 조정비용이 늘어나고
		감당이 힘들어지고,생산자와 소비자의 해석이 다를수있어서 리스크를 가지고가게됨
		그리고 프로듀서입장에서도,뭘 바꿀때 바꾸면 무슨일이 일어날지 모르니,바꾸는게 무서워지게됨
		그래서 명시적으로 나타나는게 중요한거
		
		스키마 정의에서 주석과 메타데이터는,이벤트의미를 제대로 전달하기위해 꼭 필요함
		이때 이벤트생산/소비에 관한 지식은,가능한 이벤트정의와 가깝게 붙어있는게 좋음
		주석은 
			이벤트의 트리거논리를 명시:이벤트가 생성된이유를 명확히 밝힘
			구조화한 스키마의 특정필드(날짜같은)에 콘텍스트를 부여해서 밝힘:시간의 포맷이 utc같은걸쓸지를 명확히명시
		할때 주로쓰임
		
		그리고 스키마포맷은 반드시 스키마 진화규칙의 전체범위를 지원해야함
		스키마진화를 잘 활용하면,소비자는 중단없이 이벤트를 계속 소비하면서 프로듀서가 출력포맷을 업데이트할수있음
		
		업무가 변경되면 보통 새필드를 추가하거나,옛필드를 사용하지않음으로 표시하거나,필드범위를 확장하는등의 작업이 필요함
		스키마 정의 프레임워크를 사용하면,이런변경사항을 안전하게 적용해서,소비자생산자 독립적으로 업데이트할수있게 보장함
		
		스키마진화없이는 업데이트비용이 너무 비싸짐
		스키마진화의 규칙은
			정방향호환성:새스키마로생성한걸 옛스키마로생성한거처럼 읽을수있음,즉 원래있던필드는 그대로읽을수있어서 새로추가된거 안가져다쓸거면 그대로쓰면됨
			역방향호환성:옛스키마데이터를 새스키마처럼 읽을수있음,즉 새스키마를 읽을걸로 원래데이터도 읽을수있음
			양방향호환성:정방향,역방향 둘다,즉 어떻게해도 읽어짐
		3개가 있음
		
		코드생성기는 이벤트스키마를 클래스정의처럼 그런형태로 변환시켜줌
		얘는 클래스정의를 이용해서 스키마의 데이터타입을 준수하는 이벤트 객체를 만들고,모든 널금지필드를 채워넣어서 이걸 변환시켜서 이벤트브로커에 전달함
		이걸 사용해서 컨슈머는 스키마버전을 직접 관리하고,그래서 프로듀서와 대부분 버전이 동일하지만 용도에따라 낮거나 높을수도있음
		양방향호환성일경우 양쪽다 읽을수있기때문
		
		소비자는 이벤트를 읽어서 그안에 인코딩된 스키마버전으로 이벤트를 역직렬화함
		이벤트포멧을 메시지안에 넣을수도있긴한데 규모가 커지면 비용이 많이드니,레지스트리에 보관하는식으로 함
		원래포맷으로 역직렬화한 이벤트는,소비자에서 지원되는 버전의 스키마로 바꿈(누락된필드는 기본값,미사용필드는 제거)
		이걸 사용하면,원하는 언어에 맞게 앱을 작성할수있는 큰 장점을 가지고있음
	
		
		그리고  스키마가 진화하는 흐름을 깰수밖에없는 비즈니스요건의 큰변화나,잘못된 설계들으로 인한 스키마변경이 있을경우,
		생산하는쪽은 별로 신경안써도되는데 소비자쪽은 많은 영향을 받으니 신중하게 살펴야함
		이런상황에서는 모든관련자가 다 알고있어야하고,모두다 준비된후에 바꿔야함
		이때 엔티티스키마의 데이터정의를 바꿀땐 두가지방법이 있음
			옛스키마와 새스키마를 함께두던지
			모든엔티티를 마이그레이션해서 새 스키마포맷으로 재생성하던지
		일반적으로 그냥같이두는게 편하긴하지만,이러면 나중에 부채가 너무커서 일반적으론 새스키마로 재생성하는쪽
		
		비엔티티이벤트는 그냥 새 이벤트스트림을 만들어서,새 이벤트를 이 스트림에 생산하게 하면됨
		가장 간단하겐,새 이벤트스트림을 만들어서 새이벤트를 여기서 생산하게하면됨(새테이블을 만들면된다는거)
		물론 소비자한테 여기서 받아가라고 알리긴해야함
		
	2.이벤트포맷선택
		이벤트데이터는 아브로,프로토콜버퍼처럼 엄격한 포맷을 사용하는게 좋음
		이런애들은 인코딩된 이벤트의 역직렬화와 직렬화를 지원함
		그래서 데이터저장으로 json을 사용하는건 권장되지않음(비구조텍스트도 동일)
	3.이벤트설계
		이벤트정의를 생성할때 하지 않아야할 안티패턴도 많음
		물론 완벽히 다 지켜야하는건아니지만(코스트따라서 어겨야할때도있음),어지간하면 지키는게 좋음
		
		잘 정의된 이벤트는 뭔가가 일어났음을 전하는게아닌,그이벤트가 발생한동안의 모든일을 빠짐없이 기술함
		즉, 입력데이터를 받아 나온 출력테이터를 전부 기술하고,이걸 가져다가 진실공급원으로 써야하고,
		이 이벤트에 대해 다른데서 뭐 찾을필요없이 이거하나로끝나야함
		
		스트림당 이벤트정의는 하나만 사용해야함,한 스트림에는 하나의 논리적 이벤트만 포함되어야함
		즉 한테이블에 여러 이벤트로 넣으면 안좋음
		
		가장 좁은범위의 데이터타입을사용,즉 문자열로 숫자넣고 그러면 직렬화같은거로 테스트하기가 힘들어짐
		
		이벤트는 하나의 목적만 가져야함,대표적으로 필드에 구분자를 추가해서 이벤트를 구분하려고하면,당시엔 쉬워도 나중에 엄청머리아파짐
		처음엔 비슷한거같지만 나중에 다른요구사항들어오면 머리아픔(영화대여시스템에 책대여시스템을 넣었는데,책갈피가 필요할경우 영화는 그냥 다null넣어야함)
		그냥 처음부터 다 분리하는게 편함 구분코드써야할거같으면
		특히 이벤트의 의미를 오버로드하는 타입필드는 절대사용하면안됨
		
		이벤트는 크기가 최소화되어야함,만약 몸집이 큰 이벤트일경우,데이터가 해당이벤트와 직접관련이 있는지 확인하고,
		마이크로서비스가 데이터에 직접 접근해야하는지 확인하고,너무 하는일이 많지않은지 확인해야함
		물론 뭐 이미지같은거 보내야하면 어쩔수없고
		
		미래의 소비자도 이벤트설계에 반영해야함,즉 소비자쪽팀과 협의해서 앞으로필요할기능같은걸 미리 들어둬서 일을 한번에끝내야함
		
		이벤트를 세마포나 시그널로 사용하면안됨,이벤트는 진실공급원이어야지,알림으로 사용하면안됨,
		두번이상의 접근이 필요해지면(진실공급원이 2개이상이면) 일관성에 문제가생김
		즉 알림으로 사용하는건괜찮은데,접근을 한번에 끝내야하니까 거기에 모든게 담겨있어야함
		
		
4.기존 시스템에 이벤트기반 아키텍쳐 통합
	기존 모놀리 아키텍쳐를 이벤트 기반 아키텍쳐로 바꾸는데는 데이터 해방 프로세스(데이터가 포함된 기존시스템및 상태저장소에서 데이터를 소싱하는것)이 필요함
	이렇게하면(데이터를 이벤트스트림에 생산하면)모든 시스템이 데이터에 접근할수있음
	
	1.데이터해방이란
		데이터해방은 교차도메인데이터셋을 식별해서,각 이벤트 스트림에 발행하는 마이그레이션의 일부임
		이떄 다른 외부시스템이 필요로하는 데이터 저장소에 저장된 모든 데이터역시 거기에 포함됨
		그래서 점대점디펜던시를 분석하면 해방시켜야할 데이터가 분명해짐
		
		기본적으로 데이터해방을 할땐,원래db를 그대로두고,데이터소싱어댑터를 붙여서 이벤트스트림에 넣고,이벤트스트림에서 시스템들이 가져가는식으로 설계하게됨
		이러면 이벤트스트림이 단일진실공급원이 되게되고,원래 db도 손그렇게 안대도됨
		
		이때 중요한건,데이터db와 이벤트스트림은 완전히 동기화되어야함,그리고 이벤트스트림은 반드시 복제한 소스테이블의 레플리카로 다시 구체화되어야하고,
		이런성질은 이벤트기반 ms에서 자주활용됨
		그리고 레거시시스템은 이 이벤트스트림에서 데이터셋을 재구성하지않음(다시 아무것도 읽어들이지않음)
		이게 제일 이상적이긴하지만,인력이 부족해서 이렇게까지 코스트 못붓겠다하면
		데이터해방으로 데이터저장소에서 데이터를 꺼내고,그데이터를 이벤트로 변환하고,새 앱만 거기에 접근하는것
		이때 가장 먼저 해방시킬데이터는 비즈니스전반에 걸쳐 연관성이 가장 많고 자주사용하는 데이터
		
	2.데이터 해방 패턴
		이때 데이터해방을 하는 패턴은 크게 3가지가 있음
		데이터해방하는건 결국 새로운 단일진실공급원을 만들겠다는것이니까,db에 있는 전체데이터셋을 담아야하고,계속 삽입수정삭제하면서 최신상태로 유지되어야함
		이떄 방법으론
			쿼리기반:쿼리를해서 데이터를 추출
			로그기반:로그로 데이터를 추출,일부db만 지원
			테이블기반:출력큐테이블에 데이터를 푸시하고 관련엔트리를 삭제
		세가지패턴 다 장단점이 있지만,공통적으로 소스레코드의 최근업데이트시간컬럼을 사용해서 이벤트를 타임스탬프대로 생산해야한다는것은 같음
		
		이때 데이터를 해방하는 가장쉬운 방법은,데이터를 이벤트스트림으로 추출하는 카프카커넥트,아파치고블린같은 프레임워크를 사용하는것
		물론 자기가 직접 만드는게 더 깔끔할수도있고,상황따라 그렇게해야할수도있음
		
	3.쿼리로 데이터해방
		쿼리기반으로 할땐,sql을 사용해서 벌크쿼리를 해서 전체 데이터를 로드하고,마지막 타임스탬프 이후거를 계속 로드해서 가져오는방식임(증분업데이트)
		이걸위해서 자동증가인덱스id가 필요함
		그리고 이렇게할땐,커스텀쿼리(함수로된쿼리,사용자가 직접 sql날리는걸 막음,룸에서 다오에서 query뺸거)로 제한해야함
		
		그리고 증분업데이트를 하려면,자동증가인덱스id를 설정하고,폴링빈도와 지연시간을 정하고,그 시간마다 쌓였던걸 다 푸시하고 인덱스를 다시 갱신함
		이때 너무 빠르면,앞쿼리가 로드중인데 계속 쿼리가 덮어씌워지는문제가 있을수있으니 적당히 길게잡아야함
		
		쿼리기반업데이트의 장점은
			맞춤성:모든db를 쿼리할수있고,클라이언트가 맘대로 쿼리옵션지정가능
			독립적인폴링주기:자기맘대로 폴링주기를 맞출수있음,일관성이 중요한건 최대한땡기고,나머지는 좀 풀어두는식으로 코스트조절가능
			내부데이터모델의 격리:뷰객체를 이용해서,내부데이터모델과 분리할수있음,즉 도메인모델정보를 숨길수있음
		단점은
			최종업데이트시간 타임스탬프가 필수
			하드삭제(delete쿼리날린거) 추적불가:소프트삭제(is_delete필드에 ox표시)만 추적가능
			데이터세트스키마와 출력이벤트스키마간의 취약한 의존관계:소비자이벤트포맷의 규칙과 호환되지않는방향으로 데이터셋스키마가 변경될가능성이 항상존재
			간헐적캡쳐:데이터가 일정주기마다 동기화되니까,같은레코드에대한 변경은 개별적인이벤트로만 보임
			생산리소스낭비:쿼리실행할땐 레거시시스템의 리소스를써야해서,생산시스템의 지연시간이 너무커질수있음
			데이터변경시 쿼리성능변화:계속 쿼리날려야하니까 그 변경규모에따라서 쿼리시간이 계속 왔다갔다함
		이 있음
	4.로그로 데이터해방
		이건 mysql같이 cdc로그를 뽑을수있으면,그걸활용해서 데이터해방을 할수있음
		모든 데이터세트에 발생한일의 로그를 뽑고,그걸기반으로 하는거임
		이때 테이블생성시부터 모든 로그를 뽑을순없기때문에(보통 주기적으로지우니까)현재상태를 스냅샷찍고,이 이후로부터 로그를 이용해 계속 갱신함
		이때 로그로부터 데이터소싱할땐 데베지움같은걸 쓰거나 할수있음
		
		로그의 장점은
			삭제추적이 가능:하드삭제도 상관없음
			db성능에 영향이 별로안감:로그만쓰니까
			저지연업데이트:이벤트가 로그에 적히면 바로 업데이트전파가능하니까 지연시간이 매우짧음
		단점은
			내부데이터모델 노출:로그쓰니까 완전노출됨
			저장소외부에서 반정규화:체인지로그에는 이벤트데이터만 있어서,db외부에서 반정규화가 일어나는데,
						    그래서 고도로 정규화한 이벤트스트림을 생산해야하게되면 소비자가 외래키조인과 반정규화를 처리해야함
			데이터세트 스키마와 출력이벤트 스키마간의 취약한 의존관계:db외부에서 데이터를 가져오기때문에,db스키마를 변경하는등의 일이생기는걸 막지못함
			
	5.아웃박스테이블로 데이터해방
		이건 cdc로그대상으로 지정한 데이터저장소에서 변경이 일어날때마다 해당 레코드를 아웃박스테이블에 발행하고,
		아웃박스소비자가 이벤트스트림에 기록하고 성공하면 아웃박스의 해당레코드를 삭제하는식
		각 로그대상마다 하나의 테이블을 두거나,모든걸 하나에 적을수있음
		
		내부테이블과 아웃박스테이블의 업데이트는 트랜잭션으로 묶어서,하나가 실패하면 다실패해야함,안그러면 단일진실공급원이 안되니까
		
		이패턴을 사용할땐 데이터저장소나 앱레이어중 하나는 직접 수정을 해야하는데,둘다 db개발자가 개입해야함
		아웃박스테이블에선 프라이머리키가 동일한 레코드가 짧은시간동안 여러번 업데이트될수있으므로,정렬식별자가 명확해야함
		이떄 주로 사용되는게 자동증가인덱스id,
		
		이패턴은 그 테이블이 위치한 db의 요청량이 2배가 된다는것이 단점임
		그리고 아웃박스테이블의 장점으론,아웃박스테이블을 내부테이블과 1대1로 맞출필요가 없고,아예 내부데이터모델과 달라도됨(좀더 단순화시켜도됨)
		여기서 내부데이터모델이 노출될일이 줄어듬
		그리고 스키마호환성도 보장할수있음,테이블에 이벤트가 기록되기 전후에 직렬화나 검증같은걸 수행하고,성공하면 진행,아니면 에러리턴하면됨
		그리고 아웃박스테이블에 쓰기전에 직렬화하면,모든 트랜잭션을 하나의 아웃박스테이블에 다 넣을수있음
		일반적으론 이렇게 많이쓰이는듯,이미 쓰고나서 출력때 직렬화실패하면,트랜잭션돌리기가 까다로워져서
		
		아웃박스의 장점은
			다수의언어지원
			사전스키마강화:삽입전 테스트로 스키마확인이 쉬움
			내부데이터모델 격리:db앱개발자가 아웃박스테이블의 어느필드에 쓸지 선택할수있어서 내부필드를 계속 격리할수있음
			반정규화:아웃박스테이블에 쓰기전에,필요한만큼 반정규화가능
		단점은
			앱코드변경이 필수
			비즈니스프로세스에 영향을미침(직렬화프로세스가 추가되니까)
			db에 영향을미침(2배로 작업량이 늘어나니까)
		
		이렇게 말고 트리거를 사용해서,변경된로우를 아웃박스테이블에 넣는거도 가능하긴함(자동으로 db에서 처리해줌 트랜잭션으로)
		이건 트리거실행중엔 이벤트스키마로 변경-검증이 불가능한경우가 많긴하고,비용도 비쌈
		트리거의 장점은
			대부분db가 지원
			규모가작을땐 오버헤드가 낮음
			맞춤로직이 가능함:특정필드의 하위세트만 노출시킬수있음
		단점은
			규모가커지면 리소스가 많이들어감
			변경관리가 복잡해짐(트리거수정이 필요할때 수정안하면 개판됨)
			확장성이 좋지않음(캡쳐할 데이터세트수만큼 트리거가 필요)
			사후스키마 강화:스키마강화는 아웃박스테이블에 발행후에만 발생시킬수있어서,문제있는레이블을 트랙잭션으로 돌리기가 힘들어짐
	
	
	6.데이터정의변경을 캡처대상데이터세트로
		관계형db에서 마이그레이션할땐,변경사항을 캡쳐해서 하는게 보통인데,이걸 이벤트스트림으로 생산할땐 문제가됨
		예를들어 양방향스키마호환성이 필요할땐,필드에 어떤값이 있을거라 기대하므로 기본값이 없는 널금지컬럼을 뺄수없어지고,이렇게 모호한상태가 됨
		이런경우엔(데이터규약을 깨야할땐) 반드시 새 데이터규약을 다시 체결해야함
		
		쿼리패턴은,쿼리시점에 스키마를 가져와서 이벤트 스키마를 추론할수있음
		새 이벤트스키마는 스키마호환성규칙을 이용해서 출력이벤트스트림의 스키마와 비교하면됨
		
		로그패턴은 데이터정의업데이트를 cdc로그의 일부로 캡쳐함,즉 로그에서 데이터정의변경을 추출해서 스키마표현형으로 추론하는것
		단 이건 지원하는db가 별로없음
		
		변경-데이터테이블캡쳐패턴은 내부상태스키마와 출력이벤트스트림 스키마를 연결하는 징검다리역할을 함
		앱검증코드나 db트리거중 하나라도 짝이 안맞으면 스택에 오류가쌓이고 데이터테이블에 데이터가 기록되지않음
		cdc테이블을 수정할땐 그에맞는 스키마호환성규칙에 따라 출력이벤트스트림과 호환되는 스키마를 정의해야함
		이걸로 예기치않은변경이 프로덕션에 스며들가능성을 줄일수있음
		
		
	7.이벤트데이터를 데이터저장소에 싱킹
		이벤트스트림데이터는 이벤트데이터를 소비해서 데이터저장소에 삽입하는 싱킹을 수행함
		일반적으로 싱킹은 중앙화프레임워크나 단독마이크로서비스를 사용해서 수행하고,엔티티,키없는이벤트,키있는이벤트 어느것도 다 저장할수있음
		이건 이벤트기반으로 개발되지않은 앱을 이벤트스트림과 통합할떄 유용함
		싱크 프로세스는 이벤트 브로커에서 스트림을 읽어서 특정 데이터저장소에 데이터를 삽입함
		또 앱과 독립적으로 작동하니,자신의 소비오프셋을 추적하고,데이터가 도착하는데로 db에 쓸수있음
		
		이건 보통 레거시시스템의 점대점결합을 대체할때 잘 쓰임
		또 배치기반의 빅데이터분석에도 자주 활용됨
		
		이걸 사용할때 주의해야할건
			소싱/싱킹은 책임이 팀간에 공유됨
			시스템이 프레임워크와 커넥터에 과도하게 의존하게됨
			
		이건 주로 더이상 개발할생각은없는데 유지보수만 하고있는거일때 주로 사용됨
		막 개발시작했으면 그냥 ms로가는게맞음
		
	
	
	
5.이벤트 기반 처리 기본	
	이벤트기반 마이크로서비스는
		입력이벤트스트림에서 이벤트를 소비
		이벤트를 처리
		출력이벤트를 생산
	최소한 이거 3개는 거쳐서 실행됨
	
	이벤트기반 ms인스턴스는 프로듀서/컨슈머클라이언트를 생성하거나,필요시 컨슈머그룹에 조인하고
	컨슈머클라이언트는 새 이벤트를 폴링해서 처리하고 필요출력이벤트를 내보내는걸 무한반복함
	
	1.상태비저장 토폴로지 구성
		마이크로서비스토폴로지를 설계할땐,사고방식이 이벤트기반으로 바뀌어야함
		여기는 소비자의 입력값으로 이벤트가 들어오면,거기에 반응해서 코드가 실행되는구조이기때문
		ms토폴로지는 본질적으로 이벤트에 수행하는 일련의 작업들이고,여기서 자기가 필요한 필터,변환등의 작업이벤트들을 선택해야함
		
		즉
			입력이벤트가 들어옴
			필터(값이 10보다 작으면 T 아니면 F)
			소수자리제거
			값출력
		이런식으로 돌아가게됨
		
		이 작업이벤트들의 종류는 변환과 분기,병합이 있는데
		변환은
			필터:기준을 충족하면 이벤트를 전파,0개이상의 이벤트를 리턴
			맵:이벤트키나 값,둘중 하나나 둘다를 변환해서 정확히 1개를 리턴,단순변환
			맵밸류:값만 변환해서 1개를 리턴
			맞춤변환:자기맘대로 로직을만들어서 변환해서 리턴
		분기는,조건에따라 조건에맞는 이벤트 스트림에 이벤트를 던지는것,에러가났을때 삭제하는게 아니라 에러스트림으로 던지는식
		병합은,여러 입력스트림에서 들어온 이벤트를 소비해서,하나의 출력스트림으로 보내는것
		
	2.이벤트 스트림 리파티션
		이벤트 스트림은 이벤트키와 이벤트 파티셔너로직에 의해 파티셔닝됨
		이벤트마다 파티셔너를 적용하면 이벤트가 기록될 파티션이 결정됨
		리파티션은 
			상이한 파티션수:다운스트림의 병렬도를 높이려고 파티션수를 늘이거나,코파티션을위해 다른스트림과 파티션수를 똑같이맞춤
			상이한 이벤트키:키가같은이벤트는 같은파티션에 배치되도록 이벤트키를 변경
			상이한 이벤트파티셔너:이벤트를 쓸 파티션선택로직을 변경
			
		중 하나이상을 이용해 새 이벤트스트림을 생산하는것
		
		보통 병렬도를 높이려고 파티션수를 늘이는거말곤,이걸할일이 거의없긴하지만,
		스테이트리스ms에선 소비자의 상태저장처리기가 소비할이벤트를 리파티션하는데 사용할수있음
		보통 파티셔너 알고리즘은 해시를써서 이벤트키기반으로 같은곳에 매핑함
	
	3.이벤트 스트림 코파티션
		코파티션은 어떤 이벤트스트림을 파티션수와 할당로직이 동일한 새로운 스트림으로 리파티션하는것
		이건 이벤트스트림의 키있는이벤트를,지역성을 추구하려고 다른스트림의 이벤트와 같은장소에 배치할때 필요함
		
		이건 출처가 어느스트림이든 상관없이,키가 동일한 이벤트를 동일한 노드에서 처리해야할때(상태저장작업등) 중요함
		즉
			8:a 9:s, 8:qw
			8:a,qw 9:s
			
			2:aa 2:bb , 2:y 3:r
			2:y,aa 2:y,bb
		이런식으로 키로 묶는것
		이렇게 서로 파티션수가 같고,같은키를 가진 레코드가 있을때,가장 키값의 갯수만큼 복사해서 값을 통일함
	
	4.컨슈머 인스턴스에 파티션 할당
		마이크로서비스는 각자 고유한 소비자그룹을 유지해서,자신이 소비하는 입력이벤트스트림의 오프셋을 집합으로 나타냄
		첫 소비자인스턴스는 해당 소비자그룹명으로 이벤트브로커에 등록되고,등록이끝나면 소비자인스턴스당 하나의 파티션을 할당함
		
		카프카같은 이벤트브로커는,그룹마다 첫등록클라이언트에 파티션할당임무를 맡기고,새인스턴스가 그룹에 조인하면 입력스트림의 파티션을 정확히할당함
		
		파티션을 다시할당해야할땐,경합을 방지하기위해 모든작업을 멈추고 다시 할당함
		
		스트림프레임워크를 쓰든,구현하든,대량데이터를 처리할떈 컨슈머ms를 여러 인스턴스로 실행해서 병렬처리해야함
		파티션 어사이너는 공평하고 안정된 방법으로 파티션을 여러 컨슈머인스턴스에 고루 분배함
		어사이너는 컨슈머그룹에 컨슈머인스턴스를 추가,삭제할때마다 파티션을 재할당함
		어사이너 컴포넌트는 브로커종류에 따라 클라이언트에 탑재되거나,브로커내부에서 관리함
		
		어사이너는 코파티션 요건을 모두 충족시키는 역할도 함
		코파티션된것으로 표시된 모든 파티션은,같은 하나의 컨슈머인스턴스에 할당되어야함
		그래야 어떤 로직을 수행할때 필요한 이벤트데이터하위집합이 정확히 할당되니까
		여러 이벤트스트림의 파티션수가 똑같은지 체크해서 그렇지않으면 예외를 던지는로직은 꼭 어사이너에 있는게좋음 
		
		파티션할당알고리즘의 목표는,파티션을 컨슈머 인스턴스 전체에 고루 분배하는것
		두번째는 리밸런스가 일어나는 도중에 재할당된 파티션수를 줄이는것,이건 샤딩을했을때 재할당떄문에 업데이트후 이상한샤드로 향할수있기때문에 중요함
		
		여기서 사용하는 전략은
			라운드로빈:전체파티션리스트를 만들고,인스턴스마다 라운드로빈으로 하나씩던져줌
					여기서 컨슈머인스턴스가 추가되면,부하분산을위해 다시 파티션할당을하는 리밸런스가 일어남
			정적할당:이건 특정파티션을 특정 컨슈머에 할당하는것,내부상태저장소에서 대용량데이터를 특정인스턴스에서 구체화할떄 유용함
				  만약 컨슈머인스턴스가 그룹을 떠나도,이거로하면 파티션이 재할당하지않은상태로 복귀할때까지 남아있음(설정할수있음)
			맞춤할당:외부에서 신호를 받거나,다른도구를 이용해 클라이언트요건에 최적화된 로직을 직접짤수도있음
			
		그리고 상태 비저장 처리인스턴스가 실패했을때 복구하는건,어짜피 상태저장안되니까 컨슈머그룹에 다시 인스턴스추가하면끝임
	
6.확정적 스트림 처리	
	스트림을 여러 파티션에서 소비할땐,순서대로 소비해야하기때문에 시간을 보려고 타임스탬프를 사용함
	그리고 이러다보면 가끔 순서가 뒤바뀌거나(비순차이벤트),아예 늦게오는경우(지각이벤트)도 있음
	
	이벤트기반 ms에선 두가지 주된 처리상태가 있음
		1.이벤트를 실시간에 가깝게 처리하는것(실행시간이 긴 ms가 주로함)
		2.과거부터 이벤트를 처리해서 현재를 따라잡는것(규모가 작은 신규서비스에서 주로함)
	둘다 확정적으로 처리를 하려면,ms가 동일한 출력을 내야함
	
	물론 외부영향을 받는(외부서비스를 처리한다던가)것들은 태생적으로 비확정적일수 있는데 이런걸 제외하고보면
	이론적으로는 가능한데 실제로는 네트워크이슈도 있을수있고,지연시간이 0이어야하고 그러니까 현실적으로 불가능함
	그래도 그에 가깝게는 할수있음
	
	1.타임스탬프
		이벤트는 언제 어디서나 발생할수있고,다른프로듀서가 생산한 이벤트와 조정이 필요한 경우가 많음
		그래서 일관성있고 동기화된 타임스탬프가 있어야함
		
		스트림에 저장된 이벤트는,오프셋과 타임스탬프를 둘다 가지고있음
		오프셋은 컨슈머가 이벤트를 어디까지 읽었는지,타임스탬프는 이벤트가 언제생성됐는지를 기록함
		타임스탬프를 사용하면 이벤트처리시점의 선후관계를 알수있어서,이벤트가 정확한 순서대로 처리됐는지를 알수있음
		이때 타임스탬프에서 중요한건
			이벤트시간:발생시점에 프로듀서가 이벤트에 할당한 로컬타임스탬프
			브로커인입시간:브로커가 이벤트에 할당한 타임스탬프,보통 이벤트시간을 사용해서 잘안씀
			컨슈머인입시간:컨슈머에 들어갈때의 시간,이벤트시간이나 월클럭(로컬)시간으로 설정함
			처리시간:컨슈머가 이벤트처리를 완료한 월클럭시간
		이렇게 사용됨
		이벤트가 발생하고,컨슈머에 들어가고,처리완료된시간을 전부 넣는식
		
		근데 저기서 로컬시간을 사용하니까,모든 컴퓨터들은 시간이 동기화되어야함
		완전히 동일할순없지만,대충 100ms라인까진 같으니까 그정도로 잡으면됨
		
		타임스탬프를 이용하면,여러 이벤트스트림과 파티션에 분산된 이벤트를 일관된 순서대로 처리할수있음
		대부분은 발생순서대로 정렬하고,스트림 처리시점과 무관하게 재연결과를 일관적으로 얻을수있으면됨
		오프셋으로 순서비교하는건 단일일땐 가능하지만,보통 여러스트림에서 이벤트받는경우가 많아서 사용되지않음
		
		막 스트림2개에서 예금과 인출을 받을때,
			예금:10(10초),20(20초)
			출금:-25(25)
		일때 순서대로보면 예금이 다일어나고 출금이니까 T가 나와야하는데,하나씩먹어서 10-25가돼면서 F가 나면 안되니까 타임스탬프가 필요한거
		
	2.이벤트 스케줄링과 확정적 처리
		이벤트를 일관되게 처리해야,나중에도 확정적 처리결과를 얻을수있음
		이벤트스케줄링은,여러 입력 파티션에서 이벤트를 소비할때,다음에 처리할 이벤트를 선택하는 프로세스임
		불변로그기반 이벤트스트림에선 오프셋순서대로 이벤트를 소비하는게 원칙이지만,정확한 결과를 얻기위해선 어느파티션에서 왔든 상관없이
		레코드에 기록된 이벤트시간에따라 처리순서를 정확히 바꿔야함
		
		이 이벤트스케줄링은 프레임워크의 기능중 하나지만,보통 컨슈머구현체에는 빠져있으니 넣어야함 쓰려면
		
		그리고 시간순서대로 이벤트를 처리하려면,타임스탬프로 사용할시점을 정해야하는데,보통 로컬이벤트시간을 사용하면됨
		생산-소비워크플로에서 한번씩만 발생하는데,월클럭이나 컨슈머인입은 앱실행시점에따라 달라지니까
		
		컨슈머는 이벤트 타임스탬프를 알아야 처리순서를 정할수있음,스탬프추출기를 사용해서 소비한이벤트에서 타임스탬프를 꺼내고,
		페이로드에서 키,값,메타데이터같은 정보를 획득할수있음
		추출기가 주어진 이벤트시간타임스탬프를 각 이벤트마다 세팅하면,컨슈머프레임워크는 이 타임스탬프를 이벤트처리내내 사용함
		
		그리고 이벤트기반토폴로지에서 비이벤트기반 요청을 외부시스템에 전달하면,비확정적 결과를 얻게될수있으니 조심
		
	3.워터마크
		워터마크는 처리토폴로지를 흐르면서,현재 ms의 처리이벤트시간을 추적하고,그 이전의 모든 데이터가 처리완료되었음을 선언하기위해 사용됨
		워터마크는 이벤트시간의 일정주기마다,혹은 몇개의 이벤트를 처리할때마다 갱신됨
		
		병렬적으로 이벤트를 받을때의 워터마크는,받은 전체 이벤트중 min을 적용하면됨,그러면 딱 그시간까지만 처리가 된거임
	
	4.스트림시간
		스트림처리기에서 시간을 유지하는 두번째방법은 스트림시간임
		이건 하나이상의 스트림에서 이벤트를 읽는 컨슈머가 처리된 이벤트중 가장 높은(최근의)타임스탬프를 유지하는것
		새로들어온 시간이 더 클경우 갱신하고,이건 절대 줄어들지않음
		그리고 각 이벤트를 그 다음이벤트가 처리되기전에 완전히 처리함으로서 시간을 유지함
		즉 2개이상을 지퍼처럼 하나로 묶어서 한줄로 만들고,맨마지막에 스트림시간이 제일큰게 오게 만듬
	
	5.비순차이벤트와 지각이벤트
		이벤트시간이 막 순서바뀌어서들어오면 비순차이벤트고,아예 엄청늦게오면 지각이벤트임
		만약 배치로 처리할경우엔 비순차라도 대충 받아서 순서바꿔주면되니까 상관없음,물론 지연시간이 늘어나는 트레이드오프는 있음
		근데 만약 무한히 업데이트되는 스트림의경우는,ms설계시 지연과 확장성요건을 고려해야함
		이건 기술요건만 아니라 비즈니스요건에까지 영향을 주니까,반드시 내 ms에서 비순차와 지각이벤트를 처리해야하나를 자문해야함
		
		이벤트를 지각으로 간주할지 여부는,자신을 소비하는 마이크로서비스관점에서만 판단할수있음
		
		워터마크에서 비순차이벤트는,t`가 w(t)이후에 들어오면 늦은것으로 간주,이건 해당노드에서 알아서처리
		스트림시간에서 비순차이벤트는,t`가 스트림시간이 t`만큼 증가한이후에 도착하면 늦은것으로 간주,이 이벤트는 하위토폴로지의 각 처리기가 알아서처리함
		
		비순차이벤트가 발생하는 이유는
			비순차데이터에서 소싱:애초에 이벤트만들때부터 순서가 틀렸을경우
			여러프로듀서가 여러파티션으로:즉 키가같은걸 여러ms에서 생산하고 그걸합칠경우,순서가 바뀌어서 들어올수있음(서로시간동기화를 하지않을경우엔)
			
		특정기간동안 발생한 이벤트를 취합하거나 일정시간이 경과하면 이벤트트리거하는 그런 로직에선,지각이벤트가 중요관심사임
		지각이벤트는 로직이 처리완료후에 들어온이벤트임
		
		윈도잉은 이벤트를 시간에따라 그룹핑하는것,특정시간동안 어떤키를 가진 이벤트를 대상으로 무슨일이 일어났는지알고싶을때 특히유용함
		윈도잉의 종류엔
			텀블링윈도:크기가 고정된윈도로,비는곳없이 시간별로 자름
			슬라이딩원도:크기는 고정되어있고,시간을 움직여서 자기맘대로 잡을수있음(시작시간을 정할수있음)
			세션윈도:크기가 맘대로 변하는,특정 이벤트(사용자가 행동을 멈춘)가 일어나면 거기서 끊김,그래서 중간에 갭이생길수있음
		이 윈도를 쓸땐,비순차이벤트를 반드시 고려해야하고,비순차이벤트를 얼마나 기다려야 지각으로 간주할지를 정해야함
		그러니까 지각의 발생률같은거와,얼마나 길게저장할지등을 고려해야함
		
	6.지각이벤트처리
		비순차,지각이벤트처리는 데이터중요도에 따라 달라짐
		금융거래같은건 언제들어와도 처리해야하고,온도나 힘같은 측정은 이미필요없어졌으니 폐기하면됨
		이건 어느정도까지 수용할수있을지도 요건에 명시해야함
		이벤트가 도착하길 기다릴수록,확정성은 올라가지만 지연시간은 길어져서 시간에 민감한 앱이나 sla가 빡빡한 앱에선 성능에 부정적영향을 줄수있음
		이때 이벤트처리방법은
			이벤트폐기:그냥 버림
			대기:일정시간동안 윈도결과출력을 늦춤,지연시간이 늘어나는만큼 확정성을 높이는것,시간이지날떄까진 윈도업뎃을 할수있음
			유예기간:윈도완료시 바로출력하고,일정기간동안 들어오면 업데이트하고 다시출력함(대기랑 똑같은데 일단 출력을한다는거)
	
	7.재처리 대 준실시간 처리
		불변이벤트스트림은,컨슈머그룹의 오프셋을 되감아서 특정시점부터 처리를 재연하는 재처리를 제공함
		이건 일반적으로 이벤트시간을 사용해서 이벤트를 처리하는 마이크로서비스에서만 수행하고,월클럭기반과 윈도잉에 의존하는ms에선 하지않음
		이벤트스케줄링은 이걸하기위해 아주중요함
		ms가 실시간에 가깝게 처리했던것과 동일한순서대로 이벤트가 처리되게 보장하기떄문
		
		스트림을 재처리해야할떈
			1.시작점 정하기
			2.어떤 컨슈머오프셋을 리셋할지 결정해야함
			3.데이터량확인,재처리해도 용량적으로 문제없을지 확인
			4.재처리시간확인,얼마나 리소스많이잡아먹을지(중단시간)확인
			5.영향도확인,만약 재처리과정에서 이메일 다시보낸다던가 그런거없는지확인
	
	8.간헐적실패와 지각이벤트
		실시간에 가깝게 처리할떈,이벤트가 늦게도착해서 폐기되거나했는데, 재처리할땐 스트림내부에서 원래 예상한대로 결과값이 나오는 경우가 있을수있음
		이건 이벤트를 생산하는 프로듀서중 한곳이 뻗어서,생산해야할 재고를 잔뜩안고 기절했다 일어나서 재생산을할떄,이미 쌓여있는 재고들을 생산할때나 이럴떄
		발생할수있음
		이러면 이벤트순서대로 발행하긴했지만,엄청늦었으니까 실시간에선 지각으로 표시되게됨,단 재처리할떈 일단 순서대로들어왔으니까 정상으로처리함
		이걸 해결하는방법은,뻗었을때 다 날리든가,이벤트처리전에 정해진기간동안 기다리든가,지각이벤트처리로직을 견고하게 컨슈머에 구현하든가로 처리할수있음
	
	
7.상태 저장 스트리밍
	보통 앱들은 요건상 상태를 어느정도 유지해야해서,상태저장스트리밍은 이벤트기반ms에서 가장 중요한 근간임
	
	구체화상태는 소스이벤트의 이벤트를 투영한것(불변)
	상태저장소는 서비스가 비즈니스의 상태를 저장하는곳(가변)
	
	둘다 상태저장ms에서 꼭 필요하고,폭넓게 활용되지만,둘을 구분해야함
	구체화상태는 ms에서 공통비즈니스엔티티로 사용할수있고,상태저장소에는 비즈니스상태 및 중간계산결과 저장을 할수있음
	
	ms를 설계할때 데이터를 어디저장할지 잘 생각해야함,상태를 저장/접근하는방법은
		처리기와 같은 메모리나 디스크에 저장(로컬)
		처리기외부의 스토리지에 네트워크로저장(s3버킷)
	가 있음,이건 클라우드랑 상관없이,논리적으로 어케구분되냐의문제
	
	이건 비즈니스역할과 기술요건에따라 선택하는데,그전에 체인지로그의 역할을 먼저 고려해야함
	
	체인지로그는 상태저장소에 담긴 데이터의 변경사항을 모두 기록한것,즉 이벤트기록이라고 봐도됨
	체인지로그가 변한 현재결과값이 상태저장소임
	체인지로그는 ms인스턴스 외부에 기록되는 영구적인 상태사본으로,상태를 재구성하고나 이벤트처리진행을 체크포인트하는데 사용됨
	체인지로그스트림은 최근 키/값 만 있어도 상태를 재구성할수있음
	이건 특히 내부상태저장소에서 높은성능으로 상태를 확장/복구할수있음
	확장/복구결과 새로 생성된 앱인스턴스는 자신에게 해당하는 체인지로그파티션에서 데이터를 로드하기만하면됨
	
	1.내부상태저장소에 상태 구체화
		내부상태저장소는 ms의 비즈니스로직과 같은컨테이너에 함께 둠
		이 상태저장소는 ms인스턴스가 있을떄만 의미가있고,둘다 같은기반하드웨어에서 실행됨
		
		각 인스턴스는 자신에게 할당된 파티션의 이벤트를 구체화하고,내부에서 각 파티션별 데이터를 논리적으로 분리함
		이렇게 논리적으로 나눠서 구체화해서,인스턴스는 컨슈머그룹 리밸런스후 회수된파티션상태를 그냥 삭제할수있음
		구체화상태는 파티션을 소유한 인스턴스에만 있어서,리소스누수가 생기고 진실공급원이 쪼개지는것도 막을수있음
		파티션이 새로 할당되면,스트림이나 체인지로그의 입력이벤트를 써서 재구성할수도있음
		
		보통 락스db같은걸 사용함
		
		전역상태저장소는 내부상태저장소의 특수한형태,할당된 파티션뿐아니라 해당 이벤트스트림의 모든 파티션데이터를 구체화해서,
		이벤트데이터 전체 사본을 각 마이크로서비스 인스턴스에 제공함
		즉,특정 스트림의 전역상태를 저장하는곳임(전체적인 상태값이 필요할때)
		
		이건 각 인스턴스에 전체 데이터셋이 필요한경우에 유용하고,자주쓰이면서도 변경될일이 별로없는 소규모데이터셋로 구성함
		각 인스턴스마다 전체데이터사본을 가지고있어,출력이 중복되거나 비확정적결과가 나올수있어서 트리거로는 적합하지않고,그냥 검색용으로 쓸때좋음
		
		내부상태를 사용하면 장점은
			개발자가 확장을 신경쓸필요가없음:모든 확장요건을 브로커나 리소스클러스터에 맡길수있음
			고성능디스크기반옵션:모든상태를 메모리에 올릴순없으니,싸게 ssd로 빼서 처리할수있음
			nas를 사용할수있음:nas를 로컬로 취급해서 사용할수있음,물론 통신량이 많으면 병목생기지만,
						  통신량이 많지않으면 컨테이너를 죽였다살려도 다시 붙이기편함
						  
		단점은
			런타임에 정의된디스크밖에 사용불가:디스크를 바꾸려면 껐다켜야하고,볼륨을 줄일수없음(이미차있으니까)
			디스크공간낭비:트래픽이 가장 몰릴때를 기준으로 잡을수밖에없음(껏다켜야하니까)
			
		가 있음
		
		내부상태에서 처리능력을 확장하고,실패한인스턴스를 복구하는건 상태복구관점에선 같은행위임
		새인스턴스나 복구된인스턴스나 새 이벤트를 처리하기전에,정의된상태를 전부 구체화해야함
		이걸하는 가장 빠른방법은,체인지로그를 다시 로드하는것
		
		그리고 구체화상태 레플리카는,파티션당 하나잡는게 보통이지만,두개이상잡아서 고가용성을 유지해서 인스턴스가 실패해도 상관없게할수도있음
		
		그리고 새로 생성된 인스턴스가 컨슈머그룹에 조인할떄,이 인스턴스에 할당된 모든 상태 저장파티션은,체인지로그에서 소비하면 다시 그대로 로그할수있음
		중요한건 로드하는시간동안은 새 이벤트를 처리할수없음(비확정적결과)
		
		체인지로그가 없으면,인스턴스에 할당된 입력이벤트스트림파티션의 맨 처음부터 쭉 올라가면서 복구해야함,시간은 더걸리겠지만 결과는같음
		이떄 주의점은,멱등적이벤트의경우엔 변화없게처리해야함
		
	2.외부상태저장소에 상태구체화
		외부상태저장소는 컨테이너외부에 존재하지만,보통 로컬네트워크안에 존재함(외부에있어도 상관없음 어짜피ip접근인데)
		이때 사용할수있는 기술은,관계형db,nosql,고가용성 분산키값저장소등을 사용함
		
		외부상태저장소를 공통 데이터스토리지 플랫폼에 둘수도있지만,데이터셋 자체는 다른 모든 마이크로서비스구현체와 논리적으로 당연히 분리되어야함
		마이크로서비스에서 구체화상태를 공유하는건,대표적인 안티패턴임,이렇게쓰면 상관없는제품과 특성이 단단하게 결합될수있음
		
		외부상태저장소의 장점은
			완전한 데이터 지역성:내부상태저장소와 달리,각 인스턴스가 접근 가능한 모든 구체화 데이터를 제공하기때문에,
						  많은요소간에 검색,외래키기반 쿼리등을 할떄 파티션지역성이 필요하지않음
			기술:이미 많이 사용하던 기술이라 따로 학습안해도됨,보통 faas나 프로듀서/컨슈머패턴을 사용
		외부상태저장소의 단점은
			여러기술을 관리해야함:기술의 갯수가 많아지고,서비스 소유자가 이걸 알아서 잘 관리해야함
			네트워크지연으로인한 성능저하:네트워크 지연이 발생하면 성능이 확떨어질수있음
			외부상태저장소 서비스이용료:보통 내부저장소보다 외부저장소가 더 비쌈,물론 유동적으로 용량조절은 가능하니까 계산기떄려봐야함
			완전한데이터지역성:외부저장소에 있는데이터는 처리량이 제각각인 여러 처리기와 파티션에서 비롯되어서,어떤 인스턴스가 얼마나 관여했는지 추론이어려움
						그리고 경합조건과 비확정적동작도 잘 살펴봐야함
		
		외부저장소에서 마이크로서비스를 확장,복구할떈 상태저장소접근에 필요한 인증정보만 새 인스턴스에 추가하면끝임,근데 이거랑다르게
		하부저장소를 복구/확장하는건 사용하는기술에 완전히 종속되게됨(mysql쓰면 거기서 하는대로 해야함)
		이때 사용할수있는 기술은,
			소스스트림:소스스트림의 이벤트를 초기부터 소비하면 상태저장소의 새로운 사본을 만들수있음,
				   중단시간은 길지만 재연하기쉽고,데이터만문제없으면 문제가없음
				   단 이건 앱전체리셋과 다름없어서,로직에따라 출력이벤트(이메일같은)거도 모두 재생성된다는것도 알고있어야함
			체인지로그:보통 외부저장소에선 안쓰지만,안쓸이유도없음,이거도 똑같이 저장소사본을 만들수있음,위랑똑같은데 좀 부하가적은거
			스냅샷:특정시점마다 계속 스냅샷을 찍어서 그값을 가지고가는것,상태가 멱등적일경우엔 오프셋과 구체화상태가 일치하는지 확인안해도됨
			     이때 오프셋을 스냅샷찍기 몇분전값으로 세팅할땐,유실되는 데이터가 없도록 주의해야함,그래야 이벤트의 적어도 한번이상이 만족됨
				 이게 불가능하면,컨슈머오프셋을 데이터안에 넣어 같이보관해야함(스냅샷에 같이보관)
				 
	3.재구성 대 상태저장소 마이그레이션
		새 비즈니스 요건을 반영하기위해,기존 상태저장소의 데이터구조를 변경하는경우가 많음
		기존이벤트에 새정보를 추가하거나,다른 구체화테이블을 조인하거나,새 데이터를 저장하는로직을 추가하거나
		이경우엔 재구성 또는 마이그레이션으로 데이터가 반영되도록 상태저장소를 업데이트해야함
	
		재구성은,마이크로서비스를 중지하고,입력스트림오프셋을 초기로 리셋하고,체인지로그나 외부상태저장소에 보관된 중간상태를 삭제하고,
		새버전을 시동하고 처음부터 입력스트림을 전부읽어서 상태를 재구성함
		이러면 로직에따라 새로운 상태가 정확히 구성되고,모든 새 출력이벤트도 만들어져서 이걸 구독하는 다운스트림 컨슈머에 전파됨
		이런 이벤트는 로직과 같이 출력포맷도 바뀌었을테니까,중복이벤트가 아니고 변경된 내용은 다운스트림으로 반드시 전파되어야함
		
		이걸위해선 입력이벤트스트림의 모든이벤트가 있어야함
		
		마이그레이션은,재구성이 너무 오래걸리고,영향에비해 너무 비싸니까,특정부분만 고치고 나머지는 그냥두자(db필드에 앞에건 null처리하고 그냥넣자)식임
		이건 시작코스트는 작고 변경도 쉽지만,바꿀때 영향을받는데는 없는지 잘 살펴야함(이건 비즈니스로직이 아니라서 비정합성이 있을수있음)
		
	4.트랜잭션과 실제로 한번 처리
		이벤트를 '실제로 한번 처리'하면,프로듀서와 컨슈머,브로커실패와 상관없이 단일진실공급원에 반영된 업데이트를 일관되게 적용할수있음
		실제로 한번 처리란,이벤트가 실패랑 상관없이,멱등적으로 한번만 적용되게하는것
		
		멱등적쓰기는 스트림에 이벤트를 한번만 쓰는기능으로,보통 다 지원함,
		이걸사용하면 중간에 실패해서 재시도해도 중복이벤트가 생기지않음
		
		트랜잭션을 지원하는 브로커도 있음,이거도 다수의 이벤트를 다수의 개별이벤트스트림에 원자적으로 묶어서,하나라도 실패하면 되돌리는식으로 지원함
		이걸 지원하지않는 브로커를 사용할땐,클라이언트에서 구현해야함
		
		직접 구현할떈,중복이벤트에 조심해야함,그리고 그냥 멱등적쓰기를 지원하는 브로커와 클라이언트를 쓰면 편해짐
		그리고 중복이벤트를 식별하고(이벤트id같은거로)그걸 폐기하는식으로 처리를해줘야함
	
	
8.마이크로서비스 워크플로 구축	
	이벤트기반으로 마이크로서비스를 모아서 워크플로를 구성할때 고려해야하는건
		워크플로 생성 및 수정
			워크플로내부의 서비스들은 어떻게 연관되는가
			워크플로를 수정할때,다운타임,여러마이크로서비스의 변경,모니터링과 가시성이 깨지지 않게 하려면 어떻게해야하나?
		워크플로 모니터링
			어떤 이벤트에대해 워크플로가 언제 완료됐는지 어떻게 알수있는지
			이벤트처리도중 실패하거나 막혔는지 여부의 판단방법
			워크플로의 전체상태 모니터링방법
		분산트랜잭션구현
			분산시엔 트랜잭션을 어떻게 구현할것인가(분산안할거면 상관없긴함)
			분산트랜잭션의 롤백방법
			
		여기에 사용되는 주요패턴이,코레오그래피와 오케스트레이션임
		
	1.코레오그래피 패턴
		코레오그래피 아키텍쳐는,고도로 분리된 ms 아키텍쳐를 가리키는 용어임
		마이크로서비스는 업스트림과 다운스트림과는 완전히 독립적으로,일체의 차단과 대기없이 이벤트가 도착하는대로 반응함
		즉,순수함수적으로 입력을넣으면 출력이 나옴
		
		이건 컨슈머가 업스트림 워크플로를 중단시키지않고도,자유롭게 사용할수있는 비즈니스정보의 재사용가능한 이벤트스트림을 제공하는일에 주력하고,
		모든 통신은 반드시 입출력 이벤트스트림을 통해 이루어지기때문에,코레오그래피에선 프로듀서가,자신이 생산한 데이터를 어떤 컨슈머가 소비할지 알수없고
		컨슈머가 어떤 로직을 적용할지도 알수없고 관심도없음
		
		이걸 사용하면 시스템이 느슨하게 결합돼서,조정이 줄어들어서 좋음
		
		코레오그래피의 워크플로는,마이크로서비스간의 관계로 정의됨
		함께 동작하는 일련의 마이크로서비스들은 각자 주어진 역할만 함
		코레오그래피의 워크플로는,각 마이크로서비스뿐 아니라,그들간의 관계도 포함하는 창발적행위의 한 형태

		직접호출 마이크로서비스와 이벤트기반이 다른점은,직접호출은 호출을 해야하니까 다운스트림에 대해 어느정도 알아야함(이름과 입력값,왜 그걸 불러야하는지)
		근데 이벤트기반은 그냥 스트림에 던지고,거기서 트리거가 일어나기때문에 아웃스트림에 대해 전혀 알필요가없어서 결합도가 더 낮아짐
		
		코레오그래피는 프로듀서서비스와 컨슈머서비스를 분리해서 각자가 할일을 독립적으로 수행하게 해주는 아키텍쳐라서,이벤트기반 아키텍쳐의 영역에 속함
		
		코레오그래피에서,처리단계의 마지막에 뭘 추가하는건 쉬운데,만약 중간에 2개를 순서를 바꿔야하면 좀 고려해야할게 많아짐
		일단 순서를바꿔도 돌아가나를 확인해야하고,바꿨을때 뒤에있는게 스트림을 제대로 먹을수있냐도 확인해야함
		즉 중대한 스키마변경이 불가피해짐
		
		그래서 서비스간 관계는 외부에서 이해하기 힘들기때문에,서비스수가 증가할수록 사정은 더 나빠짐
		
		코레오그래피를 모니터링할떈,워크플로의 규모와 범위를 잘 생각해야함
		코레오그래피는 개별적으로 분산되어있어서,특정이벤트의 진행상황을 알기 어려운경우가 많음
		그래서 매우 중요한 워크플로를 모니터링할땐,이벤트가 교착상태에 빠지거나,아예 실패할수있음을 고려하여, 
		출력이벤트스트림을 받아 상태저장소로 구체화할 필요가 있음
		
		예를들어 순서를 바꾸는등의 워크플로 수정이 일어났는데,한 이벤트만 계속 보고있으면,순수함수에 가깝기때문에 흘러가는걸 알기가 어려움
		그리고 서비스의 갯수도 엄청많기떄문에 알아보기가 힘듬
		그래서 진짜로 꼭 필요한 이벤트만 떼서 보는게 일반적
		
	2.오케스트레이션 패턴
		오케스트레이션 패턴은,중앙의 마이크로서비스(오케스트레이터)가 하위의 워커서비스들에 명령을 내린뒤 응답을 기다림
		즉 명령내릴애를 두고,걔한테 송수신을 시킴
		이건 명령을 수신한 마이크로서비스가 응답할때까지 기다려서,성공실패에 따라 결과를 처리함,그래서 코레오그래피와는 다름
		
		이걸 사용하면 워크플로를 하나의 마이크로서비스안에서 유연하게 정의할수있음
		오케스트레이터는,워크플로의 어느파트가 완료됐고,어느파트가 진행중이며 어느파트는 시작전인지를 계속 추적하고,
		스트림을 통해 워커에 명령을 전달하고,하위는 작업을 한 다음 스트림을 통해 오케스트레이터에게 반환함
		
		그리고 만약 결제3회후 실패던지는 로직이 있으면,3회처리하는건 오케스트레이터가 아닌,결제서비스에 넣어야함
		오케스트레이터는 시키기만하고,성공실패만 받아봐야함
		
		오케스트레이터가 아닌 마이크로서비스는 코레오그래피와 완전히 같음
	
		그리고 오케스트레이션은,이벤트기반이 아닌 직접호출방식도 당연히 가능함,이건 faas에서 유용함
		
		이 두방식(이벤트와 직접호출)의 차이는,
		이벤트기반은
			다른 이벤트기반 ms와 같은 i/o도구및 랙확장기능을 사용할수있음
			오케스트레이션 외부의 서비스를 포함한 다른 서비스가 스트림을 소비할수있음
			보존성이 더 좋음
			재시도장치가 내장돼있어서,실패시 재시도할이벤트가 스트림에 남아있음
		직접호출은
			스트림을 안거쳐도돼서 더빠름
			간헐적 접속문제를 오케스트레이터가 해결해야함
		즉,속도는 직접호출이 빠른데,보존성등 나머지는 이벤트기반이 나음
		
		그래서 메인은 이벤트기반으로 하고,외부api나 faas를 사용할땐 직접호출을 사용하는식으로 자주 쓰임
		
		오케스트레이터는 각 입출력 스트림과,요청-응답결과를 구체화함으로써 워크플로에서 이벤트를 추적함
		워크플로 자체가 오케스트레이터 내부에만 정의되므로,워크플로를 한군데서만 변경할수있고,
		많은경우에 부분처리된 이벤트를 중단시키지않고 워크플로를 변경할수 있음
		
		오케스트레이션은 결과적으로 서비스를 단단하게 결합시키기떄문에,오케스트레이터와 워커서비스간의 관계를 명확히 정의해함
		오케스트레이터는 워크플로를 오케스트레이션만 해야하지,워커서비스들에게 세부명령을 내리는건 전형적안티패턴임
		그러면 비즈니스로직이 여기저기흩어져 캡슐화가 잘 안되고,경계콘텍스트로 흐려지고 소유권도 분산됨
		그래서 오케스트레이터는 워커에 책임을 완전히 위임하고,자신이 수행하는 로직은 최소화하는게 좋음
		
		그리고 구체화상태를 쿼리하면,워크플로를 가시화할수있어서 특정이벤트의 진행상황및 워크플로에서 발생가능한 이슈를 파악하기쉬움
		또 오케스트레이터 레벨에서 모니터링,로깅을 구현하면,워크플로 장애를 유발하는 이벤트를 탐지할수있음
		
	3.분산 트랜잭션
		분산트랜잭션은,둘이상의 마이크로서비스에 걸쳐있는 트랜잭션을 말함
		마이크로서비스는 각자 트랜잭션을 처리하고 자기가한일만 되돌림
		이러한 이행/역전로직은 반드시 같은 마이크로서비스 안에 들어있어야함,그래야 롤백을 할수없어도 새 트랜잭션이 시작되지 못하게 할수있고,관리로도 편함
		
		분산트랜잭션은,가능한 구현하지않는게 좋음(리스크와 복잡도가 많이 증가됨),하지만 꼭 필요한경우가 있긴함
		없을경우가 더 복잡도가 커지게 되는경우
		
		이벤트기반 아키텍쳐에서 분산트랜잭션은,사가라고 불리고,여기서는 사가에 참여한 ms가 각자 트랜잭션에서 자신이 처리한분량을 알아서 되돌릴수있어야함
		정상처리액션과 복구액션은,사가에 참여하는 마이크로서비스가 간헐적으로 실패해도 시스템을 일관되지않은상태로 방치하지않게 멱등적이어야함
		
		코레오그래피에서 사가는 아주 복잡해질수있음
		처리중 장애가 발생하면,서비스가 자신이 변경한 내용을 롤백할수있어야함
		그래서 느슨했던서비스들이 단단하게 결합될수있고,전혀관계없던 서비스와 강력한 의존관계가 맺어지게될수도 있음
		이패턴은 단순한 분산트랜잭션,특히 바뀔일없는 워크플로에 맞음
		단 코레오그래피 트랜잭션은 참여한 각각의 스트림을 완전히 구체화해야하기에 진행상황 모니터링이 매우어려움
		
		그리고 실패했을때도,두개이상의 서비스가 스트림에 이벤트를 발행하면 안되기때문에,출력결과를 받는애는
		맨처음의 출력과,맨 마지막의 출력 두개를 둘다 구독하고있어야함(실패시는 맨처음에서 출력,성공시엔 맨마지막에서 출력)
		그리고 둘다 받더라도,진행중인 트랜잭션,교착트랜잭션의 상태는 얻을수없음,그래서 각 스트림을 구체화하거나,내부상태를 api로 표출해야함
		이래서 코레오그래피 트랜잭션은 순서가 매우중요하고,모니터링이 어렵고 취약해서 아주적은수의 ms에 맞음(2~3개의 서비스)
		
		오케스트레이션 트랜잭션은 워크플로의 어디서건 트랜잭션을 되돌릴수있는 로직을 추가함
		워크플로로직을 역전시키면,각 워커가 그에따른 복구액션을 제공하는식으로 롤백함
		얘는 타임아웃,사람의 입력등 다양한 신호를 지원함
		타임아웃을 활용하면,로컬 구체화상태를 주기적으로 체크해서,트랜잭션을 처리하는시간이 얼마나걸리는지 파악할수있고,
		사람의 입력으로 급할때 취소할수있음
		오케스트레이터는 본질적으로 중앙집중식이라서 어떤트랜잭션이라도 진행상황과 현재상태를 자세히 모니터링할수있음
		
		롤백을 했을때 해당이벤트를 최종적으로 어떻게 처리할지(재시도,폐기,앱종료,오류이벤트출력)정해야하고
		(보통은 출력스트림에 오류이벤트넣고,컨슈머가알아서하게함)
		그리고 여기서 롤백이 실패할경우도,어떻게 처리할지를 정해야함
		
		이래서 단일작성자원칙을 위배하지않고 모든 출력을 소비할수있는 코레오그래피와 다름
		또 오케스트레이터는 같은 출력스트림에서 진행중인 트랜잭션의 상태를 표출해서,워커가 결과를 반환하면 트랜잭션엔티티를 업데이트할수있음
		이러면 하부트랜잭션의 상태를 더 잘볼수있어서,스트림기반 모니터링이 가능해짐
		
		오케스트레이션트랜잭션은,워크플로를 유연하게변경할수있고,의존관계가 잘 들어나서 코레오그래피 트랜잭션보단 명쾌한 모니터링이 가능함
		물론 중앙집중작체가 오버헤드가 발생하긴하지만,코레오그래피보다 복잡한 워크플로도 돌리기쉬움
		
		
9.faas 응용 마이크로서비스		
	faas는 서버에서 실행시키는 함수임
	함수는 특정 트리거가 발생하면 실행되는 코드조각임,함수가 시작되고 쭉 실행되다가 작업이 완료되면 종료됨
	faas솔루션은 부하에 맞게 실행 함수 갯수를 늘리고 줄이기편해서,부하가 가변적인상황에도 대응이 쉬움
	
	faas는 정기적으로 실패하는 기본 컨슈머/프로듀서 구현체라고 생각하면됨,함수는 미리 정해진시간이 지나면 항상 종료되고,모든 연관연결과 상태도 같이 사라짐
	이걸 조심해야함
	
	1.함수기반 솔루션을 ms로 설계
		faas솔루션은 서로 다른 수많은 함수들로 구성되고,이들이 하는작업을 합하면,비즈니스 경계콘텍스트솔루션이 됨
		보통 aws 람다같은거 쓰는듯
		
		솔루션을 구성하는 함수와 내부이벤트스트림은 반드시 어떤 경계콘텍스트에 속해야함
		그래야 함수,데이터의 소유자가 분명하게 식별됨
		대규모로 구축할땐,기능,서비스,스트림에 관한 소유권문제를 잘 따져봐야함
		ms는 대부분 경계콘텍스트와 1:1매핑되며,여러 함수를 하나의 콘텍스트에서 사용할수있어서 n:1매핑도 많음
		함수를 너무 잘게쪼개면 경계선이 흐려질수있으니,어떤함수가 어디속하는지 제대로 분간해야함
		이떄
			데이터저장소를 외부컨텍스트에서 못보게 보호
			다른콘텍스트와 결합시엔,표준 요청-응답,혹은 이벤트기반 인터페이스로 소통
			어떤 함수가 어떤 콘텍스트에 속하는지를 나타낸 메타데이터를 엄격하게 관리
			경계콘텍스트에 매핑된 리포지터리 내부에서 코드를 관리
		
		오프셋은 함수가 시작되거나 처리가 완료될때 커밋되는데,이걸 처리가 완료된후에만 오프셋을 커밋하는게 좋음
		이렇게하면 이벤트가 적어도 한번 이상 처리되는것을 강력하게 보장함
		
		함수 시작시 커밋하는거도,사용하긴하는데 이건 좀 특수목적임
		이벤트 처리실패가 많고,이걸 해결하는데 데이터손실은 그렇게 중요하지않은곳에선 사용할수있긴함
		
		그리고 faas는 단일함수를 쉽게 작성하고,여러서비스에서 재사용가능하지만,
		그렇다고 막쓰면 경계콘텍스트안에서 무슨일이 일어나는지 알기어렵고 파편화될가능성이 높음
		그리고 함수의 소유권이 모호해지고 다른서비스에서 가져다쓰면,전역으로 영향을 어떻게줄지 모르게됨
		함수를 버저닝하면 좀 낫긴하지만,여러버전의 함수를 동시에 쓰면 문제가생길수도있음
		그래서 faas는 함수여러개보다 좀 큰함수 하나두는게 나음
	2.함수를 마이크로서비스로 개발	
		함수를 마이크로서비스로 개발할땐
			함수
			입력 이벤트 스트림
			트리거 로직
			메타데이터를 이용한 에러및 확장정책
		4가지 컴포넌트를 구현해야함
		
		faas의 첫컴포넌트는 함수 자신임
		처리할 이벤트배열을 events매개변수에 전달하고,이벤트엔 키,밸류,타임스템프,오프셋,파티션id값이 들어있음
		context매개변수엔 함수명,스트림id,함수의 잔여수명들이 들어있고
		이걸 함수를 트리거할 로직에 넣으면됨(이벤트기반에선 스트림에 뭐가 추가될떄마다 트리거떙겨지게하면됨)
		
		faas프레임워크는 이벤트가 이벤트스트림에 도착하면,함수를 트리거해서 배치를 넘겨주고 함수는 처리함
		끝나면 함수는 종료되고 다른이벤트가 올때까지 대기함
		이게 기본적인 스트림 리스너 패턴임
		
		그리고 함수가 시작할떈,콜드스타트와 웜스타트가 있는데
		콜드스타트는 함수가 진짜 처음 배정받거나 오래쉬다가,다시 준비하는 시간이고,웜스타트는 함수가 준비다된상태로 입력을 받아서 출력을 뱉는상태임
		콜드스타트를 하면 웜스타트로 바뀌고,그상태에서 처리하는것
		그리고 완료되면 중지되어서 동면상태가됨
		보통 faas프레임워크는 가능하면 종료된함수를 재사용하려고 시도함
		보통 갭이 너무길지않으면 트리거가 깨우면 보통은 일어남(끊어지지않으면)
		
	3.트리거로 함수시동
		트리거는 함수에게 처리를 시작하라고 알리는 장본인임
		얘를 어떤경우에 사용하냐면
		
		새 이벤트에 반응해 트리거(이벤트스트림리스너)는 스트림에 이벤트가 생성될때 트리거함,얘는 미리 정의된 컨슈머뒤에서 소비를 분리해서
		개발자가 작성할코드는 많지않음
		
		이벤트는 스트림에서 순서대로 배열이나,순서없이 함수에 직접 삽입됨
		하나의 함수가 여러 스트림에서 이벤트를 소비할수있게 스트림과 함수를 다중매핑할수도 있음
		함수결과는 데이터출력뿐아니라 함수의 성공을 추적하는 용도로 자신의 스트림에 출력할수도있음
		
		동기식으로 트리거할떈 함수가 다음이벤트를 발행하기전에 완료되어야함
		처리순서를 유지할떈 반드시 그렇게 처리해야하므로,스트림을 병렬처리하는데 제약이있고,
		비동기트리거를 쓰면 여러함수에 여러이벤트를 전달하고,작업을끝내고 결과를 보고함,단 이건 처리순서유지는 안됨
		
		배치크기와 배치윈도는 스트림트리거에서 중요한속성임,
		배치크기는 최대 몇개의 이벤트를 처리할것인가,배치윈도는 함수를 바로 트리거하지않고 추가이벤트를 최대 얼마동안 기다릴것인가를 의미함
		이 두개는 함수를 시작하는 오버헤드를 여러레코드에 분산시켜 비용을 줄이기위해 사용함(많이처리하는게좋으니까)
		
		
		컨슈머 그룹 렉 메트릭에 반응해서 트리거걸수도 있음,
		이러면 컨슈머그룹오프셋을 주기적으로 풀링해서,현재 컨슈머오프셋과 스트림오프셋간의 차이를 계산해서 랙을 감지할수있음
		이거도 스트림 리스너처럼 비faas마이크로서비스를 확장할때 사용됨
		
		랙 메트릭을 계산해서 모니터링 프레임워크에 전달하면,거기서 faas를 호출해서 스트림에 등록된 함수를 시작하라고 전달함
		이때 랙의 차이만큼 함수갯수를 다르게해서 부하를 줄이고 빨리처리할수도있음
		
		이게 이벤트스트림리스너와 차이점은,랙으로 트리거하면 함수는 자신이 시작할때까지 이벤트가 소비되지않음
		이렇게 시작된 함수는,브로커와 클라이언트간 연결,이벤트소비,오프셋 업데이트커밋등 할게 많음
		
		그리고 랙트리거가 함수를 너무 자주 트리거하면,보통 함수는 웜일테니까 그쪽 오버헤드는 아니고,딴데서 원인을 찾아야함
		
		
		스케줄에 따라 트리거할수도 있음,특정시간이나 날짜마다 트리거거는거임 
		
		웹훅에 반응해 트리거할수도 있음,깃헙에 뭐 올라오면 액션땡겨서 레포에 이미지넣는식으로 할수있음
		
		리소스변경에 따라 트리거할수도 있음,db에서 뭐 추가되거나 삭제,업데이트되면 반응하게하던가,파일이 변하던가 이런걸 잡을수도있음
		
	4.비즈니스 업무를 함수로 처리
		faas는 필요한만큼 유연하게 리소스를 프로비저닝하는 솔루션에 잘맞음
		상태를 저장하지않고,여러스트림을 확정적으로 처리할필요가없고,큐로 처리하는경우처럼,단순한거에 맞음
		특히 faas는 동시성과 확정성이 필요없는경우에 아주 잘 동작함
		만약 확정성이 필요해지면,스트림처리의 정확성과 일관성을 고민해야함
		코파티션된 데이터는 한번에 하나의 한수로만 성공적이고 일관되게 처리되기때문 
		
	5.상태관리
		함수는 수명이 짧아서,상태저장 faas기반 솔루션엔 외부상태저장서비스가 필요함
		faas는 보통 로컬에서 가져오지않기때문(유연성이 매우낮아짐,어디서실행되도 상관없는게 제일좋음)
		그래서 api로 상태를 조회,저장,갱신해야함
		ms의 애저엔 로컬상태저장기능이 있는거도 있긴함,필요하면 이런거쓰면됨
		
	6.함수에서 다른함수 호출
		함수가 다른함수를 실행하는건 흔하고,코레오그래피와 오케스트레이션도 같음
		함수간에 이벤트를 주고받는 비동기통신,요청-응답호출,혹은 이 둘을 조합한 방식으로 통신함
		구현방법은 faas프레임워크와 콘텍스트의 문제공간에 따라 선택하면됨
		보통 다중함수솔루션을 구현할땐 코레오그래피나 오케스트레이션을 사용함
		
		이벤트기반 통신패턴은  한 함수의 출력을 스트림에 넣어 다른함수가 소비하게 함, 
		경계콘텍스트는 여러 함수와 내부 이벤트스트림으로 구성되고,함수마다 구현된 트리거와 확장로직은 다양함
		각 함수는 자기 페이스에 맞게 이벤트를 받아 처리하고,주어진작업을 실행하면서 결과를 출력함
		
		이거의 장점은
			토폴로지안의 함수는 각각 자기작업이 끝나면 오프셋을 커밋해서 자신의 컨슈머그룹오프셋을 관리할수있음
			이벤트스트림 처리외엔 함수간 조정이 필요없고,코레오그래피와 오케스트레이션패턴도 적용가능
			이벤트처리중 실패해도,브로커에 이벤트가 남아있어서 재처리시 데이터손실이 없음
			
			
		직접호출패턴은,함수가 자기코드에서 직접 다른함수를 호출하는것
		호출하고 잊어버리는 방식으로 비동기호출하거나,동기호출을 하고 반환값을 기다리는식으로 작동함
		
		코레오그래피는,비동기호출할때 사용함
		얘는 로직에 따라 함수를 호출하고,실패,오류등의 책임은 다음함수와 faas프레임워크에 맡김
		즉 체인걸기 좋음
		얘의 단점은,처리가 성공했을때만 오프셋업데이트가 확실히 보장됨
		실패해도 뒤로 피드백은 없기때문에 오프셋커밋이 잘못될수도있음,
		단 이벤트손실이 별로 중요하지않으면 무시하면됨
		그리고 뒤의함수를 여러번호출하면 이벤트순서가 바뀔수도있음(비동기니까),이거도 순서안중요하면 상관없고
		
		오케스트레이션은 동기호출할때 사용함
		얘는 그냥 스트림에 트리거를 걸어서 받으면 밑의 함수들에 값 다보내주고 기다렸다가 순서대로 리턴해주면됨
		필요하면 함수의출력을 다시 체인걸어서 다음입력으로 넣고 그걸받아서 줘도되고
		이러면 동기식이니까 순서는 확실히 보장됨
		
	7.종료및 중단
		함수는 작업을 마치거나 할당된수명이 끝나면 종료됨
		그리고 이상태에서 오랫동안 부르지않으면 추방되어서,다시 필요할때 콜드스타트를 하는것
		
		함수가 종료되기전에,함수에 할당된 리소스와 오픈된 커넥션을 어떻게처리할지 정해야함
		컨슈머라면 인스턴스에 스트림파티션이 할당되는데,이걸 회수하지않으면 타임아웃될때까지 컨슈머그룹 소유권이 재할당안돼서 처리가 지연될수있음
		
		물론 함수가 항상 온라인상태면 굳이 저런처리를 할필요가없긴하지만,아니라면 모든 연결을끊고 스트림파티션을 할당하지않는게 좋음
		
	8.함수 튜닝
		함수는 워크로드마다 특정니즈가 있음,이때 실행중 사용하는 리소스를 최적화하면 성능을 높이고 비용을 낮출수있음
		
		함수마다 cpu,메모리를 따로 할당할수 있으므로,요건에 맞게 매개변수를 튜닝하는 작업이 중요함
		너무많으면 비싸고,너무적으면 함수가뻗거나 처리시간이 길어짐
		그리고 함수의 최대실행시간도 한정해야함,안그러면 무한히 함수가 돌아갈수있음,이건 배치크기와 밀접한 연관이 있음
		그리고 함수기반 솔루션의 콘텍스트에 속하는 상태저장소의 외부 io도 고려해야함
		일정하게 계속들어갈수도있고,산발적으로 할수도있으니까 딱맞는거보다 좀크게 잡아줘야함
		
		그리고 함수가 이벤트배치를 다 처리할수없으면,실패로 간주해서 해당배치를 재처리해야함
		근데 같은함수에 넣으면 당연히 똑같이 실패날확률이 높기떄문에,
			함수의 최대실행시간을 늘임
			함수가 처리할 이밴트 배치를 줄임
		둘중 하나는 해서 다시던져야함
		보통 aws같은데선 실패시 배치를 자동으로 둘로 나누어 처리하는기능같은게 있긴함
		
		faas는 작업의 병렬화,특히 처리순서가 중요하지 않은 데이터의 큐와 스트림에서 진가를 발휘함
		만약 순서가 중요하면,최대이벤트스트림의 파티션수까지만 병렬화가 가능함
		
		그리고 브로커에 스스로 접속해서 실행하는애들은,컨슈머가 그룹에 가입/탈퇴할때 발생하는 파티션할당 리밸런스의 영향도를 잘 살펴야함
		최악의경우 리밸런스교착으로,함수들이 파티션을 받고,다시 뺏겨서 수명이 끝나는 경우도 있음
		이런건 컨슈머 배치가 작은 단명함수를 많이쓸때 자주생기고,지연에 너무 민감해서 확장을 자주할때 더악화됨
		
		그래서 파티션을 정적으로 할당하는경우도 있음,이경우엔 리밸런스가 전혀 일어나지않고,함수가 트리거될떄 그냥소비하면됨
		단 이때는 파티션이 잘 소비되는지,함수는 잘 작동하는지를 잘 살펴야함
		
10.기본 프로듀서/컨슈머 마이크로서비스
	기본 프로듀서/컨슈머(bpc)는 하나이상의 스트림에서 이벤트를 받아 로직을 적용하고 필요시 출력스트림에 이벤트를 내보내는 ms임
	
	bpc는 프로듀서/컨슈머 클라이언트를 사용하는게 특징임
	컨슈머 클라이언트는,이벤트 스케줄링,구체화,체인지로그,로컬저장소를 이용한 수평확장등은 하지않고,이런기능은 더 큰 프레임워크에서 제공함
	
	이건 그냥 아무언어로나 쉽게 구현되니까 쉽고,경계콘텍스트의 전체 워크플로가 하나의 ms코드에 포함되어있어,로직이 로컬화되어있고 이해가쉬움
	또 워크플로를 하나이상의 컨테이너로 쉽게 래핑가능해서,쿠버네티스같은거로 배포실행이 쉬움
	
	1.bpc의 올바른용도
		bpc는 완전한 기능을 갖춘 프레임워크에 내장된 컴포넌트는 없지만,폭넓은 비즈니스요건을 충족할수있음
		확정적 이벤트스케줄링이 필요없는 상태저장패턴이나 상태 비저장변환같은 단순한패턴은 구현이 쉬움
		
		bpc구현체는 보통 내부저장소보다 외부상태저장소를 많이씀,스테이트리스가 편하고 구현할게 별로없기떄문
		만약 내부를쓰면 확장이나 실패했을때 복구하는거때문에 배보다 배꼽이 더커짐
		
		이걸 사용하기 좋은 케이스는,
			기존 레거시와 통합:기존레거시를 그대로두고 어댑터(사이드카)를 붙이는식으로 프론트엔드에 별다른 수정을 하지않고 백엔드단에서
			레거시를 이벤트기반으로 만들수있음,이벤트기반으로 백엔드에서 생산-소비를 하고,그걸 묶어서 원래보내던대로 던져주면됨 프론트에
			이경우 사이드카는 프런트엔드의 배포체의 일부분이 되어야함
			
			이벤트 순서와 무관한 상태저장 비즈니스로직:이벤트가 도착하는 순서는 상관없는데,이벤트가 전부 도착해야하는 요건이 있을떄(게이팅패턴)
			이걸 bpc로 하기좋음
			그냥 뭐가 하나 삽입할때마다,다른애들이 다 있는지 확인하고 다있으면 리턴하면됨
			
			데이터레이어가 너무 많은일을 할때:데이터레이어에서 너무많은 일을할때,이걸 좀 나눠갈수있음
			즉 역할이 너무 많을떄,걔가 꼭 필요한일은 해야겠지만,단순하게 통합하고 분리해주는건 대신할수있음
			
			독립적으로 처리 및 데이터레이어 확장:만약 시간대별로 ms가 처리할 이벤트량이 다를경우에 시간대별로 컨테이너갯수를 다르게해서 처리하면됨
			
	2.하이브리드 bpc앱으로 외부 스트리밍 처리
		bpc는 외부 스트림 처리 시스템을 활용해서,로컬에서 처리하기 어려운 작업을 수행할수있음
		이건 bpc와 외부 스트림 처리 프레임워크사이에 로직이 흩어져있는 하이브리드 앱패턴임
		
		bpc구현체는 필요한 언어기능과 라이브러리에 계속 접근할수있고,다른방법으로는 힘든 작업들을 수행할수있음
		예를들어 bpc ms에서 로컬데이터저장소에 결과를 적재하고,요청-응답쿼리를 서비스하고,
		외부스트림처리프레임워크로 여러 스트림에서 복잡한집계를 수행할수있음
		
		즉,간단간단히 상태변화시켜서 다른데 던져주는거나,응답을 요청하고 처리하는거,여러응답을 받는것들을 동시에 처리해서 출력으로 보내줄수있음
		(단순하게 함수2개불러서 출력받아서 묶어서 던져준다고만 생각해도 이렇게됨)
		그리고 bpc가 완료되면,좀비프로세스가 남으면안되니까 외부 스트림인스턴스(간단히 내가실행시킨 함수같은거)도 같이종료해줘야함
		
		이거의 장점은,다른방법으로는 어려운 스트림처리를 ms에서 활용할수있다는것,보통 sql기반 스트림작업은 이패턴을 잘 쓸수있음
		
		단점으로는 복잡도가 증가함,외부 스트림 처리 프레임워크를 테스트환경에 통합해야해서,테스트가 복잡해지고 스트리밍프레임워크를 도입해도
		가동부가 늘어나고 오류가 날 가능성이 높아져서 디버깅과 개발복잡도가 증가함
		그리고 ms의 경계콘텍스트처리가 더 어려워져서,앱의 배포,롤백,작업을 쉽게 관리할 방안이 필요함
		
		
		
11.대용량 프레임워크 마이크로서비스	
	보통 완전한 기능을 갖춘 프레임워크를 스트리밍 프레임워크라고 부르고,이런 애들은 데이터 스트림을 처리하는 메커니즘과 api를 제공하고,
	브로커에서 이벤트를 생산/소비하는 용도로 많이 사용됨
	스트리밍 프레임워크는 대용량과 경량 두개로 분류됨
	
	대용량의 특징은 작업을 수행하는 처리 리소스의 독립클러스터가 필요하다는것
	이 클러스터는 보통 스케줄링과 조정역할을 맡은 마스터노드와 워커노드로 구성됨(쿠버네티스랑 비슷)
	그리고 아파치꺼는 거의다 아파치주키퍼라는 클러스터서비스로 고가용성을 지원함
	
	또 다른 특징은,장애처리,복구,리소스할당,작업분배,스토리지,통신,처리 인스턴스와 태스크조정메커니즘을 가지고있음
	보통 경량들은 이런걸 다 떼둬서 cms(쿠버네티스)와 브로커에 전적으로 의존함
	
	이특징이 대용량 프레임워크라고 부르는이유임,즉 cms와 브로커가 하는일을 얘들이 다 하는거임
	
	얘들이 작동하는 방식은,대충 쿠버네티스랑 비슷하게 돌아감
	마스터노드가 있고,워커노드에 컨테이너를 뿌리고,이벤트브로커에 접속해서 거기있는걸 소비해서 작업을 함
	여기서는 컨테이너를 잡이라고 부름
	잡은 sdk를 사용해서 구축한 스트림 처리 토폴로지임
	그리고 잡이 마스터노드에 가면,자동으로 태스크(파드라고 보면됨)로 바뀌어서 워커노드에서 실행됨
	실행시간이 긴 태스크는 브로커에 접속하고,스트림에서 이벤트를 받아서 소비함
	
	보통 이런 프레임워크들은 주로 분석기술임,대용량 이벤트를 실시간에 가깝게 분석해서,의사결정을 신속하게 내릴수있게해줌
		데이터 추출,변환후 새 데이터저장소에 적재(ETL)
		셰션/원도 기반 분석수행
		이상동작 패턴 감지
		스트림 집계 및 상태관리
		모든종류의 상태 비저장 스트리밍 작업
	같은곳에 주로 사용됨
	
	대용량 프레임워크의 단점은
		원래 ms배포를 감안한 프레임워크가 아니라서 복잡도가 높아짐
		자바가상머신 기반이라 언어가 한정됨,그래서 다른언어로 상태저장소에 넣고,저거로 처리하는식으로 사용함
		엔티티스트림을 무한보존하는기능이 바로 지원되지않아서,게이팅패턴같은걸 구현할수없음(되는거도 있긴함 프레임워크따라)
		
	
	이 대규모 프레임워크를 구성할땐
		서버를 빌려서 올림(aws,구글,ms같은데서 다 있음)
		로컬에 구축
		cms와 연계,이렇게하면 쿠버네티스같은곳의 로그나 리소스관리기능을 쓸수있어서 편리함,확장할떄도 노드타입을 추가삭제하면됨
	
	그리고 앱을 클러스터에 제출해서 처리를 요청하는 방법은,드라이버와 클러스터 두가지모드로 나뉨
	
	드라이버는 스파크,플링크에서 지원됨
	여기서 드라이버는 앱을 조정/실행하는 하나의 로컬 단독형 앱임
	앱역시 자체 클러스터 리소스안에서 실행됨
	드라이버는 클러스터와 연동되어 앱을 관장하며 에러보고,로깅들의 작업도 수행함
	드라이버가 종료되면 앱도 종료되니까 간단히 배포/종료하기 좋음
	드라이버를 종료할땐 그냥 ms처럼 정지시키면됨
	
	클러스터는 전체 앱을 실행/관리하기위해 클러스터에 제출하면 id를 반환하고,이 id를 기반으로 식별하고 명령을 내림
	이때 종료하려면 클러스터가 그 id로 종료신호를 줘서 종료함
	
	1.상태 처리와 체크포인트 활용
		상태 저장작업은 보통 내부,외부중 하나로 할수있지만,대용량의 경우 성능과 확장성을 중시해서 내부상태를 선호함
		이때 상태저장레코드는 빠른 액세스를위해 메모리에 유지하며 상태가 점점 늘어나 가용메모리를 초과하면 디스크에 기록해서 데이터를 보존함
		내부상태를 쓰면 디스크고장나거나하면 머리아프지만,성능향상폭이 커서 잘 사용되나봄
		
		체크포인트는 현재 앱의 내부상태를 찍은 스냅샷임,확장또는 실패후 상태를 재구성할때 사용되고,
		손실을 방지하기위해 워커노드 밖에있는 영구스토리지에 보관함
		이때 체크포인트로 파티셔닝된 스트림을 소비/처리할땐
			오퍼레이터 상태:id,오프셋 쌍을 내부키상태와 파티션별 컨슈머오프셋을 똑같이 맞추어야함,id는 전체입력토픽을 통틀어 유일한값임
			키상태: 키,상태 쌍을 상태저장작업과 같이 키있는 엔티티에 해당하는 상태를 맞춰야함
		이 두개 모두 기록을 동기화해서,오퍼레이터 상태가 소비한것으로 표시된 모든 이벤트의 키상태가 정확히 반영되게해야함
		안그러면 처리가 안되거나,두번이상 처리될수가 있음
		
		새 데이터를 처리하려면 그 전에 앱테스크와 연관된 상태를 체크포인트에서 완전히 읽어야함
		
	
	2.앱 확장과 이벤트 스트림 파티션 처리
		대용량 앱의 병렬도는,파티셔닝이 가장 덜된 스트림의 입력갯수만큼 제약을 받음
		보통 얘들은 사용자가 생성한 대량의 데이터를 처리하기때문에,낮밤으로 주기성을 가짐
		그래서 오토스케일링같은거로 규모를 변경하면 돈을 아낄수있음
		
		보통 상태비저장 앱은 규모 확장/축소가 매우쉬움,그냥 갯수늘이고 줄이면됨
		상태 저장앱은 방식이 여러개로 나뉨
		
		앱을 실행중에 확장하려면,하나가 늘어나면 다시 셔플하고 재배포해야하기때문에(최종 체크포인트에서 다시 로드)
		지원하는 프레임워크가 별로없음(스파크는 지원)
		
		앱을 재시작하는건 그냥 끄고 추가하고 다시키면돼서(끄기전에 체크포인트지정하고 키고 로드하면됨) 다 지원함
		
		앱 자동확장은 매트릭에 따라 앱을 자동확장하는 프로세스임,쿠버네티스 hpa랑 비슷함
		
	3.실패복구
		대용량클러스터는 실행시간이 긴 잡이 실패할떄도 가용성을 최대한 확보하는 방향으로 설계되어있음
		워커노드가 실패하면 이노드의 작업을 다른 가용한워커로 옮기고,파티션을 할당하고 최근 체크포인트를 로드하는식
		마스터노드가 실패하면 고가용성이면 다른데로 리더 옮기고,아니면 그냥 최대한 부팅시켜보려고 하지만,원래 돌아가던애들은 되지만
		새로 배포하는애들은 배포할수없음
	
	4.멀티테넌시 이슈
		앱이 늘어날수록 리소스획득의 우선순위등의 경합들이 발생할수 있음
		이걸 해결하기위해 네임스페이스로 태스크를 분리해서 리소스를 배분할수있는데,트레이드오프로 항상 일정량이 여유로 남게됨(항상 저하된상태)
		아니면 클러스터를 더 작게 여러개실행할수도 있음
	
	
12.경량 프레임워크 마이크로서비스
	경량 프레임워크는 대용량프레임워크에서 뺄수있는거 다빼고,그건 브로커와 cms에 맞기는 프레임워크임
	앱은 개별 마이크로서비스로 배포되고,병렬도는 컨슈머그룹 멤버쉽과 파티션소유권으로 조정함
	
	경량프레임워크는 스트림을 간편하게 조인하고,테이블로 구체화할수있어서 관계형데이터와 스트림을 쉽게 처리할수있음
	
	경량프레임워크는 브로커를 적극 활용해서,내부 이벤트스트림을 통한 데이터 지역성 및 코파티션을 제공함
	브로커는 체인지로그를 사용해 서비스의 내부상태를 저장하는 저장소 역할도 함
	cms를 사용하면 다른 이벤트기반앱처럼 경량ms를 배포할수있고,인스턴스 추가삭제만으로 병렬도조절이 쉬워짐
	단점으로는 선택지가 그렇게 많지않음
	
	기본적으로 키기반 작업을 할땐 키가 같은데이터가 반드시 같은 처리인스턴스의 로컬에 있어야함,그래야 스트림을통해 이벤트를 전송하고
	인스턴스끼리 직접통신하지않고 키가 같은 이벤트를 한 파티션에만 쓰는것
	경량프레임워크는 이런 통신경로를 브로커가 제공하고,브로커와 경량앱이 긴밀하게 통합됨
	
	경량프레임워크는 기본적으론 브로커에 저장된 체인지로그를 기반으로 내부상태를 사용함
	이떄 다양한 스토리지엔진도 사용가능해서,모델과 쿼리엔진이 다른 외부상태저장소를 사용할수도 있음
	즉 대용량이 체크포인트를 썼다면,경량은 체인지로그를 사용함
	
	마이크로서비스를 확장하는것과 복구하는건 같은프로세스임
	실패든 확장이든 앱 인스턴스를 추가하려면,파티션과 거기에 맞는상태를 정확히 할당해야함
	제거할때도 똑같이 파티션과 상태를 다른 가용인스턴스에 재할당해서,처리가 끊기면 안됨
	
	경량의 가장 중요한 이점은,앱이 실행중인상태에서도 동적확장이 가능하다는것
	실제로 쿠버네티스를 사용하니까,그룹을 리밸런스하고 상태를 체인지로그에서 다시 구체화하는 과정은 필요하겠지만,
	앱재시작을 할필요는 없음(상태가 없고 외부에서 받으니까 그냥 다시 올리면됨)
	이때 중요한건
		이벤트셔플링:다운스트림에서 소비가능하게 이벤트를 내부스트림으로 리파티션해서,경량ms는 셔플링이 단순함
		이 내부이벤트스트림은 셔플된 이벤트를 생성하는 업스트림인스턴스와 이벤트를 소비하는 다운스트림 인스턴스를 서로 분리하고,동적확장을 위해
		대용량에서 한것과 비슷하게 셔플서비스 역할을 함
		그래서 프로듀서와 무관하게 컨슈머를 내부스트림에 할당하면 동적확장이 가능함
		
		상태할당:확장시 새 내부상태를 받은 인스턴스는 새 이벤트를 처리하기전에 반드시 체인지로그의 데이터를 로드해야함
		이과정은 대용량이 영구저장소에서 체크포인트를 로드하는것과 비슷함
		전체 스트림 파티션의 오퍼레이터상태는 컨슈머그룹내부에 저장되고 앱내부의 키있는상태는 체인지로그내부에 저장됨
		이때 상태를 재로드할땐,앱인스턴스는 새 이벤트를 처리하기전에 먼저 모든 내부상태의 소비/로드 우선순위를 정하고 돌리고나서 새이벤트를 처리해야함
		안그러면 비확정적결과가 나오기때문
		
		상태복제와 핫레플리카:핫레플리카는 체인지로그에서 구체화된 상태저장소의 사본임
		얘는 기본적으로 메인인스턴스가 실패했을때를 대비한 장치지만,상태저장앱의 규모를 줄일때 사용하기도함
		인스턴스종료후 컨슈머그룹이 리밸런스되면,파티션이 할당되고,핫레플리카의 상태를 사용해서 중단없이 처리를 이어가게됨
		그래서 새노드의 상태를 재구체화할때도 중지안하고 끊김없이 인스턴스수를 늘릴수있음
		
	경량프레임워크는 쓸수있는게
		아파치 카프카 스트림즈
		아파치 삼자
	밖에 없긴함
	
	그리고 둘다 자바기반이라 jvm기반 언어만 사용할수있음
	
	
13.이벤트기반 ms와 요청-응답 ms의 통합
	이벤트기반이 강력하긴한데,모든 비즈니스요건을 만족시킬수있는건 아님
	그럴땐 요청-응답과 통합해서 쓰면 됨
	이런게 유효한건
		외부소스(폰에깔린 앱)에서 메트릭수집
		기존 요청-응답과 연계
		웹,모바일기기 사용자에게 실시간콘텐츠 제공
		날씨,시간등 실시간서비스
	등이 유효함
	
	1.외부이벤트처리
		보통 외부이벤트는 요청응답api로 처리됨
		이때 두가지로 나뉘는데
			자율적으로 생성된 이벤트(외부소스에서 던져주는 이벤트)
			반응하여 생성된 이벤트(어떤 서비스의 요청에 반응해서 생성된 이벤트,응답을 받아야하는경우와 안받아도되는경우로 나뉨)
			
	2.자율적으로 생성된 분석 이벤트 처리
		분석이벤트는 한군데모아서 주기적으로 한꺼번에 전송하거나,발생즉시 전송함
		둘다 요청응답api로 전송되고,여기서 해당이벤트스트림으로 전달됨
		외부클라이언트는 분석이벤트를 이벤트수신기서비스로 보내고,여기서 출력이벤트스트림으로 이벤트를 전달함
		
		대규모 분석이벤트를 소비할땐,스키마화 이벤트가 필요함
		스키마에는 어떤 정보가 수집됐는지 명시되어있어서 나중에 사용자가 이벤트를 올바르게 이해할수있음
		스키마는 버전제어및 진화메커니즘을 제공하고,이벤트를 채워넣고,검증하고,테스트하는 책임을 컨슈머가 아닌 프로듀서에 넘김
		그래서 컨슈머서비스는 이벤트를 파싱할필요없이 그냥 받아보면됨
		
		버전이 여럿인 코드를 실행하는 기기에선 분석이벤트를 수집할때 제약이 많음
		특히 폰에서 실행되는건 버전이 많아서,하위버전을 강제로 업데이트시키는식으로 해야하는데,매번업데이트마다 그럴순없으니까 거기에대한 대책도 수립해야함
		그리고 인입된 이벤트를 스키마와 이벤트 정의에 따라 정해진 이벤트스트림으로 분류해야함
		
	3.서드파티 요청응답 api 연계
		이벤트기반ms는 서드파티api와 통신할일이 많음
		요청응답패턴은 단순히 요청과 응답을 원격함수호출처럼 처리해서,이벤트기반처리와 잘맞음
		ms는 이벤트기반 로직에 따라 api를 호출하고,응답을 기다리고 응답이 도착하면 파싱해서 스키마를 준수하는지 확인하고,로직을 적용함
		
		이패턴의 장점은 
			로직을 적용하는동안 요청응답api와 이벤트처리를 혼합할수있고,서비스는 필요한 모든외부api를 호출할수있음
			엔드포인트에 수많은 논블로킹요청을 해서 이벤트를 병렬처리할수도 있음(이렇게하면 처리순서유지는안됨)
		단점은
			결국 외부서비스를 쓰니까 비확정적결과가 나올수있고
			외부서비스에서 너무요청많다고 막아버리면 다실패날수있음
	
	
	4.상태 저장 데이터 처리 및 서비스
		이 원칙에 따라 상태를 랜덤엑세스하는 요청응답 엔드포인트를 제공하는 이벤트기반ms를 구축하는 방법도 있음
		이러면 ms는 입력이벤트스트림에서 이벤트를 소비/처리하고,로직을 적용해서 앱에 맞게 내부,외부저장소에 상태를 저장함
		이 저장소는 요청응답api로 접근할수있음
		
		내부에서 실시간요청을 처리할땐,ms는 내부상태에서 소싱한 결과를 제공할수있음
		이때 클라이언트요청이 로드밸런서에 전달되면,로드밸런서는 요청을 하부ms인스턴스중 한곳으로 흘리고,
		이때 키있는 값은 오직 하나의파티션에 할당되고(키 별로 하나의파티션),파티션은 하나의 컨슈머인스턴스에만 할당됨(두개이상에서 못나눠가짐)		
		이때,만약 라운드로빈으로 배분하고 그걸 찾으려면 요청이 히트할 확률이 인스턴스수만큼 나눠짐
		그래서 해시값을 사용해서 처리하는 스마트로드밸런서등을 사용할수있음,이떄도 잘못전달될수있기때문에 리다이렉트하는 기능은 있긴해야함
		
		
		외부에서 실시간 요청을 처리할땐,각 인스턴스가 모든상태를 사용할수있음,즉 내부스토리지모델에 따라 데이터를 호스팅하는 ms로 요청을 전달할필요가 없음
		그리고 컨슈머그룹 리밸런스가 일어나도,ms가 새 인스턴스의 내부상태를 다시 구체화할 필요가 없음
		그래서 내부상태저장소로는 어려운,끊김없는 확장 및 무중단 가동이 가능함
		이때 각 ms인스턴스는 입력스트림에서 이벤트를 소비후 외부상태저장소에 데이터를 구체화함,구체화데이터를 요청한 클라이언트에게 돌려주는 api는
		각 인스턴스마다 제공함
		즉 이렇게되면 인스턴스는 외부상태저장소의 전체데이터를 관측할수있어서,어떤요청이든 처리가능함 
		이경우엔 단순히 인스턴스수를 조절함으로서 규모를 늘이고줄이는게 가능해지니까 편해짐
		
		그리고 상태를 구체화하는  이벤트기반ms와 요청응답api를 완전히 분리하면,이벤트처리기와 독립적으로 작동하지만 둘다 같은콘텍스트에 있고,
		배포패턴도 동일함
		이경우엔 api와 이벤트처리기가 서로 완전히 독립적이라서,언어도 달라도되고 확장도 편함
		단점으론 한쪽이 데이터구조를 변경하면 둘다영향받으니까 뭐 바꾸는게 좀 짜증남(결합도가 높아짐)
		그래도 데이터를 실시간으로 제공할때 잘 쓰이는패턴
		
	
	5.이벤트기반 워크플로 내에서 요청처리
		비이벤트기반 시스템에서 하던거처럼 요청을 받아서 작업을 하고 클라이언트에 응답할수도있고,요청을 이벤트로 바꾸어 스트림으로 처리할수도 있음
		
		요청을 직접처리하는건 지연이 없지만 보존성이 떨어지고
		이벤트로 바꾸어처리하는건 지연이 발생하고 서비스가 결과를 사용할때 저장소에 구체화될떄까지 기다려야하는 단점이 있음
		값을 객체스트림에 성공적으로 기록한후에 앱이 처리할때 사용할수있게 값을 메모리에 유지하면 지연을 줄일수있지만,이벤트를 먼저처리해야해서
		사전에 어떤 데이터가 db에 있어야하는 조인같은건 처리할수없음
		
		그리고 사용자 인터페이스를 스트림으로 처리할땐,반드시 비동기ui를 써야하고,매우빠른시간내에 리턴이와야함,그래서 이경우엔
		잠시 기다려주세요 같은걸 띄워서 동기식에 가깝게 처리하는방법이 있긴함,그리고 다끝나면 그거 확인하고 풀어주는식
	
	6.요청응답앱과 마이크로프론트엔드
		마이크로프론트엔드는,각 프런트엔드마다 백엔드와 데이터저장소 마이크로서비스를 두는식임
		장점으론
			이건 조합형으로,기존 ui에 필요한만큼 서비스를 추가할수있음
			
			그리고 백엔드에서 작동되는 다른 ms처럼, 마이크로프론트엔드를 경계콘텍스트에 정확히 맞추면 비즈니스요건을 구현체단위로 추적할수있음
			이렇게 모듈식으로 필요없어지면 떼버리고 하는게 가능해짐(다른데영향을 안주니까)
		단점으론
			빡빡하게 규칙안정해두면,ui의 스타일이 전부 제각각이 될수있음,그리고 규칙정하는거자체도 부담이고
			성능이 각각 제각각이라서,들쑥날쑥하게 성능이 나오거나,장애가 발생하면 아예 로드가 안될수도있음
	
	
	
14.지원도구	
	여긴 이벤트기반 ms에 쓸만한 툴들을 소개해줌
	ms팀배정시스템은 단일작성자원칙을 정확히 지키고,구현체와 스트림의 소유권을 명확히 추적하기위해 필요함
	이건 간단히 만들어쓸수있음
	
	팀은 새 이벤트를 소유하고 필요에따라 수정할수있어야함,마이크로서비스는 자신의 내부 이벤트스트림을 자동생성할 권한이 있어야하고,
	파티션수,보존정책,복제계수등의 주요속성을 완전히 제어할수있어야함
	스트림을 생성할때 그 소유권은,특정 마이크로서비스나 외부시스템에 할당함
	
	소유권을 할당하는 쉬운방법은,스트림에 메타데이터를 태깅하는것,이 메타데이터는 스트림생산권한을 가진팀만 추가,수정,제거할수있음
	여기에 넣을만한건
		스트림소유자
		개인식별정보:보안상 민감한정보(법쪽으로,개인을 특정할수있는정보)를 표시
		재무정보:회사내에서 중요한정보
		네임스페이스:어느 네임스페이스에 속해있냐
		사용중단:여기체크되면 안쓰는거
		
	쿼터는 보편적인수준으로 브로커에 설정함,이렇게하면 한 그룹이 리소스를 다처먹어서 다른데 다 지연생기는걸 막을수있음
	이떈 최소한의 처리파워와 네트워크io를 보장하고,폭주하기쉬운애한텐 좀 더 세세히지정해줘야하고,
	부하심한애는 좀 높게잡아주고 그래야함
	
	명시적인 스키마는,이벤트를 모델링하는 강력한 프레임워크임
	이름,타입,기본값,문서화등 데이터를 정확하게 정의하면,프로듀서/컨슈머 둘다 편해짐
	이떄 사용하는게 스키마 레지스트리로,이걸 사용하면
		스키마id를 쓰니까 스키마를 이벤트와 같이 보낼필요가없음(,로 구별해서보내던가 그런식으로 알아서파싱함)
		스키마를 가져올떄 레지스트리만 참조하면됨
		스키마가 있으면 자유텍스트검색이 가능해짐(그냥텍스트처럼 검색)
	이때 작동순서는
		프로듀서가 이벤트생산전에 직렬화하고 레지스트리에 등록해 스키마id를 얻음
		이 id를 이벤트에 추가하고
		또 요청하지않게 프로듀서캐시에 넣음
		컨슈머는 이벤트를받고,id값으로 레지스트리에 쿼리해서 스키마를 받음
		그리고 스키마를 적용해서 역직렬화함
		이떄 새스키마면 컨슈머캐시에 넣음
	스키마레지스트리의 대표적인예로,컨플루언트가 있음	
	
	스트림스키마가 변화(필드가 바뀌거나 추가되거나 삭제되거나)했을때,알림시스템이 없으면 컨슈머가 알아내긴 어려움
	그래서 변화가 있을때 컨슈머에게 알리는 알림시스템이 필요함 
	
	
	이벤트기반ms에선 데이터처리전에 오프셋관리를 계속 해야함
	보통은 데이터를 처리하면서 계속 오프셋을 전진시키지만,가끔 수동으로 뭘해야할떄가 있음
		앱을 리셋:오프셋 리셋
		앱을 리셋:오프셋 전진(옛날거 버리고 지금부터)
		앱을 복구:오프셋 지정(특정시점의 오프셋으로 지정)
	이 기능은 ms팀배정시스템이 제공해야함
	
	데이터 접근통제는,보안과 단일작성자원칙을 준수하기위해 필요함
	이건 강제해야하는데,이런 제약은 ms팀배정시스템에서 강제해야함
	이때 권한은,
		read
		write
		create
		delete
		modify
		describe(사용하지않음)
	정도가 있음
	이떄 acl은 경계콘텍스트를 강제함
	예를들어,한 ms는 자신의 내부이벤트 스트림,체인지로그스트림에 대해 create,write,read를 반드시 자신혼자 유일하게 소유해야함
	그리고 단일작성자원칙에 따라,이 ms의 출력스트림은 얘만 write를 할수있어야함
	이때 부여하는 일반적인 권한은
		입력스트림:read
		출력스트림:create,write(내부사용시 read)
		내부스트림,체인지로그스트림:create,write,read
	그리고 이렇게 권한을 명시적으로 체크하면,안쓰는 ms들을 쉽게 알아볼수있어짐(안쓰는건 접근권한 취소하니까)	
	
	
	상태저장앱의 코드를 변경할떈,보통 앱의 내부상태를 리셋함
	이때 외부상태를 사용하면,이경우에도 외부상태저장소를 리셋하는게 좋음
	그래야 혹시모를 오류나 김빠진데이터로 인한 이상한출력이 안나오게됨
	단,이경우에도 당연히 자기서비스만 건드려야지,외부 이벤트스트림과 상태는 건드리면안됨
	즉
		내부스트림과 체인지로그스트림 삭제
		외부저장소 구체화상태 삭제
		컨슈머그룹 오프셋을 입력스트림 최초시점으로 리셋
	이경우에만 사용하면됨
	
	컨슈머랙은,이걸가지고 오토스케일링을 할지말지 체크할수있는 지표임
	그 쿠버네티스 hpa하는거,이걸하는 도구로는 아파치는 버로우같은게 있음
	그리고 이경우에도 한도끝도없이 확장이나 축소되는걸 막기위해,최대치와 최소치를(히스테리시스)정함
	
	ms를 생성하는 프로세스는
		리포지터리생성
		ci파이프라인과 연계
		웹훅,혹은 디펜던시를 구성
		ms팀배정시스템을 사용해 팀에 소유권할당
		입력스트림의 접근권한등록(read)
		출력스트림을 생성하고 소유권한적용
		템플릿이나 코드생성기로 ms스켈레톤을 생성할수있는 수단을 제공
	이런순서대로 진행됨
	
	ms컨테이너관리는 쿠버네티스같은 cms로 처리하고
	클러스터 생성관리는 보통 aws에서 늘이고줄이고 하겠지만,이때 브로커로 새 클러스터를 생성/관리하는게 좋음
	aws는 카프카를 온디멘드로 즉시생성할수있음
	
	ms간 데이터 의존성을 추적하면,즉 어떤 ms가 어떤 스트림을 읽고쓰는지만 알수있으면 맵으로 그릴때 편함
	그래서 권한구조를 사용하는것
	이때 용도는
		데이터계통파악:데이터의 경로를 쉽게알수있음(순서대로따라가면됨)
		팀경계 오버레이:만든 맵으로 전체조직을 시각화할수있음
		데이터출처발견:컨슈머가 쓸만한 데이터를 발견해서,그걸 사용하기 쉬워짐
		상호연결성과 복잡도측정:바로 눈에보이니까,어떻게 연결됐는지,복잡도가 얼마나복잡한지를 알기쉬움
		비즈니스요건을 ms에 매핑:요건에따라 ms를 조정하면,요건을 구현체에 매핑할수있음
	
	
15.이벤트 기반 ms 테스트
	이벤트기반의 가장 큰 장점이,모듈화가 잘되어있어서 테스트하기가 쉽다는거임
	
	이벤트기반 ms는 모든 앱에서 공통적으로,
	단위,통합,시스템,회귀테스트같은 기능테스트를 돌리고,
	성능,부하,스트레스,장애복구같은 비기능 테스트를 돌려서 테스트함
	
	1.유닛테스트
		유닛테스트는 가장 작은 앱코드조각이 잘 작동하는지 시험하는 테스트임
		더 고수준의 앱기능을 확인하기위해 작성하는 더 크고 포괄적인 테스트기반을 제공함
		이벤트기반토폴로지에선,이벤트에 변환,집계,매핑,축약을 많이 하므로,이런게 단위테스트의 대상임
		이때 null,최소최대값같은 경계값을 주로 테스트해야함,
		그리고 값을 여러개받을경우 몇개이상 경계값일때 문제생길수도있으니 이런거도 테스트해야함
		
		상태비저장함수는 이전함수호출의 상태가 필요없어서 그냥 순수함수처럼 테스트하면됨
		
		상태저장함수는 입력이벤트에 따라 가변적이라서 좀 테스트하기가 복잡함
		상태저장에 관한 코너케이스를 전부 다 테스트해야하고,모킹외부저장소든 임시내부데이터저장소든 테스트도중 저장할곳도 필요함
		보통 모킹저장소를 많이사용하는듯
		
	2.토폴로지테스트
		모든 기능을 갖춘 경량/대용량 프레임워크는 전체토폴로지를 로컬에서 테스트할수있는 기능을 제공함
		아니더라도 보통 좀 큰거면 커뮤니티에서 그런 서드파티옵션을 제공함
		
		토폴로지테스트는 단위테스트를 모은,로직 전체에 지정된 전체토폴로지를 대상으로,토폴로지를 함수처럼 써서 테스트하는거
		토폴로지테스트프레임워크를 사용하면,입력스트림에 언제,어떤 이벤트를 생산할지 완전히 제어할수있으니까 테스트가 쉬워짐
		즉,유닛테스트로 하기 힘든 프레임워크의 일부인 연산을(프레임워크내의 함수같은),이벤트를 만들어 흘림으로써 더 쉽게 테스트할수있음
	
	3.스키마 진화와 호환성테스트
		스키마가 진화했을때,규칙에 따라 모든 출력스키마가 이전스키마와 호환되게하려면 코드제출에서 스키마레지스트리에서 스키마를 가져와,
		진화규칙에 맞는지 확인하면됨
		
	4.이벤트기반 ms의 통합테스트
		ms의 통합테스트는 프로덕션환경을 로컬화한 레플리카에서 실행하는 로컬통합테스트와,
		로컬시스템 외부환경에서 ms를 실행하는 원격통합테스트 두개가 있음
		이 둘을 조합한형태로,특정부분은 로컬에서,나머지는 원격으로 하는 형태도 있음
		
		통합테스트를 할때 목표를 정해야함
			돌아만 가는지 확인할건지,리허설테스트(프로덕션올리기전 마지막테스트)인지,복잡한 워크플로 테스트인지
			버그때문에 전체데이터소실시에 입력스트림 처음부터 재처리하는기능이 ms에 있어야하나?있어야하면 그거테스트방법은?
			성공실패여부확인하려면 어떤데이터가 필요한지,시작이벤트데이터는 어떻게할것인지(직접만들던가,프로덕션에서가져오던가),얼마나필요한지
			성능부하처리량같은거도 테스트해야하는지
			자체개발하지않고 테스트할수있는 툴이있는지
		를 미리 어느정도 생각하고해야됨
		
	5.로컬통합테스트
		로컬통합테스트는 광범위 기능/비기능 테스트를 할수있음
		이경우엔 ms를 배포할 프로덕션환경의 로컬 레플리카를 주로 사용함
		즉,적어도 브로커,스키마레지스트리,ms별 데이터저장소,ms자체,그밖에 사용할 프레임워크나 faas사용시 처리프레임워크를 전부 생성해야함
		컨테이너화나 로깅,cms도 넣을수있긴한데 필수는 아님(로직과 관련성이 크지않으니까)
		
		로컬에서 제어할수있는 자체환경을 구축하면,각 시스템을 독립제어할수있는 큰 장점이 있음
		그래서 간헐적장애,비순차이벤트,네트워크차단등을 테스트하기가 쉬움
		또 로컬테스트는 코파티션과 상태에 연관된 수평확장기능테스트도 가능함
		
		그리고 같은워크플로에서 이벤트기반로직과 요청응답로직을 같이 테스트할수있다는 장점도있음
		입력스트림에 언제 이벤트넣을지도 제어할수있고,이벤트처리전후나 도중 언제라도 요청을 발행할수있음
		요청-응답api는 ms를 테스트할 목적으로 만든 별도의 이벤트소스라고 보면됨
		
		보통 이때 시스템 컴포넌트들이 제공하는 옵션들은
		브로커
			스트림의 생성/삭제
			입력스트림에 선택적으로 이벤트순서를 적용해,시간기반로직,비순차이벤트,업스트림실패를 일으킴
			파티션수 변경
			브로커장애 및 복구유발
			이벤트 스트림 장애 및 복구유발
		스키마레지스트리
			스트림에 진화가 호환되는 스키마를 발행하고 이 스키마로 입력이벤트생산
			장애 및 복구 유발
		데이터 저장소(장애 및 복구 유발 말고는 전부 선택사항)
			기존테이블의 스키마변경
			저장프로시저 변경
			앱 인스턴스 수 변경시 내부상태 재구성
			장애 및 복구유발
		처리프레임워크
			코파티션과 데이터지역성 보장을 위해 내부스트림(경량)이나 셔플메커니즘(대용량)으로 셔플링
			체크포인팅,장애,복구
			워커인스턴스 장애를 일으켜 앱인스턴스 유실상황을 모킹(대용량)
		앱
			리밸런스가 제대로 일어나는지
			체크포인트나 체인지로그스트림에서 복구 제대로되는지,지역성유지되는지
			외부상태접근의 영향은 없는지
			앱 인스턴스수를 변경해도 상태저장데이터에 대한 요청-응답접근에 별 영향이 없는지
			
		이렇게 많이 제어할수있어서,별의별상황을 다 만들어서 테스트할수있음
		
		이때 테스트하는 방법은,
		작성한 코드에 테스트라이브러리를 넣던가(언어와 프레임워크 둘다 지원해야함)
		필요한 각각 컴포넌트를 설치하고 로컬 환경을 구축하던가
		
		코드에 테스트라이브러리넣은건,쉽고 안전하긴한데 조건이 너무 까다로움(그냥 함수처럼쓰면되니까 쉬움)
		
		로컬환경 구축은 막 사람마다 다른환경 구축해서 쓰면 디버깅할때 머리아파지고,비용도 많이듬(다 구축하니까)
		그래서 컨테이너써서 쿠버네티스단에서 테스트하는경우도 있음
		
		만약 faas,브로커를 사용해야해서 호스트서비스가 테스트에 필요하면,보통은 그회사에서 테스트툴을 제공해주니까 그거쓰면됨
		만약 없으면 어쩔수없이 원격환경을 프로비저닝해서 써야함,근데 그러면 너무머리아파짐
	
	6.완전 원격 통합 테스트
		로컬에서 힘든테스트는 원격으로 해야함
		테스트대상 ms가 서비스수준의 목표를 충족하는지 확인하려면,성능테스트,부하테스트가 꼭 필요함
		이경우엔,이벤트처리량,요청응답 지연,인스턴스확장,장애복구등을 완전통합테스트로 수행할수있음
		
		완전통합테스트는 보통
			임시통합환경을 사용하고 테스트후 폐기
			공통테스트환경을 만들어,거기서 여러번 통합테스트진행
			프로덕션환경 사용
		이렇게 3가지를 사용함
		
		프로그래밍으로 임시통합환경을 만드는건,
		장점은 브로커및 환경생성프로세스가 테스트잘된다는것과 스크립트실행문제나 설정오류가 다음통합테스트전에 먼저 드러나 조치할수있다는것,
		단점은 스트림과 이벤트데이터가 절대적으로 부족하다는것
		그리고 이렇게 할때도 확장,코파티션,리파티션 로직이 올바르게 작동되려면 파티션수는 프로덕션시스템과 동일하게 설정되어야함
		
		스트림이 생성되면 이벤트로 채워야하는데,이때 선택지가 있음
		프로덕션에 있는 이벤트로 채우면,
			장점
				프로덕션데이터가 정확히 반영됨
				원하는 수량만큼,필요한데이터만 복사가능
				환경이 격리되어있어서 다른 테스트대상ms가 영향을 안줌
			단점
				브로커쿼터를 잘못잡으면 프로덕션성능에 영향을 줄수있음
				엄청많은량을 복사해야할수도있음
				민감정보가 포함된스트림은 조심해야함
				사용장벽을 낮추려면 투자가 많이필요함
				민감한 프로덕션 이벤트노출이 될수있음
		별도 구성한 테스트이벤트로 채우면(프로덕션꺼중에서 사람이 직접고르거나 경계값만 빼냄)
			장점
				소량의데이터만 포함됨
				별도구성이벤트라서 값과 관계특정이 쉬움
				프로덕션에 영향이없음
			단점
				관리오버헤드가 큼
				김빠진데이터가 될수있음
				새이벤트스트림을 처리해야함(추가할때)
				스키마변경을 처리해야함
				잘 안쓰는 스트림은 사용못함
		스키마를 이용해 목업생성은
			장점
				프로덕션에 전혀영향안줌
				퍼징을 사용하면(랜덤하게 만들어주는거) 별의별거를 만들수있음
				프로덕션에 없는 특수한 케이스를 만들수있음
				서드파티도구로 프로그램작성해서 생성가능
			단점
				리얼한데이터 만들기가 어려움
				프로덕션데이터와 비교하면 여전히 불완전함
				생성된데이터가 파싱이 안될수있음(복합키같은경우)
	
	
	
		공유환경에서 테스트하는건 쉽긴한데 머리아파지니까 하면안되고(격리가안됨),
		아예 프로덕션에서 테스트하는건,프로덕션에 영향을 줄 가능성이 커져서 추천되진않는듯
	
	
	
16.이벤트기반 ms 배포	
	1.배포원칙
		팀별로 자율적배포:팀마다 알아서 배포할수있어야함
		배포프로세스 표준화:배포하는 프로세스는 항상 같아야함(ci파이프라인타고 해야함)
		필요한도구 제공:컨슈머오프셋리셋,상태저장소초기화,스키마진화체크,내부스트림삭제등을 할수있는 도구를 팀들에 지원해야함
		스트림 재처리영향도 고려:입력스트림 재처리가 오래걸리면 컨슈머에게 김빠진결과가 갈수있고,한번에 많은출력이나와서 소비자에게 엄청큰부담이 될수있으니조심
		sla준수:다른데 영향주면안됨
		종속적 서비스변경 최소화:스키마변경같이 영향주는건 어지간하면 건들지말자
		중대한변경사항은 컨슈머와 합의:입출력스트림이 바뀌거나 로직이 바뀌면,받아보는애들과도 상의를해야함
	
	2.배포아키텍쳐 컴포넌트
		배포할땐 ci/cd를 사용해서 배포해야함
		ci는 깃에 커밋하면 그걸타고 유닛테스트하고 테스트들 하고 도커돌려서 이미지로 만드는거(보통 메인브렌치 통합되면 자동으로실행),
		이때 테스트에선 코드스타일검증과 스키마 진화검증도 하는게좋음
		cd는 만들어진 이미지를 컨테이너화시켜서 쿠버네티스같은데 던지는거

	3.풀스톱배포패턴
		이 패턴은 다른 배포패턴의 기본임
		순서는
			코드커밋:커밋해서 ci개시
			자동화 단위/통합테스트 실행:테스트실행해서 okng받기,통합테스트때문에 각 서비스의 환경을 가져올수있게,ci파이프라인을 통일해야함
			사전배포검증:릴리즈전에
				이벤트스트림검증:입출력스트림이 존재하거나 생성할수있는지,스트림접근권한이 있는지확인
				스키마검증:입출력스키마 모두 진화규칙 준수하는지 확인,디렉토리에 입출력스키마넣고 스트림맵을 사용하면 됨
				배포:현재 배포된 ms를 중단(인스턴스멈추고 정리)후 실제배포
				사후배포 검증테스트:정상동작하는지,랙이 정상범위인지,로그에 에러는없는지,엔드포인트가 잘 작동하는지 확인
		
	
	4.롤링 업데이트 패턴
		이건 실행중인상태에서 하나씩 바꿔가면서 업데이트하는거,맨날보던거랑 똑같음
		이경우 조건은
			상태저장소와 내부스트림의 중대한 변경이 없음
			ms내부토폴로지의 중대한변경이 없음
		이어야함
		이걸하면 좋을때는
			새필드가 입력이벤트에 추가될때
			새 입력스트림 소비가 필요할때
			버그를 고쳐야하지만 재처리는 안해도될때
		즉 옛로직과 새로직이 동시에 돌아가도 될때,무중단으로 하고싶으면 하면됨
		
	5.중대한 스키마 변경 패턴
		중대한 스키마변경을 해야할땐,반드시 프로듀서와 컨슈머가 논의를 해야하고,배포및 마이그레이션일정을 잡아야함
		이때 엔티티스키마 변경이 비엔티티 스키마변경보다 더 빡셈
		또 엔티티는 재사용되니까,전에 했던것들도 새스키마에 맞게 변경해주던가 해야함
		
		이경우 하는 방법은,
			스트림을 두개로 나눠서 최종일관적으로 마이그레이션
			새 이벤트스트림으로 동기화해서 마이그레이션
		두방법이 있음
		
		스트림을 두개로 나누면, 옛스트림 새스트림이 둘다 이벤트를 생산할수있고,그게 다시합쳐져도 다운스트림에서 문제없을때 할수있음
		이경우 옛스트림에 다시 신규소비자가 붙지않게 메타데이터표시해야함
		
		
		새스트림 동기화는,프로듀서를 업데이트해서 새 포맷으로만 이벤트를 생성하는것,
		이건 쉽지만 컨슈머랑 협의가 잘 안됐으면,컨슈머쪽에서 마이그레이션에 실패했을때,옛날로 쉽게 돌아가기가 힘듬(새로들어온데이터는 나가리됐으니)
		그래서 테스트환경에서 프로듀서와 컨슈머를 같이만들어서 등록해서 테스트해야함
		
	6.블루그린배포
		이건 그냥 프로덕션을 2개만들어서,한쪽은 프로덕션으로 쓰고,한쪽에 세팅다해두고 업데이트하면 반대쪽으로 트래픽을 돌리는거
		이때 한번에 다돌릴수도있고,살살 돌릴수도있음(카나리아패턴처럼 조금씩 늘려가며)
		카나리아식으로 하면,생산데이터의 정합성이 깨져서 동시에 2종류가 들어올수도 있으니 주의해야함,
		그래서 이땐 카나리아배포를 안하는게나음(출력스트림생산할때)
		
17.총정리	
	1.통신레이어
		통신레이어는 조직전체의 비즈니스 이벤트에 대한 공통접근채널
		브로커는 데이터를 엄격하게 구성해서,실시간에 가깝에 업데이트를 전파할수있고,
		데이터통신은 데이터를 변환해서사용하는 로직과 완전분리되어있어서 데이터처리는 각 경계콘텍스트의 몫임
		그래서 브로커는 읽기쓰기지원만 하고 다른건 아무것도 하지않고,컨슈머는 데이터를 저장,보존,분산시키는일만 할수있음
		
		그리고 잘만든 데이터통신 레이어는,데이터를 접근/소비하는것과 데이터를 소유/생산하는 행위를 분리함
		앱은 내부로직을 제공하면서,동시에 다른서비스에 직접접근이나 동기화같은걸 할필요가없음
		
		모든서비스는 브로커로 체인지로그등을 사용해서 보존성과 복원성을 높이고 고가용성을 실현할수있음
		
	2.비즈니스도메인과 경계콘텍스트
		비즈니스는 특정 도메인에서 작동되고,이 도메인은 다시 여러 하위도메인으로 나눠짐
		경계콘텍스트는 비즈니스문제를 해결하는 단위로,입출력,이벤트,요건,프로세스,데이터모델등 하위도메인에 해당되는 경계를 식별함
		
		ms에선 서비스와 워크플로는 비즈니스요건에 맞게 조정되니까,범용 데이터통신레이어로 도메인과 경계콘텍스트에 ms를 맞춰서 조정이쉽게 해야함
	
	3.ms세금
		ms의 세금은
			브로커
			스키마레지스트리,데이터탐색서비스
			컨테이너관리시스템
			cicd
			모니터링및 로깅서비스
		대충 그 쿠버네티스쪽 데브옵스임 브로커 스키마레지스트리빼면
		이것도 한번에 다 할필요는없고 하나씩추가해도됨
	
	4.스키마화이벤트
		스키마는 이벤트의 의미를 주고받을떄있어서 중심임
		엄격한타입은 프로듀서컨슈머 모두 데이터의 사실성을 따지고,
		프로듀서는 스키마에 입각해 이벤트를 생성해야하고,
		컨슈머는 소비한 이벤트의 타입,범위,정의를 잘 처리해아함
		이렇게 업격하게하면 컨슈머가 이벤트를 잘못해석할 가능성을 줄일수있고,변경에대한 규약으로 쓸수도있음
		
		진화는 새 비즈니스요건에 대응해서 이벤트와 엔티티를 변경하는 메커니즘임
		프로듀서는 새필드,수정된기존필드에 맞게 데이터를 생산하고,
		변경과 무관한 컨슈머는 그냥 그대로 옛날거써서 바꿀때의 위험성을 줄임
		변경사항이 필요하면 그냥 자기가 업그레이드해서 최신포맷을 처리하면됨
		
		스키마가 있으면 코드생성과 데이터검색에도 유용함
		스키마를 보고 어느스트림에 대응되는지 출력입력을 알수있어서 따라가기도쉽고
	5.데이터해방,단일진실공급원
		데이터해방엔 시간이 오래걸리고,필요한 데이터를 전부 브로커로 가져오는건 시간이 더걸림,
		이건 어쩔수없이 거쳐야할과정임
		
		데이터를 받았으면 데이터의 생산,소유권과 데이터를 사용하는 컨슈머의 접근을 분리할수있음
		
		가장 자주쓰이고,다음목표에 가장중요한거부터 해방하는게 좋음
		
	6.ms
		ms는 경계콘텍스트의 구현체로,비즈니스경계에 따라 구현해야지,기술경계에 따라 구현하면 결합도가 너무높아짐
		이떄 주의할건
			중요한 비즈니스엔티티와 이벤트는 브로커내부에둔다
			브로커를 단일진실공급원으로 사용
			서비스간 직접호출을 하지않음
			
	7.ms구현옵션
		ms에서 선택가능한옵션은
		경량은
			스트림을 테이블로 구체화해서 영구보존가능
			스트림및 테이블과 조인가능
			핫레플리카
			영구스토리지
			체인지로그
		대용량은 뭐 별거없고,쿠버네티스와 합칠수있는거정도?
		
		그리고 faas솔루션은,확정적결과를 얻을순없지만 그게 중요하지않을땐 간단히쓰기좋음
	
	
	8.테스트
		이벤트기반ms는 테스트가 매우 쉬움
		어짜피 이벤트입출력으로 동작하니까 거기만 건드리면 되기때문
		
		유닛과 통합 둘다 로컬에서 수행가능하고(세팅은해야하지만)
		프로덕션에서 테스트하는거도 할수있고 성능테스트도 쉬움
	
	9.배포
		배포는 그냥 팀마다 이미지로 올리고,배포팀같은데서 그걸 쿠버네티스로 올리던가 하는식으로 함
	
	
	
	
	
	
	
끝
	
	
	
	
	
	
	