1.마이크로서비스란
	마이크로서비스는 단일앱을 작은규모의 서비스조합으로 나누고,서비스끼리 api를 사용해 통신하는식임
	이거의 장점은,순서대로 동작하는 작업도,api로 어떻게 들어올지만 정해두면 거기에 맞춰서 개발할수있어짐
	
	마이크로서비스를 할때 주의점은,선택하고 결과는 오랜시간이 지나야 나오기때문에 신중해야함
	그렇다고 계속 고민만 하고있을수는 없음
	그래서 사용하는게 ADR임
	
	이건 아키텍쳐 결정 기록이라고 하는데
	목표,대안,선택,영향을 다 나열하고 적는것
	
		목표는 이루고자 하는 목표(해결할문제)와 제약사항등 문제를 나열
		대안은 내가고를수있는 선택지
		선택은 내가 고른 대안
		영향은 선택에 따라 일어난일
	이걸 전부 문서화하는것(깃헙의 이슈랑 비슷함)
	
	
	
2.마이크로서비스 운영모델설계
	운영모델은 사람,프로세스,도구의 집합이고 소프트웨어를 구축할때 수행하는 모든 의사결정과 작업에 중요한 영향을 미침
	운영에서 가장 중요한건 사람임
	
	그래서 마이크로서비스팀의 인원수도 중요함
	크면 의사소통에 많은시간이 필요하고,너무작으면 일손이 부족함
	대충 8명정도로 자르는듯

	그리고 이렇게 작게자르면 팀의 갯수가 많아지고,여기서 또 의사소통땜에 시간지연되면 안됨,그래서 각팀은 가능한 독립적으로 돌아가야함
	그렇다고 완전히 독립적이면,어짜피 똑같이필요한걸 모든곳에서 만들어야하기떄문에 효율성이 떨어짐,그래서 적당히 실험해보면서 조율해야함
	1.팀 토폴로지
		팀토폴로지는 팀간 일하는 방식에 중점을두고 설계에 대해 이야기하는방식
		
		1.팀유형
			마이크로소프트의 핵심개념중 하나는 팀 유형임
			이건 조직간 의사소통관점에서 팀의 성격을 설명함
			여기에 있는 팀유형은
				스트림정렬
				활성화
				난해한 하위시스템
				플랫폼
			이 있음
			
			스트림정렬은 전달가능한 작업을 소유하고 실행함
			이팀의 주요특징은 비즈니스조직과 관련된것을 지속적으로 전달함,즉 구축한걸 직접 운영하라,만든곳에서 제품을 변경하고 개선함
			
			활성화는 다른팀의 작업을 지원함,해결사같은곳임
			
			난해한 하위시스템은 암호화같은 어려운거나 해결하는데 오래걸리는걸 전문으로 함
			
			플랫폼은 활성화처럼 다른팀의 작업을 지원하는데,여기는 사용자의 역할을 해서 qa를 해줌
			그러니까 자기자신말고 나머지 모두가 플랫폼이라고 볼수있음(자기가만든걸 소비하니)
		
		2.상호작용모드
			각 팀간에는 조정비용이 가능한 작아야함,
			그래서 상호작용도 진짜 서로 같이 일을 하거나(협력),
			다른팀이 원하는 결과를 줄수있게 하거나(촉진),
			api를 만들어서 공개하거나(xaas)
			
			이 3가지가 있음
		
	2.팀 토폴로지 설계
		팀 토폴로지는 팀 조정에 대해 이야기할수 있는 언어임
		얘는 시각적 표현으로,다이어그램을 사용해 표현함
		
		기본적으로 팀 설계와 토폴로지를 만들기위해
			시스템설계팀 구성
			마이크로서비스팀 템플릿 생성
			플랫폼팀 정의
			활성화팀 난해한 하위시스템팀 생성
			주요 소비자팀 추가
		로 순서대로 하면됨
		
		1.시스템설계팀 구성
			시스템 설계팀은 시스템비전과 행동을 구체화할수있는 사람을 그룹으로 구성함
			이팀의 책임은
				팀구조 설계:팀들을 설계함
				표준,인센티브,가드레일 설정:빡빡한 규칙말고 표준적으로 이렇게처리하고,이렇게하면 좋다,이렇게는 하면안된다 식의 간단한 규칙을 만들어야함
				지속적인 시스템 개선:팀설계와 규칙들을 측정하고,개선할수있게 관리해야함
				
			이런것처럼 팀책임은 전부 문서화해두는게 좋음 
			
		2.팀 템플릿 구축
			업앤러닝모델에선 단일팀은 여러 마이크로서비스를 소유할수있음
			여기서 중요한건,한 마이크로서비스는 책임이 한 팀에만 있어야함(소유권은 한팀에있어야함)
			
			팀 템플릿은 클래스라고 보면됨,이거대로 대충만들고 오버라이드해서 약간 수정하는식
			여기서 정해야할건
				팀유형
				팀규모
				책임
			임
			책임은 여러개를 소유할수있고,팀규모는 팀의 규모 팀유형은 팀의 유형임
			
			그리고 다이어그램에서 서로 붙어있으면 서로 상호작용이 일어난다는것
		3.플랫폼팀
			플랫폼팀은 클라우드플랫폼팀으로 쿠버네티스나 aws등을 사용해서 배포하는걸 지원함
			이팀의 책임은 네트워크 인프라설계및 개발(iac),앱 인프라설계및 개발(쿠버네티스),새환경을 빌드하기위한 스크립트제공(쉘스크립트+도커),업데이트
			가 있음
			
			이팀의 책임중 핵심은 제공한 인프라를 업데이트하는것임
			이팀은 마이크로서비스팀에 xaas서비스모델을 구현함
			
		4.활성화와 난해한 하위시스템팀
			이팀들은 핵심은 아니고,추가로 필요한것들을 처리함
			주로 전문릴리즈팀(프로덕션에 마이크로서비스를 릴리즈함)이 있음,이건 난해한 하위시스템팀임
			
			얘는 다이어그램에 마이크로서비스팀 위에 작은사각형을 그리고 거기넣음

		5.소비자팀
			소비자팀들은 모바일앱개발,웹개발,서드파티조직들이나 api사용자들임
			api팀은 마이크로서비스를 api로 다른개발팀에 노출하는 책임을 맡고있음
			예를들어 모바일앱팀은 api팀에서 만든 api로 상호작용을하지,마이크로서비스를 직접호출하지않음
			
			그래서 마이크로서비스팀이 api팀에 xaas로 상호작용을 함
			




3.seed(s)프로세스
	시드는 서비스를 통한 시스템의 컴포넌트화를 말함
	여기서 시스템 구성요소는 공개인터페이스를 정의해서 서비스로 호출함
	여기서 시드프로세스는 반복가능하고 안정적이고 신뢰할수있는 방법론을 제공해줌
	
	시드는
		액터식별
		액터가 수행하는 작업식별
		시퀸스다이어그램을 사용한 상호작용패턴 발견
		jtbd와 상호작용패턴을 기반으로 높은수준의 작업및 쿼리 도출
		개방형표준(openapi)를 사용해서 액션및 쿼리를 스펙으로 설명
		api사양에 대한 피드백받기
		마이크로서비스 구현
	순서대로 되어있음
	
	1.액터 식별
	액터는,고객에서 금전적 요소를 뺀거를 말함,즉 내 서비스를 사용하는 사람들을 말함
	액터정의로 모델링을 시작하는이유는 범위와 우선순위를 지정하기위해서임
	가장 많이 저지르는 실수가 요구사항에 대한 명확성부족과 지나친 추상화기때문에 이걸 해결하려는거
	
	여기서 해야할일은 누가 이 api를 사용하는가,혹은 고객이 필요한것은 무엇인가 를 알아야함
	이때 목표에 적합한 액터를 식별하기위한 규칙은
		1.액터는 정확하기보다 구체적이여야함,
		  액터가 누군지보다 액터를 구별하는 특성의 경계를 식별하는게 더 중요함,
		  모델링과정은 모든게 정확할수없음,
		  모든세부사항보다 현실에 관련된 우선적인거를 파악해야함
		2.겹치거나 광범위한 액터는 위험함,재사용되는 액터의 포트폴리오를 갖는건 잘못될가능성이 큼
		3.모델로서 액터정의는 각 액터에 내재된 요구사항,문제점,행동을 나타냄,액터유형을 구분하는 요구사항과 행동은 관련성이 있고,중복이 매우제한적이여야함
		4.문제영역을 설명하기위해 적은수의 개별액터를 사용해야함,서비스에 5개이상의 액터가있으면 우선순위가 사라졌거나 서비스경계가 너무넓은것
		
		
	2.액터가 수행하는 작업식별
		액터의 유형을 파악했으면,액터가 할일을 파악하는데 시간을 많이들여야함
		
		시드를 포함한 설계방법론은,api및 서비스를 제품으로 정의하고 시작함
		그래서 제품을 생산할때 제일 중요한,고객의 문제를 해결해야한다는걸 제일 중요하게생각해야함
		그래서 일시적인 도구를 완성하는게 아닌,문제해결에 집중해야함
		
		이걸위해 사용하는게 잡스토리임
		잡스토리는
			__일때,나는 __하기를 원하고 __할수있다
			상황     동기           목표
		임
		이걸 좀더 개발자편의적으로 변경하면 상호작용 다이어그램을 그릴수있음
		이때 사용되는게 plantuml같은거,어떤게 어디 포함되어있고 어디서 어디로 간다 이런식으로 기술간 상호작용식으로 표현함,필요하면보자
	3.jtbd에서 액션및 쿼리도출
		잡스토리를 실제로 api로 바꿀땐,액션과 쿼리의 집합으로 바꿀수있음
		쿼리는 사이드이펙트가 없는,단순조회를 말하고
		액션은 사이드이펙트가 메인인,즉 바꾸는게 목적인(insert같은)걸 말함
		
		쿼리는
			입력:입력변수목록
			응답:출력데이터요소목록
		액션은
			입력:입력변수목록
			예상결과:유발된 사이드이펙트에 대한 설명
			응답(선택사항):응답데이터요소 목록(존재할경우)
		식으로 표현할수있음
		잡스토리가 하나의 쿼리나 액션인건 아니고,여러개의 쿼리와 액션의 집합으로 변환될수있고,쿼리와 액션은 여러 잡스토리의 소스로 결합할수있음
		
		즉 입력값을 넣으면 출력값이 나오는 함수라고 보고,저렇게 인터페이스를 짠다음 나중에 내부구현하면됨
		액션의경우엔 입력값은 똑같이하면서 출력값은 성공하면 성공코드,실패할시 오류객체를 던지면됨
		
		이거도 복잡해지면 다른방식을써야하지만(마이크로서비스 디자인 캔버스),보통은 이거로 충분함

	4.openapi를 사용해 액션및 쿼리를 스펙으로 설명
		인터페이스를 만들었으면 openapi를 사용해서 문서화를 시켜놔야함
		그리고 보통 api는 restapi를 사용하는듯
		openapi를 작성할땐 vscode에서 플러그인을 설치하고 컨트롤알트p를 누르면됨
		
		oas(오픈api사양)의 상세는 나중에찾아보자
		대충 기본설명이랑 입출력설명정도있음

	5.api사양 피드백받기
		그리고 api사양을 만들었으면,이걸 사용할사람들한테 보여주고 피드백을 받아야함
		api와 서비스를 설계할떄 두가지 유형의 고객그룹을 고려해야함
			최종사용자
			서비스이용자(서비스를 사용해 코딩할사람들)
		순서는 seed 시작단계에선 최종사용자를 인터뷰해서 잡스토리를 뽑고,후반에는 클라이언트개발자로부터 피드백을 받으면됨
		최종사용자는 목표를,서비스이용자는 과정을 피드백해줌
	6.마이크로서비스 구현
		마지막단계는 실제로 코딩을 해서 마이크로서비스를 구현하는거임
		코딩은 제일 코스트가 많이들기때문에,최대한 다른변경사항을 없애둔뒤에 딱 한번만 하면되게 함
		
		api와 마이크로서비스는 많은게 비슷함
		둘다 http를 통해 통신하며 기능을 제공한다던지
		여기서 api와 마이크로서비스의 차이점은,api는 마이크로서비스를 모아둔 시스템의 인터페이스(파사드라고 보면됨)라고 보면됨
		즉 api를 구현하는게 마이크로서비스들의 집합임
		그리고 마이크로서비스는,서로에대해 알면 안됨,단순 입출력에 따른 결과값만 나와야함 


4.마이크로서비스의 크기조정:서비스경계


















































































