1.젯팩컴포즈의 기본
*1.개요
  @Composable로 사용자지정ui구성요소를 쉽게만들수있고
  싱글액티비티로 만들게되는데,이러면 더 ui가 쉬워짐
  
*2.Jetpack Compose
  젯팩컴포즈를 사용하면 xml을 사용하지않고 코틀린코드로만 작성할수있음
  그래서 특정 액티비티에 종속되지않은 작고 무상태인 컴포넌트를 만들수있음
  그리고 구성요소에서 재사용및 테스트가 용이하게 만든 컴포넌트를 사용하면 상태가 명시적으로 전달됨
  이러면 상태에 대한 진실의근원이 하나가되고 서로 분리됨
  이렇게 상태가 변경되면 자동으로 ui가 업데이트되는식으로 동작함
  기본적으로 선언형으로 동작해서,변경된부분만 업데이트시키는 방식을 가짐
  
  Composable은 구성가능한함수,ui라고 보면되고,이함수는 데이터를 입력받아 화면이 어떻게 보여야하는지를 선언함
  그래서 반환값이없고 정보를 방출하기만함(클래스라고 봐도됨)
  
  Composition은 컴포저블이 실행되어서 만들어진 ui트리구조임(인스턴스라고 봐도됨)
  실제로 보게되는 ui를 말하고,얘는 상태저장소를 가지고,동적으로 업데이트를 할수있음
  또한 데이터가 바뀌면(상태가 바뀌면) recomposition으로 해당부분과 관련된 composable함수를 다시 실행하고,그결과를 바탕으로 컴포지션을 업데이트함
  
  @Composable는 저 어노테이션이 붙은 일반코틀린함수고,이 어노테이션은 컴포즈 컴파일러에게 이 함수를 상태와 연결하고,
  상태가 바뀌면 ui를 자동으로 업데이트할수있게 만들어줌
  즉 특정 뷰모델에 특정함수를 연동해두면,그 함수의 값이 변하면 자동으로 ui를 해당값으로 업데이트해준다는것
  
  즉 젯팩컴포즈는 ui에 비교적 상태가 없고,상태를 유지하지않는방식을 사용하고,거기에 뷰모델에다가 상태용 함수를 연결시키는방식으로 모델과 뷰를 분리시킴
  사용자가 클릭이벤트같은걸 발동시키면,거기에 연동된 함수를 값을 넣어서 실행시키는방식
  이렇게 유연성을 챙길수있음
  
*3.재구성(Recomposition) 
  초기구성(Initial composition)은 합성가능한 함수(컴포져블)를 처음 호출해서 ui를 표시하는시점을 말하고,
  재구성은 컴포저블함수들이 상태에 따라 ui를 재구성하거나 표시하는걸 말함
  
  컴포즈에서 컴포저블객체의 내부상태를 변경할땐,새 데이터를 사용해서 해당 컴포저블객체를 호출하는함수를 다시 호출하기만 하면됨
  단 이때 remember을 사용해서 값을 저장해야함(원하는값에따라 밑에서 선택,위임패턴)
    var myValue by remember{mutableStateOf(false)} //boolean
	var myValue = remember{mutableStateOf(false)}//MutableState<boolean>
  이래야 값이 저장됨
  
  컴포저블함수안에서 다른 컴포저블 함수를 호출할수있고,컴포저블함수를 처음실행할떄(초기구성)는 함수전체가 실행되지만,재구성때는 변화가있는부분만 실행됨
  주의점은
    모든 컴포저블함수실행의 순서는 랜덤(비동기라),즉 자체적으로 완결성을 가져야함
	재실행은 낙관적으로 동작하고,취소될수도있음
	특정 함수들은 상당히 자주 실행될수있음(ui애니메이션의 각프레임마다 실행된다던가),이런함수에서 비용이 높은작업을 하면안됨
  
*4.상태
  컴포즈의 상태는 시간이 지남에 따라 변할수있는 모든 값을 말함
  예를들어 db에 저장된값,클래스의변수,기기의 센서에서 읽은값등이 있음
  컴포즈에서 ui는 불변이고,상태가 아님
  단 우리는 ui의 상태를 변경해서 값을 업데이트할수있음(재구성)
  
  컴포저블은 상태를 허용하고 이벤트를 노출할수있고,상태는 변경될수있는 모든값임
  이벤트는 어떤일이 발생했음을 알리는 콜백이고,우리는 상태를 제어해서 ui를 재구성시킬수있음
  
  컴포저블함수에는 스테이트풀과 스테이스리스가 둘다 있음
  스테이트풀을 재사용과 테스트가 어려우니까 가급적 스테이스리스로 만드는게 좋음
  이를위해 상태 호이스팅을 활용할수있음
  상태를 매개변수로 대체하고,람다를 사용해서 이벤트를 표현하는것
  즉 상태를 직접 저장하지말고,매개변수로 바꿔서 주입받는거
    @Composable
	fun abc(name:String,
	  onNameChange:(String)->Unit //이벤트를 람다로 받기
	){
	  TextField(
	    value=name,
		onValueChange=onNameChange //이벤트를 람다로 받기
		
	  )
	}
  이런식으로하면 ui와 로직을 분리시키고(상태와도 분리시키고),기능때문에 ui코드를 건드리지않아도됨
  즉 mvvm패턴임
  여기서 상태홀더로 사용되는게 ViewModel이고,얘가 컴포저블의 상태를 모아두는 역할을 하게됨
  그래서 ui상태와 이벤트를 캡슐화할수있음
  
  이런식으로 하는게
    @Composable
	fun abc(
	  abcViewModel:AbcViewModel=viewModel()
	){
	  val name:String by abcViewModel.name.observeAsState("") //observeAsState특정상태를 관찰
	  TextField(
	    value=name,
		onValueChange={abcViewModel.onValueChange(it)} 
		
	  )
	}
  이렇게 처리해버리는거

*5.컴포즈 라이프사이클
  컴포저블의 생명주기는 단순하게
    컴포지션진입(초기구성)
	리컴포지션(재구성)
	컴포지션이탈(해당컴포저블이 필요없어졌을때,if가 false가 된다던지,리스트에서 스크롤되어서 화면밖으로 벗어나서 삭제된다던지)
  로 구성됨
  
  재구성이 일어나면 함수를 다시 실행한다는게 중요함
  즉 기본적으로는 해당함수내의 변수가 초기화되는데,이때 remember을 사용할경우에만 해당값을 가져가게됨
  이때 만약 컴포지션에서 이탈했다가 다시 들어올경우엔,remember했던값도 초기화됨

  컴포지션은 컴포저블(ui)의 트리계층구조임
  초기구성에서 모든 컴포저블을 생성하고,
  재구성이 발생하면 해당하는 컴포저블을 업데이트함
  
  컴포저블은 초기구성에 의해서만 생성되고,재구성에 의해서만 업데이트됨
  컴포저블을 컴포지션에 들어가고,여러번 재구성된후,컴포지션을 종료하면 죽음(보통 종료할때)
  
  모든 호출된 컴포저블은 컴포저블이 호출되는 소스의 위치별로 인스턴스가 생성되고,이를통해 재구성마다 다시시작하지않게해줌
  컴포저블을 여러번 호출하면 컴포지션에도 여러번 추가되고,
  같은곳에서 여러번 호출하면 인스턴스를 고유하게 유지하기위해 호출장소+실행순서를 적용하는데 이거때문에 이상한동작을 할수있음
  만약 리스트에서 맨 마지막에 값이 추가된다면 이전값들은 재사용할수있지만
  리스트에서 맨위나 중간이 변경,삭제되면 해당 리스트의 전체 컴포저블이 재구성됨
  
  컴포즈는 런타임에 특정객체를 식별할때 사용하는키를 받을방법을 제공하는데
    key(id값등){
	  객체
	}
  이건 전역적으로 고유할핋요는없고,해당지점에서만(해당 반복문속의 리스트내에서만)고유하면됨
  

*6.사이드이펙트
  사이드이펙트는 컴포저블의 범위밖에서 발생하는 상태의 변화를 말함
  컴포즈함수는 ui를 그리기위해 수시로 리컴포지션됨
  근데 만약 db접근같은걸 여기서 그냥 해버리면 무한히 요청해서 리소스를 다 빨아먹을수가있음
  그래서 예측가능한방식으로 동작해야함
  ui를 생성하지않고,컴포지션이 실행할때 사이드이팩트를 일으켜야함
  
  재구성은 컴포저에 의해 제어되는데,그래서 우리는 통제권이별로없음
  그래서
    number++
  대신
    SideEffect{
	  number++
	}
  이렇게 표시해줘야함
  보통 외부api호출등이 많음
  이런 사이드이펙트 처리를 위해 Effect Handlers를 사용할수있음
  이걸 사용해서 사이드이펙트의 수명주기를 제어하고 정리할수있음
  이 이펙트핸들러는
    Suspended:네트워크등 비동기작업을 안전하게 처리하기위해 사용되는 코루틴기반메커니즘
	  LaunchedEffect{}:한번만 실행하거나 특정값이 바뀔때만 실행하고싶을때 사용
	    컴포저블내부에서 suspend함수를호출할때 사용,키가 필수,매개변수로 전달된 코드로 코루틴을 실행시킴
	    키가 변경되면 기존코루틴이 취소되고 새코루틴에서 새 suspend함수가 실행됨
	  rememberCoroutineScope{}:컴포저블이 컴포지션을 떠나면 자동으로 취소됨,사용자 상호작용에 따른 비동기작업을 실행할떄 유용함
	  produceState{}:LaunchedEffect에서 결과를 State에 쉽게 넣게해줌,키가없으면 Unit를 사용하고,컴포지션 전반에서 상태가 유지됨
    Non-Suspended:코루틴을 사용하지않는 동기적인 사이드이펙트를 안전하게 사용하기위해 사용됨
	  컴포지션에 들어갈때 콜백을 초기화하기위해 사이드이펙트를 실행하고,컴포지션을 나갈때 폐기
	  SideEffect{}:컴포즈가 관리하지않는객체와 컴포즈 상태를 공유할떄사용,재구성이 될때마다 호출됨(컴포지션이 실패하면 폐기됨)
	  DisposableEffect{}:키가 변경되거나 컴포저블이 컴포지션을 종료한후 정리해야할때 사용(기존실행되던걸 지우고 새로시작해야할때,즉 정리가 필요할떄 사용),
	    키가 변경되면 컴포저블이 현재이펙트를 삭제하고 이펙트를 다시 호출해서 재설정해야함
  로 나눠짐


*7.레이아웃
  젯팩컴포즈에서 레이아웃은 
    row:수평방향정렬
    Column:수직방향정렬
	Box:이전요소위에 계속 쌓이는식으로 동작
  가 있고,사용자지정레이아웃도 만들수있음
  여기서 적용할수있는 속성들로는
	수정자:모든 컴포저블에 적용되는값을 추가할수있음(패널에 기본값추가하는느낌),fillMaxSize(),padding(),backgroungd()등을 넣을수있음
	  넣는순서대로 적용됨(패딩먼저하고 백그라운드하면 정상적으로 나오지만,백그라운드하고 패딩하면 먼저 백그라운드부터 칠해서 패딩티가안남)
	세로(가로)배열:레이아웃의 배열방식을 지정(상단이 기본값이고,하단에서부터 채울지 중앙부터할지등),spaceBetween,SpaceAround등이 있음
	수평정렬
	컴포저블컨텐츠람다
  를 지원함
	

2.앱제작
*1.프로젝트 생성
  프로젝트를 만들땐 empty Activity를 고르면됨(구버전 안드스튜디오는 empty Compose Activity)
  
  생성된 프로젝트의 메인액티비티가 메인뷰고,
  theme폴더안에 미리 설정된값상수들이 들어있음(색,타입,테마등)
  추가할거있으면 여기다가 추가해도됨
  나머진 이름그대론데,테마는 다크모드거나 라이트모드,또는 또 다른 테마를 넣을때 묶어서 선언해두는곳임
  그리고 테마의 밑에 컴포저블함수에서 무슨테마를 사용할지를 조건에 따라 넣으면됨
  또한 여기선 컨텐츠람다를 넣을수있는데,이건 메인액티비티에서 컴포저블트리를 정의할수있다는걸 의미함

*2.종속성 추가
  루트레벨 빌드그래들의 플러그인에
    id("com.google.devtools.ksp") version "2.0.21-1.0.27" apply false
	id("com.google.dagger.hilt.android") version "2.57.2" apply false
  추가하고
  앱레벨 빌드그래들의 플러그인에
    id("com.google.devtools.ksp")
    id("com.google.dagger.hilt.android")
  추가한후
  디펜던시에
    val roomVersion = "2.8.4"
    implementation("androidx.room:room-runtime:$roomVersion")
    ksp("androidx.room:room-compiler:$roomVersion")

    implementation("androidx.datastore:datastore-preferences:1.2.0")

    implementation("com.google.dagger:hilt-android:2.57.2")
    ksp("com.google.dagger:hilt-android-compiler:2.57.2")
  추가

*3.모델클래스 생성
  룸을 사용할때,엔티티를 선언할땐
    @Entity(tableName = 테이블명)
  를 붙이면됨
  
  대략적으로
    @Entity(tableName = 테이블명)
    data class ToDoTask(
	  @PrimaryKey(autoGenerate = true)
      val id: Int = 0, //0을 기본값으로 넣어주면 알아서 생성함(오토인크리즈먼트일떄)
	  val title: String,
      val desc: String,
      val priority: Priority,
    )







  
  
  
  
  