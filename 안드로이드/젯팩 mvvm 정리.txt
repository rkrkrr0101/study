1.젯팩컴포즈의 기본
*1.개요
  @Composable로 사용자지정ui구성요소를 쉽게만들수있고
  싱글액티비티로 만들게되는데,이러면 더 ui가 쉬워짐
  
*2.Jetpack Compose
  젯팩컴포즈를 사용하면 xml을 사용하지않고 코틀린코드로만 작성할수있음
  그래서 특정 액티비티에 종속되지않은 작고 무상태인 컴포넌트를 만들수있음
  그리고 구성요소에서 재사용및 테스트가 용이하게 만든 컴포넌트를 사용하면 상태가 명시적으로 전달됨
  이러면 상태에 대한 진실의근원이 하나가되고 서로 분리됨
  이렇게 상태가 변경되면 자동으로 ui가 업데이트되는식으로 동작함
  기본적으로 선언형으로 동작해서,변경된부분만 업데이트시키는 방식을 가짐
  
  @Composable는 저 어노테이션이 붙은 일반코틀린함수고,이 어노테이션은 컴포즈 컴파일러에게 이 함수를 상태와 연결하고,
  상태가 바뀌면 ui를 자동으로 업데이트할수있게 만들어줌
  즉 특정 뷰모델에 특정함수를 연동해두면,그 함수의 값이 변하면 자동으로 ui를 해당값으로 업데이트해준다는것
  
  즉 젯팩컴포즈는 ui에 비교적 상태가 없고,상태를 유지하지않는방식을 사용하고,거기에 뷰모델에다가 상태용 함수를 연결시키는방식으로 모델과 뷰를 분리시킴
  사용자가 클릭이벤트같은걸 발동시키면,거기에 연동된 함수를 값을 넣어서 실행시키는방식
  이렇게 유연성을 챙길수있음
  
*3.재구성(Recomposition) 
  초기구성(Initial composition)은 합성가능한 함수(컴포져블)를 처음 호출해서 ui를 표시하는시점을 말하고,
  재구성은 컴포저블함수들이 상태에 따라 ui를 재구성하거나 표시하는걸 말함
  
  컴포즈에서 컴포저블객체의 내부상태를 변경할땐,새 데이터를 사용해서 해당 컴포저블객체를 호출하는함수를 다시 호출하기만 하면됨
  단 이때 remember을 사용해서 값을 저장해야함
    var myValue by remember{mutableStateOf(false)}
  이래야 값이 저장됨
  
  컴포저블함수안에서 다른 컴포저블 함수를 호출할수있고,컴포저블함수를 처음실행할떄(초기구성)는 함수전체가 실행되지만,재구성때는 변화가있는부분만 실행됨
  주의점은
    모든 컴포저블함수실행의 순서는 랜덤(비동기라),즉 자체적으로 완결성을 가져야함
	재실행은 낙관적으로 동작하고,취소될수도있음
	특정 함수들은 상당히 자주 실행될수있음(ui애니메이션의 각프레임마다 실행된다던가),이런함수에서 비용이 높은작업을 하면안됨
  
*4.상태  
  
  
  
  