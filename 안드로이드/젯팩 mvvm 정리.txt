1.젯팩컴포즈의 기본
*1.개요
  @Composable로 사용자지정ui구성요소를 쉽게만들수있고
  싱글액티비티로 만들게되는데,이러면 더 ui가 쉬워짐
  
*2.Jetpack Compose
  젯팩컴포즈를 사용하면 xml을 사용하지않고 코틀린코드로만 작성할수있음
  그래서 특정 액티비티에 종속되지않은 작고 무상태인 컴포넌트를 만들수있음
  그리고 구성요소에서 재사용및 테스트가 용이하게 만든 컴포넌트를 사용하면 상태가 명시적으로 전달됨
  이러면 상태에 대한 진실의근원이 하나가되고 서로 분리됨
  이렇게 상태가 변경되면 자동으로 ui가 업데이트되는식으로 동작함
  기본적으로 선언형으로 동작해서,변경된부분만 업데이트시키는 방식을 가짐
  
  @Composable는 저 어노테이션이 붙은 일반코틀린함수고,이 어노테이션은 컴포즈 컴파일러에게 이 함수를 상태와 연결하고,
  상태가 바뀌면 ui를 자동으로 업데이트할수있게 만들어줌
  즉 특정 뷰모델에 특정함수를 연동해두면,그 함수의 값이 변하면 자동으로 ui를 해당값으로 업데이트해준다는것
  
  즉 젯팩컴포즈는 ui에 비교적 상태가 없고,상태를 유지하지않는방식을 사용하고,거기에 뷰모델에다가 상태용 함수를 연결시키는방식으로 모델과 뷰를 분리시킴
  사용자가 클릭이벤트같은걸 발동시키면,거기에 연동된 함수를 값을 넣어서 실행시키는방식
  이렇게 유연성을 챙길수있음
  
*3.재구성(Recomposition) 
  초기구성(Initial composition)은 합성가능한 함수(컴포져블)를 처음 호출해서 ui를 표시하는시점을 말하고,
  재구성은 컴포저블함수들이 상태에 따라 ui를 재구성하거나 표시하는걸 말함
  
  컴포즈에서 컴포저블객체의 내부상태를 변경할땐,새 데이터를 사용해서 해당 컴포저블객체를 호출하는함수를 다시 호출하기만 하면됨
  단 이때 remember을 사용해서 값을 저장해야함(원하는값에따라 밑에서 선택,위임패턴)
    var myValue by remember{mutableStateOf(false)} //boolean
	var myValue = remember{mutableStateOf(false)}//MutableState<boolean>
  이래야 값이 저장됨
  
  컴포저블함수안에서 다른 컴포저블 함수를 호출할수있고,컴포저블함수를 처음실행할떄(초기구성)는 함수전체가 실행되지만,재구성때는 변화가있는부분만 실행됨
  주의점은
    모든 컴포저블함수실행의 순서는 랜덤(비동기라),즉 자체적으로 완결성을 가져야함
	재실행은 낙관적으로 동작하고,취소될수도있음
	특정 함수들은 상당히 자주 실행될수있음(ui애니메이션의 각프레임마다 실행된다던가),이런함수에서 비용이 높은작업을 하면안됨
  
*4.상태
  컴포즈의 상태는 시간이 지남에 따라 변할수있는 모든 값을 말함
  예를들어 db에 저장된값,클래스의변수,기기의 센서에서 읽은값등이 있음
  컴포즈에서 ui는 불변이고,상태가 아님
  단 우리는 ui의 상태를 변경해서 값을 업데이트할수있음(재구성)
  
  컴포저블은 상태를 허용하고 이벤트를 노출할수있고,상태는 변경될수있는 모든값임
  이벤트는 어떤일이 발생했음을 알리는 콜백이고,우리는 상태를 제어해서 ui를 재구성시킬수있음
  
  컴포저블함수에는 스테이트풀과 스테이스리스가 둘다 있음
  스테이트풀을 재사용과 테스트가 어려우니까 가급적 스테이스리스로 만드는게 좋음
  이를위해 상태 호이스팅을 활용할수있음
  상태를 매개변수로 대체하고,람다를 사용해서 이벤트를 표현하는것
  즉 상태를 직접 저장하지말고,매개변수로 바꿔서 주입받는거
    @Composable
	fun abc(name:String,
	  onNameChange:(String)->Unit //이벤트를 람다로 받기
	){
	  TextField(
	    value=name,
		onValueChange=onNameChange //이벤트를 람다로 받기
		
	  )
	}
  이런식으로하면 ui와 로직을 분리시키고(상태와도 분리시키고),기능때문에 ui코드를 건드리지않아도됨
  즉 mvvm패턴임
  여기서 상태홀더로 사용되는게 ViewModel이고,얘가 컴포저블의 상태를 모아두는 역할을 하게됨
  그래서 ui상태와 이벤트를 캡슐화할수있음
  
  이런식으로 하는게
    @Composable
	fun abc(
	  abcViewModel:AbcViewModel=viewModel()
	){
	  val name:String by abcViewModel.name.observeAsState("") //observeAsState특정상태를 관찰
	  TextField(
	    value=name,
		onValueChange={abcViewModel.onValueChange(it)} 
		
	  )
	}
  이렇게 처리해버리는거

*5.컴포즈 라이프사이클
  컴포지션은 컴포저블(ui)의 트리계층구조임
  초기구성에서 모든 컴포저블을 생성하고,
  재구성이 발생하면 해당하는 컴포저블을 업데이트함
  
  컴포저블은 초기구성에 의해서만 생성되고,재구성에 의해서만 업데이트됨
  컴포저블을 컴포지션에 들어가고,여러번 재구성된후,컴포지션을 종료하면 죽음(보통 종료할때)
  
  모든 호출된 컴포저블은 컴포저블이 호출되는 소스의 위치별로 인스턴스가 생성되고,이를통해 재구성마다 다시시작하지않게해줌
  컴포저블을 여러번 호출하면 컴포지션에도 여러번 추가되고,
  같은곳에서 여러번 호출하면 인스턴스를 고유하게 유지하기위해 호출장소+실행순서를 적용하는데 이거때문에 이상한동작을 할수있음
  만약 리스트에서 맨 마지막에 값이 추가된다면 이전값들은 재사용할수있지만
  리스트에서 맨위나 중간이 변경,삭제되면 해당 리스트의 전체 컴포저블이 재구성됨
  
  컴포즈는 런타임에 특정객체를 식별할때 사용하는키를 받을방법을 제공하는데
    key(id값등){
	  객체
	}
  이건 전역적으로 고유할핋요는없고,해당지점에서만(해당 반복문속의 리스트내에서만)고유하면됨
  

*6.사이드이펙트
  사이드이펙트는 컴포저블의 범위밖에서 발생하는 상태의 변화를 말함
  함수와 모든 컴포저블은 사이드이펙트가 없어야하지만,컴포저블에서 상태를 변경해야할땐 상태변경을 위한 메서드를 호출해야함
  이건 예측가능한방식으로 동작해야함
  ui를 생성하지않고,컴포지션이 실행할때 사이드이팩트를 일으켜야함
  
  재구성은 컴포저에 의해 제어되는데,그래서 우리는 통제권이별로없음
  그래서
    number++
  대신
    SideEffect{
	  number++
	}
  이렇게 표시해줘야함
  보통 외부api호출등이 많음
  이런 사이드이펙트 처리를 위해 Effect Handlers를 사용할수있음
  이걸 사용해서 사이드이펙트의 수명주기를 제어하고 정리할수있음
  이 이펙트핸들러는
    Suspended:네트워크등 비동기작업을 안전하게 처리하기위해 사용되는 코루틴기반메커니즘
	  LaunchedEffect{}:컴포저블내부에서 suspend함수를호출할때 사용,키가 필수,매개변수로 전달된 코드로 코루틴을 실행시킴
	    키가 변경되면 기존코루틴이 취소되고 새코루틴에서 새 suspend함수가 실행됨
	  rememberCoroutineScope{}:컴포저블이 컴포지션을 떠나면 자동으로 취소됨,사용자 상호작용에 따른 비동기작업을 실행할떄 유용함
	  produceState{}:LaunchedEffect에서 결과를 State에 쉽게 넣게해줌,키가없으면 Unit를 사용하고,컴포지션 전반에서 상태가 유지됨
    Non-Suspended:코루틴을 사용하지않는 동기적인 사이드이펙트를 안전하게 사용하기위해 사용됨
	  컴포지션에 들어갈때 콜백을 초기화하기위해 사이드이펙트를 실행하고,컴포지션을 나갈때 폐기
	  SideEffect{}:컴포즈가 관리하지않는객체와 컴포즈 상태를 공유할떄사용,재구성이 될때마다 호출됨(컴포지션이 실패하면 폐기됨)
	  DisposableEffect{}:키가 변경되거나 컴포저블이 컴포지션을 종료한후 정리해야할때 사용(기존실행되던걸 지우고 새로시작해야할때),
	    키가 변경되면 컴포저블이 현재이펙트를 삭제하고 이펙트를 다시 호출해서 재설정해야함
  로 나눠짐


*7.레이아웃
  젯팩컴포즈에서 레이아웃은 
    row:수평방향정렬
    Column:수직방향정렬
	Box:이전요소위에 계속 쌓이는식으로 동작
  가 있고,사용자지정레이아웃도 만들수있음
  여기서 적용할수있는 속성들로는
	수정자:모든 컴포저블에 적용되는값을 추가할수있음(패널에 기본값추가하는느낌),fillMaxSize(),padding(),backgroungd()등을 넣을수있음
	  넣는순서대로 적용됨(패딩먼저하고 백그라운드하면 정상적으로 나오지만,백그라운드하고 패딩하면 먼저 백그라운드부터 칠해서 패딩티가안남)
	세로(가로)배열:레이아웃의 배열방식을 지정(상단이 기본값이고,하단에서부터 채울지 중앙부터할지등),spaceBetween,SpaceAround등이 있음
	수평정렬
	컴포저블컨텐츠람다
  를 지원함
	













  
  
  
  
  