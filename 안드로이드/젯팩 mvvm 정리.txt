1.젯팩컴포즈의 기본
*1.개요
  @Composable로 사용자지정ui구성요소를 쉽게만들수있고
  싱글액티비티로 만들게되는데,이러면 더 ui가 쉬워짐
  
*2.Jetpack Compose
  젯팩컴포즈를 사용하면 xml을 사용하지않고 코틀린코드로만 작성할수있음
  그래서 특정 액티비티에 종속되지않은 작고 무상태인 컴포넌트를 만들수있음
  그리고 구성요소에서 재사용및 테스트가 용이하게 만든 컴포넌트를 사용하면 상태가 명시적으로 전달됨
  이러면 상태에 대한 진실의근원이 하나가되고 서로 분리됨
  이렇게 상태가 변경되면 자동으로 ui가 업데이트되는식으로 동작함
  기본적으로 선언형으로 동작해서,변경된부분만 업데이트시키는 방식을 가짐
  
  Composable은 구성가능한함수,ui라고 보면되고,이함수는 데이터를 입력받아 화면이 어떻게 보여야하는지를 선언함
  그래서 반환값이없고 정보를 방출하기만함(클래스라고 봐도됨)
  
  Composition은 컴포저블이 실행되어서 만들어진 ui트리구조임(인스턴스라고 봐도됨)
  실제로 보게되는 ui를 말하고,얘는 상태저장소를 가지고,동적으로 업데이트를 할수있음
  또한 데이터가 바뀌면(상태가 바뀌면) recomposition으로 해당부분과 관련된 composable함수를 다시 실행하고,그결과를 바탕으로 컴포지션을 업데이트함
  
  @Composable는 저 어노테이션이 붙은 일반코틀린함수고,이 어노테이션은 컴포즈 컴파일러에게 이 함수를 상태와 연결하고,
  상태가 바뀌면 ui를 자동으로 업데이트할수있게 만들어줌
  즉 특정 뷰모델에 특정함수를 연동해두면,그 함수의 값이 변하면 자동으로 ui를 해당값으로 업데이트해준다는것
  
  즉 젯팩컴포즈는 ui에 비교적 상태가 없고,상태를 유지하지않는방식을 사용하고,거기에 뷰모델에다가 상태용 함수를 연결시키는방식으로 모델과 뷰를 분리시킴
  사용자가 클릭이벤트같은걸 발동시키면,거기에 연동된 함수를 값을 넣어서 실행시키는방식
  이렇게 유연성을 챙길수있음
  
*3.재구성(Recomposition) 
  초기구성(Initial composition)은 합성가능한 함수(컴포져블)를 처음 호출해서 ui를 표시하는시점을 말하고,
  재구성은 컴포저블함수들이 상태에 따라 ui를 재구성하거나 표시하는걸 말함
  
  컴포즈에서 컴포저블객체의 내부상태를 변경할땐,새 데이터를 사용해서 해당 컴포저블객체를 호출하는함수를 다시 호출하기만 하면됨
  단 이때 remember을 사용해서 값을 저장해야함(원하는값에따라 밑에서 선택,위임패턴)
    var myValue by remember{mutableStateOf(false)} //boolean
	var myValue = remember{mutableStateOf(false)}//MutableState<boolean>
  이래야 값이 저장됨
  
  컴포저블함수안에서 다른 컴포저블 함수를 호출할수있고,컴포저블함수를 처음실행할떄(초기구성)는 함수전체가 실행되지만,재구성때는 변화가있는부분만 실행됨
  주의점은
    모든 컴포저블함수실행의 순서는 랜덤(비동기라),즉 자체적으로 완결성을 가져야함
	재실행은 낙관적으로 동작하고,취소될수도있음
	특정 함수들은 상당히 자주 실행될수있음(ui애니메이션의 각프레임마다 실행된다던가),이런함수에서 비용이 높은작업을 하면안됨
  
*4.상태
  컴포즈의 상태는 시간이 지남에 따라 변할수있는 모든 값을 말함
  예를들어 db에 저장된값,클래스의변수,기기의 센서에서 읽은값등이 있음
  컴포즈에서 ui는 불변이고,상태가 아님
  단 우리는 ui의 상태를 변경해서 값을 업데이트할수있음(재구성)
  
  컴포저블은 상태를 허용하고 이벤트를 노출할수있고,상태는 변경될수있는 모든값임
  이벤트는 어떤일이 발생했음을 알리는 콜백이고,우리는 상태를 제어해서 ui를 재구성시킬수있음
  
  컴포저블함수에는 스테이트풀과 스테이스리스가 둘다 있음
  스테이트풀을 재사용과 테스트가 어려우니까 가급적 스테이스리스로 만드는게 좋음
  이를위해 상태 호이스팅을 활용할수있음
  상태를 매개변수로 대체하고,람다를 사용해서 이벤트를 표현하는것
  즉 상태를 직접 저장하지말고,매개변수로 바꿔서 주입받는거
    @Composable
	fun abc(name:String,
	  onNameChange:(String)->Unit //이벤트를 람다로 받기
	){
	  TextField(
	    value=name,
		onValueChange=onNameChange //이벤트를 람다로 받기
		
	  )
	}
  이런식으로하면 ui와 로직을 분리시키고(상태와도 분리시키고),기능때문에 ui코드를 건드리지않아도됨
  즉 mvvm패턴임
  여기서 상태홀더로 사용되는게 ViewModel이고,얘가 컴포저블의 상태를 모아두는 역할을 하게됨
  그래서 ui상태와 이벤트를 캡슐화할수있음
  
  이런식으로 하는게
    @Composable
	fun abc(
	  abcViewModel:AbcViewModel=viewModel()
	){
	  val name:String by abcViewModel.name.observeAsState("") //observeAsState특정상태를 관찰
	  TextField(
	    value=name,
		onValueChange={abcViewModel.onValueChange(it)} 
		
	  )
	}
  이렇게 처리해버리는거

*5.컴포즈 라이프사이클
  컴포저블의 생명주기는 단순하게
    컴포지션진입(초기구성)
	리컴포지션(재구성)
	컴포지션이탈(해당컴포저블이 필요없어졌을때,if가 false가 된다던지,리스트에서 스크롤되어서 화면밖으로 벗어나서 삭제된다던지)
  로 구성됨
  
  재구성이 일어나면 함수를 다시 실행한다는게 중요함
  즉 기본적으로는 해당함수내의 변수가 초기화되는데,이때 remember을 사용할경우에만 해당값을 가져가게됨
  이때 만약 컴포지션에서 이탈했다가 다시 들어올경우엔,remember했던값도 초기화됨

  컴포지션은 컴포저블(ui)의 트리계층구조임
  초기구성에서 모든 컴포저블을 생성하고,
  재구성이 발생하면 해당하는 컴포저블을 업데이트함
  
  컴포저블은 초기구성에 의해서만 생성되고,재구성에 의해서만 업데이트됨
  컴포저블을 컴포지션에 들어가고,여러번 재구성된후,컴포지션을 종료하면 죽음(보통 종료할때)
  
  모든 호출된 컴포저블은 컴포저블이 호출되는 소스의 위치별로 인스턴스가 생성되고,이를통해 재구성마다 다시시작하지않게해줌
  컴포저블을 여러번 호출하면 컴포지션에도 여러번 추가되고,
  같은곳에서 여러번 호출하면 인스턴스를 고유하게 유지하기위해 호출장소+실행순서를 적용하는데 이거때문에 이상한동작을 할수있음
  만약 리스트에서 맨 마지막에 값이 추가된다면 이전값들은 재사용할수있지만
  리스트에서 맨위나 중간이 변경,삭제되면 해당 리스트의 전체 컴포저블이 재구성됨
  
  컴포즈는 런타임에 특정객체를 식별할때 사용하는키를 받을방법을 제공하는데
    key(id값등){
	  객체
	}
  이건 전역적으로 고유할핋요는없고,해당지점에서만(해당 반복문속의 리스트내에서만)고유하면됨
  

*6.사이드이펙트
  사이드이펙트는 컴포저블의 범위밖에서 발생하는 상태의 변화를 말함
  컴포즈함수는 ui를 그리기위해 수시로 리컴포지션됨
  근데 만약 db접근같은걸 여기서 그냥 해버리면 무한히 요청해서 리소스를 다 빨아먹을수가있음
  그래서 예측가능한방식으로 동작해야함
  ui를 생성하지않고,컴포지션이 실행할때 사이드이팩트를 일으켜야함
  
  재구성은 컴포저에 의해 제어되는데,그래서 우리는 통제권이별로없음
  그래서
    number++
  대신
    SideEffect{
	  number++
	}
  이렇게 표시해줘야함
  보통 외부api호출등이 많음
  이런 사이드이펙트 처리를 위해 Effect Handlers를 사용할수있음
  이걸 사용해서 사이드이펙트의 수명주기를 제어하고 정리할수있음
  이 이펙트핸들러는
    Suspended:네트워크등 비동기작업을 안전하게 처리하기위해 사용되는 코루틴기반메커니즘
	  LaunchedEffect{}:한번만 실행하거나 특정값이 바뀔때만 실행하고싶을때 사용
	    컴포저블내부에서 suspend함수를호출할때 사용,키가 필수,매개변수로 전달된 코드로 코루틴을 실행시킴
	    키가 변경되면 기존코루틴이 취소되고 새코루틴에서 새 suspend함수가 실행됨
	  rememberCoroutineScope{}:컴포저블이 컴포지션을 떠나면 자동으로 취소됨,사용자 상호작용에 따른 비동기작업을 실행할떄 유용함
	  produceState{}:LaunchedEffect에서 결과를 State에 쉽게 넣게해줌,키가없으면 Unit를 사용하고,컴포지션 전반에서 상태가 유지됨
    Non-Suspended:코루틴을 사용하지않는 동기적인 사이드이펙트를 안전하게 사용하기위해 사용됨
	  컴포지션에 들어갈때 콜백을 초기화하기위해 사이드이펙트를 실행하고,컴포지션을 나갈때 폐기
	  SideEffect{}:컴포즈가 관리하지않는객체와 컴포즈 상태를 공유할떄사용,재구성이 될때마다 호출됨(컴포지션이 실패하면 폐기됨)
	  DisposableEffect{}:키가 변경되거나 컴포저블이 컴포지션을 종료한후 정리해야할때 사용(기존실행되던걸 지우고 새로시작해야할때,즉 정리가 필요할떄 사용),
	    키가 변경되면 컴포저블이 현재이펙트를 삭제하고 이펙트를 다시 호출해서 재설정해야함
  로 나눠짐


*7.레이아웃
  젯팩컴포즈에서 레이아웃은 
    row:수평방향정렬
    Column:수직방향정렬
	Box:이전요소위에 계속 쌓이는식으로 동작
  가 있고,사용자지정레이아웃도 만들수있음
  여기서 적용할수있는 속성들로는
	수정자:모든 컴포저블에 적용되는값을 추가할수있음(패널에 기본값추가하는느낌),fillMaxSize(),padding(),backgroungd()등을 넣을수있음
	  넣는순서대로 적용됨(패딩먼저하고 백그라운드하면 정상적으로 나오지만,백그라운드하고 패딩하면 먼저 백그라운드부터 칠해서 패딩티가안남)
	세로(가로)배열:레이아웃의 배열방식을 지정(상단이 기본값이고,하단에서부터 채울지 중앙부터할지등),spaceBetween,SpaceAround등이 있음
	수평정렬
	컴포저블컨텐츠람다
  를 지원함
	

2.앱제작
*1.프로젝트 생성
  프로젝트를 만들땐 empty Activity를 고르면됨(구버전 안드스튜디오는 empty Compose Activity)
  
  생성된 프로젝트의 메인액티비티가 메인뷰고,
  theme폴더안에 미리 설정된값상수들이 들어있음(색,타입,테마등)
  추가할거있으면 여기다가 추가해도됨
  나머진 이름그대론데,테마는 다크모드거나 라이트모드,또는 또 다른 테마를 넣을때 묶어서 선언해두는곳임
  그리고 테마의 밑에 컴포저블함수에서 무슨테마를 사용할지를 조건에 따라 넣으면됨
  또한 여기선 컨텐츠람다를 넣을수있는데,이건 메인액티비티에서 컴포저블트리를 정의할수있다는걸 의미함

*2.종속성 추가
  루트레벨 빌드그래들의 플러그인에
    id("com.google.devtools.ksp") version "2.0.21-1.0.27" apply false
	id("com.google.dagger.hilt.android") version "2.57.2" apply false
  추가하고
  앱레벨 빌드그래들의 플러그인에
    id("com.google.devtools.ksp")
    id("com.google.dagger.hilt.android")
  추가한후
  디펜던시에
    val roomVersion = "2.8.4"
    implementation("androidx.room:room-runtime:$roomVersion")
    ksp("androidx.room:room-compiler:$roomVersion")

    implementation("androidx.datastore:datastore-preferences:1.2.0")

    implementation("com.google.dagger:hilt-android:2.57.2")
    ksp("com.google.dagger:hilt-android-compiler:2.57.2")
  추가

*3.모델클래스 생성
  룸을 사용할때,엔티티를 선언할땐
    @Entity(tableName = 테이블명)
  를 붙이면됨
  
  대략적으로
    @Entity(tableName = 테이블명)
    data class ToDoTask(
	  @PrimaryKey(autoGenerate = true)
      val id: Int = 0, //0을 기본값으로 넣어주면 알아서 생성함(오토인크리즈먼트일떄)
	  val title: String,//@ColumnInfo(name="abc")로 상세속성설정가능
      val desc: String,
      val priority: Priority,
    )

*4.room 기본
  룸은 orm임
  얘는
    Database:db에 대한 접근역할
	DAO:db에 날릴 쿼리(레포지토리라고 생각하면됨)
	Entity:객체를 나타냄(테이블이라고 생각해도됨)
  그냥 jpa랑 거의 비슷함
  엔티티는 위에쓴거처럼 쓰면되고,dao는 jpa레포지토리랑 거의 비슷하게 쓰면됨
    @Dao
	interface AbcDao{
	  @Query("select * from abc_table")
	  fun abcAll():Flow<List<Person>>  //비동기처리를 위해 Flow사용
	  
      @Query("SELECT * FROM todo_table WHERE id=:taskId")
      fun getSelectedTask(taskId: Int): Flow<ToDoTask>	
	  
	  @Query("SELECT * FROM todo_table WHERE title LIKE :taskName")
      fun searchTitleTask(taskTitle: Int): Flow<List<ToDoTask>>

      @Insert(onConflict = OnConflictStrategy.IGNORE) //충돌났을때 어떻게 처리할지,즉 트랜잭션 롤백할지 덮어씌울지 무시할지등
      suspend fun addTask(toDoTask: ToDoTask)
	  
	  @Update
	  suspend fun update(toDoTask: ToDoTask)
	}
  이런식
  Flow를 사용하면 코루틴으로 동작해서 suspend를 안붙여도되지만,Flow를 사용하지않는(못하는) 인서트 업데이트등은 suspend를 붙여서 비동기처리해야함
  
  데이터베이스는
    @Database(entities=arrayOf(AEntity::class),version=1,exportSchema = false)
	abstract class AEntityDatabase:RoomDatabase(){
	  abstract fun abcDao():AbcDao
	}
  이런식으로 만들면됨
  데이터베이스는 싱글톤으로 만들어져야하고,그래서 대거힐트를 사용해서 di받아서 쓰는게좋음
  
*5.의존성주입이란
  다아는내용
  테스트가쉽고,리팩토링이쉽고,코드재사용성이 높다
  약의존이 쓰기편하다

*6.대거힐트 라이브러리
  이건 의존성주입 라이브러리임
  이걸 사용할땐 
    @HiltAndroidApp
	class MyApplication:Application(){...}
  를 만들고(얘가 어플리케이션레벨 종속성 컨테이너역할을 함,@SpringBootApplication같은거)
    @AndroidEntryPoint
	class ExampleActivity:AppCompatActivity(){...}
  @AndroidEntryPoint는 @Component같은거임(주입대상표시)
  이걸 액티비티들에 달아줘야하는데,젯팩컴포즈는 단일액티비티니까 거기만 달면됨
  또한 뷰모델,서비스,레포지토리등도 이런식으로 처리하면됨
  
  바인딩은 di를 받을때,이걸 어떻게 받을건지를 알려주는 어노테이션임
  그 생성자주입이랑 세터주입같은거  
  근데 보통 생성자주입쓸테니
    class MyAbc @Inject constructor(
	  private val service:MyService
	)
  이런식으로 처리하면됨(@Inject)
  생성자에 @Inject를 붙이면 붙인 클래스(여기선 MyAbc)를 이런식으로 생성하면 된다는걸 알게되고,저걸 만들어서 주입할수있게됨
  안에 의존하고있는 인터페이스는,해당인터페이스를 빈등록해둔게 있다면 자동으로 알아서 들어가게됨(뷰모델까지) 
  
  뷰모델의 경우는
    @HiltViewModel
	class MainViewModel @Inject constructor(
		private val repository: MyRepository // 생성자 주입
	) : ViewModel() {
		
		fun getMessage() = repository.getData()
	}	
  이렇게 만들고,이렇게 생성자주입만 가지고 레포지토리,서비스 뷰모델까지 처리한후에,뷰모델을 액티비티나 프래그먼트에서 부를땐,생성자를 쓸수없음(시스템이 만드니까)
  그래서
    private val viewModel: MainViewModel by viewModels()
  을 사용하게됨
  MainViewModel은 힐트가 미리 만들어둔 클래스고,저안에 다 들어있음
  만약 뷰모델이 아닌 다른 일반클래스가 필요하다면
	@Inject
    lateinit var analyticsManager: AnalyticsManager    
  이렇게 하면됨
  즉
  @AndroidEntryPoint
	class MainActivity : AppCompatActivity() {
		
		// by viewModels() 위임자를 사용하면 자동으로 주입된 ViewModel을 가져옴
		private val viewModel: MainViewModel by viewModels() 

		override fun onCreate(savedInstanceState: Bundle?) {
			super.onCreate(savedInstanceState)
			// 사용
			println(viewModel.getMessage())
		}
	}
  이렇게
  
  힐트모듈은 특정타입의 인스턴스를 제공하는 방법을 정의하는곳임
  즉 이 인터페이스에서 사용할 인스턴스를 제공해야하는데,내가 소유하지않은(외부라이브러리등)인스턴스를 주입할때 사용함
  이걸 사용해서 힐트에 바인딩정보를 제공하는것
  이건
    @Module
	@Installln(SingletonComponent::class)//이렇게 설정하면 싱글톤으로 동작
	class MyModule{...}
  이런식으로 @Module어노테이션으로 처리하고,얘는 어떤식으로 특정인스턴스를 제공할지를 줘야함
  이건 기본적으로 스코프형식으로 바인딩함
    @Singleton
	@ServiceScoped
	@ActivityScoped @ViewModelScoped       
    @ViewScoped
  위에서부터 아래로 내려가면서,상위구성요소에는 접근할수없음
	Component (@InstallIn)	   Scope Annotation	    생명주기 (언제 죽나?)	             사용 예시
	SingletonComponent	        @Singleton	           앱 종료 시	             Retrofit, DB, 공용 Util
	ViewModelComponent	        @ViewModelScoped	 ViewModel 소멸 시	          ViewModel 관련 로직
	ActivityComponent	        @ActivityScoped	    Activity 종료 시	         Activity 전용 어댑터, 매니저
	FragmentComponent	        @FragmentScoped	   Fragment 종료 시	         Fragment 전용 객체
  대충 이런식으로 있음
  
  다른 바인딩방법도 있는데,만약 인터페이스를 주입하고싶다면
    @Binds
	abstract fun bindMyService(
	  myServiceImpl:MyServiceImpl
	):MyService
  이런식으로 구현체를 선택해서 주입하면됨
  이것도 외부라이브러리라 불가능하거나,빌더패턴써야하면 @Provides를 쓸수있음
    @Singleton //이거안붙이면 매 호출마다 새로운게 나옴
	@Provides
	fun provideDB(
	  @ApplicationContext context:Context
	)= Room.databaseBuilder(
	  context,
	  MyDB::class.java,
	  "db_name"
	).build()
  이런식으로 할수있음
  여기서 @ApplicationContext context:Context는,힐트가 미리 만들어둔 컨텍스트로,앱전체생명주기를 따르는 컨텍스트임
  
  요약하면
    내 클래스다? -> 생성자에 @Inject 붙이기.  //Component,@Service같은거,빈등록이라고 보면됨
	인터페이스다? -> Module 만들고 @Binds (abstract class). //스프링에서  구현클래스 하나일때 자동감지해주던거 반드시 수동으로 한다고 생각하면됨
	라이브러리 클래스다? -> Module 만들고 @Provides (object). //@COnfigration에서 수동빈생성이라고 보면됨
	싱글톤이 필요해? -> 클래스나 Provides 위에 @Singleton 붙이기. //스프링은 기본적으로 싱글톤이지만,여기선 명시해줘야함
	Context 필요해? -> 생성자 인자에 @ApplicationContext 붙이기.
  
  
*7.대거힐트 사용법
  가장먼저 Application을 상속받는 클래스를 만들고,@HiltAndroidApp을 붙이기 
	@HiltAndroidApp
	class TodoApplication : Application()  
  그리고 Android Manifest.xml로 가서 application 태그에 name속성을 추가해야함
      <application
        android:name=".TodoApplication"
		...
  그리고 메인액티비티에
    @AndroidEntryPoint
    class MainActivity : ComponentActivity() {
  을 붙이면됨
  
  그리고 패키지를 만들고(di설정패키지,스프링의 configuration모아둔곳같은거)
  만약 인터페이스를 주입해야하거나,소유하지않은타입을 주입해야할땐
  object로 모듈을 만들어야함(@bean이라고 봐도됨),
  object는 어떨때 사용되냐면
    싱글톤
	컴패니언오브젝트(이것도 오브젝트임)에서 팩토리메서드만들때
	무명클래스선언
  이때 사용됨
  주로 싱글톤구현에 사용됨(클래스선언과 동시에 객체가 생성되기때문)
  얘도 클래스라서 상속과 구현,합성 다 가능하고 객체명을 통해 접근할수있음
  그안에서 해당객체를 제공하는 함수를 만들면됨
  대충 이런식임
	@Module
	@InstallIn(SingletonComponent::class)
	object DatabaseModule {
	
		@Singleton
		@Provides
		fun provideDatabase(
			@ApplicationContext context: Context,
		) = Room
			.databaseBuilder(
				context,
				TodoDatabase::class.java,
				DATABASE_NAME,
			).build()
		
		@Singleton
		@Provides
		fun provideDao(database: TodoDatabase) = database.toDoDao()
	}
  이렇게	
  
*8.레포지토리
  레포지토리는 그냥 dao di받아서 만들면됨
  특별할거없음
  suspend붙은 비동기함수 콜하는함수에서는 suspend를 붙여줘야한다는거정도랑
  flow정도?
  
*9.뷰모델  
  뷰모델은 여러 화면(컴포넌트)에서 공유가능할수있고,뷰모델은 레포지토리,서비스등을 주입받아서 사용함(컨트롤러라고 봐도됨)
  뷰모델은 ui패키지에 따로 패키지를 파서 만드는경우가많음
  
  뷰모델에서 사용하는(di받는) 클래스들은 @ViewModelScoped를 붙여줘야함(뷰모델에서 접근가능하다는 스코프)
  뷰모델은 @HiltViewModel를 붙여서 힐트에게 이클래스가 뷰모델이라는걸 알려줘야하고(뷰모델만 특이하게 이럼,안드로이드os가 만들어야하기때문) 
  그리고 뷰모델은 ViewModel()를 상속받아야함
  
  뷰모델의 함수는 기본적으로 뷰모델의 수명주기에 연결된 코루틴에서 실행하면됨(viewModelScope.launch {...})
  대략
    @HiltViewModel
	class SharedViewModel @Inject constructor(
		private val repository: TodoRepository,
	) : ViewModel() {

		private val _allTasks = MutableStateFlow<List<ToDoTask>>(emptyList())
		val allTasks: StateFlow<List<ToDoTask>> = _allTasks

		fun getAllTasks() {
			viewModelScope.launch {
				repository.getAllTasks.collect { //collect->flow에서 들어오는 모든데이터를 순서대로 처리
					_allTasks.value = it
				}
			}
		}
	}
  이런식으로 구성됨
  
*10.네비게이션
  젝팻컴포즈의 네비게이션은 페이지간 이동이고,이건 웹에서 url로 접근하는거와 비슷함
  이걸할떈 네비게이션컨트롤러,네비게이션그래프,네비게이션호스트가 필요함
  
  네비게이션을 사용해서 파라미터를 보낼땐,객체전체를 보내는게 아닌,스트링,인트같은 기본형값만 보내고 그걸 가지고 조회하든가 해서 사용하는게 국룰임
  즉 id같은걸 보내서 그걸 검색하든가 하는식임
  
  네비게이션 컨트롤러를 사용해서 일반적으로 이동하는형식이고,네비게이션 컨트롤러는 모든 컴포저블데이터가 생성할수있는곳에 위치해야함
  네비게이션 컨트롤러는 하나의 네비게이션 호스트에 연결되어있어야하고,네비게이션 호스트는 기본적으로 컨트롤러를 통해 이동할수있는 모든 대상들을 연결함
   
  호스트는
    NavHost(
	  navController=navController,
	  startDestination="home"//시작위치
	)
  이런식으로 작성됨
  내비게이션 그래프 또는 호스트의 목적지는 컴포저블함수내에서 정의됨
    composable(
	  route:"datails/{id}",
	  arguments=listOf(navArgument("id")){
	    type=NavType.IntType
	  }
	){navBackStackEntry->
	  ...
	}
  이런식임
  이걸 사용할땐 해당 컴포넌트의 컴포저블함수에서 온클릭이벤트등으로 넣어서 사용하면됨
    @Composable
	fun Home(navController:NavController){
	  Button(onClick={navController.navigate("details/10")}){
	    Text(text="OPEN")
	  }
	}
  이렇게 컨트롤러 받아서 저걸로 이동하면됨
  navigate는 새목적지를 백스택에 추가하고,동작방식을 수정할수있음
  이때 추가옵션들을 연결해서 내비게이터를 만들수있음
  또한 매개변수(아규먼트)를 받을수있는데,datails/{id}이런식으로 받는거 말하는거임
  이걸 사용해서 해당페이지로 이동할땐
    navController.navigate("details/10")
  이렇게 이동하면되고,
  이걸 함수내에서 읽고싶다면
    val number=navBackStackEntry.arguments?.getInt("id")
  이런식으로 받을수있음
  이때 필수도있고 선택도 넣을수있는데,기본적으로는 필수고,선택을 하려면
    ?아규먼트이름={}
	defaultValue를 설정하거나,nullability를 true로 설정
  이런식으로 해야함
  
*11.네비게이션 사용
  네비게이션컨트롤러는 모든컴포저블에서 사용할수있게 메인액티비티에 위치하게되고,
  이 컨트롤러는 연결가능한 모든 컴포저블들의 그래프를 가지는 하나의 호스트에 연결됨
  컨트롤러는 이동,뒤로가기등 동작을 담당하고,
  호스트는 컨트롤러와 그래프를 연결시켜주는걸 담당함
  그래프는 각 화면을 식별하는 주소전체를 모아둔 객체를 의미함
  
  컨트롤러는 rememberNavController()을 사용해서 라이브러리에서 값을 받을수있고,
  호스트는 메인액티비티에서 생성하고,호스트에서 컨트롤러와 그래프를 받고(일반적으로 그래프는 람다로 바로생성) 사용하게됨
  즉
    val navController = rememberNavController() //컨트롤러 생성
	NavHost(
		navController = navController, //컨트롤러연결
		startDestination = Screen.HOME
	) { // <--- [여기서부터 람다 그래프 정의 시작] ---
		
		// 이 내부의 composable 함수들이 모여서 하나의 'NavGraph' 객체가 생성됩니다.
		
		composable(route = Screen.HOME) {
			HomeScreen(navController = navController)
		}

		composable(route = "${Screen.DETAIL}/{message}", ...) {
			...
			DetailScreen(...)
		}

	} // <--- [여기까지가 그래프입니다] ---
  
  
  네비게이션 컨트롤러를 사용하려면 일단 종속성을 하나 추가해야함
    implementation("androidx.navigation:navigation-compose:2.9.6")
  
  가장먼저 경로들을 관리할 상수클래스나 sealed class등을 만들어두면 좋음(하드코딩보다 실수할 확률이 줄어듬)
  그리고 각 화면(페이지)컴포저블을 만듬
  얘들이 만약 마지막페이지가 아니라면 NavController를 매개변수로 받아서 특정 버튼에 매핑해서 특정 경로로 이동할수있음
    Button(onClick={navController.navigate("details/10")})
  페이지가 다 만들어졌으면 메인액티비티에서 NavController를 만들고,NavHost를 연결해야함
  이때 NavHost의 {}안이 NavGraph임
	@AndroidEntryPoint
	class MainActivity : ComponentActivity() {

		private lateinit var navController: NavHostController

		override fun onCreate(savedInstanceState: Bundle?) {
			super.onCreate(savedInstanceState)
			enableEdgeToEdge()
			setContent {
				ToDoComposeTheme {
					navController = rememberNavController()
					NavHost(
							navController = navController,
							startDestination = 시작스크린경로상수
					){
						// 홈 화면 정의
						composable(route = Screen.Home.route) {
							HomeScreen(navController = navController)
						}

						// 상세 화면 정의
						composable(route = Screen.Detail.route) {
							DetailScreen(navController = navController)
						}					
					}
				}
			}
		}
	}
  이때 너무 복잡하다싶으면 따로 NavHost를 생성하는 컴포저블함수를 만들고,거기서 생성해도됨
  또한 각 페이지 컴포저블도 분리할수있음(각각 그래프조각을 생성하고 합치는느낌)
    @Composable
	fun SetupNavigation(
		navController: NavHostController,
	) {
		val screen = remember(navController) {
			Screens(navController = navController)
		}
		NavHost(navController = navController, startDestination = LIST_SCREEN) {
			listComposable(
				navigateToTaskScreen = screen.task,
			)
			taskComposable(
				navigateToListScreen = screen.list,
			)
		}
	}
  페이지 컴포저블은 이렇게 NavGraphBuilder를 사용해서 그래프조각을 만드는식으로 만들면됨
	fun NavGraphBuilder.taskComposable(
		navigateToListScreen: (Action) -> Unit,
	) {
		composable(
			route = TASK_SCREEN,
			arguments = listOf(
				navArgument(TASK_ARGUMENT_KEY) {
					type = NavType.IntType
				},
			),
		) {이동할화면 컴포저블함수호출}
	}
  이렇게
  
  메인액티비티에선
    navController = rememberNavController()
    SetupNavigation(navController)
  이렇게 사용하고
  
  추가적으로 Composable안에서는 navController.navigate을 직접 호출하지말고,
  onNavigate: () -> Unit같은 람다를 받아서 상위에서 네비게이션로직을 처리하는게 재사용성에 좋음
  즉 ui와 navController의 직접의존성을 제거하는게 좋음
    Button(onClick = { 
        // 화면 안에 네비게이션 로직이 섞여있음
        navController.navigate("list")
		}
  이렇게 직접 navController를 호출하는게 아닌
    @Composable
	fun TaskScreen(navigateToList: (Action) -> Unit) {
		Button(onClick = { 
			// 난 네비게이션 몰라, 그냥 받은 함수 실행할 뿐이야
			navigateToList(Action.NO_ACTION) 
		}) { ... }
	}
  화면에서는 그냥 이렇게 람다를 받고,그냥 람다를 실행시키는거임
  그리고 해당 람다들을 모아둔 클래스를 만들고
	class NavigationActions(navController: NavHostController) {
		val list: (Action) -> Unit = { action ->
			navController.navigate("list/${action.name}") {
				popUpTo(LIST_SCREEN) { inclusive = true }
			}
		}
		val task: (Int) -> Unit = { taskId ->
			navController.navigate("task/$taskId")
		}
	}
  navhost에서는 이 람다클래스의 람다와 화면컴포저블을 연결만 시켜주는거
	@Composable
	fun SetupNavigation(
		navController: NavHostController,
	) {
		val NavigationAction = remember(navController) {
			NavigationActions(navController = navController)
		}
		NavHost(navController = navController, startDestination = LIST_SCREEN) {
			listComposable(
				navigateToTaskScreen = NavigationAction.task,
			)
			taskComposable(
				navigateToListScreen = NavigationAction.list,
			)
		}
	} 
  이러면 navController가 바뀌는거랑상관없이 재사용하거나 테스트가 더 쉬워짐
  즉 최종적인 구조는    
	호스트(컨트롤러,그래프(화면컴포저블들(화면ui),NavigationAction))
  이런식으로,화면컴포저블들과 액션들의 결합도를 제거하고,세부사항이 퍼져나가지않게 한곳에 몰아둔후,
  그래프(실질적으로는 호스트)에서 액션과 화면들을 결합하는식으로 세부사항을 분리한것
  이러면 화면에선 눌렀다는 이벤트만 상위로 던지면되고,이동로직이 전혀섞이지않게됨
  이동로직은 이동로직들끼리만 뭉쳐있을수있고(NavigationAction),
  그래프는 ui의 이벤트와 이동로직을 매핑하는일만 담당하게됨
  이러면 이동경로가 바뀌든 뭘하는 ui쪽은 손대지않고,NavigationAction쪽만 건드리면됨

  
  추가적인 팁으로 백스택을 없애서 해당화면을 뒤로가기로 못가게할수도있음
    navController.navigate("route") { popUpTo("home") { inclusive = true } }
  이렇게


    
  
*12.리스트 화면 만들기-플로팅버튼(FAB)
  스캐폴드는 머터리얼 라이브러리와 함께 사용되는 컴포저블함수로,이걸사용해서 쉽게 디자인 레이아웃구조를 구현할수있음
  플로팅버튼같은걸 추가하기도 편함
  이건 즉 미리 뼈대를 라이브러리에서 만들어뒀고,우리는 해당버튼등에 해당하는 컴포저블함수(컴포넌트)를 만들어서 넣어주기만 하면되는거
  즉 해당값이 있어야하는 위치(플로팅버튼은 오른쪽밑등)를 미리 위치를 잡아두고,우리는 거기에 넣기만하면됨
  이건
	@Composable
	fun ListScreen(
		modifier: Modifier = Modifier,
		navigateToTaskScreen: (taskId: Int) -> Unit,
	) {
		Scaffold(
			modifier = modifier,
			content = {},
			floatingActionButton = {
				ListFab(onFabClicked = navigateToTaskScreen)
			},
		)
	}
	@Composable
	fun ListFab(
		modifier: Modifier= Modifier,
		onFabClicked: (taskId: Int) -> Unit,
	) {
		FloatingActionButton(
			modifier = modifier,
			onClick = { onFabClicked(-1) }) {
			Icon(
				imageVector = Icons.Filled.Add,
				contentDescription = "Add Button",
				tint = Color.Black,
			)
		}
	}
  이런식으로 사용됨(Scaffold안에 컨트롤p로 넣을수있는 매개변수를 확인한후 넣으면됨)
  만약 contentDescription처럼 스트링을 여러군데서 똑같이쓰는데 하드코딩하기싫고,어디 한군데다 모아두고싶다면(중복제거),
  res의 value에 strings.xml에 값을 추가한후
    <string name="add_button">Add Button</string>
  이걸 불러다가 쓸수도있음
    contentDescription = stringResource(R.string.add_button)
  이렇게
  
  modifier는 컴포저블 함수들에게 패널같이 큰단위변화를 하위에 누적시키기위해 사용됨
  모디파이어는 하위로 갈수록 자신만의 Modifier을 계속 새로 만들어나가야함
	@Composable
	fun PriorityItem(priority: Priority, modifier: Modifier = Modifier) {
	Row(
		modifier = modifier,
		verticalAlignment = Alignment.CenterVertically,
	) {
		Canvas(modifier = Modifier.size(16.dp)) {
			drawCircle(color = priority.color)
		}
		Text(
			modifier = Modifier
				.padding(start = 12.dp),
			text = priority.name,
			style = Typography.titleMedium,
			color = MaterialTheme.colorScheme.onSurface,
		)
	  }
	}
  이런식으로 매개변수로 받은 모디파이어는 최상단에서 한번만쓰고,그 하위에서는 자기만의 모디파이어를 생성해서 써야함
  이래야 중복적용등의 문제가 안생기고,예측가능한방향으로 처리할수있음
	  
  
  만들어진 화면의 미리보기가 필요할경우(ide에서)
    @Composable
	@Preview
	private fun ListScreenPreview() {
		ListScreen(navigateToTaskScreen = {})
	}
  를 만들어두면 화면에 변수를 넣어서 미리볼수있음
  
  
*13.리스트 화면 만들기-앱 바
  앱바는 그 앱상단의 바를 말함,버튼들있거나 검색되거나 하는 그거
  이것도 스캐폴드에 있고,컴포저블함수만들어서 넣어주면됨
      Scaffold(
        modifier = modifier,
        topBar = { ListAppBar() },
		...
	  }
  이렇게
  
  앱바는
    @OptIn(ExperimentalMaterial3Api::class)
	@Composable
	fun DefaultListAppBar(modifier: Modifier = Modifier) {
		TopAppBar(
			modifier = modifier,
			title = {
				Text(text = "Tasks")
			},

			colors = TopAppBarColors(
				containerColor = MaterialTheme.colorScheme.primary,
				scrolledContainerColor = MaterialTheme.colorScheme.primary,
				navigationIconContentColor = MaterialTheme.colorScheme.onPrimary,
				titleContentColor = MaterialTheme.colorScheme.onPrimary,
				actionIconContentColor = MaterialTheme.colorScheme.onPrimary,
			),
		)
	}
  이런식으로 넣으면됨
  만약 앱바의 버튼을 눌렀을때 앱바를 교체(조회를 위해 버튼누르면 조회바로 변경해야할때)해야할때는,각각 앱바를 만든다음,교체시켜주면됨
  
  그리고 res/values/themes에 라이트모드랑 다크모드에 대한 설정이 이미 다 들어가있고,이걸 가지고 여기서 수정하면됨
  여기서 lightColorScheme와 darkColorScheme에 색상세트를 정의해둔다음,앱테마에서 isSystemInDarkTheme()로 수정하면됨 


*14.리스트 화면 만들기-앱 바 액션 추가  
  앱바에 actions를 추가할수있는데,이건 앱바에 버튼을 추가하는거
  새로운 아이콘이미지를 추가하고싶을땐,res/drawable에 벡터에셋을 추가한후,거기서 클립아트에서 원하는 아이콘을 검색해서 넣고 저장하면됨
  그리고 가져다쓸땐
	Icon(
		painter = painterResource(id = R.drawable.ic_filter_list),
		contentDescription = "Sort Tasks"
	)
  이렇게 가져다쓰면됨
  
  드롭다운메뉴를 추가할땐,해당메뉴가 열려있는지 닫혀있는지를 저장해둘 변수를 만들어야함
    var expanded by remember { mutableStateOf(false) }
  근데 이러면 by에서 에러가 뜰텐데,import를 수동으로 추가해줘야함
    import androidx.compose.runtime.getValue
    import androidx.compose.runtime.setValue
  그리고 열고닫기위해 각각 버튼을 누를때마다 저걸 바꿔주면됨
    IconButton(onClick = { expanded = true }) {//누르면 true로
      Icon(
        painter = painterResource(id = R.drawable.ic_filter_list),
        contentDescription = "Sort Tasks",
      )
    }
    DropdownMenu(expanded = expanded, onDismissRequest = { //onDismissRequest는 메뉴를 닫았을때의 이벤트임,여기선 변수false
        expanded = false
    }) {
        DropdownMenuItem(
            onClick = {  //누르면 메뉴변수변경후 클릭이벤트진행
                expanded = false
                onSortClick(Priority.LOW)
            },
            text = {
                Row(verticalAlignment = Alignment.CenterVertically) {
                    Text(text = "Sort by")
                    PriorityItem(priority = Priority.LOW)
                }
            },
        )
    }
  젯팩컴포즈는 선언형이기때문에,변수를 컨트롤하는거만으로 해당 상태에서의 변화가 자동으로 일어남

*15.리스트 화면 만들기-검색바 디자인
  검색바는 텍스트필드안에 아이콘,플레이스홀더,지우기버튼으로 구성됨
  디자인에서는 특별한건 없는듯
	keyboardOptions = KeyboardOptions(
		imeAction = ImeAction.Search,
	),
	keyboardActions = KeyboardActions(
		onSearch = {
			onSearchClick(text)
		},
	),
  로,해당 컴포넌트를 누를때 키보드를 띄우고,키보드의 검색버튼을 누를때 이벤트를 연결할수있다정도?

*16.리스트 화면 만들기-검색바 기능
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  

  
  
  
  
  