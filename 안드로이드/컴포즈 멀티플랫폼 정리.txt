1.젝팩컴포즈 기본
*1.젯팩컴포즈 소개
  스킵
*2.상태 및 재구성
  상태는 실제로 사용하고있는 컴포넌트의 상태(변수)임
  이건 remember을 사용하면,리컴포지션이 되었을때도 값을 유지하고있을수있음
  remember을 사용하지않았다면 그냥 초기화됨(그래서 리컴포지션이 되었을때 초기화되는식으로 변수유지하는 트릭이 있긴한데 안쓰는게좋음,화면회전등에서도 반응해서)
  즉 remember을 사용해서 순수함수에 사이드이펙트를 넣는느낌임
  이건
    var name by remember{
	  mutableStateOf("")
	}
  이런식으로 사용됨
  
  기본적으로 컴포저블함수안의 컴포넌트(TextField등)은 상태를 갖지않고,외부에 상태를 선언해둔후 끼우는식으로 만들게됨
  이래야 테스트와 유지보수가 쉬워짐
  이렇게 remember로 상태를 만들어두면 계속 그 상태를 옵저빙하고있게됨,
  그러다가 상태가 어떤이유로든 변경되면 해당 상태를 가지고있는 모든 컴포넌트들이 갱신되는데 이게 재구성(리컴포지션)임
  기본적으로 젯팩컴포즈는 선언형이고,그래서 값을 바꾸면 그 값에 맞춰서 다른것들이 수정되는형태를 띄는것
  
  보통 컴포넌트에서 마지막매개변수는 content람다를 받는데,제일마지막 람다니까 그냥 
	Button(
	  onClick=buttonClick()
	){
       ...
	}
  이런식으로 쓸수도있음
  보통 이건 그안에 뭘넣을지(버튼이라면 텍스트,아이콘등)을 정의하는곳임
  
  기본적으로 remember을 사용해서 상태를 기억하는(stateful)방식과,외부에서 값을 주입받는(stateless)방식이 있는데,가급적이면 스테이트리스를쓰는게 나음
    //스테이트풀
	@Composable
	fun abc(){
		var name by remember{
		  mutableStateOf("")
		}	
		...
	}
	//스테이트리스
    @Composable
	fun abc(name:String){
		...
	}  
  이래야 커스터마이징,테스트가 쉬움(프리뷰쓰기도편함)
  정말 꼭 필요하지않으면 내부상태유지(스테이트풀)는 하지않는게좋음
  
  기본적으로 재구성을 발생시키는건
    상태변경:상태(State,MutableState,LiveData/Flow)들중 collect되고있는애들이 변경될떄,즉 스테이트풀 변경시
	파라미터변경:컴포저블함수의 입력파라미터가 변경될때,즉 스테이트리스 변경시
	파생상태:derivedStateOf가 변경될때
  들임
  
  ui는 현재상태에 따라 ui를 출력하는 컴포지션함수들로 구성됨
  우리는 선언적으로,ui가 어떻게 보일지를 정의하면 이걸 알아서 그렇게 바꿔주고,상태가 변경되면 즉시 그 상태대로 바꿔주는거임
  이런과정을 리컴포지션이라고 부름
  
  그리고 불변데이터(val)는 remember로 업데이트하려면 통째로 갈아야함
  data class User(
    val name="abcd",
	val age:Int=29
  )
  var user by remember{
    mutableStateOf(User())
  }
  Button(
    onClick={
	  user=User(
	    name=user.name
		age=user.age+1
	  )
	}
  )  
  근데 그러면 너무 복잡하니까 .copy를 사용하면 편함
  이건 데이터클래스에서 자동으로 만들어주는 함수로,변경할값만 바꾸면됨
  Button(
    onClick={
	  user=User.copy(age=user.age+1)
	}
  )   
  
*3.구성변경 및 상태지속성
  구성변경이벤트란,사용자가 화면을 회전하거나 테마를 변경하는등의 상황에서 일어나는 이벤트임
	화면회전
	테마변경
	언어변경
	폰트변경
	시스템앱킬(강제종료)
  등의 상황에서 발생함
  이상황에서는 remember로 상태를 저장해도 저장이 되지않게됨
  그래서 사용되는게 rememberSaveable임
  이건 그냥 remember대신 그자리에 넣고쓰면됨
    var count by rememberSaveable{
	  mutableStateOf(0)
	}
  이렇게
  단,이건 인트,스트링,더블등 기본형만 저장이 됨,그래서 객체같은건 id만 기억하는식으로 보통 사용하고
  데이터클래스같은건 custom saver을 만들어서 사용해야함
  이건 Saver로 형태를 지정해두고 그걸 rememberSaveable(stateSaver=해당형태)하는식으로 사용함
    val UserSaver:Saver<User,Any>=Saver(
	  save={user->listOf(user.name,user.age)},
	  restore={list->
	    val name=list[0] as String
		val age=list[1] as Int
		User(name,age)
	  }
	)
    var user by rememberSaveable(stateSaver=UserSaver){
	  mutableStateOf(User("abc",15))
	}
  이런식으로 사용하게됨
  이러면 구성변경시에도 해당값을 유지할수있음
  
  다른방법으로는 ViewModel을 사용할수있음
  뷰모델속의 상태들은 구성변경후에도 계속 유지됨
  우리는 그냥 거기에 상태를 선언하고 초기화만 해두면됨
  보통 세터는 잠궈두고,거기에맞는 함수노출해서 그걸사용함(상태변경의 캡슐화)
    class abcViewModel:ViewModel(){
	  var count by mutableStateOf(0)
	    private set
	  fun increment(){
	    count++
	  }
	}
	@Composable
	fun CounterScreen(){
	  val viewModel:CounterViewModel=viewModel()
	  val count=viewModel.count
	  
	  Button(onClick={viewModel.increment()})
	}
  대충 이런식으로 사용하게됨
  
  모든상태는 최상위레벨에서 초기화되고 사용되어야함
  또한 그곳에서 뷰모델을 초기화해야함
  뷰모델은 재구성과 구성의 영향을 받지않아서,remember을 사용할필요가없음(프로세스종료시에만 삭제)
  
  프로세스종료시에도 값을 저장하고싶다면,savedStateHandle을 사용할수있음
    class abcViewModel:ViewModel(
	  private val savedStateHandle:SavedStateHandle
	){
	  var count by mutableStateOf(savedStateHandle.get<Int>("count") ?:0)
	    private set
	  fun increment(){
	    count++
		savedStateHandle["count"]=count
	  }
	}  
  이런식으로 db처럼 외부에 저장한값을 불러오고,아니면 기본값을 설정하는식으로 사용됨
  이건 사용자가 이전에 무슨화면에서 종료했는지를 기억한다음,그걸 다시불러오거나 할때 사용됨
  이건 채널방식으로 유용하긴하지만,모든 상태에 대해 이렇게하면안되고,꼭 이렇게 해야하는것만 하는게좋음
  그리고 만약 이렇게 여러 상태를 저장해야한다면,그냥 제네릭확장함수만들어서 넣어두면편함
    fun <T> SavedStateHandle.mutableStateOf(
	  key:String,
	  default:T,
	):MutableState<T>{
	  val state=mutableStateOf(this[key]?:default)
	  return object:MutableState<T> by state{
	    override var value:T
		  get()=state.value
		  set(value){
		    state.value=value
			this@mutableStateOf[key]=value
		  }
	  }
	}
  이렇게
  
  또한 데이터클래스를 사용해서 뷰모델속의 데이터들을 묶어두는것도 도움이됨
  즉 remember대신 기본적으로 뷰모델에서 상태를 저장하는게 나음
  ui쪽에서는 ui만
  
*4.이벤트와 UDF(단방향데이터흐름)
  보통 이벤트는 이런식으로 만들고 사용됨
    sealed class UiEvent{
	  data class ShowSnackBar(val message:String):UiEvent()
	  data class NavigateTo(val screen:Screen):UiEvent()
	  data class RequestPermission(val permission:String):UiEvent()
	}
  sealed은 안붙여도되긴하지만,보통 클린아키텍처적으로 쓰려고 붙이는편임
  이렇게 이벤트클래스를 만들어둔다음,뷰모델에서 이벤트채널을 만들고,해당이벤트를 추가할때 사용하는 함수를 만드는식
    class MyViewModel:ViewModel(){
	  var state by mutableStateOf(ScreenState());
	    private set
		
	  private val _events=Channel<UiEvent>() //이벤트 채널(일회용이니까 채널사용)
	  val events=_events.receiveAsFlow()
	  
	  fun showSnackBar(message:String){ //채널에 이벤트를 추가할때 호출,스낵바를 보여달라고 호출하는느낌임(캡슐화)
	    viewmodelScope.launch(Dispatchers.Main){
		  _events.send(UiEvent.ShowSnackBar(message))
		}
	  }
	}
  이렇게 이벤트를 큐에 추가하고,컴포저블함수에서 이벤트를 처리하는방식
  뷰모델에는 ui관련로직을 추가하면안됨,그래서 실제로 ui관련을 직접 처리하지말고,해당하는 이벤트만 보내고,함수이름은 캡슐화해두는것
  처리는
    @Composable
	fun MyScreen(){
	  val viewModel:MyViewModel=viewModel()
	  
	  LaunchedEffect(Unit){
	    viewModel.events.collect{event->
		  when(event){
		    is UiEvent.ShowSnackBar ->{...}
		    is UiEvent.NavigateTo ->{...}
			else ->{...}
		  }
		}
	  }
	}
  이런식으로 처리하게됨
  LaunchedEffect로 이벤트를 계속 받으면서,해당하는이벤트가 들어오면 바로 해당로직을 실행시키는방식
  
  상태는 바깥으로(아래로) 흐르고,이벤트는 안으로(위로) 흐름
  상태는 현재 ui를 설명하는 데이터묶음임
  이건 뷰모델에서 컴포저블,하위컴포저블로 흐름(ui,즉 바깥으로)
  즉 상태는 뷰모델과,최상위 컴포저블(screen)에서 모든 상태를 정의하고,그 하위 컴포저블들은 그런 상태를 합성등으로 가져오는식으로 의존하게됨
  
  이벤트는 사용자가 어떤 행동을 트리거하면,이벤트를 등록하고 이를 뷰모델에 알림(뷰모델의 이벤트채널에 이벤트를 추가)
  그리고 그 이벤트에 반응하기위해 ui에서는 뷰모델의 채널을 관찰하고있음
  
  요약하면,상태는 뷰모델과 최상위컴포저블에서 가지고(보통 상태보유는 뷰모델이 하고),그게 흘러서 버튼같은 하위컴포저블로 흘러들어가는것
  같은 상태에 의존하는 컴포저블들은 데이터나 같은상태가 변경될때마다 다시 렌더링됨
  또한 사용자가 이벤트를 수행하면 즉시 뷰모델의 이벤트채널에 추가되고,선택적으로 상태를 변경시키고,
  이벤트를 수신하는쪽에서 이벤트를 컨슘하고 토스트같은 작업을 진행함
  
  그래서 상태는 뷰모델에서 하위로 나가니까 아래로 흐른다는거고,
  이벤트는 하위에서 발생해서 뷰모델채널에 추가되니까 위로흐른다는거임
  
  보통 이벤트는 큰단위로 구분해서 사용함,UiEvent,LoginEvent 이런식으로 sealed클래스묶음을 만들어서 사용하는식
  이거단위별로 채널을 만들고 구독시키면됨
  
  
*5.상태 호이스팅 
  상태 호이스팅(상태 상승)은,하위컴포저블에서 상위컴포저블로 상태를 이동시키는 관행을 말함
  즉 상태를 상위컴포저블에 몰아두고,하위컴포저블은 매개변수합성을통해 구성되기때문에,스테이트리스로 구성하게됨
  이러면 쉽게 재사용가능하고,테스트가 쉬워짐
  
  추가적으로 컴포저블에서는 null허용하는 컴포저블을 만들일이 많은데,이걸 typealias로 만들어두면편함
    typealias NullableComposable=(@Composable () -> Unit)

*6.레이아웃
  레이아웃은 자식컴포저블들의 위치를 지정하는 컴포저블함수임
  즉 그안에 속한애들을 어떤식으로 정리할지(수직,수평,겹쳐서등)을 정의함
  레이아웃들은 측정과 배치라는 책임이 있음
  
  레이아웃은 
    column:세로배열
	row:가로배열
	box:안에 계속 쌓음(포개어둠)
  등이 있음
  
  horizontalArrangement는 어떤식으로 배치할지를 선택하는건데
    Start:시작부터 배열
	End:끝부터 배열
	Center:중앙배열
    SpaceBetween:최대한 멀리 띄워둠(제일바깥패딩제거)
	SpaceAround:제일 바깥에도 약간의 패딩을 둠
	SpaceEvenly:제일 바깥에도 똑같이 패딩을 둠
  들이 있음
  Alignment는 정렬매개변수임
  Top,Center,Bottom과 Start,Center,End를 섞어서 사각형을 9등분해서 어디둘지 정하거나,
  Vertical로 세로(이떈 Top,CenterVertically,Bottom)정렬
  Horizontal로 가로(Start,CenterHorizontally,End)정렬
  들을 사용할수있음
  얘는 horizontalArrangement보다 좀더 정교하게 배열할수있음


*7.모디파이어
  모디파이어는 객체의 외형을 변경할떄 보통 사용되고,접근성(clickable같은)등을 제어하기위해서도 사용됨
  컴포넌트의 속성을 조정하기위한 용도라고 보면됨
  모디파이어는 순서가 중요하고,순서대로 적용됨
  그래서 clickable은 보통 제일위에 두는편
  만약 제일마지막에 두면,백그라운드등에는 물결표시가 안나고,글자에만 나게됨
    
  각 컴포지션함수들은,이전함수에서 반환된 모디파이어를 변경하고,이 순서또한 최종결과에 영향을 미침
  그래서 스코프 세이프티로 어디까지 모디파이어가 영향을 주는지를 명확히 알아야하는데,
  기본적으로는 자신의 자식요소에는 해당 컴포넌트의 디폴트로 적용되고,해당컴포넌트가 그값을 명시적으로 바꾸면 그값이 적용되는느낌
  또한 부모의값을 받아오는 모디파이어함수들도 있음
    .matchParentSize()
  이런거들
  matchParentSize는 박스에서만 사용할수있고,컬럼이나 로우에선 사용할수없음
  weight(얘가 얼마나 차지할지 비율,1f,5f가 있으면 1대 5로 전체를 차지함)는 컬럼로우에서만 사용가능하고,박스에선 사용불가능함(박스에선 의미없으니까..)
  
  모디파이어도 확장함수를 사용해서 일정템플릿을 만들어두면 쓰기편함,재사용도 편해지고
  또한 than을 사용하면 if문을 내부에서 쓸수있음
    modifier=Modifier
	  .then(
	    if (...){
		  Modifier
		    .size(30.dp)
		}else Modifier
	  )
  이런식으로
  이거말고 takeIf나 let(현재 호출대상 가져오기,it으로 사용)등도 사용가능
  
  추가적으로 젯팩컴포즈엔 마진이 없고 패딩만 존재함

*7.Lazy 컴포넌트
  레지컴포넌트는 큰 데이터를 효율적으로,즉 지연렌더링으로 표시하는 컴포넌트들임
  이건 말그대로 테이블전체를 한번에 표시하고 가지고있는게 아닌,화면에 실제로 보이는것들만 렌더링하는거
  리사이클러뷰에서 발전한거 맞음
  
  이걸 쓰는이유는
    성능
	간편성
	유연성
  이 있음
  리사이클러뷰보다 엄청나게 편해졌고,유연성도 높으면서 성능은 그대로임
  
  이건 보통 LazyColumn이나 LazyRow를 사용하고,이건
    LazyColumn{
	  items(
		items=users,
		key={it.id}
	  ){user->
		Text(text=user.name)
	  }	  
	}
  이런식으로 사용하게됨
    LazyColumn{
	  userList
	    .groupBy{it.date}
		.forEach{(date,users)->
		  item{
		    Text(text=date)
		  }	  
	      items(
		    items=users,
		    key={it.id}
		  ){user->
	        Text(text=user.name)
	      }
		}
	}  
  여기서 forEach내에서 item을 사용하면 하나만 표시되고,items를 사용하면 그 리스트를 다쓸떄까지 사용함
  즉 제목과 테이블을 뽑을때 씀
  이경우엔 그룹바이로 묶은다음 그걸 표시하는식으로 사용함
  
  items대신 itemsIndexed도 있는데,이건 인덱스값을 사용해야할때 사용함(람다값으로 인덱스도 받을수있음)
  
  레지컴포넌트에서 중요한건 key파라미터임
  이건 
    items(key={it.id})
  이런식으로 지정하는데,이건 해당 리스트내부에서 유니크한값을 사용해야함(해당 리스트에서만 유니크하면됨,보통 id쓰면되긴함)
  이걸 사용하지않아도 동작이 되긴하는데,이경우 추가,삭제,순서변경등을 하면 문제가 생기니,항상 넣는게 좋음
  또한 키가 중복될경우에도 문제가 생기니 조심
  
  레이지로우와 컬럼말고도,LazyVerticalGrid나 LazyHorizontalGrid등 여러가지가 있음
  또한 FlowColumn과 FlowRow는 항목의 갯수에 따라 화면에 표시될 항목크기등을 조절하거나,새행으로 넘기거나 할수있음

*8.remember과 derivedStateOf의 차이점
  remember은 보통 재구성할때 값을 기억하기위해 사용되고,remember에 키를 넣을수도있음
    val abc=remember(keyValue){
	  keyValue.length>3
	}
  여기서 key는 종속성을 의미하고,그상태가 의존하는걸 말함(여기선 abc가 keyValue를 의존)
  이러면 keyValue의 상태가 변경될떄마다 이걸 다시실행함
  remember은 기본적으로 값캐싱도구인데,키를 추가하면 키가 바뀔때만 다시 계산하는거
  이건 키가 변경될때만 무거운연산을 시키고싶을때 사용됨
  
  derivedStateOf는 상태변환기이자 리컴포지션필터로,다른상태객체들로부터 새로운 상태를 만들어내는데,
  이때 결과값이 실제로 변할때만 ui에 변경되었다고 알림
  즉 상태가 아무리 자주 바뀌더라도 결과가 같다면 리컴포지션을 발생시키지않음(매우 자주 변하는값을 둔하게 만들어서 리컴포지션횟수를 줄이고싶을떄 사용하기좋음)
  보통 드래그나 스크롤같은 매우 빠르게 변하는값을 기반으로 불리언값이나 특정값을 도출할때 사용함
  예를들면 맨위로가기버튼을 첫번쨰아이템이 안보일때만 나타나게 한다거나
	val showButton by remember {
        derivedStateOf {
            listState.firstVisibleItemIndex > 0
        }
    }  
  즉 remember(key)는 연산비용을 최적화하고,key값이 변경될때만 재계산하고싶을때 사용하고(무거운객체생성,복잡한로직계산),
  derivedStateOf는 리컴포지션횟수를 최적화하고,내부참조 state가 변경될때만 재계산하고싶을때 사용함(스크롤에따른 ui변경,폼유효성검사)
  둘다 똑같이 쓸수있지만,상황에 맞는걸 선택해야함


*9.슬롯 기반 api
  슬롯기반 레이아웃이란 미리 정해진 자리들이 있는,템플릿 레이아웃임
  스케폴드같은거
  스케폴드는 탑바,바텀바,플로팅액션버튼과 컨텐츠자리를 제공함
  또 다른건 NavigationDrawer이 있음
  이건 스와이프나 버튼을 눌렀을때 왼쪽이나 오른쪽에 나타나는 메뉴를 말함
  이런거말고도 많이 있는데,필요할때 찾아쓰면됨
  
  이런 템플릿들은 어짜피 맨날 쓰는방식이 똑같으니까 쓰면 편함

*10.프리뷰
  프리뷰는 앱을 실행하지않고 구성요소가 어떻게 보일지 확인하는거임
    @Preview
	@Composable
	fun abc(){
	  테스트컴포저블(값)
	}
  이렇게쓰면됨
  또한 쉽게 프리뷰를 만들수있다면,테스트만들기도 쉬워짐(강의존이 없고 내부상태가 없다는거니까)
  
  또한 테마설정도 쉬움
    @Preview(uiMode=Configuration.UI_MODE_NIGHT_YES)
  이렇게하면 다크모드가 되고
    @Preview(uiMode=Configuration.UI_MODE_NIGHT_NO)
  이렇게하면 일반모드가됨
  또한 width,height설정도 쉬움
  이렇게 여러설정으로 여러개를 만들어볼수도있음
	
*11.지역 컴포지션
  컴포즈는 중첩된 ui트리안에 중첩된 ui트리를 가질수있음
  또한 각 컴포넌트들은 각자의 파일에 따로 흩어져있고(또한 여러 패키지에),각 컴포넌트들은 재사용이 쉽게 스테이트리스로 구성해야함
  
  지역컴포지션은 컴포지션 계층구조에 값을 암묵적으로 제공하는 메커니즘임(보통 테마지정,스타일지정,인증등 의존성공유에 잘 사용됨)
  즉 명시적으로 제공하지않아도 로컬컴포지션을 활용해서 같은값을 얻을수있음
  그래서 앱 전체에서 인증상태가 필요할때,모든 계층구조에 해당 상태를 전달하는대신,로컬컴포지션을 활용하여 이걸 받아갈수있음
  이건
	// 값이 자주 변할때 사용
	val LocalActiveUser = compositionLocalOf<User> { error("No User found!") }

	// 자주 변경되지 않는 데이터 (테마 등)에 적합,보통 이거사용하게됨
	val LocalAppTheme = staticCompositionLocalOf { Color.Blue }
  이런식으로 선언할수있고(싱글톤 선언한다고 생각하면됨)
  이거만 있는 kt파일을 만들던가,해당 데이터클래스랑 같은곳에 위치시킨후,다른 provider이 공급할곳에서 임포트해서 쓴다고 생각하면됨
  이런식으로 상위컴포지션에서 하위컴포지션중 공급할곳을 저거로 감싸주고(저안에있는애들은 다 받아볼수있음) 
	@Composable
	fun MyApp() {
		val user = User("AndroidDev", 30)
		
		// LocalActiveUser에 user 객체를 바인딩
		CompositionLocalProvider(LocalActiveUser provides user) {
			// 이 내부의 모든 컴포저블은 user 데이터에 접근 가능
			UserProfile()
		}
	}
  current를 사용해서 가장 가까운 프로바이더가 제공한값을 읽음
	@Composable
	fun UserProfile() {
		// 매개변수로 받지 않았지만 접근 가능
		val user = LocalActiveUser.current
		Text(text = "Hello, ${user.name}")
	}
  대충 범위를 내가 지정할수있는 변수라고 생각하면될듯?전역변수쓰긴싫은데 다 합성시키긴 싫을때 사용하면될듯	
  스코프를 내가 지정할수있으니까

*12.사이드이펙트
  사이드이펙트란 컴포저블함수의 범위밖에있는것에 영향을 주는 모든걸 말함
    로깅
	토스트,스낵바
	라이프사이클 옵저빙
	코루틴으로 데이터가져오기
  등
  컴포저블은 데이터가 변경될때마다 리컴포지션되는데,그래서 일반적인 함수처럼 내부에서 api호출을 하거나 타이머를 돌리면 예상치못한 동작이 발생할수있음
  그래서 안전하게 사이드이펙트를 일으킬수있는 api를 컴포즈가 제공함
  여기엔
    LaunchedEffect:컴포지션시작시 코루틴실행,키값이 바뀌면 기존작업을 취소하고 재시작
	rememberCoroutineScope:버튼클릭등 이벤트핸들러 내부에서 코루틴을 실행할때 사용
	DisposableEffect:리소스해제나 정리처럼 정리가 필요할떄 사용
	SideEffect:컴포지션이 완료될때마다 실행,보통 외부상태동기화를 위해 사용
	rememberUpdatedState:이펙트내부에서 오래걸리는 작업을 해야하는데,중간에 바뀐 최신값을 참조해야하지만 재시작은 하기싫을때 사용
  가 있음
  보통 Effect가 붙으면 일회용작업,state는 상태기억,감시,상태파생이 대부분
    LaunchedEffect:특정상태가 변했을때 비동기작업(네트워크통신,스낵바표시등)을 해야할때 사용
		@Composable
		fun MyScreen(state: MyState) {
			// state.isLoading이 true가 될 때마다 실행
			LaunchedEffect(state.isLoading) {
				if (state.isLoading) {
					// 비동기 로직 수행
				}
			}
		}
	DisposableEffect:컴포저블이 화면에서 사라지거나(onDispose사용시 컴포저블이 사라질때 발동),키값이 변경될때 특정작업을 마무리해야할때 사용
		@Composable
		fun SensorScreen() {
			DisposableEffect(Unit) {
				// 센서 리스너 등록
				onDispose {
					// 센서 리스너 해제 (메모리 누수 방지)
				}
			}
		}
	SideEffect:외부상태 동기화나 로깅할때 사용(리컴포지션 횟수셀때도 자주사용됨)
	
  컴포저블은 가급적 순수함수로 구성되어야하지만,외부와 상호작용해야하는경우가 있는데 그럴때 사용됨
  컴포저블은 순수함수로 유지하고,사이드이펙트는 이펙트api내부에서 분리시키는방식
  또한 LaunchedEffect을 사용할떈 key를 적절히 설정해서 무분별한 재실행을 막아야하고,
  비동기작업은 반드시 코루틴스코프내에서 처리해서 ui가 멈추면안됨



 
  
  
  
  
  
  
  
  