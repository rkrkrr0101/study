1.젯팩컴포즈 기본
*1.젯팩컴포즈 소개
  스킵
*2.상태 및 재구성
  상태는 실제로 사용하고있는 컴포넌트의 상태(변수)임
  이건 remember을 사용하면,리컴포지션이 되었을때도 값을 유지하고있을수있음
  remember을 사용하지않았다면 그냥 초기화됨(그래서 리컴포지션이 되었을때 초기화되는식으로 변수유지하는 트릭이 있긴한데 안쓰는게좋음,화면회전등에서도 반응해서)
  즉 remember을 사용해서 순수함수에 사이드이펙트를 넣는느낌임
  이건
    var name by remember{
	  mutableStateOf("")
	}
  이런식으로 사용됨
  
  기본적으로 컴포저블함수안의 컴포넌트(TextField등)은 상태를 갖지않고,외부에 상태를 선언해둔후 끼우는식으로 만들게됨
  이래야 테스트와 유지보수가 쉬워짐
  이렇게 remember로 상태를 만들어두면 계속 그 상태를 옵저빙하고있게됨,
  그러다가 상태가 어떤이유로든 변경되면 해당 상태를 가지고있는 모든 컴포넌트들이 갱신되는데 이게 재구성(리컴포지션)임
  기본적으로 젯팩컴포즈는 선언형이고,그래서 값을 바꾸면 그 값에 맞춰서 다른것들이 수정되는형태를 띄는것
  
  보통 컴포넌트에서 마지막매개변수는 content람다를 받는데,제일마지막 람다니까 그냥 
	Button(
	  onClick=buttonClick()
	){
       ...
	}
  이런식으로 쓸수도있음
  보통 이건 그안에 뭘넣을지(버튼이라면 텍스트,아이콘등)을 정의하는곳임
  
  기본적으로 remember을 사용해서 상태를 기억하는(stateful)방식과,외부에서 값을 주입받는(stateless)방식이 있는데,가급적이면 스테이트리스를쓰는게 나음
    //스테이트풀
	@Composable
	fun abc(){
		var name by remember{
		  mutableStateOf("")
		}	
		...
	}
	//스테이트리스
    @Composable
	fun abc(name:String){
		...
	}  
  이래야 커스터마이징,테스트가 쉬움(프리뷰쓰기도편함)
  정말 꼭 필요하지않으면 내부상태유지(스테이트풀)는 하지않는게좋음
  
  기본적으로 재구성을 발생시키는건
    상태변경:상태(State,MutableState,LiveData/Flow)들중 collect되고있는애들이 변경될떄,즉 스테이트풀 변경시
	파라미터변경:컴포저블함수의 입력파라미터가 변경될때,즉 스테이트리스 변경시
	파생상태:derivedStateOf가 변경될때
  들임
  
  ui는 현재상태에 따라 ui를 출력하는 컴포지션함수들로 구성됨
  우리는 선언적으로,ui가 어떻게 보일지를 정의하면 이걸 알아서 그렇게 바꿔주고,상태가 변경되면 즉시 그 상태대로 바꿔주는거임
  이런과정을 리컴포지션이라고 부름
  
  그리고 불변데이터(val)는 remember로 업데이트하려면 통째로 갈아야함
  data class User(
    val name="abcd",
	val age:Int=29
  )
  var user by remember{
    mutableStateOf(User())
  }
  Button(
    onClick={
	  user=User(
	    name=user.name
		age=user.age+1
	  )
	}
  )  
  근데 그러면 너무 복잡하니까 .copy를 사용하면 편함
  이건 데이터클래스에서 자동으로 만들어주는 함수로,변경할값만 바꾸면됨
  Button(
    onClick={
	  user=User.copy(age=user.age+1)
	}
  )   
  
*3.구성변경 및 상태지속성
  구성변경이벤트란,사용자가 화면을 회전하거나 테마를 변경하는등의 상황에서 일어나는 이벤트임
	화면회전
	테마변경
	언어변경
	폰트변경
	시스템앱킬(강제종료)
  등의 상황에서 발생함
  이상황에서는 remember로 상태를 저장해도 저장이 되지않게됨
  그래서 사용되는게 rememberSaveable임
  이건 그냥 remember대신 그자리에 넣고쓰면됨
    var count by rememberSaveable{
	  mutableStateOf(0)
	}
  이렇게
  단,이건 인트,스트링,더블등 기본형만 저장이 됨,그래서 객체같은건 id만 기억하는식으로 보통 사용하고
  데이터클래스같은건 custom saver을 만들어서 사용해야함
  이건 Saver로 형태를 지정해두고 그걸 rememberSaveable(stateSaver=해당형태)하는식으로 사용함
    val UserSaver:Saver<User,Any>=Saver(
	  save={user->listOf(user.name,user.age)},
	  restore={list->
	    val name=list[0] as String
		val age=list[1] as Int
		User(name,age)
	  }
	)
    var user by rememberSaveable(stateSaver=UserSaver){
	  mutableStateOf(User("abc",15))
	}
  이런식으로 사용하게됨
  이러면 구성변경시에도 해당값을 유지할수있음
  
  다른방법으로는 ViewModel을 사용할수있음
  뷰모델속의 상태들은 구성변경후에도 계속 유지됨
  우리는 그냥 거기에 상태를 선언하고 초기화만 해두면됨
  보통 세터는 잠궈두고,거기에맞는 함수노출해서 그걸사용함(상태변경의 캡슐화)
    class abcViewModel:ViewModel(){
	  var count by mutableStateOf(0)
	    private set
	  fun increment(){
	    count++
	  }
	}
	@Composable
	fun CounterScreen(){
	  val viewModel:CounterViewModel=viewModel()
	  val count=viewModel.count
	  
	  Button(onClick={viewModel.increment()})
	}
  대충 이런식으로 사용하게됨
  
  모든상태는 최상위레벨에서 초기화되고 사용되어야함
  또한 그곳에서 뷰모델을 초기화해야함
  뷰모델은 재구성과 구성의 영향을 받지않아서,remember을 사용할필요가없음(프로세스종료시에만 삭제)
  
  프로세스종료시에도 값을 저장하고싶다면,savedStateHandle을 사용할수있음
    class abcViewModel:ViewModel(
	  private val savedStateHandle:SavedStateHandle
	){
	  var count by mutableStateOf(savedStateHandle.get<Int>("count") ?:0)
	    private set
	  fun increment(){
	    count++
		savedStateHandle["count"]=count
	  }
	}  
  이런식으로 db처럼 외부에 저장한값을 불러오고,아니면 기본값을 설정하는식으로 사용됨
  이건 사용자가 이전에 무슨화면에서 종료했는지를 기억한다음,그걸 다시불러오거나 할때 사용됨
  이건 채널방식으로 유용하긴하지만,모든 상태에 대해 이렇게하면안되고,꼭 이렇게 해야하는것만 하는게좋음
  그리고 만약 이렇게 여러 상태를 저장해야한다면,그냥 제네릭확장함수만들어서 넣어두면편함
    fun <T> SavedStateHandle.mutableStateOf(
	  key:String,
	  default:T,
	):MutableState<T>{
	  val state=mutableStateOf(this[key]?:default)
	  return object:MutableState<T> by state{
	    override var value:T
		  get()=state.value
		  set(value){
		    state.value=value
			this@mutableStateOf[key]=value
		  }
	  }
	}
  이렇게
  
  또한 데이터클래스를 사용해서 뷰모델속의 데이터들을 묶어두는것도 도움이됨
  즉 remember대신 기본적으로 뷰모델에서 상태를 저장하는게 나음
  ui쪽에서는 ui만
  
*4.이벤트와 UDF(단방향데이터흐름)
  보통 이벤트는 이런식으로 만들고 사용됨
    sealed class UiEvent{
	  data class ShowSnackBar(val message:String):UiEvent()
	  data class NavigateTo(val screen:Screen):UiEvent()
	  data class RequestPermission(val permission:String):UiEvent()
	}
  sealed은 안붙여도되긴하지만,보통 클린아키텍처적으로 쓰려고 붙이는편임
  이렇게 이벤트클래스를 만들어둔다음,뷰모델에서 이벤트채널을 만들고,해당이벤트를 추가할때 사용하는 함수를 만드는식
    class MyViewModel:ViewModel(){
	  var state by mutableStateOf(ScreenState());
	    private set
		
	  private val _events=Channel<UiEvent>() //이벤트 채널(일회용이니까 채널사용)
	  val events=_events.receiveAsFlow()
	  
	  fun showSnackBar(message:String){ //채널에 이벤트를 추가할때 호출,스낵바를 보여달라고 호출하는느낌임(캡슐화)
	    viewmodelScope.launch(Dispatchers.Main){
		  _events.send(UiEvent.ShowSnackBar(message))
		}
	  }
	}
  이렇게 이벤트를 큐에 추가하고,컴포저블함수에서 이벤트를 처리하는방식
  뷰모델에는 ui관련로직을 추가하면안됨,그래서 실제로 ui관련을 직접 처리하지말고,해당하는 이벤트만 보내고,함수이름은 캡슐화해두는것
  처리는
    @Composable
	fun MyScreen(){
	  val viewModel:MyViewModel=viewModel()
	  
	  LaunchedEffect(Unit){
	    viewModel.events.collect{event->
		  when(event){
		    is UiEvent.ShowSnackBar ->{...}
		    is UiEvent.NavigateTo ->{...}
			else ->{...}
		  }
		}
	  }
	}
  이런식으로 처리하게됨
  LaunchedEffect로 이벤트를 계속 받으면서,해당하는이벤트가 들어오면 바로 해당로직을 실행시키는방식
  
  상태는 바깥으로(아래로) 흐르고,이벤트는 안으로(위로) 흐름
  상태는 현재 ui를 설명하는 데이터묶음임
  이건 뷰모델에서 컴포저블,하위컴포저블로 흐름(ui,즉 바깥으로)
  즉 상태는 뷰모델과,최상위 컴포저블(screen)에서 모든 상태를 정의하고,그 하위 컴포저블들은 그런 상태를 합성등으로 가져오는식으로 의존하게됨
  
  이벤트는 사용자가 어떤 행동을 트리거하면,이벤트를 등록하고 이를 뷰모델에 알림(뷰모델의 이벤트채널에 이벤트를 추가)
  그리고 그 이벤트에 반응하기위해 ui에서는 뷰모델의 채널을 관찰하고있음
  
  요약하면,상태는 뷰모델과 최상위컴포저블에서 가지고(보통 상태보유는 뷰모델이 하고),그게 흘러서 버튼같은 하위컴포저블로 흘러들어가는것
  같은 상태에 의존하는 컴포저블들은 데이터나 같은상태가 변경될때마다 다시 렌더링됨
  또한 사용자가 이벤트를 수행하면 즉시 뷰모델의 이벤트채널에 추가되고,선택적으로 상태를 변경시키고,
  이벤트를 수신하는쪽에서 이벤트를 컨슘하고 토스트같은 작업을 진행함
  
  그래서 상태는 뷰모델에서 하위로 나가니까 아래로 흐른다는거고,
  이벤트는 하위에서 발생해서 뷰모델채널에 추가되니까 위로흐른다는거임
  
  보통 이벤트는 큰단위로 구분해서 사용함,UiEvent,LoginEvent 이런식으로 sealed클래스묶음을 만들어서 사용하는식
  이거단위별로 채널을 만들고 구독시키면됨
  
  
*5.상태 호이스팅 
  상태 호이스팅(상태 상승)은,하위컴포저블에서 상위컴포저블로 상태를 이동시키는 관행을 말함
  즉 상태를 상위컴포저블에 몰아두고,하위컴포저블은 매개변수합성을통해 구성되기때문에,스테이트리스로 구성하게됨
  이러면 쉽게 재사용가능하고,테스트가 쉬워짐
  
  추가적으로 컴포저블에서는 null허용하는 컴포저블을 만들일이 많은데,이걸 typealias로 만들어두면편함
    typealias NullableComposable=(@Composable () -> Unit)

*6.레이아웃
  레이아웃은 자식컴포저블들의 위치를 지정하는 컴포저블함수임
  즉 그안에 속한애들을 어떤식으로 정리할지(수직,수평,겹쳐서등)을 정의함
  레이아웃들은 측정과 배치라는 책임이 있음
  
  레이아웃은 
    column:세로배열
	row:가로배열
	box:안에 계속 쌓음(포개어둠)
  등이 있음
  
  horizontalArrangement는 어떤식으로 배치할지를 선택하는건데
    Start:시작부터 배열
	End:끝부터 배열
	Center:중앙배열
    SpaceBetween:최대한 멀리 띄워둠(제일바깥패딩제거)
	SpaceAround:제일 바깥에도 약간의 패딩을 둠
	SpaceEvenly:제일 바깥에도 똑같이 패딩을 둠
  들이 있음
  Alignment는 정렬매개변수임
  Top,Center,Bottom과 Start,Center,End를 섞어서 사각형을 9등분해서 어디둘지 정하거나,
  Vertical로 세로(이떈 Top,CenterVertically,Bottom)정렬
  Horizontal로 가로(Start,CenterHorizontally,End)정렬
  들을 사용할수있음
  얘는 horizontalArrangement보다 좀더 정교하게 배열할수있음


*7.모디파이어
  모디파이어는 객체의 외형을 변경할떄 보통 사용되고,접근성(clickable같은)등을 제어하기위해서도 사용됨
  컴포넌트의 속성을 조정하기위한 용도라고 보면됨
  모디파이어는 순서가 중요하고,순서대로 적용됨
  그래서 clickable은 보통 제일위에 두는편
  만약 제일마지막에 두면,백그라운드등에는 물결표시가 안나고,글자에만 나게됨
    
  각 컴포지션함수들은,이전함수에서 반환된 모디파이어를 변경하고,이 순서또한 최종결과에 영향을 미침
  그래서 스코프 세이프티로 어디까지 모디파이어가 영향을 주는지를 명확히 알아야하는데,
  기본적으로는 자신의 자식요소에는 해당 컴포넌트의 디폴트로 적용되고,해당컴포넌트가 그값을 명시적으로 바꾸면 그값이 적용되는느낌
  또한 부모의값을 받아오는 모디파이어함수들도 있음
    .matchParentSize()
  이런거들
  matchParentSize는 박스에서만 사용할수있고,컬럼이나 로우에선 사용할수없음
  weight(얘가 얼마나 차지할지 비율,1f,5f가 있으면 1대 5로 전체를 차지함)는 컬럼로우에서만 사용가능하고,박스에선 사용불가능함(박스에선 의미없으니까..)
  
  모디파이어도 확장함수를 사용해서 일정템플릿을 만들어두면 쓰기편함,재사용도 편해지고
  또한 than을 사용하면 if문을 내부에서 쓸수있음
    modifier=Modifier
	  .then(
	    if (...){
		  Modifier
		    .size(30.dp)
		}else Modifier
	  )
  이런식으로
  이거말고 takeIf나 let(현재 호출대상 가져오기,it으로 사용)등도 사용가능
  
  추가적으로 젯팩컴포즈엔 마진이 없고 패딩만 존재함

*7.Lazy 컴포넌트
  레지컴포넌트는 큰 데이터를 효율적으로,즉 지연렌더링으로 표시하는 컴포넌트들임
  이건 말그대로 테이블전체를 한번에 표시하고 가지고있는게 아닌,화면에 실제로 보이는것들만 렌더링하는거
  리사이클러뷰에서 발전한거 맞음
  
  이걸 쓰는이유는
    성능
	간편성
	유연성
  이 있음
  리사이클러뷰보다 엄청나게 편해졌고,유연성도 높으면서 성능은 그대로임
  
  이건 보통 LazyColumn이나 LazyRow를 사용하고,이건
    LazyColumn{
	  items(
		items=users,
		key={it.id}
	  ){user->
		Text(text=user.name)
	  }	  
	}
  이런식으로 사용하게됨
    LazyColumn{
	  userList
	    .groupBy{it.date}
		.forEach{(date,users)->
		  item{
		    Text(text=date)
		  }	  
	      items(
		    items=users,
		    key={it.id}
		  ){user->
	        Text(text=user.name)
	      }
		}
	}  
  여기서 forEach내에서 item을 사용하면 하나만 표시되고,items를 사용하면 그 리스트를 다쓸떄까지 사용함
  즉 제목과 테이블을 뽑을때 씀
  이경우엔 그룹바이로 묶은다음 그걸 표시하는식으로 사용함
  
  items대신 itemsIndexed도 있는데,이건 인덱스값을 사용해야할때 사용함(람다값으로 인덱스도 받을수있음)
  
  레지컴포넌트에서 중요한건 key파라미터임
  이건 
    items(key={it.id})
  이런식으로 지정하는데,이건 해당 리스트내부에서 유니크한값을 사용해야함(해당 리스트에서만 유니크하면됨,보통 id쓰면되긴함)
  이걸 사용하지않아도 동작이 되긴하는데,이경우 추가,삭제,순서변경등을 하면 문제가 생기니,항상 넣는게 좋음
  또한 키가 중복될경우에도 문제가 생기니 조심
  
  레이지로우와 컬럼말고도,LazyVerticalGrid나 LazyHorizontalGrid등 여러가지가 있음
  또한 FlowColumn과 FlowRow는 항목의 갯수에 따라 화면에 표시될 항목크기등을 조절하거나,새행으로 넘기거나 할수있음

*8.remember과 derivedStateOf의 차이점
  remember은 보통 재구성할때 값을 기억하기위해 사용되고,remember에 키를 넣을수도있음
    val abc=remember(keyValue){
	  keyValue.length>3
	}
  여기서 key는 종속성을 의미하고,그상태가 의존하는걸 말함(여기선 abc가 keyValue를 의존)
  이러면 keyValue의 상태가 변경될떄마다 이걸 다시실행함
  remember은 기본적으로 값캐싱도구인데,키를 추가하면 키가 바뀔때만 다시 계산하는거
  이건 키가 변경될때만 무거운연산을 시키고싶을때 사용됨
  
  derivedStateOf는 상태변환기이자 리컴포지션필터로,다른상태객체들로부터 새로운 상태를 만들어내는데,
  이때 결과값이 실제로 변할때만 ui에 변경되었다고 알림
  즉 상태가 아무리 자주 바뀌더라도 결과가 같다면 리컴포지션을 발생시키지않음(매우 자주 변하는값을 둔하게 만들어서 리컴포지션횟수를 줄이고싶을떄 사용하기좋음)
  보통 드래그나 스크롤같은 매우 빠르게 변하는값을 기반으로 불리언값이나 특정값을 도출할때 사용함
  예를들면 맨위로가기버튼을 첫번쨰아이템이 안보일때만 나타나게 한다거나
	val showButton by remember {
        derivedStateOf {
            listState.firstVisibleItemIndex > 0
        }
    }  
  즉 remember(key)는 연산비용을 최적화하고,key값이 변경될때만 재계산하고싶을때 사용하고(무거운객체생성,복잡한로직계산),
  derivedStateOf는 리컴포지션횟수를 최적화하고,내부참조 state가 변경될때만 재계산하고싶을때 사용함(스크롤에따른 ui변경,폼유효성검사)
  둘다 똑같이 쓸수있지만,상황에 맞는걸 선택해야함


*9.슬롯 기반 api
  슬롯기반 레이아웃이란 미리 정해진 자리들이 있는,템플릿 레이아웃임
  스케폴드같은거
  스케폴드는 탑바,바텀바,플로팅액션버튼과 컨텐츠자리를 제공함
  또 다른건 NavigationDrawer이 있음
  이건 스와이프나 버튼을 눌렀을때 왼쪽이나 오른쪽에 나타나는 메뉴를 말함
  이런거말고도 많이 있는데,필요할때 찾아쓰면됨
  
  이런 템플릿들은 어짜피 맨날 쓰는방식이 똑같으니까 쓰면 편함

*10.프리뷰
  프리뷰는 앱을 실행하지않고 구성요소가 어떻게 보일지 확인하는거임
    @Preview
	@Composable
	fun abc(){
	  테스트컴포저블(값)
	}
  이렇게쓰면됨
  또한 쉽게 프리뷰를 만들수있다면,테스트만들기도 쉬워짐(강의존이 없고 내부상태가 없다는거니까)
  
  또한 테마설정도 쉬움
    @Preview(uiMode=Configuration.UI_MODE_NIGHT_YES)
  이렇게하면 다크모드가 되고
    @Preview(uiMode=Configuration.UI_MODE_NIGHT_NO)
  이렇게하면 일반모드가됨
  또한 width,height설정도 쉬움
  이렇게 여러설정으로 여러개를 만들어볼수도있음
	
*11.지역 컴포지션
  컴포즈는 중첩된 ui트리안에 중첩된 ui트리를 가질수있음
  또한 각 컴포넌트들은 각자의 파일에 따로 흩어져있고(또한 여러 패키지에),각 컴포넌트들은 재사용이 쉽게 스테이트리스로 구성해야함
  
  지역컴포지션은 컴포지션 계층구조에 값을 암묵적으로 제공하는 메커니즘임(보통 테마지정,스타일지정,인증등 의존성공유에 잘 사용됨)
  즉 명시적으로 제공하지않아도 로컬컴포지션을 활용해서 같은값을 얻을수있음
  그래서 앱 전체에서 인증상태가 필요할때,모든 계층구조에 해당 상태를 전달하는대신,로컬컴포지션을 활용하여 이걸 받아갈수있음
  이건
	// 값이 자주 변할때 사용
	val LocalActiveUser = compositionLocalOf<User> { error("No User found!") }

	// 자주 변경되지 않는 데이터 (테마 등)에 적합,보통 이거사용하게됨
	val LocalAppTheme = staticCompositionLocalOf { Color.Blue }
  이런식으로 선언할수있고(싱글톤 선언한다고 생각하면됨)
  이거만 있는 kt파일을 만들던가,해당 데이터클래스랑 같은곳에 위치시킨후,다른 provider이 공급할곳에서 임포트해서 쓴다고 생각하면됨
  이런식으로 상위컴포지션에서 하위컴포지션중 공급할곳을 저거로 감싸주고(저안에있는애들은 다 받아볼수있음) 
	@Composable
	fun MyApp() {
		val user = User("AndroidDev", 30)
		
		// LocalActiveUser에 user 객체를 바인딩
		CompositionLocalProvider(LocalActiveUser provides user) {
			// 이 내부의 모든 컴포저블은 user 데이터에 접근 가능
			UserProfile()
		}
	}
  current를 사용해서 가장 가까운 프로바이더가 제공한값을 읽음
	@Composable
	fun UserProfile() {
		// 매개변수로 받지 않았지만 접근 가능
		val user = LocalActiveUser.current
		Text(text = "Hello, ${user.name}")
	}
  대충 범위를 내가 지정할수있는 변수라고 생각하면될듯?전역변수쓰긴싫은데 다 합성시키긴 싫을때 사용하면될듯	
  스코프를 내가 지정할수있으니까

*12.사이드이펙트
  사이드이펙트란 컴포저블함수의 범위밖에있는것에 영향을 주는 모든걸 말함
    로깅
	토스트,스낵바
	라이프사이클 옵저빙
	코루틴으로 데이터가져오기
  등
  컴포저블은 데이터가 변경될때마다 리컴포지션되는데,그래서 일반적인 함수처럼 내부에서 api호출을 하거나 타이머를 돌리면 예상치못한 동작이 발생할수있음
  그래서 안전하게 사이드이펙트를 일으킬수있는 api를 컴포즈가 제공함
  여기엔
    LaunchedEffect:컴포지션시작시 코루틴실행,키값이 바뀌면 기존작업을 취소하고 재시작
	rememberCoroutineScope:버튼클릭등 이벤트핸들러 내부에서 코루틴을 실행할때 사용
	DisposableEffect:리소스해제나 정리처럼 정리가 필요할떄 사용
	SideEffect:컴포지션이 완료될때마다 실행,보통 외부상태동기화를 위해 사용
	rememberUpdatedState:이펙트내부에서 오래걸리는 작업을 해야하는데,중간에 바뀐 최신값을 참조해야하지만 재시작은 하기싫을때 사용
  가 있음
  보통 Effect가 붙으면 일회용작업,state는 상태기억,감시,상태파생이 대부분
    LaunchedEffect:특정상태가 변했을때 비동기작업(네트워크통신,스낵바표시등)을 해야할때 사용
		@Composable
		fun MyScreen(state: MyState) {
			// state.isLoading이 true가 될 때마다 실행
			LaunchedEffect(state.isLoading) {
				if (state.isLoading) {
					// 비동기 로직 수행
				}
			}
		}
	DisposableEffect:컴포저블이 화면에서 사라지거나(onDispose사용시 컴포저블이 사라질때 발동),키값이 변경될때 특정작업을 마무리해야할때 사용
		@Composable
		fun SensorScreen() {
			DisposableEffect(Unit) {
				// 센서 리스너 등록
				onDispose {
					// 센서 리스너 해제 (메모리 누수 방지)
				}
			}
		}
	SideEffect:외부상태 동기화나 로깅할때 사용(리컴포지션 횟수셀때도 자주사용됨)
	
  컴포저블은 가급적 순수함수로 구성되어야하지만,외부와 상호작용해야하는경우가 있는데 그럴때 사용됨
  컴포저블은 순수함수로 유지하고,사이드이펙트는 이펙트api내부에서 분리시키는방식
  또한 LaunchedEffect을 사용할떈 key를 적절히 설정해서 무분별한 재실행을 막아야하고,
  비동기작업은 반드시 코루틴스코프내에서 처리해서 ui가 멈추면안됨

*13.애니메이션
  젯팩컴포즈에선 애니메이션도 선언적인 방식으로 동작시킴
  즉 애니메이션은 상태변화를 통해 애니메이션을 동작시키고,
  컴포즈는 상태가 변경되면 이전값에서 새값으로 애니메이션을 적용하는방법을 계산함
  
  컴포즈는 이미 애니메이션 컴포저블함수들을 만들어뒀고,그걸 가져다쓰면됨
  visible을 통해 에니메이션을 넣고싶을땐
    AnimatedVisibility(
	  visible=조건상태변수,
	  enter=slideInVertically(),//true될때 어떤식의 애니메이션 표시
	  exit=fadeOut(),//false될때 어떤식의 애니메이션
	){
	  보여질 컴포저블함수
	}
  여러 애니메이션을 합치는것도 가능하고,자식의 애니메이션을 Modifier로 별도로 설정해줄수도있음
    Modifier.animateEnterExit(enter=... , exit=...)
  이렇게
  
  가시성기반애니메이션 말고도(이건 나올때랑 사라질때만쓰는거),그냥 해당 값에대한 모든 애니메이션을 관리하는건 AnimatedContent임
    AnimatedContent(
	  transitionSpec={
	    slideInVertucally{height->height} //슬라이드인
		  + fadeIn() togetherWith
		slideOutVertically{height->height} //슬라이드아웃
		  +fadeOut()
	  }
	){ targetCount->
	   Text(
	     text="$targetCount",	
	   )
	}
  이런식으로 하면 각각에 맞는 애니메이션을 추가할수있음
  여기서도 Modifier.animateEnterExit을 사용해서 자식레벨에서 바꿀수있고,
    Modifier.animateContentSize().height(if(조건)3.dp else 5.dp)
  이런식으로 조건에따른 컨텐츠사이즈조절도 가능함
  
  또한 LazyColumn같은애들한테도 애니메이션넣기쉬운데,그냥
    LazyColumn{
	  items(abcList,ket={it.id}){
	    Row(Modifier.animateItem()){
		  ...
		}
	  }
	}
  이런식으로 처리할수있음
  
  값기반애니메이션도 있는데,이건 animate값타입AsState()함수들임
  즉 이런건 값을 기반으로 애니메이션을 만들수있음
   val rotation by animateFloatAsState(
     targetValue=if(조건) 0f else 180f,
     label="rotation"
   )
  이렇게 선언해둔후
    Box(
	  Modifier
	    .rotate(degrees=rotation)
	)
  이렇게 사용할수있음
  이러면 조건에 따라 값이 천천히 변해서 선언적으로 애니메이션이 됨(rotation값이 0에서 180으로 순차적으로 변하는거)
  
  무한으로 동작할 애니메이션은 infiniteTransition.animate값타입()을 사용할수있음
  필요해지면 검색해보자,위랑 비슷한데,반복모드설정해두면 계속 값이 변하는거임
  
  
  추가적으로,데이터의 상태를 나타내는 클래스(RequestState같은이름의)를 만들어두면 편함
  이걸 사용하면 모든 타입을 제네릭으로 감싸서 리턴할수도있고,현재상태를 줄수도있음
  또한 이 클래스에 대해 확장함수를 만들어서 현재 상태에 대한 애니메이션과 상태를 명시적으로 적어서쓸수있음

 
*14.테마
  젯팩컴포즈에선 테마를 만들기도 쉬움  
  이거의핵심은 색상,폰트,shape를 정의하는 테마시스템이고,이걸기반으로 커스터마이즈할수있음
  기본적으로 젯팩컴포즈엔 기본값이 들어가있고,이게 material3임
  
  색상조합과,폰트조합,형태조합을 미리 만들어둔다음 이걸 갈아끼우는식으로 하면됨
  
  MaterialTheme는 로컬구성에 있는 값을 주는 특별한 객체임
  앱어디서든 매개변수로 받지않고 싱글톤처럼 받을수있음
  여기엔 미리 만들어둔값들도 있고,우리가 템플릿을 추가할수도있음
  하드코딩으로 12dp하는것보다 이렇게 만들어둔값을 쓰는게 일괄수정도 편함
  
2.프로젝트세팅 
*1.프로젝트 세팅 
  kmp.jetbrains.com을 사용하면 start.spring.io처럼 쉽게 프로젝트를 만들수있음
  이렇게 만들어진 프로젝트를 열떈 그냥 압축파일해제하고 그폴더를 잡고 열면됨
  그리고나서 왼쪽 탐색창의 프로젝트를 안드로이드모드로 바꿔주면됨
  
  이폴더에서 composeApp/src에 코드가 들어가고,여기에서 commonMain이 공통소스고,안드로이드메인과 ios메인은 각각 자기플랫폼꺼임
  즉  commonMain에 적는 코드는 전체에 공유되고,여기에서 코드를 거의 다 작성하면됨
  이아래의 kotlin밑에 com.어쩌구같은 곳에서 시작하면되고,platform파일이 있을텐데,이걸 액츄얼이라고 부르고,각각 실제구현을 작성하고,
  빌드시에 각각 다른걸 갈아끼우는식으로 동작시킬수있음(결제처럼 양쪽이 달라야하는경우에 사용)
  즉 안드로이드 ios 다 이게 있는걸 확인할수있음
  
  그리고 ktlint ktlint-compose-0.5.3-all.jar 룰셋에 추가하고 .editorsetting추가하고 껏다켜기
  
*2.종속성추가 
  기본적인 종속성은 컴포즈앱의 빌드그래들에 설정할수있음 
  각각 os에 맞게 따로따로 종속성설치도 가능하고,commonMain에 있는건 양쪽다 설치됨
  
  그런데 여기보단 gradle에 libs.versions.toml에서(버전카탈로그) 관리하는게좋음
  이런거처럼 여러모듈이 있는경우엔 이렇게 중앙에서 버전관리를 해두는게 좋기때문
  
  종속성은 버전에
    serialization = "1.9.0"
	koin = "4.2.0-beta2"
	navigation3 = "1.0.0"
	navigation2 = "2.9.1"
	navigation3ViewModel = "2.10.0"
	navigation3Adaptive = "1.3.0-alpha05"
	dateTime = "0.7.1"
	sqldelight = "2.2.1"
	swipeableKmp = "1.0.3"  
  사용할 버전을 나열해주고 
  라이브러리에
    kotlinx-serialization = { module = "org.jetbrains.kotlinx:kotlinx-serialization-json", version.ref = "serialization" }
    kotlinx-date-time = { module = "org.jetbrains.kotlinx:kotlinx-datetime", version.ref = "dateTime" }
    
    navigation3-runtime = { module = "androidx.navigation3:navigation3-runtime", version.ref = "navigation3" }
    navigation3-ui = { module = "androidx.navigation3:navigation3-ui", version.ref = "navigation3" }
    navigation3-viewmodel = { module = "androidx.lifecycle:lifecycle-viewmodel-navigation3", version.ref = "navigation3ViewModel" }
    navigation3-adaptive = { group = "androidx.compose.material3.adaptive", name = "adaptive-navigation3", version.ref = "navigation3Adaptive" }
    navigation2 = { group = "org.jetbrains.androidx.navigation", name = "navigation-compose", version.ref = "navigation2" }
    
    koin-android = { module = "io.insert-koin:koin-android", version.ref = "koin" }
    koin-core = { module = "io.insert-koin:koin-core", version.ref = "koin" }
    koin-compose = { module = "io.insert-koin:koin-compose", version.ref = "koin" }
    koin-compose-viewmodel = { module = "io.insert-koin:koin-compose-viewmodel", version.ref = "koin" }
    koin-navigation3 = { module = "io.insert-koin:koin-compose-navigation3", version.ref = "koin" }
    
    sqldelight-android = { module = "app.cash.sqldelight:android-driver", version.ref = "sqldelight" }
    sqldelight-ios = { module = "app.cash.sqldelight:native-driver", version.ref = "sqldelight" }
    sqldelight-coroutines = { module = "app.cash.sqldelight:coroutines-extensions", version.ref = "sqldelight" }
    
    swipeable-kmp = { module = "com.stevdza-san:swipeable-kmp", version.ref = "swipeableKmp" }
  이렇게 추가하고 플러그인에
    serialization = { id = "org.jetbrains.kotlin.plugin.serialization", version.ref = "kotlin" }
	sqlDelight = { id = "app.cash.sqldelight", version.ref = "sqldelight" }
  추가하면됨
  직렬화라이브러리,네비게이션,koin(의존성주입),sqlDelight(db접근,멀티플랫폼이라 room대신쓰는거,룸써도 최신버전에선 되긴함)임
  swipeable-kmp는 얘가 만든라이브러리 틈새광고임
  
  그리고 sqlDelight쓸거면 안드스튜디오 설정에서 플러그인(sqlDelight)도 설치하는게좋음
  
  이렇게 버전설정을해뒀으면 적용하면되는데,프로젝트레벨 빌드그래들에 플러그인2개를 추가해주고
      alias(libs.plugins.serialization) apply false
      alias(libs.plugins.sqlDelight) apply false
  컴포즈앱의 빌드그래들에서 플러그인을 추가해주고
    alias(libs.plugins.serialization)
    alias(libs.plugins.sqlDelight)
  디펜던시에서 안드로이드메인에 추가
	implementation(libs.koin.android)

	implementation(libs.sqldelight.android)

	implementation(libs.navigation3.runtime)
	implementation(libs.navigation3.ui)
	implementation(libs.navigation3.viewmodel)
	implementation(libs.navigation3.adaptive)  
  원래는 commonMain에 둬야하지만,버전문제때문에 일단 여기에 두는거
  commonMain에는
	implementation(libs.kotlinx.serialization)
	implementation(libs.kotlinx.date.time)

	implementation(libs.koin.core)
	implementation(libs.koin.compose)
	implementation(libs.koin.compose.viewmodel)
	implementation(libs.koin.navigation3)

	implementation(libs.swipeable.kmp)

	implementation(libs.sqldelight.coroutines)
  추가,기본적인것들이 들어있음
  ios메인에는
    implementation(libs.sqldelight.ios)
  추가
  
  이러면 일단 Collection is empty. 에러가 날텐데,컬렉션이 없어서 그런거
  바로 db쓸거아니면 sqldelight관련 의존성 제거하고 테스트하던가 해도되고,아니면 db설정하면됨
  
3.앱만들기
*1.네비게이션3 세팅  
  네비게이션이란 탐색경로와 백스택(이동이력)을 관리하는걸 말함
  
  네비게이션을 쓸땐 모든 네비게이션관련내용을 저장할 패키지를 만들어두는게좋음
  그리고 그안에 
    sealed class Screen{}
  을 만들고,여기서 사용할 화면들을 object나 data class로 선언하고 Screen을 받으면됨(그 ui이벤트할떄 하던거처럼 인터페이스화하는거)
  인수가 없으면 object,있으면 data class를 쓰면됨
	@Serializable //객체직렬화,네비게이션3에선 문자열로 안던지고 이거끼우고 객체를 던지는식으로 경로를 조정함
	sealed class Screen {
		@Serializable
		object Home : Screen()
		@Serializable
		data class Task(
			val id: String? = null,//로직상 널허용
		) : Screen()
	}
  이렇게
  이 상태패턴은 외부에서 Screen의 상속을 막고,여기서만 클래스를 만들수있게해서 이안에있는것만 들어올수있다는걸 보장해줌
  또한 각 상태에 필요한 고유데이터를 묶어서 관리하기도 쉽고,when쓸때도 모든 하위클래스처리를 컴파일러가 확인해줌
  객체직렬화가 되어있으면 네비게이션을 문자열경로가 아니라 객체를 던지는식으로 처리함 요즘음
    navController.navigate("task/100")//옛날방식
    navController.navigate(Screen.Task(id = "100"))//요즘방식
  이렇게
  
  그리고 Navigator클래스를 만들고,여기에 백스택변수를 만들면됨
    val backStack: SnapshotStateList<Screen> = mutableStateListOf(Screen.Home)
  이렇게 SnapshotStateList을 사용해야 컴포저블스코프내에서 관측할수있음
  일반리스트를 쓰면 ui가 바뀌어도 업데이트되지않음
  이렇게 백스택을 쓰면,화면들이 여기에 순서대로 겹쳐져있는느낌으로 동작하고,제일위에있는거만 현재 실행중인 화면이 됨
  
  그리고 이동함수와 돌아가는 함수를 만들면됨
    fun navigateTo(screen: Screen) {
        backStack.add(screen)
    }
    fun navigateBack() {
        backStack.removeLastOrNull()
    }
  이렇게
  
  그리고나서 내비게이션그래프만 만들면됨
  여기엔 우리가 갈수있는 모든 목적지구성요소가 들어있음
  현재버전기준으로는 ios에서는 내비게이션을 쓸수없어서,expect로 만들고 각각 안드와 ios에서 구현을 해줘야함
    @Composable
	expect fun NavGraph()
  이렇게 commonMain에 만들고,알트엔터로 구현생성하면됨
  
  그리고 NavDisplay를 사용해서 그래프를 만들면됨
    @Composable
	actual fun NavGraph(navigator:Navigator) {
		NavDisplay(
			backStack = navigator.backStack,  //백스택
			onBack = { navigator.navigateBack() },//뒤로가기할때 사용할 함수
			entryProvider = entryProvider {  //사용할 모든 화면들
				entry<Screen.Home> { //각화면들
				                      //화면구현컴포저블클래스 넣으면됨
				}  
				entry<Screen.Task> { 
				                       //화면구현컴포저블클래스 넣으면됨
				}
			},

		)
	}
  이렇게

*2.koin di 프레임워크
  이건 그냥 di라이브러리임
  처음에 세팅에서 유의해야할건 빌드그래들에서 안드로이드 디펜던시에
    implementation(libs.koin.android)
  이게 들어가야한다는거정도(위에서 세팅할떄 들어있음)
  
  이거도 의존성세팅용 패키지는 하나 만드는게좋고
  모듈을 만들고 이걸 init에서 키면됨
  
  모듈을 만들떄 싱글톤생성하려면
    val koinModule = module {
      singleOf(::Navigator) //이건 최신방식
	  //single(Navigator(get()))//이건 예전방식,get을 쓰면 스프링처럼 알아서 끼워주고,명시적으로 넣을수도있음
    }
  이렇게 생성하면되고
  매번 생성하려면
    factoryOf(::GetUserUseCase)
  이렇게하면됨
  등록할떈
	fun initKoin(
		config: (KoinApplication.() -> Unit)? = null,  //수신객체지정함수
	) {
		startKoin {
			config?.invoke(this)
			modules(koinModule)
		}
	}
  이렇게 등록하면됨
  
  안드로이드와 ios메인에 각각 initKoin을 실행시켜줘야하는데,이건
  ios는
    fun MainViewController() = ComposeUIViewController(
      configure = { initKoin() },
    ) { App() }
  이렇게 메인뷰에 configure에서 실행시켜주면되고
  
  안드로이드는 Application을 상속한 클래스를 만들고,여기서 onCreate의 마지막에 initKoin을 실행시켜주면됨
	class MyApplication : Application() {
		override fun onCreate() {
			super.onCreate()
			initKoin(config = { androidContext(this@MyApplication) })//안드로이드 컨텍스트 추가
		}
	} 
  그리고 AndroidManifest.xml에서 application에
    android:name=".MyApplication"
  을 추가해서 저거로 부팅하겠다는걸 선언해주면됨
  이러면 의존성라이브러리 설정은 끝났음
  
  그리고 의존성을 받을땐 여러방법이 있는데,
  필드로 받는건(보통 컴포저블들은 이렇게 받을수밖에없음)
    val navigator = koinInject<Navigator>()
  이렇게 받으면 해당 타입클래스가 koin에 등록되어있다면 그걸줌(보통 싱글톤일테니)
  생성자로 받는건,해당클래스에 val로 의존성을 받게하고
    class MyViewModel(val repository: MyRepository) : ViewModel()
  넣는건 모듈에서 넣으면됨
    viewModel { MyViewModel(get()) }
  이렇게 넣거나,
    viewModelOf(::MyViewModel)
  이렇게 리플렉션으로 넣으면 알아서 생성자를 분석해서 주입해줌(파라미터가 많아도 알아서해줘서 편함)
  
  즉 모듈에서 어떻게 조립할지를 선언한후 init를 하면 주입된상태로 생성되어있는거
  
  추가로 인터페이스주입(여러클래스중 하나 택일주입)을 할떈 bind를 사용해서 현재타입을 감출수있음
    // ThemeServiceImpl을 만들되, 외부에서는 ThemeService 타입으로 쓰겠다.
    singleOf(::ThemeServiceImpl) { bind<ThemeService>() }  
  생성자에서는 인터페이스를 적으면됨
    class MainViewModel(val themeService: ThemeService) : ViewModel()
  이렇게
  
  그런데 컴포저블함수들은 클래스가 아니기떄문에,필드주입을 받아야함(KoinInject,KoinVoewModel())
  그렇다고 모든 컴포저블함수에서 필드주입을하면 개판나니까 최상위에서 주입한다음 아래로는 전달만 하는 상태 호이스팅을사용하는게 좋음
  보통 스크린 함수에서만 주입받고,하위 컴포넌트들은 매개변수로 받아서 사용하는식
  
*3.마테리얼 테마 색상 생성 
  마테리얼3에는 기본색,보조색등 다양한 기본 색상토큰들이 이미 들어있음 
  그리고 우리가 추가할수도있음,그런데 직접 만드는건 복잡해서,외부사이트를 통해 쉽게만들수있음
    https://material-foundation.github.io/material-theme-builder/
  여기 들어가면 색상을 선택하고,폰트를 고르면 거기에 테마를 명암비로 3개씩 만들어줌
  라이트모드와 다크모드도 테스트할수있고 다운로드할수있음
  그러면 theme.kt로 받을수있는데,그러면 압축파일안에 ui/theme폴더안에 테마,컬러,타입 3가지가 들어있음
  이걸 우리쪽에다가 따로 패키지를 만들고 가져가서 쓸수있음
  
  그리고 각 코틀린파일의 패키지경로 바꿔주고,색상과 테마 설정을 App에서 할수있음
	@Composable
	fun App() {
		val colorScheme = if (isSystemInDarkTheme()) darkScheme else lightScheme
			MaterialTheme(colorScheme) {
				NavGraph()
			}
		}
	}
  이렇게 하면됨
  
*4.ToDoTask모델 클래스  
  그냥 엔티티클래스 만드는거
    val id: String = Uuid.random().toHexString(),
  로 uuid자동생성가능하다는거정도?
  대신 @OptIn(ExperimentalUuidApi::class) 붙여야함
  
  그거말곤 그 클래스에서만 쓰는 클래스라면 그냥 같이두는게 낫다정도?
  
*5.아이콘/이미지 리소스 추가  
  기본적인 아이콘은 composeMain/composeResources/drawable에 벡터에셋을 추가한후,거기서 클립아트에서 원하는 아이콘을 검색해서 넣고 저장하면됨
  그리고 가져다쓸땐
	Icon(
		painter = painterResource(id = R.drawable.ic_filter_list),
		contentDescription = "Sort Tasks"
	)
  이렇게 가져다쓰면됨
  만약 외부에서 받은거 쓰고싶으면,composeMain/composeResources에 벡터에셋을 추가하는건 똑같은데,이때 로컬파일을 첨부하면됨
  
  그리고 리소스를 가져오는 유틸오브젝트를 만들고 연결하면됨
	object Resource {
		object Icon {
			val BACK_ARROW = Res.drawable.arrow_back
			val BLANK_BOX = Res.drawable.blank_box
			val CHECK_BOX = Res.drawable.check_box
		}

		object Image {
			val PAINTING_LIGHT = Res.drawable.painting_light
			val PAINTING_DARK = Res.drawable.painting_dark
		}
	}
  이렇게 만들어두면 편하게 가져다쓸수있음
  아이콘과 이미지는 물리적으로는 똑같지만,논리적으로 분리되기때문에 따로두면좋음
  만약 arrow_back처럼 이런 아이콘들이 인텔리센스에 안뜨면 실행함떙기면 리빌딩하면서 나올거임
  
  그리고 아이콘들은 마테리얼심볼에서 찾을수도있음
  
*6.인포카드와 로딩카드 컴포넌트 만들기  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  