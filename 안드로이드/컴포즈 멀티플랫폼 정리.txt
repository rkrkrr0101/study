1.젝팩컴포즈 기본
*1.젯팩컴포즈 소개
  스킵
*2.상태 및 재구성
  상태는 실제로 사용하고있는 컴포넌트의 상태(변수)임
  이건 remember을 사용하면,리컴포지션이 되었을때도 값을 유지하고있을수있음
  remember을 사용하지않았다면 그냥 초기화됨(그래서 리컴포지션이 되었을때 초기화되는식으로 변수유지하는 트릭이 있긴한데 안쓰는게좋음,화면회전등에서도 반응해서)
  즉 remember을 사용해서 순수함수에 사이드이펙트를 넣는느낌임
  이건
    var name by remember{
	  mutableStateOf("")
	}
  이런식으로 사용됨
  
  기본적으로 컴포저블함수안의 컴포넌트(TextField등)은 상태를 갖지않고,외부에 상태를 선언해둔후 끼우는식으로 만들게됨
  이래야 테스트와 유지보수가 쉬워짐
  이렇게 remember로 상태를 만들어두면 계속 그 상태를 옵저빙하고있게됨,
  그러다가 상태가 어떤이유로든 변경되면 해당 상태를 가지고있는 모든 컴포넌트들이 갱신되는데 이게 재구성(리컴포지션)임
  기본적으로 젯팩컴포즈는 선언형이고,그래서 값을 바꾸면 그 값에 맞춰서 다른것들이 수정되는형태를 띄는것
  
  보통 컴포넌트에서 마지막매개변수는 content람다를 받는데,제일마지막 람다니까 그냥 
	Button(
	  onClick=buttonClick()
	){
       ...
	}
  이런식으로 쓸수도있음
  보통 이건 그안에 뭘넣을지(버튼이라면 텍스트,아이콘등)을 정의하는곳임
  
  기본적으로 remember을 사용해서 상태를 기억하는(stateful)방식과,외부에서 값을 주입받는(stateless)방식이 있는데,가급적이면 스테이트리스를쓰는게 나음
    //스테이트풀
	@Composable
	fun abc(){
		var name by remember{
		  mutableStateOf("")
		}	
		...
	}
	//스테이트리스
    @Composable
	fun abc(name:String){
		...
	}  
  이래야 커스터마이징,테스트가 쉬움(프리뷰쓰기도편함)
  정말 꼭 필요하지않으면 내부상태유지(스테이트풀)는 하지않는게좋음
  
  기본적으로 재구성을 발생시키는건
    상태변경:상태(State,MutableState,LiveData/Flow)들중 collect되고있는애들이 변경될떄,즉 스테이트풀 변경시
	파라미터변경:컴포저블함수의 입력파라미터가 변경될때,즉 스테이트리스 변경시
	파생상태:derivedStateOf가 변경될때
  들임
  
  ui는 현재상태에 따라 ui를 출력하는 컴포지션함수들로 구성됨
  우리는 선언적으로,ui가 어떻게 보일지를 정의하면 이걸 알아서 그렇게 바꿔주고,상태가 변경되면 즉시 그 상태대로 바꿔주는거임
  이런과정을 리컴포지션이라고 부름
  
  그리고 불변데이터(val)는 remember로 업데이트하려면 통째로 갈아야함
  data class User(
    val name="abcd",
	val age:Int=29
  )
  var user by remember{
    mutableStateOf(User())
  }
  Button(
    onClick={
	  user=User(
	    name=user.name
		age=user.age+1
	  )
	}
  )  
  근데 그러면 너무 복잡하니까 .copy를 사용하면 편함
  이건 데이터클래스에서 자동으로 만들어주는 함수로,변경할값만 바꾸면됨
  Button(
    onClick={
	  user=User.copy(age=user.age+1)
	}
  )   
  
*3.구성변경 및 상태지속성
  구성변경이벤트란,사용자가 화면을 회전하거나 테마를 변경하는등의 상황에서 일어나는 이벤트임
	화면회전
	테마변경
	언어변경
	폰트변경
	시스템앱킬(강제종료)
  등의 상황에서 발생함
  이상황에서는 remember로 상태를 저장해도 저장이 되지않게됨
  그래서 사용되는게 rememberSaveable임
  이건 그냥 remember대신 그자리에 넣고쓰면됨
    var count by rememberSaveable{
	  mutableStateOf(0)
	}
  이렇게
  단,이건 인트,스트링,더블등 기본형만 저장이 됨,그래서 객체같은건 id만 기억하는식으로 보통 사용하고
  데이터클래스같은건 custom saver을 만들어서 사용해야함
  이건 Saver로 형태를 지정해두고 그걸 rememberSaveable(stateSaver=해당형태)하는식으로 사용함
    val UserSaver:Saver<User,Any>=Saver(
	  save={user->listOf(user.name,user.age)},
	  restore={list->
	    val name=list[0] as String
		val age=list[1] as Int
		User(name,age)
	  }
	)
    var user by rememberSaveable(stateSaver=UserSaver){
	  mutableStateOf(User("abc",15))
	}
  이런식으로 사용하게됨
  이러면 구성변경시에도 해당값을 유지할수있음
  
  다른방법으로는 ViewModel을 사용할수있음
  뷰모델속의 상태들은 구성변경후에도 계속 유지됨
  우리는 그냥 거기에 상태를 선언하고 초기화만 해두면됨
  보통 세터는 잠궈두고,거기에맞는 함수노출해서 그걸사용함(상태변경의 캡슐화)
    class abcViewModel:ViewModel(){
	  var count by mutableStateOf(0)
	    private set
	  fun increment(){
	    count++
	  }
	}
	@Composable
	fun CounterScreen(){
	  val viewModel:CounterViewModel=viewModel()
	  val count=viewModel.count
	  
	  Button(onClick={viewModel.increment()})
	}
  대충 이런식으로 사용하게됨
  
  모든상태는 최상위레벨에서 초기화되고 사용되어야함
  또한 그곳에서 뷰모델을 초기화해야함
  뷰모델은 재구성과 구성의 영향을 받지않아서,remember을 사용할필요가없음(프로세스종료시에만 삭제)
  
  프로세스종료시에도 값을 저장하고싶다면,savedStateHandle을 사용할수있음
    class abcViewModel:ViewModel(
	  private val savedStateHandle:SavedStateHandle
	){
	  var count by mutableStateOf(savedStateHandle.get<Int>("count") ?:0)
	    private set
	  fun increment(){
	    count++
		savedStateHandle["count"]=count
	  }
	}  
  이런식으로 db처럼 외부에 저장한값을 불러오고,아니면 기본값을 설정하는식으로 사용됨
  이건 사용자가 이전에 무슨화면에서 종료했는지를 기억한다음,그걸 다시불러오거나 할때 사용됨
  이건 채널방식으로 유용하긴하지만,모든 상태에 대해 이렇게하면안되고,꼭 이렇게 해야하는것만 하는게좋음
  그리고 만약 이렇게 여러 상태를 저장해야한다면,그냥 제네릭확장함수만들어서 넣어두면편함
    fun <T> SavedStateHandle.mutableStateOf(
	  key:String,
	  default:T,
	):MutableState<T>{
	  val state=mutableStateOf(this[key]?:default)
	  return object:MutableState<T> by state{
	    override var value:T
		  get()=state.value
		  set(value){
		    state.value=value
			this@mutableStateOf[key]=value
		  }
	  }
	}
  이렇게
  
  또한 데이터클래스를 사용해서 뷰모델속의 데이터들을 묶어두는것도 도움이됨
  즉 remember대신 기본적으로 뷰모델에서 상태를 저장하는게 나음
  ui쪽에서는 ui만
  
*4.이벤트와 UDF(단방향데이터흐름)
  보통 이벤트는 이런식으로 만들고 사용됨
    sealed class UiEvent{
	  data class ShowSnackBar(val message:String):UiEvent()
	  data class NavigateTo(val screen:Screen):UiEvent()
	  data class RequestPermission(val permission:String):UiEvent()
	}
  sealed은 안붙여도되긴하지만,보통 클린아키텍처적으로 쓰려고 붙이는편임
  이렇게 이벤트클래스를 만들어둔다음,뷰모델에서 이벤트채널을 만들고,해당이벤트를 추가할때 사용하는 함수를 만드는식
    class MyViewModel:ViewModel(){
	  var state by mutableStateOf(ScreenState());
	    private set
		
	  private val _events=Channel<UiEvent>() //이벤트 채널(일회용이니까 채널사용)
	  val events=_events.receiveAsFlow()
	  
	  fun showSnackBar(message:String){ //채널에 이벤트를 추가할때 호출,스낵바를 보여달라고 호출하는느낌임(캡슐화)
	    viewmodelScope.launch(Dispatchers.Main){
		  _events.send(UiEvent.ShowSnackBar(message))
		}
	  }
	}
  이렇게 이벤트를 큐에 추가하고,컴포저블함수에서 이벤트를 처리하는방식
  뷰모델에는 ui관련로직을 추가하면안됨,그래서 실제로 ui관련을 직접 처리하지말고,해당하는 이벤트만 보내고,함수이름은 캡슐화해두는것
  처리는
    @Composable
	fun MyScreen(){
	  val viewModel:MyViewModel=viewModel()
	  
	  LaunchedEffect(Unit){
	    viewModel.events.collect{event->
		  when(event){
		    is UiEvent.ShowSnackBar ->{...}
		    is UiEvent.NavigateTo ->{...}
			else ->{...}
		  }
		}
	  }
	}
  이런식으로 처리하게됨
  LaunchedEffect로 이벤트를 계속 받으면서,해당하는이벤트가 들어오면 바로 해당로직을 실행시키는방식
  
  상태는 바깥으로(아래로) 흐르고,이벤트는 안으로(위로) 흐름
  상태는 현재 ui를 설명하는 데이터묶음임
  이건 뷰모델에서 컴포저블,하위컴포저블로 흐름(ui,즉 바깥으로)
  즉 상태는 뷰모델과,최상위 컴포저블(screen)에서 모든 상태를 정의하고,그 하위 컴포저블들은 그런 상태를 합성등으로 가져오는식으로 의존하게됨
  
  이벤트는 사용자가 어떤 행동을 트리거하면,이벤트를 등록하고 이를 뷰모델에 알림(뷰모델의 이벤트채널에 이벤트를 추가)
  그리고 그 이벤트에 반응하기위해 ui에서는 뷰모델의 채널을 관찰하고있음
  
  요약하면,상태는 뷰모델과 최상위컴포저블에서 가지고(보통 상태보유는 뷰모델이 하고),그게 흘러서 버튼같은 하위컴포저블로 흘러들어가는것
  같은 상태에 의존하는 컴포저블들은 데이터나 같은상태가 변경될때마다 다시 렌더링됨
  또한 사용자가 이벤트를 수행하면 즉시 뷰모델의 이벤트채널에 추가되고,선택적으로 상태를 변경시키고,
  이벤트를 수신하는쪽에서 이벤트를 컨슘하고 토스트같은 작업을 진행함
  
  그래서 상태는 뷰모델에서 하위로 나가니까 아래로 흐른다는거고,
  이벤트는 하위에서 발생해서 뷰모델채널에 추가되니까 위로흐른다는거임
  
  보통 이벤트는 큰단위로 구분해서 사용함,UiEvent,LoginEvent 이런식으로 sealed클래스묶음을 만들어서 사용하는식
  이거단위별로 채널을 만들고 구독시키면됨
  
  
*5.상태 호이스팅 
  상태 호이스팅(상태 상승)은,하위컴포저블에서 상위컴포저블로 상태를 이동시키는 관행을 말함
  즉 상태를 상위컴포저블에 몰아두고,하위컴포저블은 매개변수합성을통해 구성되기때문에,스테이트리스로 구성하게됨
  이러면 쉽게 재사용가능하고,테스트가 쉬워짐
  
  추가적으로 컴포저블에서는 null허용하는 컴포저블을 만들일이 많은데,이걸 typealias로 만들어두면편함
    typealias NullableComposable=(@Composable () -> Unit)

*6.레이아웃
  레이아웃은 자식컴포저블들의 위치를 지정하는 컴포저블함수임
  즉 그안에 속한애들을 어떤식으로 정리할지(수직,수평,겹쳐서등)을 정의함
  레이아웃들은 측정과 배치라는 책임이 있음
  
  레이아웃은 
    column:세로배열
	row:가로배열
	box:안에 계속 쌓음(포개어둠)
  등이 있음
  
  horizontalArrangement는 어떤식으로 배치할지를 선택하는건데
    Start:시작부터 배열
	End:끝부터 배열
	Center:중앙배열
    SpaceBetween:최대한 멀리 띄워둠(제일바깥패딩제거)
	SpaceAround:제일 바깥에도 약간의 패딩을 둠
	SpaceEvenly:제일 바깥에도 똑같이 패딩을 둠
  들이 있음
  Alignment는 정렬매개변수임
  Top,Center,Bottom과 Start,Center,End를 섞어서 사각형을 9등분해서 어디둘지 정하거나,
  Vertical로 세로(이떈 Top,CenterVertically,Bottom)정렬
  Horizontal로 가로(Start,CenterHorizontally,End)정렬
  들을 사용할수있음
  얘는 horizontalArrangement보다 좀더 정교하게 배열할수있음


*7.모디파이어
  모디파이어는 객체의 외형을 변경할떄 보통 사용되고,접근성(clickable같은)등을 제어하기위해서도 사용됨
  컴포넌트의 속성을 조정하기위한 용도라고 보면됨
  모디파이어는 순서가 중요하고,순서대로 적용됨
  그래서 clickable은 보통 제일위에 두는편
  만약 제일마지막에 두면,백그라운드등에는 물결표시가 안나고,글자에만 나게됨
    
  각 컴포지션함수들은,이전함수에서 반환된 모디파이어를 변경하고,이 순서또한 최종결과에 영향을 미침
  그래서 스코프 세이프티로 어디까지 모디파이어가 영향을 주는지를 명확히 알아야하는데,
  기본적으로는 자신의 자식요소에는 해당 컴포넌트의 디폴트로 적용되고,해당컴포넌트가 그값을 명시적으로 바꾸면 그값이 적용되는느낌
  또한 부모의값을 받아오는 모디파이어함수들도 있음
    .matchParentSize()
  이런거들
  matchParentSize는 박스에서만 사용할수있고,컬럼이나 로우에선 사용할수없음
  weight(얘가 얼마나 차지할지 비율,1f,5f가 있으면 1대 5로 전체를 차지함)는 컬럼로우에서만 사용가능하고,박스에선 사용불가능함(박스에선 의미없으니까..)
  
  모디파이어도 확장함수를 사용해서 일정템플릿을 만들어두면 쓰기편함,재사용도 편해지고
  또한 than을 사용하면 if문을 내부에서 쓸수있음
    modifier=Modifier
	  .then(
	    if (...){
		  Modifier
		    .size(30.dp)
		}else Modifier
	  )
  이런식으로
  이거말고 takeIf나 let(현재 호출대상 가져오기,it으로 사용)등도 사용가능
  
  추가적으로 젯팩컴포즈엔 마진이 없고 패딩만 존재함

*7.Lazy 컴포넌트
  레지컴포넌트는 큰 데이터를 효율적으로,즉 지연렌더링으로 표시하는 컴포넌트들임
  이건 말그대로 테이블전체를 한번에 표시하고 가지고있는게 아닌,화면에 실제로 보이는것들만 렌더링하는거
  리사이클러뷰에서 발전한거 맞음
  
  이걸 쓰는이유는
    성능
	간편성
	유연성
  이 있음
  리사이클러뷰보다 엄청나게 편해졌고,유연성도 높으면서 성능은 그대로임
  
  이건 보통 LazyColumn이나 LazyRow를 사용하고,이건
    LazyColumn{
	  items(
		items=users,
		key={it.id}
	  ){user->
		Text(text=user.name)
	  }	  
	}
  이런식으로 사용하게됨
    LazyColumn{
	  userList
	    .groupBy{it.date}
		.forEach{(date,users)->
		  item{
		    Text(text=date)
		  }	  
	      items(
		    items=users,
		    key={it.id}
		  ){user->
	        Text(text=user.name)
	      }
		}
	}  
  여기서 forEach내에서 item을 사용하면 하나만 표시되고,items를 사용하면 그 리스트를 다쓸떄까지 사용함
  즉 제목과 테이블을 뽑을때 씀
  이경우엔 그룹바이로 묶은다음 그걸 표시하는식으로 사용함
  
  items대신 itemsIndexed도 있는데,이건 인덱스값을 사용해야할때 사용함(람다값으로 인덱스도 받을수있음)
  
  레지컴포넌트에서 중요한건 key파라미터임
  이건 
    items(key={it.id})
  이런식으로 지정하는데,이건 해당 리스트내부에서 유니크한값을 사용해야함(해당 리스트에서만 유니크하면됨,보통 id쓰면되긴함)
  이걸 사용하지않아도 동작이 되긴하는데,이경우 추가,삭제,순서변경등을 하면 문제가 생기니,항상 넣는게 좋음
  또한 키가 중복될경우에도 문제가 생기니 조심
  
  레이지로우와 컬럼말고도,LazyVerticalGrid나 LazyHorizontalGrid등 여러가지가 있음
  또한 FlowColumn과 FlowRow는 항목의 갯수에 따라 화면에 표시될 항목크기등을 조절하거나,새행으로 넘기거나 할수있음

*8.remember과 derivedStateOf의 차이점











 
  
  
  
  
  
  
  
  