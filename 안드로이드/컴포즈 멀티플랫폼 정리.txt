1.젝팩컴포즈 기본
*1.젯팩컴포즈 소개
  스킵
*2.상태 및 재구성
  상태는 실제로 사용하고있는 컴포넌트의 상태(변수)임
  이건 remember을 사용하면,리컴포지션이 되었을때도 값을 유지하고있을수있음
  remember을 사용하지않았다면 그냥 초기화됨(그래서 리컴포지션이 되었을때 초기화되는식으로 변수유지하는 트릭이 있긴한데 안쓰는게좋음,화면회전등에서도 반응해서)
  즉 remember을 사용해서 순수함수에 사이드이펙트를 넣는느낌임
  이건
    var name by remember{
	  mutableStateOf("")
	}
  이런식으로 사용됨
  
  기본적으로 컴포저블함수안의 컴포넌트(TextField등)은 상태를 갖지않고,외부에 상태를 선언해둔후 끼우는식으로 만들게됨
  이래야 테스트와 유지보수가 쉬워짐
  이렇게 remember로 상태를 만들어두면 계속 그 상태를 옵저빙하고있게됨,
  그러다가 상태가 어떤이유로든 변경되면 해당 상태를 가지고있는 모든 컴포넌트들이 갱신되는데 이게 재구성(리컴포지션)임
  기본적으로 젯팩컴포즈는 선언형이고,그래서 값을 바꾸면 그 값에 맞춰서 다른것들이 수정되는형태를 띄는것
  
  보통 컴포넌트에서 마지막매개변수는 content람다를 받는데,제일마지막 람다니까 그냥 
	Button(
	  onClick=buttonClick()
	){
       ...
	}
  이런식으로 쓸수도있음
  보통 이건 그안에 뭘넣을지(버튼이라면 텍스트,아이콘등)을 정의하는곳임
  
  기본적으로 remember을 사용해서 상태를 기억하는(stateful)방식과,외부에서 값을 주입받는(stateless)방식이 있는데,가급적이면 스테이트리스를쓰는게 나음
    //스테이트풀
	@Composable
	fun abc(){
		var name by remember{
		  mutableStateOf("")
		}	
		...
	}
	//스테이트리스
    @Composable
	fun abc(name:String){
		...
	}  
  이래야 커스터마이징,테스트가 쉬움(프리뷰쓰기도편함)
  정말 꼭 필요하지않으면 내부상태유지(스테이트풀)는 하지않는게좋음
  
  기본적으로 재구성을 발생시키는건
    상태변경:상태(State,MutableState,LiveData/Flow)들중 collect되고있는애들이 변경될떄,즉 스테이트풀 변경시
	파라미터변경:컴포저블함수의 입력파라미터가 변경될때,즉 스테이트리스 변경시
	파생상태:derivedStateOf가 변경될때
  들임
  
  ui는 현재상태에 따라 ui를 출력하는 컴포지션함수들로 구성됨
  우리는 선언적으로,ui가 어떻게 보일지를 정의하면 이걸 알아서 그렇게 바꿔주고,상태가 변경되면 즉시 그 상태대로 바꿔주는거임
  이런과정을 리컴포지션이라고 부름
  
  그리고 불변데이터(val)는 remember로 업데이트하려면 통째로 갈아야함
  data class User(
    val name="abcd",
	val age:Int=29
  )
  var user by remember{
    mutableStateOf(User())
  }
  Button(
    onClick={
	  user=User(
	    name=user.name
		age=user.age+1
	  )
	}
  )  
  근데 그러면 너무 복잡하니까 .copy를 사용하면 편함
  이건 데이터클래스에서 자동으로 만들어주는 함수로,변경할값만 바꾸면됨
  Button(
    onClick={
	  user=User.copy(age=user.age+1)
	}
  )   
  
*3.구성변경 및 상태지속성  
  
  
  
  
  
  
  
  
  
  
  
  