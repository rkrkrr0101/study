그리디:그냥 젤 많은거부터 단순하게 채워나감 바로앞에보이는 젤큰이득따라감

인접행렬:그냥 2차원배열에 0번은 첫줄에 0노드비용,1노드비용,2노드비용순으로 채워넣음 그래서 [i][i]는 항상 0
graph = [
 [0, 7, 5],
 [7, 0, INF],
 [5, INF, 0]
]
그러니까 노드수가 늘어나면 행렬이 많이커짐
인접리스트:2차원배열에 1번노드 2번노드 가지고있는건 행렬이랑 똑같은데 0번노드에 추가하려면 array[0]에 어펜드해서 추가하는식
[[(1, 7), (2, 5)], [(0, 7)], [(0, 5)]]
1,7 2,5가 0번노드에 붙어있는 노드들임 대신 얘들은 리스트라서 앞에서부터 포루프돌려야대서 시간복잡도가 높음 검색할떄

DFS:깊이우선탐색 한줄로 우직하게 파고 들어가서 바닥보고 그위에 다음바닥보고 함
	구현은 갈수있는노드 for로 반복해서 값바꿔서 재귀함수호출(자기자신) 그래서 자기가 바닥일경우 리턴
	결과적으로 스택식으로 쌓이다가 더쌓을거없으면 하나뺴고 그위에 넣을거있으면 넣고 반복
	그러니까 처음주는 그래프복사해서 방문한그래프 하나 만들어서 그거 색칠하면서 색칠다되면 자동으로 끝나게하면됨
	(if not visited[i]:dfs() )
BFS:너비우선탐색 일단 그라인에서 갈수있는거 다 하나씩 간다음에 계속 단계 늘려나가는 식으로 감
	1번이동(234)2번이동(567)이런느낌임 그러니까 목표지에 처음 도달한값이 무조건 최단경로일수밖에없음
	큐에 시작점넣고 그거 빼고 연결노드 다넣고 맨밑에거 빼고 다음거 다넣고하는식으로 1번노드의 연결점을 다 처리해야 다음노드연결점을
	처리할수있음
	구현은 큐만들고 방문지만들고 큐바닥날떄까지 와일문 돌리고 큐에서 하나 팝해서 그거잡고 반복문돌려서 방문한적없으면 
	큐에 다넣고 다 방문처리하고 끝
	방문순서 필요할떄는 최단경로 무조건 하나나오면 리턴이니까 배열하나만들어서 하나 움직일때마다 전위치 적는식으로 한다음에 도착점배열잡고
	재귀돌려서 출력
정렬:계수정렬이랑 퀵소트만 알고있으면될듯 거의 정렬 끝나있는배열이면 삽입정렬 

	sorted(array,key=lambda x:x[1],reverse=True) ex)2차원배열에서 0,1번쨰중 1번째 키로잡고 역순으로 배열

퀵소트: 맨앞에 피벗으로 잡고 하나남으면 리턴 재귀조건달고 
	  끝까지반복문돌려서(파이썬 배열생성반복문써도됨) 
	  그거기준으로 크면 라이트배열에넣고 작으면 레프트배열에 넣어서 각각 재귀돌리고 라이트+피벗+레프트해서 리턴
계수정렬:정수일때만 동작하고 제일 큰거 작은거 폭이 작아야함 ex)성적 0부터 100까지있을떄라던가
	  정렬배열을 0부터 배열에서 제일큰거만큼 만들고 배열 처음부터 끝까지 루프돌려서 만나는 수마다 배열 그주소에 +1한다음에
	  루프끝나고 정렬배열에서 또 루프돌려서 주소값에 있는 숫자만큼 배열에 더해서 루프끝나면 리턴
	  
이진탐색:절반씩 잘라서 체크해서 왼쪽 오른쪽 판정만 하고 재귀돌다가 왼쪽오른쪽 교차나면 리턴
	  기본적으로 뭐 계산해서 할라고 하면안되고 결과값만 가지고 다때려박은다음에 왼쪽 오른쪽 판정만 하면 되는거같음
	  최적화문제를(시간 최소값을 구해라 이런거)선택문제로(왼쪽인지 오른쪽인지)바꿔서 풀수있게됨
	  높이가 막 10억 이러고있으면 무조건 이진탐색임
	  
DP:	  그냥 d[0] d[1] d[2] 앞에거 몇개만 적어두고 점화식만들어서 그거 앞에거 참고하면서 밀고나가면됨
	  
다익스트라:한노드기준 최단경로 구하는알고리즘(그리드계열임)
	   방문확인배열이랑 거리배열 만든다음에 현재노드에서 갈수있는 노드중 제일 코스트낮은노드 간다음에 그거 반복해서 (우선순위큐에넣어서)
	   완성후 리턴 처음위치는 0으로잡으면 알아서 코스트낮은노드되니까 그렇게하면됨 단 현재 최단거리적은거보다 적을때만 넣어야됨

플로이드 워셜:모든노드에서 모든노드로가는 최단경로(2차원배열) 전부 무한대처리하고 자기자신은 0처리하고
		 그냥 3중반복문으로 k a b 잡고 
		 graph[a][b]=min(graph[a][b],graph[a][k]+graph[k][b]
		 돌리면됨
		 지금 ab직진길이랑 k로가서b로가는거 비교해서 짧은거 적고 반복

서로소:요소들 한덩어리로 묶어줄떄 사용 123456에서 1234 56 으로 묶고싶으면 배열값뒤에 자기부모노드적어서 1121 55 이런식으로 나오게함
	구성은 find와 union 두개함수를 만들고 find에서 부모노드와 자기자신이 같을때까지(루트일때까지)루프돌리면서 자기의 부모를 그 루트로
	바꾸는 역할까지 수행(경로압축)
	union은 서로 루트 파인드해서루트 큰거에 작은거 부모노드를 적어줌(보통 작은걸 루트로씀)
	물론 경로압축을해도 순서에따라 전부 루트통일되는건 아니고 검색량이 좀 줄어들뿐이니까 찾을떄도 find로 찾아야됨 
	ex 14 23 21순으로 될떄 1 1 2 1 이런식으로 중간에 처리된건 안바뀜
	서로소를 가지고 무방향그래프에서 사이클이 있는지(다른길이 있는지)확인할수 있음
	if 루트노드가 서로 다르면 합치고
		루트노드가 같으면 사이클발생한거임
크루스칼:최저 비용으로 모든 노드 연결하는 알고리즘(그리드계열임)
	  선중 제일 작은걸 먼저 잡고 연결시킨다음 부모노드를 만들고 (start)
	  그다음 작은거를 잡고 부모노드가 같은지 다른지 확인하고
		같으면 건너뜀
		다르면 부모노드에 합침
	  선이 끝날때까지 or 노드 n-1개만큼 선이 연결될때까지 반복
	  
위상정렬:스킬트리에서 선행스킬이 있을떄 찍을순위같은거 이렇게 앞에걸 먼저 끝내야 할수있을때 순서뽑는정렬임
	  연결된 선갯수를 미리 적어두고
	  선이 0인거를 큐에 넣고
	  그걸뺴면서 근처 선을 다 제거하고
	  선이 0된거를 큐에 다 넣고
	  큐가 바닥날때까지 돌린다음에 리턴
	  이건 중간에 사이클이 발생하면  사이클에 포함된건 전부 못들어가니까 원소가 다 나오기 전에 끝나면 사이클있는거임
	  
	  
	
	
	