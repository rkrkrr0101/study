그리디:그냥 젤 많은거부터 단순하게 채워나감 바로앞에보이는 젤큰이득따라감

인접행렬:그냥 2차원배열에 0번은 첫줄에 0노드비용,1노드비용,2노드비용순으로 채워넣음 그래서 [i][i]는 항상 0
graph = [
 [0, 7, 5],
 [7, 0, INF],
 [5, INF, 0]
]
그러니까 노드수가 늘어나면 행렬이 많이커짐
인접리스트:2차원배열에 1번노드 2번노드 가지고있는건 행렬이랑 똑같은데 0번노드에 추가하려면 array[0]에 어펜드해서 추가하는식
[[(1, 7), (2, 5)], [(0, 7)], [(0, 5)]]
1,7 2,5가 0번노드에 붙어있는 노드들임 대신 얘들은 리스트라서 앞에서부터 포루프돌려야대서 시간복잡도가 높음 검색할떄

DFS:깊이우선탐색 한줄로 우직하게 파고 들어가서 바닥보고 그위에 다음바닥보고 함
	구현은 갈수있는노드 for로 반복해서 값바꿔서 재귀함수호출(자기자신) 그래서 자기가 바닥일경우 리턴
	결과적으로 스택식으로 쌓이다가 더쌓을거없으면 하나뺴고 그위에 넣을거있으면 넣고 반복
	그러니까 처음주는 그래프복사해서 방문한그래프 하나 만들어서 그거 색칠하면서 색칠다되면 자동으로 끝나게하면됨
	(if not visited[i]:dfs() )
BFS:너비우선탐색 일단 그라인에서 갈수있는거 다 하나씩 간다음에 계속 단계 늘려나가는 식으로 감
	1번이동(234)2번이동(567)이런느낌임 그러니까 목표지에 처음 도달한값이 무조건 최단경로일수밖에없음
	큐에 시작점넣고 그거 빼고 연결노드 다넣고 맨밑에거 빼고 다음거 다넣고하는식으로 1번노드의 연결점을 다 처리해야 다음노드연결점을
	처리할수있음
	구현은 큐만들고 방문지만들고 큐바닥날떄까지 와일문 돌리고 큐에서 하나 팝해서 그거잡고 반복문돌려서 방문한적없으면 
	큐에 다넣고 다 방문처리하고 끝
	방문순서 필요할떄는 최단경로 무조건 하나나오면 리턴이니까 배열하나만들어서 하나 움직일때마다 전위치 적는식으로 한다음에 도착점배열잡고
	재귀돌려서 출력
정렬:계수정렬이랑 퀵소트만 알고있으면될듯 거의 정렬 끝나있는배열이면 삽입정렬 

	sorted(array,key=lambda x:x[1],reverse=True) ex)2차원배열에서 0,1번쨰중 1번째 키로잡고 역순으로 배열

퀵소트: 맨앞에 피벗으로 잡고 하나남으면 리턴 재귀조건달고 
	  끝까지반복문돌려서(파이썬 배열생성반복문써도됨) 
	  그거기준으로 크면 라이트배열에넣고 작으면 레프트배열에 넣어서 각각 재귀돌리고 라이트+피벗+레프트해서 리턴
계수정렬:정수일때만 동작하고 제일 큰거 작은거 폭이 작아야함 ex)성적 0부터 100까지있을떄라던가
	  정렬배열을 0부터 배열에서 제일큰거만큼 만들고 배열 처음부터 끝까지 루프돌려서 만나는 수마다 배열 그주소에 +1한다음에
	  루프끝나고 정렬배열에서 또 루프돌려서 주소값에 있는 숫자만큼 배열에 더해서 루프끝나면 리턴
	  
이진탐색:절반씩 잘라서 체크해서 왼쪽 오른쪽 판정만 하고 재귀돌다가 왼쪽오른쪽 교차나면 리턴
	  기본적으로 뭐 계산해서 할라고 하면안되고 결과값만 가지고 다때려박은다음에 왼쪽 오른쪽 판정만 하면 되는거같음
	  최적화문제를(시간 최소값을 구해라 이런거)선택문제로(왼쪽인지 오른쪽인지)바꿔서 풀수있게됨
	  높이가 막 10억 이러고있으면 무조건 이진탐색임
	  





	