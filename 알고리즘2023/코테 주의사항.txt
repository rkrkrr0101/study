코틀린 max()못찾으면 maxOf{it}
효율성 어쩌고있으면 n^2말고 n이나 logn은 찍어야함
가능하면 직접 for문돌리는게 복잡도계산돼서 맞는거같음
중복지워야할거같으면 set쓰자
배열의 갯수 항상 신경쓰자,최소값보다 작은지
for하나로 해결가능하면 그냥 돌리자,이게 더 실수할일없을듯

이중리스트 집합으로 변환(리스트[집합(집합)])
	items = list(set([tuple(set(item)) for item in item]))
	print(items)
	# [(1, 2), (1, 3)]
이중리스트 resList에서의 안쪽리스트 중복제거(리스트[리스트(집합)])
	items=list(list([tuple(set(resList))for resList in resList]))
	
집합에서 discard()쓰면 없는거지워도됨




n이 1 000 000인 경우, O(n),O(nlogn)
n이10000이면 O(n^2),
n이500이면 O(n^3)
즉 만보다 크면 이중루프못돌림

절대값을 키로 정렬
	sortAbsA=sorted(배열명,key=abs)
	
최소거리찾기=bfs
전염시키기=dfs(전체배열 루프돌리면서 해당위치와 연결된거 전부 뒤집어야할때)
한지점에서 다른 특정지점까지 최단경로=다익스트라
모든지점에서 다른 모든지점까지 최단경로=플로이드워셜(이경우는 n이 100 뭐 이정도일거임 크기가)
서로 연결된 지점의 갯수세기(연결된애들을 하나로 묶어서 갯수세거나 해야할때),무방향그래프에서의 사이클판별=유니온파인드(275p)
	
	
	
	
	
	
	
1. 걍주는문제	
2.dfs,bfs,그리디(다익스트라,유니온파인드),dp아마 dp일거같은데,안배운거라는걸 알았으니 첨보는애들인 그래프쪽일수도있긴하겠다
3.구현문제 빡센듯
