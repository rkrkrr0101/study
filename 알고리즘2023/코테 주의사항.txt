코틀린 max()못찾으면 maxOf{it}
효율성 어쩌고있으면 n^2말고 n이나 logn은 찍어야함
가능하면 직접 for문돌리는게 복잡도계산돼서 맞는거같음
중복지워야할거같으면 set쓰자
배열의 갯수 항상 신경쓰자,최소값보다 작은지
for하나로 해결가능하면 그냥 돌리자,이게 더 실수할일없을듯

이중리스트 집합으로 변환(리스트[집합(집합)])
	items = list(set([tuple(set(item)) for item in item]))
	print(items)
	# [(1, 2), (1, 3)]
이중리스트 resList에서의 안쪽리스트 중복제거(리스트[리스트(집합)])
	items=list(list([tuple(set(resList))for resList in resList]))
	
집합에서 discard()쓰면 없는거지워도됨

갯수세야할때(개수정렬필요할떄)collections.Counter(배열명) 사용
most_common은 중복문제+시간복잡도같은거때문에 사용안하는게 나을듯


n이 1 000 000인 경우, O(n),O(nlogn)
n이10000이면 O(n^2),
n이500이면 O(n^3)
즉 만보다 크면 이중루프못돌림

절대값을 키로 정렬
	sortAbsA=sorted(배열명,key=abs)
	
최소거리찾기=bfs
전염시키기=dfs(전체배열 루프돌리면서 해당위치와 연결된거 전부 뒤집어야할때)
한지점에서 다른 특정지점까지 최단경로=다익스트라
모든지점에서 다른 모든지점까지 최단경로=플로이드워셜(이경우는 n이 100 뭐 이정도일거임 크기가)
서로 연결된 지점의 갯수세기(연결된애들을 하나로 묶어서 갯수세거나 해야할때),무방향그래프에서의 사이클판별=유니온파인드(275p)
최적화를 결정문제로->이진탐색(n만큼을 얻기위해 ~할수있는 최댓값,건드릴수있는값이 10억 이러면 일단 이진탐색생각해야함),
	해당조건을 만족하는걸 계속 갱신하면서 끝까지 돌리면됨


스택써야할거같으면 보통 입력과 출력으로 나눠서,입력시에는 append,출력시에 pop로 나눠서 생각하는게 편함(괄호같은거도 {에서 넣고 }에서 빼면되니)
즉,넣는곳과 아무것도 하지않는곳,빼는곳이 분리되는 구조일확률이 높음

while이나 for에도 else를 넣을수있음,이경우엔 break되지않고 정상종료됐을때만 동작함

중앙값구하기
	n이 array의 길이이고, array는 정렬되었다 가정,
	n이 홀수인 경우 :  median = array[ n//2 번째 ]
	n이 짝수인 경우 : median =  ( array[ n//2 번째  ] + array[ n//2 -1 번째  ] ) / 2	

count시간복잡도 n	

2차원배열 돌리기
def rotate_90(m):
    N = len(m)
    ret = [[0] * N for _ in range(N)]

    for r in range(N):
        for c in range(N):
            ret[c][N-1-r] = m[r][c]
    return ret




1. 걍주는문제	
2.dfs,bfs,그리디(다익스트라,유니온파인드),dp아마 dp일거같은데,안배운거라는걸 알았으니 첨보는애들인 그래프쪽일수도있긴하겠다
3.구현문제 빡센듯
