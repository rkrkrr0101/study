예약
	임시예약
	

https://jhkang-tech.tistory.com/774
https://alswns7984.tistory.com/91

https://www.perplexity.ai/search/naneun-deiteobeiseu-teibeuleul-w.8uEIpJR0uuYj3113vUnA

시간은 타임슬롯으로[24][6]관리?스타트엔드만 관리?
창고와 시간을 미리 선택하면,해당부분을 확인하고 겹치지않으면 예약주문을 날림
이때 확인을 누르는 즉시 임시예약을 insert하고,스키마에 겹치지않게 유니크처리(창고와 날짜?),겹쳤을때 예외처리

할증처리,공휴일처리?공휴일은 구하기힘드니 일요일처리?

안녕하세요 예약 시스템을 설계하면서 고민 중인데 집단 지성의 힘이 필요합니다 ㅜㅜ
창고 1, 2, … N이 있고 예약의 최소 단위는 10분입니다.
각 창고마다 최대 2주일만큼의 시간을 예약할 수 있습니다.
예를 들어 누군가 창고 1을 10월 30일 10:00 ~ 12:00으로 예약했다면 다른 사람들은 창고1의 이 닫힌 구간에 대해 예약이 불가능해야 합니다.
Q1. Mysql의 Gap Lock을 사용해 구간에 잠금을 거는 방법을 생각했으나 데드락이 우려되는 상황인데요 이를 해결할 좋은 방법이 있을까요?
Q2. 인메모리 저장소에 각각 시작시각, 종료시각을 저장하기 위한 두 개의 정렬된 자료구조에 예약 시작 시 조회 후 삽입 → 예약 완료 시 삭제하는 방법을 생각했지만 각 step이 원자적으로 실행되어야 하는 제약으로 복잡도가 너무 올라갈 것 같아 고민입니다.. 성능과 복잡도를 트레이드오프한다 생각할까요?

바쁘신 분들을 위한 3줄 요약
구간을 점유하는 상호배타적인 write 연산을 어떻게 하면 빠른 쿼리 속도와 동시성으로부터 자유롭게 할 수 있을까입니다.

다른곳에도 질문드리긴 했는데 다양한 의견을 듣고 싶습니다..!

--
TimeSlot(
startTimeInclusive : LocalTime,
endTimeInclusive: LocalTime
){
private val _slots[24][6]
init{
…
}

 fun overlaps(other: Timeline) : Boolean { …. }
}

2차원 배열로 타임슬롯을 표현하고 조회 시 레코드락 잠구고 하던 레디스에 타임슬롯을 올려두고 비교하든 하시면 어떨까요~ 

--
배열 24개 순회돌면서 겹치는지 안겹치는지 여부를 찾는건 찰나기도하고
--
꼭 배열로 안하더래도 로컬타임 두개로 겹치는지안겹치는지는 타임슬롯 타임라인 같은 밸류오브젝트로 처리하심어떨런지
--
[최재형] [오후 11:14] 저는 할인할증이 시간에 먹이고 있어서
[최재형] [오후 11:14] 특정 구간에 겹치는 규간은 할증, 할인 땜에.. ㅎㅎ
[최재형] [오후 11:15] 다만 예약은 아니어서 동시성문제는 없고
[최재형] [오후 11:15] 예전에 예약할때는 
[최재형] [오후 11:15] 일단위였어서 이런 고민은 딱히 안했었는데요
--
나중에 생각해봤을땐 
예약 테이블엔 프롬 투 적규
예약 슬롯 테이블 여긴 프롬 투 사이의 모든 값을 다 적고 예약슬롯 테이블을 잠구고 조회할수있게 예약테이블에 있는 그 기간를 레코드로 다 펼쳤습니다
[최재형] [오후 11:17] 창고를 잠구고 들어가니 문제가없지않을까요?
[윤좌홍] [오후 11:19] 아아 예약 테이블이 아니라 창고와 슬롯을 매핑한 테이블을 두는거군요
[최재형] [오후 11:19] 그리고 레디스에 올렸다면 슬롯을 가져간 순간 레디스에도 잠굼마킹하구 못읽게
[최재형] [오후 11:21] 네 그러면 창고 조회에서는 버퍼풀에서 가져갈테고 예약시 슬롯만 잠궈서 동시성을 제어하는 방식
[윤좌홍] [오후 11:25] 만약 최대 1년까지 예약이 가능한 상황으로 가정해도 저장공간만 늘려주면 되겠네요
[윤좌홍] [오후 11:25] 좋은 아이디어 같습니다 ㅎㅎ 감사합니다
[최재형] [오후 11:25] 그렇다면 타임슬롯 하나하나가 하루를
표현하고 있으니
[최재형] [오후 11:26] date: 까지 넣어서 타임라인으로 
[최재형] [오후 11:26] 타임라인들자체를 비교하게하면 많으면 365개고
[최재형] [오후 11:26] 월단위로 다시 묶고 이걸 바이너리서치로 찾으면
[최재형] [오후 11:26] 아니면 해시로 하던
[최재형] [오후 11:26] 그럼 탐색은 금방할겁니다
[윤좌홍] [오후 11:29] 앗 그런데 만약 10월 30일 10시에 2시간 예약을 했다면 12시가 되었을 때 slot을 갱신해주어야 하지 않나요?
[최재형] [오후 11:29] 네 
[윤좌홍] [오후 11:29] 미래의 예약이 할당될 공간 확보를 위해
[최재형] [오후 11:30] 제가 무매몽지하여 잘이해하지못했읍니다
[최재형] [오후 11:30] 12시가 됐을때 갱신한다는게 어떤말씀이시쥬
[윤좌홍] [오후 11:31] 예를 들어 10시에 2시간만큼의 slot을 할당했다면 12시가 됐을 때 더이상 점유된 slot이 없어야 하지 않나요?
[윤좌홍] [오후 11:32] 제가 잘못 이해했을 수도 있습니다 ㅠ
[윤좌홍] [오후 11:32] 아 그래서 이런 말씀을 하신거구나
[최재형] [오후 11:34] 열시부터 열두시까지 두시간을 예약하셨다면

slot[9][0]:10
slot[9][1]:10
slot[9][2]:10
slot[9][3]:10
slot[9][4]:10
아오 힘들다 임튼 이해하신거같슴다
[최재형] [오후 11:34] 네 날별로 해야 그 크로스오버
[최재형] [오후 11:34] 자정이넌어가는 시간도표현이가늘해서요
[윤좌홍] [오후 11:34] 창고 1의 10월 1일부터 31일까지의 slot 데이터를 들고있겠네요
[윤좌홍] [오후 11:34] ㅇㅎ
[최재형] [오후 11:34] 그거까지 타임슬 롯 자체로 표현하려면
[최재형] [오후 11:35] 스타트보다 끝이 작을땐
자정이넘어가는 시간이라 판단하고 듀레이션을 자정 기준으로 파티션으로 짤라서 비교..
[윤좌홍] [오후 11:36] 네네 이해했습니다 ㅎㅎ 야심한 밤 답변 감사합니다~!

--타임슬롯
data class TimeSlot(
    val startTimeInclusive: LocalTime,
    val endTimeInclusive: LocalTime,
) {
    init {
        require(this.startTimeInclusive != this.endTimeInclusive) { "시작 시간과 종료 시간이 같을 수 없습니다." }
    }

    val crossesMidnight: Boolean = this.startTimeInclusive > this.endTimeInclusive

    val crossesMidnightFirstTimeSlot: TimeSlot? =
        if (this.crossesMidnight && this.endTimeInclusive != LocalTime.MIDNIGHT
        ) {
            TimeSlot(LocalTime.MIDNIGHT, this.endTimeInclusive)
        } else {
            null
        }

    val crossesMidnightSecondPart: TimeSlot? =
        if (this.crossesMidnight) TimeSlot(this.startTimeInclusive, LocalTime.MAX) else null

    val isFullTime: Boolean = (this.startTimeInclusive == LocalTime.MIN) && (this.endTimeInclusive == LocalTime.MAX)

    val totalMinutes: Long =
        when {
            this.isFullTime -> FULL_DAY_OF_MINUTES
            this.crossesMidnight -> {
                val firstPart: Long = Duration.between(this.startTimeInclusive, LocalTime.MAX).toMinutes() + 1
                val secondPart: Long = Duration.between(LocalTime.MIDNIGHT, this.endTimeInclusive).toMinutes()
                firstPart + secondPart
            }

            else -> Duration.between(this.startTimeInclusive, this.endTimeInclusive).toMinutes()
        }

    fun overlapsWith(other: TimeSlot): Boolean =
        when {
            // 둘 다 자정을 넘기는 경우 무조건 겹침
            this.crossesMidnight && other.crossesMidnight -> true

            !this.crossesMidnight && other.crossesMidnight ->
                other.startTimeInclusive.isBefore(this.endTimeInclusive) ||
                        other.endTimeInclusive.isAfter(this.startTimeInclusive)

            this.crossesMidnight ->
                this.startTimeInclusive.isBefore(other.endTimeInclusive) ||
                        this.endTimeInclusive.isAfter(other.startTimeInclusive)

            else ->
                this.endTimeInclusive.isAfter(other.startTimeInclusive) &&
                        this.startTimeInclusive.isBefore(other.endTimeInclusive)
        }

    operator fun contains(other: TimeSlot): Boolean = other.startTimeInclusive in this && other.endTimeInclusive in this

    operator fun contains(time: LocalTime): Boolean =
        if (!this.crossesMidnight) {
            time in this.startTimeInclusive..this.endTimeInclusive
        } else {
            (this.crossesMidnightSecondPart != null && time in this.crossesMidnightSecondPart) ||
                    (this.crossesMidnightFirstTimeSlot != null && time in this.crossesMidnightFirstTimeSlot)
        }

    companion object {
        const val FULL_DAY_OF_MINUTES = 24 * 60L
        val FULL_TIME = TimeSlot(LocalTime.MIN, LocalTime.MAX)
        fun midnightTo(endTimeInclusive: LocalTime): TimeSlot = TimeSlot(LocalTime.MIDNIGHT, endTimeInclusive)
    }
}
--(타임라인)
class Timeline {
    val dayOfWeek: DayOfWeek
    val specifiedDate: LocalDate?
    private val _slots: MutableList<TimeSlot> = mutableListOf()
    val slots: List<TimeSlot> get() = this._slots.toList()

    constructor(dayOfWeek: DayOfWeek) {
        this.dayOfWeek = dayOfWeek
        this.specifiedDate = null
    }

    constructor(specifyDate: LocalDate) {
        this.dayOfWeek = specifyDate.dayOfWeek
        this.specifiedDate = specifyDate
    }

    fun satisfiedBy(selectedDate: LocalDate): Boolean =
        this.specifiedDate?.isEqual(selectedDate) ?: (this.dayOfWeek == selectedDate.dayOfWeek)

    fun addSlot(
        startTimeInclusive: LocalTime,
        endTimeInclusive: LocalTime,
    ) {
        this.addSlot(slot = TimeSlot(startTimeInclusive, endTimeInclusive))
    }

    fun addSlot(slot: TimeSlot) {
        check(!this.isOverlappingWithExistingTimeSlots(other = slot)) {
            "The specified time slot overlaps with an existing time slot."
        }

        this._slots += slot
        this._slots.sortBy { it.startTimeInclusive }
    }

    fun overlapsWith(other: Timeline): Boolean {
        if (!isSameDay(other)) return false

        return other._slots.any(this::isOverlappingWithExistingTimeSlots)
    }

    private fun isSameDay(other: Timeline): Boolean =
        this.specifiedDate?.isEqual(other.specifiedDate) ?: (this.dayOfWeek == other.dayOfWeek)

    private fun isOverlappingWithExistingTimeSlots(other: TimeSlot): Boolean {
        // 새로운 슬롯이 들어갈 위치를 찾음
        val position: Int = determineTimeSlotPosition(timeline = this, timeSlot = other)

        // 이전 슬롯과 겹치는지 확인
        val overlapWithPrevious: Boolean =
            position > 0 && this._slots[position - 1].endTimeInclusive > other.startTimeInclusive

        // 다음 슬롯과 겹치는지 확인
        val overlapWithNext: Boolean =
            position < this._slots.size && this._slots[position].startTimeInclusive < other.endTimeInclusive

        return overlapWithPrevious || overlapWithNext
    }

    private fun determineTimeSlotPosition(
        timeline: Timeline,
        timeSlot: TimeSlot,
    ): Int =
        timeline._slots
            .binarySearch { it.startTimeInclusive.compareTo(timeSlot.startTimeInclusive) }
            .let { if (it < 0) -(it + 1) else it }

    override fun equals(other: Any?): Boolean {
        if (this === other) return true
        if (this.javaClass != other?.javaClass) return false

        other as Timeline

        if (this.dayOfWeek != other.dayOfWeek) return false
        if (this.specifiedDate != other.specifiedDate) return false
        if (this._slots != other._slots) return false

        return true
    }

    override fun hashCode(): Int {
        var result = this.dayOfWeek.hashCode()
        result = 31 * result + (this.specifiedDate?.hashCode() ?: 0)
        result = 31 * result + this._slots.hashCode()
        return result
    }

    override fun toString(): String = "Timeline(dayOfWeek=${this.dayOfWeek}, specifiedDate=${this.specifiedDate}, slots=${this._slots})"

    companion object {
        fun fullTime(specifyDate: LocalDate): Timeline =
            Timeline(specifyDate = specifyDate).apply { this.addSlot(LocalTime.MIN, LocalTime.MAX) }

        fun fullTime(dayOfWeek: DayOfWeek): Timeline = Timeline(dayOfWeek = dayOfWeek).apply { this.addSlot(LocalTime.MIN, LocalTime.MAX) }
    }
}
--
[최재형] [오후 11:45] 잠금에대한부분 빼고는 비슷해서 한번 말씀드랴봤어여 ㅋ
[최재형] [오후 11:45] 저는 주어진 시간을 
[최재형] [오후 11:45] 차감하고 할증해야하는데
[최재형] [오후 11:45] 반복일정과 특정일의 정책이 중복 적옹이안되어야해서 
[최재형] [오후 11:47] 총 주차시간 9시부터 18시까지
11;00~13:00까지 주중할인 50프로 걸면 
120분에서 60분으로 조정해야해서
[최재형] [오후 11:48] 저기 그 겹치면안된다는 고민을 풀다보니 ㅋㅋ 비슷해서요

