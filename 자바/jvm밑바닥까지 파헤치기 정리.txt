1.자바와 친해지기
	스킵
2.자동 메모리 관리
  1.자바메모리영역과 메모리 오버플로
	자바 가상머신은 자바프로그램을 실행하는동안 메모리를 몇개의 영역으로 나눠서 관리하고,각 영역들은 목적과 생성삭제시점이 있음
	크게 가상머신과 생명주기를 같이하는애랑 스레드와 생명주기를 같이하는애로 나눠짐
	
	프로그램 카운터는 작은 메모리영역으로,현재 실행중인 스레드의 바이트코드 줄 번호 표시기임
	즉 GOTO같이 다음에 실행할 바이트코드명령의 위치를 가지는 작은 메모리영역임,그래서 스레드프라이빗함
	이건 모든 스레드가 각각 가지고있음(멀티스레딩이 cpu코어 하나를 번갈아가며 사용하는식이기때문)
	또한 스레드가 네이티브메서드(다른언어)를 실행중일때는 undefined가 뜸
	
	
	자바 가상머신스택도 프로그램카운터처럼 스레드프라이빗하고 생명주기가 스레드와 같음
	얘는 자바의 메서드가 호출될때마다 스택프레임을 만들어 지역변수테이블,피연산자 스택,동적링크,메서드반환값등 정보를 제공하고,
	이걸 프레임으로 만들어 가상머신스택에 푸시하고,메서드가 끝나면 팝함
	보통 자바의 메모리영역을 힙과 스택으로 구분하는경우가 많은데,
	실제로는 훨씬 복잡하지만 객체메모리할당과 가장 밀접하고 개발자들이 가장 신경써야하는 영역이 이 두개기때문
	보통 스택이라고 하면 이 자바 가상머신스택중에서도 지역변수테이블을 가리킬때가 많음
	
	지역변수테이블에는 자바 가상머신이 컴파일타임에 알수있는 기본데이터타입,객체참조,반환주소타입을 저장함
	이때 데이터타입을 저장하는공간을 지역변수슬롯이라고 하고,슬롯하나의 크기는 32비트임
	그래서 더블같은경우 2슬롯을 차지하고,나머지는 1슬롯을 차지함
	자바메서드는 스택프레임에서 지역변수용으로 할당받아야할 공간의 크기가 이미 완벽하게 결정되어있고,이건 메서드실행중에 절대 변하지않음(정확히는 슬롯갯수)
	만약 스레드가 요청한 스택깊이가 가상머신이 허용하는 깊이보다 크면 스택오버플로우를 던지고,
	스택용량을 동적으로 확장할수있는 가상머신에서 여유메모리가 모자라면 oom(아웃오브메모리)을 던짐
	
	네이티브메서드스택은 가상머신스택과 매우 비슷한데,차이는 그냥 네이티브메서드용이라는거뿐임
	네이티브메서드는 자바쪽에서 아무 규칙이 없고,알아서 자유롭게 표현할수있음,이거도 스택오버플로우와 oom은 가상머신스택과 똑같은 이유로 던짐
	
	
	자바 힙은 어플리케이션이 사용할수있는 가장 큰 메모리이고,이건 모든스레드가 공유하고 가상머신이 구동될때 만들어짐
	이 힙의 목적은 객체인스턴스를 저장하는것이고,자바의 거의 모든 객체인스턴스가 이 영역에 할당됨
	이 힙은 gc(가비지컬렉터)가 관리하는영역임
	또한 메모리 할당관점에서 힙은 모든 스레드가 공유하고,이때 객체할당효과를 높이고자 스레드로컬할당버퍼 여러개로 나뉨
	즉 힙안에서 공간을 나눠서 각 스레드용으로 배분하는거,이떄도 스레드로컬에는 객체인스턴스만 저장할수있음
	
	힙은 물리적으로 떨어진 메모리에 위치해도 되지만,논리적으로는 연속되어야함(디스크와 같음)
	또한 힙은 크기를 고정할수도,확장할수도 있고 요즘엔 거의 확장가능함(-Xmx와 -Xms로 범위지정)
	또한 새 인스턴스에 할당할 힙공간이 부족한데 힙확장이 불가능하면 oom을 던짐
	
	메서드영역도 자바힙처럼 모든 스레드가 공유함
	논리적으로는 힙의 한부분이지만 힙과 구분하기위해 논힙이라고 부르기도함
	보통 메서드영역에 들어온 데이터는 거의 gc되지않음(보통 상수나 타입만 gc되는데 타입은 조건도 까다로움)
	
	런타임상수풀은 메서드영역의 일부로,여긴 컴파일타임에 생성된 다양한 리터럴과 심벌참조가 저장됨
	가상머신이 클래스를 로드할때 이런 정보를 메서드영역의 런타임상수풀에 저장함
	또한 클래스파일의 상수풀과 다른점은,동적이라는점임
	자바에선 상수가 반드시 컴파일타임에 생성되어야하지않음,그래서 런타임에서도 새 상수가 추가될수있음
	
	다이렉트메모리는 가상머신런타임에 속하지않지만,자주쓰이는 메모리이고 oom의 원인이 될수있음
	이건 물리메모리를 직접 할당해서 자바힙의 크기제약과 무관하지만,어짜피 램이라서 물리램의 크기를 넘어설순없음
	그래서 가상머신의 램만 생각하지말고 이거까지 생각해서 메모리한계를 잡아야함
	
	
	자바에서 new를 쓰면 객체가 생성됨,이때 가상머신이 new를 만나면 이게 상수풀안의 클래스를 가리키는 심벌참조인지를 확인하고,
	심벌참조가 뜻하는 클래스가 로딩,해석,초기화되었는지를 확인함
	만약 준비되지않은 클래스면 준비부터하고,준비가 끝난 클래스라면 새 객체를 담을 메모리를 할당함
	이때 필요한 메모리크기는 클래스를 로딩하면 알수있음,즉 객체용 메모리공간할당은 자바힙에서 특정크기의 메모리블록을 잘라주는일임
	
	자바힙이 완전히 규칙적이면 그냥 마지막에 넣은뒤에 포인터만 밀쳐내면되겠지만,규칙적이지않기떄문에 가용메모리블록을 따로 목록으로 관리하며,
	객체인스턴스를 담기에 충분한 공간을 찾아 할당한후 목록을 갱신함,이 할당목록을 여유목록이라고함
	이 두가지방식중 상황에따라 방식을 선택함
	이때 동시에 두스레드에서 할당을 요청해서 충돌날수있기때문에 모든 객체생성은 원자적으로 수행하던지,각 스레드마다 영역을 정해놓고 해야함(이거도 설정할수있음)
	보통 스레드로컬방식으로 쓰다가 버퍼가 모자라지면 더 요청하는식으로 구현됨
	
	메모리할당이 끝났으면 가상머신은 해당공간을 0으로 초기화하고(그래서 자바에선 객체의 인스턴스필드를 초기화하지않아도되는거),
	가상머신은 각 객체에 필요한 설정을 해줌(어느클래스의 인스턴스인지,메타정보는 어떻게찾는지,해시코드는 무엇인지 등)
	이런 정보들은 객체헤더에 들어감
	이러면 가상머신은 할일이 끝났고,이제부터 프로그램의 영역임
	이제 생성자를 실행할수있고 필드들의 값을 채울수있음
	즉 이떄 init를 실행하고나면 객체가 완성됨
	
	객체는 세부분으로 나눠 힙에 저장되는데,객체헤더와 인스턴스데이터,정렬패딩임
	
	객체헤더는 객체자체의 런타임데이터(해시코드,gc세대나이,락상태플래그등)인 마크워드와,
	객체의 클래스관련 메타데이터(어떤클래스의 인스턴스인지)를 나타내는 클래스워드,
	추가적으로 배열일경우 배열길이도 객체헤더에 저장됨,이때 객체헤더에 저장되는 객체타입은 배열에 담긴 원소의 타입임,그래서 배열길이도 알아야 계산할수있음
	
	인스턴스데이터는 객체가 실제로 담고있는 정보임,즉 필드와 부모클래스유무,부모클래스필드등이 여기 기록됨
	
	정렬패딩은 그냥 가상머신은 8바이트정수배여야하기때문에 자리채우는용도
	
	
	객체들은 다른객체 여러개를 조합해 만들어짐,또한 자바프로그램은 스택에 있는 참조데이터를 통해 힙에 들어있는 객체들에 접근해 이를 조작함
	이때 방식은 핸들과 다이렉터포인터가 있음
	핸들은 별도의 풀을 만들어서 거기다가 조회를 치는방식이고,다이렉터포인터는 직접 해당메모리로 접근하는방식
	핸들은 한단계를 더 거쳐야하는대신 안정적이고,다이렉터포인터는 좀 불안정한대신 빠름
	
	
	oom이 나는 방법중에는
		객체를 계속 생성하는데 그 객체들에 접근할 경로가 살아있으면(gc작동못시키면)->이때는 java heap space라는 문구가 예외옆에 같이뜸
			이때 이걸 해결할때는 힙덤프를 떠서 오버플로를 일으킨객체를 찾고,그게 꼭 필요한객체인지를 확인해야함(누수인지 오버플로인지)
			필요없으면 해당객체부터 gc루트까지 참조사슬을 살펴보고,어떤게 남아있어서 못지웠는지를 확인한후 제거하면됨
			오버플로면 그냥 메모리늘려야하고
		스택오버플로우:메서드호출스택이 오버되었을때
		스레드를 너무 많이 만들었을때->스레드를 줄이던가 64비트쓰던가 각 스레드의 최대힙크기와 스택용량을 줄이던가
		메서드영역이 가득찼을때->cglib등으로 바이트코드를 직접 조작해서 클래스를 동적으로 생성할때 너무많이만들면 터짐,(jdk8부터는 발생힘듬)
			이땐 metaspace라는게 oom옆에뜸
		네이티브 다이렉트 메모리 오버플로->이경우엔 힙덤프파일에서 이상한점을 찾을수없음,이떄는 이거의심
	등이 있음

  2.가비지컬렉터와 메모리할당전략
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	