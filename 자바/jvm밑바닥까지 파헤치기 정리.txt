1.자바와 친해지기
	스킵
2.자동 메모리 관리
1.자바메모리영역과 메모리 오버플로
	자바 가상머신은 자바프로그램을 실행하는동안 메모리를 몇개의 영역으로 나눠서 관리하고,각 영역들은 목적과 생성삭제시점이 있음
	크게 가상머신과 생명주기를 같이하는애랑 스레드와 생명주기를 같이하는애로 나눠짐
	
	프로그램 카운터는 작은 메모리영역으로,현재 실행중인 스레드의 바이트코드 줄 번호 표시기임
	즉 GOTO같이 다음에 실행할 바이트코드명령의 위치를 가지는 작은 메모리영역임,그래서 스레드프라이빗함
	이건 모든 스레드가 각각 가지고있음(멀티스레딩이 cpu코어 하나를 번갈아가며 사용하는식이기때문)
	또한 스레드가 네이티브메서드(다른언어)를 실행중일때는 undefined가 뜸
	
	
	자바 가상머신스택도 프로그램카운터처럼 스레드프라이빗하고 생명주기가 스레드와 같음
	얘는 자바의 메서드가 호출될때마다 스택프레임을 만들어 지역변수테이블,피연산자 스택,동적링크,메서드반환값등 정보를 제공하고,
	이걸 프레임으로 만들어 가상머신스택에 푸시하고,메서드가 끝나면 팝함
	보통 자바의 메모리영역을 힙과 스택으로 구분하는경우가 많은데,
	실제로는 훨씬 복잡하지만 객체메모리할당과 가장 밀접하고 개발자들이 가장 신경써야하는 영역이 이 두개기때문
	보통 스택이라고 하면 이 자바 가상머신스택중에서도 지역변수테이블을 가리킬때가 많음
	
	지역변수테이블에는 자바 가상머신이 컴파일타임에 알수있는 기본데이터타입,객체참조,반환주소타입을 저장함
	이때 데이터타입을 저장하는공간을 지역변수슬롯이라고 하고,슬롯하나의 크기는 32비트임
	그래서 더블같은경우 2슬롯을 차지하고,나머지는 1슬롯을 차지함
	자바메서드는 스택프레임에서 지역변수용으로 할당받아야할 공간의 크기가 이미 완벽하게 결정되어있고,이건 메서드실행중에 절대 변하지않음(정확히는 슬롯갯수)
	만약 스레드가 요청한 스택깊이가 가상머신이 허용하는 깊이보다 크면 스택오버플로우를 던지고,
	스택용량을 동적으로 확장할수있는 가상머신에서 여유메모리가 모자라면 oom(아웃오브메모리)을 던짐
	
	네이티브메서드스택은 가상머신스택과 매우 비슷한데,차이는 그냥 네이티브메서드용이라는거뿐임
	네이티브메서드는 자바쪽에서 아무 규칙이 없고,알아서 자유롭게 표현할수있음,이거도 스택오버플로우와 oom은 가상머신스택과 똑같은 이유로 던짐
	
	
	자바 힙은 어플리케이션이 사용할수있는 가장 큰 메모리이고,이건 모든스레드가 공유하고 가상머신이 구동될때 만들어짐
	이 힙의 목적은 객체인스턴스를 저장하는것이고,자바의 거의 모든 객체인스턴스가 이 영역에 할당됨
	이 힙은 gc(가비지컬렉터)가 관리하는영역임
	또한 메모리 할당관점에서 힙은 모든 스레드가 공유하고,이때 객체할당효과를 높이고자 스레드로컬할당버퍼 여러개로 나뉨
	즉 힙안에서 공간을 나눠서 각 스레드용으로 배분하는거,이떄도 스레드로컬에는 객체인스턴스만 저장할수있음
	
	힙은 물리적으로 떨어진 메모리에 위치해도 되지만,논리적으로는 연속되어야함(디스크와 같음)
	또한 힙은 크기를 고정할수도,확장할수도 있고 요즘엔 거의 확장가능함(-Xmx와 -Xms로 범위지정)
	또한 새 인스턴스에 할당할 힙공간이 부족한데 힙확장이 불가능하면 oom을 던짐
	
	메서드영역도 자바힙처럼 모든 스레드가 공유함
	논리적으로는 힙의 한부분이지만 힙과 구분하기위해 논힙이라고 부르기도함
	보통 메서드영역에 들어온 데이터는 거의 gc되지않음(보통 상수나 타입만 gc되는데 타입은 조건도 까다로움)
	
	런타임상수풀은 메서드영역의 일부로,여긴 컴파일타임에 생성된 다양한 리터럴과 심벌참조가 저장됨
	가상머신이 클래스를 로드할때 이런 정보를 메서드영역의 런타임상수풀에 저장함
	또한 클래스파일의 상수풀과 다른점은,동적이라는점임
	자바에선 상수가 반드시 컴파일타임에 생성되어야하지않음,그래서 런타임에서도 새 상수가 추가될수있음
	
	다이렉트메모리는 가상머신런타임에 속하지않지만,자주쓰이는 메모리이고 oom의 원인이 될수있음
	이건 물리메모리를 직접 할당해서 자바힙의 크기제약과 무관하지만,어짜피 램이라서 물리램의 크기를 넘어설순없음
	그래서 가상머신의 램만 생각하지말고 이거까지 생각해서 메모리한계를 잡아야함
	
	
	자바에서 new를 쓰면 객체가 생성됨,이때 가상머신이 new를 만나면 이게 상수풀안의 클래스를 가리키는 심벌참조인지를 확인하고,
	심벌참조가 뜻하는 클래스가 로딩,해석,초기화되었는지를 확인함
	만약 준비되지않은 클래스면 준비부터하고,준비가 끝난 클래스라면 새 객체를 담을 메모리를 할당함
	이때 필요한 메모리크기는 클래스를 로딩하면 알수있음,즉 객체용 메모리공간할당은 자바힙에서 특정크기의 메모리블록을 잘라주는일임
	
	자바힙이 완전히 규칙적이면 그냥 마지막에 넣은뒤에 포인터만 밀쳐내면되겠지만,규칙적이지않기떄문에 가용메모리블록을 따로 목록으로 관리하며,
	객체인스턴스를 담기에 충분한 공간을 찾아 할당한후 목록을 갱신함,이 할당목록을 여유목록이라고함
	이 두가지방식중 상황에따라 방식을 선택함
	이때 동시에 두스레드에서 할당을 요청해서 충돌날수있기때문에 모든 객체생성은 원자적으로 수행하던지,각 스레드마다 영역을 정해놓고 해야함(이거도 설정할수있음)
	보통 스레드로컬방식으로 쓰다가 버퍼가 모자라지면 더 요청하는식으로 구현됨
	
	메모리할당이 끝났으면 가상머신은 해당공간을 0으로 초기화하고(그래서 자바에선 객체의 인스턴스필드를 초기화하지않아도되는거),
	가상머신은 각 객체에 필요한 설정을 해줌(어느클래스의 인스턴스인지,메타정보는 어떻게찾는지,해시코드는 무엇인지 등)
	이런 정보들은 객체헤더에 들어감
	이러면 가상머신은 할일이 끝났고,이제부터 프로그램의 영역임
	이제 생성자를 실행할수있고 필드들의 값을 채울수있음
	즉 이떄 init를 실행하고나면 객체가 완성됨
	
	객체는 세부분으로 나눠 힙에 저장되는데,객체헤더와 인스턴스데이터,정렬패딩임
	
	객체헤더는 객체자체의 런타임데이터(해시코드,gc세대나이,락상태플래그등)인 마크워드와,
	객체의 클래스관련 메타데이터(어떤클래스의 인스턴스인지)를 나타내는 클래스워드,
	추가적으로 배열일경우 배열길이도 객체헤더에 저장됨,이때 객체헤더에 저장되는 객체타입은 배열에 담긴 원소의 타입임,그래서 배열길이도 알아야 계산할수있음
	
	인스턴스데이터는 객체가 실제로 담고있는 정보임,즉 필드와 부모클래스유무,부모클래스필드등이 여기 기록됨
	
	정렬패딩은 그냥 가상머신은 8바이트정수배여야하기때문에 자리채우는용도
	
	
	객체들은 다른객체 여러개를 조합해 만들어짐,또한 자바프로그램은 스택에 있는 참조데이터를 통해 힙에 들어있는 객체들에 접근해 이를 조작함
	이때 방식은 핸들과 다이렉터포인터가 있음
	핸들은 별도의 풀을 만들어서 거기다가 조회를 치는방식이고,다이렉터포인터는 직접 해당메모리로 접근하는방식
	핸들은 한단계를 더 거쳐야하는대신 안정적이고,다이렉터포인터는 좀 불안정한대신 빠름
	
	
	oom이 나는 방법중에는
		객체를 계속 생성하는데 그 객체들에 접근할 경로가 살아있으면(gc작동못시키면)->이때는 java heap space라는 문구가 예외옆에 같이뜸
			이때 이걸 해결할때는 힙덤프를 떠서 오버플로를 일으킨객체를 찾고,그게 꼭 필요한객체인지를 확인해야함(누수인지 오버플로인지)
			필요없으면 해당객체부터 gc루트까지 참조사슬을 살펴보고,어떤게 남아있어서 못지웠는지를 확인한후 제거하면됨
			오버플로면 그냥 메모리늘려야하고
		스택오버플로우:메서드호출스택이 오버되었을때
		스레드를 너무 많이 만들었을때->스레드를 줄이던가 64비트쓰던가 각 스레드의 최대힙크기와 스택용량을 줄이던가
		메서드영역이 가득찼을때->cglib등으로 바이트코드를 직접 조작해서 클래스를 동적으로 생성할때 너무많이만들면 터짐,(jdk8부터는 발생힘듬)
			이땐 metaspace라는게 oom옆에뜸
		네이티브 다이렉트 메모리 오버플로->이경우엔 힙덤프파일에서 이상한점을 찾을수없음,이떄는 이거의심
	등이 있음

2.가비지컬렉터와 메모리할당전략
  1.대상이 죽었는가?
	자바에서는 거의 모든 객체인스턴스가 힙에 저장되고,여기서 가비지컬렉터가 청소할땐 어떤객체가 살아있고 어떤객체가 죽었는지를 판단해야함
	이때 제일 일반적인게 참조카운팅임(자바에서는 이렇게 바로사용하진않음)
	참조카운팅은 참조갯수를 세는건데,문제는 순환참조일경우 영원히 제거할수없다는 문제가 있음
	
	그래서 사용하는게 도달가능성 분석 알고리즘임
	이건 루트객체를 잡고,여기서부터 참조하는 다른객체들로 탐색해나가면서 접근가능한애들만 살리고,접근못한애들은 죽이는거임
	여기서 루트객체로 사용할수있는애들은
		스택에서 참조하는객체:현재 실행중인 메서드에서 쓰는 매개변수,지역변수,임시변수등
		메서드영역에서 정적필드로 참조하는 객체:클래스의 참조타입 정적변수
		메서드영역에서 상수로 참조되는 객체:문자열테이블 안의 참조
		네이티브메서드스택에서 네이티브메서드가 참조하는 객체
		가상머신내부에서 쓰이는참조(보통 예외)
		동기화락으로 잠겨있는객체
	등이 있음
	또한 메모리영역들은 완전히 격리되어있지않기때문에 연관된 영역의 객체들도 gc루트집합에 포함시켜야 도달가능성을 정확히 분석할수있음
	
	참조는 객체생사판단에서 제일 중요한거임,이때 그냥 참조갯수만 세면 버리기아까운객체들도 다 버려지니(캐시),4가지로 구분함
		강한참조:일반적인 참조,new로 참조를 할당하는걸 말함,절대 회수되지않음
		부드러운참조:유용하지만 필수는 아닌객체,메모리오버플로 직전에 회수함
		약한참조:부드러운참조보다 약함,다음 gc까지만 살아있음(메모리랑 상관없이 다음번에 회수됨)
		유령참조:그냥 객체 삭제될때 알림받기위한용도의 참조
	가 있음
	
	도달불가능한 객체라고 즉시 죽진않음,죽을객체들은 gc를 거쳐서 2번까지 마킹을 받아야 죽을수있음
	
	메서드영역도 gc의 대상이 될수있음(필수구현은 아님),여기가 필수가 아닌이유는 효율이 낮기때문임(힙은 한번에 85퍼 회수하는데 여긴 별로못함)
	여기서는 크게 2가지를 회수하는데,상수와 클래스임
	상수는 객체와 거의똑같음,해당 상수를 사용하는곳이 없다면 제거함
	클래스는 좀 까다로움
		이 클래스의 인스턴스가 힙에 하나도 존재하지않음
		클래스를 읽어들인 클래스로더가 회수되었음
		이 클래스에 해당하는 java.lang.class객체를 아무곳에서도 참조하지않고 리플렉션으로 사용하지도않음
	이 3개를 다 만족해야함
	cglib같이 동적프록시같은걸 바이트코드로 구현하는 프레임워크를 쓴다면,이게 구현되는 가상머신을 사용해야함

  2.가비지 컬렉션 알고리즘
	가비지컬렉션 알고리즘의 핵심은 세대단위 컬렉션임
	이건
		대다수 객체는 일찍 죽고
		오래살아남으면 다음번에도 살아남을확률이 높음
		세대간 참조는 횟수가 훨씬적음
	1번2번을 합쳐서,
		힙을 몇개의 공간으로 나누고
		모든객체를 1번(신세대)부터 둔다음
		gc에서 살아남으면 2번(구세대)으로 옮기고
		1번구역을 0으로 리셋
	이런식으로 하는거임
	이때 객체들이 서로 다른 영역에 있는걸 참조하는경우가 매우 적으니,구세대를 의존한다고 해도 어짜피 같은땅으로 갈거니까 구세대 참조까진 확인하지않는것
	이렇게 기본적으로는 신세대만 gc를 하다가,한 5번 10번하면 구세대까지 싹 합쳐서 한번 gc를 돌리고 이걸 반복하는거임
	
	이때 살아남을(혹은 죽을)객체를 어떻게 표시할거냐에 따라 알고리즘이 나뉨
	일단 제일오래된건 별생각없이 지울거만 표시하고 지우는거고(메모리파편화가 심해서 안씀),
	신세대내에서도 공간을 나눠서,살아남은애들을 복사하거나 옮기고 이전땅을 싹 밀어버리는거임(블루그린같은느낌)
	이때 반으로나눌필요는 없고,대충 10퍼만 남겨도됨,어짜피 살아남을애는 2퍼센트정도밖에 안됨
	그래서 메인공간(에덴)1,생존자공간2를 8:1:1로 구성해서 사용함,
	그리고 생존자공간1개와 메인공간에만 객체들을 두다가,gc가 일어나면 살아남은객체들은 남은 생존자공간으로 복사하고 나머지를 다 비워버리는거임
	또한 10퍼센트이상 살아남았을경우(엣지케이스),그냥 구세대로 승격시켜버림
	
	이때 객체를 이동시킬지(객체를 이동시키고 참조를 갱신),그냥 둘지는 트레이드오프임(파편화된공간과 객체이동,참조갱신비용)
	객체를 이동시키면 회수작업이 복잡해지고,하지않으면 할당작업이 복잡해짐
	또한 객체를 이동시킬땐 프로그램이 잠시 멈춰야함(참조 갱신해야하니까)
	그래서 일반적으로는 파편화를 감내하면서 이동시키지않다가,너무 심해지면 한번 이동시키고 밀어버리는방식을 사용함

  3.핫스팟 알고리즘 상세 구현
	루트노드열거는 도달가능성분석 알고리즘에서,gc루트집합으로부터 참조체인을 찾는 작업임
	기본적으로는 루트노드열거시에는 참조가 변하면 안되니 프로그램이 멈춰야함(요즘거는 안그럼),일관성유지가 되어야하기때문
	그래서 이걸 피하기위해 OopMap이라는걸 사용하는데,이건 클래스로딩이 완료되면 객체에 포함된 각 데이터타입을 확인하고,
	컴파일과정에서 스택의 어느위치와 어느레지스터의 데이터가 참조인지를 기록함
	이런식으로 gc루트로부터 추적하지않고 스캔과정에서 이 정보를 직접 얻어내는식으로 우회함
	문제는 이렇게하면 참조관계나 OopMap의 내용을 변경할수있는 명령어 모두에 OopMap를 만들어넣어야하는데,그러면 메모리사용량이 감당안됨
	
	그래서 안전지점이라고 하는 특정한 위치에만 기록함
	gc는 사용자프로그램이 안전지점에 도달할때까지는 절대 멈춰세우지않음
	이때 안전지점의 위치를 선택할떈,프로그램이 장시간 실행될 가능성이 있냐가 제일 중요함
	또한 안전지점에서 멈출때는,
	각 스레드가 실행중에 안전지점플래그를 계속 풀링하다가 true면 가장 가까운 안전지점에서 멈추고,이걸 전스레드가 끝내면 gc돌리는거임
	
	안전지점은 객체생성등 힙메모리를 소비하는장소에서도 추가됨
	문제는 락이걸린 스레드들임,얘들은 안전지점에 도착할수없음,그래서 안전지역이라는게 필요함
	스레드들은 안전지역의 코드를 실행하기전에 안전지역이라는 플래그를 표시함,그러면 안전지점에 도착했다고 치는거
	또한 안전지역을 벗어날때는 가상머신이 루트노드열거를 완료했는지,사용자스레드를 일시정지시켜야하는 다른 gc단계를 완료했는지를 확인하고 진행함
	
	기억집합과 카드테이블은 스킵(필요해지면 보는데 필요없을거같음)
	
	루트노드열거가 끝나면 gc루트로부터 객체그래프를 탐색할수있고,이때의 일시정지시간은 힙크기에 비례함
	이때 스냅숏을 사용해서 객체그래프를 탐색하는식으로 일시정지문제를 해결할수있음
	이떄는
		방문하지않은객체(흰색)
		방문했지만 스캔이 끝나지않은객체(회색)
		방문했고 확실히 살아남을객체(검은색)
	3개로 나눌수있음,gc가 끝날때까지 흰색이면 삭제되고 검은색이면 살아남음
	이때 스냅숏을 사용하지않고,일시정지를 하지않으면 중간에 막 참조가 바뀌면서 개판될수있음(살아있는객체를 죽었다고 표시할수있음)
	그래서 객체그래프를 탐색할시간에 일어난일들을 따로 기록한다음,해당부분만 다시 스캔하거나 하는식으로 회피할수있음
	
  4.클래식 가비지 컬렉터
	예전 가비지컬렉터들은 신세대와 구세대용이 따로있었음
	가장 처음나온건 시리얼컬렉터인데,이건 단일스레드로 동작함,그래서 gc가 시작되면 회수가 끝날때까지 모든 작업스레드들이 멈춰야함
	최신으로 와도 이 일시정지시간을 줄일수는 있어도,완전히 없애지는 못하고있음
	
	시리얼컬렉터는 요즘도 사용하는데,요즘은 이게 메모리사용량이 적다는 이점때문에,단일코어프로세서나 코어수가 적은환경에서 회수효율을 올릴때 사용됨
	
	파뉴컬렉터는 시리얼컬렉터의 병렬버전임,스레드회수에 멀티스레드를 사용한다는거만 빼면 시리얼컬렉터와 같음

	ps컬렉터는 신세대용 컬렉터임,이건 일시정지시간을 줄이는걸 포기하고,처리량을 제어하는걸 목표로 뒀음
	즉 일단 멈추는걸 상수로 둔다음,그안에서 최대한 효율적으로 처리하는게 목표인거임,그래서 사용자프로그램보단 분석업무등에 효율적임
	
	cms컬렉터는 동시성을 지원한 최초의 컬렉터임,이건 gc스레드와 사용자스레드가 동시에 실행된다는걸 처음 실현해냈음
	이건
		최초표시
		동시표시
		재표시
		동시쓸기
	순으로 수행되고,여기서 최초표시와 재표시는 여전히 스톱더월드(시간멈춤)이 일어남,
	단 최초표시는 gc루트와 직접연결된거만 표시해서 매우빠르게끝나고,
	동시표시는 오래걸리지만 사용자스레드와 같이 실행될수있음
	재표시는 잠시 멈추고 동시표시중에 변경된 참조들만 다시 체크함(이때 시간멈추고 처리),이때 최초표시보다는 좀 길지만 매우빠르게끝남
	동시쓸기는 표시된거 지움
	즉 가장 긴 동시표시와 동시쓸기를 동시처리가 가능하게 한게 핵심임
	이거의 단점은
		프로세서자윈에 매우 민감함(동시성이라)
		부유쓰레기(표시스레드가 지나간후 쓰레기가 된 객체)를 처리하지못함,또한 이게 많아지면 스톱더월드키고 다시 밀어야할수있음(처리량보다 쌓이는게빠를때)
		마크스웜방식이라 파편화가 심함,그래서 가끔 전체gc를 수행할때 조각모음도 같이 수행함
	이건 한참 잘쓰다가 더 나은게 나와서 요즘은 사용하지않음
		
	g1컬렉터는 가비지우선컬렉터임,이건 부분회수라는 아이디어를 바탕으로,힙을 여러영역으로 나눠서(리전),한번에 하나씩만 처리하는거임
	즉 사용자스레드가 쓰레기를 버리는것과,gc가 쓰레기를 치우는걸 동시에 하는거임,
	이걸 함으로써 가비지컬렉터가 쓰는시간을 완전히 제어할수있음(힙을 얼마나 크게나누냐니까)
	즉 세대구분없이,어디에 쓰레기가 가장 많냐+회수이득이 어디가 가장 크냐를 기준으로 회수영역을 고르는거임
	그러면 신세대쪽에서 주로 돌아가다가,구세대쪽이 많이쌓이면 한번 치워주고 이런식으로 동작하는거
	물론 쉽진않고,신경쓸게 좀 많이있긴했음
	g1의 동작방식은
		최초표시:gc루트의 직접참조객체들을 표시하는등 시작단계스냅숏을 생성함,이땐 일시정지해야하지만 마이너gc할때 같이돌려서 시간정지는 없다싶이함
		동시표시:gc루트부터 시작해서 객체들의 도달가능성을 분석하고,전체힙의 객체그래프를 재귀스캔해서 회수할 객체를 찾음,이건 동시실행가능함
			또한 끝난후엔 시작단계스냅숏과 비교해서 실행도중 변경된애들을 다시 스캔해야함
		재표시:변경이 있었던애들만 다시 체크함,일시정지해야하지만 몇개안돼서 매우빠름
		복사 및 청소:데이터를 기초로 리전들을 회수가치와 비용에따라 줄세운다음,가장 효율좋은거만 시간안에 처리할 계획을 짜고,
			살아남은애들을 빈곳에 옮겨두고 밀어버림
	즉 g1의 핵심은 지연시간을 제어하면서 처리량을 최대한 올리는게 목표임
	근데 지연시간을 너무 짧게주면,쌓이는게 버리는거보다 빨라서 전체gc가 일어남,그래서 기본값인 200으로 잡는게 좋음
	
	
	이 가비지컬렉터중에 요즘도 쓰는건 시리얼과 ps(패러렐),g1정도임,요즘거로는 zgc와 셰넌도어정도가 있음
	또한 신세대와 구세대구분이 사라져서 걍 하나만 씀 요즘은
	그리고 zgc와 셰넌도어는 지연시간최소화를 목표로하는 최첨단컬렉터들임

  5.저지연 가비지컬렉터
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	