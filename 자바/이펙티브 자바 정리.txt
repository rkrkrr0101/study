1.들어가기
	스킵
2.객체 생성과 파괴
	1.생성자대신 정적팩터리메서드를 고려하라
		퍼블릭생성자대신,정적팩터리메서드를 사용해서 생성자에 이름을 붙이고,하나의 매개인수조합으로 여러종류의 생성자를 만들수있음
		그리고 호출될때마다 인스턴스를 새로생성하는게 아닌,싱글톤같은식으로 만들수있음(플라이웨이트패턴같은느낌)
		가장큰 장점으로,반환타입의 하위반환타입을 반환할수있게됨,그래서 구현클래스를 퍼블릭으로 안만들어도 되게됨		
		자바8이후엔 인터페이스에 정적메서드를 선언할수있어져서 이게 편해졌음
		그래서 입력매개변수에 따라 다른하위구현클래스를 리턴할수있어짐
		그리고 정적팩터리메서드를 작성하는시점에는 반환할객체의 클래스가 존재하지않아도됨
		
		정적팩터리메서드의 단점은,상속을 하려면 퍼블릭이나 프로텍티드생성자가 필요하니,이거만 있으면 하위클래스를 만들수없음
		이경우엔 합성을 사용하는게 좋음
		또한,프로그래머가 정적팩터리메서드를 찾기힘듬(생성자처럼 반드시있어야하는게 아니니)
		그래서 관례에 따라 이름짓는거로 어케하는데 완전히 대체되는건아님
		
	2.생성자에 매개변수가 많다면 빌더를 고려하라
		이건 코틀린에선 사용하지않던 방식인데,자바에서는 매개변수의 디폴트값이 없기때문에,미리 메서드에 빌더패턴메서드를 넣어두고 빌드하는식으로 자주사용함
		이러면 디폴트값을 사용할수있고,해당 값에 이름을 붙일수있어서 확인이 쉬워짐(순서헷갈릴일도 없고)
		이런 빌더패턴은 계층적으로 설계된 클래스와 함께쓰기가 좋음
		
		보통 매개변수가 많을때 생성자나 정적팩토리대신 빌더를 사용하면 효과적임
		
	3.private나 enum으로 싱글톤임을 보장하라
		싱글톤은 클라입장에서 테스트하기가 어려워짐(인터페이스를 구현하지않은경우)
		싱글톤을 만들땐,생성자를 프라이빗으로 감춰두고,유일하게 접근할수있는 스태틱멤버를 하나 만들어두고,거기에 주소값을 넘겨주는방식으로 사용함
		이때,퍼블릭필드가 아닌 이넘타입의 싱글톤을 사용하는걸로 리플렉션이나 제2의 인스턴스가 생기는걸 막을수있음
		단 해당 싱글톤이 enum이외의 클래스를 사용해야하면 이건사용할수없음(이중상속안되니까,물론 인터페이스구현은 됨)
		
	4.인스턴스화를 막으려면 private를 사용해라
		단순히 정적메서드와 정적필드만 담긴 클래스는 별로 좋진않지만,만들어야할때가 있음
		이때는 생성자를 막아서 생성이 안되게하는게 좋음(추상클래스만으로는 하위를 구현하면돼서 막지못함)
		추가적으로 이러면 상속도 막을수있어서 좋음
		
	5.자원을 직접 명시하지말고 의존객체주입을 사용하라
		자원을 직접 생성하지말고,인터페이스로 변수만 생성하고,생성자를 통해 di받으면 훨씬 더 유연하게 사용할수있음
		이러면 유연성과 테스트가 편해짐
		이방식의 변형으로,생성자에 자원팩토리를 넘겨주는방식이 있음(팩토리메서드패턴)
		이런건 스프링쓰면 편해게해줌
		
	6.불필요한 객체생성을 피하라
		같은 객체를 여러번 만드는건 효율적이지않음,물론 이건 객체생성비용이 비쌀때의 이야기지(db커넥션같은),쌀땐 걍 가독성만 중심으로 쓰면됨
		일반적으로 재사용해서 문제가 생길확률이,객체생성 더해서 문제생길확률보다 훨씬 크니 알아만두자
		
	7.다 쓴 객체 참조를 해제하라
		가비지컬렉터도 사용하진않는데 내부에서 참조는 가지고있는애들을 지우진 못함
		그래서 모든것들의 스코프를 최소한으로 잡아서,끝나면 바로 리프레시되게 만드는게 좋고,만약 그럴수없다면 해당참조를 다썼을때 null처리하면됨
		이렇게 null처리하는건 예외적인거여야하고,일반적으론 스코프를 최대한 좁게잡아서 그냥 해당영역이 끝나게하는게 젤 좋음
		보통 메모리누수가 생기는건,자기메모리를 직접 관리하는 클래스나,캐시를 사용하는경우,리스너나 콜백을 사용할경우 그럴수있음
		캐시나 콜백같은경우,weakHashMap같은걸 사용해서 약한참조를 걸어버리는 방법이 주로 사용됨(자리없으면 우선적으로 날려버림)
		
	8.finalizer나 cleaner의 사용을 피해라
		난 있다는거도 첨알았음,어짜피 안쓰니까 넘어가자
		
	9.try-finally보단 try-with-resources를 사용하자
		리소스열고 닫을때는,try-with-resources가 try-finally보다 더 깔끔하게 나옴
		이건 해당클래스가 autoCloseable이 구현되어있으면,자동으로 끝나고 리소스를 닫아줌
	
3.모든 객체의 공통 메서드	
	1.equals는 규약을 지켜 재정의하라
		이퀄은 기본적으로는 같은객체인지를 비교하는데,이걸 논리적동치성(필드값이 같은)으로 매핑해야할때가 있음
		이떈 equals을 재정의해야함
		보통 값클래스에서 재정의하는경우가 많음,그리고 값클래스라도 싱글톤일경우엔 할필요가 없음,어짜피 같은거니까
		
		이 이퀄은
			널이 아닐때 널과비교하면 false             널아님
			자기자신과 비교하면 항상 true              반사성
			x,y가 true면 y,x도 true여야함          대칭성
			x,y,z중 x,y가 T y,z가 T면 x,z도 T여야함  추이성
			변경이 없을때 백만번돌려도 값이 다 똑같아야함     일관성
		이라는 조건을 만족해야함
		특히 x,y가 true고 y,x가 true여야한다는건,만약 클래스 2개이상을 비교해야할경우엔,반대편에도 똑같이 작업해줘야한다는것(대칭성)
		그리고 상위클래스에 없는 새로운필드를 하위클래스에 추가했을때,상위클래스와 하위클래스를 비교할때 추이성이 깨지기쉬움
		구체클래스를 확장해서 새값을 추가하며,equals을 만족시킬방법은 없음
		그래서 이런경우 상속대신 합성을 사용해야함
		
		equals을 만들때 구현방법의 순서는
			1.==를 사용해 입력이 자기자신의 참조인지 확인
			2.instanceof로 입력이 올바른타입인지 확인
			3.입력을 올바른타입으로 형변환,instanceof를 썼으니 이건 100%성공함
			4.입력객체와 자기자신의 대응되는 핵심필드가 모두 일치하는지 하나하나체크
		이렇게 구현하면됨
		그리고 마지막에 비교할때,비교가격이 싼거부터 하는게 빨리false치고 나갈수있어서 좋음
		
		그리고 equals을 구현할때,가능하면 간단하게 해결하는게 좋음,별칭같은건 걍 잘라버리는게나음
		그리고 입력타입은 반드시 object로 둬야함(안그러면 오버로딩되버림)
		
		그리고 이런 equals을 자동으로 만들어주는 프레임워크들이 있으니,그거쓰는거도 좋음(autoValue같은)
		그리고 꼭필요한경우가 아니면 재정의안하는게 좋음
		
	2.equals을 재정의했으면 hashCode도 재정의하라
		이건 반드시 해야함,안그러면 해시를 사용하는 모든곳에서 문제가 생김
		해시코드메서드는 equals을 사용하기때문
		equals로 true가 나왔으면 같은 해시값이 나와야하는데 이게 안되기때문
		그리고 두 객체가 false라면,서로 다른값을 리턴해야함,무조건 다 달라야하는건 아니긴한데 그게 더 성능에좋음
		
		이건
			equals에서 비교한 모든 필드 각각에 대해,type.hashCode(field명)으로 해시코드를 뽑아두고(참조타입이면 책참조)
			result=31*result+현재필드해시값를 반복해서 모든핵심필드에 돌리고,값을뽑아서 리턴
		그러고나서 단위테스트만들어서 돌리면됨
		그리고 이때,equals비교에서 사용하지않은필드는 반드시 빼야함
		
		그리고 해시코드를 뽑는방법을 클라쪽에 공개하면안됨,그러면 의존성생기면 나중에 머리아파짐
	
	3.toString을 항상 재정의하라
		toString은 거의 쓸모없는값을 리턴해줌
		그래서 그 클래스를 표현할수있는 값으로 리턴하면 삶의질이 달라짐
		이때 toString은 그 객체가 가진 주요정보 모두를 반환하는게 좋고,만약 너무크거나 문자열로쓰기 뭐하면,요약정보를 담아야함
	
	4.clone재정의는 주의해서 진행하라
		clone의 규약은 허술해서,깨지기쉬우니 가급적 재정의하지말고 안쓰는게좋음
		그냥 생성자써서 새로만드는게 나음
		보통 복사생성자나 복사팩토리를 사용해서 복사하는게 나음(자기클래스를 매개변수로 받는 생성자)
	
	5.comparable를 구현할지 고려해라
		이건 equals에서 순서까지 비교하는 메서드인 compareTo를 가진 인터페이스임
		즉 이걸 구현하면,그 클래스의 인스턴스에는 순서가 있음을 뜻하고,이걸통해 정렬을 쉽게할수있음
		
		순서가 있는,알파벳,숫자,연대같이 순서가 명확한 값클래스를 작성하면 comparable를 구현하는게 좋음
		이거의 조건의 equals과 거의 똑같은데
		타입이 다른객체가 주어지면 예외를 던지면되고,
		compareTo로 수행한 동치성테스트의 결과가,equals과 같아야함
	
	
4.클래스와 인터페이스
	1.클래스와 멤버의 접근권한을 최소화하라
		클래스가 외부로부터 최소한의 정보만 노출되는 컴포넌트가 잘 설계된 컴포넌트임
		그래서 구현과 api를 깔끔하게 분리하고,api를 통해서만 다른 컴포넌트와 소통하며 서로의 내부동작방식에는 전혀 영향을 안줘야함
		이런 정보은닉을 하면,개발속도가 올라가고,관리비용이 줄고,성능최적화를 하기가 쉬워지고,재사용성과 큰시스템을 만들때도 난이도가 낮아짐
		
		자바에서 정보은닉을 할땐,접근자를 통해서 주로 하게되는데,이때 기본원칙은 모든 클래스와 멤버의 접근성을 가능한 좁히는것
		즉 소프트웨어가 동작하는 가장 낮은 접근수준을 부여해야한다는것
		
		톱레벨에서도 패키지외부에서 사용할일이 없으면 패키지프라이빗으로 두고,한클래스에서만 사용하는 패키지프라이빗은 중첩클래스로 만들고(프라이빗 스태틱)
		멤버들은,일단 먼저 공개api(인터페이스)를 먼저 만들고 나서,나머지는 모두 프라이빗으로 만들면됨
		퍼블릭과 프로텍티드는 외부에 공개되면,계속 유지보수를 해줘야하니까 부담이 엄청나게 커지니,프로텍티드는 최대한 줄이는게좋음
		근데 리스코프치환원칙에 의해 하위클래스는 상위클래스보다 접근수준을 줄일수없음(인터페이스를 구현할때)
		이떄는 예외로 보면됨
		
		코드를 테스트하려는 목적으로 접근범위를 넓혀야할땐,적당한 범위까지는 넓혀도됨,단 이건 프라이빗을 패키지프라이빗정도로 여는거까지만 허용
		패키지프라이빗에서 프로텍티드가 되는건 부담이 너무커지니까 불가능함,즉 테스트만을 위해 클래스,인터페이스,멤버를 공개api로 만들면 안됨
	
		퍼블릭클래스의 인스턴스필드는 최대한 퍼블릭이 아니어야함,퍼블릭이되면 내부에 값을 제한하기가 어려워지고,
		필드값이 수정될때 다른작업을 할수없어져서 스레드안전하지않음
		단,정적필드중 해당 클래스가 표현하는 추상개념을 완성하는데 꼭 필요한 상수는 퍼블릭스태틱파이널로 공개할수있음
		이때도 배열의경우는 변경이 가능하니 공개하면안됨,불변리스트를 사용해야함(아니면 프라이빗으로 만들고 복사본을 던져주던가)
	
	2.퍼블릭 클래스에서는 퍼블릭필드가 아닌 접근자메서드를 사용하라
		퍼블릭 필드는 진짜 어지간하면 사용하면안되고,게터세터를 사용해야함
		그래도 프라이빗중첩클래스같은경우엔 괜찮긴함,dto나
		
	3.변경가능성을 최소화하라
		불변클래스는 설계,구현,사용이 쉽고 오류가 생길 여지도 적고 훨씬 안전함
		이때 따라야하는건
			객체의 상태를 변경하는 메서드를 제공하지않는다
			클래스를 확장할수 없도록 한다
			모든필드를 파이널로 선언한다
			모든필드를 프라이빗으로 선언한다
			자신외에는 내부의 가변컴포넌트에 접근할수없어야함
		이걸 따르면 값이 바뀌지않고,항상 순수함수적으로 동작하게됨,이러면 스레드안전하고,공유를 맘놓고해도됨,실패도 원자성을 제공하게됨
		불변클래스의 단점은,값이 달라지면 반드시 독립된 객체로 만들어야하니,메모리적으로 봤을때는 좀 손해볼수있음
		보통 객체를 완성하는 단계가 많고,중간과정마다 객체를 만들고 버리고 해야할경우 이런문제가 좀 커짐
		그래서 스트림같은데서도 시퀸스를 사용하는거고
		
		그리고 불변클래스는,자신을 상속하지 못하게 해야하는데,이때 가장쉬운방법은 final을 사용하는거고,두번째는 생성자를 프라이빗으로 만들고,
		정적팩토리를 제공하는방법이 있음
		
	4.상속보단 합성을 사용해라
		상속은 서브타이핑용도(인터페이스에서 여러 타입들이 구현되는)로만 사용해야하고,서브클래싱이 필요할경우엔 합성을 사용해야함
		상속은 캡슐화를 깨트리기때문에 머리아파짐(상위클래스의 변경에 하위클래스들이 전부 영향을받음)
		그래서 사용되는게 합성임
		즉 확장이 필요할때,새로운클래스를 만들고,기존클래스의 인스턴스를 프라이빗필드에 넣어,해당 필드에서 메서드를 부르는거임
		이러면 새클래스는 기존클래스의 내부구현방식의 영향에서 벗어나고,기존클래스에 새 메서드가 추가되더라도 전혀 영향을 받지 않음
		
		이건 래퍼클래스를 만들때,즉 데코레이터 패턴을 사용할때 잘 사용됨,보통 합성과 전달을 조합해서 위임이라고 부름
		
		상속은 반드시 하위클래스가 상위클래스의 진짜 하위타입인 경우에만 상속을 해야함
		
	5.상속을 고려해 설계하고 문서화하라,그러지않았다면 상속을 금지하라
		상속용 클래스는,재정의가능한 메서드들을 내부적으로 어떻게 이용하는지,즉 구현을 문서로 남겨야함
		이건 상속이 캡슐화를 깨기때문에 어쩔수없는문제임
		상속용클래스를 시험하는방법은,직접 하위클래스를 만들어보는게 유일한 방법임,그래서 빈자리를 찾을수있음(보통 3개정도 만들어보면된대)
		그리고 상속용클래스의 생성자는,직접적이든 간접적이든 재정의가능메서드를 호출하면 안됨(프라이빗,파이널,스태틱메서드만 호출가능)
		이러면 상속받은애쪽에서 이상하게동작해버림
		
		그래서 상속용으로 설계하지않은 클래스는 그냥 상속을 금지하는게 젤 속편함(파이널로 설정하거나,생성자를 프라이빗으로)
		
	6.추상클래스보단 인터페이스를 우선하라
		추상클래스나 인터페이스나 둘다 디폴트메서드를 사용할수있어져서 인스턴스메서드를 구현형태로 제공할수있어졌음
		근데 추상클래스는 반드시 구현하는 클래스가 하위클래스여야해서,제약이 생기는데,인터페이스는 다중상속이 가능함
		그래서 어지간하면 인터페이스를 사용하는게 나음
		
		인터페이스와 추상골격구현클래스를 같이 제공하는식으로 둘의 장점을 모두 가져가는 방법도 있음
		인터페이스로는 타입을 정의하고,필요하면 디폴트메서드몇개도 넣어두고,골격추상클래스는 나머지도 구현하고,핵심부분만 추상메서드로 남겨두는식
		즉 템플릿메서드패턴임
		
	7.인터페이스는 구현하는쪽을 생각해 설계하라
		디폴트메서드를 사용하면,인터페이스에 새로운 메서드를 추가하는게 편해짐,단 이러면 구현클래스에 대한 정보는 전혀없이 추가하는거라,
		기존구현체에 런타임에러를 일으킬수있음(흔하진않음)
		즉,디폴트메서드를 너무믿지말고,인터페이스를설계할땐 세심하게 만들어야함
		
	8.인터페이스는 타입을 정의하는 용도로만 사용하라
		상수인터페이스같은,상수가 들어있고 상수를 받아오기위한 용도로만 사용되는 인터페이스같은건 사용하면안됨
		이건 인터페이스의 영역이 아니라 내부구현의 영역임
		이런건 유틸클래스나,이넘타입의 클래스등으로 공개하는게 맞음
		
	9.태그달린클래스보단 클래스계층구조를 활용하라
		클래스에 이넘이나 TF등으로 태그값이 있는건 매우안좋음
		이경우엔 상속이나 합성등으로 별도의 클래스로 분할하는게 좋음
		즉 이경우엔 서브타이핑을 사용하자
		이땐
			해당 클래스를 포함할 추상클래스를 정의하고
			태그값에 따라 동작이 달라지는 메서드들을 추상메서드로선언
			태그랑 상관없이 동작이 똑같은애들은 추상클래스에서 구현
		이방법으로 계층구조로 변경할수있음
		
	10.멤버클래스는 되도록 static으로 만들라
		중첩클래스는 자신을 감싼 바깥클래스에서만 사용되어야하고,그 외부에서 사용할일이 있으면 별도의 클래스로 분할되어야함
		보통 정적멤버클래스는,바깥클래스와 함께쓰일때만 유용한 도우미클래스로 사용됨
		근데 보통 그러면 외부에서 사용되지않을거면 스태틱을 붙이지 않을 이유가 없음,이걸 붙이지않으면 외부로의 숨은참조를 가지게됨(메모리누수발생가능성)
		
	11.톱레벨 클래스는 한파일에 하나만 담으라
		소스파일 하나에 톱레벨클래스가 여러개 들어갈수있는데,이러면 이득도없고 위험도 있음(컴파일순서에 따른 위험)
		그러니 한파일에 톱레벨 클래스는 하나만 들어가는게 좋음
		
		
5.제네릭		
	1.로타입은 사용하지 마라
		제네릭이 들어온시점에서 컬렉션에서 제네릭이 안붙은타입은 사용할 이유도 없고,사용해서도 안됨
		제네릭을 사용한 컬렉션은,내부에서의 타입이 보장되는데,로타입은 그게 안되기때문
		그래서 로타입을 사용하면,꺼낼때 classCastException이 발생할 확률이 생기니 사용하면안됨
		
		만약 원소의 타입을 몰라도되는 컬렉션을 만들고싶으면(단 추가하진 않고 사용만할때)
			Set<?>
		이렇게 비한정적 와일드카드를 사용하면됨
		이러면 모든타입을 받을수있고, null을 제외한 어떤것도 추가할수없고,출력은 할수있어서 타입안정성을 지킬수있음 
	
	2.비검사 경고를 제거하라
		제네릭을 사용할때,처음쓰면 컴파일러 경고가 막 뜨는데,그걸 하나하나 지워서 전부지우고나면 타입안정성이 보장되게됨
		즉,타입안정성을 확신할수 없는상황이면 컴파일러 경고를 다 지켜서 지워야함,
		보장할수 있으면 그냥 어노테이션(@SuppressWarnings)으로 지워도되긴함
	
	3.배열보단 리스트를 사용하라
		배열에서의 제네릭은,컴파일시점에 날아가기때문에 런타임에서 classCastException가 발생할수 있음
		그래서 리스트제네릭을 사용해야함
		이유는 배열은 공변인데,제네릭은 불공변이기때문
		그래서 서로 잘 어울리지못함
	
	4.이왕이면 제네릭타입으로 만들어라
		제네릭으로 타입을 만드는건 좀 어렵긴한데,만들어두면 쓰기편함
		보통 오브젝트를 사용하고있으면 제네릭으로 바꾸기좋음
		이때 제네릭은 실체화불가능하기때문에 컴파일오류가 뜰텐데
		이때는 오브젝트로 만들고 캐스팅하는식을 자주 사용함(이때는 배열이 기본타입이기때문에 리스트대신 배열을 사용해야함)
		
	5.이왕이면 제네릭메서드로 만들라
		메서드로 제네릭으로 만들수있는데,이떄도 그냥 제네릭써서 만들면됨
		이렇게만들면 클라에서 명시적으로 형변환하는거보다 쓰기도편하고 안전함
		즉 형변화이 필요한 메서드를 제네릭하게 만들면됨
	
	6.한정적 와일드카드를 사용해 api유연성을 높여라
		매개변수화타입은 불공변임
		즉 List<String>는 List<Object>의 하위타입이 아님(리스코프치환원칙)
		이때 명시적으로 하위타입임을 적어서,공변으로 만들수있는데,이땐
			List<? extends E>
		이렇게하면됨
		상위로 올리려면
			List<? super E>
		이렇게하면되고
		즉 유연성이 필요할때 이렇게 사용할수있음
		보통 프로듀서는 extends고,컨슈머는 super을 넣으면됨
		단 반환타입은 한정적와일드카드를 사용하면안됨,그러면 클라코드에서도 와일드카드타입을 써야하기때문
		
		이건 어려우니까 나중에 한번더보자
		
	7.제네릭과 가변인수를 함께쓸때는 신중하라
		가변인수와 제네릭은 서로 잘 어울리지못함
		구현방식에 헛점이 있기때문임
		그래서 힙오염이 발생해,자동생성한 형변환이 흔들리고 타입안정성이 흔들림
		그래서 제네릭리스트를 가변인수로 늘리는건 주의해서 작업해야함
		이거자체는 유용하긴한데,이걸 사용하려면 타입안전을 직접 확인한후에 @SafeVarargs으로 경고를 숨겨야함(즉 책임은 구현자에있음)
		이때,메서드가 배열에 아무것도 저장하지않고,그 배열의 참조가 밖으로 노출되지않으면 타입안전하다고 할수있음
		아니면 그냥 배열대신 리스트를 쓸수있음
		
	8.타입안전 이종컨테이너를 고려하라
		타입을 오브젝트로 아무거나 받을수있게 만들고,해당 타입들을 모아서 사용하고싶다면,
		즉 키밸류로 키를 타입으로 잡고싶다면,타입안전이종컨테이너를 사용할수있음
		이건
			abc(class<T> type,T instance)
			private Map<Class<?>,Object> favMap=new HashMap<>();
		이런식으로 받아서 넣으면됨
		이러면 일단 타입정보도 있으니 classCastException도 터지지않음
		이러면 키가 와일드카드타입이니,모든값을 넣을수있음
		여기서 주의점은
			악의적클라가 로타입으로 넘기면 타입안정성이 쉽게 깨짐
			실체화불가타입에는 사용할수없음,즉 List<String>같은건 저장할수없음(List<String>과 List<Integer>은 컴파일러단에선 같은취급이니)
		이거만 넘기면 편하게 쓸수있음
		
		
6.열거타입과 어노테이션		
	1.int상수 대신 열거타입을 사용하라
		그냥 인트를 상수로 사용하는거 대신 이넘클래스를 만들어서 사용하는게 좋음
		그냥 인트는 변경시 이상하게 동작하기쉽고,디버거로 볼때도 그냥 숫자라 뭔지 알아채기어려움
		
		이넘은 상수 하나당 자신의 인스턴스를 하나씩 만들어,퍼블릭 스태틱 파이널로 공개한다고 보면됨
		추가로 생성자가 없으니 싱글톤처럼 동작함
		이건 컴파일타임 타입안정성을 제공함
		해당 이넘타입을 매개변수로 받는다고 선언하면,무조건 그안에서 값이 들어있는게 보장됨(다른게들어오면 컴파일에러)
		그리고 이넘도 클래스니까 메서드나 필드를 추가할수있음,이건 묻지않고 시켜라 원칙에 맞게 만들수있는 원료임
		
		그리고 이넘에서 뭘 제거한다고 해도,그걸 참조하지않는애들은 전혀 영향을 받지않고,추가한다고 해도 원래있던애들은 전혀 영향을 받지않음
		
		이넘도 특정클래스에서만 쓰면 프라이빗으로,전체에서 쓰면 퍼블릭으로 공개하면됨
		이넘은 특정값에 메서드를 붙여서,그걸 콜하면 메서드를 사용하게 할수도 있고 그럼
		
		그리고 새 상수를 추가할때 전략을 선택하게 만들어서,유연하게 만들수도있음(주휴수당계산등)
		
		이런 이넘은,필요한 원소를 컴파일타임에 다 알수있는 상수집합이라면,항상 이넘을 사용하면됨(일주일이나,태양계같은)
		
	2.ordinal메서드 대신 인스턴스필드를 사용하라
		이넘에서 선언숫자는 사용하면안됨,즉 ordinal은 사용금지임
		나중에 추가하거나 제거했을때 디게 머리아파지니까,차라리(SOLO(1))이런식으로 숫자를 저장해둔뒤 불러다 쓰는게 나음
		
	3.비트필드 대신 EnumSet를 사용하라	
		이넘값들이 단독이 아닌 집합으로 사용될경우,enumSet클래스를 사용하면 됨
			public class abc{
				public enum Style{A,B,C,D}
				
				public void applyStyles(Set<Style>styles){...}
			}
			abc.applyStyles(EnumSet.of(Style.A,Style.B));
		이런거
		
	4.ordinal인덱싱대신 EnumMap를 사용하라
		원소를 꺼낼때도 순서가 아닌,해당값에 의존해서 꺼내야 나중에 수정할때 문제가안생김
		이때 EnumMap를 사용하면,속도도 빠르고 타입안정성도 챙길수있음
		
	5.확장할수있는 열거타입이 필요하면 인터페이스를 사용하라
		열거타입은 일반적으로 확장할수없음,보통 할일이 없기도 하고
		근데 만약 확장이 필요하다면,인터페이스를 만들고,이넘클래스에서 이걸 각기 구현하여 확장하면됨
		이거로 클라가 자신만의 이넘타일을 만들수있음
	
	6.명명패턴보다 어노테이션을 사용하라
		이름기반으로 뭘 하는거보다,어노테이션기반으로 하는게 훨씬 컴파일시간에 에러띄우기도 쉬움
		
	7.@Override 어노테이션을 일관되게 사용하라
		항상 오버라이드할땐 @Override를 붙이자,안그러면 오버로딩이 되버리는 경우가 있음(매개변수를 실수로 다르게잡았을때)
	
	8.정의하려는것이 타입이라면,마커인터페이스를 사용하라
		아무메서드도 없고,단지 자신을 구현하는 클래스가 특정속성을 가지는걸 표현하는 인터페이스를 마커인터페이스라고 함(Serializable)
		마커어노테이션도 있지만,이거두개도 캐바캐로 적용해야함
		마커인터페이스는 이를 구현한 클래스의 인스턴스를 구분하는 타입으로 사용할수있지만,마커어노테이션은 불가능하다는점
		적용대상을 좀 더 정밀하게 지정할수있다는점이 있음

7.람다와 스트림
	1.익명클래스보다는 람다를 사용하라
		추상메서드가 하나담긴 인터페이스나,익명클래스를 사용할거면,그자리에 람다를 쓰는게 나음
		이건 이름을 붙일수 있다는거 말곤 큰의미가없음
		
		그리고 람다의 타입은,명시해야 더 코드가 명확할때를 제외하곤 타입을 생략하고,컴파일러가 타입을 알수없다는 오류를 뱉으면 그때 적으면됨
		즉 람다는 제네릭으로 사용하는게 젤좋음
		
		람다는 보통 3줄이하로 적을수 있을때 좋지만,코드에 꼭 이름을 붙여야하거나,코드가 3줄이상으로 길어진다면 익명클래스를 사용해야함
		그리고 람다는 직렬화하면안됨(익명클래스의 인스턴스도 마찬가지)
	
	2.람다보다는 메서드참조를 사용하라
		람다로 작성할 코드를 새 메서드에 담은다음,그 메서드참조를 사용하면,이름을 지을수있고 설명도 적을수있음
		물론 람다도,메서드참조보다 짧고,코드를 바로 보여주니 더 명확하다는 장점이 있음
		즉,메서드참조가 더 짧고 명확하면 메서드참조를 쓰고,그렇지않으면 람다를 사용하면됨
		
	3.표준 함수형 인터페이스를 사용하라
		템플릿메서드는 람다가 생기면서 효용성이 크게줄었음
		보통 요즘은 같은효과의 함수객체를 받는 정적팩터리나 생성자를 제공함
		즉 람다를 받는 생성자를 사용하여 템플릿메서드처럼 쓴다는것
		
		그리고 java.util.function에 보면 표준함수형 인터페이스들이 담겨있으니,구현하지말고 그거쓰면됨
			operator(반환값과 인수타입이 같음,즉 일반적함수)
			predicate(인수하나를받아 TF를 반환,즉 테스트함수)
			function(인수와 반환타입이 다름,즉 일반적함수)
			supplier(인수를받지않고 값을 반환,즉 게터)
			consumer(인수를 하나받아서 소비하고 반환값은 없음,db변환적용함수)
		이렇게만 알고있으면됨
		이건 대부분 기본타입만 지원함
		
		그리고 커스텀으로 함수형인터페이스를 구현해야 할땐
			자주쓰이고 이름자체가 용도를 명확히 설명
			반드시 따라야하는 규약이 있음
			유용한 디폴트메서드를 제공할수있음
		이중 하나이상을 만족할때 고민하면됨
		이때,인터페이스를 만드는거니 주의해서 설계해야함
		그리고 이땐 @FunctionalInterface를 붙여야함
		
	4.스트림은 주의해서 사용하라
		스트림은 소스에서 시작해,종단연산으로 끝나고,그사이에 중간연산이 여러개 들어갈수있음
		각 중간연산은 스트림을 어떤방식으로 변환시킴
		이때 변환된 스트림의 원소타입은,변환전 스트림의 원소타입과 같을수도,다를수도있음
		스트림은,마지막에 종단연산이 되어야 실행되고,이때 사용되지않는원소는 계산하지않음
		
		스트림을 병렬로도 할수있긴하지만,이렇게 할일은 거의없고,스트림을 사용해서 많은걸 할수있지만,이게 더 깔끔할때 선택해야함
		보통 집합전체에서 뭐 걸러낼때나,같은조건으로 뭘 변형해야할때 사용하기좋음
		그리고 한 원소가 아닌,다른원소에도 접근해야하면 사용하기어려움(아니면 앞단계의 값을 필요로하거나)
		즉 읽기편하게 스트림을 사용해야함
		그리고 char값을 처리해야할땐 스트림을 사용하지않는게 좋음
		
	5.스트림에선 부작용없는 함수를 사용하라
		스트림에서 사이드이펙트가 있으면,일단 함수형이라는 패러다임자체도 위반하게되고 문제가 많음
		그래서 사이드이펙트가 없게 만들어야하고,반드시 필요하면 스트림말고 반복문을 사용하는게좋음
		그리고 forEach연산은,스트림계산결과를 보고할때만 사용하고,계산할땐 사용하면안됨
		그리고 collect로 계산결과를 리스트나 집합,맵등으로 뽑을수있음
		
	6.반환타입으로는 스트림보다 컬렉션이 낫다
		자바8기준으로는 스트림을 컬렉션처럼 취급하지못함(이터레이터가 없음)
		그래서 리턴을 할땐 컬렉션으로 던져주는게 받을때 사용하기 더 편함
		그래서 스트림을 이터레이터로 바꾸는 어댑터를 만들어서 던져주는게좋음
		
	7.스트림병렬화는 주의해서 적용하라
		스트림에서 limit를 사용하거나,데이터소스가 Stream.iterate면 병렬화로 성능개선을 할수없음
		그리고 병렬화를 하면,성능이 나빠질수도,결과가 잘못될수도,예상못한동작이 발생할수도있음
		그래서 가능하면 안하는게좋음
		꼭 성능최적화가 필요한경우에만 사용하자
		
		
8.메서드		
	1.매개변수가 정상인지 검사하라	
		메서드가 실행하는 시점에서,매개변수값을 최대한 빨리 검사하는게 좋음
		이런 제약은 반드시 문서화되어야하고,메서드 메인부분이 실행전에 검사되어야함,이게 깔끔함
		그리고 가능하다면,메서드단위로 문서화하는거보다,클래스단위로 매개변수들의 값범위를 문서화하는게 훨씬 깔끔함
		
		널검사는 
			Objects.requireNonNull(abc,"예외메시지")
		를 사용할수있음
		
		퍼블릭이 아닌 메서드는,만든사람이 메서드가 호출되는 상황을 통제할수있으니,반드시 유효한값만 넘겨야함
		그러니 assert를 사용해서 유효성검증해도됨,어짜피 아니면 절대안되니까
		
		그리고 메서드가 직접 사용하진않으나,나중에 다른데서 쓰려고 받는 매개변수는 더더욱 신경써서 검사해야함
		이건 몇번 메서드 거치고나면 찾기가 너무힘들어짐
		
	2.적시에 방어적 복사본을 만들라
		리플렉션같은걸 제외한,언어내에서는 최대한 외부로부터의 침범을 막아내야함
		이런게 뚫리는건,주로 메모리참조계열 변수를 직접 던져줬을때 변경해버려서 생기는경우가 많음
		그래서 이런걸 사용할떄,get같은걸 해야하면 복사해서 리턴해야함
		이때는,유효성 검사를 하기전에 먼저 복사본을 만들고,그거로 유효성검사를 하고 사용하는방식을 취하면됨(멀티쓰레딩에서의 문제방지)
		
		그리고 매개변수가 제 3자에 의해 확장될수 있는 타입이면,복사본을 만들때 clone를 사용하면안됨,생성자를 사용하자
		이렇게 내부필드를 완전히 캡슐화해두는게 나중에 일이 덜생김
		즉,되도록 불변객체를 조합해 객체를 구성하는게 좋고,이러면 방어적복사를 할 일도 줄어듬
		
	3.메서드 시그니처를 신중히 설계하라
		메서드 이름은 신중히 지어야함,항상 표준명명규칙을 따라야함
		즉 이해할수있고,같은패키지에 속한 다른이름들과 일관되게 지어야함,
		그다음목표로 개발자 커뮤니티에서 널리 받아들여지는 이름을 사용하자,긴이름은 가급적피하고
		
		편의메서드를 너무 많이만들면,테스트하기 어려우니까,자기자신이 할일은 자기자신한테 주는게 좋음
		확신이 없으면 만들지말자
		
		매개변수목록은 짧게 유지하자,4개이하가 좋고,작으면 작을수록 좋음
		같은타입의 매개변수가 여러개 연달아 나오는게 엄청헷갈리니까 피하자
		이러려면,여러메서드로 쪼개거나,
		매개변수여러개를 묶는 클래스를 만드는것(정적멤버클래스),이건 매개변수 몇개를 하나의 개념으로 묶을수있을때 좋음
		이거의 발전형으로,빌더패턴을 사용하는방법도 있음
		
		매개변수의 타입으로는,구체클래스보다 인터페이스가 더 나음
		이래야 좀 더 활용할 여지가 커짐
		
		불리언보단 원소2개짜리 열거타입이 더 나음,이게 각 원소마다 이름을 붙일수있어서 더 직관적임
		
	4.다중정의는 신중히 사용하라
		오버로딩은 어느 메서드를 호출할지가 컴파일타임에 정해지기때문에,런타임에서 타입이 바뀌는 제네릭같은건 호출할 메서드를 선택하는데 영향을 주지못함
		즉 오버라이딩은 동적으로 선택되고,오버로딩은 정적으로 선택됨
		그래서 런타임타입은 메서드호출의 기준이 되지않음 오버로딩은
		그래서 int를 받는거와 object를 받는 메서드가 동시에 있다면(특히 클래스 계층별로 하나씩 있다거나할때)
		어떻게 동작할지 모름
		
		그래서 최대한 안전하고 보수적으로 가려면,매개변수 수가 같은 오버로딩은 만들지말거나,최소한 같은 계층관계에 있는건 넣으면안됨
		그리고 가변인수를 사용하면 오버로딩을 금지하고
		아니면 그냥 메서드이름을 다르게짓는 방법도있음
		
		생성자의 경우엔 이름을 바꿀수없음,그래서 이경우엔 정적팩토리를 활용할수있음
		
		메서드를 다중정의할때,서로 다른 함수형 인터페이스라고 해도,같은위치의 인수를 받아서는 안됨
		
	5.가변인수는 신중히 사용하라
		가변인수를 사용하면,인수가 0개일수있음,이때 하나이상을 무조건받고싶으면,이걸 메서드 내부에서 랭스체크해서 예외던지는건 런타임에 터지기때문에 좋지않고,
		그냥 첫 인수를 넣고,그뒤를 가변인수로 해서 컴파일시점에 예외터지게 만들수있음
		
		그리고 가변인수로 인한 성능문제가 있으면,인수갯수만 늘려서 오버로딩으로 한 4개정도까지 만든뒤에 그뒤에 가변인수가 들어간걸 만들면,
		가변인수를 사용하는 비율을 줄여서 좀 완화할수있음
		
	6.null이 아닌 빈컬렉션이나 배열을 반환하라
		컬렉션이 비었으면 null을 보내는게 아니라 그냥 비어있는 컬렉션을 던지면됨
		null을 던지면 받는쪽에서 또 처리해야하니까 골치아픔
		그리고 컬렉션생성비용이 문제면,불변한 빈컬렉션을 만들어두고,계속 그걸 공유하는방법도 있음
		
	7.옵셔널 반환은 신중히 하라
		옵셔널을 반환하는 메서드면,절대 널을 반환하면안됨
		옵셔널을 받는쪽에선 옵셔널을 깠을때 널일경우를 처리해줘야함(isPresent등으로 확인하거나)
		그리고 리스트같은거는 옵셔널로 감싸면안됨,그냥 빈리스트를 던지는게 나음
		
	8.공개된 api요소에는 항상 문서화 주석을 작성하라
		api를 공개하면 해당메서드와 클라이언트사이의 규약,즉 하는일과 사전조건,사후조건,불변식등을 문서화해서 공개해야함
		그리고 반드시 사이드이펙트도 같이 문서화해야함
		
		문서에서 첫문장은,해당요소의 요약설명이어야함(해당 메서드가 하는일을 요약해서 적기)
		그리고 제네릭이나 제네릭메서드를 문서화할땐,모든 타입매개변수에 주석을 달아야함
		열거타입을 문서화할떈 상수들에도 주석을 달아야함
		어노테이션타입을 문서화할땐 멤버들에도 주석을 달아야함
		
		그리고 스레드안전성과 직렬화가능성도 반드시 api설명에 추가되어야함
		
		
		
		
9.일반적인 프로그래밍 원칙	
	1.지역변수의 범위를 최소화하라
		지역변수는 사용하기 직전에 선언하고,선언하자마자 초기화해서 스코프를 최대한 줄여야함
		그리고 사용하는 블록 외부에 선언하는거도,자동적으로 gc가 동작하지않기때문에 문제가 생길 여지가 많음
		그리고 해당블록 바깥에서도 사용해야 하면,그래도 최대한 범위를 좁게 줄이는게 좋음(해당블록 바로앞이라거나)
		
		특히 반복문에서 루프범위지정에서 선언된애들은,블록이 끝나면 바로 사라지니까 같은이름을 계속 반복해서 사용해도됨
		
		그리고 메서드는 가능한 작게유지하고,한가지 기능에만 집중하는게 좋음
		
	2.전통적인 for문보단 foreach를 사용하라
		컬렉션을 순회할땐,foreach가 진짜 편하니까 이거쓰는게 좋음
		반복범위를 잘못처리할일도 없고 맘편함
		물론 컬렉션안에서 뭘 지워야하거나,변형해야하거나 이러면 전통적인 for문 돌려야함
		사실 그러면 스트림으로 필터거는게 더 적합하겠지만
		
	3.라이브러리를 익히고 사용하라
		어지간하면 라이브러리에 있는걸 사용하는게,직접 구현하는거보다 나음
		문제가 생길여지도 덜하고,다른사람들이 보고 쉽게 무슨일할지를 추론할수있음
		성능도 개선된상태고
		그래서 java.lang,java.util,java.io정도는 알고있는게 좋음
		
	4.정확한 답이 필요하다면 float와 double은 피하라
		애네들은 근사치라서,정확한답이 필요할경우엔 문제가 생길 여지가 많음
		그래서 금융계산같은거엔 bigDecimal,int,long를 사용해야함(즉 소수점단위를 올리고 직접계산)
		
	5.박싱된 기본타입보다는 기본타입을 사용하라
		int,double,boolean은 기본타입,Integer,Double,Boolean은 박싱된 기본타입임
		이 두개는 서로 호환되긴하지만,차이점이 좀 있음
		박싱타입은 각각의 식별성이 있어서,오브젝트를 구분할수있고,널을 넣을수있음
		가장 큰 차이로,기본타입이 항상 박싱타입보다 시간,메모리면에서 효율적임
		
		그리고 문제는,기본타입과 박싱타입을 비교할경우 자동으로 박싱이 풀리는데,이때 null이 들어있으면 바로 npe임
		박싱타입은 컬렉션의 원소,키,값으로 사용하거나,리플렉션을 사용할때만 사용해야함
		
	6.다른타입이 적절하다면 문자열 사용을 피하라
		뭐든 다 문자열로 떄려박는건 피하는게 좋음
		문자열을 사용할땐 진짜 문자열일때만 써야함
		수치형이면 int나 double,TF면 불리언이나 이넘을 사용해야함
		혼합일경우에도,각각을나눠서 dto같은데 넣어서 사용하는게 좋음
	
	7.문자열연결은 느리니 주의하라	
		문자열에 +로 문자열끼리 더하는건 n^2의 연산임
		문자열은 불변이라 양쪽의 내용을 모두 복사해야하기때문
		그래서 성능이 중요하면 stringBuilder을 사용하면됨
		
	8.객체는 인터페이스를 사용해 참조하라
		구현클래스타입은,실제 생성자를 호출할때 말곤 사용하지말고,다 인터페이스에 의존하는게 좋음
		매개변수,반환값,필드,변수 모두 다 그럼
		이러면 프로그램이 훨씬 더 유연해짐
		
		물론 적합한 인터페이스가 없으면 클래스참조를 해야함(값클래스같은거 dto같이)
		해당상황에서 필요한기능을 만족하는 가장 상위의 인터페이스나 클래스를 선택하라는것
	
	9.리플렉션보다는 인터페이스를 사용하라
		리플렉션은 막 빠요엔처럼 사용할수있긴하지만,이건 위험성이 좀 많이높고,캡슐화가 깨짐
		대표적단점은
			컴파일타임검사이점을 전혀누릴수없음
			코드가 장황해짐
			성능이 떨어짐
		그래서 아주 제한된상황에서만 사용해야함
		사용할떄도 리플렉션으로 생성해서 인터페이스로 참조해 사용해야함
	10.네이티브 메서드는 신중히 사용하라
		C같은 네이티브언어로 된 메서드를 호출할수있는데 자바는,이건 요즘시대엔 거의 사용되지않음
		특히 성능개선을 목적으로 하는건 거의 효과를 못보고,단점만 있음(메모리훼손오류등)
	
	11.최적화는 신중히 하라
		최적화는 꼭 필요할때만 해야함,안하는게 더 나은경우가 훨씬많음
		약간의 성능향상을 위해 코드의 안정성이 깨지는건 최악이고,어떻게 할지 명백한 방법을 찾고나서 해야함
		그리고 최적화가 아니라,성능을 제한하는 설계를 피하고(API같은 소통방식에서 특히)
		API를 설계할때 성능에 주는 영향을 고려해서 애초부터 설계해야함
		보통 잘설계된 api는 성능이 좋은게 보통임,그래서 성능을위해 api를 왜곡하는건 나쁜생각임
		
		꼭 최적화를 해야하면,최적화시도 전후로 성능을 측정해야함
		보통 최적화를 적용하고나서가 성능이 나쁠때가 많음(어디서 병목인지 찾기가 힘들기때문)
		
	12.일반적으로 통용되는 명명규칙을 따르라
		자바언어명세를 따르고
		패키지이름의 나머지는 해당패키지를 성명하는 하나이상의 요소(8자이하의 짧은단어)로 하면됨
		가능하면 의미가 통하는 약어를 사용하고,여러단어로 구성되었으면,한자씩 떼는거도 괜찮음
		
		클래스와 인터페이스명은 대문자로 시작하고,하나이상의 단어로 구성됨,각 단어의 처음은 대문자처리
		메서드는 첫자가 소문자인거말곤 똑같음
		상수필드는 전체가 대문자,사이는 _로 구분
		
		타입매개변수는 한글자로 표현하고,임의의타입은 T,컬렉션원소타입은 E,맵의 키와 값은 K와 V,메서드반환타입은 R을 사용
		임의타입이 여러개면 T,U,V 혹은 T1,T2,T3를 사용
		
		객체를 생성할수있는 클래스는 단수명사나 명사구(Thread같이)를 사용
		할수없으면 복수형명사를 사용(Collectors,Collections)
		인터페이스명은 클래스와 똑같이
		메서드명은 동사나 목적어를 포함한 동사구로 지으면됨(append,drawImage)
		TF값을 반환하는 메서드면 보통 is나 has로 시작하고,명사를 붙임(isDigit)
		반환타입이 불리언이 아니거나 해당인스턴스의 속성을 반환하면 get을 붙이거나,명사자체를 사용(size,getSize)
		
		
10.예외
	1.예외는 진짜 예외상황에만 사용하라
		예외는 반드시 예외상황에서만 사용해야함,일상적인 흐름제어에서 사용하면 절대안됨
		즉 예외가 뜨는게 디폴트인 상황은 안됨
		api도 마찬가지로,정상적인 제어흐름에선 예외가 나와선안됨
		특정상황에서만 호출할수있는,상태의존적 메서드는 상태검사메서드도 함께 제공해야함
	
	2.복구할수 있는 상황에서는 체크예외를,프로그래밍오류에선 런타임예외를 사용하라
		이건 근데 요즘은 그냥 다 언체크예외쓰는듯
		일단 자원부족,불변식깨짐등 더이상 수행을 할수없으면 무조건 런타임인건 확실함
		그리고 throwable은 직접 사용하면안됨
		
	3.필요없는 체크예외의 사용은 피하라
		체크예외는 중간에 처리를 안하면 메서드호출에 대한 클래스계층을 타고 계속 예외선언을 해줘야하기때문에 매우귀찮음(캡슐화도 깨지고)
		그래서 해당부분에서 처리할수없다면,사용하면안됨
		그리고 체크예외는 해당메서드에서 하나만 있는게 좋음
		가능하면 안쓰는추세이긴한듯 코틀린도그렇고
	
	4.표준예외를 사용하라
		예외는 일반적으로는 표준예외를 사용하는게,다른사람들이 읽기 쉬움
			IllegalArgumentException:호출자가 인수로 부적절한값을 넘길때,즉 사전조건이 틀렸을때
			IllegalStateException:대상객체의 상태가 호출된 메서드를 수행할수없는 상태일때(초기화되지않은 객체라거나)
			NPE:널을 허용하지않는 메서드에 널을 던졌을때(IllegalArgumentException대신 관례상 이거씀)
			IndexOutOfBoundsException:어떤 스퀸스의 허용범위를 넘겼을때(IllegalArgumentException대신 관례상 이거씀)
			ConcurrentModificationException:단일스레드에서 사용하려고 설계한 객체를 여러스레드가 동시에 수정하려할때
			UnsupportedOperationException:클라이언트가 요청한 동작을 대상객체에서 지원하지않을때(보통은 사용되지않음)
		이렇게가 자주쓰이고,저상황에선 저걸쓰면됨
		
		그리도 Exception,RuntimeException,Throwable,Error은 직접사용하지말고,추상클래스라 생각하고 상속해서 사용해야함
		그리고 인수값이 뭐든 무조건 실패했을거면 IllegalStateException,그렇지않으면 IllegalArgumentException을 선택하면됨
		
	5.추상화수준에 맞는 예외를 던지라
		하위계층에서 예외가 올라오는데,해당 층에 맞지않다면 구현을 드러내서 캡슐화가 깨질수도있고,일단 당황스러움
		그래서 하위계층의 예외를,현재계층에 맞게 번역해서 다시 던지는 작업을 해야할수도있음
		컬렉션에서,IndexOutOfBoundsException가 올라왔을때,배열을 전부뒤져도 없어서 그런거면 NoSuchElementException을 던진다거나
		이때 그 아래층예외를 상위층예외에 담아 보내서 나중에 찾기쉽게 하는게 좋음(보통 예외상속받으면 다들어있음,initCause사용해서 커스텀도가능)
		그리고 가능하면,아래계층에서 예외가 발생하지않도록 하는게 최선이고,상위층에서 조용히 처리할수있으면 그렇게하는거도 방법임(로깅만 해두고)
		
	6.메서드가 던지는 모든 예외를 문서화하라
		해당 메서드가 던지는 예외는,그 메서드를 올바로사용할때의 중요한 정보임
		그래서 그 예외 하나하나당 다 문서화를 해야함(특히 체크예외,언체크예외는 가급적 하는게 좋고,현실적으로 못할때도 있긴함)
		그리고 예외는 하나하나 따로 선언하고,공통으로 묶어서 던지면 절대안됨
		그러면 얻을수있는 정보가 없음
		
	7.예외의 상세 메시지에 실패 관련 정보를 담으라
		실패 순간을 포착하려면,예외에 관여된 모든 매개변수와 필드의 값을 실패메시지에 담아야함
		즉 IndexOutOfBoundsException이라면,범위의 최소값,최대값,인덱스의값을 모두 예외에 담아야함
		단,보안과 관련된 비밀번호같은건 담으면안됨
		
	8.가능한 한 실패원자적으로 만들라
		호출된 메서드가 실패하더라도,해당객체는 메서드 호출 전 상태를 유지하는걸 실패원자성이라고 함
		메서드를 실패원자적으로 만드는 가장 쉬운방법은,객체를 불변객체로 만드는것
		불변객체는 태생적으로 실패원자적임,새로 생성을 못할수는 있지만 해당객체는 변하지않음
		
		가변객체를 실패원자적으로 만드는 가장쉬운방법은,작업 수행 전에 매개변수의 유효성을 검사하고,실패하면 미리 끝내버리는것
		다른방법으론,객체의 복사본에서 작업을 한 다음,성공하면 객체를 덮어쓰는방법도 있음
		
		이런 실패원자성은,스레드같은곳에선 깨질수있고,예외가 아닌 오류,즉 Error같은경우는 어짜피 복구가 불가능하니까 할필요없음
		
	9.예외를 무시하지 마라
		catch에서 아무것도 안하는 이런 예외무시는 매우 안좋음
		물론 예외무시를 메서드설계상 해야하는경우도 있지만,이경우에도 반드시 주석을 남겨야함
		예외가 떴으면 적절히 처리해야함,최소한 로깅은해야함
		
		
11.동시성		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
	
	
	