1.들어가기
	스킵
2.객체 생성과 파괴
	1.생성자대신 정적팩터리메서드를 고려하라
		퍼블릭생성자대신,정적팩터리메서드를 사용해서 생성자에 이름을 붙이고,하나의 매개인수조합으로 여러종류의 생성자를 만들수있음
		그리고 호출될때마다 인스턴스를 새로생성하는게 아닌,싱글톤같은식으로 만들수있음(플라이웨이트패턴같은느낌)
		가장큰 장점으로,반환타입의 하위반환타입을 반환할수있게됨,그래서 구현클래스를 퍼블릭으로 안만들어도 되게됨		
		자바8이후엔 인터페이스에 정적메서드를 선언할수있어져서 이게 편해졌음
		그래서 입력매개변수에 따라 다른하위구현클래스를 리턴할수있어짐
		그리고 정적팩터리메서드를 작성하는시점에는 반환할객체의 클래스가 존재하지않아도됨
		
		정적팩터리메서드의 단점은,상속을 하려면 퍼블릭이나 프로텍티드생성자가 필요하니,이거만 있으면 하위클래스를 만들수없음
		이경우엔 합성을 사용하는게 좋음
		또한,프로그래머가 정적팩터리메서드를 찾기힘듬(생성자처럼 반드시있어야하는게 아니니)
		그래서 관례에 따라 이름짓는거로 어케하는데 완전히 대체되는건아님
	2.생성자에 매개변수가 많다면 빌더를 고려하라
		이건 코틀린에선 사용하지않던 방식인데,자바에서는 매개변수의 디폴트값이 없기때문에,미리 메서드에 빌더패턴메서드를 넣어두고 빌드하는식으로 자주사용함
		이러면 디폴트값을 사용할수있고,해당 값에 이름을 붙일수있어서 확인이 쉬워짐(순서헷갈릴일도 없고)
		이런 빌더패턴은 계층적으로 설계된 클래스와 함께쓰기가 좋음
		
		보통 매개변수가 많을때 생성자나 정적팩토리대신 빌더를 사용하면 효과적임
	3.private나 enum으로 싱글톤임을 보장하라
		싱글톤은 클라입장에서 테스트하기가 어려워짐(인터페이스를 구현하지않은경우)
		싱글톤을 만들땐,생성자를 프라이빗으로 감춰두고,유일하게 접근할수있는 스태틱멤버를 하나 만들어두고,거기에 주소값을 넘겨주는방식으로 사용함
		이때,퍼블릭필드가 아닌 이넘타입의 싱글톤을 사용하는걸로 리플렉션이나 제2의 인스턴스가 생기는걸 막을수있음
		단 해당 싱글톤이 enum이외의 클래스를 사용해야하면 이건사용할수없음(이중상속안되니까,물론 인터페이스구현은 됨)
	4.인스턴스화를 막으려면 private를 사용해라
		단순히 정적메서드와 정적필드만 담긴 클래스는 별로 좋진않지만,만들어야할때가 있음
		이때는 생성자를 막아서 생성이 안되게하는게 좋음(추상클래스만으로는 하위를 구현하면돼서 막지못함)
		추가적으로 이러면 상속도 막을수있어서 좋음
	5.자원을 직접 명시하지말고 의존객체주입을 사용하라
		자원을 직접 생성하지말고,인터페이스로 변수만 생성하고,생성자를 통해 di받으면 훨씬 더 유연하게 사용할수있음
		이러면 유연성과 테스트가 편해짐
		이방식의 변형으로,생성자에 자원팩토리를 넘겨주는방식이 있음(팩토리메서드패턴)
		이런건 스프링쓰면 편해게해줌
	6.불필요한 객체생성을 피하라
		같은 객체를 여러번 만드는건 효율적이지않음,물론 이건 객체생성비용이 비쌀때의 이야기지(db커넥션같은),쌀땐 걍 가독성만 중심으로 쓰면됨
		일반적으로 재사용해서 문제가 생길확률이,객체생성 더해서 문제생길확률보다 훨씬 크니 알아만두자
	7.다 쓴 객체 참조를 해제하라
		가비지컬렉터도 사용하진않는데 내부에서 참조는 가지고있는애들을 지우진 못함
		그래서 모든것들의 스코프를 최소한으로 잡아서,끝나면 바로 리프레시되게 만드는게 좋고,만약 그럴수없다면 해당참조를 다썼을때 null처리하면됨
		이렇게 null처리하는건 예외적인거여야하고,일반적으론 스코프를 최대한 좁게잡아서 그냥 해당영역이 끝나게하는게 젤 좋음
		보통 메모리누수가 생기는건,자기메모리를 직접 관리하는 클래스나,캐시를 사용하는경우,리스너나 콜백을 사용할경우 그럴수있음
		캐시나 콜백같은경우,weakHashMap같은걸 사용해서 약한참조를 걸어버리는 방법이 주로 사용됨(자리없으면 우선적으로 날려버림)
	8.finalizer나 cleaner의 사용을 피해라
		난 있다는거도 첨알았음,어짜피 안쓰니까 넘어가자
	9.try-finally보단 try-with-resources를 사용하자
		리소스열고 닫을때는,try-with-resources가 try-finally보다 더 깔끔하게 나옴
		이건 해당클래스가 autoCloseable이 구현되어있으면,자동으로 끝나고 리소스를 닫아줌
	
3.모든 객체의 공통 메서드	
	1.equals는 규약을 지켜 재정의하라
		이퀄은 기본적으로는 같은객체인지를 비교하는데,이걸 논리적동치성(필드값이 같은)으로 매핑해야할때가 있음
		이떈 equals을 재정의해야함
		보통 값클래스에서 재정의하는경우가 많음,그리고 값클래스라도 싱글톤일경우엔 할필요가 없음,어짜피 같은거니까
		
		이 이퀄은
			널이 아닐때 널과비교하면 false             널아님
			자기자신과 비교하면 항상 true              반사성
			x,y가 true면 y,x도 true여야함          대칭성
			x,y,z중 x,y가 T y,z가 T면 x,z도 T여야함  추이성
			변경이 없을때 백만번돌려도 값이 다 똑같아야함     일관성
		이라는 조건을 만족해야함
		특히 x,y가 true고 y,x가 true여야한다는건,만약 클래스 2개이상을 비교해야할경우엔,반대편에도 똑같이 작업해줘야한다는것(대칭성)
		그리고 상위클래스에 없는 새로운필드를 하위클래스에 추가했을때,상위클래스와 하위클래스를 비교할때 추이성이 깨지기쉬움
		구체클래스를 확장해서 새값을 추가하며,equals을 만족시킬방법은 없음
		그래서 이런경우 상속대신 합성을 사용해야함
		
		equals을 만들때 구현방법의 순서는
			1.==를 사용해 입력이 자기자신의 참조인지 확인
			2.instanceof로 입력이 올바른타입인지 확인
			3.입력을 올바른타입으로 형변환,instanceof를 썼으니 이건 100%성공함
			4.입력객체와 자기자신의 대응되는 핵심필드가 모두 일치하는지 하나하나체크
		이렇게 구현하면됨
		그리고 마지막에 비교할때,비교가격이 싼거부터 하는게 빨리false치고 나갈수있어서 좋음
		
		그리고 equals을 구현할때,가능하면 간단하게 해결하는게 좋음,별칭같은건 걍 잘라버리는게나음
		그리고 입력타입은 반드시 object로 둬야함(안그러면 오버로딩되버림)
		
		그리고 이런 equals을 자동으로 만들어주는 프레임워크들이 있으니,그거쓰는거도 좋음(autoValue같은)
		그리고 꼭필요한경우가 아니면 재정의안하는게 좋음
	2.equals을 재정의했으면 hashCode도 재정의하라
		이건 반드시 해야함,안그러면 해시를 사용하는 모든곳에서 문제가 생김
		해시코드메서드는 equals을 사용하기때문
		equals로 true가 나왔으면 같은 해시값이 나와야하는데 이게 안되기때문
		그리고 두 객체가 false라면,서로 다른값을 리턴해야함,무조건 다 달라야하는건 아니긴한데 그게 더 성능에좋음
		
		이건
			equals에서 비교한 모든 필드 각각에 대해,type.hashCode(field명)으로 해시코드를 뽑아두고(참조타입이면 책참조)
			result=31*result+현재필드해시값를 반복해서 모든핵심필드에 돌리고,값을뽑아서 리턴
		그러고나서 단위테스트만들어서 돌리면됨
		그리고 이때,equals비교에서 사용하지않은필드는 반드시 빼야함
		
		그리고 해시코드를 뽑는방법을 클라쪽에 공개하면안됨,그러면 의존성생기면 나중에 머리아파짐
	
	3.toString을 항상 재정의하라
		toString은 거의 쓸모없는값을 리턴해줌
		그래서 그 클래스를 표현할수있는 값으로 리턴하면 삶의질이 달라짐
		이때 toString은 그 객체가 가진 주요정보 모두를 반환하는게 좋고,만약 너무크거나 문자열로쓰기 뭐하면,요약정보를 담아야함
	
	4.clone재정의는 주의해서 진행하라
		clone의 규약은 허술해서,깨지기쉬우니 가급적 재정의하지말고 안쓰는게좋음
		그냥 생성자써서 새로만드는게 나음
		보통 복사생성자나 복사팩토리를 사용해서 복사하는게 나음(자기클래스를 매개변수로 받는 생성자)
	
	5.comparable를 구현할지 고려해라
		이건 equals에서 순서까지 비교하는 메서드인 compareTo를 가진 인터페이스임
		즉 이걸 구현하면,그 클래스의 인스턴스에는 순서가 있음을 뜻하고,이걸통해 정렬을 쉽게할수있음
		
		순서가 있는,알파벳,숫자,연대같이 순서가 명확한 값클래스를 작성하면 comparable를 구현하는게 좋음
		이거의 조건의 equals과 거의 똑같은데
		타입이 다른객체가 주어지면 예외를 던지면되고,
		compareTo로 수행한 동치성테스트의 결과가,equals과 같아야함
	
	
4.클래스와 인터페이스
	1.클래스와 멤버의 접근권한을 최소화하라
		클래스가 외부로부터 최소한의 정보만 노출되는 컴포넌트가 잘 설계된 컴포넌트임
		그래서 구현과 api를 깔끔하게 분리하고,api를 통해서만 다른 컴포넌트와 소통하며 서로의 내부동작방식에는 전혀 영향을 안줘야함
		이런 정보은닉을 하면,개발속도가 올라가고,관리비용이 줄고,성능최적화를 하기가 쉬워지고,재사용성과 큰시스템을 만들때도 난이도가 낮아짐
		
		자바에서 정보은닉을 할땐,접근자를 통해서 주로 하게되는데,이때 기본원칙은 모든 클래스와 멤버의 접근성을 가능한 좁히는것
		즉 소프트웨어가 동작하는 가장 낮은 접근수준을 부여해야한다는것
		
		톱레벨에서도 패키지외부에서 사용할일이 없으면 패키지프라이빗으로 두고,한클래스에서만 사용하는 패키지프라이빗은 중첩클래스로 만들고(프라이빗 스태틱)
		멤버들은,일단 먼저 공개api(인터페이스)를 먼저 만들고 나서,나머지는 모두 프라이빗으로 만들면됨
		퍼블릭과 프로텍티드는 외부에 공개되면,계속 유지보수를 해줘야하니까 부담이 엄청나게 커지니,프로텍티드는 최대한 줄이는게좋음
		근데 리스코프치환원칙에 의해 하위클래스는 상위클래스보다 접근수준을 줄일수없음(인터페이스를 구현할때)
		이떄는 예외로 보면됨
		
		코드를 테스트하려는 목적으로 접근범위를 넓혀야할땐,적당한 범위까지는 넓혀도됨,단 이건 프라이빗을 패키지프라이빗정도로 여는거까지만 허용
		패키지프라이빗에서 프로텍티드가 되는건 부담이 너무커지니까 불가능함,즉 테스트만을 위해 클래스,인터페이스,멤버를 공개api로 만들면 안됨
	
		퍼블릭클래스의 인스턴스필드는 최대한 퍼블릭이 아니어야함,퍼블릭이되면 내부에 값을 제한하기가 어려워지고,
		필드값이 수정될때 다른작업을 할수없어져서 스레드안전하지않음
		단,정적필드중 해당 클래스가 표현하는 추상개념을 완성하는데 꼭 필요한 상수는 퍼블릭스태틱파이널로 공개할수있음
		이때도 배열의경우는 변경이 가능하니 공개하면안됨,불변리스트를 사용해야함(아니면 프라이빗으로 만들고 복사본을 던져주던가)
	
	2.퍼블릭 클래스에서는 퍼블릭필드가 아닌 접근자메서드를 사용하라
		퍼블릭 필드는 진짜 어지간하면 사용하면안되고,게터세터를 사용해야함
		그래도 프라이빗중첩클래스같은경우엔 괜찮긴함,dto나
		
	3.변경가능성을 최소화하라
		불변클래스는 설계,구현,사용이 쉽고 오류가 생길 여지도 적고 훨씬 안전함
		이때 따라야하는건
			객체의 상태를 변경하는 메서드를 제공하지않는다
			클래스를 확장할수 없도록 한다
			모든필드를 파이널로 선언한다
			모든필드를 프라이빗으로 선언한다
			자신외에는 내부의 가변컴포넌트에 접근할수없어야함
		이걸 따르면 값이 바뀌지않고,항상 순수함수적으로 동작하게됨,이러면 스레드안전하고,공유를 맘놓고해도됨,실패도 원자성을 제공하게됨
		불변클래스의 단점은,값이 달라지면 반드시 독립된 객체로 만들어야하니,메모리적으로 봤을때는 좀 손해볼수있음
		보통 객체를 완성하는 단계가 많고,중간과정마다 객체를 만들고 버리고 해야할경우 이런문제가 좀 커짐
		그래서 스트림같은데서도 시퀸스를 사용하는거고
		
		그리고 불변클래스는,자신을 상속하지 못하게 해야하는데,이때 가장쉬운방법은 final을 사용하는거고,두번째는 생성자를 프라이빗으로 만들고,
		정적팩토리를 제공하는방법이 있음
	4.상속보단 합성을 사용해라
		상속은 서브타이핑용도(인터페이스에서 여러 타입들이 구현되는)로만 사용해야하고,서브클래싱이 필요할경우엔 합성을 사용해야함
		상속은 캡슐화를 깨트리기때문에 머리아파짐(상위클래스의 변경에 하위클래스들이 전부 영향을받음)
		그래서 사용되는게 합성임
		즉 확장이 필요할때,새로운클래스를 만들고,기존클래스의 인스턴스를 프라이빗필드에 넣어,해당 필드에서 메서드를 부르는거임
		이러면 새클래스는 기존클래스의 내부구현방식의 영향에서 벗어나고,기존클래스에 새 메서드가 추가되더라도 전혀 영향을 받지 않음
		
		이건 래퍼클래스를 만들때,즉 데코레이터 패턴을 사용할때 잘 사용됨,보통 합성과 전달을 조합해서 위임이라고 부름
		
		상속은 반드시 하위클래스가 상위클래스의 진짜 하위타입인 경우에만 상속을 해야함
	5.상속을 고려해 설계하고 문서화하라,그러지않았다면 상속을 금지하라
		상속용 클래스는,재정의가능한 메서드들을 내부적으로 어떻게 이용하는지,즉 구현을 문서로 남겨야함
		이건 상속이 캡슐화를 깨기때문에 어쩔수없는문제임
		상속용클래스를 시험하는방법은,직접 하위클래스를 만들어보는게 유일한 방법임,그래서 빈자리를 찾을수있음(보통 3개정도 만들어보면된대)
		그리고 상속용클래스의 생성자는,직접적이든 간접적이든 재정의가능메서드를 호출하면 안됨(프라이빗,파이널,스태틱메서드만 호출가능)
		이러면 상속받은애쪽에서 이상하게동작해버림
		
		그래서 상속용으로 설계하지않은 클래스는 그냥 상속을 금지하는게 젤 속편함(파이널로 설정하거나,생성자를 프라이빗으로)
		
	6.추상클래스보단 인터페이스를 우선하라
		추상클래스나 인터페이스나 둘다 디폴트메서드를 사용할수있어져서 인스턴스메서드를 구현형태로 제공할수있어졌음
		근데 추상클래스는 반드시 구현하는 클래스가 하위클래스여야해서,제약이 생기는데,인터페이스는 다중상속이 가능함
		그래서 어지간하면 인터페이스를 사용하는게 나음
		
		인터페이스와 추상골격구현클래스를 같이 제공하는식으로 둘의 장점을 모두 가져가는 방법도 있음
		인터페이스로는 타입을 정의하고,필요하면 디폴트메서드몇개도 넣어두고,골격추상클래스는 나머지도 구현하고,핵심부분만 추상메서드로 남겨두는식
		즉 템플릿메서드패턴임
		
	7.인터페이스는 구현하는쪽을 생각해 설계하라
		디폴트메서드를 사용하면,인터페이스에 새로운 메서드를 추가하는게 편해짐,단 이러면 구현클래스에 대한 정보는 전혀없이 추가하는거라,
		기존구현체에 런타임에러를 일으킬수있음(흔하진않음)
		즉,디폴트메서드를 너무믿지말고,인터페이스를설계할땐 세심하게 만들어야함
		
	8.인터페이스는 타입을 정의하는 용도로만 사용하라
		상수인터페이스같은,상수가 들어있고 상수를 받아오기위한 용도로만 사용되는 인터페이스같은건 사용하면안됨
		이건 인터페이스의 영역이 아니라 내부구현의 영역임
		이런건 유틸클래스나,이넘타입의 클래스등으로 공개하는게 맞음
		
	9.태그달린클래스보단 클래스계층구조를 활용하라
		클래스에 이넘이나 TF등으로 태그값이 있는건 매우안좋음
		이경우엔 상속이나 합성등으로 별도의 클래스로 분할하는게 좋음
		즉 이경우엔 서브타이핑을 사용하자
		이땐
			해당 클래스를 포함할 추상클래스를 정의하고
			태그값에 따라 동작이 달라지는 메서드들을 추상메서드로선언
			태그랑 상관없이 동작이 똑같은애들은 추상클래스에서 구현
		이방법으로 계층구조로 변경할수있음
		
	10.멤버클래스는 되도록 static으로 만들라
		중첩클래스는 자신을 감싼 바깥클래스에서만 사용되어야하고,그 외부에서 사용할일이 있으면 별도의 클래스로 분할되어야함
		보통 정적멤버클래스는,바깥클래스와 함께쓰일때만 유용한 도우미클래스로 사용됨
		근데 보통 그러면 외부에서 사용되지않을거면 스태틱을 붙이지 않을 이유가 없음,이걸 붙이지않으면 외부로의 숨은참조를 가지게됨(메모리누수발생가능성)
		
	11.톱레벨 클래스는 한파일에 하나만 담으라
		소스파일 하나에 톱레벨클래스가 여러개 들어갈수있는데,이러면 이득도없고 위험도 있음(컴파일순서에 따른 위험)
		그러니 한파일에 톱레벨 클래스는 하나만 들어가는게 좋음
		
		
5.제네릭		
	1.로타입은 사용하지 마라
		제네릭이 들어온시점에서 컬렉션에서 제네릭이 안붙은타입은 사용할 이유도 없고,사용해서도 안됨
		제네릭을 사용한 컬렉션은,내부에서의 타입이 보장되는데,로타입은 그게 안되기때문
		그래서 로타입을 사용하면,꺼낼때 classCastException이 발생할 확률이 생기니 사용하면안됨
		
		만약 원소의 타입을 몰라도되는 컬렉션을 만들고싶으면(단 추가하진 않고 사용만할때)
			Set<?>
		이렇게 비한정적 와일드카드를 사용하면됨
		이러면 모든타입을 받을수있고, null을 제외한 어떤것도 추가할수없고,출력은 할수있어서 타입안정성을 지킬수있음 
	
	2.비검사 경고를 제거하라
		제네릭을 사용할때,처음쓰면 컴파일러 경고가 막 뜨는데,그걸 하나하나 지워서 전부지우고나면 타입안정성이 보장되게됨
		즉,타입안정성을 확신할수 없는상황이면 컴파일러 경고를 다 지켜서 지워야함,
		보장할수 있으면 그냥 어노테이션(@SuppressWarnings)으로 지워도되긴함
	
	3.배열보단 리스트를 사용하라
		배열에서의 제네릭은,컴파일시점에 날아가기때문에 런타임에서 classCastException가 발생할수 있음
		그래서 리스트제네릭을 사용해야함
		이유는 배열은 공변인데,제네릭은 불공변이기때문
		그래서 서로 잘 어울리지못함
	
	4.이왕이면 제네릭타입으로 만들어라
		제네릭으로 타입을 만드는건 좀 어렵긴한데,만들어두면 쓰기편함
		보통 오브젝트를 사용하고있으면 제네릭으로 바꾸기좋음
		이때 제네릭은 실체화불가능하기때문에 컴파일오류가 뜰텐데
		이때는 오브젝트로 만들고 캐스팅하는식을 자주 사용함(이때는 배열이 기본타입이기때문에 리스트대신 배열을 사용해야함)
		
	5.이왕이면 제네릭메서드로 만들라
		메서드로 제네릭으로 만들수있는데,이떄도 그냥 제네릭써서 만들면됨
		이렇게만들면 클라에서 명시적으로 형변환하는거보다 쓰기도편하고 안전함
		즉 형변화이 필요한 메서드를 제네릭하게 만들면됨
	
	6.한정적 와일드카드를 사용해 api유연성을 높여라
		매개변수화타입은 불공변임
		즉 List<String>는 List<Object>의 하위타입이 아님(리스코프치환원칙)
		이때 명시적으로 하위타입임을 적어서,공변으로 만들수있는데,이땐
			List<? extends E>
		이렇게하면됨
		상위로 올리려면
			List<? super E>
		이렇게하면되고
		즉 유연성이 필요할때 이렇게 사용할수있음
		보통 프로듀서는 extends고,컨슈머는 super을 넣으면됨
		단 반환타입은 한정적와일드카드를 사용하면안됨,그러면 클라코드에서도 와일드카드타입을 써야하기때문
		
		이건 어려우니까 나중에 한번더보자
		
	7.제네릭과 가변인수를 함께쓸때는 신중하라
		가변인수와 제네릭은 서로 잘 어울리지못함
		구현방식에 헛점이 있기때문임
		그래서 힙오염이 발생해,자동생성한 형변환이 흔들리고 타입안정성이 흔들림
		그래서 제네릭리스트를 가변인수로 늘리는건 주의해서 작업해야함
		이거자체는 유용하긴한데,이걸 사용하려면 타입안전을 직접 확인한후에 @SafeVarargs으로 경고를 숨겨야함(즉 책임은 구현자에있음)
		이때,메서드가 배열에 아무것도 저장하지않고,그 배열의 참조가 밖으로 노출되지않으면 타입안전하다고 할수있음
		아니면 그냥 배열대신 리스트를 쓸수있음
		
	8.타입안전 이종컨테이너를 고려하라
		타입을 오브젝트로 아무거나 받을수있게 만들고,해당 타입들을 모아서 사용하고싶다면,
		즉 키밸류로 키를 타입으로 잡고싶다면,타입안전이종컨테이너를 사용할수있음
		이건
			abc(class<T> type,T instance)
			private Map<Class<?>,Object> favMap=new HashMap<>();
		이런식으로 받아서 넣으면됨
		이러면 일단 타입정보도 있으니 classCastException도 터지지않음
		이러면 키가 와일드카드타입이니,모든값을 넣을수있음
		여기서 주의점은
			악의적클라가 로타입으로 넘기면 타입안정성이 쉽게 깨짐
			실체화불가타입에는 사용할수없음,즉 List<String>같은건 저장할수없음(List<String>과 List<Integer>은 컴파일러단에선 같은취급이니)
		이거만 넘기면 편하게 쓸수있음
		
		
6.열거타입과 어노테이션		
		
		
		
	
	
	