1.들어가기
	스킵
2.객체 생성과 파괴
	1.생성자대신 정적팩터리메서드를 고려하라
		퍼블릭생성자대신,정적팩터리메서드를 사용해서 생성자에 이름을 붙이고,하나의 매개인수조합으로 여러종류의 생성자를 만들수있음
		그리고 호출될때마다 인스턴스를 새로생성하는게 아닌,싱글톤같은식으로 만들수있음(플라이웨이트패턴같은느낌)
		가장큰 장점으로,반환타입의 하위반환타입을 반환할수있게됨,그래서 구현클래스를 퍼블릭으로 안만들어도 되게됨		
		자바8이후엔 인터페이스에 정적메서드를 선언할수있어져서 이게 편해졌음
		그래서 입력매개변수에 따라 다른하위구현클래스를 리턴할수있어짐
		그리고 정적팩터리메서드를 작성하는시점에는 반환할객체의 클래스가 존재하지않아도됨
		
		정적팩터리메서드의 단점은,상속을 하려면 퍼블릭이나 프로텍티드생성자가 필요하니,이거만 있으면 하위클래스를 만들수없음
		이경우엔 합성을 사용하는게 좋음
		또한,프로그래머가 정적팩터리메서드를 찾기힘듬(생성자처럼 반드시있어야하는게 아니니)
		그래서 관례에 따라 이름짓는거로 어케하는데 완전히 대체되는건아님
	2.생성자에 매개변수가 많다면 빌더를 고려하라
		이건 코틀린에선 사용하지않던 방식인데,자바에서는 매개변수의 디폴트값이 없기때문에,미리 메서드에 빌더패턴메서드를 넣어두고 빌드하는식으로 자주사용함
		이러면 디폴트값을 사용할수있고,해당 값에 이름을 붙일수있어서 확인이 쉬워짐(순서헷갈릴일도 없고)
		이런 빌더패턴은 계층적으로 설계된 클래스와 함께쓰기가 좋음
		
		보통 매개변수가 많을때 생성자나 정적팩토리대신 빌더를 사용하면 효과적임
	3.private나 enum으로 싱글톤임을 보장하라
		싱글톤은 클라입장에서 테스트하기가 어려워짐(인터페이스를 구현하지않은경우)
		싱글톤을 만들땐,생성자를 프라이빗으로 감춰두고,유일하게 접근할수있는 스태틱멤버를 하나 만들어두고,거기에 주소값을 넘겨주는방식으로 사용함
		이때,퍼블릭필드가 아닌 이넘타입의 싱글톤을 사용하는걸로 리플렉션이나 제2의 인스턴스가 생기는걸 막을수있음
		단 해당 싱글톤이 enum이외의 클래스를 사용해야하면 이건사용할수없음(이중상속안되니까,물론 인터페이스구현은 됨)
	4.인스턴스화를 막으려면 private를 사용해라
		단순히 정적메서드와 정적필드만 담긴 클래스는 별로 좋진않지만,만들어야할때가 있음
		이때는 생성자를 막아서 생성이 안되게하는게 좋음(추상클래스만으로는 하위를 구현하면돼서 막지못함)
		추가적으로 이러면 상속도 막을수있어서 좋음
	5.자원을 직접 명시하지말고 의존객체주입을 사용하라
		자원을 직접 생성하지말고,인터페이스로 변수만 생성하고,생성자를 통해 di받으면 훨씬 더 유연하게 사용할수있음
		이러면 유연성과 테스트가 편해짐
		이방식의 변형으로,생성자에 자원팩토리를 넘겨주는방식이 있음(팩토리메서드패턴)
		이런건 스프링쓰면 편해게해줌
	6.불필요한 객체생성을 피하라
		같은 객체를 여러번 만드는건 효율적이지않음,물론 이건 객체생성비용이 비쌀때의 이야기지(db커넥션같은),쌀땐 걍 가독성만 중심으로 쓰면됨
		일반적으로 재사용해서 문제가 생길확률이,객체생성 더해서 문제생길확률보다 훨씬 크니 알아만두자
	7.다 쓴 객체 참조를 해제하라
		가비지컬렉터도 사용하진않는데 내부에서 참조는 가지고있는애들을 지우진 못함
		그래서 모든것들의 스코프를 최소한으로 잡아서,끝나면 바로 리프레시되게 만드는게 좋고,만약 그럴수없다면 해당참조를 다썼을때 null처리하면됨
		이렇게 null처리하는건 예외적인거여야하고,일반적으론 스코프를 최대한 좁게잡아서 그냥 해당영역이 끝나게하는게 젤 좋음
		보통 메모리누수가 생기는건,자기메모리를 직접 관리하는 클래스나,캐시를 사용하는경우,리스너나 콜백을 사용할경우 그럴수있음
		캐시나 콜백같은경우,weakHashMap같은걸 사용해서 약한참조를 걸어버리는 방법이 주로 사용됨(자리없으면 우선적으로 날려버림)
	8.finalizer나 cleaner의 사용을 피해라
		난 있다는거도 첨알았음,어짜피 안쓰니까 넘어가자
	9.try-finally보단 try-with-resources를 사용하자
		리소스열고 닫을때는,try-with-resources가 try-finally보다 더 깔끔하게 나옴
		이건 해당클래스가 autoCloseable이 구현되어있으면,자동으로 끝나고 리소스를 닫아줌
	
3.모든 객체의 공통 메서드	
	1.equals는 규약을 지켜 재정의하라
		이퀄은 기본적으로는 같은객체인지를 비교하는데,이걸 논리적동치성(필드값이 같은)으로 매핑해야할때가 있음
		이떈 equals을 재정의해야함
		보통 값클래스에서 재정의하는경우가 많음,그리고 값클래스라도 싱글톤일경우엔 할필요가 없음,어짜피 같은거니까
		
		이 이퀄은
			널이 아닐때 널과비교하면 false             널아님
			자기자신과 비교하면 항상 true              반사성
			x,y가 true면 y,x도 true여야함          대칭성
			x,y,z중 x,y가 T y,z가 T면 x,z도 T여야함  추이성
			변경이 없을때 백만번돌려도 값이 다 똑같아야함     일관성
		이라는 조건을 만족해야함
		특히 x,y가 true고 y,x가 true여야한다는건,만약 클래스 2개이상을 비교해야할경우엔,반대편에도 똑같이 작업해줘야한다는것(대칭성)
		그리고 상위클래스에 없는 새로운필드를 하위클래스에 추가했을때,상위클래스와 하위클래스를 비교할때 추이성이 깨지기쉬움
		구체클래스를 확장해서 새값을 추가하며,equals을 만족시킬방법은 없음
		그래서 이런경우 상속대신 합성을 사용해야함
		
		equals을 만들때 구현방법의 순서는
			1.==를 사용해 입력이 자기자신의 참조인지 확인
			2.instanceof로 입력이 올바른타입인지 확인
			3.입력을 올바른타입으로 형변환,instanceof를 썼으니 이건 100%성공함
			4.입력객체와 자기자신의 대응되는 핵심필드가 모두 일치하는지 하나하나체크
		이렇게 구현하면됨
		그리고 마지막에 비교할때,비교가격이 싼거부터 하는게 빨리false치고 나갈수있어서 좋음
		
		그리고 equals을 구현할때,가능하면 간단하게 해결하는게 좋음,별칭같은건 걍 잘라버리는게나음
		그리고 입력타입은 반드시 object로 둬야함(안그러면 오버로딩되버림)
		
		그리고 이런 equals을 자동으로 만들어주는 프레임워크들이 있으니,그거쓰는거도 좋음(autoValue같은)
		그리고 꼭필요한경우가 아니면 재정의안하는게 좋음
	2.equals을 재정의했으면 hashCode도 재정의하라
		이건 반드시 해야함,안그러면 해시를 사용하는 모든곳에서 문제가 생김
		해시코드메서드는 equals을 사용하기때문
		equals로 true가 나왔으면 같은 해시값이 나와야하는데 이게 안되기때문
		그리고 두 객체가 false라면,서로 다른값을 리턴해야함,무조건 다 달라야하는건 아니긴한데 그게 더 성능에좋음
		
		이건
			equals에서 비교한 모든 필드 각각에 대해,type.hashCode(field명)으로 해시코드를 뽑아두고(참조타입이면 책참조)
			result=31*result+현재필드해시값를 반복해서 모든핵심필드에 돌리고,값을뽑아서 리턴
		그러고나서 단위테스트만들어서 돌리면됨
		그리고 이때,equals비교에서 사용하지않은필드는 반드시 빼야함
		
		그리고 해시코드를 뽑는방법을 클라쪽에 공개하면안됨,그러면 의존성생기면 나중에 머리아파짐
	
	3.toString을 항상 재정의하라
		toString은 거의 쓸모없는값을 리턴해줌
		그래서 그 클래스를 표현할수있는 값으로 리턴하면 삶의질이 달라짐
		이때 toString은 그 객체가 가진 주요정보 모두를 반환하는게 좋고,만약 너무크거나 문자열로쓰기 뭐하면,요약정보를 담아야함
	
	4.clone재정의는 주의해서 진행하라
		clone의 규약은 허술해서,깨지기쉬우니 가급적 재정의하지말고 안쓰는게좋음
		그냥 생성자써서 새로만드는게 나음
		보통 복사생성자나 복사팩토리를 사용해서 복사하는게 나음(자기클래스를 매개변수로 받는 생성자)
	
	5.comparable를 구현할지 고려해라
		이건 equals에서 순서까지 비교하는 메서드인 compareTo를 가진 인터페이스임
		즉 이걸 구현하면,그 클래스의 인스턴스에는 순서가 있음을 뜻하고,이걸통해 정렬을 쉽게할수있음
		
		순서가 있는,알파벳,숫자,연대같이 순서가 명확한 값클래스를 작성하면 comparable를 구현하는게 좋음
		이거의 조건의 equals과 거의 똑같은데
		타입이 다른객체가 주어지면 예외를 던지면되고,
		compareTo로 수행한 동치성테스트의 결과가,equals과 같아야함
	
	
4.클래스와 인터페이스	
	
	
	
	
	
	
	
	
	