1.노드 시작하기
	노드js는 주로 서버(클라이언트가 요청하면 응답을해주는프로그램)를 돌리기위해 사용됨
	기본적으로 이벤트기반으로 작동되니까,이벤트리스너에 콜백을 등록해두는식으로 작동함
	기본적으론 동기식으로 작동하지만,setTimeout같은걸 사용해서 비동기식으로 사용할수도있음
	여기서 setTimeout은,n초뒤에 작동하는건데,n초뒤에 태스크큐로 보내고 다시 호출스택으로 가서 동기식으로 작동하는거라,
	호출스택이 이미 차있으면 정확히 n초뒤에 켜진다고 보장할순없음
	이 태스크큐에서 꺼내서 호출스택으로 보내는걸 이벤트루프라고함,루프니까 계속 무한루프돌면서 대기함
	
	이 이벤트루프를 잘 사용하면,비동기처리해도되는것들을 묶어서 한번에 처리해서(i/o같은것들),성능을 올릴수있음
	그리고 동시성은,동시처리가 가능한 작업을 논블로킹해야(비동기처리해야) 얻을수있음
	
	그리고 자바스크립트는 싱글스레드로 동작함
	
	js,즉 노드가 서버에쓰기 좋은건,싱글스레드라서,i/o에 강해서 잘 사용됨
	기본적으로 논블로킹으로 작은데이터를 많이 처리하기 좋으니까
	그리고 json이 자바스크립트형식이라 처리하기쉽다는 장점도있음
	
	
2.알아두어야할 js
1.es6문법
	const,let은 var과 다르게,블럭내에서만 스코프가 동작하는 변수선언임,
	var은 전역스코프를 사용하고
	const는 블록스코프에 상수(한번선언하면 값못바꿈)
	let는 블록스코프에 변수
	
	그리고 `(백틱,1옆에있는거)과 ${}를 사용해서,문자열내에서 변수를 사용할수있음
		`${num}은 숫자다`
	이런식
	
	그리고 객체에 함수를 연결할때
		const abc={
			say(){
				console.log('abc')
			},
			saynode
			[변수+'qqq']:'qwer'
		}
	이런식으로 적고,이미 만들어진 함수면 그냥 나열하는식으로 넣는게가능
	사용할떈
		abc.say()
		abc.saynode()
		abc.변수qqq
	이렇게그냥쓰면됨
	
	화살표함수는 그냥
		const abc=(x,y)=>(x+y) //한줄만쓸땐
		const abc=(x,y)=>{ //여러줄쓸때
			if(){
				...
			}
			return aaa
		}
	이렇게쓰면됨
	화살표함수는 this바인드가 달라짐
	기존 함수내에선 따로 this로 함수를 가리키는 포인터를 받아서 그걸 저장하고 써야했다면(안에서 for문같이 블록써서 스코프달라질경우)
	화살표함수안에선 this가 외부를 그대로 가리키기떄문에,그냥 this를 써도됨,즉 내부스코프가 없음
	
	구조분해할당은,객체나 배열에서 속성이나 요소를 한번에 꺼내는거
		const (getabc,status:{count})=abcmachine
	이렇게하면 객체내의 함수와 값을,같은이름의(getabc와 count라는이름의)변수에 저장함
	즉
		const getabc=abcmachine.getabc
	와 같음
	단,구조분해할당을 사용하면,this의 스코프가 달라지니까,만약 this를 사용하면 bind등을 사용해야함
	
	배열을 구조분해할땐 딴데랑 똑같이 갯수맞춰서
		const [a,b,,c]=array
	하면 4개짜리로 나눠서 들어감
	
	그리고 es6부터는 클래스문법도 지원함,단 프로토타입으로 동작하는건 똑같고 그냥 외형상 클래스로 바꾼거
	
	프로미스는,비동기식으로 동작하는 함수임
	그냥 함수를 진행하다가 성공,실패로 나눠서 기입하고(resolve,reject)
	거기따라서 비동기식으로 진행하다가 성공,실패따라서 다른결과나오는거
	이거도 try,catch,finally랑 같은식으로 진행됨
	리턴값은 resolve와 reject의 값을 받으면됨
		const abc=new Promise((resolve,reject))=>{
			if (t/f){
				resolve('T')
			}else{
				reject('F')
			}
		}
		abc.then((message)=>{
			console.log(message)
		}).catch((error)=>{
			console.error(error)
		}).finally(()=>{
			console.log(message)
		})
	이런식으로 그냥 비동기함수를 성공실패로 나눠서 동작함
	즉,resolve가 호출되면 then,reject가 호출되면 catch가 작동하는식
	그리고 프로미스는,선언되자마자 바로 동작함,즉 밑에서 then은 결과값을 받는거고 일단 실행은 위의 abc선언부터 바로실행됨
	그리고 프로미스안에 프로미스를 선언하고,리턴한다음 그걸 바로 then으로 붙여나갈수도 있음
	이러면 이전 then의 리턴값을 다음then의 매개변수로 넘김
	이걸 사용해서 콜백을 프로미스로 바꿀수있음
	이렇게했을땐,마지막에 캐치하나써서 모든 에러를 거기서 한번에 처리할수있음
	
	그리고 promise.all([pro1,pro2]).then
	으로 여러개를 한번에 실행할수도있음
	이경우엔,모두 결과값이 나올때까지 기다렸다가,다 나오면 그걸 배열로 리턴함,만약 하나라도 reject가 있으면 catch로 가고
	
	async/await는 프로미스가 then catch로 길어지니까,그걸 해결하기위해 나온 비동기기능임
	그냥 프로미스에서 엑시큐터(실제실행함수)부분만 남기고 나머지 다없애고 함수앞에 async붙이면 똑같이동작함
	그리고 async의 리턴값은 무조건 프로미스임,그래서 명시적으로 하고싶으면 promise를 붙여도되지만,동작은똑같음
	async함수를 선언하고,프로미스앞에 await를 붙이면 됨,그리고 catch를 하기위해,try catch로 딴언어랑 똑같이 싸면됨
	이러면 await와 await사이가 기존 then이 됨
	즉 await가 끝날때까지 기다렸다가 다음거로 진행함,즉 비동기사이에서 동기적으로 진행할수있는거
	비동기로 처리하고 그걸 다 받을때까지 기다렸다가 실행하는 게이팅패턴을 사용하고싶으면,
	프로미스들을 배열에 받은뒤에 그걸 await+ promise.all로 실행하는식으로 처리할수있음
	만약 한줄한줄 await를 사용하면(반복문에 넣는거도 포함해서),안에서 전부 동기식으로 처리해버리니까 하는의미가없어짐
	이걸 비동기끼리 묶어서 동시에 실행하고싶으면,promise.all써야함
	즉 await를 사용하면,코드가 알아보기 엄청편해짐
	그리고 for문과 같이 사용해서,프로미스를 순차적으로 실행할수도 있음
		(async()=>{
			for await (promisere of [pro1,pro2]){
				console.log(promisere)
			}
		})
	이런식

2.프런트엔드 js
	ajax(비동기웹)을 사용해서 restapi를 사용할때도 프로미스로 보내면됨
		axios.get(http://주소).then((result)=>{
			...
			console.log(result)
			console.log(result.data)
		}).catch((error)=>{
			...
			console.error(error)
		})
	이런식임
	프로미스니까 그냥 async/await로 바꿀수있음
		(async()=>{
			try{
				const result=await axios.get(http://주소)
				console.log(result)
				console.log(result.data)
			}
			catch{
				console.error(error)
			}
		})();
	post는
		(async()=>{
			try{
				const result=await axios.post(http://주소,{json값들})
				console.log(result)
				console.log(result.data)
			}
			catch{
				console.error(error)
			}
		})();	
	이렇게 보내면됨
	
	
	formdata는,html form태그 데이터를 동적으로 제어함,보통 ajax와 같이 사용됨
	먼저 formdata는
		append
		has
		get
		getall
		delete
	메서드를 가지고있음
	얘는 append로 키-값형식으로 저장하고(abc.append('name','aa')),키값이니까 같은키에 여러값이 들어갈수도 있음
	그리고 has로 그 키에 값이있나 확인하고,get으로 키에해당하는값 하나를 받고,getall로 키에해당하는값 전체를 받음
	delete로 키를 삭제,set으로 현재키 수정
	이걸 post같은데서 매개변수로 받아서 거기에 해당하는걸 할수있음
	
	그리고 ajax요청을 보낼때,주소에 한글이 들어가면
	백틱을 써서 
		`앞주소${encodeURIcomponent('한글문자')}`
	를 사용해서 16진수로 바꾸고
		decodeURIcomponent('16진수')
	로 다시 돌릴수있음

	프런트엔드로 값을 넘길때 사용되는 공식방식이 데이터속성임
	html태그의 속성으로 data-이름='값'으로
		<li data-id="1" data-user-job="pro"  />
	이런식으로 던져주면
	id,userJob 이렇게 자바스크립트에서 사용할수있어짐
		<script>
			console.log(document.querySelector('li').dataset)
			document.querySelector('li').dataset.money=1000
			
		</script>
	이렇게 꺼내쓸수있고,dataset.이름=값 으로 삽입도 가능함 (dataset.money=1000은 data-money="1000")
	
	
	
3.노드기능
	기본적으로 cmd에서 node치면 repl(읽고해석하고리턴 루프),즉 일반입력모드로 동작함
	파일로 실행하고싶으면 파일만들고 node 파일경로하면 됨,js는 생략해도됨
1.모듈	
	노드js에선 코드를 모듈로 만들수있음,즉 코드를 모듈로 만들어서 다른코드에서 임포트해서 사용할수있음
	일반적으론 파일단위로 파일하나가 모듈하나가 됨
	
	이때
		module.exports={
			odd,even//함수나 변수,상수
		}
	
	저안에 있는거만 가져다쓸수있음
	아니면
		exports.odd='문자열'
	이런식으로 변수를 바로 던질수도있음
	이경우엔 반드시 객체처럼 이름과 값을 대입해야함,그래서 함수의경우는 저렇게할수없음
	사용할땐
		const {odd,even}=require('./경로')
		console.log(odd)
	이런식으로 사용하면됨
2.노드 내장 객체
	global은 브라우저의 window같은 전역객체임
	전역객체라서 모든파일에서 접근할수있고,global을 생략해도됨
	console같은경우도 global.console인데 글로벌생략한거
	
	그리고 전역객체라는걸 이용해서,모듈간에 데이터를 공유할수있긴한데,아무리봐도 안티패턴인듯,이렇게하면 나중에못찾을거같음
	그냥 값가져와야하면 모듈형식으로 명시적으로 값을불러와서 사용하는게 좋을거같음
	
	console에서 time과 timeend로 그 사이의 시간을 잴수있고,table에 배열넣으면 테이블형태로 표현해줌
	dir은 객체를 콘솔에 표시해줌
	
	타이머로는 setTimeout,setInterval,setImmediate가 있음
	셋타임아웃은 명시된 시간이 지난후에 콜백함수를 실행큐에 넣고,
	셋인터벌은 명시된 시간동안 반복적으로 콜백함수를 실행큐에 넣음
	setimmediate는 즉시 콜백함수를 실행함
	타이머를 취소할땐,각각 clearTimeout(아이디),clearInterval(아이디),clearImmediate(아이디)로 취소할수있음
	저 아이디는,그 타이머가 들어있는 상수나변수를 넣으면됨(일반적으로 js는 함수를 변수에담아 실행하니까)
	
	노드js에서 __filename과 __dirname은 현재파일명(파일명과 경로를 합쳐서나옴)과 현재파일경로를 리턴하는 키워드임
	
	그리고 노드에서 최상위 this는 module.exports를 가리키고,함수내부에서의 this는 글로벌객체를 가리킴
	
	노드js에서도 호이스팅이 일어나니까,require이 최상단에 반드시 있어야하지않고,exports도 최하단에 있어야하지않음
	그리고 require.cache에는 파일이름,경로등이 들어있음
	require.main은 노드실행시 첫 모듈을 가리킴,즉 처음시작한객체를 가리킴
	현재파일이 첫모듈(node 파일명 으로 시작한모듈)인지 알려면,require.main===module을 하면 알수있음
	첫 모듈의 이름은 require.main.filename으로 확인하면됨
	
	그리고 순환참조(서로를 모듈로 부르는것)가 일어나면,에러가 안뜨고 순환참조대상을 그냥 빈객체로 만들어버리니 조심해야함
	
	process객체는 현재 실행되는 노드프로세스정보를 가지고있음,즉 현재cpu사용량,플랫폼등을 확인할수있음
	process.env는 환경변수를 부르고,바꿀수있음
	process.nextTick은 이벤트루프가 다른콜백보다 이걸 우선처리하게 바꿀수있음,이러면 setImmediate나 타임아웃보다 먼저실행됨(동시라고해도)
	process.exit는 실행중인 노드 프로세스를 종료함,서버에선 안쓰고(그냥끄면되니까),일반프로그램에서 수동으로멈출때 사용함
	process.exit(0)은 정상종료,1은 비정상종료
	
	
3.노드내장모듈사용	
	
	
	
	
	
	
	
	
	
	
	
	
	

	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	