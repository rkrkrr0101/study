1.노드 시작하기
	노드js는 주로 서버(클라이언트가 요청하면 응답을해주는프로그램)를 돌리기위해 사용됨
	기본적으로 이벤트기반으로 작동되니까,이벤트리스너에 콜백을 등록해두는식으로 작동함
	기본적으론 동기식으로 작동하지만,setTimeout같은걸 사용해서 비동기식으로 사용할수도있음
	여기서 setTimeout은,n초뒤에 작동하는건데,n초뒤에 태스크큐로 보내고 다시 호출스택으로 가서 동기식으로 작동하는거라,
	호출스택이 이미 차있으면 정확히 n초뒤에 켜진다고 보장할순없음
	이 태스크큐에서 꺼내서 호출스택으로 보내는걸 이벤트루프라고함,루프니까 계속 무한루프돌면서 대기함
	
	이 이벤트루프를 잘 사용하면,비동기처리해도되는것들을 묶어서 한번에 처리해서(i/o같은것들),성능을 올릴수있음
	그리고 동시성은,동시처리가 가능한 작업을 논블로킹해야(비동기처리해야) 얻을수있음
	
	그리고 자바스크립트는 싱글스레드로 동작함
	
	js,즉 노드가 서버에쓰기 좋은건,싱글스레드라서,i/o에 강해서 잘 사용됨
	기본적으로 논블로킹으로 작은데이터를 많이 처리하기 좋으니까
	그리고 json이 자바스크립트형식이라 처리하기쉽다는 장점도있음
	
	
2.알아두어야할 js
1.es6문법
	const,let은 var과 다르게,블럭내에서만 스코프가 동작하는 변수선언임,
	var은 전역스코프를 사용하고
	const는 블록스코프에 상수(한번선언하면 값못바꿈)
	let는 블록스코프에 변수
	
	그리고 `(백틱,1옆에있는거)과 ${}를 사용해서,문자열내에서 변수를 사용할수있음
		`${num}은 숫자다`
	이런식
	
	그리고 객체에 함수를 연결할때
		const abc={
			say(){
				console.log('abc')
			},
			saynode
			[변수+'qqq']:'qwer'
		}
	이런식으로 적고,이미 만들어진 함수면 그냥 나열하는식으로 넣는게가능
	사용할떈
		abc.say()
		abc.saynode()
		abc.변수qqq
	이렇게그냥쓰면됨
	
	화살표함수는 그냥
		const abc=(x,y)=>(x+y) //한줄만쓸땐
		const abc=(x,y)=>{ //여러줄쓸때
			if(){
				...
			}
			return aaa
		}
	이렇게쓰면됨
	화살표함수는 this바인드가 달라짐
	기존 함수내에선 따로 this로 함수를 가리키는 포인터를 받아서 그걸 저장하고 써야했다면(안에서 for문같이 블록써서 스코프달라질경우)
	화살표함수안에선 this가 외부를 그대로 가리키기떄문에,그냥 this를 써도됨,즉 내부스코프가 없음
	
	구조분해할당은,객체나 배열에서 속성이나 요소를 한번에 꺼내는거
		const (getabc,status:{count})=abcmachine
	이렇게하면 객체내의 함수와 값을,같은이름의(getabc와 count라는이름의)변수에 저장함
	즉
		const getabc=abcmachine.getabc
	와 같음
	단,구조분해할당을 사용하면,this의 스코프가 달라지니까,만약 this를 사용하면 bind등을 사용해야함
	
	배열을 구조분해할땐 딴데랑 똑같이 갯수맞춰서
		const [a,b,,c]=array
	하면 4개짜리로 나눠서 들어감
	
	그리고 es6부터는 클래스문법도 지원함,단 프로토타입으로 동작하는건 똑같고 그냥 외형상 클래스로 바꾼거
	
	프로미스는,비동기식으로 동작하는 함수임
	그냥 함수를 진행하다가 성공,실패로 나눠서 기입하고(resolve,reject)
	거기따라서 비동기식으로 진행하다가 성공,실패따라서 다른결과나오는거
	이거도 try,catch,finally랑 같은식으로 진행됨
	리턴값은 resolve와 reject의 값을 받으면됨
		const abc=new Promise((resolve,reject))=>{
			if (t/f){
				resolve('T')
			}else{
				reject('F')
			}
		}
		abc.then((message)=>{
			console.log(message)
		}).catch((error)=>{
			console.error(error)
		}).finally(()=>{
			console.log(message)
		})
	이런식으로 그냥 비동기함수를 성공실패로 나눠서 동작함
	즉,resolve가 호출되면 then,reject가 호출되면 catch가 작동하는식
	그리고 프로미스는,선언되자마자 바로 동작함,즉 밑에서 then은 결과값을 받는거고 일단 실행은 위의 abc선언부터 바로실행됨
	그리고 프로미스안에 프로미스를 선언하고,리턴한다음 그걸 바로 then으로 붙여나갈수도 있음
	이러면 이전 then의 리턴값을 다음then의 매개변수로 넘김
	이걸 사용해서 콜백을 프로미스로 바꿀수있음
	이렇게했을땐,마지막에 캐치하나써서 모든 에러를 거기서 한번에 처리할수있음
	
	그리고 promise.all([pro1,pro2]).then
	으로 여러개를 한번에 실행할수도있음
	이경우엔,모두 결과값이 나올때까지 기다렸다가,다 나오면 그걸 배열로 리턴함,만약 하나라도 reject가 있으면 catch로 가고
	
	async/await는 프로미스가 then catch로 길어지니까,그걸 해결하기위해 나온 비동기기능임
	그냥 프로미스에서 엑시큐터(실제실행함수)부분만 남기고 나머지 다없애고 함수앞에 async붙이면 똑같이동작함
	그리고 async의 리턴값은 무조건 프로미스임,그래서 명시적으로 하고싶으면 promise를 붙여도되지만,동작은똑같음
	async함수를 선언하고,프로미스앞에 await를 붙이면 됨,그리고 catch를 하기위해,try catch로 딴언어랑 똑같이 싸면됨
	이러면 await와 await사이가 기존 then이 됨
	즉 await가 끝날때까지 기다렸다가 다음거로 진행함,즉 비동기사이에서 동기적으로 진행할수있는거
	비동기로 처리하고 그걸 다 받을때까지 기다렸다가 실행하는 게이팅패턴을 사용하고싶으면,
	프로미스들을 배열에 받은뒤에 그걸 await+ promise.all로 실행하는식으로 처리할수있음
	만약 한줄한줄 await를 사용하면(반복문에 넣는거도 포함해서),안에서 전부 동기식으로 처리해버리니까 하는의미가없어짐
	이걸 비동기끼리 묶어서 동시에 실행하고싶으면,promise.all써야함
	즉 await를 사용하면,코드가 알아보기 엄청편해짐
	그리고 for문과 같이 사용해서,프로미스를 순차적으로 실행할수도 있음
		(async()=>{
			for await (promisere of [pro1,pro2]){
				console.log(promisere)
			}
		})
	이런식

2.프런트엔드 js
	ajax(비동기웹)을 사용해서 restapi를 사용할때도 프로미스로 보내면됨
		axios.get(http://주소).then((result)=>{
			...
			console.log(result)
			console.log(result.data)
		}).catch((error)=>{
			...
			console.error(error)
		})
	이런식임
	프로미스니까 그냥 async/await로 바꿀수있음
		(async()=>{
			try{
				const result=await axios.get(http://주소)
				console.log(result)
				console.log(result.data)
			}
			catch{
				console.error(error)
			}
		})();
	post는
		(async()=>{
			try{
				const result=await axios.post(http://주소,{json값들})
				console.log(result)
				console.log(result.data)
			}
			catch{
				console.error(error)
			}
		})();	
	이렇게 보내면됨
	
	
	formdata는,html form태그 데이터를 동적으로 제어함,보통 ajax와 같이 사용됨
	먼저 formdata는
		append
		has
		get
		getall
		delete
	메서드를 가지고있음
	얘는 append로 키-값형식으로 저장하고(abc.append('name','aa')),키값이니까 같은키에 여러값이 들어갈수도 있음
	그리고 has로 그 키에 값이있나 확인하고,get으로 키에해당하는값 하나를 받고,getall로 키에해당하는값 전체를 받음
	delete로 키를 삭제,set으로 현재키 수정
	이걸 post같은데서 매개변수로 받아서 거기에 해당하는걸 할수있음
	
	그리고 ajax요청을 보낼때,주소에 한글이 들어가면
	백틱을 써서 
		`앞주소${encodeURIcomponent('한글문자')}`
	를 사용해서 16진수로 바꾸고
		decodeURIcomponent('16진수')
	로 다시 돌릴수있음

	프런트엔드로 값을 넘길때 사용되는 공식방식이 데이터속성임
	html태그의 속성으로 data-이름='값'으로
		<li data-id="1" data-user-job="pro"  />
	이런식으로 던져주면
	id,userJob 이렇게 자바스크립트에서 사용할수있어짐
		<script>
			console.log(document.querySelector('li').dataset)
			document.querySelector('li').dataset.money=1000
			
		</script>
	이렇게 꺼내쓸수있고,dataset.이름=값 으로 삽입도 가능함 (dataset.money=1000은 data-money="1000")
	
	
	
3.노드기능
	기본적으로 cmd에서 node치면 repl(읽고해석하고리턴 루프),즉 일반입력모드로 동작함
	파일로 실행하고싶으면 파일만들고 node 파일경로하면 됨,js는 생략해도됨
1.모듈	
	노드js에선 코드를 모듈로 만들수있음,즉 코드를 모듈로 만들어서 다른코드에서 임포트해서 사용할수있음
	일반적으론 파일단위로 파일하나가 모듈하나가 됨
	
	이때
		module.exports={
			odd,even//함수나 변수,상수
		}
	
	저안에 있는거만 가져다쓸수있음
	아니면
		exports.odd='문자열'
	이런식으로 변수를 바로 던질수도있음
	이경우엔 반드시 객체처럼 이름과 값을 대입해야함,그래서 함수의경우는 저렇게할수없음
	사용할땐
		const {odd,even}=require('./경로')
		console.log(odd)
	이런식으로 사용하면됨
2.노드 내장 객체
	global은 브라우저의 window같은 전역객체임
	전역객체라서 모든파일에서 접근할수있고,global을 생략해도됨
	console같은경우도 global.console인데 글로벌생략한거
	
	그리고 전역객체라는걸 이용해서,모듈간에 데이터를 공유할수있긴한데,아무리봐도 안티패턴인듯,이렇게하면 나중에못찾을거같음
	그냥 값가져와야하면 모듈형식으로 명시적으로 값을불러와서 사용하는게 좋을거같음
	
	console에서 time과 timeend로 그 사이의 시간을 잴수있고,table에 배열넣으면 테이블형태로 표현해줌
	dir은 객체를 콘솔에 표시해줌
	
	타이머로는 setTimeout,setInterval,setImmediate가 있음
	셋타임아웃은 명시된 시간이 지난후에 콜백함수를 실행큐에 넣고,
	셋인터벌은 명시된 시간동안 반복적으로 콜백함수를 실행큐에 넣음
	setimmediate는 즉시 콜백함수를 실행함
	타이머를 취소할땐,각각 clearTimeout(아이디),clearInterval(아이디),clearImmediate(아이디)로 취소할수있음
	저 아이디는,그 타이머가 들어있는 상수나변수를 넣으면됨(일반적으로 js는 함수를 변수에담아 실행하니까)
	
	노드js에서 __filename과 __dirname은 현재파일명(파일명과 경로를 합쳐서나옴)과 현재파일경로를 리턴하는 키워드임
	
	그리고 노드에서 최상위 this는 module.exports를 가리키고,함수내부에서의 this는 글로벌객체를 가리킴
	
	노드js에서도 호이스팅이 일어나니까,require이 최상단에 반드시 있어야하지않고,exports도 최하단에 있어야하지않음
	그리고 require.cache에는 파일이름,경로등이 들어있음
	require.main은 노드실행시 첫 모듈을 가리킴,즉 처음시작한객체를 가리킴
	현재파일이 첫모듈(node 파일명 으로 시작한모듈)인지 알려면,require.main===module을 하면 알수있음
	첫 모듈의 이름은 require.main.filename으로 확인하면됨
	
	그리고 순환참조(서로를 모듈로 부르는것)가 일어나면,에러가 안뜨고 순환참조대상을 그냥 빈객체로 만들어버리니 조심해야함
	
	process객체는 현재 실행되는 노드프로세스정보를 가지고있음,즉 현재cpu사용량,플랫폼등을 확인할수있음
	process.env는 환경변수를 부르고,바꿀수있음
	process.nextTick은 이벤트루프가 다른콜백보다 이걸 우선처리하게 바꿀수있음,이러면 setImmediate나 타임아웃보다 먼저실행됨(동시라고해도)
	process.exit는 실행중인 노드 프로세스를 종료함,서버에선 안쓰고(그냥끄면되니까),일반프로그램에서 수동으로멈출때 사용함
	process.exit(0)은 정상종료,1은 비정상종료
	
	
3.노드내장모듈사용	
	1.os모듈
		os모듈은 컴퓨터의 운영체제정보를 가져옴,즉 process와 역할이 겹침
		일반적으로 사용할일이 별로없긴할듯
	2.path
		path는 경로조작을 도와줌
			path.dirname //파일의 경로
			path.extname//파일의 확장자
		등을 리턴받을수있음
			path.join //여러경로를 합침('/a','/b','/c')-> /a/b/c
		
	3.url
		웹주소를 쉽게 조작하게 도와주는모듈
		방식이 채신식인 whatwg와 그냥 구url이 있는데,whatwg가 처리할수없는(host가 없이 pathname이 있는)거도 있어서,
		이런건 그냥url로 처리해야함
		whatwg는 search를 searchParams이라는 객체로 반환해줘서 유용하긴함
			const a=url.parse('주소') //주소를 분해해서 키값배열에 넣어줌
			url.format//분해된 주소를 합쳐서 문자열로 바꿔줌
		
		searchParams은,각 쿼리를 각각 나누고,그 키를 키-값형식으로 배열에 저장함
		그리고 getall(키)로 전부 가져오거나,has,keys,values등으로 뽑아낼수있음
		
		기존 url을 사용할땐,querystring를 사용하면 search부분을 객체로 만들어서 사용할수있음
		
	4.crypto
		이건 다양한방식으로 암호화를 해줌,이건 기본적으로 따로 뭐안해도 멀티스레드로 동작함
		여긴 단방향암호화(복호화불가능암호화),양방향암호화(키를사용해서복호화)가 있음
		단방향암호화는 패스워드를 저장할때 사용하고,양방향은 서로 데이터주고받을때 사용함(ssh정리참조)
		
		단방향은 해시를 사용해서 암호화함,이떄 막 10만번반복하는식으로해서 연관성을 없애버림
			crypto.pdkdf2(해시화문자열,기준문자열(해시키),반복횟수,출력바이트,해시알고리즘)
		
		양방향은 키를 사용해서 복호화를 할수있음
			a=crypto.createCipheriv(알고리즘,키,iv(초기화백터값))
			re=cipher.update(암호화문장,입력인코딩,출력인코딩)
			re+=a.final('re의 인코딩값') //암호화끝
			
			dec=crypto.createDecipheriv(알고리즘,키,iv)
			re2=dec.update(re,입력인코딩,출력인코딩)
			re2=dec.final('re2출력인코딩값')
		이렇게 암호화복호화를 할수있음	
	5.util
		각종 유틸기능이 들어감
			util.deprecate//함수가 deprecated됐다고 경고함
			utol.promisify//콜백을 프로미스로 바꿔줌
	
	6.worker_threads
		멀티스레드로 작업할때 사용함
		isMainThread로 메인스레드인지 아닌지 확인할수있고,
		new Worker로 워커를 생성하고,
		worker.postMessage로 부모에서 워커로 메세지를 보낼수있고,parentPort.postMessage로 부모에게 메세지보낼수있음
		받을땐 worker.on(메세지명)으로 부모는 받고,parentPort.on(메세지명)으로 워커는 받을수있음
		워커의경우 on하고나서 받았으면 close로 워커를 명시적으로 닫아줘야함,안그럼 안꺼짐
		
		멀티스레딩에서 제일어려운건,일을 나누는거임
	
	7.child_process
		이건 노드에서 다른프로그램을 실행하거나,cmd를 돌릴떄 사용함
			const exec=require('child_process').exec
			const process= exec('명령어')
		이런식으로 명령어를 실행함
		다른프로그램을 실행할떈
			const spawn = require('child_process').spawn
			constpro=spawn('python',['파일명.py'])
		이렇게 명령어와 실행파일을 주면됨
		exec와 spawn의 차이는,셸을 실행하냐 아니면 프로세스를 실행하냐의 차이임

4.파일시스템
	fs모듈은 파일시스템에 접근하는 모듈임
	기본적으로 웹에서는 fs를 사용한 접근이 금지되어있음
	이거도 사용법은
		fs require하고
		fs.readfile('경로',(err,data)=>{
			if (err){
				에러처리
			}
			console.log(data.tostring())
		})
	이런식으로 사용하면됨
	tostring을 안붙이면,메모리값이 나오니까 붙여야함
	기본적으로 콜백으로 나오니까 프로미스로 바꾸려면
		const fs = require('fs').promises;
		fs.readfile('./readfile.txt')
		.then((data)=>{
			console.log(data.tostring())
		})
		.catch((err)=>{
			에러처리
		})
	이렇게하면됨,이러면 프로미스기반의 모듈로 연결해줌
	쓸때도 똑같이
		fs.writefile('경로','문자열')
		.then(()=>{
			return fs.readFile('경로')//옵션,적은거보여주려면
		}).catch 예외처리
	이런식으로 적을수있음
	
	기본적으로 비동기로 동작해서,i/o의 순서는 자기맘대로동작함
	순서대로 하고싶으면
		fs.readFileSync
	를 사용하면됨,근데 io에서 사용할일이 별로없을듯
	만약 비동기로하되 비동기끼리 순서를 유지하고싶으면
		const fs = require('fs').promises;
		fs.readfile('./readfile.txt')
		.then((data)=>{
			console.log(data.tostring())
		})
		.then((data)=>{
			console.log(data.tostring())
		})
	이런식으로 다음then을 붙이면 저건 동기적으로 처리됨
	
	
	그리고 파일을 읽고쓸떈 버퍼와 스트림방식이 있음
	버퍼는 파일의 크기만큼 메모리에 자리를 만들어두고,사용하는식이고,사용법은
		a=Buffer.from('문자열')//버퍼로바꾸기
		a.concat()//버퍼문자열로 바꾸기
		b=buffer.alloc(바이트크기)//바이트크기만큼 빈버퍼생성
		
	이렇게 할수있음
	버퍼는 편하긴한데,문제가 무조건 파일크기만큼을 비워야하니까 막 1기가넘는파일을 전송할때,그걸 메모리에 올리고 그래야함
	그래서 나온게 스트림임
	이건 버퍼를 쪼개서 여러번으로 나눠보내는거,이때 나눠진조각을 청크라고 함
	파일읽기의사용법은
		rs=fs.createReadStream('파일경로',{highWaterMark:16})//16은 청크의 크기,기본값은 64kb
		const data=[]
		rs.on('data',(chunk)=>{ //데이터전송중일때
			data.push(chunk)
			
		})
		rs.on('end',()=>{ //데이터전송완료후 버퍼를 합침
			console.log(Buffer.concat(data).tostring())
		})
		rs.on('error',(err)=>{
			에러처리
		})
	이렇게 이벤트식으로 데이터전송,완료,에러 3개로 나눠서 동작함,rs.on의 첫번째 매개변수가 이벤트리스너임,data,err,end를 보통 사용함
	파일쓰기는
		const ws=fs.createWriteStream('경로')
		ws.on('finish',()=>{
			완료시 이벤트
		})
		ws.write('적을내용1')
		ws.write('적을내용2')
		ws.end()//스트림저장하고 완료이벤트출력
	이렇게함
	읽은걸 바로쓸수도있는데,이걸 파이프라고부름
		rs.pipe(ws)
	이렇게하면 읽은걸 바로 라이트로 던짐
	그리고 스트림사이에 계속연결되니까,읽고,압축하고 던지려면
		rs.pipe(zs).pipe(ws) //zs는 압축모듈,zlib모듈(zlib.createGzip)
	이렇게하면 읽어서 압축하고 던짐
	
	스트림을 사용하면 정해진량만큼의 메모리밖에 점유하지않아서,메모리오버나서 문제될일이 없어짐
	
	
	fs에는 저거말고도 뭐 디렉토리가 있는지확인,폴더생성,파일오픈,이름바꾸기,파일삭제(없으면에러남),폴더삭제(폴더비어있지않으면에러)등등 메서드가 있음
	그리고 fs는 기본적으로 스레드로 동작함
	
5.이벤트 이해
	이벤트를 직접 생성할떈,events모듈의 EventEmitter()을 사용하면됨
		const me= new EventEmitter()
		me.addListener('event1',()=>{ //이벤트이름과 액션을 연결
			console.log('이벤트1')
		})
		me.on('event1',()=>{ //이벤트이름과 액션을 연결,addListener와 같음
			console.log('이벤트1')
		})
		me.once('event1',()=>{ //이벤트이름과 액션을 연결,이벤트가 한번만 발생,한이벤트에 여러개가 묶일수있음
			console.log('이벤트1')
		})	
		me.emit('이벤트명')//이벤트호출
		me.removeAllListeners('이벤트명')//이벤트명의 모든 이벤트를 삭제함
		const li=()=>{
			이벤트내용
		}
		me.on('이벤트명2',li)//이벤트와 리스너연결
		me.removeListeners('이벤트명',리스너변수)//이벤트에서 특정리스너제거
		me.off('이벤트명',리스너변수)//removeListeners와 같음
		me.listenerCount('이벤트명')//이벤트에 연결된 리스너갯수리턴
	
	
6.예외처리
	서버에선 예외처리가 매우중요함,예외떠서 서버멈추면안됨
	기본적으론 try,catch로 잡으면됨
	보통 노드내장모듈은 자체적으로 try catch해주긴하지만,기본적으로 넣어야함
	
	프로미스는 일단 에러를 알아서 처리해주긴하는데,그래도 항상 catch를 붙여주는게좋음
	
	그리고
		process.on('uncaughtException',(err)=>{
			에러처리
		})
		
	이렇게 이벤트처리를 하면,만약 예기치못한에러가 떠도 일단 처리는해주는데,당연히 다음코드가 정상동작한다는 보증이 없어지니까,정 답이없을때만 써야함
	즉 저건 단순히 에러내용을 저장하는용도로만 쓰고,기록하고 바로 exit로 프로세스종료하는게 좋음
	
	
	
	
	
4.http모듈로 서버만들기	
1.요청과 응답이해
	기본적으로 서버를 돌릴땐
		http 임포트
		http.createServer((req,res)=>{
			응답내용
		})
	이렇게하면 됨
	req에는 요청정보,res에는 응답정보가 담김
	즉
		http 임포트
		http.createServer((req,res)=>{
			res.wirteHead(200,{'Content-type':'text/html; charset=utf-8'})
			res.write('<h1>Hello Node</h1>')
			res.end('<p>Hello Server</p>')
		})
		.listen(8080,()->{
			console.log('8080포트대기')
		})
	이렇게하면 8080포트가 열리고,로컬호스트 :8080으로 접근할수있음
	그러면 저 헬로우노드 헬로서버가 나옴
	
	즉 createServer에서 응답내용을 명시하고,
	그걸 listen으로 열어주면 거기적힌포트로 접근하면 크리에이트서버의 이벤트가 발생해서 응답을 하게됨
	
	그리고 listen에 콜백함수를 넣는거대신,
		server.listen(8080)
		server.on('listening',()=>{
			console.log('8080포트대기')
		})
		server.on('error',(error)=>{
			console.error(error)
		})
	이렇게 이벤트리스너를 붙일수도있음
	
	한번에 여러서버를 쓸때도,크리에이트서버를 여러개하고 포트만다르게해서 listen하면됨
	그리고 매번 html을 일일히 적을수없으니까,그냥 파일에 만들고 파일던지는게 좋음
		http.createServer(async (req,res)=>{
			try{
				const data=await fs.readFile('./html파일명')
				res.wirteHead(200,{'Content-type':'text/html; charset=utf-8'})
				res.end(data)
			} catch(err){
				console.error(error)
				res.wirteHead(500,{'Content-type':'text/html; charset=utf-8'})
				res.end(err.message)
			}
		})
		.listen(8080,()->{
			console.log('8080포트대기')
		})		
	이렇게 파일로 던지고,못읽을수도있으니까 못읽으면 에러던지면됨(일단 무조건 응답을 보내긴해야함,안그럼 타임아웃까지 기다려야하니까)
	
2.rest와 라우팅 사용하기
	restapi를 사용해서,rest메서드와(get,post등)과 주소와 쿼리+데이터를 보내면,그걸 받아서 라우팅하는방식으로 동작시킬수있음
	대충 if문을 사용하면됨
		http 임포트
		http.createServer(async(req,res)=>{
			if (req.method==='GET'){
				if(req.url === '/'){
					res.wirteHead(200,{'Content-type':'text/html; charset=utf-8'})
					res.write('<h1>Hello Node</h1>')
					return res.end('<p>Hello Server</p>')
				}
				else if (req.url==='/about'){
					const data= await fs.readFile('./about.html')
					res.wirteHead(200,{'Content-type':'text/html; charset=utf-8'})
					return res.end(data) //end자체만으론 함수가안끝나니까 return붙여야함
				}
				try{ // /도 /about도 아니면 
					const data = await fs.readFile(`.${req.url}`)
					return res.end(data)
				}catch(err){
					//404에러발생
				}
			}
			res.wruteHead(404)

		})
		.listen(8080,()->{
			console.log('8080포트대기')
		})	
	대충 이렇게던지면되는데,물론 전체를 싸는 try catch(500에러)도 있긴해야하지만
	post의 경우엔(delete,put등도 포함해서)
		req.method
			req.url
				let body=''
				req.on('data',(data)=>{
					body+=data
				})
				return req.on('end',()=>{
					const{name}=JSON.parse(body)
					const id=Date.now()
					users[id]=name
					res.writeHead(201)
					res.end('등록성공')
				})
	이런식으로 스트림으로 받아서 json으로 넣으면됨,기본적으로 req와 res도 스트림형식이라서,스트림처럼 읽으면됨
	근데 이렇게 if문으로 분기하면 보기머리아프니까,express모듈을 사용하면 쿠키세션과 rest분기도 편해짐
	
	
	
3.쿠키와 세션
	로그인을 구현하려면 쿠키와 세션을 알아야함
	서버에서 클라이언트를 구분하기위해 기본적으로 사용하는건 쿠키임
	쿠키는 유효기간이 있는 단순한 키-값쌍임
	서버로부터 쿠키가오면 브라우저는 저장해뒀다가 다음에 그 서버에 요청할때마다 쿠키를 같이 보내고,서버는 그걸 읽어서 누구인지를 파악함
	브라우저는 쿠키가 있으면 자동으로 같이 보내주니까 따로 처리할필요가 없음
	
	즉 서버는 미리 클라이언트에 요청자를 추정할만한 정보를 쿠키로 보내고,그다음부턴 쿠키를보고 누군지파악함
	쿠키를 만들어서 넣을떈
		http 임포트
		http.createServer((req,res)=>{
			res.wirteHead(200,{'Set-Cookie':'쿠키키=쿠키값'})
			res.end('<p>Hello Server</p>')
		})
		.listen(8080,()->{
			console.log('8080포트대기')
		})	
	이렇게 보내면됨
	그리고 쿠키를 보내면,기본적으로 홈페이지의 아이콘을 같이 보냄(favicon.ico)
	
	서버에서 이걸 사용하려면,쿠키 파싱함수를 만들고(기본적으로 문자열로 들어옴),기본적으로 쿠키의 특정값이 있는지 없는지로 분기타서 맞춰서 던져주면됨
	
	근데 그냥 이렇게만쓰면 쿠키가 노출되고,쿠키를 조작할수있기때문에,쿠키에는 번호만 주고,서버에서 사용자정보를 관리하게만들어야함
	(특정숫자와 정보배열이 연동되는식으로),이게 세션임
	보통은 그냥 다른사람들이 만들어둔 세션모듈을 사용함
	
	
	
4.https와 http2
	https는 웹서버에 ssl암호화를 추가한거
	이건 근데 해보려면 인증서필요함
	거의 비슷한데,http모듈대신 https모듈 임포트하고,cert,key,ca를 읽어서 https.createServer앞 매개변수에 넣어주면됨
	그리고 443포트를 열면됨
	
	http2는 그냥 좀 빠른 http인데,그렇게 큰차이는 안난다고함
	이거도 그냥 https를 http2모듈로 바꾸고 똑같이쓰면됨

	
	
5.cluster
	클러스터모듈은 기본적으로 싱글프로세스로 동작하는 노드가,cpu를 전부사용하게 해주는 모듈임
	쓰레드가 아닌 프로세스를 사용함
	기본적으로 마스터는 워커를 생산하는일만 하고,워커들이 같은포트에서 대기하고있다가 일을 받아가서 하는식
	
	
	
	
	
5.패키지매니저
	보통 js에서 패키지매니저로 npm과 yarn을 사용함
	이책에선 npm사용하는듯
	
	노드js의 프로젝트폴더에 package.json을 추가하면(npm init하면됨),설치한 패키지의 버전정보가 다 적혀짐
	기본적으로 init하면 프로젝트를 생성해줌,그래서 이름,버전,깃레포,키워드 등을 적어주면됨
	
	package.json의 scripts안에 내가 실행한 npm 명령어가 저장되고,저기에 따로 명령어를 저장해두고 쓸수도있음
	
	npm으로 설치하면,node_modules에 저장됨
	그리고 개발중에만 사용할 패키지를 설치할땐
		npm install --save-dev 패키지명
	하면 됨
	
	그리고 노드모듈폴더를 지워도,npm install하면 다시 다 설치해줌
	기본적으로 npm설치하면 전역설치인데,문제는 만약 다른프로젝트에서 뭘설치해서 npm install없이 사용가능하면,package.json에 값이 안남음
	그래서 지역설치를 할땐 npx를 사용하면됨
	
	노드js패키지의 버전은 3단위로 나뉘는데,메이저 마이너 패치임
	보통 메이저끼리는 하위호환이 안되고,마이너에서는 됨
	그리고 버전앞에 ^붙은건 마이너단까지 호환된다는거(^1.1.1이면 1.1.1~2.0.0)
	~붙은건 패치단까지 호환(~1.1.1이면 1.1.1~1.2.0)
	
	그리고 어지간하면 프로젝트에서, 처음에 깔았던 패키지에서 업데이트는 안하는게좋음
	
	
6.익스프레스 웹서버
1.익스프레스시작
	일단 맨먼저 폴더를만들고 npm init로 package.json을 생성하고,
	package.json의 스크립트에 start:nodemon app 으로 노드몬(코드변경시 자동재시작해줌)설정하고(dev에서만 쓰는게좋음)
	코드를 적으면됨
	
	기본적으론
		express모듈임포트
		const app=express()
		app.set('port',process.env.PORT || 3000) //env포트환경변수가있으면 그거쓰고,아니면 3000번사용
		
		app.get('/',(req,res)=>{
			res.sendFile(path.join(__dirname,'html파일이름'))
		})
		
		app.listen(app.get('port'),()=>{
			console.log('대기중')
		})
		
	이런식으로,포트세팅하고 라우팅 나열하고 listen하면됨
	get은 get요청이 들어오면 /인지 확인하고 들어가는,2중if문을 암축해둔거임
	요청이 들어오면 파일경로에 있는 파일을 전송함
	
	
2.자주사용하는 미들웨어
	미들웨어는 익스프레스의 핵심임
	라우터와 에러헨들러등도 다 미들웨어니,익스프레스의 전부라고 봐도됨
	
	미들웨어를 사용하는방법은
		app.use(주소,미들웨어) //주소는 옵션
	임
	기본적으로
		app.use((req,res,next)=>{
			함수내용
			next()
		})
	로 동작하고,next가 없으면 다음미들웨어로 넘어가지못하고 거기서끝남
	매개변수의 맨앞에 주소를 넣어주면,그 주소에서만 동작하고,아니면 모든요청에서 동작함
		app.post('주소',미들웨어)
		app.get('주소',미들웨어)
	이렇게 액션을 선택해서 거기만 동작하게할수도있음
		app.use((err,req,res,next)=>{
			res.status(500).send(err.message)
			
		})	
	이렇게 err을 미들웨어 매개변수에 넣으면,모든에러처리가 됨
	
	미들웨어는 위부터 순서대로작동하기떄문에,저런 에러처리는 맨마지막에 넣으면됨
	
	직접 미들웨어를 만들어쓰기도 하지만,기본적으로 이미 다 만들어둔 모듈을 가져다 쓰는경우가 많음
		app.use(morgan('dev'))
		app.use(express.json())
	이런식임
	보통 만들어둔건 next가 안에 들어있어서,그냥 순서대로 동작한다고 생각하면됨
	
	morgan은 요청에 대한 정보를 콘솔로 출력해줌
		메서드/주소/http상태코드/응답속도/응답바이트
	가 나옴
	개발시엔 dev,배포시엔 combined를 넣어주면됨
	
	static은 정적인 파일을 제공하는 라우터임
	얘는 기본적으로 익스프레스에 들어있고
		app.use('요청경로',express.static('실제경로'))
	이렇게 하면됨
	이걸 사용하면,실제경로를 감출수있어서,보안에 도움이됨,즉 어떤폴더에 뭐가 들어가있고 그런걸 감출수있음
	그리고 정적파일을 알아서 제공해줘서,fs.readFile로 파일을 직접 읽어서 전송할필요가 없음
	이떄 파일을 발견하면 next를 안치고,파일을 못찾으면 next를 침
	응답을 보넀으면 더할필요가없으니까
	
	body-parser은 요청의 본문에 있는데이터를 해석해서 req.body객체로 만들어줌
	보통 폼데이터나 ajax요청데이터를 처리하고,이미지,동영상,파일같은건 처리하지못함
	즉 얘는 rest의 쿼리스트링을,키값객체로 만들거나,post같은거의 json객체를 파싱해서 키값객체에 넣어줌
	
	cookie-parser는,요청에 있는 쿠키를 해석해 req.cookies객체로 만들어줌
	해석된 쿠키는 req.cookies객체에 들어가고,거기서 그냥 키값쌍처럼 쓰면되고,유효기간지난건 알아서걸러줌
		app.use(cookieparser(비밀키))
	첫번째인수로 비밀키를 받을수있는데,서명된쿠키의경우,저 키로 내가 만든키인지를 검증할수있음(내키까지 같이 압축해서 그걸로 복호화걸어서 풀리나보는느낌)
	이건 기본적으로 쿠키 해석하는용도고,쿠키를 생성/제거할땐
		res.cookies(키,값,옵션) //옵션에 유효기간,httponly등이 들어감
		res.clearCookie(키,값,옵션)//키,값,옵션이 전부 일치해야 지울수있음
	이렇게 하면됨
	옵션에 signed라는 옵션이 있는데,이걸 true로하면 키뒤에 서명이 붙으니,항상켜두는게좋음
	이때 키는 cookieparser에 인수로넣은값이고,process.env.COOKIE_SECRET에 있음
	
	express-session은 세션관리용 미들웨어임
	로그인등의 이유로 세션을 구현하거나,특정사용자를 위한 데이터를 임시로 저장해둘때 사용됨
	세션은 사용자별로 req.session객체 안에 유지됨
		app.use(session({
			resave:false,
			saveUninitialized:false,
			secret:process.env.COOKIE_SECRET,
			cookie:{
				httponly:true
				secure:false
			}
			name:'session-cookie'
			
		}))
	일반적으론 미들웨어순서랑 상관없는데,구버전에선 내부적으로 쿠키파서를 사용해서 쿠키파서미들웨어보다 뒤에있어야했지만,
	이젠 상관없긴한데 관례적으로 뒤에다 놓는게 좋다고함
	
	얘는 인수로 세션에 대한 설정을 받음
		resave는 요청이 올때 세션에 수정사항이 없어도 세션을 다시저장할지 설정하는거고
		saveUninitialized는 세션에 저장할내용이 없을때 처음부터 세션을 생성할지 설정하는것
		secret는 쿠키서명에 필요한 비밀키값을 주는거고,쿠키파서값과 똑같이주는게조음
		cookie옵션은 세션쿠키에 대한 설정임,쿠키파서에서 사용가능한옵션이 다 제공됨
			httponly는 클라이언트에서 키확인을 막는거고
			secure는 https가 아닌환경에서 사용가능한지아닌지
		store는,기본적으론 메모리에 세션을 저장하는데,이걸 db에 저장하는거임,보통 레디스사용함
		
	여기서 만들어진 req.session객체에 값을 대입하거나 삭제해서 세션을 변경할수있음
		req.session.name='zeor' //세션등록
		req.sessionID //세션아이디확인
		req.session.destroy()//세션모두제거
		
	세션쿠키는 앞에 s%3A로 시작하는데,이렇게시작하면 express-session에서 서명했다는거임
	이 뒤에내용이 실제 암호화된 쿠키내용임
	
	그리고 미들웨어는 동시에 여러 모듈을 장착할수있음(app.use하나에 여러개장착가능)
	이경우에도 다음으로 넘어가려면 next를 내부적으로 호출해야함
	이때 express.static같은경우는 next대신 res.sendFile을 보내므로,그뒤에있는건 실행되지않음
	즉 서순을 잘 맞춰야함
	만약 next도 안보내고 응답도 안보내면 클라이언트는 타임아웃까지 기다려야하니까 주의
	
	그리고 next에 매개변수를 넣어서 특수한동작을 하게할수있음
		next('route')//다음 라우터의 미들웨어로 이동
		next(err)//에러처리미들웨어로 이동
	미들웨어간에 데이터 전달할땐,req객체에 데이터를 넣고,그걸읽으면됨
		req.data='31'
	이경우엔 현재 요청이 처리되는동안 공유되고,새요청이오면 초기화됨
	이떄 다른미들웨어와 겹치지않게,유니크한이름을 쓰는게좋음
	이렇게 전달하면,req객체는 요청을 보낸 사용자 개개인에 귀속되니까,함수내 지역변수처럼 사용할수있어서 조흥ㅁ
	
	그리고 미들웨어안에 미들웨어를 넣어서,조건에따라 분기처리를 하는 패턴도 있음
	
	multer은 이미지,동영상,파일등을 업로드할때 사용하는 미들웨어임
	이때 형식이 multipart/form-data라서 멀티파트형식이라고 부르고,이걸처리해줌
	사용법은
		const upload=multer({
			storage:multer.diskStorage({
				destination(req,file,done){ //어디에저장할지
					done(null,'uploads/')
				},
				filename(req,file,done){ //어떤이름으로
					const ext=path.extfile(file.originlname)
					done(null,path.basename(file.originlname,ext)+Date.now()+ext)//중복방지를위해 시간붙임
				}
			}),
			limits:{fileSize:5*1024*1024}
			
		})
	이렇게 사용함
	스토리지속성엔 어디에,어떤이름으로 저장할지를 넣고 리미트를 거는거임
	req는 요청에대한정보가,file엔 파일경로정보가,done에는 req와 file을 사용해 가공한값이 들어있음
	리미트는 사이즈제한같은걸 거는거(저기는 5mb)
	
	이경우에,uploads/폴더가 반드시 있어야하기때문에,readFileSync를 사용해서 폴더있는지확인을 해줘야함
	저 만들어진 upload변수를 사용할땐
		app.post('파일경로',upload.single('image'),(req,res)=>{
			console.log(req.file,req.body)
			res.send('ok')
		})
	이 미들웨어를 라우터미들웨어 앞에 넣어두면,req.file객체가 생성되고 인수는 input태그의 name이나 폼데이터의 키와 일치하게넣으면됨
	업로드성공시 결과는 req.file에 들어있음
	req.body엔 파일이 아닌 데이터인  title이 들어있음
	
	여러파일업로드시엔 html input태그에 multiple을 넣고
	미들웨어에 single대신 array를 사용하면됨
	업로드결과는 req.files배열에 들어있음
	req.files['html인풋이름']에 들어있음
	
	
	
3.라우터객체로 라우팅분리
	익스프레스에서는 라우팅을 깔끔하게 관리할수있음
	route/app.js에서
		const router=express.Router()
		
		router.get('/',(req,res)=>{
			내용
		})
		mudule.exports=router
	이렇게 js파일을 따로 만들고,
		const indexRouter=require('.route/app.js') //만약 route/하면 index.js가 기본값으로 들어가짐
		app.use('/',indexRouter)
	
	이렇게 사용하면됨
	이경우,app,js와 메인의 값이 같으니까 /2개가 합쳐져서 get / 라우터가 되고,
		app.use('/user',userRouter)
	이경우엔 /와 /user이 합쳐져서 get/user라우터가 됨
	
	여기서 next('route')를 사용하면,현재라우터를 종료하고 다음라우터로 넘어가는것(라우터에 연결된 나머지미들웨어를 건너뜀)
	그리고 같은주소의 라우터를 여러개만들어도,그냥 한라우터에 미들웨어 여러개달린거랑 똑같이동작함
	
	라우터주소에 정규표현식을 사용해서 값을 받을수도있는데,보통 정규표현식이 범위가 넓으니까,라우터단에서 제일밑쪽에 넣는게 좋음
		/user/like를 먹는 라우터 위에 /user/:id 를 먹는애가있으면 다먹어버리고 밑에는 안주니까
		
	그리고 주소는같지만 메서드가 다른코드는
		router.route('/abc')
		.get((req,res)=>{내용})
		.post((req,res)=>{내용})
	이런식으로 묶을수도있음
	
	
4.req,res객체
	익스프레스의 req,res객체는 http모듈의 req,res객체를 확장한것
	기존http모듈의 메서드도 사용할수있는데,보통 잘안씀 익스프레스메서드쓰지
		req.app:req객체를 통해 app객체에 접근할수있음
			req.app.get('port') 이렇게사용
		req.body:body-parser미들웨어가 만드는요청의 본문을 해석한 객체임
		req.cookies:쿠키파서가 만든 요청의 쿠키를 해석한객체
		req.ip:요청의 ip주소가 담겨있음
		req.params:라우트매개변수정보가 담겨있음
		req.query:쿼리스트링정보가 담겨있음
		req.signedCookies:서명된쿠키는 req.cookies대신 여기있음
		req.get(헤더이름):헤더읙밧을 가져올때 사용
		
		res.app:req.app처럼 res객체를 통해 app에 접근할수있음
		res.cookie(키,값,옵션):쿠키설정메서드
		res.clearCookie(키,값,옵션):쿠키제거메서드
		res.end():데이터없이 응답보냄
		res.json(JSON):json형식응답을 보냄
		res.redirect(주소):리다이렉트주소와 함께 응답을보냄
		res.render(뷰,데이터):템플릿엔진을 렌더링해서 응답함
		res.send(데이터):데이터와 함께 응답을보냄,문자열,html,버퍼,객체,배열 다 가능
		res.sendFile(경로):경로에 위치한 파일을 응답함
		res.set(헤더,값):응답헤더를 설정
		res.status(코드):응답http상태코드를 지정
	보통 메서드체이닝을 지원하니까	
		res
			.status(201)
			.cookie('text','tt')
			.redirect('/admin')
	이런식으로 적는경우가 많음
	
5.템플릿엔진
	html은 정적인언어라서 기능추가가 안돼서,자바스크립트로 처리해야함
	템플릿엔진은 js를 사용해서 html을 렌더링할수있게 해줌
	제일 큰건 퍼그와 넌적스임
	1.퍼그
		퍼그는 괄호없이
			html
				head
					title=title //title는 변수,js에서 받아다씀
					link(rel='stylesheet')
		
		이런식으로 적는방식임,즉 들여쓰기가지고 구분함
		그리고 변수보내는건,렌더링호출시 거기서함
			router.get('/',(req,res,next)=>{
				res.render('index',{title:'exp'})
			})
		이런식으로넣음
		이러면 html에서도 변수를 사용할수있어짐
		그리고
			router.get('/',(req,res,next)=>{
				res.locals.title='exp'
				res.render('index')
			})	
		이렇게 locals에 넣어주면,자동으로 렌더링시에 그 변수를 찾아서 집어넣음
		이거의 장점은,현재라우터뿐아니라 다른 미들웨어에서도 res.locals객체에 접근할수있다는게 장점임
		퍼그에서 변수사용시엔,대입은 그냥붙이면되고,문자열에서 쓸땐
			p abcd to #{title}
		이렇게 #{변수명}으로 사용하면됨
		내부적으로 #{}내부와 =뒤는 js로 처리하는방식임
		
		퍼그내부에서 변수사용하는방법은
			- const a='abcd'
		이렇게 앞에 -를 붙이면 js구문을 사용할수있음
		
		그리고 퍼그는 기본적으로 변수의 특수문자를 html엔티티로 변환하는데,이걸원하지않으면 
		=대신 !=를 사용하면됨
		
		반복문은
			each i in 배열
				li=i
		이렇게 작성함
		인덱스가져올땐
			each i,index in 배열
				li=index+i	
		이렇게하면됨
		
		조건문은
			if TF값
				내용
			else
				내용
		케이스문은
			case 변수명
				when '값1'
					내용
				when '값2'
					내용	
				default
					내용
		
		그리고 다른 퍼그나 html파일도 넣을수있음
		즉 모듈화시켜서 조립할수있음
			include 파일명
		으로 그자리에 파일을 추가하는식으로 작동함
			include 파일명1
			내 작성내용
			include 파일명2
		이런식
		
		레이아웃을 정할수도있음
		레이아웃을 만들어두고
			extends 레이아웃파일명
			내용
			block 블록명
				내용
			block 블록명2
				내용	
		블록은 레이아웃에서 특정한 레이아웃을 블록별로 만들고,그 블록에만 적용시킬수있음(이름으로 매칭)
	2.넌적스
		넌적스는 좀 더 html과 가까운 템플릿엔진임
		여기는 <h1></h1>으로 구분하고,변수사용시엔 {{변수}}로 사용
		변수선언시엔 {% set 변수='값'%}
		이스케이프안할떈 {{변수 | safe}}
		
		반복문은 
			{% for item in 배열%}
			<li>{{item}}</li>
			{%endfor%}
		이렇게 for문과 endfor 사이에 두면됨
		인덱스는
			{% for item in 배열%}
			<li>{{item}{loop.index}}</li>
			{%endfor%}	
		이렇게 loop.index를 사용하면됨
		
		조건문은
			{% if TF값%}
			내용
			{%else%}
			내용
			{%endif%}
		케이스는 없고,elif는 있으니 이거로분기해야함
	
	
		include는
			{%include "파일명"%}
		으로 넣고,
		레이아웃은
			{%extends '파일명'%}
		으로 관리할수있음
		블록은
			{%block 블록명%}
			{%endblock%}
		로 관리 
	
	
7.mysql	
	설치스킵
	테이블생성스킵
	crud스킵
1.시퀄라이즈 사용
	시퀄라이즈는,mysql과 노드js의 or mapper라이브러리임
	mysql만 지원하는건아니고,마리아,mssql,sqlite등도 지원함
	
	orm은 js구문을 자동으로 sql로 바꿔주고,js객체를 db테이블과 동기화시켜줌
	그래서 만들어진 객체배열에 추가하고 빼는거만으로 insert와 delete를 자동으로 할수있음
	
	시퀄라이저 sync시에,force매개변수를 true로 주면,서버 실행시마다 테이블을 재생성하고,false로주면 그냥 있는거사용함
	그리고 연동시엔 config/config.json안에 설정을 넣어두고,그걸가져다가 사용함(id,패스워드등)
	
	접속이 됐으면,mysql에서 정의한 테이블을 시퀄라이즈에서도 정의해야함
		module.exports=class 클래스명1 extends Sequelize.Model{
			static init(sequelize){
				return super.init({
					컬럼1:{
						type:Sequelize.STRING(20),
						notnull:true,
						unique:true
					},
					컬럼2:{
						type:Sequelize.INTEHER,
						notnull:true,
						unique:true
					},					
					...
				},{
					sequelize,
					timestamps:false, //true면 createdAt와 updatedAt컬럼을 추가함
					underscored:false, //createdAt이걸 created_At이런식으로 만들어줌
					modelName:'클래스명1',//모델의 이름
					tanleName:'mysql테이블명', //만들테이블의 이름,이미 만든테이블있으면 똑같이만들어주면됨
					paranoid:false, //삭제시 deletedAt에 표시하는식으로 삭제함
					charset:'utf8',  //인코딩
					collate:'utf8_general_ci' //인코딩
					
				
				})
				static associate(db){}
			
			}
		
		}
	이런식으로 init에 컬럼 전부 나열한 테이블 만들고,옵션과 연결데이터(테이블명같은)거 주고
	associate에 다른모델과의 관계를 적으면됨
	그리고 varchar이 string임
	
	사용할 테이블모델을 다만들었으면,db커넥트하는 코드모듈에서 전부 임포트하고 init,associate하면됨
		db.sequelize=sequelize
		user.init(sequelize)
		comment.init(sequelize)
		user.associate(db)
		comment.associate(db)
		module.exports=db
	
	
	시퀄라이즈에서 관계는,1대1,1대다,다대다가 있음
	일대일은 사용자와 사용자정보테이블을 예로 들수있고,
	다대다는 게시글과 해시태그를 예로들수있음(같은해시태그가 여러게시글에달리고,게시글내에서 여러해시태그를 달수있음)
	일대다는 사용자의 댓글작성목록을 예로들수있음
	
	기본적으로 sql에선 join으로 여러테이블간의 관계를 파악해서 결과를 도출함
	시퀄라이즈는 이 join도 알아서 구현하는데,일단 테이블간에 어떤관계가있는지는 알려줘야함
	
	일대다의 경우엔 hasMany,belongsTo라는 메소드로 표현함
	가져오는쪽에(시전자)hasMany를 넣고,가져가지는쪽에(피대상자)belongsTo를 넣음
	시전자에 hasMany를 associate에 넣고
		static associate(db){
			db.user.hasMany(db.Comment,{foreignKey:'commer',sourceKey:'id'})
		}
	이렇게 hasmany를 콜하고,연결할 모델,내가 저장할이름(foreignKey),가져올대상이름(sourceKey)으로 하면됨
	피대상자에
		static associate(db){
			db.Comment.belongsTo(db.user,{foreignKey:'commer',targetKey:'id'})
		}
	이렇게 똑같이 넣어주면됨
	이러면 user이 comment를 참조해서,코멘트의 id를 가져온 컬럼을 생성함
	만약 foreignKey를 지정하지않으면,모델명+기본키인 컬럼이 시전자쪽에 추가됨(기본 프라이머리키)
	
	이렇게 넣어주고 npm start로 서버를 시작하면 알아서 쿼리날림
	
	
	일대일관계에선 hasOne와 belongsTo를 사용해서 똑같이하면됨
	다대다에선 양쪽다 belongsToMany를 사용하면됨
		db.post.belongsToMany(db.hashtag,{through:'PostHashTag'})
		db.hashtag.belongsToMany(db.post,{through:'PostHashTag'})
	이러면 양쪽의 키를 딴 새로운 테이블이 만들어짐(through가 테이블이름임)
	이경우엔 필연적으로 데이터조회시 여러단계를 거쳐야함
	방식은,원하는 로우를 찾고,그 로우의 키로 키합성테이블에 조회한후,받은키로 다시 다음테이블에 조회하는식
	
	
	시퀄라이즈로 crud를 하려면,시퀄라이즈쿼리를 먼저 알아야함
	기본적으로 자바스크립트로 생성하고,프로미스를 반환하므로,then을 붙여 받을수있고,async/await와도 같이쓸수있음
	insert는
		user.create({
			컬럼명1:데이터,
			컬럼명2:데이터,
		})
	이렇게 넣으면됨,이때 주의점은 mysql자료형이 아닌,시퀄라이즈모델에 정의한 자료형대로 넣어야함,이걸 시퀄라이즈가 알아서 mysql자료형으로 바꿈
	select는
		user.findall({}) //전체검색,일반select
		user.findOne({})//1개검색
	원하는 컬럼만 가져올때(sql에서 *대신 컬럼적고싶을떄)
		user.findall({attributes:['name','age']})
	where문 넣을때
		user.findall({attributes:['name','age'],where:{married:true,age:{[op.gt]:30}}})
	기본적으로 자바스크립트로 해야해서,<>같은걸 못써서 저런 코드로 대체함
		Op.gt: >
		Op.gte: >=
		Op.lt: <
		Op.lte: <=
		Op.ne: !=
		Op.or: or
		Op.in:배열에 포함
		Op.notin:배열에 포함안됨
	등이 있음
	or을 쓰는법은	
	where:{[Op.or]:[ married:true,age:{[op.gt]:30}]}
	이렇게 or처리할걸 묶어서 안에넣으면됨
	정렬은
		user.findall({attributes:['name','age'],where:{married:true,age:{[op.gt]:30}},order:[['age']]})
	이때 배열2개임,여러개쓸수도있으니까 기본적으로 배열안에배열임
	그리고 findall안에 
		limit:숫자  
	를 적으면 그 갯수만큼 리턴함(findone에서 갯수선택가능)
	offset도 똑같이하면됨
	
	업데이트는
		user.update({
			컬럼명:바꿀내용
		}{
			where:{조건}
		})
	이렇게하면됨
	삭제는
		user.destory({
			where:{조건}
		})
	이렇게
	
	
	기본적으로 find를 하면 프로미스의 결과로 모델을 반환함
	이때 바로 모델의 정보에 접근할수도 있지만,관계쿼리도 지원함(join같은)
	만약 특정 사용자를 가져오면서 그사람의 댓글까지 가져오고싶으면 include를 사용하면됨
		user.findall({include:[{model:Comment}]})	
	이건 서로간의 관계(hasMany같은)가 맺어져있어야지만 동작함
	어떤 모델과 관계가 있는지를 include배열에 넣으면,
	user.comments로 접근하던가 user.getComments()로 접근할수있음
	get,set,add,remove를 지원함
	동사뒤에 모델명을 붙이면됨
	그리고 동사뒤에 모델명을 바꾸고싶으면,
	hasmany같은데 foreignKey있는곳에 as:'별명'넣으면됨
	getComments같은데도 where나 attrubute를 사용할수있음
	
		co=await user.getComments({
			where:{
				id:1
			},
			attributes:['id']
		})
	이렇게하면 id가 1인거만 가져오고,컬럼도 id컬럼만 가져옴
	
	그리고 만약 sql을 날리고싶으면,
		a=sequelize.query('sql')
	이렇게 쿼리를 날릴수도있음
	
	
	
8.mongodb	
	몽고디비는 nosql임
	nosql은 sql을 사용하지않는,스키마가 없는 db임
	얘는 일관성을 포기하고 확장성과 가용성을 높였음
	여기서는 용어가 좀다른데
		테이블->컬렉션
		로우->도큐먼트
		컬럼->필드
	라고 부름
	
	nosql에는 고정된 테이블이 없음(스키마가없음)
	그래서 각 도큐먼트(로우)마다 아무값이나 넣을수있음,게시판의 글이라고 생각하면됨
	그리고 몽고디비에는 조인이 없어서,하나의쿼리로 여러테이블을 합치는 작업이 항상가능하진않음
	그리고 동시에실행이 안되니까,일관성이 꺠질수있음
	
1.crud
	몽고디비에서 크리에이트는 컬렉션에 컬럼을 정의하지않아도 돼서,아무데이터나 넣을수있음
	몽고디비의 자료형은,기본적으로 js에,거기에 undefind와 symbol을 사용하지않고,objectid,binarydata,timestamp등이 추가됨
	
	오브젝트id는 rdbms의 기본키라고 생각하면됨
	고유한값을 가지므로 조회할때 사용가능
	
	인서트를 할땐,
		db.컬렉션명.save(도큐먼트)
		db.user.save({name:'abc',age:24,createAt:new Date()})
	이런식으로 적으면됨,js객체라고 생각하고 생성하면됨
	명령이 성공하면
		WriteResult({"nInserted":1})
	이렇게 인서트한갯수가 리턴됨
	
	셀렉트를 할땐
		db.컬렉션명.find({}) //전체검색
		db.컬렉션명.find({조건},{서치필드}) //조건,필드제한  첫인수가 조건,두번째가 필드선택
		db.user.find({name:'zero'},{_id:1})
	이렇게 조회하면됨
	이때 조건에서는
		$gt 초과
		$gte 이상
		$lt 미만
		$lte 이하
		$ne 같지않음
		$or 또는
		$in 배열요소중 하나
	등이 사용됨
	or은
		find({$or:[{age:{$gt:30}},{_id:0}]})
	이런식으로 사용됨
	
	정렬할땐(orderby)
		db.컬렉션명.find({}).sort({정렬필드명:-1}) //-1은 내림차순 1은 오름차순
	갯수제한검색은 
		db.컬렉션명.find({}).sort({정렬필드명:-1}).limit(3)
	앞에 몇개 건너뛸땐
		db.컬렉션명.find({}).sort({정렬필드명:-1}).limit(3).skip(4)
	
	
	업데이트할떈
		db.컬렉션명.update({조건필드:'조건값'},{$set:{바꿀필드명:'바꿀필드값'}})
	하면 writeresult가 나옴
	$set를 넣으면 그 필드만 수정하고,이걸안쓰고 일반객체를 넣으면 아예 그객체로 덮어써버리니 주의(스키마가없으니까)
	
	삭제할떈
		db.컬렉션명.remove({조건필드:'조건값'})
	이렇게하면 리턴옴
	
2.몽구스
	몽구스는 몽고db의 시퀄라이즈임
	몽구스는 orm이 아닌 odm임(릴레이션이 아니라 도큐멘트)
	
	몽구스를 사용하면 스키마를 사용할수있고,조인을 할수있음(populate),내부적으로는 쿼리여러번해서 하지만,우리가신경쓸필요는없음
	
	몽고디비와 몽구스와 노드를 연결할땐
		mongoose.connect('mongodb://이름:패스워드@주소:포트/디비명',
		{dbname:'nodejs',
		},(error)=>{
			에러처리
		})
	이렇게하면댐
	
	스키마정의도
		const us=new Schema({
			name:{
				type:string,
				required:true,
				unique:true
			},
			age:{
				type:Number,
				required:true,
			},
			createAt:{
				type:Date,
				default:Date.now
			}			
			...
		})
	이런식으로하면됨
	_id는 기본적으로 생성하므로 적을필요가 없음
	그리고 참조시엔
		commenter:{
			type:ObjectId,
			require:true,
			ref:'User'
		}
	이렇게 id값으로 참조필드를 만듬
	
	
	
	
9.익스프레스로 sns서비스 만들기
	
	라우터는 express.router()쓰면되고
	기타등등프론트엔드는 패스하고
	
	db는 mysql과 시퀄라이즈로 모델들을 생성하고,associate에 각 모델간의 관계를 정의하고,
	그리고 같은모델에서도 서로간 n:m관계를 가질수있음
	이경우엔 두필드를 전부 belongsToMany해주면됨,그리고 이경우엔 as가 필수임,구분안되니까
	
	그리고 시퀄라이즈에는 config.json을 읽어서 자동으로 db를 생성해주는 기능이 있음
	여기서 아이디패스워드,db명을 넣고 dialect를 mysql로 설정해주고,
		npx sequelize db:create
	하면됨
	그리고 이걸 sequelize.sync로 연결하면됨
	
	
	
1.passport모듈
	패스포트모듈은 세션,쿠키처리등을 처리해주는 검증된 모듈임
		임포트하고
		app.use(passport.initialize()) //req객체에 passport설정을 심음
		app.use(passport.session())  //req.session객체에 passport정보를 저장함
	하면됨
	req.session은 express-session에서 생성하므로,이거보다 뒤에있어야함
	
	그리고 passport/index.js에서
		const passport=require('passport')
		const local=require('./localStrategy')
		const kakao=require('./kakaoStrategy')
		const user=require('../models/user')
	이렇게 임포트하고,
		module.exports=()=>{
			passport.serializeUser((user,done)=>{  //로그인시 실행
				done(null,user.id)
			
			})
			passport.deserualizeUser((id,done)=>{ //매요청시 실행,passport.session미들웨어가 호출함
				User.findOne({where:{id}})
				.then(user=>done(null,user))
				.catch(err=>done(err))
			})
			local();
			kakao();
		}
	serializeUser는 로그인시 실행되고,매개변수로 유저를 받아서,유저의아이디를 done에 넘겨줌
	
	done의 첫함수는 에러시에 사용하고,두번째에 넣고싶은걸 넣으면됨
	
	deserualizeUser는 매요청시 실행되고,passport.session이 호출함
	done의 두번째로 넣었던인수가 여기서의 매개변수가되고,그걸가지고 db에서 사용자정보를 조회함
	그걸 req.user에 저장하므로(then의 done(null,넣을곳이름)),거기서 사용자정보를 가져올수있음
	
	로컬로그인시엔 passport-local모듈이 필요함
	로컬로그인을 할땐,로그인이 필요한곳,로그인이 필요없는곳,로그인 안해야하는곳으로 나누고,거기에 맞는 라우터를 거쳐가게하면됨
	이 미들웨어는
		exports.isLoggedIn=(req,res,next)=>{
			if (req.isAuthenticated()){
				next()
			}else{
				res.status(403).send('로그인필요')
			}
			
		}
		exports.isNotLoggedIn=(req,res,next)=>{
			if (!req.isAuthenticated()){
				next()
			}else{
				res.status(403).send('로그인한상태')
				res.redirect(`/?error=${message}`)
			}
			
		}
	이렇게 req.isAuthenticated로 로그인한지 안한지 확인하고(이건 패스포트가 req에 자동으로추가함),그거보고 루틴들어가면됨
	이 미들웨어를 필요한 주소라우터에 넣는식
		router.get('/profile',isLoggedIn,(req,res)=>{
			res.render('profile',{title:'내 정보'})
		
		})
	이렇게 미들웨어를 거쳐서 true여야 넘어가게(next나와야넘어가니까)
	이거말고도 팔로잉여부,관리자여부등의 미들웨어를 만들어서 사용할수있음
	res.locals.user속성에 req.user을 넣어서,넌적스에서 user객체를 통해 사용자정보에 접근할수있음
	
	카카오로그인시엔,처음로그인할때(검색결과가없을때)는 회원가입처리하고,있을땐 그대로로그인해주면됨
	
	
2.multer로 이미지업로드
	기본적으로 multer로 위치와 파일을 받은다음에  upload.single('img')미들웨어로 던지면됨
	
	
	
	
	

10.웹 api서버 만들기
	api서버를 만들때,요청을 보낸사람을 체크할때,키와 도메인같이 그정도는 일치시켜야 도용의 위험을 막을수있음,아니면 그냥 키주고 관리는 알아서하라고하던가
	그리고 시퀄라이즈의 enum타입은,정해진 값만 넣을수있게 하는 타입임(a,b,c만 가능하게,d들어오면 에러)
1.jwt토큰	
	요청의 키는 jwt토큰을 사용할수있음
	이건
		헤더:토큰종류와 해시알고리즘정보가 들어있음
		페이로드:토큰내용물이 인코딩된부분
		시그니처:토큰변조확인하기위한 부분
	시그니처는 jwt비밀키로 만들어지는데,이게 노출되면 토큰을 위조할수있게되니까 철저히 숨겨야함
	시그니처는 안숨겨도됨,그리고 jwt는 공개되니까 민감한내용을 넣으면안됨(페이로드와 헤더가 암호화되지않기때문)
	
	이건 받는쪽이 변조가 없었는지를 확인하기위해 사용하는거라서(+로,랜덤문자열로 이게누군지 확인하는절차가 없어짐),
	내용물을 믿고 사용할수있음(변조된지안된지),즉 사용자id,권한같은걸 넣어두고 서치하기좋음
	암호화안되니까 비밀번호같은건 넣으면안됨
	
	단점으론 용량이 큼,내용물을 그대로 보내니까 그만큼 데이터량이 정량으로 나오게됨
	
	이걸 쓸땐 jsonwebtoken을 설치하고 임포트하고,
	jwt_secret설정하고
		const jwt=require('jsonwebtoken')
		...
		exports.verifyToken=(req,res,next)=>{
		try{
			req.decoded=jwt.verify(req.headers.authorization,
			process.env.JWT_SECRET)  //req.headers.authorization에 있는 토큰으로 검증,process.env.JWT_SECRET는 키
			return next()
		}catch(error){
			if (error.name==='TokenExpiredError'){
				return res.status(419.json)({
					code:419,
					message:'토큰만료'
				})
			}
			return res.status(401).json({
				code:401,
				message:'유효하지않은토큰'
			})
		}
		}
	
	이렇게 사용함
	인증에 성공하면 토큰내용이 반황되어서 req.decoded에 저장됨
	토큰 생성도 라우터api로 만들어서 사용하면됨
	토큰생성은
		const token=jwt.sign({
			id:domain.user.id,
			nick:domain.user.nick
		}),process.env.JWT_SECRET,{
			expiresIn:'1m',//유효기간
			issuer:'발급자명'
		}
	이렇게 jwt.sign(토큰내용,키,토큰설정)으로 생성하면됨

2.다른서비스에서 호출
	다른서비스에서 호출할땐,
	토큰을 발급받고,
	받고나서 해당주소로 get같은걸 날리고(result=await axios.get('주소',{headers:{authorization:req.session.jwt}})),
	header에 jwt토큰을 준다음
	result.data로 받으면됨
	
	이때 만약 토큰이 없으면 토큰발급을 해서 넣고,있으면 그냥 그대로 진행사는식으로 if문돌리는게좋음(만료시도 동일)
	
3.사용량제한
	특정 사용자마다 사용량을 제한할땐 express-rate-limit를 사용하면됨
	이걸 설치하고
		const ratelimit=require('express-rate-limit')
		exports.apuLimiter=new ratelimit({
			windowMs:60*1000//1분,
			max:1,
			handler(req,res){
				res.status(this.statusCode).json({
					code:this.statusCode,//기본값 429
					message:'1분에한번'
				})
			}
		})
	
	이런식으로 미들웨어를 만들어서 라우터에 넣으면됨
	만약 사용량이 넘으면 핸들러가 발동하고 next로 안가는식임
	
	
	
4.cors
	cors는,브라우저와 서버의 도메인이 일치하지않을때 요청이 차단되는현상임
	이걸 cors라고 부름,이건 브라우저에서 서버로 보낼때만 발생하고,서버에서 서버로갈땐 발생하지않음

	이걸 해결할떈 cors모듈을 설치하고,api서버쪽에
		router.use(cors({
			credentials:true //다른도메인간 쿠키공유,이거없으면 다른도메인간 로그인안됨
		}))
	해주면됨
	이렇게하면 요청을 보내는 주체가 클라이언트라서,비밀키가 모두에게 노출되는데,이거때문에 도메인일치를 한거
	보통 상용에서는,tls같은거로 암호화할거같긴함 공개키비밀키로
	만약 도메인으로 거르려면
		if (domain){
			router.use(cors({
				credentials:true, //다른도메인간 쿠키공유,이거없으면 다른도메인간 로그인안됨
				origin:req.get('origin')
			})(req,res,next))	
		} else(){
			next()
		}
	이렇게 클라도메인과 호스트일치확인하고 일치하면 cors를 허용해서 다음으로,아니면 그냥 다음으로 보내는식으로 동작
	origin은 와일드카드가 아닌,저 도메인만 허용한다는거,여러개를 넣고싶으면 배열로 넣으면됨
	
	
	
11.노드서비스 테스트	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	