1.노드 시작하기
	노드js는 주로 서버(클라이언트가 요청하면 응답을해주는프로그램)를 돌리기위해 사용됨
	기본적으로 이벤트기반으로 작동되니까,이벤트리스너에 콜백을 등록해두는식으로 작동함
	기본적으론 동기식으로 작동하지만,setTimeout같은걸 사용해서 비동기식으로 사용할수도있음
	여기서 setTimeout은,n초뒤에 작동하는건데,n초뒤에 태스크큐로 보내고 다시 호출스택으로 가서 동기식으로 작동하는거라,
	호출스택이 이미 차있으면 정확히 n초뒤에 켜진다고 보장할순없음
	이 태스크큐에서 꺼내서 호출스택으로 보내는걸 이벤트루프라고함,루프니까 계속 무한루프돌면서 대기함
	
	이 이벤트루프를 잘 사용하면,비동기처리해도되는것들을 묶어서 한번에 처리해서(i/o같은것들),성능을 올릴수있음
	그리고 동시성은,동시처리가 가능한 작업을 논블로킹해야(비동기처리해야) 얻을수있음
	
	그리고 자바스크립트는 싱글스레드로 동작함
	
	js,즉 노드가 서버에쓰기 좋은건,싱글스레드라서,i/o에 강해서 잘 사용됨
	기본적으로 논블로킹으로 작은데이터를 많이 처리하기 좋으니까
	그리고 json이 자바스크립트형식이라 처리하기쉽다는 장점도있음
	
	
2.알아두어야할 js
1.es6문법
	const,let은 var과 다르게,블럭내에서만 스코프가 동작하는 변수선언임,
	var은 전역스코프를 사용하고
	const는 블록스코프에 상수(한번선언하면 값못바꿈)
	let는 블록스코프에 변수
	
	그리고 `(백틱,1옆에있는거)과 ${}를 사용해서,문자열내에서 변수를 사용할수있음
		`${num}은 숫자다`
	이런식
	
	그리고 객체에 함수를 연결할때
		const abc={
			say(){
				console.log('abc')
			},
			saynode
			[변수+'qqq']:'qwer'
		}
	이런식으로 적고,이미 만들어진 함수면 그냥 나열하는식으로 넣는게가능
	사용할떈
		abc.say()
		abc.saynode()
		abc.변수qqq
	이렇게그냥쓰면됨
	
	화살표함수는 그냥
		const abc=(x,y)=>(x+y) //한줄만쓸땐
		const abc=(x,y)=>{ //여러줄쓸때
			if(){
				...
			}
			return aaa
		}
	이렇게쓰면됨
	화살표함수는 this바인드가 달라짐
	기존 함수내에선 따로 this로 함수를 가리키는 포인터를 받아서 그걸 저장하고 써야했다면(안에서 for문같이 블록써서 스코프달라질경우)
	화살표함수안에선 this가 외부를 그대로 가리키기떄문에,그냥 this를 써도됨,즉 내부스코프가 없음
	
	구조분해할당은,객체나 배열에서 속성이나 요소를 한번에 꺼내는거
		const (getabc,status:{count})=abcmachine
	이렇게하면 객체내의 함수와 값을,같은이름의(getabc와 count라는이름의)변수에 저장함
	즉
		const getabc=abcmachine.getabc
	와 같음
	단,구조분해할당을 사용하면,this의 스코프가 달라지니까,만약 this를 사용하면 bind등을 사용해야함
	
	배열을 구조분해할땐 딴데랑 똑같이 갯수맞춰서
		const [a,b,,c]=array
	하면 4개짜리로 나눠서 들어감
	
	그리고 es6부터는 클래스문법도 지원함,단 프로토타입으로 동작하는건 똑같고 그냥 외형상 클래스로 바꾼거
	
	프로미스는,비동기식으로 동작하는 함수임
	그냥 함수를 진행하다가 성공,실패로 나눠서 기입하고(resolve,reject)
	거기따라서 비동기식으로 진행하다가 성공,실패따라서 다른결과나오는거
	이거도 try,catch,finally랑 같은식으로 진행됨
	리턴값은 resolve와 reject의 값을 받으면됨
		const abc=new Promise((resolve,reject))=>{
			if (t/f){
				resolve('T')
			}else{
				reject('F')
			}
		}
		abc.then((message)=>{
			console.log(message)
		}).catch((error)=>{
			console.error(error)
		}).finally(()=>{
			console.log(message)
		})
	이런식으로 그냥 비동기함수를 성공실패로 나눠서 동작함
	즉,resolve가 호출되면 then,reject가 호출되면 catch가 작동하는식
	그리고 프로미스는,선언되자마자 바로 동작함,즉 밑에서 then은 결과값을 받는거고 일단 실행은 위의 abc선언부터 바로실행됨
	그리고 프로미스안에 프로미스를 선언하고,리턴한다음 그걸 바로 then으로 붙여나갈수도 있음
	이러면 이전 then의 리턴값을 다음then의 매개변수로 넘김
	이걸 사용해서 콜백을 프로미스로 바꿀수있음
	이렇게했을땐,마지막에 캐치하나써서 모든 에러를 거기서 한번에 처리할수있음
	
	그리고 promise.all([pro1,pro2]).then
	으로 여러개를 한번에 실행할수도있음
	이경우엔,모두 결과값이 나올때까지 기다렸다가,다 나오면 그걸 배열로 리턴함,만약 하나라도 reject가 있으면 catch로 가고
	
	async/await는 프로미스가 then catch로 길어지니까,그걸 해결하기위해 나온 비동기기능임
	그냥 프로미스에서 엑시큐터(실제실행함수)부분만 남기고 나머지 다없애고 함수앞에 async붙이면 똑같이동작함
	그리고 async의 리턴값은 무조건 프로미스임,그래서 명시적으로 하고싶으면 promise를 붙여도되지만,동작은똑같음
	async함수를 선언하고,프로미스앞에 await를 붙이면 됨,그리고 catch를 하기위해,try catch로 딴언어랑 똑같이 싸면됨
	이러면 await와 await사이가 기존 then이 됨
	즉 await가 끝날때까지 기다렸다가 다음거로 진행함,즉 비동기사이에서 동기적으로 진행할수있는거
	비동기로 처리하고 그걸 다 받을때까지 기다렸다가 실행하는 게이팅패턴을 사용하고싶으면,
	프로미스들을 배열에 받은뒤에 그걸 await+ promise.all로 실행하는식으로 처리할수있음
	만약 한줄한줄 await를 사용하면(반복문에 넣는거도 포함해서),안에서 전부 동기식으로 처리해버리니까 하는의미가없어짐
	이걸 비동기끼리 묶어서 동시에 실행하고싶으면,promise.all써야함
	즉 await를 사용하면,코드가 알아보기 엄청편해짐
	그리고 for문과 같이 사용해서,프로미스를 순차적으로 실행할수도 있음
		(async()=>{
			for await (promisere of [pro1,pro2]){
				console.log(promisere)
			}
		})
	이런식

2.프런트엔드 js
	ajax(비동기웹)을 사용해서 restapi를 사용할때도 프로미스로 보내면됨
		axios.get(http://주소).then((result)=>{
			...
			console.log(result)
			console.log(result.data)
		}).catch((error)=>{
			...
			console.error(error)
		})
	이런식임
	프로미스니까 그냥 async/await로 바꿀수있음
		(async()=>{
			try{
				const result=await axios.get(http://주소)
				console.log(result)
				console.log(result.data)
			}
			catch{
				console.error(error)
			}
		})();
	post는
		(async()=>{
			try{
				const result=await axios.post(http://주소,{json값들})
				console.log(result)
				console.log(result.data)
			}
			catch{
				console.error(error)
			}
		})();	
	이렇게 보내면됨
	
	
	formdata는,html form태그 데이터를 동적으로 제어함,보통 ajax와 같이 사용됨
	먼저 formdata는
		append
		has
		get
		getall
		delete
	메서드를 가지고있음
	얘는 append로 키-값형식으로 저장하고(abc.append('name','aa')),키값이니까 같은키에 여러값이 들어갈수도 있음
	그리고 has로 그 키에 값이있나 확인하고,get으로 키에해당하는값 하나를 받고,getall로 키에해당하는값 전체를 받음
	delete로 키를 삭제,set으로 현재키 수정
	이걸 post같은데서 매개변수로 받아서 거기에 해당하는걸 할수있음
	
	그리고 ajax요청을 보낼때,주소에 한글이 들어가면
	백틱을 써서 
		`앞주소${encodeURIcomponent('한글문자')}`
	를 사용해서 16진수로 바꾸고
		decodeURIcomponent('16진수')
	로 다시 돌릴수있음

	프런트엔드로 값을 넘길때 사용되는 공식방식이 데이터속성임
	html태그의 속성으로 data-이름='값'으로
		<li data-id="1" data-user-job="pro"  />
	이런식으로 던져주면
	id,userJob 이렇게 자바스크립트에서 사용할수있어짐
		<script>
			console.log(document.querySelector('li').dataset)
			document.querySelector('li').dataset.money=1000
			
		</script>
	이렇게 꺼내쓸수있고,dataset.이름=값 으로 삽입도 가능함 (dataset.money=1000은 data-money="1000")
	
	
	
3.노드기능
	기본적으로 cmd에서 node치면 repl(읽고해석하고리턴 루프),즉 일반입력모드로 동작함
	파일로 실행하고싶으면 파일만들고 node 파일경로하면 됨,js는 생략해도됨
1.모듈	
	노드js에선 코드를 모듈로 만들수있음,즉 코드를 모듈로 만들어서 다른코드에서 임포트해서 사용할수있음
	일반적으론 파일단위로 파일하나가 모듈하나가 됨
	
	이때
		module.exports={
			odd,even//함수나 변수,상수
		}
	
	저안에 있는거만 가져다쓸수있음
	아니면
		exports.odd='문자열'
	이런식으로 변수를 바로 던질수도있음
	이경우엔 반드시 객체처럼 이름과 값을 대입해야함,그래서 함수의경우는 저렇게할수없음
	사용할땐
		const {odd,even}=require('./경로')
		console.log(odd)
	이런식으로 사용하면됨
2.노드 내장 객체
	global은 브라우저의 window같은 전역객체임
	전역객체라서 모든파일에서 접근할수있고,global을 생략해도됨
	console같은경우도 global.console인데 글로벌생략한거
	
	그리고 전역객체라는걸 이용해서,모듈간에 데이터를 공유할수있긴한데,아무리봐도 안티패턴인듯,이렇게하면 나중에못찾을거같음
	그냥 값가져와야하면 모듈형식으로 명시적으로 값을불러와서 사용하는게 좋을거같음
	
	console에서 time과 timeend로 그 사이의 시간을 잴수있고,table에 배열넣으면 테이블형태로 표현해줌
	dir은 객체를 콘솔에 표시해줌
	
	타이머로는 setTimeout,setInterval,setImmediate가 있음
	셋타임아웃은 명시된 시간이 지난후에 콜백함수를 실행큐에 넣고,
	셋인터벌은 명시된 시간동안 반복적으로 콜백함수를 실행큐에 넣음
	setimmediate는 즉시 콜백함수를 실행함
	타이머를 취소할땐,각각 clearTimeout(아이디),clearInterval(아이디),clearImmediate(아이디)로 취소할수있음
	저 아이디는,그 타이머가 들어있는 상수나변수를 넣으면됨(일반적으로 js는 함수를 변수에담아 실행하니까)
	
	노드js에서 __filename과 __dirname은 현재파일명(파일명과 경로를 합쳐서나옴)과 현재파일경로를 리턴하는 키워드임
	
	그리고 노드에서 최상위 this는 module.exports를 가리키고,함수내부에서의 this는 글로벌객체를 가리킴
	
	노드js에서도 호이스팅이 일어나니까,require이 최상단에 반드시 있어야하지않고,exports도 최하단에 있어야하지않음
	그리고 require.cache에는 파일이름,경로등이 들어있음
	require.main은 노드실행시 첫 모듈을 가리킴,즉 처음시작한객체를 가리킴
	현재파일이 첫모듈(node 파일명 으로 시작한모듈)인지 알려면,require.main===module을 하면 알수있음
	첫 모듈의 이름은 require.main.filename으로 확인하면됨
	
	그리고 순환참조(서로를 모듈로 부르는것)가 일어나면,에러가 안뜨고 순환참조대상을 그냥 빈객체로 만들어버리니 조심해야함
	
	process객체는 현재 실행되는 노드프로세스정보를 가지고있음,즉 현재cpu사용량,플랫폼등을 확인할수있음
	process.env는 환경변수를 부르고,바꿀수있음
	process.nextTick은 이벤트루프가 다른콜백보다 이걸 우선처리하게 바꿀수있음,이러면 setImmediate나 타임아웃보다 먼저실행됨(동시라고해도)
	process.exit는 실행중인 노드 프로세스를 종료함,서버에선 안쓰고(그냥끄면되니까),일반프로그램에서 수동으로멈출때 사용함
	process.exit(0)은 정상종료,1은 비정상종료
	
	
3.노드내장모듈사용	
	1.os모듈
		os모듈은 컴퓨터의 운영체제정보를 가져옴,즉 process와 역할이 겹침
		일반적으로 사용할일이 별로없긴할듯
	2.path
		path는 경로조작을 도와줌
			path.dirname //파일의 경로
			path.extname//파일의 확장자
		등을 리턴받을수있음
			path.join //여러경로를 합침('/a','/b','/c')-> /a/b/c
		
	3.url
		웹주소를 쉽게 조작하게 도와주는모듈
		방식이 채신식인 whatwg와 그냥 구url이 있는데,whatwg가 처리할수없는(host가 없이 pathname이 있는)거도 있어서,
		이런건 그냥url로 처리해야함
		whatwg는 search를 searchParams이라는 객체로 반환해줘서 유용하긴함
			const a=url.parse('주소') //주소를 분해해서 키값배열에 넣어줌
			url.format//분해된 주소를 합쳐서 문자열로 바꿔줌
		
		searchParams은,각 쿼리를 각각 나누고,그 키를 키-값형식으로 배열에 저장함
		그리고 getall(키)로 전부 가져오거나,has,keys,values등으로 뽑아낼수있음
		
		기존 url을 사용할땐,querystring를 사용하면 search부분을 객체로 만들어서 사용할수있음
		
	4.crypto
		이건 다양한방식으로 암호화를 해줌,이건 기본적으로 따로 뭐안해도 멀티스레드로 동작함
		여긴 단방향암호화(복호화불가능암호화),양방향암호화(키를사용해서복호화)가 있음
		단방향암호화는 패스워드를 저장할때 사용하고,양방향은 서로 데이터주고받을때 사용함(ssh정리참조)
		
		단방향은 해시를 사용해서 암호화함,이떄 막 10만번반복하는식으로해서 연관성을 없애버림
			crypto.pdkdf2(해시화문자열,기준문자열(해시키),반복횟수,출력바이트,해시알고리즘)
		
		양방향은 키를 사용해서 복호화를 할수있음
			a=crypto.createCipheriv(알고리즘,키,iv(초기화백터값))
			re=cipher.update(암호화문장,입력인코딩,출력인코딩)
			re+=a.final('re의 인코딩값') //암호화끝
			
			dec=crypto.createDecipheriv(알고리즘,키,iv)
			re2=dec.update(re,입력인코딩,출력인코딩)
			re2=dec.final('re2출력인코딩값')
		이렇게 암호화복호화를 할수있음	
	5.util
		각종 유틸기능이 들어감
			util.deprecate//함수가 deprecated됐다고 경고함
			utol.promisify//콜백을 프로미스로 바꿔줌
	
	6.worker_threads
		멀티스레드로 작업할때 사용함
		isMainThread로 메인스레드인지 아닌지 확인할수있고,
		new Worker로 워커를 생성하고,
		worker.postMessage로 부모에서 워커로 메세지를 보낼수있고,parentPort.postMessage로 부모에게 메세지보낼수있음
		받을땐 worker.on(메세지명)으로 부모는 받고,parentPort.on(메세지명)으로 워커는 받을수있음
		워커의경우 on하고나서 받았으면 close로 워커를 명시적으로 닫아줘야함,안그럼 안꺼짐
		
		멀티스레딩에서 제일어려운건,일을 나누는거임
	
	7.child_process
		이건 노드에서 다른프로그램을 실행하거나,cmd를 돌릴떄 사용함
			const exec=require('child_process').exec
			const process= exec('명령어')
		이런식으로 명령어를 실행함
		다른프로그램을 실행할떈
			const spawn = require('child_process').spawn
			constpro=spawn('python',['파일명.py'])
		이렇게 명령어와 실행파일을 주면됨
		exec와 spawn의 차이는,셸을 실행하냐 아니면 프로세스를 실행하냐의 차이임

4.파일시스템
	fs모듈은 파일시스템에 접근하는 모듈임
	기본적으로 웹에서는 fs를 사용한 접근이 금지되어있음
	이거도 사용법은
		fs require하고
		fs.readfile('경로',(err,data)=>{
			if (err){
				에러처리
			}
			console.log(data.tostring())
		})
	이런식으로 사용하면됨
	tostring을 안붙이면,메모리값이 나오니까 붙여야함
	기본적으로 콜백으로 나오니까 프로미스로 바꾸려면
		const fs = require('fs').promises;
		fs.readfile('./readfile.txt')
		.then((data)=>{
			console.log(data.tostring())
		})
		.catch((err)=>{
			에러처리
		})
	이렇게하면됨,이러면 프로미스기반의 모듈로 연결해줌
	쓸때도 똑같이
		fs.writefile('경로','문자열')
		.then(()=>{
			return fs.readFile('경로')//옵션,적은거보여주려면
		}).catch 예외처리
	이런식으로 적을수있음
	
	기본적으로 비동기로 동작해서,i/o의 순서는 자기맘대로동작함
	순서대로 하고싶으면
		fs.readFileSync
	를 사용하면됨,근데 io에서 사용할일이 별로없을듯
	만약 비동기로하되 비동기끼리 순서를 유지하고싶으면
		const fs = require('fs').promises;
		fs.readfile('./readfile.txt')
		.then((data)=>{
			console.log(data.tostring())
		})
		.then((data)=>{
			console.log(data.tostring())
		})
	이런식으로 다음then을 붙이면 저건 동기적으로 처리됨
	
	
	그리고 파일을 읽고쓸떈 버퍼와 스트림방식이 있음
	버퍼는 파일의 크기만큼 메모리에 자리를 만들어두고,사용하는식이고,사용법은
		a=Buffer.from('문자열')//버퍼로바꾸기
		a.concat()//버퍼문자열로 바꾸기
		b=buffer.alloc(바이트크기)//바이트크기만큼 빈버퍼생성
		
	이렇게 할수있음
	버퍼는 편하긴한데,문제가 무조건 파일크기만큼을 비워야하니까 막 1기가넘는파일을 전송할때,그걸 메모리에 올리고 그래야함
	그래서 나온게 스트림임
	이건 버퍼를 쪼개서 여러번으로 나눠보내는거,이때 나눠진조각을 청크라고 함
	파일읽기의사용법은
		rs=fs.createReadStream('파일경로',{highWaterMark:16})//16은 청크의 크기,기본값은 64kb
		const data=[]
		rs.on('data',(chunk)=>{ //데이터전송중일때
			data.push(chunk)
			
		})
		rs.on('end',()=>{ //데이터전송완료후 버퍼를 합침
			console.log(Buffer.concat(data).tostring())
		})
		rs.on('error',(err)=>{
			에러처리
		})
	이렇게 이벤트식으로 데이터전송,완료,에러 3개로 나눠서 동작함,rs.on의 첫번째 매개변수가 이벤트리스너임,data,err,end를 보통 사용함
	파일쓰기는
		const ws=fs.createWriteStream('경로')
		ws.on('finish',()=>{
			완료시 이벤트
		})
		ws.write('적을내용1')
		ws.write('적을내용2')
		ws.end()//스트림저장하고 완료이벤트출력
	이렇게함
	읽은걸 바로쓸수도있는데,이걸 파이프라고부름
		rs.pipe(ws)
	이렇게하면 읽은걸 바로 라이트로 던짐
	그리고 스트림사이에 계속연결되니까,읽고,압축하고 던지려면
		rs.pipe(zs).pipe(ws) //zs는 압축모듈,zlib모듈(zlib.createGzip)
	이렇게하면 읽어서 압축하고 던짐
	
	스트림을 사용하면 정해진량만큼의 메모리밖에 점유하지않아서,메모리오버나서 문제될일이 없어짐
	
	
	fs에는 저거말고도 뭐 디렉토리가 있는지확인,폴더생성,파일오픈,이름바꾸기,파일삭제(없으면에러남),폴더삭제(폴더비어있지않으면에러)등등 메서드가 있음
	그리고 fs는 기본적으로 스레드로 동작함
	
5.이벤트 이해
	이벤트를 직접 생성할떈,events모듈의 EventEmitter()을 사용하면됨
		const me= new EventEmitter()
		me.addListener('event1',()=>{ //이벤트이름과 액션을 연결
			console.log('이벤트1')
		})
		me.on('event1',()=>{ //이벤트이름과 액션을 연결,addListener와 같음
			console.log('이벤트1')
		})
		me.once('event1',()=>{ //이벤트이름과 액션을 연결,이벤트가 한번만 발생,한이벤트에 여러개가 묶일수있음
			console.log('이벤트1')
		})	
		me.emit('이벤트명')//이벤트호출
		me.removeAllListeners('이벤트명')//이벤트명의 모든 이벤트를 삭제함
		const li=()=>{
			이벤트내용
		}
		me.on('이벤트명2',li)//이벤트와 리스너연결
		me.removeListeners('이벤트명',리스너변수)//이벤트에서 특정리스너제거
		me.off('이벤트명',리스너변수)//removeListeners와 같음
		me.listenerCount('이벤트명')//이벤트에 연결된 리스너갯수리턴
	
	
6.예외처리
	서버에선 예외처리가 매우중요함,예외떠서 서버멈추면안됨
	기본적으론 try,catch로 잡으면됨
	보통 노드내장모듈은 자체적으로 try catch해주긴하지만,기본적으로 넣어야함
	
	프로미스는 일단 에러를 알아서 처리해주긴하는데,그래도 항상 catch를 붙여주는게좋음
	
	그리고
		process.on('uncaughtException',(err)=>{
			에러처리
		})
		
	이렇게 이벤트처리를 하면,만약 예기치못한에러가 떠도 일단 처리는해주는데,당연히 다음코드가 정상동작한다는 보증이 없어지니까,정 답이없을때만 써야함
	즉 저건 단순히 에러내용을 저장하는용도로만 쓰고,기록하고 바로 exit로 프로세스종료하는게 좋음
	
	
	
	
	
4.http모듈로 서버만들기	
1.요청과 응답이해
	기본적으로 서버를 돌릴땐
		http 임포트
		http.createServer((req,res)=>{
			응답내용
		})
	이렇게하면 됨
	req에는 요청정보,res에는 응답정보가 담김
	즉
		http 임포트
		http.createServer((req,res)=>{
			res.wirteHead(200,{'Content-type':'text/html; charset=utf-8'})
			res.write('<h1>Hello Node</h1>')
			res.end('<p>Hello Server</p>')
		})
		.listen(8080,()->{
			console.log('8080포트대기')
		})
	이렇게하면 8080포트가 열리고,로컬호스트 :8080으로 접근할수있음
	그러면 저 헬로우노드 헬로서버가 나옴
	
	즉 createServer에서 응답내용을 명시하고,
	그걸 listen으로 열어주면 거기적힌포트로 접근하면 크리에이트서버의 이벤트가 발생해서 응답을 하게됨
	
	그리고 listen에 콜백함수를 넣는거대신,
		server.listen(8080)
		server.on('listening',()=>{
			console.log('8080포트대기')
		})
		server.on('error',(error)=>{
			console.error(error)
		})
	이렇게 이벤트리스너를 붙일수도있음
	
	한번에 여러서버를 쓸때도,크리에이트서버를 여러개하고 포트만다르게해서 listen하면됨
	그리고 매번 html을 일일히 적을수없으니까,그냥 파일에 만들고 파일던지는게 좋음
		http.createServer(async (req,res)=>{
			try{
				const data=await fs.readFile('./html파일명')
				res.wirteHead(200,{'Content-type':'text/html; charset=utf-8'})
				res.end(data)
			} catch(err){
				console.error(error)
				res.wirteHead(500,{'Content-type':'text/html; charset=utf-8'})
				res.end(err.message)
			}
		})
		.listen(8080,()->{
			console.log('8080포트대기')
		})		
	이렇게 파일로 던지고,못읽을수도있으니까 못읽으면 에러던지면됨(일단 무조건 응답을 보내긴해야함,안그럼 타임아웃까지 기다려야하니까)
	
2.rest와 라우팅 사용하기
	restapi를 사용해서,rest메서드와(get,post등)과 주소와 쿼리+데이터를 보내면,그걸 받아서 라우팅하는방식으로 동작시킬수있음
	대충 if문을 사용하면됨
		http 임포트
		http.createServer(async(req,res)=>{
			if (req.method==='GET'){
				if(req.url === '/'){
					res.wirteHead(200,{'Content-type':'text/html; charset=utf-8'})
					res.write('<h1>Hello Node</h1>')
					return res.end('<p>Hello Server</p>')
				}
				else if (req.url==='/about'){
					const data= await fs.readFile('./about.html')
					res.wirteHead(200,{'Content-type':'text/html; charset=utf-8'})
					return res.end(data) //end자체만으론 함수가안끝나니까 return붙여야함
				}
				try{ // /도 /about도 아니면 
					const data = await fs.readFile(`.${req.url}`)
					return res.end(data)
				}catch(err){
					//404에러발생
				}
			}
			res.wruteHead(404)

		})
		.listen(8080,()->{
			console.log('8080포트대기')
		})	
	대충 이렇게던지면되는데,물론 전체를 싸는 try catch(500에러)도 있긴해야하지만
	post의 경우엔(delete,put등도 포함해서)
		req.method
			req.url
				let body=''
				req.on('data',(data)=>{
					body+=data
				})
				return req.on('end',()=>{
					const{name}=JSON.parse(body)
					const id=Date.now()
					users[id]=name
					res.writeHead(201)
					res.end('등록성공')
				})
	이런식으로 스트림으로 받아서 json으로 넣으면됨,기본적으로 req와 res도 스트림형식이라서,스트림처럼 읽으면됨
	근데 이렇게 if문으로 분기하면 보기머리아프니까,express모듈을 사용하면 쿠키세션과 rest분기도 편해짐
	
	
	
3.쿠키와 세션
	로그인을 구현하려면 쿠키와 세션을 알아야함
	서버에서 클라이언트를 구분하기위해 기본적으로 사용하는건 쿠키임
	쿠키는 유효기간이 있는 단순한 키-값쌍임
	서버로부터 쿠키가오면 브라우저는 저장해뒀다가 다음에 그 서버에 요청할때마다 쿠키를 같이 보내고,서버는 그걸 읽어서 누구인지를 파악함
	브라우저는 쿠키가 있으면 자동으로 같이 보내주니까 따로 처리할필요가 없음
	
	즉 서버는 미리 클라이언트에 요청자를 추정할만한 정보를 쿠키로 보내고,그다음부턴 쿠키를보고 누군지파악함
	쿠키를 만들어서 넣을떈
		http 임포트
		http.createServer((req,res)=>{
			res.wirteHead(200,{'Set-Cookie':'쿠키키=쿠키값'})
			res.end('<p>Hello Server</p>')
		})
		.listen(8080,()->{
			console.log('8080포트대기')
		})	
	이렇게 보내면됨
	그리고 쿠키를 보내면,기본적으로 홈페이지의 아이콘을 같이 보냄(favicon.ico)
	
	서버에서 이걸 사용하려면,쿠키 파싱함수를 만들고(기본적으로 문자열로 들어옴),기본적으로 쿠키의 특정값이 있는지 없는지로 분기타서 맞춰서 던져주면됨
	
	근데 그냥 이렇게만쓰면 쿠키가 노출되고,쿠키를 조작할수있기때문에,쿠키에는 번호만 주고,서버에서 사용자정보를 관리하게만들어야함
	(특정숫자와 정보배열이 연동되는식으로),이게 세션임
	보통은 그냥 다른사람들이 만들어둔 세션모듈을 사용함
	
	
	
4.https와 http2
	https는 웹서버에 ssl암호화를 추가한거
	이건 근데 해보려면 인증서필요함
	거의 비슷한데,http모듈대신 https모듈 임포트하고,cert,key,ca를 읽어서 https.createServer앞 매개변수에 넣어주면됨
	그리고 443포트를 열면됨
	
	http2는 그냥 좀 빠른 http인데,그렇게 큰차이는 안난다고함
	이거도 그냥 https를 http2모듈로 바꾸고 똑같이쓰면됨

	
	
5.cluster
	클러스터모듈은 기본적으로 싱글프로세스로 동작하는 노드가,cpu를 전부사용하게 해주는 모듈임
	쓰레드가 아닌 프로세스를 사용함
	기본적으로 마스터는 워커를 생산하는일만 하고,워커들이 같은포트에서 대기하고있다가 일을 받아가서 하는식
	
	
	
	
	
5.패키지매니저
	보통 js에서 패키지매니저로 npm과 yarn을 사용함
	이책에선 npm사용하는듯
	
	노드js의 프로젝트폴더에 package.json을 추가하면(npm init하면됨),설치한 패키지의 버전정보가 다 적혀짐
	기본적으로 init하면 프로젝트를 생성해줌,그래서 이름,버전,깃레포,키워드 등을 적어주면됨
	
	package.json의 scripts안에 내가 실행한 npm 명령어가 저장되고,저기에 따로 명령어를 저장해두고 쓸수도있음
	
	npm으로 설치하면,node_modules에 저장됨
	그리고 개발중에만 사용할 패키지를 설치할땐
		npm install --save-dev 패키지명
	하면 됨
	
	그리고 노드모듈폴더를 지워도,npm install하면 다시 다 설치해줌
	기본적으로 npm설치하면 전역설치인데,문제는 만약 다른프로젝트에서 뭘설치해서 npm install없이 사용가능하면,package.json에 값이 안남음
	그래서 지역설치를 할땐 npx를 사용하면됨
	
	노드js패키지의 버전은 3단위로 나뉘는데,메이저 마이너 패치임
	보통 메이저끼리는 하위호환이 안되고,마이너에서는 됨
	그리고 버전앞에 ^붙은건 마이너단까지 호환된다는거(^1.1.1이면 1.1.1~2.0.0)
	~붙은건 패치단까지 호환(~1.1.1이면 1.1.1~1.2.0)
	
	그리고 어지간하면 프로젝트에서, 처음에 깔았던 패키지에서 업데이트는 안하는게좋음
	
	
6.익스프레스 웹서버
1.익스프레스시작
	일단 맨먼저 폴더를만들고 npm init로 package.json을 생성하고,
	package.json의 스크립트에 start:nodemon app 으로 노드몬(코드변경시 자동재시작해줌)설정하고(dev에서만 쓰는게좋음)
	코드를 적으면됨
	
	기본적으론
		express모듈임포트
		const app=express()
		app.set('port',process.env.PORT || 3000) //env포트환경변수가있으면 그거쓰고,아니면 3000번사용
		
		app.get('/',(req,res)=>{
			res.sendFile(path.join(__dirname,'html파일이름'))
		})
		
		app.listen(app.get('port'),()=>{
			console.log('대기중')
		})
		
	이런식으로,포트세팅하고 라우팅 나열하고 listen하면됨
	get은 get요청이 들어오면 /인지 확인하고 들어가는,2중if문을 암축해둔거임
	요청이 들어오면 파일경로에 있는 파일을 전송함
	
	
2.자주사용하는 미들웨어
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	