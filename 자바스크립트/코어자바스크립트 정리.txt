자바스크립트의 데이터 타입에는 기본형과(number,string,boll등) 참조형(array,function등)이 있음

데이터는 기본적으로 변수명부분과 데이터 부분으로 나눠지는데 변수명에 이름적고 데이터부분을 포인터하게 만들어져있음

기본형은 기본적으로 불변성을 띔
왜냐면 선언된 변수의주소부분은 바뀌지 않고 가리키는 데이터값의주소만 바뀌니까
(데이터부분은 아예 상수라서 한번 선언된값이랑 똑같은건 무조건 같은데씀 깊은복사안하면)
기본적으로 처음에 선언된 변수주소는 바뀌지않음
그래서 변수는 불변성을 가지고있지만 데이터 영역은 바꿀수있고,상수는 아예 처음에 한번 변수명에 데이터를 박아두면 건드리지도 못함
(변수와 상수의 차이는 변수영역메모리 불변성은 데이터영역의 메모리)

참조형은 변수->데이터->변수[i]->데이터 로 구성되어있음(1차원배열)
그래서 기본적으로는 변수[i]부터 바뀔수있기때문에 가변값임

그래서 변수를 복사할때는 기본형같은경우 복사하든 대입하든 복사하고나서 바꿀때 행위가 같지만,
참조형은 주소값을적고 다시 주소값으로 가기떄문에 그냥 얇은복사를 해버리면(첫주소값을 가리키면) 바꾸면 주소값에있는걸 바꾸기떄문에 둘다바뀌게됨
그리고 그냥 변수[i]->데이터로 끝나면 변수[i]까지 불러오고 복사해버리면 되는데 
2차원배열이상같은경우 재귀로 바닥까지 들어가서 바꿔야됨(깊은복사)
뭐 귀찮으면 json파싱한다음에 다시바꾸는식으로 한다는데 그러면 내부함수나 겟셋은못받으니까
그래서 아예 리액트처럼 새로객체만들어서 붙여넣기하거나 하는거같음(usestate)

js에는 undefined와 null이 있는데 
언디파인드는 당연히 뭐 초기화안하거나 없는거건드릴때 나오고 null은 내가 없다고 지정했을때 넣어주는거임
그리고 명시적으로 언디파인드를 넣어주면 반복문이 그거 안건너뛰고 동작하고 아니면 건너뛴다는데 누가 언디파인드를넣어 널넣지

null은 자바스크립트 자체 버그가있어서 typeof로 보면 오브젝트로 나옴 그래서 n==null이랑 n==undefined가 같게나옴
그래서 n===null을 해야 null확인가능함

실행컨택스트는 실행할 코드에 제공할 정보를 모아둔 객체 
기본적으로 스택으로 동작 (전역   전역-a클래스   전역-a클래스-b함수   전역-a클래스   전역 )

자바스크립트에서는 어디서 선언되든간에 선언된(var a) 변수나 객체가 있으면 최상단으로 끌어올려 버림
print a       var a   
var a=1    --->print a
               a=1
이런식으로 대입부분만 남겨두고 다 올려버려서 저거 프린트a도 언디파인드가 나오게됨
함수의 경우는 함수 전체를 끌어올려서 함수명과 같은 변수명을 선언하고 대입한거랑 똑같이취급
fun a(){}  -> var a=fun a(){}

함수 표현방식에는 3가지가있는데
function a(){}//함수선언
a();

var b=function (){}//익명표현
b();

var c=function d(){} //안씀이건
c();
d();//에러

선언이랑 익명표현 차이점이 뭐냐면 
바로 함수명을 적으면 통째로 올라가는데 익명표현을 해버리면 var b만 올라가서 그위에서 사용이 불가능함(장점)

그래서 막 두함수가 똑같은이름으로 중복해서 나오게될때 익명표현으로 함수에박아버리면 에러뜨면서 막히게됨

스코프는 식별할 유효범위
전역으로 생성하면 전역에서 식별할수있고
함수내부에서 생성하면 함수내부에서만 식별할수있음
보통 검색은 내부에서부터 하고 없으면 한칸 밖으로 나가는식으로 전역까지 스택으로 나가다가 발견하면 그것만 사용하게됨

이것도 선언은 위로 끌려가니까 호출보다 선언이 밑에있어도 자기 함수 내부의 것부터 스코프에 잡히게됨


 


