자바스크립트의 데이터 타입에는 기본형과(number,string,boll등) 참조형(array,function등)이 있음

데이터는 기본적으로 변수명부분과 데이터 부분으로 나눠지는데 변수명에 이름적고 데이터부분을 포인터하게 만들어져있음

기본형은 기본적으로 불변성을 띔
왜냐면 선언된 변수의주소부분은 바뀌지 않고 가리키는 데이터값의주소만 바뀌니까
(데이터부분은 아예 상수라서 한번 선언된값이랑 똑같은건 무조건 같은데씀 깊은복사안하면)
기본적으로 처음에 선언된 변수주소는 바뀌지않음
그래서 변수는 불변성을 가지고있지만 데이터 영역은 바꿀수있고,상수는 아예 처음에 한번 변수명에 데이터를 박아두면 건드리지도 못함
(변수와 상수의 차이는 변수영역메모리 불변성은 데이터영역의 메모리)

참조형은 변수->데이터->변수[i]->데이터 로 구성되어있음(1차원배열)
그래서 기본적으로는 변수[i]부터 바뀔수있기때문에 가변값임

그래서 변수를 복사할때는 기본형같은경우 복사하든 대입하든 복사하고나서 바꿀때 행위가 같지만,
참조형은 주소값을적고 다시 주소값으로 가기떄문에 그냥 얇은복사를 해버리면(첫주소값을 가리키면) 바꾸면 주소값에있는걸 바꾸기떄문에 둘다바뀌게됨
그리고 그냥 변수[i]->데이터로 끝나면 변수[i]까지 불러오고 복사해버리면 되는데 
2차원배열이상같은경우 재귀로 바닥까지 들어가서 바꿔야됨(깊은복사)
뭐 귀찮으면 json파싱한다음에 다시바꾸는식으로 한다는데 그러면 내부함수나 겟셋은못받으니까
그래서 아예 리액트처럼 새로객체만들어서 붙여넣기하거나 하는거같음(usestate)

js에는 undefined와 null이 있는데 
언디파인드는 당연히 뭐 초기화안하거나 없는거건드릴때 나오고 null은 내가 없다고 지정했을때 넣어주는거임
그리고 명시적으로 언디파인드를 넣어주면 반복문이 그거 안건너뛰고 동작하고 아니면 건너뛴다는데 누가 언디파인드를넣어 널넣지

null은 자바스크립트 자체 버그가있어서 typeof로 보면 오브젝트로 나옴 그래서 n==null이랑 n==undefined가 같게나옴
그래서 n===null을 해야 null확인가능함

실행컨택스트는 실행할 코드에 제공할 정보를 모아둔 객체 
기본적으로 스택으로 동작 (전역   전역-a클래스   전역-a클래스-b함수   전역-a클래스   전역 )

자바스크립트에서는 어디서 선언되든간에 선언된(var a) 변수나 객체가 있으면 최상단으로 끌어올려 버림
print a       var a   
var a=1    --->print a
               a=1
이런식으로 대입부분만 남겨두고 다 올려버려서 저거 프린트a도 언디파인드가 나오게됨
함수의 경우는 함수 전체를 끌어올려서 함수명과 같은 변수명을 선언하고 대입한거랑 똑같이취급
fun a(){}  -> var a=fun a(){}

함수 표현방식에는 3가지가있는데
function a(){}//함수선언
a();

var b=function (){}//익명표현
b();

var c=function d(){} //안씀이건
c();
d();//에러

선언이랑 익명표현 차이점이 뭐냐면 
바로 함수명을 적으면 통째로 올라가는데 익명표현을 해버리면 var b만 올라가서 그위에서 사용이 불가능함(장점)

그래서 막 두함수가 똑같은이름으로 중복해서 나오게될때 익명표현으로 함수에박아버리면 에러뜨면서 막히게됨

스코프는 식별할 유효범위
전역으로 생성하면 전역에서 식별할수있고
함수내부에서 생성하면 함수내부에서만 식별할수있음
보통 검색은 내부에서부터 하고 없으면 한칸 밖으로 나가는식으로 전역까지 스택으로 나가다가 발견하면 그것만 사용하게됨

이것도 선언은 위로 끌려가니까 호출보다 선언이 밑에있어도 자기 함수 내부의 것부터 스코프에 잡히게됨

this는 자바스크립트에선 딴데랑 다르게 동작함
보통 다른데서는 현재함수나 메서드 가리키는건데 얘는 전역공간에서 this하면 전역공간 가르킴

자바스크립트의 모든 변수는 특정 객체의 프로퍼티로 동작함
그래서 전역변수를 선언해도 전역변수의 프로퍼티로 작동해서
var a = 1;
console.log(a); // 1
console.log(window.a); // 1
console.log(this.a); // 1
이렇게됨
그래서 그냥 console.log(a)해도 1이 나오는 이유도 스코프돌렸는데 제일 가까이있어서 나오는거임

단 del연산할떄는 명시적으로 window.a이런식으로 생성한거아니면 못하게막음 실수로지울까봐그런듯

메서드와 함수에서의 this는 구분을 a.method()랑 func() 이렇게 그냥 앞에 점이 있나없나만 가지고 구분해서
함수로 부를떈 this가 앞에 뭐 아무것도 없기떄문에 전역객체를 가르키고 메서드로 부르면 현재 포함된객체로 this가 바인딩됨
이것도 함수를 메서드로 바인딩시켜버려도 메서드콜하면 앞에 점이있기때문에 this는 현재 들어있는 객체를 가르키게됨

그래서 막 위에있는this값 필요하면 self=this이런식으로 넣어서 이거 가져다쓰던가 화살표함수로 쓰면 this는 상위객체를 가르키게되서
변수쓰는꼼수안써도됨

콜백함수에서는 부르는애가 어떻게했냐따라서 걔를 따라감 이거도 앞에 점있으면 메서드취급이고 없으면 함수취급이니까 어지간하면 안써야할거같음

생성자함수에서는 this가 생성될 자기 자신(앞에 new붙여서 부를때)을 가리킴
var a= new cat(c,b)하면 this는 a를 따라가서 자기자신을 세팅할수있음

그냥 명시적으로 바인딩 하고싶으면 call이나 apply로 적은값 줘서 바인딩해버릴수도있음

뭐 특수용도로 쓸수있다는데 
(...연산자처럼 여러개 묶어서 배열로만들기,배열처럼생긴 객체는 깡으로는 배열메서드를 못쓰는데 apply쓰면 쓸수있다던지,생성자 내부에서
다른 생성자 부른다던지)

bind는 call이랑 비슷한데 즉시부르진않고 받은 this랑 인자들로 새로운함수 만들어서 리턴해줌
bind는 bind를 써서 만든 함수에 .name을 붙여서 불러보면 bound (기존함수명)이 붙어서 추적하기쉬움

바인드나 콜이나 어플리같은거로 아까 뭐 변수로받아서 쓰고하는거 대신쓸수도있음

콜백함수는 어떤 상황이 들어오면 나를 불러달라고 다른함수에 권한을 넘겨줄때 쓰는함수

setinterval(함수,밀리세컨드) 밀리세컨드가 지나면 함수콜(콜백함수)
clearinterval(변수)세팅된 시간을 지워버림(멈춤)

콜백함수를 실행하면 따로 프로세스를 만들어서(비동기)걔한테 킬시간되면 켜달라고 하고 제어권 넘겨줘버림
콜백함수가 콜하면 함수실행하고 다시 제어권 넘겨주고 끝날때까지 반복

array.map(콜백함수(현재처리중인값,인덱스,배열),(생략가능)this바인딩대상)
배열 처음부터 끝까지 콜백함수에 넣어서 반복후에 처리된배열을 돌려줌

당연하지만 콜백함수안에 순서는 고정이기떄문에 뭐 이름다르게부르든말든 첫번쨰는 i 두번째는 인덱스임

메서드에 콜백함수를 구현했을경우에도 메서드에 함수를 콜하라고 한거기때문에 따로 this바인딩을 안해주면 전역을 바라보기때문에
(2번쨰인자||window)2번째인자에 this를 받는거임

그리고 위에도 말했지만 메서드에 콜백함수를 해도 콜백함수는 메서드가 아닌 함수로 콜됨 
그래서 콜백함수 내에 명시적으로 바인딩해줌 라이브러리에 있는 함수들은

array.foreach(콜백함수(현재값,인덱스,배열),this)

vals: [1, 2, 3],
logValues: function(v, i) {
 console.log(this, v, i);
 }

[4, 5, 6].forEach(obj.logValues)
 이런식으로 써도 obj의 logValues가 가르키는 함수를 콜한거라 obj의 변수들과는 관계없어서 window가 나옴 this에
 obj.logValues(1, 2); 그냥 이렇게쓰면 this에 { vals: [1, 2, 3], logValues: f }가 나옴
 
 즉 어떤 매서드에 있는 함수를 콜백함수를 달라고하는데 넣으면 this바인딩 하는게 동작을못하기때문에 전역을 가르키게됨
 
그래서 위에처럼 self=this를 바인딩 하는 꼼수를 썼는데 
함수안에 self=this넣고 
바로 리턴 진짜함수를 해서 뒤에 진짜함수에서 self를 쓸수있게함

그래서 요즘은 bind를 써서 콜백함수를 콜할때 
setTimeout(obj1.func.bind(obj1), 1000);이런식으로 바인드를 해서보냄

콜백함수를 여러개 묶어서 써야할때 그냥 쓰면 깊이도 깊어지고 알아보기도 힘들어지니까
익명함수말고 기명함수로 쓰던가

promise를 쓰면 resolve나 reject를 호출하는 구문이 있으면 그거 처리전까진 다음거나 오류구문으로 안넘어가니까 비동기를 동기적으로
처리할수있음

generator을 쓰면 (function* abc 하면됨)
next메서드가 생기는데 
함수 안에 yield가 나오기직전까지 처리하고 
next받으면 다음 yield까지 처리하고 해서 비동기를 적당히 동기처럼 쓸수있음

제일 편하고 짧은건 async/await인데
함수앞에 async를 적어주고 비동기작업이 필요한부분마다 await를 적어주면 
그부분을 promise로 바꿔주고 내용이 resolve되야지 다음거로처리됨
그냥 promise를 짧게바꿔줌

클로저는 함수속의 함수가 자기 외부의 변수를 사용하는데,리턴이나 콜백에 넣거나 해서 외부변수를 사용하는 함수를 외부에 줬을때
가비지컬렉터가 그 참조하는 외부변수를 지우지 않는 현상
즉 클로저란 어떤 함수 A에서 선언한 변수a를 참조하는 내부함수 B를 외부로 전달할 경우 
A의 실행 컨텍스트가 종료된 이후에도 변수 a가 사라지지 않는 현상

리턴말고 콜백함수에 함수를 넣으면 그함수에서 또 지역변수를 참조하니까 안사라짐 위에적은거처럼

클로저가 일어나면 그만큼 메모리가 고정적으로 할당되고 안없어지니까 개발자가 의도하지 않은 클로저는 메모리누수임
하지만 명시적으로 그 함수를 null같은거로 덮어버리면 참조카운트가 0이되면서 메모리할당이 풀리니까 의도하고 클로저일으키면 사용할수있음

대표적으로 사용하는곳은 

콜백함수내에서 외부 데이터를 사용하고싶을때가 기본적으로 사용하는건데
딴데서도 쓰거나 해서 밖으로 그함수를 꺼내는데 클로저는 시키고싶으면 바인드를 쓰면되긴하는데 그러면 this가 바뀌고 이거저거 귀찮아지니까
보통은 고차함수(함수를받거나,함수를 리턴하는함수)를 사용함

그냥 a=function (f){ return function(){...}}해서 함수를 리턴하는함수 만들어주면 
이걸로 클로저를 사용하면서 this도 안바꾸고 할수있음

자바스크립트는 기본적으로 퍼블릭 프라이빗같은걸 지원하지 않는데,클로저를 사용해서 비슷하게 쓸수있음
제일큰함수에
 변수가 선언되고 
 내부함수로 
	그걸 조작하면 
그 내부함수를 제외한방법으로는 그걸 건드릴수가 없음
거기에 안에 뭐 퍼블릭으로 두고싶으면
그 데이터 리턴해서(여럿으면 객체나 배열로)  getset둘다하면되고 읽기만하고싶으면 get만 두면 읽을수도있음

부분적용함수는 함수에 받을 인자가 10개일떄 5개 5개로 나눠받을떄 사용

보통 인자받을함수 만들어서 그거로 모았다가 다모이면 처리하는식으로 하는거같은데
프론트엔드에서 막 버튼클릭같은거 난타하면 처음거나 마지막거만 처리되게 할떄 
처음에 시간받고 누를때마다 시간확인해서 일정시간내면 무시하는식으로 처리할수있음

커링함수는 여러개인자받는걸 다 하나씩 나눠받을수있게해서 다모여야지만 실행되게만든함수임

화살표함수를 쓸수있으면 
var curry5 = func => a => b => c => d => e => func(a, b, c, d, e);
그냥이렇게쓰면됨
막 하나계산하고 한칸채우고하다가 마지막에 실행시킬때 쓸만할듯

자바스크립트는 클래스기반이 아닌 프로토타입 기반 언어임
클래스기반은 상속을 하지만 프로토타입기반은 어떤 객체를 원형으로 잡고 이걸 복사해서(참조)줘서 상속과 비슷하게 사용함
프로토타입은
생성자-프로토타입
:   /
:  /
: /
:/
인스턴스(객체가 메모리상에 올라온것)
이렇게 되어있는데,
인스턴스를 생성하면(var instance = new Constructor();)
new로 생성자를 불러오면 생성자의 프로토타입을 복사해서 인스턴스의 프로토타입으로 보내주고(참조) 자기가 코드에 적힌내용을 처리함

저기서 프로토타입은 참조값으로 보내주기떄문에 객체의 프로토타입에 메서드를 추가하면 만든 인스턴스의 프로토타입에도 추가됨
Person.prototype.getName = function() {return this._name;};
suzi.__proto__.getName(); // undefined
이게 에러가 안뜨는 이유도 일단 프로토타입을 받아왔기때문에 같은게 있기때문에 그럼
Person.prototype === suzi.__proto__ // true
이렇게 같다고나옴

함수를 메서드로부르면(앞에.찍고부르면)앞객체가 this가 되니까 위에는 suzi.prototype에 name을 넣어주면 그 네임값을 반환할거임

그리고 자바스크립트에서는 저 프로토타입이 생략가능하기때문에
-> suzi(.__proto__ ).getName-> suzi.getName 이렇게 표현이 가능한데 이렇게되면
suzi.__proto__가 아닌 suzi가 this가 되기때문에 상위에있는(클래스로치면 상속받았다고 할수있는)메서드를 그대로사용할수있게됨
(이건 그냥 js만든사람이 이렇게만든거니까 그냥외우면됨)

즉,생성자함수의 prototype에 어떤 메서드나 프로퍼티가 있다면 
인스턴스에서도 마치 자신의 것처럼 해당 메서드나 프로퍼티에 접근할 수 있게 됨

여기서도 주는건 생성자와 프로토타입내용물밖에 없기떄문에,생성자(배열로치면 array)에 있는 메서드를 직접사용할순없고 프로토타입에 있는거만
사용할수있음 array로치면 isarray나 이런것들은 인스턴스에선 사용할수없음

프로토타입 내부에서 생성자가 있는데 이건 원래 자기자신을 참조함
이게 왜있냐면 현재인스턴스에서 위로 올라갈수있는 수단이기 때문(원형을 알수있음)

그래서 막 var arr2 = new arr.constructor(3, 4);이런식으로 이미있는인스턴스의 생성자를 불러와서 생성하는 이상한짓도 가능해짐

만약 위에 인스턴스가 getname을 이미 가지고있는데 프로토타입에다가 새 메서드를 넣으면 자기자신이 만든 getname이 불러지게됨(스코프상으로
가까이있음)
그래서 suzi.getname은 자기자신이 만든걸 사용하는거고,
suzi.prototype.getname은 상속받았거나 중간에 프로토타입에 넣은걸 사용하게됨

프로토타입 체인은 프로토타입이 상위의 프로토타입을 참조하니까, 프로토타입을 타고 계속 올라가는거임
(프로토타입은 생략가능하니까 이래서 오브젝트의 메서드를 하위인스턴스에서도 사용가능한 이유)
그래서 프로토타입 체이닝은 위에서 오버라이드할떄처럼 자기자신검색후 프로토타입검색후 프로토타입의프로토타입을 검색하는식으로 체인걸어서나가는거

인스턴스가 아닌 객체에서는 상위의 프로토타입에 쓸수가없음(오브젝트이기때문)그래서 오브젝트의 메서드에 정적메서드로 추가하고 this의 사용을
포기하는식으로 쓸수밖에없음

같은이유로 오브젝트에는 무슨객체든 다 쓸만한 그런메서드밖에없음

자기가 직접 프로토타입체인을 만들고싶으면(클래스상속처럼 만들고싶으면)
생성자함수의 프로토타입을 연결할 상위 생성자의 인스턴스를 가리키게하면됨
Grade.prototype = [];이런식으로 하면 grade는 배열의 인스턴스를 가리키게되면서 프로토타입체인이 이어지며 배열의메서드를 사용할수있음

그리고 실제로 프로토타입쓸떄는 Object.getPrototypeOf()/ Object.create() 이런거쓰라고함 직접부르는건 이렇게쓰면안된대

js es6버전와서는 클래스가 추가됨
클래스는 
상위의 개념:음식
에서
하위1단계:과일
하위2-1:나무에서열림
하위2-2:땅에서열림
이런식으로 상위걸 받아서 거기서 확장하는식으로 나감
즉 클래스는 추상적인 개념을 좀더 내려올수록 구체화시키는거고
인스턴스는 그 클래스의 개념을 전부 가지는 실존하는 개체(메모리상에 할당된개체)임

뭐 클래스없어도 프로토타입 체이닝하는것도 상속 비스무리하게 사용할수는 있었지만 아무래도 여러가지로 불편한게있음

인스턴스에 상속되는지 안되는지에 따라 스태틱멤버(상속안됨)인스턴스멤버(상속됨)으로 나눠지는데,
아무래도 js에서는 인스턴스메서드라고하면 프로토타입에 정의한건지 인스턴스에 정의한건지 헷갈리니까 그냥 프로토타입메서드라고 부름
(클래스기반에서는 인스턴스에서 메서드를 만들수없지만 얘는 가능해서 인스턴스에서도 메서드만들수있어서 이럼)

뭐 위에 프로토타입에서 그랬지만 생성자가 주는 프로토타입에 들어간 메서드들은 인스턴스에서 사용할수있고 밖에있는메서드들은 생성자.메서드()해서
쓸수있고 그런거

es6에서는 클래스가 추가됐는데 딴동네 클래스랑 똑같이 만들면됨
 var ES6 = class {
	constructor (name) {
		this.name = name;
	}	
	static staticMethod () {#스태틱메서드하려면 앞에 스태틱붙이면됨
		return this.name + ' staticMethod';
	}
	method () {
		return this.name + ' method';
	}
 };
상속은
var Square = class extends Rectangle {
	constructor (width) {
		super(width, width);#슈퍼는 자기 상위클래스
	}
	getArea () {#오버라이드해서 슈퍼의 메서드들고사용
		console.log('size is :', super.getArea());
	}
 };
 
 -끝-