자바스크립트의 데이터 타입에는 기본형과(number,string,boll등) 참조형(array,function등)이 있음

데이터는 기본적으로 변수명부분과 데이터 부분으로 나눠지는데 변수명에 이름적고 데이터부분을 포인터하게 만들어져있음

기본형은 기본적으로 불변성을 띔
왜냐면 선언된 변수의주소부분은 바뀌지 않고 가리키는 데이터값의주소만 바뀌니까
(데이터부분은 아예 상수라서 한번 선언된값이랑 똑같은건 무조건 같은데씀 깊은복사안하면)
기본적으로 처음에 선언된 변수주소는 바뀌지않음
그래서 변수는 불변성을 가지고있지만 데이터 영역은 바꿀수있고,상수는 아예 처음에 한번 변수명에 데이터를 박아두면 건드리지도 못함
(변수와 상수의 차이는 변수영역메모리 불변성은 데이터영역의 메모리)

참조형은 변수->데이터->변수[i]->데이터 로 구성되어있음(1차원배열)
그래서 기본적으로는 변수[i]부터 바뀔수있기때문에 가변값임

그래서 변수를 복사할때는 기본형같은경우 복사하든 대입하든 복사하고나서 바꿀때 행위가 같지만,
참조형은 주소값을적고 다시 주소값으로 가기떄문에 그냥 얇은복사를 해버리면(첫주소값을 가리키면) 바꾸면 주소값에있는걸 바꾸기떄문에 둘다바뀌게됨
그리고 그냥 변수[i]->데이터로 끝나면 변수[i]까지 불러오고 복사해버리면 되는데 
2차원배열이상같은경우 재귀로 바닥까지 들어가서 바꿔야됨(깊은복사)
뭐 귀찮으면 json파싱한다음에 다시바꾸는식으로 한다는데 그러면 내부함수나 겟셋은못받으니까
그래서 아예 리액트처럼 새로객체만들어서 붙여넣기하거나 하는거같음(usestate)

js에는 undefined와 null이 있는데 
언디파인드는 당연히 뭐 초기화안하거나 없는거건드릴때 나오고 null은 내가 없다고 지정했을때 넣어주는거임
그리고 명시적으로 언디파인드를 넣어주면 반복문이 그거 안건너뛰고 동작하고 아니면 건너뛴다는데 누가 언디파인드를넣어 널넣지

null은 자바스크립트 자체 버그가있어서 typeof로 보면 오브젝트로 나옴 그래서 n==null이랑 n==undefined가 같게나옴
그래서 n===null을 해야 null확인가능함

실행컨택스트는 실행할 코드에 제공할 정보를 모아둔 객체 
기본적으로 스택으로 동작 (전역   전역-a클래스   전역-a클래스-b함수   전역-a클래스   전역 )

자바스크립트에서는 어디서 선언되든간에 선언된(var a) 변수나 객체가 있으면 최상단으로 끌어올려 버림
print a       var a   
var a=1    --->print a
               a=1
이런식으로 대입부분만 남겨두고 다 올려버려서 저거 프린트a도 언디파인드가 나오게됨
함수의 경우는 함수 전체를 끌어올려서 함수명과 같은 변수명을 선언하고 대입한거랑 똑같이취급
fun a(){}  -> var a=fun a(){}

함수 표현방식에는 3가지가있는데
function a(){}//함수선언
a();

var b=function (){}//익명표현
b();

var c=function d(){} //안씀이건
c();
d();//에러

선언이랑 익명표현 차이점이 뭐냐면 
바로 함수명을 적으면 통째로 올라가는데 익명표현을 해버리면 var b만 올라가서 그위에서 사용이 불가능함(장점)

그래서 막 두함수가 똑같은이름으로 중복해서 나오게될때 익명표현으로 함수에박아버리면 에러뜨면서 막히게됨

스코프는 식별할 유효범위
전역으로 생성하면 전역에서 식별할수있고
함수내부에서 생성하면 함수내부에서만 식별할수있음
보통 검색은 내부에서부터 하고 없으면 한칸 밖으로 나가는식으로 전역까지 스택으로 나가다가 발견하면 그것만 사용하게됨

이것도 선언은 위로 끌려가니까 호출보다 선언이 밑에있어도 자기 함수 내부의 것부터 스코프에 잡히게됨

this는 자바스크립트에선 딴데랑 다르게 동작함
보통 다른데서는 현재함수나 메서드 가리키는건데 얘는 전역공간에서 this하면 전역공간 가르킴

자바스크립트의 모든 변수는 특정 객체의 프로퍼티로 동작함
그래서 전역변수를 선언해도 전역변수의 프로퍼티로 작동해서
var a = 1;
console.log(a); // 1
console.log(window.a); // 1
console.log(this.a); // 1
이렇게됨
그래서 그냥 console.log(a)해도 1이 나오는 이유도 스코프돌렸는데 제일 가까이있어서 나오는거임

단 del연산할떄는 명시적으로 window.a이런식으로 생성한거아니면 못하게막음 실수로지울까봐그런듯

메서드와 함수에서의 this는 구분을 a.method()랑 func() 이렇게 그냥 앞에 점이 있나없나만 가지고 구분해서
함수로 부를떈 this가 앞에 뭐 아무것도 없기떄문에 전역객체를 가르키고 메서드로 부르면 현재 포함된객체로 this가 바인딩됨
이것도 함수를 메서드로 바인딩시켜버려도 메서드콜하면 앞에 점이있기때문에 this는 현재 들어있는 객체를 가르키게됨

그래서 막 위에있는this값 필요하면 self=this이런식으로 넣어서 이거 가져다쓰던가 화살표함수로 쓰면 this는 상위객체를 가르키게되서
변수쓰는꼼수안써도됨

콜백함수에서는 부르는애가 어떻게했냐따라서 걔를 따라감 이거도 앞에 점있으면 메서드취급이고 없으면 함수취급이니까 어지간하면 안써야할거같음

생성자함수에서는 this가 생성될 자기 자신(앞에 new붙여서 부를때)을 가리킴
var a= new cat(c,b)하면 this는 a를 따라가서 자기자신을 세팅할수있음

그냥 명시적으로 바인딩 하고싶으면 call이나 apply로 적은값 줘서 바인딩해버릴수도있음

뭐 특수용도로 쓸수있다는데 
(...연산자처럼 여러개 묶어서 배열로만들기,배열처럼생긴 객체는 깡으로는 배열메서드를 못쓰는데 apply쓰면 쓸수있다던지,생성자 내부에서
다른 생성자 부른다던지)

bind는 call이랑 비슷한데 즉시부르진않고 받은 this랑 인자들로 새로운함수 만들어서 리턴해줌
bind는 bind를 써서 만든 함수에 .name을 붙여서 불러보면 bound (기존함수명)이 붙어서 추적하기쉬움

바인드나 콜이나 어플리같은거로 아까 뭐 변수로받아서 쓰고하는거 대신쓸수도있음


