1부.프로그래밍 기초중 특이한거
	함수가 한줄로만 이뤄졌을경우
		fun abc(x:Int):Int=x*3
	이런식으로 쓰고
		abc(3)
	이런식으로 사용할수도있음
	
	int를 나누기하면 기본적으론 버림처리하고,이게싫으면 double로 변환해서 처리해야함
	그리고 코틀린은 오버플로우를 잡아주지않으므로(잡아줄떄도있지만 확실한건아님),항상 신경써야함,이때 Long를 쓸수있음
	Long도 모자라면 BigDecimal을사용해야함
	
	do-while을 사용하면 무조건 한번은 실행하는 while을 만들수있음
	
	for를 쓸때 
		until로 마지막값을 제외한값을 돌릴수있고(0 until 3 ->0,1,2)
		downTo로 역순진행(5,4,3,2,1)을 할수있고,
		step으로 n개씩 건너띌수있음(0..9 step 3)
	등이 있음

	in으로 어떤 값이 해당범위안에 존재하는지 확인할수있음(bool)
		32 in 1..100 -> true
		3233 in 1..100 -> false
	반열림범위도 있음(코틀린 1.8부터)
		32 in 1 ..<100 -> true
		100 in 1 ..<100 -> false
	string도 적용됨
		"ab" in "aa".."az" -> true
		"bb" in "aa".."az" -> false
	이렇게

	문은 상태를 변경하고,식은 값을 짜냄
	즉 문은 사이드이팩트를 일으키기위해서 사용되고(for),식은 값을 뽑아내기위해서 사용됨(함수)
	그래서 식은 값을 돌려주기때문에 다른식의 하위요소나 변수에 대입할수있지만,문은 변수로 대입할수없음
	if는 식을 반환하기때문에,변수에 대입할수있음(if의 결과가 대입됨,즉 if문을 돌리고 결과값만 대입해서 해당타입이 대입됨)
	i++도 문이 아니라 식임
2부.객체소개중 특이한거
	코틀린에서는 자바와 달리,패키지의 구조가 폴더를 따라가지않아도됨(하지만 따라가게하는게 편함)
	
	vararg로 생성자에서 파라미터를 여러개받을수있음
		fun abc(val a:String,vararg ints:Int){}
	이때 array로 들어옴
	그리고 저자리에 array를 넣어서 호출할수있음(이때 그냥 array<Int>가 아닌 타입이 지정된 array를 사용해야함)
		abc("aqq",intArrayOf(1,2,3))
	이런식
	
	프로퍼티에 get,set을 설정할수있음(프로퍼티 선언뒤에 바로 적으면됨)
		var i:Int=0
			get(){
				return i+30
			}
	이렇게	
3부.사용성
  1.확장함수
	확장함수는 해당 클래스에 멤버변수를 추가하는거처럼 동작하게할수있음
	즉
		fun String.abc()="abc"
	이런식으로 해당클래스의 함수를 추가할수있는데,일단 이 확장함수는 해당 패키지에서만 사용할수있고,다른패키지에서 사용하려면 임포트를 해야함
	그리고 this를 사용하지않아도 자기자신(즉 String)의 프로퍼티나 메서드에 접근할수있음
		fun String.abcTwin()=this.abc()+this.abc()
		fun String.abcTwin()=abc()+abc()
	두개다 똑같이동작
	그리고 확장함수는,실제로 해당 클래스에 들어가는게 아닌 데코레이터패턴을 구현한거라서,퍼블릭원소에만 접근할수있고,밖에서 접근가능한곳에만 접근할수있음
	즉 신택틱슈가임(ide사용할떄는 편해지고,구분도 안해도되니)
  2.이름붙은 인자와 디폴트인자
	함수를 콜할때 이름을 명확히 지정해서 부를수있음
		val a=aqq(red=255,blue=240)
	그리고 메서드를 만들때도 디폴트값을 설정할수있음	
  3.오버로딩
	오버로딩은 같은동작인데 약간다른 타입을 같은방식으로 처리할때 사용됨(int와 double같은)
	만약 어떤 클래스안에 확장함수와 시그니처가 똑같은 멤버함수가 있으면 멤버함수를 우선시하는데,이걸가지고 오버로딩을 할수있음
	그래서,확장함수+오버로딩을 디폴트인자를 흉내내기위해 사용하면안됨
	즉 진짜 오버로딩을 하기위해 확장함수를 사용하는건 괜찮은데,디폴트인자처럼 동작시키기위해 사용하면안됨(애초에 디폴트쪽으로 접근이 불가능하기때문)
  4.when
	when은 case문임
	when에서 ,로 여러값들을 한 분기로 묶어처리할수있음
	when에서 {}를 두면 해당값으로 아무처리도 안하겠다는거(그냥 빈거임)
	when에서 return을 하면 해당 함수자체가 끝이나니 조심
	when에서 값이 아닌 조건(age<20)도 조건에 넣을수있음,단 boolean타입이어야함
  5.이넘
	이넘은 이름을 모아둔 클래스임
	이걸 사용하면 오타걱정이 없어지고,when을 사용할떄도 편하게 사용할수있음(분기가 정확히 나눠지니 else가 필요없음)
	이넘에서도 멤버함수를 추가할수있는데,이때는 마지막이넘값 다음에 세미콜론을 꼭 붙이고,함수나 프로퍼티를 추가하면됨
	보통 프로퍼티나 함수만들고,자기자신클래스를 가공해서 리턴하는걸 자주사용함
  6.데이터클래스
	데이터클래스는 toString(),hashCode()등을 자동으로 생성해주는 클래스임,즉 데이터저장만 하는 클래스면 이걸쓰면 편함
	이떄 해당클래스는,생성자의 모든 파라미터를 val이나 var로 선언해야함
  7.구조분해선언
	pair이나 triple같은 클래스들을 한번에 분해할수있음
		val (a,b)=페어값
	data클래스는 자동으로 구조분해선언을 지원함,이때 그냥 프로퍼티순서대로 넣으니,데이터클래스에 값추가할떄는 조심해야함	
  8.널이될수있는타입
	널이될수있는타입은 String?처럼 물음표를 붙임,타입추론도 만약 해당값이 널허용이면 물음표를 붙여줌
	String와 String?는 서로 다른타입이라,대입할수없고,String?에 가공을거쳐서 String로 바꿔서 대입할수는있음
	그리고 물음표타입은 역참조(메서드나 프로퍼티에 접근)할수없고,널일경우 어케할지를 말해준다음 접근할수있음
	이건
		널일경우를 if문으로 검사
		안전한호출(널일경우 아무일도안함)
		엘비스연산자(?:)
		널아님단언(!!)
	로 처리해야함
  9.안전한호출과 엘비스연산자
	val a:String?일 경우에 멤버변수를 호출하고싶으면
		a?.echo() //안전한호출,널일경우 그냥 패스됨
		a?.echo()?:println(null)//엘비스,널일경우 뒤의식이 실행됨(if문이라고봐도됨)
	호출을 연쇄시키는 중간에 널이 결과로 나올경우 이걸 사용해서 처리해줄수있음(안전한호출로 연쇄해서 엘비스로 널처리)
  10.널아님단언
	!!로 얘는 널이 아니다라고 단정지을수있음,당연히 어지간하면 사용하면안되고,
	보통 if문으로 검사하거나 엘비스연산자를 주로 사용함(자바라이브러리쓸때도 가끔씀)
	그리고 널일때 예외를 발생시켜야할때도,
	npe보다는 해당예외가 뜨는게 명확한 예외가 뜨는게 나음
	즉,맵을 map["aa"]보다 map.getValue("aa")로 읽어서 값이없으면 npe말고 NoSuchElementException가 발생함 
  11.확장함수와 널이될수있는타입
	abc?.aa()는 abc가 널이 될수있는타입이라는걸 암시하지만,abc.aa()는 abc가 널이될수없는타입이라는걸 암시하지않음
	왜냐면 코틀린의 확장함수는,널이될수있는타입에만 추가하는,즉 String?에만 추가할수있기때문임
	이런함수를 만들땐
		fun String?.abc():리턴타입{}
	이렇게 타입뒤에 물음표를 붙이면됨
  12.제네릭스	
	제네릭은 클래스의 파라메터나 리턴타입등을 해당클래스가 생성될때 지정하는것임
	보통 컬렉션에서 주로 사용됨
	any나 오브젝트를 사용하지못하는이유는,얘들은 붙여두면 구체적인타입을 사용(해당파라메터의 하위메서드를 호출할때)할수없어지기때문
  13.확장프로퍼티
	확장프로퍼티는,확장함수처럼 프로퍼티를 확장하는거임
	이건
		val String.abcd:타입명
		  get(){...}
	이렇게 사용됨,이때 반드시 커스텀게터를 넣어줘야함
	즉 확장함수의 변형처럼 사용됨(파라미터가 없는 확장함수와 동격이라고 생각하면됨,실제로 양쪽은 서로 변형할수있음)
	보통 기능이 단순하고 가독성이 올라갈때만 이걸 쓰는데,보통 잘 쓸일은 없음
	이 확장프로퍼티도 제네릭을 사용할수있음
		val <T> List<T>.abcd:T?
		  get(){...}
	만약 함수가 예외를 던질땐,프로퍼티보다 함수쓰는게 나음
	그리고 제네릭대신 *를 사용할수도있는데,이경우엔 해당타입정보(하위메서드등)를 다 잃어버리니 조심
  14.break와 continue
	일반 break와 continue는 잘 사용하지않는게 좋음,goto보다야 당연히 낫지만,알아보기 힘들어지는경우가 많기때문(한번더 생각해야함)
	또한 break와 continue는 자신이 속한 루프범위(가장 가까이있는 for나 while)를 벗어날수없음
	이때 레이블을 사용하는게 좋음
	레이블은 
		하려는일@레이블명
		break@abc
	로 사용할수있음
	이건 for나 while에 이름을 붙이고,해당 반복문을 대상으로 조작할수있음
		abc@ for( i in aList){
			for (j in i){
				if(j==1)break@abc
			}
		}
	이런식으로 사용하면,바로 j가 1일경우 바로 전체반복문이 탈출됨
	근데 애초에 어떤식이든 반복문을 중간에 탈출한다는거 자체가 머리가 복잡해지기때문에,가급적 사용하지않고 루프돌리는게나음

4.함수형 프로그래밍		
		
		
		
		
		
		
		
		