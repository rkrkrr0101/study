1부.프로그래밍 기초중 특이한거
	함수가 한줄로만 이뤄졌을경우
		fun abc(x:Int):Int=x*3
	이런식으로 쓰고
		abc(3)
	이런식으로 사용할수도있음
	
	int를 나누기하면 기본적으론 버림처리하고,이게싫으면 double로 변환해서 처리해야함
	그리고 코틀린은 오버플로우를 잡아주지않으므로(잡아줄떄도있지만 확실한건아님),항상 신경써야함,이때 Long를 쓸수있음
	Long도 모자라면 BigDecimal을사용해야함
	
	do-while을 사용하면 무조건 한번은 실행하는 while을 만들수있음
	
	for를 쓸때 
		until로 마지막값을 제외한값을 돌릴수있고(0 until 3 ->0,1,2)
		downTo로 역순진행(5,4,3,2,1)을 할수있고,
		step으로 n개씩 건너띌수있음(0..9 step 3)
	등이 있음

	in으로 어떤 값이 해당범위안에 존재하는지 확인할수있음(bool)
		32 in 1..100 -> true
		3233 in 1..100 -> false
	반열림범위도 있음(코틀린 1.8부터)
		32 in 1 ..<100 -> true
		100 in 1 ..<100 -> false
	string도 적용됨
		"ab" in "aa".."az" -> true
		"bb" in "aa".."az" -> false
	이렇게

	문은 상태를 변경하고,식은 값을 짜냄
	즉 문은 사이드이팩트를 일으키기위해서 사용되고(for),식은 값을 뽑아내기위해서 사용됨(함수)
	그래서 식은 값을 돌려주기때문에 다른식의 하위요소나 변수에 대입할수있지만,문은 변수로 대입할수없음
	if는 식을 반환하기때문에,변수에 대입할수있음(if의 결과가 대입됨,즉 if문을 돌리고 결과값만 대입해서 해당타입이 대입됨)
	i++도 문이 아니라 식임
	
	
2부.객체소개중 특이한거
	코틀린에서는 자바와 달리,패키지의 구조가 폴더를 따라가지않아도됨(하지만 따라가게하는게 편함)
	
	vararg로 생성자에서 파라미터를 여러개받을수있음
		fun abc(val a:String,vararg ints:Int){}
	이때 array로 들어옴
	그리고 저자리에 array를 넣어서 호출할수있음(이때 그냥 array<Int>가 아닌 타입이 지정된 array를 사용해야함)
		abc("aqq",intArrayOf(1,2,3))
	이런식
	
	프로퍼티에 get,set을 설정할수있음(프로퍼티 선언뒤에 바로 적으면됨)
		var i:Int=0
			get(){
				return i+30
			}
	이렇게	
	
	
3부.사용성
  1.확장함수
	확장함수는 해당 클래스에 멤버변수를 추가하는거처럼 동작하게할수있음
	즉
		fun String.abc()="abc"
	이런식으로 해당클래스의 함수를 추가할수있는데,일단 이 확장함수는 해당 패키지에서만 사용할수있고,다른패키지에서 사용하려면 임포트를 해야함
	그리고 this를 사용하지않아도 자기자신(즉 String)의 프로퍼티나 메서드에 접근할수있음
		fun String.abcTwin()=this.abc()+this.abc()
		fun String.abcTwin()=abc()+abc()
	두개다 똑같이동작
	그리고 확장함수는,실제로 해당 클래스에 들어가는게 아닌 데코레이터패턴을 구현한거라서,퍼블릭원소에만 접근할수있고,밖에서 접근가능한곳에만 접근할수있음
	즉 신택틱슈가임(ide사용할떄는 편해지고,구분도 안해도되니)
	
  2.이름붙은 인자와 디폴트인자
	함수를 콜할때 이름을 명확히 지정해서 부를수있음
		val a=aqq(red=255,blue=240)
	그리고 메서드를 만들때도 디폴트값을 설정할수있음	
	
  3.오버로딩
	오버로딩은 같은동작인데 약간다른 타입을 같은방식으로 처리할때 사용됨(int와 double같은)
	만약 어떤 클래스안에 확장함수와 시그니처가 똑같은 멤버함수가 있으면 멤버함수를 우선시하는데,이걸가지고 오버로딩을 할수있음
	그래서,확장함수+오버로딩을 디폴트인자를 흉내내기위해 사용하면안됨
	즉 진짜 오버로딩을 하기위해 확장함수를 사용하는건 괜찮은데,디폴트인자처럼 동작시키기위해 사용하면안됨(애초에 디폴트쪽으로 접근이 불가능하기때문)
	
  4.when
	when은 case문임
	when에서 ,로 여러값들을 한 분기로 묶어처리할수있음
	when에서 {}를 두면 해당값으로 아무처리도 안하겠다는거(그냥 빈거임)
	when에서 return을 하면 해당 함수자체가 끝이나니 조심
	when에서 값이 아닌 조건(age<20)도 조건에 넣을수있음,단 boolean타입이어야함
	
  5.이넘
	이넘은 이름을 모아둔 클래스임
	이걸 사용하면 오타걱정이 없어지고,when을 사용할떄도 편하게 사용할수있음(분기가 정확히 나눠지니 else가 필요없음)
	이넘에서도 멤버함수를 추가할수있는데,이때는 마지막이넘값 다음에 세미콜론을 꼭 붙이고,함수나 프로퍼티를 추가하면됨
	보통 프로퍼티나 함수만들고,자기자신클래스를 가공해서 리턴하는걸 자주사용함
	
  6.데이터클래스
	데이터클래스는 toString(),hashCode()등을 자동으로 생성해주는 클래스임,즉 데이터저장만 하는 클래스면 이걸쓰면 편함
	이떄 해당클래스는,생성자의 모든 파라미터를 val이나 var로 선언해야함
	
  7.구조분해선언
	pair이나 triple같은 클래스들을 한번에 분해할수있음
		val (a,b)=페어값
	data클래스는 자동으로 구조분해선언을 지원함,이때 그냥 프로퍼티순서대로 넣으니,데이터클래스에 값추가할떄는 조심해야함	
	
  8.널이될수있는타입
	널이될수있는타입은 String?처럼 물음표를 붙임,타입추론도 만약 해당값이 널허용이면 물음표를 붙여줌
	String와 String?는 서로 다른타입이라,대입할수없고,String?에 가공을거쳐서 String로 바꿔서 대입할수는있음
	그리고 물음표타입은 역참조(메서드나 프로퍼티에 접근)할수없고,널일경우 어케할지를 말해준다음 접근할수있음
	이건
		널일경우를 if문으로 검사
		안전한호출(널일경우 아무일도안함)
		엘비스연산자(?:)
		널아님단언(!!)
	로 처리해야함
	
  9.안전한호출과 엘비스연산자
	val a:String?일 경우에 멤버변수를 호출하고싶으면
		a?.echo() //안전한호출,널일경우 그냥 패스됨
		a?.echo()?:println(null)//엘비스,널일경우 뒤의식이 실행됨(if문이라고봐도됨)
	호출을 연쇄시키는 중간에 널이 결과로 나올경우 이걸 사용해서 처리해줄수있음(안전한호출로 연쇄해서 엘비스로 널처리)
	
  10.널아님단언
	!!로 얘는 널이 아니다라고 단정지을수있음,당연히 어지간하면 사용하면안되고,
	보통 if문으로 검사하거나 엘비스연산자를 주로 사용함(자바라이브러리쓸때도 가끔씀)
	그리고 널일때 예외를 발생시켜야할때도,
	npe보다는 해당예외가 뜨는게 명확한 예외가 뜨는게 나음
	즉,맵을 map["aa"]보다 map.getValue("aa")로 읽어서 값이없으면 npe말고 NoSuchElementException가 발생함 
	
  11.확장함수와 널이될수있는타입
	abc?.aa()는 abc가 널이 될수있는타입이라는걸 암시하지만,abc.aa()는 abc가 널이될수없는타입이라는걸 암시하지않음
	왜냐면 코틀린의 확장함수는,널이될수있는타입에만 추가하는,즉 String?에만 추가할수있기때문임
	이런함수를 만들땐
		fun String?.abc():리턴타입{}
	이렇게 타입뒤에 물음표를 붙이면됨
	
  12.제네릭스	
	제네릭은 클래스의 파라메터나 리턴타입등을 해당클래스가 생성될때 지정하는것임
	보통 컬렉션에서 주로 사용됨
	any나 오브젝트를 사용하지못하는이유는,얘들은 붙여두면 구체적인타입을 사용(해당파라메터의 하위메서드를 호출할때)할수없어지기때문
	
  13.확장프로퍼티
	확장프로퍼티는,확장함수처럼 프로퍼티를 확장하는거임
	이건
		val String.abcd:타입명
		  get(){...}
	이렇게 사용됨,이때 반드시 커스텀게터를 넣어줘야함
	즉 확장함수의 변형처럼 사용됨(파라미터가 없는 확장함수와 동격이라고 생각하면됨,실제로 양쪽은 서로 변형할수있음)
	보통 기능이 단순하고 가독성이 올라갈때만 이걸 쓰는데,보통 잘 쓸일은 없음
	이 확장프로퍼티도 제네릭을 사용할수있음
		val <T> List<T>.abcd:T?
		  get(){...}
	만약 함수가 예외를 던질땐,프로퍼티보다 함수쓰는게 나음
	그리고 제네릭대신 *를 사용할수도있는데,이경우엔 해당타입정보(하위메서드등)를 다 잃어버리니 조심
	
  14.break와 continue
	일반 break와 continue는 잘 사용하지않는게 좋음,goto보다야 당연히 낫지만,알아보기 힘들어지는경우가 많기때문(한번더 생각해야함)
	또한 break와 continue는 자신이 속한 루프범위(가장 가까이있는 for나 while)를 벗어날수없음
	이때 레이블을 사용하는게 좋음
	레이블은 
		하려는일@레이블명
		break@abc
	로 사용할수있음
	이건 for나 while에 이름을 붙이고,해당 반복문을 대상으로 조작할수있음
		abc@ for( i in aList){
			for (j in i){
				if(j==1)break@abc
			}
		}
	이런식으로 사용하면,바로 j가 1일경우 바로 전체반복문이 탈출됨
	근데 애초에 어떤식이든 반복문을 중간에 탈출한다는거 자체가 머리가 복잡해지기때문에,가급적 사용하지않고 루프돌리는게나음


4.함수형 프로그래밍
  1.람다
	람다는 이름없는함수임
	이건 파라메터로 함수를 받는 코드(map(),filter()같은)곳에서 사용됨
	람다의 파라메터가 하나일경우,자동으로 it으로 이름을 붙이고,여러개일경우는
		{n:Int,a:Int->n+a}
	이런식으로 쓸수있음,여기서 타입은 생략가능(추론가능)
	함수의 파라메터가 람다뿐이면 ()괄호를 생략하고 바로{}로 시작할수있음
	람다가 파라메터의 마지막이면,밖으로 빼낼수있음
		abc(){}
	단,이름붙은인자(abc(a="aa",b={...}))를 쓸땐 괄호안에 넣어야함
	그리고 람다의 인자중 하나이상을 사용하지않는데,ide경고를 제거하고싶으면 해당자리에 _를 넣어서 명시적으로 무시하겠다고 선언하면됨
	그리고 람다에 파라메터가 없으면 그냥 쓰면됨
	
  2.람다의 중요성
	람다는 비슷한 여러 작업들을 묶기가 매우편함
	즉 함수형프로그래밍은 문제를 작은단계로 풀어나가는데,이걸통해 매우 작은부분만 새로작성하고 나머지부분을 전부 재사용할수있음
	예를들면 filter()을 사용하지않으면,해당리스트에서 조건부분을 제외하면 전부 중복인데,filter를 사용하면 조건만 나열하면되니 중복을 제거할수있음
	람다는 변수에 넣을수있음
	그리고 람다는 자기 밖의 변수를 포획할수있음(클로저),즉 람다내부에서 자기 밖의 변수를 건드릴수있다는거(읽기쓰기둘다됨)
	뭐 보통은 변경하지않는게 코드가 깔끔할확률이 높긴함
	
  3.컬렉션에 대한 연산
	컬렉션연산은
		map(해당식으로 현재값 변형,aList.map{it+1}이런느낌,아예 aList.map{Person("a",it)}이런식도 가능 )
		filter(조건만족하는애들만 리스트로 리턴)
		filterNotNull(널을 제거)
		any(해당조건만족하는게 1개이상있는지 리턴,bool)
		all(모든원소가 조건만족)
		none(모든원소가 조건불만족)
		forEach
		find(만족하는 첫번째원소 반환,없으면 예외)
		findOrNull(만족하는 첫번째원소 반환,없으면 null)
		lastOrNull(만족하는 마지막원소 반환,없으면 null)
		count(만족하는 원소갯수 리턴)
		partition(조건을 기준으로 값을 나눌수있음,Pair<List,List>로 리턴됨)
		sumBy(람다에 들어온값을 더함,정수리턴,단순한값이 아닌 클래스리스트일때 어떤 한값을 선택해서 더할때 주로사용됨)
		sumByDouble(람다에 들어온값을 더함,실수리턴,단순한값이 아닌 클래스리스트일때 어떤 한값을 선택해서 더할때 주로사용됨)
		sortBy(람다에 들어온값을 기준으로 정렬,두개이상도가능,오름차순)
		sortByDescending(람다에 들어온값을 기준으로 정렬,두개이상도가능,내림차순)
		sortedWith(compareBy를 사용해서 리스트를 정렬,compareBy안에 조건을 나열하면됨)
		take(해당조건을 만족하는 첫원소를 리스트에서 제거하고 가져옴)
		drop(해당조건을 만족하는 첫원소를 리스트에서 제거함)
		takeLast(해당조건을 만족하는 마지막원소를 리스트에서 제거하고 가져옴)
		dropLast(해당조건을 만족하는 마지막원소를 리스트에서 제거함)
	등이 일단 있고,any나 find들은 만족하는거 찾자마자 반복문탈출함
	리스트를 만들땐
		List(리스트크기){초기화값}
		List(리스트크기){it}//인자로 추가할 원소의 인덱스값을 받음
		List(리스트크기){0}//0으로 초기화
		List(리스트크기){'a'+it}//a에 인덱스값을 추가한값으로 초기화(a,b,c,d...)
	등으로 만들수있음
	즉 첫파라메터로 크기를 던져주고,람다로 초기화방법을 던져줌
	
  4.멤버참조
	멤버참조는 해당클래스의 메서드나 프로퍼티를 참조할수있음
		Message::isRead
	이런식
	사용할때는
		val messages=listOf<Message>(...)
		messages.filter(Message::isRead) //{it.isRead=true}와 같음
	이런식으로 사용할수있음(즉 람다를 좀더 짧게쓰는느낌임)
	정렬순서를 적용할때도 유용함
		messages.sortedWith(compareBy(Message::isRead,Message::sender))
	이런식으로 사용할수있음	
	
	메서드를 참조할땐,보통 해당 클래스내에 bool을 리턴하는걸 미리 만들어두고,해당메서드를 참조하는식으로 사용함
	즉 람다가 너무길어질거같을때나,반복사용이 될거같을때 저쪽으로 미리 빼놓고 그걸 가져다 사용하는식(함수참조)
	이거도 확장함수랑 같이 잘 사용됨
	이건
		fun Message.isImportant():Boolean{...}
		messages.any(Message::isImportant)
	이런식으로 사용됨
	그리고 만약 해당함수가 최상위함수라면
		fun abcd(){...}
		messages.any(::abcd)
	이런식으로 사용됨
	
	생성자를 참조할수도있음
		names.mapIndexed{index,name->Student(index,name)}
		names.mapIndexed(::Student)
	이 두개는 같음
		
  5.고차함수
	고차함수는 함수를 다른함수의 인자로 넘기는게 고차함수임
	람다는 변수에 저장할수있고,이걸 가져다가 다른함수에 쓸수있으니 코틀린은 고차함수를 지원함
  6.리스트 조작하기
	zip()은 두 리스트를 하나씩 Pair로 만든 리스트로 변환함
		aList.zip(bList)
	만약 두 리스트의 크기가 다를경우,작은쪽이 끝나면 거기서 종료됨
	그리고 람다를 써서 변형하는것도 가능
		aList.zip(bList){a,b->Person(a,b)}
	이런식	
	
	flatten()은 리스트를 평평하게 펴서 리턴함(이중리스트같은걸 한줄로 만들어서 리턴)
	flatMap()은 해당조건의 값만 평평하게 펴서 리턴해줌(map+flatten이라고 보면됨)
	Person(이름,나이)일때
		val personList=ListOf<Person>(...)
		personList.flatMap{it.age}
	이러면 나이만 리스트로 출력됨
	
	이넘.vlaues를 map하면,각 이넘값마다 하나의 리스트를 생성함,
	그래서 이중이넘을 묶어서 만들고싶으면 밖에 flatMap치고 안에서 Map쳐야함
	
  7.맵만들기
	맵은 키밸류쌍을 저장하는 컬렉션임
	맵을 사용하면 키를사용해 빠르게 값에 접근할수있음(O(1))
	맵을 만들때는 groupBy()를 사용하면 쉽게만들수있는데,이건 해당하는 키값으로 밸류엔 리스트를 넣어서 그룹바이해줌
		abcList.groupBy{it.age}
	이런식으로 람다식안에 키값을 넣고 쓰면됨(물론 이름의 첫자같은 이런식도가능함)
	그리고 그룹이 딱 2개일경우엔,groupBy보다 partition이 더 적절함
	
	리스트에 대해 associateWith()를 사용하면,리스트원소를 키로하고,람다를 리스트원소에 적용한값을 밸류로하는 맵을 만들수있고,
	associateBy()로 반대로적용도 가능,즉 람다적용을 키로,원래원소를 밸류로 함
	이때 람다를 적용한 키가 유일한값을 뱉어내야함,만약 유일하지않으면 원본의 값중 일부가 사라짐(겹치는 키중 마지막에 들어오는 원소만 남아있음)
	
	getOrElse()로 키가 없을때 디폴트값을 계산하는 방법이 담긴 람다를 받아서 처리할수있음
	getOrPut()은 mutableMap에서만 쓸수있고,키가 없을때 값을계산하고 ()안에 키를 받고 람다로 밸류를 받아서 맵에 저장하고 그걸 리턴해줌
		abcMap.getOrPut(0){"zero"}
	즉 키가있으면 그냥리턴,없으면 해당입력값으로 맵에 삽입후 리턴함
	
	Map에 map를 적용하는걸 맵을 변환한다고함
	이때 람다에 키와 밸류를 각각 받을수있음(이경우 리스트로 반환됨)
		abcMap.map{(key,value)->"$key=$value"}
		abcMap.map{"${it.key}=${it.value}"}
	만약 맵으로 받고싶으면 toMap()를 붙여야함
	mapKeys()나 mapValues()를 사용하면 모든 키나 값이 변환된 새맵을 받을수있음(해당 키나 값중 하나를 변형해서 맵으로 리턴)

  8.시퀀스	
	시퀀스는 스트림임
	즉 filter같은걸 전부 계산한다음에 리스트로 뽑아서 다음으로 넘어가지않고,각 원소별로 모든 공정을 완료하는걸 반복하는것
	이걸 사용하면 filter같은거에서 걸러진애들이 이후공정에 들어가지않아 좀 더 효율적이 됨
	만약 any같은 하나만 찾아내도되는걸 찾으면,하나 찾고난다음에 추가적으로 뒤의 원소를 사용하지도않음
	시퀸스를 쓸땐,연산 제일앞에 asSequence()를 붙이고,마지막에 toList()로 변형해주면됨
	
	추가적으로,시퀸스를 사용해서 무한시퀸스같은걸 만들수도 있음
	generateSequence()를 사용하면,해당 람다를 사용해서,이전값과 연산해서 무한히있는거처럼 사용할수있는 시퀸스를 뽑아낼수있음
		val abcSeq=generateSequence(1){it+1}
	여기서 1은 최초값으로 사용되고,그뒤로 해당값을 사용해서 1,2,3,4...이런식으로 작동됨
	지연연산이라 추가연산이 있을때만 해당부분까지만 작동하고,이경우 일정부분을 끊어서 사용하면됨
		abcSeq.take(3).toList()
	이렇게
	첫인자를 사용하지않고,람다만 받을수도있음
		val abcSeq=generateSequence{ abcList.removeAt(0).takeIf{it!="qqq"}}
	이러면 해당리스트를 이터레이션돌면서 맨앞을 제거하면서 반환하고,takeIf로 값을 검증하다가 if문에 걸리면 null을 반환함
	즉 리스트크기까지만 동작함
	
	sequence는 한번만 이터레이션할수있음
		
  9.지역함수
	다른함수안에 함수를 넣을수있음,즉 함수를 함수내부에서 작성해서 가져다쓸수있음
	이건 확장함수를 지역함수로 작성할수도있음
	이때 해당 함수를 벗어나면 해당지역함수는 사용불가능해지고,그래서 전역네임스페이스에 영향을 주지못함
	이경우 클로저로 작동하고,자신을 둘러싼 변수들을 포획해서 사용할수있음,이때 클로저니까 함수내부에서 값을 변경하면 밖의 해당값도 변경됨
	
	보통 람다로 대체가 가능하긴한데,지역함수의 장점은 return을 사용할수있다는것(물론 람다도 레이블쓰면됨),추가로 람다보다 좀더 보기쉬워짐
	이떄 익명함수를 사용할수있음(그냥 함수인데 함수명을 안넣은거,보통 어디 담아두고쓰던가 람다자리에 넣음)
	
	return의 기본동작은 fun을 사용해 정의한 함수를 끝냄,즉 람다는 fun을 사용하지않아서,가장 가까운 fun을 사용한 함수가 종료됨
	그래서 람다에서만 return을 하고싶으면 labeled return을 사용하면됨
		abcList.forEach{
			...
			if(it==value)return@forEach
		}
	기본적으로 이런식으로 해당메서드명으로 동작시킬수있고,이름을 적을수도있음
		abcList.forEach abc@{
			...
			if(it==value)return@abc
		}		
	이런식
	
	var이나 val안에 람다나 익명함수를 저장할수있고,이렇게 함수를 변수처럼 사용할수있음
		
  10.리스트 접기
	fold()를 사용해서 리스트의 모든 원소를 순서대로 조합해,결과값을 만들어낼수있음
	즉 sum동작시킬때처럼 할수있음
		abcList.fold(초깃값){누적값,현재원소->계산식}
		abcList.fold(0){sum,n->sum+n}
	이런식
	foldRight를 사용해서 오른쪽부터 이터레이션할수있음
	그리고 초깃값설정을 하지않고,첫원소를 초깃값으로 사용하고싶으면
		abcList.reduce{누적값,현재원소->계산식}
	를 사용할수있음
	그리고 연산의 마지막값이 아닌,각 연산을 적용할떄마다의 값이 필요하면(1,2,3,4를 sum해서 1,3,6,10리스트가 필요하면)
	runningFold()나 runningReduce()를 사용할수있음
		abcList.runningFold(초깃값){누적값,현재원소->계산식}
	이러면 값이 아닌 리스트가 반환됨,이때 리스트의 마지막값은 fold와 같음
		
  11.재귀
	재귀의경우 호출스택한계가 있어서 잘못하면 스택오버플로우가 날수있음,그래서 재귀보단 보통 반복문이 나은경우가 많은데,
	코틀린의 경우 일정조건을 만족하면 자동으로 재귀를 반복문으로 바꿔서 돌리는 기능이 있음(꼬리재귀)
	이건 tailRec를 재귀함수의 fun앞에 붙여서 사용하면됨
	이때 조건은
		재귀가 마지막연산이어야함,즉 재귀함수가 자신을 호출해 얻은 결과값을 아무연산도 적용하지않고 리턴해야함
			즉 return n+재귀함수명(n-1)은 안되고,return 재귀함수명(n-1)은 됨
	그래서 tailRec을 사용할땐,재귀함수의 인자를 2개받아서,현재값과 누적값을 따로 받아서 처리하는게좋음	
		
		
5.객체지향 프로그래밍
  1.인터페이스
	인터페이스에서 프로퍼티를 선언할수있는데,이경우 구현클래스는 반드시 프로퍼티를 오버라이드해야함
	이때
		직접 값을 바꿈(override val abc="aaa")
		커스텀게터를 사용(override val abc get()="aaa")
		생성자로 받음(class qqq(override val abc:String):aaa{})
	이렇게 3가지방식으로 처리할수있음
	
	이넘도 인터페이스를 만들고,구현할수있음,이때는 각 이넘타입별로 메서드를 모두 오버라이드를 해줘야함
	
	sam은 단일추상메서드로,메서드가 하나인 특수클래스임
	이걸 쓸땐 fun interface를 사용하면됨
		fun interface abcd{
			fun aa(a:Int,b:Int):Int
		}
	fun interface를 쓰면,컴파일러는 해당인터페이스안에 메서드가 하나밖에없는지를 확인함
	이걸 구현할때는 클래스를 통해 구현할수도있고,람다를 넘기는식으로 구현할수도있음(람다던지는게 자주쓰임)
	클래스구현은 걍 클래스하나만들어서 똑같이 구현하는거고,람다넘기는건
		val abc=abcd{i,j->i+j}
	이런식으로 {}안에 식을쓰면 자동으로 저걸 오버라이드해줌
	
	그리고 람다를 sam인터페이스가 필요한곳에 파라메터로 넘겨줄수도있음
	즉 sam을 구현한거 자체가 구현클래스이고,인터페이스를 상속했으니 해당인터페이스를 타입으로 받는 매개변수에 넣어서 실행하는게 가능한것(509p)

  2.복잡한 생성자
	init블록을 사용하면 객체가 생성될때 일을 할수있고,이때는 생성자파라메터에 val이나 var이 없어도 사용할수있음
	그리고 val로 정의되어있지만 초기화되지않은 변수도,init블록에서 초기화시켜주면 예외가 안뜸
	
  3.부생성자
	부생성자는 오버로드를 하기위해 사용됨,이건 constructor을 사용해야함
	부생성자를 쓸땐 반드시 주생성자를 포함해야함,즉 매개변수를 어떻게받든간에 주생성자의 인자들을 주입해야함
	즉 부생성자만 단독으로 오버로딩할수는없고,무조건 주생성자를 호출해야함
	그래서
		constructor(a:Char):this(주생성자인자들){
			...
		}
	이렇게 this를 붙여줘야함
	그리고 이렇게 부생성자를 통해 생성돼도 init블록은 주생성자에 붙어있기때문에 반드시 호출됨
	그래서 서로 공유해야하는 초기화로직은 init안에 넣으면됨(없으면 init를 안써도됨)
	그리고 가능하다면 걍 디폴트인자를 써서 주생성자 하나로 처리하는게 더 단순해지긴함
	
  4.상속
	코틀린에서 상속은,open으로 열어주지않으면 기본값은 불가능하게 되어있음
	그리고 메서드도 open으로 열어주지않으면 오버라이드가 불가능하니 명시적으로 열어줘야함
	확장함수는 상위클래스에 확장함수를 만들면,하위클래스들도 해당 확장함수를 사용할수있음(같은클래스취급이니)
	그리고 일반적으로는 접근불가능하지만,오버라이드할때 하위클래스에서만 접근가능하게하고싶으면 protected를 사용하면됨
	private는 하위클래스에서도 접근불가
	
	만약 해당 함수의 상위클래스버전을 호출하고싶으면
		super.메서드명()
	을 하면됨
  
  5.기반클래스 초기화
	클래스가 다른클래스를 상속할때,두 클래스는 모두 초기화되어야함
	그래서 기반클래스가 매개변수가 있다면,파생클래스가 생성될때는 반드시 기반클래스의 생성자인자를 제공해야함
		class abc(i:Int,j:Int):alpa(i,j)
	이런식으로 받아서 바로넘겨도되고,아니면 특정값을 걍넣어도됨,어쨌든 초기화만 되면됨      
	그리고 기반클래스에 파라메터가 없어도 빈괄호는 넣어야하고,만약 기반클래스에 부생성자가 있으면 그거써도됨
	
	하위클래스의 부생성자는,기반클래스의 생성자를 호출할수도있고(super(인자)),하위클래스 자기자신의 생성자를 호출할수도있음(this(인자))
	
  6.추상클래스
	추상클래스는 abstract를 사용하면됨
	추상클래스는 인터페이스와 거의 똑같지만,상태를 가질수있다는 차이점이 있음,즉 프로퍼티안에 데이터를 넣는게 가능함
	인터페이스나 추상클래스나 둘다 구현이 있는 메서드를 가질수있고(디폴트메서드),구현이 없는 메서드도 가질수있음
	그리고 인터페이스는 다중상속이 되지만,추상클래스는 다중상속할수없음(상태의중복때문)
	
	인터페이스의 메서드명 중복시엔 Super<a>.aa(),Super<b>.aa()이런식으로 표시해서 사용할수있음
	그리고 디폴트메서드도 적용안되고 직접 해당클래스에서 오버라이드해야함
	
  7.업캐스트
	인터페이스를 구현한 클래스를 받아서,그 클래스의 기반클래스처럼 취급하는걸 업캐스트라고 함
	즉 animal을 구현한 monkey,rabbit들은 animal처럼 취급할수있음(animal만 받는곳에 넣을수있음)
	상속의 목적 자체가 구체타입을 더 일반적인 상위타입으로 다룰수있게하는게 전부이기때문(리스코프 치환 원칙)
	이렇게 되지않는케이스엔 상속을 사용하지말고 합성을 사용해야함
	
	그리고 업캐스트를 한곳에서는 기반타입의 메서드만 호출할수있음(밑에 구체클래스 정보는 다 날아갔으니까)
  
  8.다형성
	상속을 이용한 다용성을 사용하면,기반클래스가 아닌 구체클래스의 정보는 모두 사라지고,오버라이드한 정보만 남음
	
  9.합성
	합성은 사용하려는 클래스를 해당 클래스 안에 포함하는것(has-a)
	상속은 사용하려는 클래스가 자기보다 상위개념(is-a)일때 사용됨
	즉 api를 재사용하는게 아닌,기능을 재사용할때 사용됨,그래서 기능을 재사용하고싶을땐 상속보다 합성하는게 좋고,
	우선순위는 합성>상속>클래스위임 순서로 선택하면됨
	합성을 사용하면 약의존을 만들기 쉬워짐
	즉 상속은 api재사용을 위해 사용하고,합성은 해당클래스의 api를 완전히 감추고 기능만 사용할수있게함
	즉 외부에서 해당클래스에 대한 의존이없기때문에,같은일을 하는 다른클래스를 가져다가 붙여도 외부에 영향이없음
	
  10.상속과 확장
	기존클래스를 새 목적으로 사용하고싶은데,기존클래스를 변경할수없을때는 상속대신 확장함수를 사용할수있음
	보통 상속을 하는 목적이 새로운 메서드를 추가하고싶어서 그런거라면,확장함수를 쓰는게 나은선택지인 경우가 많음
	기반클래스에서 벗어나는 함수를 만드는건,기반클래스처럼 하위클래스를 사용할수없기때문에 항상 별로임
	
	어댑터패턴을 만들때는,인터페이스와 open클래스를 둘다 상속받아서,
	인터페이스의 구현을 open클래스쪽으로 몰아주는(스프링시큐리티 일반로그인이랑 소셜로그인 묶던 그거)방법도 있지만
	만약 open이 아니고 수정할수없다면 합성을 통해 어댑터를 만들수있음(jpa레포지토리분리할때 합성해서쓰던 그거)
	합성해서쓰는게 둘다쓰는거보다 좀 덜깔끔하긴하지만 그래도 괜찮음
	
	확장함수는 어댑터를 생성할때 사용할수없음,확장함수를 모아서 인터페이스를 만들수없기떄문
	
	그리고 확장함수가 private멤버에는 접근할수없기때문에,이경우엔 멤버함수를 정의해야함
	그리고 오버라이드할수도 없음(가장 큰 한계)
	함수를 오버라이드 할필요가 없고,공개맴버만으로 충분할때는 멤버함수로해도되고 확장함수로 해도되는데,
	멤버함수는 타입의 핵심을 반영하고,해당함수가 없으면 클래스성립이 안될정도여야하고
	확장함수는 타입의 존재에 필수적이지않은,대상타입을 지원하고 활용하기위한 외부연산이나 편리를 위한 연산이어야함
	
	코틀린은 상속을 의도적으로 허용하지않으면 다 금지함
	상속보단 확장함수나 합성을 택하는게 정답일 확률이 높음
	
  11.클래스위임
	클래스위임은 상속과 합성의 중간지점임,코틀린에선 위임을 언어단에서 지원하고,이 위임의 기본동작은
	해당 클래스의 모든 메서드를 인터페이스의 모든 메서드와 연동해줌
	이건
		interface abc
		class aaa:abc
		class bbb(val a:aaa):abc by aaa
	이런식으로 인터페이스 by 합성객체 하면됨
	이때 앞은 무조건 인터페이스여야함,클래스를 사용할순없음
	
	즉 
		위임은 같은 구체클래스를 di받은다음(val a:aaa)
		인터페이스를 상속받고(:abc)
		해당 인터페이스의 기본동작을 정해주는것(by aaa)
	이때 기본동작이니 override를 bbb내부에서 적용하면 aaa랑 다르게 동작하게할수있음
	
	이걸 사용해서 다중상속 비슷하게 흉내낼수있음(전혀 다른 여러 클래스를 묶을때)
	즉 다중위임이 가능함
	이렇게 다중위임을 하면 해당 하위클래스는 양쪽의 기반클래스로 업캐스트가 가능해짐
	물론 좀 위험하긴하기떄문에,합성(기본값)->상속(타입계층과 하위계층간의 관계)->위임(정안될때) 순서대로 생각하는게 좋음
	
  12.다운캐스트
	기반클래스는 항상 하위클래스보다 작거나같은 인터페이스를 가지기때문에 업캐스트는 항상 안전함
	다운캐스트는 기반클래스를 하위클래스로 취급하는거임(그래서 예외확률이 있음)
	이때 예외발생을 막기위해 스마트캐스트를 사용할수있음(is)
	스마트캐스트를 사용해서 if문을 짜면,어떤객체가 특정타입인지 검사하고,이 영역안에서는 해당객체를 검사에 성공한 타입으로 취급함
		if(a is aaa){... 여기서 a를 aaa로 취급}
	그렇기떄문에 저 블록안에선 하위클래스의 메서드를 호출할수있게됨
	이 스마트캐스트는 is를 통해 사용하는 when에서 아주 유용함
	
	이 스마트캐스트는 대상이 val이어야 제대로 작동함,
	var이라면 중간에 바뀔수있기때문에 스마트캐스트를 하지못하고 명시적 다운캐스트를 해야함(a as aaa)
	명시적 다운캐스트가 실패하면 ClassCastException을 던짐(그래서 안전하지않은 다운캐스트임)
	안전한캐스트인 as?는 실패하면 null을 던져서,null을 처리해줘야함(보통 엘비스를 사용함)
	
	컬렉션에서 타입검사할떄도 유용함
		abcList.find{it is aaa} as aaa?
	이렇게 쓰면 aaa(첫값)거나 null(하나도 일치하지않을경우)인 2가지로 리턴됨
	물론 filter쓰는게 더 나음
	그리고 filter{it is aaa}보다 filterIsInstance<aaa>()가 더 깔끔함
	동작은 거의똑같은데,단 결과타입은 filter은 인터페이스를,filterIsInstance는 구체클래스 리스트를 내놓는다는게 좀 다름
	
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
		