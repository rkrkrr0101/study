1부.프로그래밍 기초중 특이한거
	함수가 한줄로만 이뤄졌을경우
		fun abc(x:Int):Int=x*3
	이런식으로 쓰고
		abc(3)
	이런식으로 사용할수도있음
	
	int를 나누기하면 기본적으론 버림처리하고,이게싫으면 double로 변환해서 처리해야함
	그리고 코틀린은 오버플로우를 잡아주지않으므로(잡아줄떄도있지만 확실한건아님),항상 신경써야함,이때 Long를 쓸수있음
	Long도 모자라면 BigDecimal을사용해야함
	
	do-while을 사용하면 무조건 한번은 실행하는 while을 만들수있음
	
	for를 쓸때 
		until로 마지막값을 제외한값을 돌릴수있고(0 until 3 ->0,1,2)
		downTo로 역순진행(5,4,3,2,1)을 할수있고,
		step으로 n개씩 건너띌수있음(0..9 step 3)
	등이 있음

	in으로 어떤 값이 해당범위안에 존재하는지 확인할수있음(bool)
		32 in 1..100 -> true
		3233 in 1..100 -> false
	반열림범위도 있음(코틀린 1.8부터)
		32 in 1 ..<100 -> true
		100 in 1 ..<100 -> false
	string도 적용됨
		"ab" in "aa".."az" -> true
		"bb" in "aa".."az" -> false
	이렇게

	문은 상태를 변경하고,식은 값을 짜냄
	즉 문은 사이드이팩트를 일으키기위해서 사용되고(for),식은 값을 뽑아내기위해서 사용됨(함수)
	그래서 식은 값을 돌려주기때문에 다른식의 하위요소나 변수에 대입할수있지만,문은 변수로 대입할수없음
	if는 식을 반환하기때문에,변수에 대입할수있음(if의 결과가 대입됨,즉 if문을 돌리고 결과값만 대입해서 해당타입이 대입됨)
	i++도 문이 아니라 식임
	
	
2부.객체소개중 특이한거
	코틀린에서는 자바와 달리,패키지의 구조가 폴더를 따라가지않아도됨(하지만 따라가게하는게 편함)
	
	vararg로 생성자에서 파라미터를 여러개받을수있음
		fun abc(val a:String,vararg ints:Int){}
	이때 array로 들어옴
	그리고 저자리에 array를 넣어서 호출할수있음(이때 그냥 array<Int>가 아닌 타입이 지정된 array를 사용해야함)
		abc("aqq",intArrayOf(1,2,3))
	이런식
	
	프로퍼티에 get,set을 설정할수있음(프로퍼티 선언뒤에 바로 적으면됨)
		var i:Int=0
			get(){
				return i+30
			}
	이렇게	
	
	
3부.사용성
  1.확장함수
	확장함수는 해당 클래스에 멤버변수를 추가하는거처럼 동작하게할수있음
	즉
		fun String.abc()="abc"
	이런식으로 해당클래스의 함수를 추가할수있는데,일단 이 확장함수는 해당 패키지에서만 사용할수있고,다른패키지에서 사용하려면 임포트를 해야함
	그리고 this를 사용하지않아도 자기자신(즉 String)의 프로퍼티나 메서드에 접근할수있음
		fun String.abcTwin()=this.abc()+this.abc()
		fun String.abcTwin()=abc()+abc()
	두개다 똑같이동작
	그리고 확장함수는,실제로 해당 클래스에 들어가는게 아닌 데코레이터패턴을 구현한거라서,퍼블릭원소에만 접근할수있고,밖에서 접근가능한곳에만 접근할수있음
	즉 신택틱슈가임(ide사용할떄는 편해지고,구분도 안해도되니)
	
  2.이름붙은 인자와 디폴트인자
	함수를 콜할때 이름을 명확히 지정해서 부를수있음
		val a=aqq(red=255,blue=240)
	그리고 메서드를 만들때도 디폴트값을 설정할수있음	
	
  3.오버로딩
	오버로딩은 같은동작인데 약간다른 타입을 같은방식으로 처리할때 사용됨(int와 double같은)
	만약 어떤 클래스안에 확장함수와 시그니처가 똑같은 멤버함수가 있으면 멤버함수를 우선시하는데,이걸가지고 오버로딩을 할수있음
	그래서,확장함수+오버로딩을 디폴트인자를 흉내내기위해 사용하면안됨
	즉 진짜 오버로딩을 하기위해 확장함수를 사용하는건 괜찮은데,디폴트인자처럼 동작시키기위해 사용하면안됨(애초에 디폴트쪽으로 접근이 불가능하기때문)
	
  4.when
	when은 case문임
	when에서 ,로 여러값들을 한 분기로 묶어처리할수있음
	when에서 {}를 두면 해당값으로 아무처리도 안하겠다는거(그냥 빈거임)
	when에서 return을 하면 해당 함수자체가 끝이나니 조심
	when에서 값이 아닌 조건(age<20)도 조건에 넣을수있음,단 boolean타입이어야함
	
  5.이넘
	이넘은 이름을 모아둔 클래스임
	이걸 사용하면 오타걱정이 없어지고,when을 사용할떄도 편하게 사용할수있음(분기가 정확히 나눠지니 else가 필요없음)
	이넘에서도 멤버함수를 추가할수있는데,이때는 마지막이넘값 다음에 세미콜론을 꼭 붙이고,함수나 프로퍼티를 추가하면됨
	보통 프로퍼티나 함수만들고,자기자신클래스를 가공해서 리턴하는걸 자주사용함
	
  6.데이터클래스
	데이터클래스는 toString(),hashCode()등을 자동으로 생성해주는 클래스임,즉 데이터저장만 하는 클래스면 이걸쓰면 편함
	이떄 해당클래스는,생성자의 모든 파라미터를 val이나 var로 선언해야함
	
  7.구조분해선언
	pair이나 triple같은 클래스들을 한번에 분해할수있음
		val (a,b)=페어값
	data클래스는 자동으로 구조분해선언을 지원함,이때 그냥 프로퍼티순서대로 넣으니,데이터클래스에 값추가할떄는 조심해야함	
	
  8.널이될수있는타입
	널이될수있는타입은 String?처럼 물음표를 붙임,타입추론도 만약 해당값이 널허용이면 물음표를 붙여줌
	String와 String?는 서로 다른타입이라,대입할수없고,String?에 가공을거쳐서 String로 바꿔서 대입할수는있음
	그리고 물음표타입은 역참조(메서드나 프로퍼티에 접근)할수없고,널일경우 어케할지를 말해준다음 접근할수있음
	이건
		널일경우를 if문으로 검사
		안전한호출(널일경우 아무일도안함)
		엘비스연산자(?:)
		널아님단언(!!)
	로 처리해야함
	
  9.안전한호출과 엘비스연산자
	val a:String?일 경우에 멤버변수를 호출하고싶으면
		a?.echo() //안전한호출,널일경우 그냥 패스됨
		a?.echo()?:println(null)//엘비스,널일경우 뒤의식이 실행됨(if문이라고봐도됨)
	호출을 연쇄시키는 중간에 널이 결과로 나올경우 이걸 사용해서 처리해줄수있음(안전한호출로 연쇄해서 엘비스로 널처리)
	
  10.널아님단언
	!!로 얘는 널이 아니다라고 단정지을수있음,당연히 어지간하면 사용하면안되고,
	보통 if문으로 검사하거나 엘비스연산자를 주로 사용함(자바라이브러리쓸때도 가끔씀)
	그리고 널일때 예외를 발생시켜야할때도,
	npe보다는 해당예외가 뜨는게 명확한 예외가 뜨는게 나음
	즉,맵을 map["aa"]보다 map.getValue("aa")로 읽어서 값이없으면 npe말고 NoSuchElementException가 발생함 
	
  11.확장함수와 널이될수있는타입
	abc?.aa()는 abc가 널이 될수있는타입이라는걸 암시하지만,abc.aa()는 abc가 널이될수없는타입이라는걸 암시하지않음
	왜냐면 코틀린의 확장함수는,널이될수있는타입에만 추가하는,즉 String?에만 추가할수있기때문임
	이런함수를 만들땐
		fun String?.abc():리턴타입{}
	이렇게 타입뒤에 물음표를 붙이면됨
	
  12.제네릭스	
	제네릭은 클래스의 파라메터나 리턴타입등을 해당클래스가 생성될때 지정하는것임
	보통 컬렉션에서 주로 사용됨
	any나 오브젝트를 사용하지못하는이유는,얘들은 붙여두면 구체적인타입을 사용(해당파라메터의 하위메서드를 호출할때)할수없어지기때문
	
  13.확장프로퍼티
	확장프로퍼티는,확장함수처럼 프로퍼티를 확장하는거임
	이건
		val String.abcd:타입명
		  get(){...}
	이렇게 사용됨,이때 반드시 커스텀게터를 넣어줘야함
	즉 확장함수의 변형처럼 사용됨(파라미터가 없는 확장함수와 동격이라고 생각하면됨,실제로 양쪽은 서로 변형할수있음)
	보통 기능이 단순하고 가독성이 올라갈때만 이걸 쓰는데,보통 잘 쓸일은 없음
	이 확장프로퍼티도 제네릭을 사용할수있음
		val <T> List<T>.abcd:T?
		  get(){...}
	만약 함수가 예외를 던질땐,프로퍼티보다 함수쓰는게 나음
	그리고 제네릭대신 *를 사용할수도있는데,이경우엔 해당타입정보(하위메서드등)를 다 잃어버리니 조심
	
  14.break와 continue
	일반 break와 continue는 잘 사용하지않는게 좋음,goto보다야 당연히 낫지만,알아보기 힘들어지는경우가 많기때문(한번더 생각해야함)
	또한 break와 continue는 자신이 속한 루프범위(가장 가까이있는 for나 while)를 벗어날수없음
	이때 레이블을 사용하는게 좋음
	레이블은 
		하려는일@레이블명
		break@abc
	로 사용할수있음
	이건 for나 while에 이름을 붙이고,해당 반복문을 대상으로 조작할수있음
		abc@ for( i in aList){
			for (j in i){
				if(j==1)break@abc
			}
		}
	이런식으로 사용하면,바로 j가 1일경우 바로 전체반복문이 탈출됨
	근데 애초에 어떤식이든 반복문을 중간에 탈출한다는거 자체가 머리가 복잡해지기때문에,가급적 사용하지않고 루프돌리는게나음


4.함수형 프로그래밍
  1.람다
	람다는 이름없는함수임
	이건 파라메터로 함수를 받는 코드(map(),filter()같은)곳에서 사용됨
	람다의 파라메터가 하나일경우,자동으로 it으로 이름을 붙이고,여러개일경우는
		{n:Int,a:Int->n+a}
	이런식으로 쓸수있음,여기서 타입은 생략가능(추론가능)
	함수의 파라메터가 람다뿐이면 ()괄호를 생략하고 바로{}로 시작할수있음
	람다가 파라메터의 마지막이면,밖으로 빼낼수있음
		abc(){}
	단,이름붙은인자(abc(a="aa",b={...}))를 쓸땐 괄호안에 넣어야함
	그리고 람다의 인자중 하나이상을 사용하지않는데,ide경고를 제거하고싶으면 해당자리에 _를 넣어서 명시적으로 무시하겠다고 선언하면됨
	그리고 람다에 파라메터가 없으면 그냥 쓰면됨
	
  2.람다의 중요성
	람다는 비슷한 여러 작업들을 묶기가 매우편함
	즉 함수형프로그래밍은 문제를 작은단계로 풀어나가는데,이걸통해 매우 작은부분만 새로작성하고 나머지부분을 전부 재사용할수있음
	예를들면 filter()을 사용하지않으면,해당리스트에서 조건부분을 제외하면 전부 중복인데,filter를 사용하면 조건만 나열하면되니 중복을 제거할수있음
	람다는 변수에 넣을수있음
	그리고 람다는 자기 밖의 변수를 포획할수있음(클로저),즉 람다내부에서 자기 밖의 변수를 건드릴수있다는거(읽기쓰기둘다됨)
	뭐 보통은 변경하지않는게 코드가 깔끔할확률이 높긴함
	
  3.컬렉션에 대한 연산
	컬렉션연산은
		map
		filter(조건만족하는애들만 리스트로 리턴)
		filterNotNull(널을 제거)
		any(해당조건만족하는게 1개이상있는지 리턴,bool)
		all(모든원소가 조건만족)
		none(모든원소가 조건불만족)
		forEach
		find(만족하는 첫번째원소 반환,없으면 예외)
		findOrNull(만족하는 첫번째원소 반환,없으면 null)
		lastOrNull(만족하는 마지막원소 반환,없으면 null)
		count(만족하는 원소갯수 리턴)
		partition(조건을 기준으로 값을 나눌수있음,Pair<List,List>로 리턴됨)
		sumBy(람다에 들어온값을 더함,정수리턴,단순한값이 아닌 클래스리스트일때 어떤 한값을 선택해서 더할때 주로사용됨)
		sumByDouble(람다에 들어온값을 더함,실수리턴,단순한값이 아닌 클래스리스트일때 어떤 한값을 선택해서 더할때 주로사용됨)
		sortBy(람다에 들어온값을 기준으로 정렬,두개이상도가능,오름차순)
		sortByDescending(람다에 들어온값을 기준으로 정렬,두개이상도가능,내림차순)
		sortedWith(compareBy를 사용해서 리스트를 정렬,compareBy안에 조건을 나열하면됨)
		take(해당조건을 만족하는 첫원소를 리스트에서 제거하고 가져옴)
		drop(해당조건을 만족하는 첫원소를 리스트에서 제거함)
		takeLast(해당조건을 만족하는 마지막원소를 리스트에서 제거하고 가져옴)
		dropLast(해당조건을 만족하는 마지막원소를 리스트에서 제거함)
	등이 일단 있고,any나 find들은 만족하는거 찾자마자 반복문탈출함
	리스트를 만들땐
		List(리스트크기){초기화값}
		List(리스트크기){it}//인자로 추가할 원소의 인덱스값을 받음
		List(리스트크기){0}//0으로 초기화
		List(리스트크기){'a'+it}//a에 인덱스값을 추가한값으로 초기화(a,b,c,d...)
	등으로 만들수있음
	즉 첫파라메터로 크기를 던져주고,람다로 초기화방법을 던져줌
	
  4.멤버참조
	멤버참조는 해당클래스의 메서드나 프로퍼티를 참조할수있음
		Message::isRead
	이런식
	사용할때는
		val messages=listOf<Message>(...)
		messages.filter(Message::isRead) //{it.isRead=true}와 같음
	이런식으로 사용할수있음(즉 람다를 좀더 짧게쓰는느낌임)
	정렬순서를 적용할때도 유용함
		messages.sortedWith(compareBy(Message::isRead,Message::sender))
	이런식으로 사용할수있음	
	
	메서드를 참조할땐,보통 해당 클래스내에 bool을 리턴하는걸 미리 만들어두고,해당메서드를 참조하는식으로 사용함
	즉 람다가 너무길어질거같을때나,반복사용이 될거같을때 저쪽으로 미리 빼놓고 그걸 가져다 사용하는식(함수참조)
	이거도 확장함수랑 같이 잘 사용됨
	이건
		fun Message.isImportant():Boolean{...}
		messages.any(Message::isImportant)
	이런식으로 사용됨
	그리고 만약 해당함수가 최상위함수라면
		fun abcd(){...}
		messages.any(::abcd)
	이런식으로 사용됨
	
	생성자를 참조할수도있음
		names.mapIndexed{index,name->Student(index,name)}
		names.mapIndexed(::Student)
	이 두개는 같음
		
  5.고차함수
	고차함수는 함수를 다른함수의 인자로 넘기는게 고차함수임
	람다는 변수에 저장할수있고,이걸 가져다가 다른함수에 쓸수있으니 코틀린은 고차함수를 지원함
  6.리스트 조작하기
	zip()은 두 리스트를 하나씩 Pair로 만든 리스트로 변환함
		aList.zip(bList)
	만약 두 리스트의 크기가 다를경우,작은쪽이 끝나면 거기서 종료됨
	그리고 람다를 써서 변형하는것도 가능
		aList.zip(bList){a,b->Person(a,b)}
	이런식	
	
	flatten()은 리스트를 평평하게 펴서 리턴함(이중리스트같은걸 한줄로 만들어서 리턴)
	flatMap()은 해당조건의 값만 평평하게 펴서 리턴해줌(map+flatten이라고 보면됨)
	Person(이름,나이)일때
		val personList=ListOf<Person>(...)
		personList.flatMap{it.age}
	이러면 나이만 리스트로 출력됨
	
	이넘.vlaues를 map하면,각 이넘값마다 하나의 리스트를 생성함,
	그래서 이중이넘을 묶어서 만들고싶으면 밖에 flatMap치고 안에서 Map쳐야함
	
  7.맵만들기
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		