1.안정성
	1.가변성을 제한하라
		꼭 변경할 이유가 있는곳에만 var을 사용하고,변경할이유가 없으면 val을 사용해야함
		가변성이 있으면 코드실행시 값추론이 어려워지고 멀티스레드에서도 동기화안하면 문제생기고,테스트도 귀찮아지고 문제가 많아짐
		그리고 다른 프로퍼티에 의존하는경우에도
			val fullName
				get()="$name $surName"
		이런식으로 커스텀게터를 사용하는거로 var을 사용하지않고 대체할수있음
		이처럼 val은 변경불가능이 아닌,재할당불가능임
		그리고 val은 스마트캐스트(위에서 if문으로 해당타입검사하면 그거로 자동 캐스팅,보통 널에이블지울떄사용)같은 기능을 사용할수있음
		
		그리고 리스트같은 컬렉션의 경우에도,컬렉션 내부의 값을 변경할수있는 mutable컬렉션과,변경할수없는 immutable컬렉션으로 나눠짐
		즉 var과 val의 선택,mutable과 immutable의 선택으로 총 4가지 경우의수가 있음
		단 immutable의 경우에도,코틀린내부에서 값을 변경하지못하게 막는거라서 억지로 바꾸려고하면 바꿀수있으니 컨벤션으로 이걸못하게해야함
		주로 다운캐스팅으로 이렇게할수있으니 주의
		그리고 mutable과 var을 같이쓰는건 안하는게좋음,두개를 같이쓰면 모호성때문에 사용하지못하는 기능들이 생김(+=같은거 사용불가능해짐)
		
		이런 immutable객체들은 공유해도 충돌이 안나서 병렬처리에 걍박아도되고,캐싱도쉽고(변경이없으니),깊은복사도 안해도됨
		그리고 리스트의경우는 집합이나 맵의 키로 사용할수있음,
		mutable의경우는 불가능함(집합과 맵이 해시를 사용하는데,해시테이블은 처음요소를 넣을떄 값을 기반으로 버킷을 결정하기때문)
		
		이런 immutable객체들을 수정하고싶으면,자신의 일부를 수정한 새로운 객체를 만들어내는 기능이 있어야하는데 이게 copy임
		data를 클래스앞에 붙이면 이런 copy메서드를 만들어줌
		
		변경가능한 객체를 외부에 노출하는건 굉장히 위험함(mutable리스트를 리턴한다던가)
		이러면 얕은복사가 되니 밖에서 값을 바꾸면 안까지 바뀌어버림
		그래서 이걸 리턴해야할땐 이걸 복사해서 리턴해줘야함
		
	2.변수의 스코프를 최소화하라
		변수는 가능한 작은 스코프를 가져야함
		
		프로퍼티보단 지역변수를 사용하는게 좋고,반복문내부에서만 변수가 사용되면,변수를 반복문안으로 넣는게 좋음
		코틀린에서 스코프는 중괄호로 만들어지며,내부에서 외부로만 접근할수있음
		
		이렇게 스코프를 좁게만들면,프로그램을 추적하고 관리하기가 쉬워짐
		코드를 분석할땐 어떤시점에 어떤 요소가 있는지를 알아야하는데,이때 요소가 많아져서 프로그램에 변경할수있는게 많아지면 인지과부하걸림
		추가적으로 스코프가 너무 넓으면,생각하지못한곳에서 변수가 사용될수있음
		
		그리고 변수는,변수를 정의할때 바로 초기화되는게(val abc:String="abc")가장 이상적임
		그리고 여러변수를 한번에 설정해야할땐,구조분해선언을 사용할수있음
		
		그리고 추가적으로,람다의 캡쳐(변수포획)에서도 반복문외부에 있을경우 문제가 생길수있으니 최대한 안에넣는게좋음
		
	3.최대한 플랫폼타입을 사용하지마라
		플랫폼타입은 코틀린말고 자바라이브러리같은데서 생성된 리턴값을 말함
		이경우엔 널에이블인지 아닌지 알수없음
		특히 자바의 제네릭에서 자주 문제가 터짐,특히 리스트와 리스트 내부까지 전부 널검사를 해야함
		거기다 2중리스트일경우 더복잡해짐
		물론 리스트의경우엔 검사메서드가 있지만,이거말고 다른거일경우 너무머리아파짐
		
		이런 플랫폼타입은,만약 자바코드를 수정할수있으면 @NotNull같은거로 표시해두는게 좋고,
		못한다면(라이브러리) 최대한 빨리 널검사를 쳐서 널이 아님을 확정짓고 처리해야함,플랫폼타입을 리턴하는건 금기임
		
	4.inferred타입으로 리턴하지마라
		inferred타입은 타입추론된 타입임
		문제는 이런 타입추론은 정확히 오른쪽에 있는 피연산자에 맞게 설정되어서 타입을 상위타입(인터페이스)으로 올릴수없어짐
		즉 인터페이스를 상속받은 구체클래스로 만들어져서,인터페이스를 상속받은 다른 구체클래스로 변경이 불가능해진다는 문제가 생김
		그러니 리턴값은 추론값이 아닌 명시된타입으로 리턴을 해야함
		
	5.예외를 활용해 코드에 제한을 걸어라	
		확실하게 어떤 형태로 동작해야하는,즉 api에서의 사전조건을 확인할땐 예외를 활용해서 제한을 걸어주는게 좋음
		코틀린에서 코드의 동작에 제한을 걸땐
			require:매개변수의 제한을 걸때 사용(id!=null)
			check:상태와 관련된 동작을 할때 사용(isOpen)
			assert(테스트모드에서만 작동,어떤값이 true인지 확인할수있음)
			return,throw와 같이사용하는 Elvis
		이렇게 사용할수있음
		만약 해당검사가 실패하면,바로 예외를 던짐(일리걸아규먼트익셉션)
			require(id!=null){
				"id is null"
			}
		이렇게 메세지도 넣을수있음
		보통 매개변수테스트는 require을 사용함
		이렇게 제한을 걸면 문서를 값이 잘못들어오는걸 바로 차단하고 예외를 던져서 확인이 쉬워짐
		예상하지못한행동을 하는건 예외를 던지는거보다 굉장히 코스트가 많이드는일임
		그리고 이렇게 제한을 걸면 자동으로 스마트캐스트가 된다는 추가적장점이 있음(보통 널에이블 지워져서 유용할듯,변수를 언팩할떄 유용)
		
		상태를 검사하고싶을땐 check를 사용함
		이건 일리걸스테이트익셉션을 던진다는거말고는 require과 똑같은데,관례상 require는 최상단에 위치하고,
		check는 중단부에서 체크할필요가 있을때 사용함
		
		Assert는 그냥 단위테스트를 약간 보조해주는정도인듯,잘 사용하진 않나봄
		
		그리고 엘비스를 사용해서,해당값이 널일경우 바로 리턴을 한다던가 쓰로우를 한다던가 하는식도,nullable을 벗길때 자주 사용되는 관용적방법임
		이런건 함수앞부분에 넣어서 잘보이게 만드는게 좋음
		
	6.사용자 정의 예외보단 표준예외를 사용하라
		정 해당상황에 사용할만한 예외가 없는게 아니면,최대한 표준라이브러리의 예외를 사용하는게 좋음
			IllegalArgumentException:잘못된 매개변수
			IllegalStateException:잘못된 상태
			IndexOutOfBoundsException:컬렉션의 범위를 넘었음
			ConcurrentModificationException:동시수정을 금지했는데 발생해버렸을때
			UnsupportedOperationException:사용자가 사용하려는 메서드가 현재객체에서는 사용할수없을때(보통은 이런게있으면안됨)
			NoSuchElementException:해당 요소가 존재하지않을때
		이런거로 해결안될때 커스텀예외를 사용하면됨
		
	7.결과부족이 발생하면 null이나 Faulure를 사용
		결과부족이 발생하면(레포지토리에서 뭘 찾았는데 없었거나),널을 반환하거나,널을 반환하기싫으면 실패를 나타내는 sealed클래스를 리턴하는게 좋음
		예외를 반환하는식으로 처리하면,예외는 예외적인 상황이 나왔을때만 사용하는게 좋고,정보를 전달하는용도로 사용되면 안됨
		특히 코틀린의경우 모든예외가 언체크예외라서,저쪽에서 안잡으면 바로 터짐
		
		널을 반환했을경우엔 받는쪽에서 바로 널을 벗겨서 사용하면됨,널이면 분기타고
		보통 추가정보를 반환해야하면 Faulure를 사용하고,아니라면 null을 사용하는식임
		
		보통 
			get()은 반드시 해당값이 있을때,
			getOrNull()은 있을지없을지 모를때,
			getOrDefault()는 있을지없을지모르겠지만 없으면 기본값받고싶을때
		사용함
		즉 get()에선 예외를 터트리는게 맞고,getOrNull에선 null반환하는식
	
	8.적절하게 null을 처리
		null은 값이 부족하다는걸 나타냄
		프로퍼티가 null이라는건 값이 설정되지않았거나,제거되었다는것
		즉 null을 사용할땐 null에 대한 의미가 명확해야함
		
		보통 null을 처리할땐
			?.(안전호출),엘비스,스마트캐스팅등으로 처리
			예외를 던짐
			nullable을 널불가로 바꿈
		3가지 방법으로 처리함
		
		보통 문맥상 널이 나올만하면 처리하고,널이 뜬금없이나오면 예외를 던지거나,널불가로 바꾸는식
		그리고 !!는 진짜 어지간하면 사용하면안됨
		현재 널이 안나오는게 확정되었다고,미래에도 확정된건 아닐수있음
		아예 금지하는게 나음
		
		그리고 널가능해지면 어떻게든 이걸 처리하는비용이 발생하니까,가급적이면 꼭필요하지않으면 널불가로 사용하는게 좋음
		그리고 어떤값이 클래스생성이후 반드시 초기화되면 lateinit나 notNull델리게이트를 사용할수있고
		빈컬렉션대신 null을 리턴하면안됨(의미가 완전히다름)
		nullable enum과 None enum은 완전히 다른의미임,null은 따로처리해야하지만,None는 정의에 없다는뜻
		
		그리고 초기화를 늦게해야할경우에도(반드시 초기화될때),널을 허용하는게 아닌 lateinit를 사용해서 늦은초기화를 걸어버리는게 나음
		이경우엔 해당값이 없을때 해당필드를 건드리면 예외가 발생하지만,애초에 그걸 사용하는게 초기화전에 있다는게 문제라서 상관없음
		이 lateinit는 Int,Long,Double,Boolean같은 기본타입과 연결된타입에선 사용할수없음
		이때는 Delegates.notNull을 사용할수있음
			var abc:Int by Delegates.notNull()
		이런식
	
	9.use를 사용하여 리소스를 닫아라
		필요하지않을때 close로 닫아야하는 리소스들(db관련이나 스트림관련)은 보통 try caych finally로 닫는데
		이경우 finally에선 try가 안된다는문제가 있음
		그래서 use라는 함수가 표준라이브러리에 들어있음
			reader.use{...}
		저안에 넣으면 자동으로 끝나고 알아서 닫아줌(Closeable를 상속받은 모든객체)
		
	10.단위테스트를 만들어라
		단위테스트는 꼭 만들어야함
		단위테스트를 만들면
			개발시점의 빠른피드백(유스케이스확인)
			회귀버그방지
			올바른 아키텍쳐모양이 되는걸 강요(모킹을 안했을때)
		라는 장점이 있음

2.가독성			
	1.가독성을 목표로 설계해라
		코드를 쓰는데보다 읽는데 시간을 더 소모하기때문에,항상 가독성을 염두에두고 코드를짜야함,이러려면 인지부하를 감소시켜야함
		이때 가능하면 해당언어에서만 사용되는 관용구는 한줄당 하나씩만 넣고,if같은 평범한걸 기준으로 짜는게 좋음
		즉 사용빈도가 적은관용구는 코드가 복잡해지고,그런 관용구들을 한문장내에서 조합해서 사용하면 훨씬 더 복잡성이 올라감(1+1=3)
		
		그리고 그냥 명시적으로 툭툭던지는게 나중에 수정하기도 쉬움
		물론 언어특성으로 훨씬 효율적이 되는경우가 있음,즉 저런거를 쓰려면 해당행동을 사용하는데에 명확한 이유가 있어야함
		즉 let를 널제거용도로 사용하는식같은느낌
		
		그리고 사람에따라 가독성에 대한 관점이 다를수있는데,그래도 하면안되는건 있음
			dsl이 아닌곳에서 연산자의미와 맞지않은 연산자오버로딩
			이미있는기능을 다시만들기
		같은거
		
	2.연산자오버로딩을 할때는 의미에 맞게 사용해라
		연산자 오버로딩을 할땐,해당 오버로딩을 할때의 함수명과 같은 행동을 해야함
		a+b와 a.plus(b)는 같은 함수를 부르기떄문에,자기맘대로 이상한거 붙여버리면 다른사람들이 혼란에 빠짐
		
		그리고 애매할땐 infix(중위함수)를 사용해서 확장함수를 사용하거나,톱레벨함수(1급객체로 함수를 만드는것)를 사용하는게나음
		단,dsl의경우엔 무시해도됨
	
	3.Unit?를 리턴하지마라
		이건 Unit으로 tf를 받으려고 이렇게하는데,이건 처음보면 이해하기도어렵고,예측하기 어려운 오류를 만들수있음
		그러니 사용하지않는게좋음
	
	4.변수타입이 명확하지 않은경우 확실하게 지정하라
		진짜로 타입이 명확하지않은경우엔 무조건 타입을 명시해두는게 좋음
		즉
			val num=10 
		이런건 타입추론해도 상관없는데
			val data=getData()
		이런거 타입추론해버리면 뭔지 또 찾아봐야하니까 개귀찮음
		이런건
			val data:UserData=getData()
		이런식으로 명시해두는게 가독성면에서 좋음,그리고 가독성외에도 안전을 위해서도 타입을 지정하는게 낫고(플랫폼타입사용금지와 추론타입으로 리턴금지)
	
	5.리시버를 명시적으로 참조하라
		어디를 참조하는지 명시적으로 알려주는 this같은거를 사용해서,명시적으로 참조하게 하면 가독성에 도움이 됨
		특히 apply,with,run같은걸 사용할때가 대표적임
		리시버가 명확하지않으면 명시적으로 리시버를 적어서 이를 명확하게 해줘야함,아니면 가장 가까운 리시버를 사용하니까
		즉 코드줄인다고 리시버를 제거하는거보단,좀길더라도 명시적인게 나음
		
		그리고 널에이블을 처리할땐,also나 let를 사용하는게 좋음,apply말고
	
	6.프로퍼티는 동작이 아니라 상태를 나타내야한다
		프로퍼티는 필드와 비슷해보이지만,서로 다른개념임
		프로퍼티는 필드+게터+세터(var일경우)임
		그래서 필드를 기반으로 게터를 커스텀하거나
			get()=field?.toUpperCase()
		아예 다른곳의 값을 기반으로 게터를 만들수있음
			get()="$name is $age"
		즉 필드는 프로퍼티에 있어서 필수요소가 아니라는거
		
		그래서 코틀린은 인터페이스에도 프로퍼티를 설정할수있는거임(게터를 설정하는거)
		
		그리고 프로퍼티는 
			상태를 나타내거나 설정하는목적으로만 사용해야하고,다른로직을 포함하면안됨
			즉 해당행위가 get이나 set이 붙을만해야하고,연산비용이 커선안됨(O(1)보다 크면 다시생각)
			get를 했을때 값이 변하면안됨(내가바꿔도안되고 따로 뭐안했는데 바뀌어도안됨)
			타입캐스팅을 프로퍼티로 만드는건 관습위반임(보통 toInt처럼 함수만들어서쓰니까)
			어떤 합계를 계산한다던가 같은 동작이 들어가면 이건 프로퍼티가 아니라 함수임(O(n))
		그리고 상태를 추출,설정하는건 프로퍼티를 써야지 함수를 사용하면안됨
		
		즉 프로퍼티는 상태집합,함수는 행동을 나타내는게 관습임
	
	7.이름있는 아규먼트를 사용해라
		코드에서 아규먼트의 의미가 명확하지 않아보인다면,명시적으로 해당 아규먼트의 이름을 적어주는게좋음
			abcList.joinToString("|")
			abcList.joinToString(separator="|")
		아니면 그냥 저값을 변수에 담아서 변수이름으로 쓰는거도 괜찮음
			val separator="|"
			abcList.joinToString(separator)
		이렇게 아규먼트에 이름을 붙이는걸,디폴트아규먼트 사용할때만 사용하는게 아닌,가독성도구로 사용할수도 있다는거
		그리고
			디폴트아규먼트가 있을경우엔 항상 이름을 붙여서 사용하는게 좋음
			같은타입의 파라미터가 많을경우 항상 이름을 붙여서 사용하는게 좋음
		추가적으로 함수타입파라미터의 경우 마지막에 배치하는게 좋음,그래야 {}를 사용해서 뽑아낼수있음(특히 함수타입파라미터가 여러개일경우)
		이경우에도 이름있는 아규먼트를 사용하는게 좋음(아니면 엄청햇갈림)
		
	8.코딩 컨벤션을 지켜라
		코딩컨벤션을 맞춰야 어떤프로젝트를 접해도 쉽게 이해할수있고,다른사람도 쉽게 이해할수있음
		그리고 코드병합도 쉬워지고
		
		이걸위해서 ktlink같은 린터를 사용할수있음
		
		추가적으로 자주 어겨지는 컨벤션으론,한 파라미터는 한줄에 하나만
					class Person(val id:int,val name:String)
		이게아닌
			class Person(
				val id:int=0,
				val name:String=""
			)
		이런식으로 해야함
		함수도 좀 길어지면 마찬가지
		
3.재사용성		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		