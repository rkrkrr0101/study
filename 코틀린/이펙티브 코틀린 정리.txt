1.안정성
	1.가변성을 제한하라
		꼭 변경할 이유가 있는곳에만 var을 사용하고,변경할이유가 없으면 val을 사용해야함
		가변성이 있으면 코드실행시 값추론이 어려워지고 멀티스레드에서도 동기화안하면 문제생기고,테스트도 귀찮아지고 문제가 많아짐
		그리고 다른 프로퍼티에 의존하는경우에도
			val fullName
				get()="$name $surName"
		이런식으로 커스텀게터를 사용하는거로 var을 사용하지않고 대체할수있음
		이처럼 val은 변경불가능이 아닌,재할당불가능임
		그리고 val은 스마트캐스트(위에서 if문으로 해당타입검사하면 그거로 자동 캐스팅,보통 널에이블지울떄사용)같은 기능을 사용할수있음
		
		그리고 리스트같은 컬렉션의 경우에도,컬렉션 내부의 값을 변경할수있는 mutable컬렉션과,변경할수없는 immutable컬렉션으로 나눠짐
		즉 var과 val의 선택,mutable과 immutable의 선택으로 총 4가지 경우의수가 있음
		단 immutable의 경우에도,코틀린내부에서 값을 변경하지못하게 막는거라서 억지로 바꾸려고하면 바꿀수있으니 컨벤션으로 이걸못하게해야함
		주로 다운캐스팅으로 이렇게할수있으니 주의
		그리고 mutable과 var을 같이쓰는건 안하는게좋음,두개를 같이쓰면 모호성때문에 사용하지못하는 기능들이 생김(+=같은거 사용불가능해짐)
		
		이런 immutable객체들은 공유해도 충돌이 안나서 병렬처리에 걍박아도되고,캐싱도쉽고(변경이없으니),깊은복사도 안해도됨
		그리고 리스트의경우는 집합이나 맵의 키로 사용할수있음,
		mutable의경우는 불가능함(집합과 맵이 해시를 사용하는데,해시테이블은 처음요소를 넣을떄 값을 기반으로 버킷을 결정하기때문)
		
		이런 immutable객체들을 수정하고싶으면,자신의 일부를 수정한 새로운 객체를 만들어내는 기능이 있어야하는데 이게 copy임
		data를 클래스앞에 붙이면 이런 copy메서드를 만들어줌
		
		변경가능한 객체를 외부에 노출하는건 굉장히 위험함(mutable리스트를 리턴한다던가)
		이러면 얕은복사가 되니 밖에서 값을 바꾸면 안까지 바뀌어버림
		그래서 이걸 리턴해야할땐 이걸 복사해서 리턴해줘야함
		
	2.변수의 스코프를 최소화하라
		변수는 가능한 작은 스코프를 가져야함
		
		프로퍼티보단 지역변수를 사용하는게 좋고,반복문내부에서만 변수가 사용되면,변수를 반복문안으로 넣는게 좋음
		코틀린에서 스코프는 중괄호로 만들어지며,내부에서 외부로만 접근할수있음
		
		이렇게 스코프를 좁게만들면,프로그램을 추적하고 관리하기가 쉬워짐
		코드를 분석할땐 어떤시점에 어떤 요소가 있는지를 알아야하는데,이때 요소가 많아져서 프로그램에 변경할수있는게 많아지면 인지과부하걸림
		추가적으로 스코프가 너무 넓으면,생각하지못한곳에서 변수가 사용될수있음
		
		그리고 변수는,변수를 정의할때 바로 초기화되는게(val abc:String="abc")가장 이상적임
		그리고 여러변수를 한번에 설정해야할땐,구조분해선언을 사용할수있음
		
		그리고 추가적으로,람다의 캡쳐(변수포획)에서도 반복문외부에 있을경우 문제가 생길수있으니 최대한 안에넣는게좋음
		
	3.최대한 플랫폼타입을 사용하지마라
		플랫폼타입은 코틀린말고 자바라이브러리같은데서 생성된 리턴값을 말함
		이경우엔 널에이블인지 아닌지 알수없음
		특히 자바의 제네릭에서 자주 문제가 터짐,특히 리스트와 리스트 내부까지 전부 널검사를 해야함
		거기다 2중리스트일경우 더복잡해짐
		물론 리스트의경우엔 검사메서드가 있지만,이거말고 다른거일경우 너무머리아파짐
		
		이런 플랫폼타입은,만약 자바코드를 수정할수있으면 @NotNull같은거로 표시해두는게 좋고,
		못한다면(라이브러리) 최대한 빨리 널검사를 쳐서 널이 아님을 확정짓고 처리해야함,플랫폼타입을 리턴하는건 금기임
		
	4.inferred타입으로 리턴하지마라
		inferred타입은 타입추론된 타입임
		문제는 이런 타입추론은 정확히 오른쪽에 있는 피연산자에 맞게 설정되어서 타입을 상위타입(인터페이스)으로 올릴수없어짐
		즉 인터페이스를 상속받은 구체클래스로 만들어져서,인터페이스를 상속받은 다른 구체클래스로 변경이 불가능해진다는 문제가 생김
		그러니 리턴값은 추론값이 아닌 명시된타입으로 리턴을 해야함
		
	5.예외를 활용해 코드에 제한을 걸어라	
		확실하게 어떤 형태로 동작해야하는,즉 api에서의 사전조건을 확인할땐 예외를 활용해서 제한을 걸어주는게 좋음
		코틀린에서 코드의 동작에 제한을 걸땐
			require:매개변수의 제한을 걸때 사용(id!=null)
			check:상태와 관련된 동작을 할때 사용(isOpen)
			assert(테스트모드에서만 작동,어떤값이 true인지 확인할수있음)
			return,throw와 같이사용하는 Elvis
		이렇게 사용할수있음
		만약 해당검사가 실패하면,바로 예외를 던짐(일리걸아규먼트익셉션)
			require(id!=null){
				"id is null"
			}
		이렇게 메세지도 넣을수있음
		보통 매개변수테스트는 require을 사용함
		이렇게 제한을 걸면 문서를 값이 잘못들어오는걸 바로 차단하고 예외를 던져서 확인이 쉬워짐
		예상하지못한행동을 하는건 예외를 던지는거보다 굉장히 코스트가 많이드는일임
		그리고 이렇게 제한을 걸면 자동으로 스마트캐스트가 된다는 추가적장점이 있음(보통 널에이블 지워져서 유용할듯,변수를 언팩할떄 유용)
		
		상태를 검사하고싶을땐 check를 사용함
		이건 일리걸스테이트익셉션을 던진다는거말고는 require과 똑같은데,관례상 require는 최상단에 위치하고,
		check는 중단부에서 체크할필요가 있을때 사용함
		
		Assert는 그냥 단위테스트를 약간 보조해주는정도인듯,잘 사용하진 않나봄
		
		그리고 엘비스를 사용해서,해당값이 널일경우 바로 리턴을 한다던가 쓰로우를 한다던가 하는식도,nullable을 벗길때 자주 사용되는 관용적방법임
		이런건 함수앞부분에 넣어서 잘보이게 만드는게 좋음
		
	6.사용자 정의 예외보단 표준예외를 사용하라
		정 해당상황에 사용할만한 예외가 없는게 아니면,최대한 표준라이브러리의 예외를 사용하는게 좋음
			IllegalArgumentException:잘못된 매개변수
			IllegalStateException:잘못된 상태
			IndexOutOfBoundsException:컬렉션의 범위를 넘었음
			ConcurrentModificationException:동시수정을 금지했는데 발생해버렸을때
			UnsupportedOperationException:사용자가 사용하려는 메서드가 현재객체에서는 사용할수없을때(보통은 이런게있으면안됨)
			NoSuchElementException:해당 요소가 존재하지않을때
		이런거로 해결안될때 커스텀예외를 사용하면됨
		
	7.결과부족이 발생하면 null이나 Faulure를 사용
		결과부족이 발생하면(레포지토리에서 뭘 찾았는데 없었거나),널을 반환하거나,널을 반환하기싫으면 실패를 나타내는 sealed클래스를 리턴하는게 좋음
		예외를 반환하는식으로 처리하면,예외는 예외적인 상황이 나왔을때만 사용하는게 좋고,정보를 전달하는용도로 사용되면 안됨
		특히 코틀린의경우 모든예외가 언체크예외라서,저쪽에서 안잡으면 바로 터짐
		
		널을 반환했을경우엔 받는쪽에서 바로 널을 벗겨서 사용하면됨,널이면 분기타고
		보통 추가정보를 반환해야하면 Faulure를 사용하고,아니라면 null을 사용하는식임
		
		보통 
			get()은 반드시 해당값이 있을때,
			getOrNull()은 있을지없을지 모를때,
			getOrDefault()는 있을지없을지모르겠지만 없으면 기본값받고싶을때
		사용함
		즉 get()에선 예외를 터트리는게 맞고,getOrNull에선 null반환하는식
	
	8.적절하게 null을 처리
		null은 값이 부족하다는걸 나타냄
		프로퍼티가 null이라는건 값이 설정되지않았거나,제거되었다는것
		즉 null을 사용할땐 null에 대한 의미가 명확해야함
		
		보통 null을 처리할땐
			?.(안전호출),엘비스,스마트캐스팅등으로 처리
			예외를 던짐
			nullable을 널불가로 바꿈
		3가지 방법으로 처리함
		
		보통 문맥상 널이 나올만하면 처리하고,널이 뜬금없이나오면 예외를 던지거나,널불가로 바꾸는식
		그리고 !!는 진짜 어지간하면 사용하면안됨
		현재 널이 안나오는게 확정되었다고,미래에도 확정된건 아닐수있음
		아예 금지하는게 나음
		
		그리고 널가능해지면 어떻게든 이걸 처리하는비용이 발생하니까,가급적이면 꼭필요하지않으면 널불가로 사용하는게 좋음
		그리고 어떤값이 클래스생성이후 반드시 초기화되면 lateinit나 notNull델리게이트를 사용할수있고
		빈컬렉션대신 null을 리턴하면안됨(의미가 완전히다름)
		nullable enum과 None enum은 완전히 다른의미임,null은 따로처리해야하지만,None는 정의에 없다는뜻
		
		그리고 초기화를 늦게해야할경우에도(반드시 초기화될때),널을 허용하는게 아닌 lateinit를 사용해서 늦은초기화를 걸어버리는게 나음
		이경우엔 해당값이 없을때 해당필드를 건드리면 예외가 발생하지만,애초에 그걸 사용하는게 초기화전에 있다는게 문제라서 상관없음
		이 lateinit는 Int,Long,Double,Boolean같은 기본타입과 연결된타입에선 사용할수없음
		이때는 Delegates.notNull을 사용할수있음
			var abc:Int by Delegates.notNull()
		이런식
	
	9.use를 사용하여 리소스를 닫아라
		필요하지않을때 close로 닫아야하는 리소스들(db관련이나 스트림관련)은 보통 try caych finally로 닫는데
		이경우 finally에선 try가 안된다는문제가 있음
		그래서 use라는 함수가 표준라이브러리에 들어있음
			reader.use{...}
		저안에 넣으면 자동으로 끝나고 알아서 닫아줌(Closeable를 상속받은 모든객체)
		
	10.단위테스트를 만들어라
		단위테스트는 꼭 만들어야함
		단위테스트를 만들면
			개발시점의 빠른피드백(유스케이스확인)
			회귀버그방지
			올바른 아키텍쳐모양이 되는걸 강요(모킹을 안했을때)
		라는 장점이 있음

2.가독성			
	1.가독성을 목표로 설계해라
		코드를 쓰는데보다 읽는데 시간을 더 소모하기때문에,항상 가독성을 염두에두고 코드를짜야함,이러려면 인지부하를 감소시켜야함
		이때 가능하면 해당언어에서만 사용되는 관용구는 한줄당 하나씩만 넣고,if같은 평범한걸 기준으로 짜는게 좋음
		즉 사용빈도가 적은관용구는 코드가 복잡해지고,그런 관용구들을 한문장내에서 조합해서 사용하면 훨씬 더 복잡성이 올라감(1+1=3)
		
		그리고 그냥 명시적으로 툭툭던지는게 나중에 수정하기도 쉬움
		물론 언어특성으로 훨씬 효율적이 되는경우가 있음,즉 저런거를 쓰려면 해당행동을 사용하는데에 명확한 이유가 있어야함
		즉 let를 널제거용도로 사용하는식같은느낌
		
		그리고 사람에따라 가독성에 대한 관점이 다를수있는데,그래도 하면안되는건 있음
			dsl이 아닌곳에서 연산자의미와 맞지않은 연산자오버로딩
			이미있는기능을 다시만들기
		같은거
		
	2.연산자오버로딩을 할때는 의미에 맞게 사용해라
		연산자 오버로딩을 할땐,해당 오버로딩을 할때의 함수명과 같은 행동을 해야함
		a+b와 a.plus(b)는 같은 함수를 부르기떄문에,자기맘대로 이상한거 붙여버리면 다른사람들이 혼란에 빠짐
		
		그리고 애매할땐 infix(중위함수)를 사용해서 확장함수를 사용하거나,톱레벨함수(1급객체로 함수를 만드는것)를 사용하는게나음
		단,dsl의경우엔 무시해도됨
	
	3.Unit?를 리턴하지마라
		이건 Unit으로 tf를 받으려고 이렇게하는데,이건 처음보면 이해하기도어렵고,예측하기 어려운 오류를 만들수있음
		그러니 사용하지않는게좋음
	
	4.변수타입이 명확하지 않은경우 확실하게 지정하라
		진짜로 타입이 명확하지않은경우엔 무조건 타입을 명시해두는게 좋음
		즉
			val num=10 
		이런건 타입추론해도 상관없는데
			val data=getData()
		이런거 타입추론해버리면 뭔지 또 찾아봐야하니까 개귀찮음
		이런건
			val data:UserData=getData()
		이런식으로 명시해두는게 가독성면에서 좋음,그리고 가독성외에도 안전을 위해서도 타입을 지정하는게 낫고(플랫폼타입사용금지와 추론타입으로 리턴금지)
	
	5.리시버를 명시적으로 참조하라
		어디를 참조하는지 명시적으로 알려주는 this같은거를 사용해서,명시적으로 참조하게 하면 가독성에 도움이 됨
		특히 apply,with,run같은걸 사용할때가 대표적임
		리시버가 명확하지않으면 명시적으로 리시버를 적어서 이를 명확하게 해줘야함,아니면 가장 가까운 리시버를 사용하니까
		즉 코드줄인다고 리시버를 제거하는거보단,좀길더라도 명시적인게 나음
		
		그리고 널에이블을 처리할땐,also나 let를 사용하는게 좋음,apply말고
	
	6.프로퍼티는 동작이 아니라 상태를 나타내야한다
		프로퍼티는 필드와 비슷해보이지만,서로 다른개념임
		프로퍼티는 필드+게터+세터(var일경우)임
		그래서 필드를 기반으로 게터를 커스텀하거나
			get()=field?.toUpperCase()
		아예 다른곳의 값을 기반으로 게터를 만들수있음
			get()="$name is $age"
		즉 필드는 프로퍼티에 있어서 필수요소가 아니라는거
		
		그래서 코틀린은 인터페이스에도 프로퍼티를 설정할수있는거임(게터를 설정하는거)
		
		그리고 프로퍼티는 
			상태를 나타내거나 설정하는목적으로만 사용해야하고,다른로직을 포함하면안됨
			즉 해당행위가 get이나 set이 붙을만해야하고,연산비용이 커선안됨(O(1)보다 크면 다시생각)
			get를 했을때 값이 변하면안됨(내가바꿔도안되고 따로 뭐안했는데 바뀌어도안됨)
			타입캐스팅을 프로퍼티로 만드는건 관습위반임(보통 toInt처럼 함수만들어서쓰니까)
			어떤 합계를 계산한다던가 같은 동작이 들어가면 이건 프로퍼티가 아니라 함수임(O(n))
		그리고 상태를 추출,설정하는건 프로퍼티를 써야지 함수를 사용하면안됨
		
		즉 프로퍼티는 상태집합,함수는 행동을 나타내는게 관습임
	
	7.이름있는 아규먼트를 사용해라
		코드에서 아규먼트의 의미가 명확하지 않아보인다면,명시적으로 해당 아규먼트의 이름을 적어주는게좋음
			abcList.joinToString("|")
			abcList.joinToString(separator="|")
		아니면 그냥 저값을 변수에 담아서 변수이름으로 쓰는거도 괜찮음
			val separator="|"
			abcList.joinToString(separator)
		이렇게 아규먼트에 이름을 붙이는걸,디폴트아규먼트 사용할때만 사용하는게 아닌,가독성도구로 사용할수도 있다는거
		그리고
			디폴트아규먼트가 있을경우엔 항상 이름을 붙여서 사용하는게 좋음
			같은타입의 파라미터가 많을경우 항상 이름을 붙여서 사용하는게 좋음
		추가적으로 함수타입파라미터의 경우 마지막에 배치하는게 좋음,그래야 {}를 사용해서 뽑아낼수있음(특히 함수타입파라미터가 여러개일경우)
		이경우에도 이름있는 아규먼트를 사용하는게 좋음(아니면 엄청햇갈림)
		
	8.코딩 컨벤션을 지켜라
		코딩컨벤션을 맞춰야 어떤프로젝트를 접해도 쉽게 이해할수있고,다른사람도 쉽게 이해할수있음
		그리고 코드병합도 쉬워지고
		
		이걸위해서 ktlink같은 린터를 사용할수있음
		
		추가적으로 자주 어겨지는 컨벤션으론,한 파라미터는 한줄에 하나만
					class Person(val id:int,val name:String)
		이게아닌
			class Person(
				val id:int=0,
				val name:String=""
			)
		이런식으로 해야함
		함수도 좀 길어지면 마찬가지
		
3.재사용성
	1.의도적인정보를 반복하여 사용하지마라
		즉 dry를 말하는거임
		같은 이유로 변경하는곳은 한군데여야한다는거
		
		의도적인정보가 반복되어있으면,변경할때 되게힘듬
		그래서 한군데로 묶고,그걸 참조하는식으로 사용해야함
		단,비슷하게 생겼다고 다 줄이면 안됨
		문맥상 같은흐름인경우,즉 같은이유로 변경될 가능성이 높은애들만 추출하고,다른이유로 변경될수있는애들은 따로둬야함
		이걸 구분하는방법은,비즈니스규칙이 다른곳으로부터 온애면 다른이유로 변경될가능성이 큼(애트리거트)
		
		코드를 추출해도되는지 확인할수있는 원칙으로는 단일책임원칙이 있음
		이건 클래스를 변경하는이유는 단 한가지여야 한다라는 의미임
		즉 두 액터(서로의 영역에대해 모르는 두명이상의 개발자)가 같은클래스를 수정하는일을 없어야함
		그래서 보통은,중앙클래스를 만들고,자기쪽에서만 사용하는건 확장함수를 통해 자기쪽에만 만들어서 사용하는패턴을 코틀린에선 주로사용
		
	2.일반적인 알고리즘을 반복해서 구현하지마라
		이미 기본라이브러리에 있는 함수를 직접 구현하지말고,stdlib정도는 한번 보고 뭐있는지정도는 알아두자
		직접만들면 잘못만들수도있고,만드는데 시간도 걸리고 여러모로 안좋음
		
		그리고 거기없는 알고리즘이 필요할경우에도,확장함수로 구현하는게 좋음(이러면 자동완성으로 띄워주니까)
		
	3.일반적 프로퍼티패턴은 프로퍼티위임으로 만들어라
		지연초기화나(by lazy),객체가 직접 처리하지않고 다른친구한테 그 작업을 시키고싶을땐 by를 사용해서 위임을 할수있음
		즉 게터에 직접 그 객체의 메서드나 함수를 호출하는것과 같은데,by를 써서 글자수가 줄고,따로 예외처리도 걔한테 맞기는거임
		
		이걸사용하면 변화가있을때 감지하는 옵저버패턴도 쉽게만들수있음
		뷰,리소스바인딩,의존성주입,데이터바인딩들도 쉽게처리할수있음
		따로 로깅같은거 할때도,함수에서 <T>를 받게해서 그냥 출력해주면될거고
		
		직접 만들지않더라도 stdlib에서
			lazy //지연초기화
			Delegates.observable
			Delegates.vetoable
			Delegates.notNull
		이정도는 알아두는게 좋음
		
	4.일반적인 알고리즘을 구현할때 제네릭을 사용하라	
		아무거나 다받아먹을수있는,제네릭을 사용한 함수를 제네릭함수라고 부름
		이때 타입파라미터에서,제네릭을 써도 콜론을 써서 타입을 제한걸수있음(해당타입의 하위타입만 들어올수있게)
			fun<T:Comparable<T>> abc(){}
		이렇게 제한을 걸면,내부에서 해당 슈퍼타입의 메서드를 사용할수있어짐(보장이 되니까)
		많이 사용하는거로 Any가 있음,널거르기위한목적
		
	5.타입파라미터의 섀도잉을 피하라
		섀도잉은,프로퍼티와 파라미터가 같은이름을 가지는것
		즉 외부스코프와 내부스코프가 같은이름을 가지는것임(제네릭에서의 T같은경우도,클래스레벨과 메서드레벨에서 독립적이려면 이름을 바꾸는게좋음)
		이런건 헷갈리니까,독립적인 타입파라미터를 의도했으면 아예 이름을 다르게 하는게좋음
		
	6.제네릭타입에서 변성을 사용해라(이해못했음)
		제네릭에서 out과 in을 사용해서 공변성(out)과 반공변성(in)을 넣을수있음
		공변성은 A가 B의 서브타입일때, Cup<A>가 Cup<B>의 서브타입이라는것
		반공변성은 A가 B의 서브타입일때 Cup<B>가 Cup<A>의 서브타입이라는것
		만약 변성을 사용하지않으면,서로 아무관계가 없는거로 취급됨
		
		이런건,int리스트에 double를 넣고싶다던지 할때 자동으로 업캐스팅을 해주기떄문에 유용함(out)
		out는 리턴에,in은 파라미터에 붙이면됨
		
	7.공통모듈을 추출해서 여러 플랫폼에서 재사용하라
		코틀린을 사용하면,서버와 브라우저의 언어를 통일시킬수있으니(코틀린js),공통라이브러리를 만들수있음
		비즈니스로직 즉 도메인을 순수하게 분리해버리고 이걸 재사용할수있다는것
		
4.추상화 설계
	1.함수내부의 추상화레벨을 통일해라
		해당지점마다의 계층분리는 확실히 되어야함
		즉 그 지점을 작업할때,그 계층만 생각하면되도록 만들어야함
		꼭 레포서비스컨트롤러같은게 아니라도,클래스 내부에서의 메서드들이 같은급에서 놀아야함
		커피머신클래스에서,모든걸 대표하는 커피만들기함수는 다른메서드들을 조합하는 역할만 하고,
		물끓이기,커피따르기,우유따르기등등의 메서드들은 같은급에서 동작해야한다는것
		
		즉 함수는 이름만보고 이해하기쉽고,최소한의 책임만 가져야함
		어떤함수가 다른함수보다 복잡하면 일부부분을 추출해서 추상화하는게 좋음
		이렇게하면 나중에 재사용도 쉽고,단위테스트도 편해짐
		
	2.변화로부터 코드를 보호하려면 추상화를 사용하라
		함수나 클래스등의 추상화로 실제코드를 숨기면,사용자는 세부사항을 몰라도되고,수정에있어서 사전조건 사후조건만 지켜주면 부담없음
		이런 추상화로는,
			상수(const):특정 숫자같은거에 이름을 부여해서 보기쉽게하고,중복을 제거할수있음
			함수:어느 한곳에 특화된 함수들을 묶어서 더 큰단위로 추상화를 걸어버리면,유지보수성이 증가함,이떄는 이름을 잘붙여야함
			클래스:함수가 좀 커졌다싶으면 클래스로 떼버리는게 좋음,클래스는 상태를가질수있고 여러함수를 가질수있고,di하기쉽고,모킹해서테스트도 쉬움
			인터페이스:가장 메인이되는 추상화,즉 타입의 입력과 출력들을 명시해서,해당추상화를 가져간애면 반드시 있다는걸 명시해줌
				클래스(구현)는 인터페이스(추상화)뒤로 숨겨야함
				특히 코틀린은 여러언어에서사용되기때문에,각 언어마다 최적화를 다르게해줌
			보편적객체를 특수객체로 래핑:코드조각을 래핑해서 좀 더 안전하게 변경할수있게 묶는게 좋음
		가 있음
		
		이렇게 추상화를 할때 사용할수있는 도구로는
			제네릭
			내부클래스추출
			생성제한(팩토리로만 생성하게하는거처럼)
		등이 있음
		근데 추상화는 자유를 주지만,코드를 이해하고 수정하기는 어려워진다는 단점이 있음
		즉 추상화는 비용이 발생함
		그래서 너무 추상화를 안해도안되고,너무 많이해도 안됨
			
	3.api안정성을 확인하라		
		api는 최대한 안정적이고 표준적이어야함
		그래서 메이저 마이너 패치로 버전을 붙여서 관리하는것
		그리고 처음 api에 뭘 추가할땐,실험적인(@Experimental)태그를 붙여두는게 좋음
	
	4.외부api를 랩해서 사용하라
		외부api를 신뢰할수없을경우,해당api를 래핑해서 변경에 쉽게 대응할수있음
	
	5.요소의 가시성을 최소화하라
		사람들이 쓰고있던 api를 작게하거나 프라이빗처리하기 어려우니,처음부터 최대한 작게 노출되게 만들어야함(자기가쓸곳에만 노출되게)
		그리고 인터페이스가 작을수록 이렇게하기가 쉬워짐
		그리고 세터같은건 최대한 못쓰게막아야하고(프라이빗처리)
		그리고 dto의경우엔,쓸데없어진건 걍 지워버리면됨
		
		추가적으로,api를 상속할때 오버라이드해서 가시성을 제한할순없음(퍼블릭인걸 프라이빗으로 못바꿈),서브클래스가 슈퍼클래스로 사용될수있기때문
		이게 상속보단 합성을 쓰는 대표적인 이유임
			
	6.문서로 규약을 정의하라		
		사전조건 사후조건 불변식은 문서화가 되어있어야함
		그래야 만드는사람 쓰는사람 둘다 편함
		
		보통 문서화에는 주석을 쓰거나,따로 어노테이션같은거로 뺄수있음(스웨거같은거)
		그리고 주석을쓸땐 Kdoc마크다운을 사용할수있는데,이건 찾아보자
		
		그리고 타입에 관한 타입계층도 문서화가 되어있어야함
		클래스가 어떤동작을 할거라고 예측되면,서브클래스도 그걸 보장해야함(리스코프치환원칙)
			
	7.추상화 규약을 지켜라	
		규약은 단순한 합의라서,한쪽에서 위반할수도 있음
		일례로,리플렉션을 쓰면 모든제약을 제거할수있음
		물론 이렇게하면 절대안됨
		
		그리고 클래스를 상속하거나,다른 라이브러리의 인터페이스를 구현할땐 규약을 반드시 지켜야함
		대표적으로  equals와 hashCode가 있음(Any로부터 나온거)
			
			
5.객체생성			
	1.생성자대신 팩토리함수를 사용하라
		팩토리패턴으로 생성을 하면
			생성자와 다르게 생성패턴에 이름을 붙일수있고,아규먼트의 설명도 가능함
			함수가 원하는 형태의 타입을 리턴할수있음,즉 다른객체를 생성할수도있음(같은인터페이스의)
			호출할때마다 새 객체를 만들필요가 없음
			아직 존재하지않는 객체를 리턴할수있음(어노테이션처리에서 많이 사용)
			가시성설정이 자유로움(특정위치에서만 보이게)
			생성자로 만들기 복잡한객체도 만들수있음
			기본생성자나 슈퍼클래스호출을 즉시할필요가 없음(원할때호출가능)
		단 서브클래스생성엔 슈퍼클래스의 생성자가 필요하기때문에,서브클래스를 만들어낼수없음
		그래서 이경우엔 서브클래스에도 팩토리함수를 만들면됨
		
		이 팩토리함수는 기본생성자와 싸우는게아닌,세컨더리생성자와 경쟁관계임
		
		팩토리함수를 정의하는 가장일반적인방법은 companion을 사용하는것
			companion object{...}
		이거쓰는거
		즉 정적팩토리함수랑 똑같은방식임
		코틀린에선 이걸 인터페이스에도 구현할수있음
		여기에서 팩토리의 이름관례는
			from:파라미터를 하나받아서 같은타입의 인스턴스를 하나 리턴하는 타입변환함수
			of:파라미터를 여러개받아서 이걸 합쳐서 인스턴스를 만들어줌
			valueOf:from이나 of와 비슷한기능인데,좀 더 쉽게읽어지게만듬
			instance,getInstance:싱글톤으로 인스턴스하나를 리턴함,
				파라미터가 있으면 파라미터기반으로하는 인스턴스를 리턴함(파라미터가 같으면 같은인스턴스리턴)
			createInstance,newInstance:인스턴스하나를 리턴함(싱글톤이아님),즉 매번 새인스턴스를 만들어서 리턴
			get타입명:getInstance처럼 동작하지만,팩토리함수가 다른클래스에 있을때
			new타입명:newInstance처럼 동작하지만,팩토리함수가 다른클래스에 있을때
		이렇게 있음
		
		이 companion은 단순 정적멤버처럼 쓸수도있지만,얘는 인터페이스를 구현할수있고 클래스를 상속받을수도있음
			companion object:ActivityFactory(){}
		그리고 추상 companion객체팩토리는 값을 가질수있음
		그래서 캐싱을 구현하거나 테스트용 가짜객체생성을 할수있음
		
		그리고 companion을 확장함수로 정의해서 사용할수도 있음
			fun abc.Companion.함수명():리턴값{}
		이런식으로 생성하고
			abc.함수명()
		으로 호출
		단 이렇게 하려면,컴패니언객체가 인터페이스안에 있어야함
		
		톱레벨함수로 팩토리만드는건,남용하면 IDE넘복잡해지니까 이름을 잘지어야함(모든곳에서 접근가능하니)
		
		톱레벨함수를 생성자처럼 보이게할수도 있음,이걸 가짜생성자라고 부름
		이건
			인터페이스를 위한 생성자를 만들고싶을때
			reified타입 아규먼트를 갖게하고싶을때
		사용됨
		이 가짜생성자는 진짜생성자처럼 동작해야함,생성자처럼 보여야하고,생성자와 같은동작을 해야함
		캐싱,널에이블리턴,서브클래스리턴들을 포함해서 객체를 만들고싶으면 companion을 사용하는게 나음
		
		팩토리클래스(특정클래스를 생성하는 다른클래스)에서 점층적 생성자패턴과 빌더패턴은 코틀린에서 사용되지않음
		팩토리클래스는 프로퍼티를 가질수있음
		그래서 캐싱을 사용하거나 이전객체를 복제해서 객체를 생성하는방법으로 객체생성속도를 올릴수도있음
		
	2.기본생성자에 이름있는 옵션 아규먼트를 사용하라
		보통 가장 편하게 객체를 생성하는건 기본생성자를 사용하는것
		이때,디폴트값으로 초기화되든 내가넣어서 초기화하든 보통은 초기화만 되면 별 문제가 없음
		
		점층적생성자패턴은 여러종류의 생성자를 사용하는걸 말함(코틀린에선 그냥 constructor이 여러개있는거)
		코틀린에선 사용하지않고,디폴트아규먼트를 사용함
		이러면 아규먼트의 이름도 사용할수있고,생성자도 하나로 줄일수있고,순서변경도 자유로움
		자바에선 네임드파라미터와 디폴트아규먼트가 없어서,빌더패턴을 사용함
		빌더패턴은
			pizza.Builder().size("L").setTomato(True).Build()
		이런식으로 클래스내에 빌더클래스를 만들고,그안에서 생성하는 패턴임
		이거의 장점은 파라미터에 이름을 붙일수있다는건데,코틀린에선 이름을 그냥붙일수있으니 안쓰는거
		물론 값의 의미를 묶어서 사용할수있다는것과,특정값을 누적하는형태로 사용할수있다는 장점이 있어서 제한적으로 사용되긴함
		근데 이경우에도 dsl빌더를 사용해서 포지션이 애매한듯
		
	3.복잡한 객체를 생성하기 위한 dsl을 정의하라	
		dsl은 복잡한객체,계층구조를 가진 객체들을 만들때 굉장히 편함
		이건 만들기가 좀 힘들긴한데,만들고나면 보일러플레이트와 복잡성을 숨기면서 의도를 명확히 표현할수있음
			button("abc"){
				onClick{toast("Hello")}
			}
		이런식으로 사용하면되니까
		
		이걸 만들땐,리턴값으로 함수타입((Int)->Unit같은)을 리턴해줘야함
		필요해지면 보자
		
		dsl은 복잡한 자료구조,계층적구조,거대한양의 데이터를 표현할때 사용됨
		보통은 가져다가쓰고 만드는일은 잘없음
		
		
6.클래스 설계		
	1.상속보다 컴포지션(합성)을 사용해라
		상속은 서브타이핑용도로만 사용하고,서브클래싱용도로는 합성을 사용해야함
		즉 재사용이나 코드추출용도로는 합성이 맞음
		
		상속을 서브클래싱용도로 사용하면,많은함수를 갖는 거대한 베이스클래스를 만들게되고,굉장히 계층구조가 복잡해짐
		그리고 클래스의 모든걸 가져오니 인터페이스분리원칙 위반
		이해하기도 어려움
		
		그래서 합성을 사용하는것
		공통부분을 외부클래스로 뺀다음,해당클래스의 인스턴스를 생성해 사용하는식임
		이러면 이해하기도 쉽고,재사용도 편하고,명확해짐
		그리고 상속은 하나이상의 클래스를 상속할수없는데,합성은 여러개 그냥 합성시켜도되고,
		인터페이스 분리원칙도 필요없고,리스코프치환원칙도 적용안되니 필요한거만 빼다쓰면됨
		
		합성을 쓸땐 문제가 하나있긴한데,다형성이 사라진다는것
		그래서 다형성을 유지하고싶으면 위임패턴(by)를 사용할수있음
		이걸 포워딩메서드라고함
			class 클래스명(생성자):MutableSet<T> by innerSet{}
		이런식으로하면,기본적으로 innerSet을 전부 들고오고,오버라이드해서쓸수있음
		
		상속은 허용하는데 메서드오버라이드를 막고싶으면 클래스와 메서드앞에 open을 붙이면됨
			open class 클래스명{
				open fun a(){}
			}
		이러면 오픈이붙은 메서드만 오버라이드할수있음
		
		상속은 명확한 is-a관계일때만 사용해야함
		즉 슈퍼클래스로 동작하던건 서브클래스로 동작해야함(슈퍼클래스의 모든 단위테스트는 서브클래스로도 통과해야함)
		
	2.데이터집합표현에 data한정자를 사용하라
		데이터를 한번에 전달해야하면 클래스에 data를 붙이면,투스트링이나 카피같은게 자동으로생김
		카피는 얕은복사를 하지만,이뮤테이블이라서 상관없음(변경을안하니)
		
		그리고 객체분해로 값꺼낼땐,데이터클래스의 기본생성자에 붙어있는 프로퍼티이름과 같은이름으로 꺼내야함(순서틀리면 ide가 경고날려줌)
		
		튜플은 코틀린에선 거의사용하지않고,그역할을 데이터클래스가 대신함
			메서드의 리턴타입이 명확해지고
			리턴타입이 짧아지고 전달하기도 쉽고
			데이터클래스와 다른이름으로 분해하면 경고도 날려줌
		그래서 튜플은 잘 사용하지않음
			
	3.연산또는 액션을 전달할땐 인터페이스대신 함수타입을 사용하라
		다른언어에선 함수타입이라는 개념이 없어서,보통 인터페이스를 만들고 그 인터페이스를 구현한 객체를 전달받음(SAM)
		그 온클릭같은거에서 리스너받는식
			fun setOnClickListener(listener:OnClick){
				...
			}
			setOnClickListener(object:OnClick{
				override fun clicked(view:View){
					...
				}
			})
		이걸 함수타입코드로 변경하면 엄청편해짐
			fun setOnClickListener(listener:(View)->Unit){
				...
			}
			setOnClickListener{...}
			setOnClickListener(this::showUsers)
		이렇게 람다로 바로던져버리던가,함수로 던질수있음
		그리고 타입별칭을 사용하면 함수타입도 이름을 붙일수있음
			typealias OnClick=(view:View)->Unit
		
	4.태그클래스보단 클래스계층을 사용하라
		태그클래스는 두가지이상의 기능을 가지면서,그중 하나를 선택하는 필드가 있는 클래스를 말함
		즉,비슷한 여러클래스를 합쳐두고 그중 하나를 선택해서 사용하는식으로 사용하는것
		이러면 서로 다른책임이 한클래스에서 태그로 구분되니까,
			여러모드를 처리하기위한 보일러플레이트가 많이생김
			여러목적으로 사용해야하니 프로퍼티가 일관적이지 않게 사용됨
			팩토리메서드를 사용해야하는경우가 많음
		이런단점들이 있음
		
		이렇게 단점이 많아서,코틀린에선 sealed클래스를 많이사용함
		이건 각각의 모드를 sealed클래스 내부의 클래스로 분리하고,타입시스템과 다형성을 활용하는식
		보통 자바에선 abstract를 사용해서 이런식으로 구현함
		
		sealed를 사용하면,외부에서 서브클래스를 생성할수없으니 when을 쓸때 else를 넣을필요가없음
		when은 모드를 구분해서 다른처리를할때 굉장히 편리함
		그냥 어떤처리를 각각의 서브클래스에 구현할필요없이,when을 활용하는 확장함수로 정의하면 한번에 구현가능해짐(sealed에서만 가능)
		
		태그클래스와 상태패턴은 다름,상태패턴은 한번생성되고나서 상태가 바뀌는거고,태그클래스는 첫생성자에서 생성하고 값이변하지않음
		
	5.equals의 규약을 지켜라
		코틀린의 any에는 equals과 hashCode,toString이 있음
		any에 이게 들어있기때문에,모든 클래스들은 이 규약을 지켜야함
		
		equals는,구조적 동등성(==)과 레퍼런스적 동등성(===) 둘중 하나를 선택할수있음
		equals는 모든객체에서 사용할수있지만,다른타입의 두 객체를 비교하는건 허용되지않음(연산자를 사용해서,함수명으로 콜은 가능)
		물론 같은타입이거나,둘이 상속관계일경우엔 가능함
		
		equals의 기본값은 ===임
		근데 ==처럼 동작해야하는경우도 있는데,보통 data를 붙이면 ==로 자동으로 바꿔줌
		추가적으로 일부프로퍼티만 비교해야할때도 equals을 오버라이딩할수있음
		데이터클래스에서도 뭐 따로안쓰고 가능한데,기본생성자에만 비교할걸 넣어두고,필드로 비교하지않을값을 넣어두면 자동으로 만들어줌
		참고로,이럴땐 기본생성자에 선언되지않은 프로퍼티는 data에서 복사해주지않음
		
		보통 그래서 equals를 직접구현할필요가 없는데,진짜 가끔 id값만 가지고 비교하고싶다던가 하면 구현할때가 있긴함
			기본동작과 다른동작을 해야하거나
			일부프로퍼티만 비교해야하거나
			data붙이기싫거나 비교할프로퍼티가 기본생성자에 없거나
		한경우임
		
		이경우엔 이걸 만족해야함
			널이아니면 자기자신이퀄은 T여야함
			x==y와 y==x의 값은 같아야함(다른클래스의경우에 많이터짐,다른클래스는 F뜨게만드는게좋음)
			x,y,z 가 같을경우 x=z도 같아야함(이거도 다른타입일때 많이터짐,시간에서 day만 있는거랑 day hour이 있는 이런거)
			x==y는 여러번해도 똑같아야함(time쓸때 주의)
			x가 널이아니면,x==null은 false여야함
			빠르게 동작해야함
		이런 규칙을 만족해야함
		어지간하면 구현안하는게 낫고,이런클래스는 파이널로 만들어야함
		
	6.hashCode의 규약을 지켜라
		해시코드는 해시테이블을 구축할때 사용됨
		
		이 해시코드의 규약은
			어떤객체를 변경하지않으면,해시코드를 여러번호출해도 결과가 같아야함
			이퀄의 결과로 두 객체가 같다고나오면,해시코드의 호출결과도 같아야함
		그래서 보통 equals이나 리스트의 요소찾을때 해시테이블을 사용해서,이퀄을 오버라이딩하면 해시코드도 같이 오버라이딩해야함
		
		추가적으로 해시코드는,최대한 요소를 넓게 퍼트려야 효율적으로 동작함
		보통 이퀄을 오버라이딩할때말곤 오버라이딩할 필요도없고 해서도안됨
		
	7.compareTo의 규약을 지켜라
		이건 부등호(>=<)임
		여기의 규약은
			a>=b이고 b>=이면 a==b여야함(이퀄과 동등성비교는 관계가있어야하고,일관적이어야함)
			a>=b이거 b>=c면 a>=c여야함
			a>=b 혹은 b>=a중 둘중 하나는 참이어야함
		보통 이걸 따로 정의할일은 없음
		
	8.api의 필수적이지 않은부분을 확장함수로 추출하라
		클래스의 메서드로 정의하든,확장함수로 정의하든 거의비슷한데,가장 큰 차이점은 확장함수는 따로 가져와서 사용해야한다는것(보통 다른패키지)
		그래서 같은이름으로 여러개 만들수있다는 장점이 있고,위험성도있음
		위험가능성이 있으면 멤버함수로 만드는게 나음
		
		또다른 차이점으로 오버라이드할수없다는것
		추가적으로는,클래스가 아닌 타입에 정의하는거라서 널에이블이나 제네릭에도 확장함수를 정의할수있음
			public fun Iterable<Int>.sum():Int{}
			inline fun CharSequence?.isNullOrBlank():Boolean{}
		이런거도 가능
		
		즉 좀 더 자유로워지는대신,혼동올수가 있음
		필수적인건 멤버로,필수적이지 않은건 확장함수로 넣는게 보통 맞음
		
	9.멤버확장함수의 사용을 피해라
		어떤 클래스에대한 확장함수를 정의할떄,이를 멤버로 추가하는건 좋지않음
		즉 클래스 내부에서 다른 클래스에 대한 확장함수를 넣으면 안됨
		보통 이런건 가시성제한때문에 이러는데,그러려면 그냥 private를 붙이는게나음
		
		즉 확장함수는 클래스랑 같은급으로 있어야지,
			어디 안에 들어있으면 쓰기도힘들고,
			레퍼런스도 지원하지않고,
			암묵적접근도 혼란스럽고,
			다른클래스가 합성했을때,도대체 어떻게동작할지 예상이안감(B클래스 안에있는 A의 업데이트멤버확장함수같은거)
		이걸 사용하는게 큰 의미가 있을땐 어쩔수없는데,가능하면 안쓰는게좋음
		어짜피 멤버함수로 해놔도 외부에서 접근이 가능해짐
		
		
7.비용줄이기		
		
		
		
		
		
		
		
		
		
		
		