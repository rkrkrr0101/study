1.코틀린코루틴을 배워야하는 이유
  1.안드로이드에서 코루틴사용
	코루틴대신 사용할수있는것들은
		스레드전환:블로킹이 가능한 스레드를 먼저 사용하고,이후 메인스레드로 전환
		  단점:
		    스레드가 실행되면 멈출수없어서 메모리누수될수있음
			스레드를 많이생성하면 비용이 많이듬
			스레드를 자주 전환하면 복잡도가 올라가고 관리가 어려움
			코드가 쓸데없이 길어지고 이해가 어려움
		콜백:함수를 논블로킹으로 만들고,함수작업이 끝나면 호출될 콜백함수 넘겨주기
		  단점:
		    중간에 작업취소 어려움
			데이터소스가 여러곳일경우,동시처리어려움
			콜백지옥
			작업의 순서다루기가 어려움
		rxJava,리액티브스트림:데이터스트림내에서 일어나는 모든연산을 시작,처리,관찰 가능
		  단점:
		    콜백보다 모든면에서 낫지만,구현이 복잡함
	들이 있음,위에서 밑으로 내려갈수록 최신이고,좋음
	
	코틀린 코루틴의 핵심은 코루틴을 특정지점에서 멈추고 이후에 재개할수있다는것
	이거로 우리가 짠 코드를 메인스레드에서 실행하고,api로 데이터를 얻어올때 잠깐 중단시킬수도 있음
	코루틴을 중단시켰을때 스레드는 블로킹되지않고,뷰를 바꾸거나 다른 코루틴을 실행하는등의 또 다른 작업이 가능함
	데이터가 준비되면 코루틴은 메인스레드에서 대기하고있다가,메인스레드가 준비되면 멈춘지점에서 다시 작업을 수행함
	
	코루틴의 코드는 메인스레드에서 실행되지만,스레드를 블로킹하진않음
	코루틴의 중단은 데이터가 오는걸 기다릴때 코루틴을 잠시 멈추는방식으로 작동하고,이때 멈춰있는동안 메인스레드는 다른작업을 할수있음
	데이터가 준비되면 코루틴은 다시 메인스레드를 할당받아 이전에 멈춘지점부터 다시 시작함
	
	사실 코루틴자체는 async await와 큰차이없고,동작자체도 똑같음
		fun abc(){
			val user=async{user.getUser()}
			val prodect=async{pro.getProdect()}
			...(중간작업들)
			print(user.await(),prodect.await())
		}
	이러면 async를 먼저 다 날려두고,다른작업들을 처리하다가 await를 만나면 값이 들어왔는지 확인하고,
	안들어왔으면 다 들어올때까지 다른작업하다가 다 들어오면 처리하는느낌임
	
	또한 코틀린 코루틴은 for문을 논블로킹으로 처리하기같은 이런일을 할때 효과적임
	
  2.백엔드에서의 코루틴사용
	백엔드에서 코루틴을 사용할때 가장 큰 장점은 간결성임
	rxJava와 다르게 코루틴은 코드의 변화를 거의 주지않을수있음
	단순히 suspend제어자를 함수에 추가하는것만으로 충분함
	
	또한 스레드에 비해 비용이 싸다는 장점도 있음


2.시퀸스 빌더
    파이썬이나 자바스크립트는 제한된 형태의 코루틴을 사용함
		비동기함수(async,await)
		제너레이터함수(값을 순차적으로 반환하는 함수)
	코틀린에서는 비동기함수는 지원하고,제너레이터 대신 시퀸스를 제공함(그 컬렉션시퀸스같은거 맞음)
	
	시퀸스는 컬렉션과 비슷한개념이지만,필요할때마다 값을 하나씩 계산하는,lazy하게 동작함
	이건 요구되는 연산을 최소한으로 수행할수있고,메모리사용이 효율적이라는 장점이 있음(시퀸스가 없으면 중간리스트가 생기는데,저거쓰면 하나씩처리하니까)
	
	시퀸스자체로 동작을 시킬때는,제너레이터처럼 1순회 돌때마다 yield가 있는 위치까지 돌린후,그뒤에는 그위치부터 시작함
	
	시퀸스는 피보나치나 난수,임의의문자열들을 생성할때도 사용할수있음
	시퀸스빌더를 사용할때 주의점은,yield대신 중단함수를 사용하면 안된다는것
	중단이 필요하다면 시퀸스대신 플로우를 사용하는게 더 나음(전반적으로도 플로우가낫긴한듯)

3.중단은 어떻게 작동할까
























