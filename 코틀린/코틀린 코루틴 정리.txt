1.코틀린 코루틴 이해하기
1.코틀린코루틴을 배워야하는 이유
  1.안드로이드에서 코루틴사용
	코루틴대신 사용할수있는것들은
		스레드전환:블로킹이 가능한 스레드를 먼저 사용하고,이후 메인스레드로 전환
		  단점:
		    스레드가 실행되면 멈출수없어서 메모리누수될수있음
			스레드를 많이생성하면 비용이 많이듬
			스레드를 자주 전환하면 복잡도가 올라가고 관리가 어려움
			코드가 쓸데없이 길어지고 이해가 어려움
		콜백:함수를 논블로킹으로 만들고,함수작업이 끝나면 호출될 콜백함수 넘겨주기
		  단점:
		    중간에 작업취소 어려움
			데이터소스가 여러곳일경우,동시처리어려움
			콜백지옥
			작업의 순서다루기가 어려움
		rxJava,리액티브스트림:데이터스트림내에서 일어나는 모든연산을 시작,처리,관찰 가능
		  단점:
		    콜백보다 모든면에서 낫지만,구현이 복잡함
	들이 있음,위에서 밑으로 내려갈수록 최신이고,좋음
	
	코틀린 코루틴의 핵심은 코루틴을 특정지점에서 멈추고 이후에 재개할수있다는것
	이거로 우리가 짠 코드를 메인스레드에서 실행하고,api로 데이터를 얻어올때 잠깐 중단시킬수도 있음
	코루틴을 중단시켰을때 스레드는 블로킹되지않고,뷰를 바꾸거나 다른 코루틴을 실행하는등의 또 다른 작업이 가능함
	데이터가 준비되면 코루틴은 메인스레드에서 대기하고있다가,메인스레드가 준비되면 멈춘지점에서 다시 작업을 수행함
	
	코루틴의 코드는 메인스레드에서 실행되지만,스레드를 블로킹하진않음
	코루틴의 중단은 데이터가 오는걸 기다릴때 코루틴을 잠시 멈추는방식으로 작동하고,이때 멈춰있는동안 메인스레드는 다른작업을 할수있음
	데이터가 준비되면 코루틴은 다시 메인스레드를 할당받아 이전에 멈춘지점부터 다시 시작함
	
	사실 코루틴자체는 async await와 큰차이없고,동작자체도 똑같음
		fun abc(){
			val user=async{user.getUser()}
			val prodect=async{pro.getProdect()}
			...(중간작업들)
			print(user.await(),prodect.await())
		}
	이러면 async를 먼저 다 날려두고,다른작업들을 처리하다가 await를 만나면 값이 들어왔는지 확인하고,
	안들어왔으면 다 들어올때까지 다른작업하다가 다 들어오면 처리하는느낌임
	
	또한 코틀린 코루틴은 for문을 논블로킹으로 처리하기같은 이런일을 할때 효과적임
	
  2.백엔드에서의 코루틴사용
	백엔드에서 코루틴을 사용할때 가장 큰 장점은 간결성임
	rxJava와 다르게 코루틴은 코드의 변화를 거의 주지않을수있음
	단순히 suspend제어자를 함수에 추가하는것만으로 충분함
	
	또한 스레드에 비해 비용이 싸다는 장점도 있음


2.시퀸스 빌더
    파이썬이나 자바스크립트는 제한된 형태의 코루틴을 사용함
		비동기함수(async,await)
		제너레이터함수(값을 순차적으로 반환하는 함수)
	코틀린에서는 비동기함수는 지원하고,제너레이터 대신 시퀸스를 제공함(그 컬렉션시퀸스같은거 맞음)
	
	시퀸스는 컬렉션과 비슷한개념이지만,필요할때마다 값을 하나씩 계산하는,lazy하게 동작함
	이건 요구되는 연산을 최소한으로 수행할수있고,메모리사용이 효율적이라는 장점이 있음(시퀸스가 없으면 중간리스트가 생기는데,저거쓰면 하나씩처리하니까)
	
	시퀸스자체로 동작을 시킬때는,제너레이터처럼 1순회 돌때마다 yield가 있는 위치까지 돌린후,그뒤에는 그위치부터 시작함
	
	시퀸스는 피보나치나 난수,임의의문자열들을 생성할때도 사용할수있음
	시퀸스빌더를 사용할때 주의점은,yield대신 중단함수를 사용하면 안된다는것
	중단이 필요하다면 시퀸스대신 플로우를 사용하는게 더 나음(전반적으로도 플로우가낫긴한듯)

3.중단은 어떻게 작동할까
	중단은 코루틴의 핵심임
	중단이란 실행을 중간에 멈추는것,실행을 멈추고 다른일을 하다가 다시 해당작업을 수행할수있음
	코루틴은 중단되면 Continuation객체를 반환함,이건 세이브포인트고,이걸 사용해서 멈췄던곳에서 다시 코루틴을 실행할수있음
	
	여기서 스레드와의 차이가 나타나는데,스레드는 저장이 불가능하고 멈추는것만 가능하고,코루틴은 중단됐을때 어떤 자원도 사용하지않고,
	다른스레드에서 시작할수있고,컨티뉴에이션 객체는 직렬화와 역직렬화가 가능하고,다시 실행될수있음
	
  1.재개
	작업을 재개하려면 코루틴이 필요하고,코루틴은 runBlocking나 launch와 같은 코루틴빌더를 통해 만들수있음
	중단함수는 말그대로 코루틴을 중단할수있는 함수고,이는 중단함수는 반드시 코루틴,혹은 다른 중단함수에 의해서 호출되어야함을 의미함
	즉 중단함주는 중단할수있는곳이 필요함
	
	코틀린은 코루틴내부에서 suspend가 붙은 main함수를 실행하고,중간에 중단될경우(suspendCoroutine),
	인자로 들어간 람다함수가 중단되기직전에 실행되고,이 함수는 컨티뉴에이션객체를 인자로 받음
	
	즉 중단된 이후에는 컨티뉴에이션 객체를 사용할수없기때문에,실행이 끝나기전에 람다함수로 끼어들어가서 사용하는것
	즉 람다함수에는 재시작을 위한 로직을 넣을수있음
	
	또한 suspendCoroutine에서는 잠깐동안 정지된뒤 재개되는 다른 스레드를 실행할수도있음
	즉 정해진시간뒤에 코루틴을 다시 재개하는 함수를,다른 스레드를 써서 만들수있다는거
	보통은 이렇게 직접하지않고 알람라이브러리,ScheduledExecutorService를 사용하긴하지만 동작원리자체는 같음
	이걸 코틀린코루틴에서 만들어둔게 delay함수임
	
	즉 일정시간이 지나면 continuation.resume(Unit)를 호출하게 알람을 설정하는것
	
  2.값으로 재개하기
	이때resume에 Unit를 넣는이유와,suspendCoroutine에 Unit를 제네릭타입인자로 사용하는이유는,
	suspendCoroutine을 호출할때 컨티뉴에이션 객체로 반환될 값의 타입을 지정할수있는데,
	이떄 resume로 반환되는 값은 반드시 지정된타입과 같은타입이어야하기때문
	
	즉 코루틴이 있으면 값을 요청하고,중단한후에 데이터를 받고나면 받은 데이터를 resume함수로 보내줘 라고
	컨티뉴에이션 객체를 통해 라이브러리에 전달할수있음
	그러면 스레드는 다른일을 할수있고,데이터가 도착하면 스레드는 코루틴이 중단된지점에서 재개하게됨
	즉 resume를 람다에 넣어서,값이 들어오면 재개하게 할수있는것

  3.예외로 재개하기
	만약 값을 받아오는데 실패했거나 하는 이유로 에러가 떴다면,코루틴이 발생한곳에서 예외를 발생시켜야함
	우리가 사용하는 모든 함수는 값을 반환하거나 예외를 던지고,이건 suspendCoroutine도 마찬가지임
	resume가 호출될때 suspendCoroutine는 인자로 들어온 데이터를 반환하고,
	resumeWithException이 호출되면 중단된지점에서 인자로 넣어둔 예외를 던짐
	
  4.함수가 아닌 코루틴을 중단시킨다
	여기서 중요한건 함수가 아닌 코루틴을 중단시킨다는것
	중단함수는 코루틴이 아니고,단지 코루틴을 중단시킬수있는 함수임
	즉
		continuation:Continuation<Unit>?=null
		suspentFunction()//continuation변수를 채우는 코루틴
		continuation?.resume(Unit)
	이런식으로 코드를 짜면 resume가 호출되지않고,다른스레드나 다른코루틴으로 재개하지않으면 프로그램은 실행된상태로 유지됨
	즉 메모리누수임
	그러니까 람다


4.코루틴의 실제 구현
  스킵해도됨 중요하지않은 구현방식이니까
  1.컨티뉴에이션 전달방식
	컨티뉴에이션은 함수에서 함수로 인자를 통해 전달되고,도중에 중단되면 null을 줘야하니 Any에서 Any?로 자동으로 바뀜
	이때 중단함수는 COROUTINE_SUSPENDED를 반환함
		suspend fun getUser():User?//이건
		suspend fun getUser(continuation:Continuation<*>):Any?
	이렇게 바뀜

  2.아주 간단한 함수
	suspend가 붙는다는건,함수의 매개변수에 continuation:Continuation<*>이 추가되고,
	함수의 리턴값으로 Continuation이 하나 추가된다는것과 비슷함
	이때 해당 함수가 실행되면,해당함수는 받은 매개변수 continuation을 자신만의 컨티뉴에이션인 aaContinuation으로 포장함
	즉 데코레이터로 싸는거,이때 클래스에 내래퍼가 없을때만 포장을해야함(내가 이미 포장한후에 중단했으면,재포장될수있으니)
	
	함수가 시작되는시점은 함수의 시작점과,중단이후 재개시점 두곳이고,현재상태는 label이라는 필드로 저장됨(해당 continuation의 시작위치)
	또한 함수가 중단되면,COROUTINE_SUSPENDED가 반환되고,이건 해당 함수를 호출한 함수부터 콜스택의 모든 함수를 다 넣어둠
	따라서 중단이 일어나면 콜스택의 모든 함수가 종료되고,이 중단된 코루틴을 실행하던 스레드는 다른코드들이 사용할수있어짐
	
  3.상태를 가진 함수
	즉 함수가 중단되면,현재상황과 실행위치,콜스택,변수등을 전부 상태로 기록하고,이걸 객체로 바꾼게 Continuation객체임

  4.값을받아 재개되는함수
	만약 중단함수로부터 값을 보내야할때는 값으로 재개되면 성공,예외로 재개되면 실패를 던지면됨

  5.콜스택
	함수a가 함수 b를 호출하면 가상머신은 a의 상태외 b가 끝나면 실행이될지점을 어딘가에 저장해야하는데,이걸 콜스택이라고 함
	코루틴을 중단하면 스레드를 반환해 콜스택의 정보가 사라짐,이걸 해결하기위해 중단객체에 컨티뉴에이션객체에 콜스택을 때려박음
	
	또한 컨티뉴에이션객체는 하나의 컨티뉴에이션이 다른하나를 참조하고,참조된객체가 또 다른 컨티뉴에이션객체를 참조하는식의 데코레이터패턴으로 구성됨
	컨티뉴에이션객체가 재개될때 각 컨티뉴에이션 객체는 자신이 담당하는 함수를 먼저 호출하고,함수의 실행이 끝나면 자신을 호출한 함수의 컨티뉴에이션을 재개함
	이걸 스택이 끝날때까지 반복함

  6.중단함수의 성능
	함수를 상태로 나누는건 매우 코스트가 낮고,컨티뉴에이션에 상태를 저장하는것도 간단함,그냥 메모리위치만 넣어주면되니까

  7.요약
	중단함수는 상태머신과 비슷해,함수가 시작될때외 중단함수를 호출한뒤의 상태를 가짐
	상태를 나타내는값과 로컬데이터는 컨티뉴에이션객체에 저장됨
	호출된 함수의 컨티뉴에이션객체는 호출한 함수의 컨티뉴에이션을 데코레이팅함,즉 컨티뉴에이션은 콜스택의 역할을 할수있어짐

5.코루틴:언어차원에서의 지원 vs 라이브러리
	코틀린 코루틴은 언어차원의 기본적인 지원과,코틀린 코루틴 라이브러리로 구성되어있음
	즉 언어레벨의 코루틴을 가져다가 내가 라이브러리만들어서 쓰는거도 코루틴라이브러리 의존성없이 가능하다는거
	
	일반적으로는 코루틴을 쓴다면 라이브러리를 가져다쓰겠지만..


2.코틀린 코루틴 라이브러리
6.코루틴 빌더
  1.서론
    중단함수는 컨티뉴에이션 객체를 다른 중단함수로 전달해야함,
	따라서 중단함수가 일반함수를 호출하는건 가능하지만 일반함수가 중단함수를 호출하는건 불가능함
	모든 중단함수는 또 다른 중단함수에 의해 호출되어야하며,이는 앞서 호출한 중단함수도 마찬가지임
	즉 중단함수를 연속으로 호출하면,시작되는지점이 반드시 있고 이를 코루틴빌더가 담당하고,얘가 일반함수와 중단함수를 연결하는 매개체가 됨
	이 코루틴빌더에서 가장 대표적인 코루틴빌더로는
		launch
		runblocking
		async
	3가지가 있음
  1.launch 빌더
	launch가 작동하는방식은 thread함수를 호출하여 새 스레드를 시작하는것과 비슷함
	launch함수는 coroutineScope인터페이스의 확장함수이고,
	coroutineScope는 부모코루틴과 자식코루틴 사이의 관계를 정립시키기위한 목적으로 사용되는 구조화된 동시성의 핵심임
	
	코루틴을 쓸때 globalScope에서 launch를 사용하는건 좋지않고 
	이렇게쓸때 코루틴을 사용할때 스레드가 끝나버리면 코루틴은 그대로 끝나게됨
	즉 스레드가 블로킹되어야함(단 구조화된 동시성을 사용하면 Thread.sleep는 필요없음)
	
	launch가 작동하는방식은 데몬스레드와 유사하지만 가벼움
	둘 다 작업을 하는동안 프로그램이 끝나는걸 막는 무언가가 필요하지만,블로킹된 스레드를 유지하는건 비용이 들지만 코루틴은 거의 공짜임
	
  2.runBlocking 빌더
	일반적으로는 코루틴이 스레드를 블로킹하지않고 작업을 중단시키기만 해야하지만,매우 가끔 블로킹이 필요한경우가 있음
	이럴때 사용되는게 runBlocking임
	이건 코루틴이 중단되었을때 runBlocking빌더는 중단메인함수와 마찬가지로 시작한 스레드를 중단시킴
	따라서 runBlocking 내부에서 delay(1000)을 치면 Thread.sleep(1000)과 비슷하게 동작함
	
	이걸 사용하는 특수한경우는,
	프로그램이 끝나는걸 방지하기위해 스레드를 블로킹할필요가 있는 메인함수와,
	같은이유로 스레드를 블로킹할필요가 있는 유닛테스트임
	
	근데 요즘은 유닛테스트에는 runTest를 사용하고,메인함수에는 suspend를 붙여 중단함수로 만들기때문에 잘 사용되지않음

  3.async빌더
	async빌더는 launch와 비슷하지만 값을 생성하고,이 값은 람다로 반환되어야함
	async함수는 Deferred<T>타입의 객체를 리턴하고,T는 생성되는값의 제네릭임
	Deferred에는 작업이 끝나면 값을 반환하는 중단메서드인 await가 있고,이걸 호출하면 제네릭값이 리턴됨
	즉 async의 리턴값의 await 메서드로 비동기처리를 할수있다는거임
	
	async빌더는 호출되자마자 코루틴을 즉시 시작하고,그래서 몇개의 작업을 한번에 시작하고 모든 결과를 한꺼번에 기다릴때 사용함
	반환된 Deferred는 값이 생성되면 값을 내부에 저장하기때문에,
	await에서 값이 반환되는 즉시 값을 사용할수있고,
	값이 생성되기전에 await를 사용하면 값이 나올때까지 기다리게됨
	
	launch와 await는 거의 비슷하지만,await가 값을 반환한다는 차이가 있음
	값이 필요하다면 async를,값이 필요없다면 launch를 사용하면됨
	
	async빌더는 두가지 다른곳에서 데이터를 얻어와 합치는것처럼,여러작업을 병렬로 실행할때 주로 사용됨

  4.구조화된 동시성
	코루틴이 globalScope에서 시작되면,프로그램은 해당 코루틴을 기다리지않음
	코루틴은 어떤 스레드도 블록하지않아서 프로그램이 끝나는걸 막을수없음
	
	globalScope가 필요한이유는,launch와 async가 coroutineScope의 인터페이스확장이기때문
	근데 runBlocking이나 launch,async의 block파라미터는 모두 CoroutuneScope타입임,
	그래서 globalScope대신 runBlocking을 사용해서 launch나 async를 호출해도됨(runBlocking내부에서 this.launch나 launch쓰면됨)
	이러면 launch는 runBlocking의 자식이 되고,이경우에는 runBlocking은 모든 자식이 작업을 끝낼때까지 기다림
	
	이렇게 부모는 자식들을 위한 스코프를 제공하고,자식들을 해당 스코프내에서 호출하는 관계가 구조화된 동시성임
	여기서 중요한 특징은
		자식은 부모의 컨텍스트를 상속받고,이를 재정의할수있음
		부모는 모든 자식이 일을 끝낼때까지 기다림
		부모가 취소되면 자식도 취소됨
		자식에서 에러가 발생하면 부모도 에러로 소멸함
	이 있음
	
	다른 코루틴빌더와 달리,runBlocking은 CoroutuneScope의 인터페이스확장이 아니고,그래서 자식이 될수없고 루트코루틴으로만 사용할수있음
	그래서 runBlocking은 다른 코루틴과 쓰임새가 다름

  5.현업에서의 코루틴사용
	중단함수는 다른 중단함수들로 부터 호출되어야하고,모든중단함수는 코루틴빌더로 시작되어야함
	그리고 runBlocking을 제외한 모든 코루틴빌더는 coroutineScope에서 시작되어야함
	
	보통 스코프는 직접 만들거나,프레임워크가 제공하는 스코프를 사용함(Ktor같은)
	첫빌더가 스코프에서 시작되면 다른빌더가 첫빌더의 스코프에서 시작될수있고,이게 어플리케이션 구조화과정의 본질임
	
	중단함수내에서 스코프를 처리할순없음
	스코프는 인자로 넘기는건 좋은방법이 아니고,이때는 코루틴빌더가 사용할 스코프를 만들어주는 중단함수인 coroutineScope()를 사용하는게 좋음

  6.coroutineScope()사용하기
	async를 호출하려면 스코프가 필요하지만,함수에 스코프를 넘기고싶지않을떄 coroutineScope를 사용할수있음
	coroutineScope는 람다표현식이 필요로 하는 스코프를 만들어주는 중단함수임
	이건 람다식이 반환하는것이면 무엇이든 반환함(제네릭)
	이건 중단함수내에서 스코프가 필요할떄 일반적으로 사용하는 함수임
	중단함수를 coroutineScope와 함께 시작하는것도 가능하고,이는 메인함수와 runBlocking을 함께 사용하는것보다 세련된방법임

  7.요약
	대부분의 경우 함수를 coroutineScope로 래핑하고,스코프내에서 빌더를 사용해야함
	모든것은 스코프내에서 빌더를 호출함으로써 시작되어야함
	그리고 대부분의 프로젝트에서 스코프는 한번 정의도면 건드릴일이 별로없음
	
7.코루틴 컨텍스트















