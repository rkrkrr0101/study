1.코틀린 코루틴 이해하기
1.코틀린코루틴을 배워야하는 이유
  1.안드로이드에서 코루틴사용
	코루틴대신 사용할수있는것들은
		스레드전환:블로킹이 가능한 스레드를 먼저 사용하고,이후 메인스레드로 전환
		  단점:
		    스레드가 실행되면 멈출수없어서 메모리누수될수있음
			스레드를 많이생성하면 비용이 많이듬
			스레드를 자주 전환하면 복잡도가 올라가고 관리가 어려움
			코드가 쓸데없이 길어지고 이해가 어려움
		콜백:함수를 논블로킹으로 만들고,함수작업이 끝나면 호출될 콜백함수 넘겨주기
		  단점:
		    중간에 작업취소 어려움
			데이터소스가 여러곳일경우,동시처리어려움
			콜백지옥
			작업의 순서다루기가 어려움
		rxJava,리액티브스트림:데이터스트림내에서 일어나는 모든연산을 시작,처리,관찰 가능
		  단점:
		    콜백보다 모든면에서 낫지만,구현이 복잡함
	들이 있음,위에서 밑으로 내려갈수록 최신이고,좋음
	
	코틀린 코루틴의 핵심은 코루틴을 특정지점에서 멈추고 이후에 재개할수있다는것
	이거로 우리가 짠 코드를 메인스레드에서 실행하고,api로 데이터를 얻어올때 잠깐 중단시킬수도 있음
	코루틴을 중단시켰을때 스레드는 블로킹되지않고,뷰를 바꾸거나 다른 코루틴을 실행하는등의 또 다른 작업이 가능함
	데이터가 준비되면 코루틴은 메인스레드에서 대기하고있다가,메인스레드가 준비되면 멈춘지점에서 다시 작업을 수행함
	
	코루틴의 코드는 메인스레드에서 실행되지만,스레드를 블로킹하진않음
	코루틴의 중단은 데이터가 오는걸 기다릴때 코루틴을 잠시 멈추는방식으로 작동하고,이때 멈춰있는동안 메인스레드는 다른작업을 할수있음
	데이터가 준비되면 코루틴은 다시 메인스레드를 할당받아 이전에 멈춘지점부터 다시 시작함
	
	사실 코루틴자체는 async await와 큰차이없고,동작자체도 똑같음
		fun abc(){
			val user=async{user.getUser()}
			val prodect=async{pro.getProdect()}
			...(중간작업들)
			print(user.await(),prodect.await())
		}
	이러면 async를 먼저 다 날려두고,다른작업들을 처리하다가 await를 만나면 값이 들어왔는지 확인하고,
	안들어왔으면 다 들어올때까지 다른작업하다가 다 들어오면 처리하는느낌임
	
	또한 코틀린 코루틴은 for문을 논블로킹으로 처리하기같은 이런일을 할때 효과적임
	
  2.백엔드에서의 코루틴사용
	백엔드에서 코루틴을 사용할때 가장 큰 장점은 간결성임
	rxJava와 다르게 코루틴은 코드의 변화를 거의 주지않을수있음
	단순히 suspend제어자를 함수에 추가하는것만으로 충분함
	
	또한 스레드에 비해 비용이 싸다는 장점도 있음


2.시퀸스 빌더
    파이썬이나 자바스크립트는 제한된 형태의 코루틴을 사용함
		비동기함수(async,await)
		제너레이터함수(값을 순차적으로 반환하는 함수)
	코틀린에서는 비동기함수는 지원하고,제너레이터 대신 시퀸스를 제공함(그 컬렉션시퀸스같은거 맞음)
	
	시퀸스는 컬렉션과 비슷한개념이지만,필요할때마다 값을 하나씩 계산하는,lazy하게 동작함
	이건 요구되는 연산을 최소한으로 수행할수있고,메모리사용이 효율적이라는 장점이 있음(시퀸스가 없으면 중간리스트가 생기는데,저거쓰면 하나씩처리하니까)
	
	시퀸스자체로 동작을 시킬때는,제너레이터처럼 1순회 돌때마다 yield가 있는 위치까지 돌린후,그뒤에는 그위치부터 시작함
	
	시퀸스는 피보나치나 난수,임의의문자열들을 생성할때도 사용할수있음
	시퀸스빌더를 사용할때 주의점은,yield대신 중단함수를 사용하면 안된다는것
	중단이 필요하다면 시퀸스대신 플로우를 사용하는게 더 나음(전반적으로도 플로우가낫긴한듯)

3.중단은 어떻게 작동할까
	중단은 코루틴의 핵심임
	중단이란 실행을 중간에 멈추는것,실행을 멈추고 다른일을 하다가 다시 해당작업을 수행할수있음
	코루틴은 중단되면 Continuation객체를 반환함,이건 세이브포인트고,이걸 사용해서 멈췄던곳에서 다시 코루틴을 실행할수있음
	
	여기서 스레드와의 차이가 나타나는데,스레드는 저장이 불가능하고 멈추는것만 가능하고,코루틴은 중단됐을때 어떤 자원도 사용하지않고,
	다른스레드에서 시작할수있고,컨티뉴에이션 객체는 직렬화와 역직렬화가 가능하고,다시 실행될수있음
	
  1.재개
	작업을 재개하려면 코루틴이 필요하고,코루틴은 runBlocking나 launch와 같은 코루틴빌더를 통해 만들수있음
	중단함수는 말그대로 코루틴을 중단할수있는 함수고,이는 중단함수는 반드시 코루틴,혹은 다른 중단함수에 의해서 호출되어야함을 의미함
	즉 중단함주는 중단할수있는곳이 필요함
	
	코틀린은 코루틴내부에서 suspend가 붙은 main함수를 실행하고,중간에 중단될경우(suspendCoroutine),
	인자로 들어간 람다함수가 중단되기직전에 실행되고,이 함수는 컨티뉴에이션객체를 인자로 받음
	
	즉 중단된 이후에는 컨티뉴에이션 객체를 사용할수없기때문에,실행이 끝나기전에 람다함수로 끼어들어가서 사용하는것
	즉 람다함수에는 재시작을 위한 로직을 넣을수있음
	
	또한 suspendCoroutine에서는 잠깐동안 정지된뒤 재개되는 다른 스레드를 실행할수도있음
	즉 정해진시간뒤에 코루틴을 다시 재개하는 함수를,다른 스레드를 써서 만들수있다는거
	보통은 이렇게 직접하지않고 알람라이브러리,ScheduledExecutorService를 사용하긴하지만 동작원리자체는 같음
	이걸 코틀린코루틴에서 만들어둔게 delay함수임
	
	즉 일정시간이 지나면 continuation.resume(Unit)를 호출하게 알람을 설정하는것
	
  2.값으로 재개하기
	이때resume에 Unit를 넣는이유와,suspendCoroutine에 Unit를 제네릭타입인자로 사용하는이유는,
	suspendCoroutine을 호출할때 컨티뉴에이션 객체로 반환될 값의 타입을 지정할수있는데,
	이떄 resume로 반환되는 값은 반드시 지정된타입과 같은타입이어야하기때문
	
	즉 코루틴이 있으면 값을 요청하고,중단한후에 데이터를 받고나면 받은 데이터를 resume함수로 보내줘 라고
	컨티뉴에이션 객체를 통해 라이브러리에 전달할수있음
	그러면 스레드는 다른일을 할수있고,데이터가 도착하면 스레드는 코루틴이 중단된지점에서 재개하게됨
	즉 resume를 람다에 넣어서,값이 들어오면 재개하게 할수있는것

  3.예외로 재개하기
	만약 값을 받아오는데 실패했거나 하는 이유로 에러가 떴다면,코루틴이 발생한곳에서 예외를 발생시켜야함
	우리가 사용하는 모든 함수는 값을 반환하거나 예외를 던지고,이건 suspendCoroutine도 마찬가지임
	resume가 호출될때 suspendCoroutine는 인자로 들어온 데이터를 반환하고,
	resumeWithException이 호출되면 중단된지점에서 인자로 넣어둔 예외를 던짐
	
  4.함수가 아닌 코루틴을 중단시킨다
	여기서 중요한건 함수가 아닌 코루틴을 중단시킨다는것
	중단함수는 코루틴이 아니고,단지 코루틴을 중단시킬수있는 함수임
	즉
		continuation:Continuation<Unit>?=null
		suspentFunction()//continuation변수를 채우는 코루틴
		continuation?.resume(Unit)
	이런식으로 코드를 짜면 resume가 호출되지않고,다른스레드나 다른코루틴으로 재개하지않으면 프로그램은 실행된상태로 유지됨
	즉 메모리누수임
	그러니까 람다


4.코루틴의 실제 구현
  스킵해도됨 중요하지않은 구현방식이니까
  1.컨티뉴에이션 전달방식
	컨티뉴에이션은 함수에서 함수로 인자를 통해 전달되고,도중에 중단되면 null을 줘야하니 Any에서 Any?로 자동으로 바뀜
	이때 중단함수는 COROUTINE_SUSPENDED를 반환함
		suspend fun getUser():User?//이건
		suspend fun getUser(continuation:Continuation<*>):Any?
	이렇게 바뀜

  2.아주 간단한 함수
	suspend가 붙는다는건,함수의 매개변수에 continuation:Continuation<*>이 추가되고,
	함수의 리턴값으로 Continuation이 하나 추가된다는것과 비슷함
	이때 해당 함수가 실행되면,해당함수는 받은 매개변수 continuation을 자신만의 컨티뉴에이션인 aaContinuation으로 포장함
	즉 데코레이터로 싸는거,이때 클래스에 내래퍼가 없을때만 포장을해야함(내가 이미 포장한후에 중단했으면,재포장될수있으니)
	
	함수가 시작되는시점은 함수의 시작점과,중단이후 재개시점 두곳이고,현재상태는 label이라는 필드로 저장됨(해당 continuation의 시작위치)
	또한 함수가 중단되면,COROUTINE_SUSPENDED가 반환되고,이건 해당 함수를 호출한 함수부터 콜스택의 모든 함수를 다 넣어둠
	따라서 중단이 일어나면 콜스택의 모든 함수가 종료되고,이 중단된 코루틴을 실행하던 스레드는 다른코드들이 사용할수있어짐
	
  3.상태를 가진 함수
	즉 함수가 중단되면,현재상황과 실행위치,콜스택,변수등을 전부 상태로 기록하고,이걸 객체로 바꾼게 Continuation객체임

  4.값을받아 재개되는함수
	만약 중단함수로부터 값을 보내야할때는 값으로 재개되면 성공,예외로 재개되면 실패를 던지면됨

  5.콜스택
	함수a가 함수 b를 호출하면 가상머신은 a의 상태외 b가 끝나면 실행이될지점을 어딘가에 저장해야하는데,이걸 콜스택이라고 함
	코루틴을 중단하면 스레드를 반환해 콜스택의 정보가 사라짐,이걸 해결하기위해 중단객체에 컨티뉴에이션객체에 콜스택을 때려박음
	
	또한 컨티뉴에이션객체는 하나의 컨티뉴에이션이 다른하나를 참조하고,참조된객체가 또 다른 컨티뉴에이션객체를 참조하는식의 데코레이터패턴으로 구성됨
	컨티뉴에이션객체가 재개될때 각 컨티뉴에이션 객체는 자신이 담당하는 함수를 먼저 호출하고,함수의 실행이 끝나면 자신을 호출한 함수의 컨티뉴에이션을 재개함
	이걸 스택이 끝날때까지 반복함

  6.중단함수의 성능
	함수를 상태로 나누는건 매우 코스트가 낮고,컨티뉴에이션에 상태를 저장하는것도 간단함,그냥 메모리위치만 넣어주면되니까

  7.요약
	중단함수는 상태머신과 비슷해,함수가 시작될때외 중단함수를 호출한뒤의 상태를 가짐
	상태를 나타내는값과 로컬데이터는 컨티뉴에이션객체에 저장됨
	호출된 함수의 컨티뉴에이션객체는 호출한 함수의 컨티뉴에이션을 데코레이팅함,즉 컨티뉴에이션은 콜스택의 역할을 할수있어짐

5.코루틴:언어차원에서의 지원 vs 라이브러리
	코틀린 코루틴은 언어차원의 기본적인 지원과,코틀린 코루틴 라이브러리로 구성되어있음
	즉 언어레벨의 코루틴을 가져다가 내가 라이브러리만들어서 쓰는거도 코루틴라이브러리 의존성없이 가능하다는거
	
	일반적으로는 코루틴을 쓴다면 라이브러리를 가져다쓰겠지만..


2.코틀린 코루틴 라이브러리
6.코루틴 빌더
  1.서론
    중단함수는 컨티뉴에이션 객체를 다른 중단함수로 전달해야함,
	따라서 중단함수가 일반함수를 호출하는건 가능하지만 일반함수가 중단함수를 호출하는건 불가능함
	모든 중단함수는 또 다른 중단함수에 의해 호출되어야하며,이는 앞서 호출한 중단함수도 마찬가지임
	즉 중단함수를 연속으로 호출하면,시작되는지점이 반드시 있고 이를 코루틴빌더가 담당하고,얘가 일반함수와 중단함수를 연결하는 매개체가 됨
	이 코루틴빌더에서 가장 대표적인 코루틴빌더로는
		launch
		runblocking
		async
	3가지가 있음
  1.launch 빌더
	launch가 작동하는방식은 thread함수를 호출하여 새 스레드를 시작하는것과 비슷함
	launch함수는 coroutineScope인터페이스의 확장함수이고,
	coroutineScope는 부모코루틴과 자식코루틴 사이의 관계를 정립시키기위한 목적으로 사용되는 구조화된 동시성의 핵심임
	
	코루틴을 쓸때 globalScope에서 launch를 사용하는건 좋지않고 
	이렇게쓸때 코루틴을 사용할때 스레드가 끝나버리면 코루틴은 그대로 끝나게됨
	즉 스레드가 블로킹되어야함(단 구조화된 동시성을 사용하면 Thread.sleep는 필요없음)
	
	launch가 작동하는방식은 데몬스레드와 유사하지만 가벼움
	둘 다 작업을 하는동안 프로그램이 끝나는걸 막는 무언가가 필요하지만,블로킹된 스레드를 유지하는건 비용이 들지만 코루틴은 거의 공짜임
	
  2.runBlocking 빌더
	일반적으로는 코루틴이 스레드를 블로킹하지않고 작업을 중단시키기만 해야하지만,매우 가끔 블로킹이 필요한경우가 있음
	이럴때 사용되는게 runBlocking임
	이건 코루틴이 중단되었을때 runBlocking빌더는 중단메인함수와 마찬가지로 시작한 스레드를 중단시킴
	따라서 runBlocking 내부에서 delay(1000)을 치면 Thread.sleep(1000)과 비슷하게 동작함
	
	이걸 사용하는 특수한경우는,
	프로그램이 끝나는걸 방지하기위해 스레드를 블로킹할필요가 있는 메인함수와,
	같은이유로 스레드를 블로킹할필요가 있는 유닛테스트임
	
	근데 요즘은 유닛테스트에는 runTest를 사용하고,메인함수에는 suspend를 붙여 중단함수로 만들기때문에 잘 사용되지않음

  3.async빌더
	async빌더는 launch와 비슷하지만 값을 생성하고,이 값은 람다로 반환되어야함
	async함수는 Deferred<T>타입의 객체를 리턴하고,T는 생성되는값의 제네릭임
	Deferred에는 작업이 끝나면 값을 반환하는 중단메서드인 await가 있고,이걸 호출하면 제네릭값이 리턴됨
	즉 async의 리턴값의 await 메서드로 비동기처리를 할수있다는거임
	
	async빌더는 호출되자마자 코루틴을 즉시 시작하고,그래서 몇개의 작업을 한번에 시작하고 모든 결과를 한꺼번에 기다릴때 사용함
	반환된 Deferred는 값이 생성되면 값을 내부에 저장하기때문에,
	await에서 값이 반환되는 즉시 값을 사용할수있고,
	값이 생성되기전에 await를 사용하면 값이 나올때까지 기다리게됨
	
	launch와 await는 거의 비슷하지만,await가 값을 반환한다는 차이가 있음
	값이 필요하다면 async를,값이 필요없다면 launch를 사용하면됨
	
	async빌더는 두가지 다른곳에서 데이터를 얻어와 합치는것처럼,여러작업을 병렬로 실행할때 주로 사용됨

  4.구조화된 동시성
	코루틴이 globalScope에서 시작되면,프로그램은 해당 코루틴을 기다리지않음
	코루틴은 어떤 스레드도 블록하지않아서 프로그램이 끝나는걸 막을수없음
	
	globalScope가 필요한이유는,launch와 async가 coroutineScope의 인터페이스확장이기때문
	근데 runBlocking이나 launch,async의 block파라미터는 모두 CoroutuneScope타입임,
	그래서 globalScope대신 runBlocking을 사용해서 launch나 async를 호출해도됨(runBlocking내부에서 this.launch나 launch쓰면됨)
	이러면 launch는 runBlocking의 자식이 되고,이경우에는 runBlocking은 모든 자식이 작업을 끝낼때까지 기다림
	
	이렇게 부모는 자식들을 위한 스코프를 제공하고,자식들을 해당 스코프내에서 호출하는 관계가 구조화된 동시성임
	여기서 중요한 특징은
		자식은 부모의 컨텍스트를 상속받고,이를 재정의할수있음
		부모는 모든 자식이 일을 끝낼때까지 기다림
		부모가 취소되면 자식도 취소됨
		자식에서 에러가 발생하면 부모도 에러로 소멸함
	이 있음
	
	다른 코루틴빌더와 달리,runBlocking은 CoroutuneScope의 인터페이스확장이 아니고,그래서 자식이 될수없고 루트코루틴으로만 사용할수있음
	그래서 runBlocking은 다른 코루틴과 쓰임새가 다름

  5.현업에서의 코루틴사용
	중단함수는 다른 중단함수들로 부터 호출되어야하고,모든중단함수는 코루틴빌더로 시작되어야함
	그리고 runBlocking을 제외한 모든 코루틴빌더는 coroutineScope에서 시작되어야함
	
	보통 스코프는 직접 만들거나,프레임워크가 제공하는 스코프를 사용함(Ktor같은)
	첫빌더가 스코프에서 시작되면 다른빌더가 첫빌더의 스코프에서 시작될수있고,이게 어플리케이션 구조화과정의 본질임
	
	중단함수내에서 스코프를 처리할순없음
	스코프는 인자로 넘기는건 좋은방법이 아니고,이때는 코루틴빌더가 사용할 스코프를 만들어주는 중단함수인 coroutineScope()를 사용하는게 좋음

  6.coroutineScope()사용하기
	async를 호출하려면 스코프가 필요하지만,함수에 스코프를 넘기고싶지않을떄 coroutineScope를 사용할수있음
	coroutineScope는 람다표현식이 필요로 하는 스코프를 만들어주는 중단함수임
	이건 람다식이 반환하는것이면 무엇이든 반환함(제네릭)
	이건 중단함수내에서 스코프가 필요할떄 일반적으로 사용하는 함수임
	중단함수를 coroutineScope와 함께 시작하는것도 가능하고,이는 메인함수와 runBlocking을 함께 사용하는것보다 세련된방법임

  7.요약
	대부분의 경우 함수를 coroutineScope로 래핑하고,스코프내에서 빌더를 사용해야함
	모든것은 스코프내에서 빌더를 호출함으로써 시작되어야함
	그리고 대부분의 프로젝트에서 스코프는 한번 정의도면 건드릴일이 별로없음
	
7.코루틴 컨텍스트
  1.서론
	coroutineScope는 coroutineContext를 감싸는 래퍼고,코루틴컨텍스트는 여기저기 다 들어감
	Continuation에서 coroutineContext가 들어가고

  2.CoroutineContext 인터페이스
	CoroutineContext는 원소나 원소들의 집합을 나타내는 인터페이스임
	이거자체로 컬렉션과 개념이 비슷함,1개만 있을수도있고 여러개가 있을수도있음,이때 각 원소들도 전부 CoroutineContext이라는게 특이점
	
	컨텍스트에서 모든 원소는 식별할수있는 유일한 키를 가지고있고,각 키는 주소로 비교할수있음
	또한 CoroutineName이나 Job도 CoroutineContext.Element를 구현함

  3.CoroutineContext에서 원소 찾기
	CoroutineContext는 컬렉션과 비슷하게 get을 사용해서 키로 원소를 찾을수있고,대괄호로도 가능함
	이때 원소가 없으면 null이 반환됨
	
	또한 CoroutineName을 찾기위해서는 CoroutineName을 사용하기만 하면됨
	이건 타입이나 클래스가 아닌 컴패니언객체고,클래스의 이름이 컴패니언객체의 참조로 사용되는 코틀린의 특성상,CoroutineName.key로 찾을수있음
	이렇게 컴패니언객체를 키로 사용해서 같은이름을 가진 원소를 찾는건 자주쓰이고,키는 클래스나 같은 키를 사용하는 클래스가 구현한 인터페이스를 가리킴

  4.컨텍스트 더하기
	CoroutineContext는 두개의 컨텍스트를 합쳐 하나의 컨텍스트로 만들수있음(val ctx3=ctx1+ctx2)
	다른키를 가진 두 원소를 더하면 만들어진 컨텍스트는 두가지키를 모두 가짐
	또한 같은키를 가진 또 다른원소가 더해지면 맵처럼 새로운원소가 기존의 원소를 덮어씀

  5.비어있는 코루틴 컨텍스트
	코루틴컨텍스트는 컬렉션이므로,빈컨텍스트도 만들수있고,이걸 더하면 아무 변화가없음

  6.원소제거
	minusKey()로 원소를 컨텍스트에서 제거할수있음(이건 -로 할수없음)

  7.컨텍스트 폴딩
	컨텍스트의 각 원소를 조작해야하는경우,다른 컬렉션의 fold와 유사한 fold를 사용할수있음
	이건
		첫번째값
		현재상태와 현재 실행되는 원소로 다음 상태를 계산할 람다식
	이 필요함
  
  8.코루틴 컨텍스트와 빌더
	코루틴컨텍스트는 코루틴의 데이터를 저장하고 전달하는 방법임
	부모자식관계의 영향으로 부모는 기본적으로 컨텍스트를 자식에게 전달함
	자식은 부모의 컨텍스트를 상속받는다고 보면됨
	
	모든 자식은 빌더의 인자에서 정의된 특정 컨텍스트를 가질수있고,인자로 전달된 컨텍스트는 부모컨텍스트를 대체함
	
	즉 코루틴컨텍스트는 기본적으로
		기본컨텍스트+부모컨텍스트+자식컨텍스트임
	또한 새원소가 같은키를 가진 이전원소를 대체하므로,자식의 컨텍스트는 부모컨텍스트중 같은키를 가진 원소를 대체하고,
	디폴트는 부모자식 둘중 어디에도 없어야 사용됨
	
	Job은 변경이 가능하고,코루틴의 자식과 부모가 소통하기위해 사용되는 특별한 컨텍스트임

  9.중단함수에서 컨텍스트에 접근하기
	코루틴스코프는 컨텍스트에 접근할때 사용하는 코루틴컨텍스트 프로퍼티를 가지고있음
	컨텍스트는 중단함수 사이에 전달되는 컨티뉴에이션 객체가 참조하고있고,중단함수에서 부모의 컨텍스트에 접근하는게 가능함
	코루틴컨텍스트 프로퍼티는 모든 중단스코프에서 사용가능하고,이를통해 컨텍스트에 접근할수있음

  10.컨텍스트를 개별적으로 생성하기
	커스턴 코루틴컨텍스트를 만들일은 별로없지만,
	방법은 그냥 CoroutineContext.Element인터페이스를 구현하는 클래스를 만들면됨

  11.요약
	코루틴컨텍스트는 맵이나 집합같은 컬렉션과 비슷함
	코루틴컨텍스트는 Element인터페이스의 인덱싱된 집합이고,Element또한 CoroutineContext임
	코루틴 컨텍스트안의 모든 원소는 식별할때 사용되는 유일한 키를 가지고있음
	코루틴컨텍스트는 코루틴에 관련된 정보를 객체로 그룹화하고 전달하는 보편적인 방법
	코루틴컨텍스트는 코루틴에 저장되고,코루틴컨텍스트로 코루틴의 상태확인,스레드선택등 코루틴작동방식을 정할수있음


8.잡과 자식코루틴 기다리기
  1.서론
	자식이 부모로부터 컨텍스트를 물려받는건 코루틴빌더의 가장 기본적인 특징임
	이외에 구조화된 동시성의 중요한 특성중 세가지는 Job컨텍스트와 관련이 있음
	Job는 코루틴을 취소하고,상태를 파악하는등 다양하게 사용될수있음

  2.Job이란 무엇인가
	잡은 수명을 가지고있고 취소가능함,잡은 인터페이스지만 구체적인 사용법과 상태를 가지고있어서 추상클래스처럼 다룰수도있음
	잡의 수명은 상태로 나타남
		new->active->completing->completed
				   |->          |->Cancelling->Cancelled
	이렇게 액티브와 컴플리팅에서는 실패할수있고,대부분의 코루틴은 Active상태로 시작되고,지연시작하는애들만 new로 시작함
	실행이 완료되면 completing으로 가고 자식들을 기다림
	자식들의 실행도 끝났다면 잡은 마지막상태인 completed로 바뀜
	만약 실행도중에 취소되거나 실패하면 Cancelling으로 가고 여기서 연결을 끊거나 자원반납등 후처리를 할수있음
	후처리가 완료되면 Cancelled가 됨
	
	잡의 상태는 toString로 볼수있음
	빌더로 생성된잡은 job.complete()가 나올때까지 active고,
	launch는 기본적으로 액티브임(start에 CorutineStart.LAZY를 넣으면 지연시작가능,이땐 lazyjob11.start()로 시작가능)
	
	코루틴은 각자의 잡을 가지고있고,이 잡을 찹조하고 사용할수있음

  3.코루틴빌더는 부모의잡을 기초로 자신들의 잡을 생성함
    모든 코루틴빌더는 자신만의 잡을 생성하고,대부분의 코루틴빌더는 잡을 반환함(launch의 명시반환값이 Job)
	async로 반환되는 Deferred<T>도 Job를 구현하고있어서 Job라고 할수있음
	
	Job은 코루틴컨텍스트이므로 coroutineContext[Job]으로 접근할수있지만,확장프로퍼티를 쓰면 더 편함
	
	Job는 코루틴이 상속하지않는 유일한 코루틴컨텍스트고,이는 매우중요함
	모든 코루틴은 자신만의 잡을 생성하고,인자 또는 부모코루틴에서 온 잡은 새로운 잡의 부모로 사용됨
	
	부모잡은 자식잡을 모두 참조할수있고,자식또한 부모를 참조할수있음
	그래서 예외처리가 가능함
	
	이떄 주의해야할건,잡을 인자로 넣을경우 부모대신 인자를 사용하기때문에,부모와 자식간에 관계가 없어지고 부모는 자식을 기다리지않음
	즉 구조화된 동시성을 잃게되니 주의해야함

  4.자식들 기다리기
    잡의 이점은 코루틴이 완료될때까지 기다리는데 사용될수있다는점
	이를 위해 join메서드를 사용할수있음
	이건 지정한 잡이 Completed나 Cancelled에 도달할때까지 기다리는 중단함수임
	
	잡인터페이스는 모든 자식을 참조할수있는 children프로퍼티도 노출시켜서 join을 통해서 모든 자식들이 마지막상태가 될때까지 기다릴수있음

  5.잡팩토리 함수
	Job()팩토리함수로 코루틴없이 잡을 만들수있음
	이 잡은 어떤 코루틴과도 연관되지않고 컨텍스트로 사용될수있음
	즉 한개 이상의 자식코루틘을 가진 부모잡으로 사용할수있음
	
	이때 Job()팩토리함수로 잡을 생성하고,다른 코루틴의 부모로 지정한뒤에 잡에 대해 join을 호출하면,
	자식코루틴이 모두 끝나도 내가 수동으로 생성한 Job는 끝나지않아서 프로그램이 종료되지않으니 주의
	즉 자식코루틴을 대상으로 join을 걸어야지,수동생성Job를 대상으로 join을 걸면 무한실행임
	
	그래서 잡의 모든 자식코루틴에서 join을 하는
		job11.children.forEach{it.join()}
	을 사용해야지 job11.join()을 사용하면안됨 
	
	팩토리로 Job를 생성하면 CompletableJob타입이 나옴(Job을 좀 더 확장한 인터페이스)
	얘는 
		complete():잡을 완료하는데 사용,이걸 호출하면 모든자식이 작업완료할때까지 기다리지만,새코루틴을 생성할수없음
		completeExceptionally():인자로 받은 예외로 잡을 완료시키고,모든 자식코루틴은 주어진 예외를 래핑한 예외로 즉시취소됨
	를 추가로 보유함
	
	complete는 잡의 마지막 코루틴을 시작한후 자주 사용됨,이후에는 join으로 잡이 완료되는걸 기다리기만 하면 됨
	
	또한 Job함수의 인자로 부모잡의 참조값을 전달할수있고,이때 부모잡이 취소되면 해당잡또한 취소됨
	

9.취소
  1.서론
	코루틴에서 매우 중요한 기능중 하나가 취소임
	스레드를 죽이는건 최악의 취소방법이고(연결을 닫고 자원을 해제하지 못하기때문에),개발자들이 상태를 계속 확인하는건 불편함

  2.기본적인 취소
	job인터페이스는 cancel메서드를 가지고있고,이걸 호출하면
		호출한 코루틴은 첫중단점에서 잡을 끝냄
		잡이 자식이 있다면 자식들또한 취소되지만,부모는 영향을 받지 않음
		잡이 취소되면 취소된잡은 새 코루틴의 부모로 사용될수없고,취소된잡은 Cancelling이 되었다가 Cancelled가 됨
	이런 효과가 나타남
	
	또한 Cancel을 한 후에 취소과정을 기다리기위해 join을 같이하는게 일반적이고,거의 항상 묶어쓰기때문에 메서드도 있음
		job11.cancelAndJoin()
	만약 join을 하지않으면 경쟁상태가 될수도있음(첫중단점에서 끝내기때문에)
	
	또한 cancel함수에 각기 다른 예외를 인자로 넣어서 취소된원인을 명확히 할수있고,
	이떄 예외는 반드시 CancellationException이어야함,즉 저 예외의 서브타입이어야함
	
	Job()팩터리함수로 생성된 잡도 같은방법으로 취소될수있음
	이건 잡에 딸린 수많은 코루틴을 한번에 취소할때 자주 사용됨(안드로이드에서 화면닫을떄 해당화면에 코루틴 전부 취소할때 등)

  3.취소는 어떻게 작동하는가
	잡이 취소되면 Cancelling이 되고,첫 중단점에서 CancellationException을 던짐
	예외는 trycatch로 잡을수있긴하지만,다시던지는게 좋음
	취소된 코루틴은 단지 멈추는게 아니라,내부적으로 예외를 사용해 취소된다는걸 명심해야함
	
	대신 finally로 모든걸 정리할수는 있음(여기서 커넥션끊기),
	즉 try-catch가 아닌 try-finally로 예외는 예외대로 던지고 finally만 사용하는게 좋음
	즉 코루틴에서 finally사용은 자유로움

  4.취소중 코루틴을 한번 더 호출하기
	코루틴은 모든 자원을 정리할 필요가 있는 한 계속 실행될수있지만,정리과정중에 중단을 허용하진않음
	Job는 이미 Cancelling이 되었기때문에 중단되거나 다른 코루틴을 시작하는건 절대 불가능함
	만약 다른코루틴을 실행하려고하면 무시하고,중단하려고하면 CancellationException을 던짐
	
	만약 코루틴이 이미 취소됐는데 중단함수를 반드시 호출해야하는경우(db롤백등)에는,
	함수콜을 withContext(NonCancellable)로 포장하는 방법이 있음
	여기서 중요한건 코드블록의 컨텍스트를 바꾼다는것
	withContext의 내부에다가 취소될수없는잡인 NonCancellable을 사용하고,
	블록내부에서 잡은 액티브상태를 유지하고 중단함수를 원하는만큼 호출할수있음

  5.invokeOnCompletion
	자원을 해제하는데 자주 사용되는 또 다른 방법은 Job의 invokeOnCompletion메서드를 호출하는것
	이건 잡이 Cancelled나 Completed에 도달하면 호출될 핸들러를 지정하는 역할을 함
	즉 여기에 람다식을 넣어두면 이게 호출됨
	
	이 핸들러의 파라미터중 하나인 예외의 종류는
		잡이 예외없이 끝나면 null
		코루틴이 취소되면 CancellationException
		코루틴을 종료시킨 예외일수도 있음
	임
	잡이 invokeOnCompletion이 호출되기전에 완료되면,핸들러는 즉시 호출됨
	또한 onCancelling와 invokeImmediately파라미터로 핸들러의 동작방식을 변경할수도있음
	
	invokeOnCompletion는 취소되는중에 동기적으로 호출되고,어떤스레드에서 실행할지는 결정할수없음

  6.중단될수없는걸 중단하기
	취소는 중단점에서 일어나기때문에,중단점이 없으면 취소할수없음
	
	그래서
		yield를 주기적으로(큰작업하나하나뒤에 넣어두기)호출
		잡의 상태를 추적
	두가지 방법으로 대응할수있음
	yield야 뻔한방법이고,잡의 상태추적은,코루틴빌더 내부에는 빌더스코프를 참조하고있고,
	CoroutineScope는 coroutineContext프로퍼티로 참조할수있는 컨텍스트를 가지고있음
	따라서 코루틴잡에 접근해서 현재상태를 확인할수있음(isActive)
	이때 액티브하지않다면 연산을 중단시킬수있음
	즉 코루틴내부에서 현재 자신의 상태를 관측할수있고,이걸 계속 주기적으로 확인하는방법임(do-while같은느낌)
	또다른 방법으로,Job이 액티브가 아니면 CancellationException를 던지는 ensureActive()함수를 사용할수있음(yield처럼 쓰면됨)
	
	이 yield와  ensureActive 둘은 비슷해보이지만 둘은 매우다른데
	ensureActive()는 CoroutineScope(또는 CoroutineContext나 Job)에서 호출되어야하고,얘는 잡이 액티브가 아니면 예외를 던지는거고
	yield는 전형적인 최상위중단함수로,스코프가 필요없고 일반적인 중단함수에서도 사용될수있음
	중단하고 재개하는일을 하기떄문에 스레드풀을 가진 디스패처에서 사용하면 스레드가 바뀌는 문제가 있을수있음
	yield는 cpu사용량이 크거나 스레드를 블로킹하는 중단함수에서 자주사용되고
	ensureActive는 가벼워서 일반적인상황에서 주로 사용됨

  7.suspendCancellableCoroutine
	suspendCancellableCoroutine함수는 suspendCoroutine과 비슷하지만,
	컨티뉴에이션객체를 몇가지 메서드가 추가된 CancellableContinuation<T>로 래핑함
	여기서 가장 중요한건 invokeOnCancellation메서드임
	이건 라이브러리의 실행을 취소하거나,자원을 해제할때 자주 사용됨(즉 정리작업에 자주사용됨)

  8.요약
	취소는 코루틴의 아주 강력한 기능임
	취소를 적절하게 사용하면 자원낭비와 메모리누수를 줄일수있음

10.예외처리
  1.서론
	예외처리는 코루틴의 작동원리중 아주 중요함
	잡히지않은 예외가 발생하면 코루틴은 종료되고,추가적으로 부모도 같이 종료됨
	특이한점은 부모가 종료되면 자식들 모두를 취소시키니,하나의 자식에서 생긴 예외는 연관된 모든 코루틴에 종료를 날리게됨

  2.코루틴 종료 멈추기
	코루틴이 종료되기전에 예외를 잡는건 비동기특성상 위험함
	즉 코루틴빌더내부에서 새로운코루틴빌더를 try-catch를 하는건 전혀 도움이되지않음(자식을 감싸는 try문)

  3.SupervisorJob
	코루틴종료를 멈추는 가장 중요한 방법은 SupervisorJob을 사용하는것
	이걸 사용하면 자식에서 발생한 모든 예외를 무시할수있음
	
	일반적으로 SupervisorJob은 다수의 코루틴을 시작하는 스코프로 사용됨
	이때 조심해야할건,SupervisorJob을 부모코루틴의 인자로 사용하면,SupervisorJob은 단 하나의 자식만 가지기때문에 도움이 되지않음
	즉
		val scope=CoroutineScope(SupervisorJob())
		scope.launch{예외발생}
		scope.launch{정상작업}
	이러면 정상작업하는애는 문제없이 동작하지만(1-2)
		launch(SupervisorJob()){
			scope.launch{예외발생}
			scope.launch{정상작업}		
		}
	이러면 전부 취소되게됨
	왜냐면 위에는 스코프에 바로 launch가 2개 연결됐지만,
	밑에는 Job이 생기고 그밑에 launch가 하나 연결되고 그밑에 launch가 2개 연결되는 구조기때문(1-1-2)
	즉 저런식이 아닌
		val job11=SupervisorJob()
		launch(job11){예외발생}
		launch(job11){정상작업}
	이런식이면 정상적으로 동작하게됨(잡에 바로 2개꽂은상태니,1-2)

  4.supervisorScope
	예외전파를 막는 또다른 방법은 코루틴빌더를 supervisorScope로 래핑하는것
	이건 다른 코루틴에서 발생한 예외를 무시하고 부모와의 연결을 유지한다는점에서 아주 편리함
	이건 그냥
		supervisorScope{
			launch{예외발생}
			launch{정상작업}		
		}
	이런식으로 쓰면됨
	이건 단지 중단함수일뿐이고,중단함수본체를 래핑하는데 사용됨
	이걸 사용하는 일반적인 방법은 서로 무관한 다수의 작업을 스코프내에서 실행할때 사용됨(여러개중 하나가 실패해도 상관없을때)
	
	예외전파를 멈추는 또 다른 방법은 coroutineScope를 사용하는건데,이건 try-catch를 이용해 잡을수있는 예외를 던짐
	
	supervisorScope는 withContext(SupervisorJob())으로 대체될수없음
	Job는 상속되지않고 잡을 다른 코루틴에 전달하여 부모자식관계를 맺는데,
	이때 SupervisorJob은 withContext의 부모가 되버리기때문에 다시 1-1-2가 돼버림

  5.await
	예외가 발생했을때 async는 launch처럼 부모코루틴을 종료하고 부모와 관련있는 다른 코루틴빌더도 종료시킴
	이때 SupervisorJob이나 supervisorScope를 사용하면 이걸 막을수있고,
	이때 await를 사용하면 예외면 해당 예외가 던져지고(즉 try-catch필요),다른친구들은 그대로 자기일을 처리함
		supervisorScope{
			val a1=async{예외발생}
			val a2=async{정상작업}		
			try{
				print(a1.await())
			}catch(e:Exception){
				print(e)
			}
			print(a2.await())
		}
	즉 이런식으로 사용할수있다는거

  6.CancellationException은 부모까지 전파되지않는다
	예외가 CancellationException의 서브클래스라면 부모로 전파되지않음 
	현재 코루틴을 취소시킬뿐임
	즉 현재코루틴을 취소시키니 자신과 자신의 자식코루틴만 죽음
	
	CancellationException은 열린클래스(open)라서 다른클래스나 객체로 확장될수있음

  7.코루틴예외핸들러
	예외를 다룰때 예외를 처리하는 기본행동을 정의하는게 유용할떄가있는데,이때 CoroutineExceptionHandler컨텍스트를 사용하면 편리함
	이걸 사용하면 예외전파를 중단시키진않지만 해야할것들(보통 스택트레이스 출력)을 정의할수있음


11.코루틴 스코프 함수
  1.코루틴스코프 함수 이전에 사용한 방법들
	1.중단함수에서 중단함수호출
		이건 작업이 동시에 진행되지않는다는 큰 문제가 있음,즉 비동기가 아닌 동기실행됨
			suspend fun abcd(){
				val aa=abc()
				val bb=qwe()
			}
		이때 두 중단함수를 동시실행하려면 각각을 async로 래핑해야하는데,
		async는 스코프를 필요로하고,globalScope를 사용하는건 좋지못한방법임
			suspend fun abcd(){
				val aa=GlobalScope.async{abc()}
				val bb=GlobalScope.async{qwe()}
				
				print(aa.await())
				print(bb.await())
			}
		GlobalScope는 단지 EmptyCoroutineContext를 가진 스코프일뿐임
		GlobalScope에서 async를 호출하면 부모코루틴과는 전혀 관계가 없고,이때 async코루틴은
			취소될수없음(부모가 취소되도 관계가 없기때문에 캐스케이드취소되지않음)
			부모로부터 스코프를 상속받지않음(항상 기본디스패처에서 실행되고,부모의 컨텍스트를 전혀신경쓰지않음)
		또한 가장 중요한건
			메모리누수가 발생할수있고,쓸데없이 cpu를 낭비함
			코루틴을 단위테스트하는 도구가 작동하지않아 테스트가 매우 어려움
		그래서 이건 사용하면안됨
		
	2.스코프를 인자로 넘기기
		이건
			suspend fun abcd(scope:CoroutineScope){
				val aa=scope.async{abc()}
				val bb=scope.async{qwe()}
				
				print(aa.await())
				print(bb.await())
			}
		이렇게 하겠다는건데,이건 취소가 가능하고 단위테스트가 가능하지만,문제는 스코프가 함수에서 함수로 전달되어야한다는데 있음
		이렇게하면 실수하기 딱좋고 예상치못한 사이드이펙트가 터지기쉬움
		예를들면 async에서 예외가 발생하면 모든 스코프가(SupervisorJob을 사용하지않았을때) 닫히고,
		스코프에 접근하는 함수가 cancel메서드를 사용해 스코프를 취소하는등의 조작을 할수있어짐(내부와 외부가 스코프로 연결되어있으니)
		
		즉 다루기도 어렵고 잠재적으로도 위험해짐
  
  2.coroutineScope
	그래서 사용되는게 코루틴스코프임
	coroutineScope는 스코프를 시작하는 중단함수이고,인자로 들어온 함수가 생성한 값을 반환함
	
	async나 launch와 다르게 coroutineScope의 본체는 리시버없이 바로 호출됨(즉 앞에 뭐 없이 coroutineScope{}하면됨)
	코루틴스코프 함수는 새 코루틴을 생성하지만,새 코루틴이 끝날때까지 코루틴스코프를 호출한 코루틴을 중단시킴
	즉 2개이상 호출했을때 호출된 코루틴들이 동시작업을 하지않음
	
	생성된 스코프는 바깥의 스코프에서 coroutineContext를 상속받지만,컨텍스트의 Job는 오버라이딩함
	즉 생성된 스코프는 부모가 해야할 책임을 이어받음
		부모로부터 컨텍스트를 상속받고
		자식의 작업을 끝내기전까지 모든 자식을 기다리고
		부모가 취소되면 자식들 모두를 취소함
	이런식
	
	코루틴빌더와 달리 코루틴스코프나 스코프에 속한 자식에서 예외가 발생하면 다른 모든자식이 취소되고 같은 예외가 다시 던져짐
	그래서 중단함수에서 병렬로 작업을 수행할때는 코루틴스코프를 사용해서 중간에 끊긴경우 후속작업을 진행할수없다면 이걸 사용해서 끊어주는게 좋음
	
	즉 코루틴스코프는 중단메인함수 본체를 래핑하는식으로 주로 사용됨,즉 runBlocking자리를 coroutineScope가 대체하는느낌
	코루틴스코프함수는 기존의 중단컨텍스트에서 벗어난 새 스코프를 만들고,부모로부터 스코프를 상속받고 구조화된 동시성을 지원함

  3.코루틴 스코프함수
	스코프를 만드는 함수는 여러개가 있고,대부분 coroutineScope와 비슷하게 작동함
	supervisorScope는 coroutineScope와 비슷하지만,Job대신 SupervisorJob을 사용하고
	withContext는 코루틴컨텍스트를 바꿀수있는 코루틴스코프임
	withTimeout는 타임아웃이 있는 코루틴스코프임
	
	이런것들을 묶어서 코루틴스코프함수(스코핑함수)라고 하고,얘들은 중단함수에서 코루틴스코프를 만들기위해 사용됨
	
	코루틴스코프함수는 코루틴빌더와 혼동되지만 많이 다름
	코루틴빌더는
		코루틴스코프의 확장함수
		코루틴스코프 리시버의 코루틴컨텍스트를 사용
		예외는 Job으로 부모로 전파
		비동기인 코루틴을 시작
	코루틴 스코프함수는
		중단함수
		중단함수의 컨티뉴에이션객체가 가진 코루틴컨텍스트를 사용
		일반함수와 같은방식으로 예외를 던짐
		코루틴빌더가 호출된곳에서 코루틴을 시작
	하는 차이점이 있음(각 줄마다 대응됨)
	
	runBlocking은 코루틴빌더보다 코루틴스코프와 더 비슷한데,차이점은 런블로킹은 블로킹함수고 코루틴스코프함수는 중단함수라는것
	그래서 런블로킹은 코루틴의 계층에서 최상위에 있고,코루틴스코프는 계층중간에 있음

  4.WithContext
	withContext는 코루틴스코프와 비슷하지만,스코프의 컨텍스트를 변경할수있다는점에서 다름
	withContext의 인자로 컨텍스트를 제공하면,코루틴빌더처럼 부모스코프의 컨텍스트를 대체할수있음
	즉
		withContext(EmptyCoroutineContext)
		coroutineScope()
	이 두개는 같음
	
	이건 기존 스코프와 컨텍스트가 다른 코루틴스코프를 설정하기위해 주로 사용됨
	보통 디스패처와 함께 자주 사용됨
	
	또한 coroutineScope{..}는 async{}.await()와 비슷한데(async후 바로 await호출),
	가장 큰 차이는 async await는 스코프가 필요하지만,coroutineScope와 withContext는 해당함수를 호출한 중단점에서 스코프를 들고온다는것
	두경우 모두 async-await즉시사용 대신 coroutineScope와 withContext를 사용하는게 나음

  5.supervisorScope
	supervisorScope는 호출한 스코프로부터 상속받은 코루틴스코프를 만들고 지정된 중단함수를 호출한다는점에서 coroutineScope와 같지만,
	Job를 SupervisorJob으로 오버라이딩하기때문에 자식이 예외를 던져도 취소되지않음
	
	이건 서로 독립적인 작업을 시작하는 함수(서로 영향을 주지않는)에서 주로 사용됨
		supervisorScope{
			actions.forEach{
				launch{it.noti()}
			}
		}
	이런느낌임,노티는 서로간에 영향을 주지않고 동작하는데,하나가 뻗는다고 다른곳도 뻗으면 안되기때문에 이런상황에서 자주 사용됨
	
	또한 supervisorScope와 같이 async를 사용할땐 예외가 부모로 전파되는걸 막는것 외에 추가적인 예외처리가 필요함
	즉 try-catch로 await호출을 래핑해야함
	async코루틴이 예외로 끝나면 await도 예외를던지기때문
	
	또한 supervisorScope대신 withContext(SupervisorJob())을 사용할수없음1-2와 1-1-2관계이기때문
	즉 withContext(SupervisorJob())는 아무의미없음
	
  6.withTimeout
	withTimeout은 coroutineScope와 똑같은데,타임아웃이 있는거
	withTimeout에 제한시간을 매우 크게잡으면 coroutineScope와 똑같음
	
	withTimeout의 람다식을 실행할때의 제한시간을 줄수있는데,
	너무 오래걸리면 CancellationException의 서브타입인 TimeoutCancellationException을 던짐
	이건
		withTimeout(3000){
			...
		}
	이렇게 쓰면됨
	이건 테스트할때 유용하고,runTest내부에서 사용되면 가상시간으로 작동하게됨
	특정함수의 실행시간을 제한하기위해 런블로킹내부에서도 사용가능
	
	또한 TimeoutCancellationException이 던져지면,해당코루틴만 취소되고 부모에 영향을 주지않음(CancellableContinuation의 서브타입이니)
	즉 자식만 취소되고 부모에는 영향을 주지않음
	
	withTimeout의 친구로 withTimeoutOrNull도 있음,이건 타임아웃되면 람다식이 취소되고 null이 반환됨

  7.코루틴스코프함수 연결하기
	서로다른 코루틴스코프 함수의 두가지기능이 모두 필요하다면,두 코루틴스코프함수를 연달아 쓰면됨
		withContext(Dispatchers.Default){
			withTimeout(1000){
				...
			}
		}
  8.추가적인 연산
	작업을 수행하는도중에 추가적인 연산을 수행할때는,같은스코프에서 launch를 호출하는 방법이 자주 사용됨
	근데 여기엔 문제가 있는데,launch가 다른 launch를 기다려야한다는 문제가 있음
	
	다른방법으로는 취소가있는데,이건 사실상 말도안됨,보조적인 연산(로깅)이 실패했다고 전체가 다 취소되는건 말이안되니까
	
	그래서 추가적인 연산이 필요하면 또 다른 스코프에서 시작하는편이 나음
	쉬운방법으로는 생성자를 통해 주입하면 유닛테스트를 추가할수도있고 스코프를 사용하는데도 편리함
	
	이런식으로 주입된 스코프에서 추가연산을 시작하는건 자주사용되는 방법임
	이렇게 스코프를 전달하면 전달된 클래스를 통해 독립적인 작업을 실행한다는걸 명확하게 알수있고,중단함수는 주입된 스코프연산을 기다리지않음
	그래서 스코프가 전달되지않으면 중단함수는 모든 연산이 완료될때까지 종료되지않는다는걸 예상할수있음

  9.요약
	코루틴스코프함수는 모든 중단함수에서 사용될수있으므로 아주 유용함
	코루틴스코프함수는 람다식 전체를 래핑할때 주로 사용됨

12.디스패처
  1.서론
	디스패처는 코루틴이 실행되어야 할,즉 시작되거나 재개될 스레드를 결정할수있게 함
	또한 직접적으로 코루틴이 어디서 실행될지 정하는건 CoroutineContext임

  2.기본디스패처
	디스패처를 설정하지않으면 기본값은 cpu집약적인 연산을 수행하게 설계된 Dispatchers.Default를 사용함
	이건 코드가 실행되는 컴퓨터의 cpu코어 갯수와 동일한수의 스레드풀을 가지고있음(이론상 최적의 스레드수)
	
	추가적으로 runBlocking은 디스패처설정을 안하면 자신만의 디스패처를 사용해서,Dispatchers.Default를 사용하지않음

  3.기본디스패처를 제한하기
	비용이 많이드는 작업이 Dispatchers.Default의 스레드를 다 써버려서,같은 디스패처를 사용하는 다른코루틴이 실행될 기회를 제한한다면,
	이때 limitedParallelism을 사용해서 디스패처가 같은 스레드풀을 사용하지만,같은시간에 해당갯수이상 스레드를 사용하지못하게 제한할수있음
		val dispatcher11=Dispatchers.Default.limitedParallelism(5)
	이건 Default에만 사용하지않고 여러군데서 사용함(주로 Dispatchers.IO에서 사용함)

  4.메인 디스패처
	안드로이드같은 어플리케이션쪽에선,가장 중요한 스레드인 메인스레드라는 개념이 있음
	이 메인스레드는 ui와 상호작용하는데 사용되는 유일한 스레드임
	이 메인스레드는 조심스럽게 다뤄야함,이게 멈추면 전체앱이 멈춰버림
	이 메인스레드에서 코루틴을 실행할떈 Dispatchers.Main을 사용하면됨
	
	만약 블로킹하지않고 복잡한 연산을 쓰지않는다면 Dispatchers.Main을 써도되지만,
	Cpu집약적인 작업을 실행한다면 Dispatchers.Default로 실행해야함
	또한 Cpu는 별로 안들지만 스레드를 블로킹해야하는,시간이 오래걸리는 io작업을 하려면 Dispatchers.IO를 사용하면됨

  5.IO디스패처
	Dispatchers.IO는 파일을 읽고 쓸때,블로킹함수를 호출할때 등 io연산으로 스레드를 블로킹해야할때 사용하기위해 설계됨
	Dispatchers.Default는 프로세스가 가진 코어수로 제한이 되지만,여기는 추가적으로 더 많은 갯수의 스레드풀을 생성함
	
	이때 중요한건 Dispatchers.Default와 Dispatchers.IO는 같은 스레드풀을 공유한다는것
	즉 Dispatchers.Default로 실행되는 도중에 withContext(Dispatchers.IO){..}에 도달하면,
	대부분 같은스레드풀(Dispatchers.Default)로 실행되지만,
	만약 Default의 갯수를 넘겼을경우에는 스레드 수 제한이 Dispatchers.IO걸 사용하는식으로 적용됨(디폴트먼저쓰고 모자라면 io)
	즉 디폴트 12개 io 30개면,공유스레드풀에서 활성화된 갯수는 42개임
	
	그리고 스레드의 한도는 독립적이라서,다른 디스패처의 스레드를 고갈시키지않음
	
	Dispatchers.IO를 사용하는 가장 흔한경우는,블로킹함수를 호출해야할때 사용됨
	이때는
		suspend fun aa:abcd=withContext(Dispatchers.IO){..}
	이렇게 래핑해서 중단함수로 만드는게 가장좋음,이러면 쓰기도편함
	
	만약 저 래핑한 함수가 너무 많은 스레드를 블로킹할경우엔,limitedParallelism를 사용해야함

  6.커스텀스레드풀을 사용하는 io디스패처
	Dispatchers.IO에는 limitedParallelism을 위해 정의된 특별한 작동방식이 있음
	limitedParallelism은 독립적인 스레드풀을 가진 새로운 디스패처를 만드는데,이렇게 만들어진 풀은 원하는만큼 스레드수를 설정할수있음
	디스패처의 한도는 서로 무관하기때문에 아예 새로운 디스패처를 만들어버리고,갯수제한도 풀어주면 딱맞게 만들수있는거
	
	즉
		Dispatchers.Default의 limitedParallelism->기본스레드풀 안에서 갯수제한(12개중 5개만 쓰기)
		Dispatchers.io->새로운 io용 스레드풀(기본스레드풀과 별개)
		Dispatchers.io.limitedParallelism->완전히 새로운 io용 스레드풀(기본스레드풀과 별개고,Dispatchers.IO과도 별개)
	이렇게됨
	모든 디스패처는 스레드가 무제한인 스레드풀을 함께 공유함
	
	limitedParallelism을 사용하는 가장 좋은방법은,스레드를 블로킹하는 경우가 잦은 클래스에서,자기만의 한도를 가진 커스텀 디스패처를 정의하는것
	한도는 대충 딱 맞추는게 좋음,너무많으면 자원낭비고,너무적으면 회차를 돌아야해서 오래걸림
	가장 중요한건 이때 사용하는 스레드한도가 Dispatchers.IO을 비롯한 다른 디스패처와 무관하다는것
	그래서 얘가 뭔짓을하든 다른서비스를 블로킹하진않음

  7.정해진수의 스레드풀을 가진 디스패처
	만약 스레드풀을 직접 관리하길 원하면,Executors클래스로 스레드의 수가 정해져있는 스레드풀이나 캐싱된 스레드풀을 만들수있음
	이건 asCoroutineDispatcher로 디스패처로 변형하는것도 가능함
	
	주의할건,ExecutorService.asCoroutineDispatcher()로 만들어진 디스패처는 반드시 close로 닫혀야함
	이걸 까먹으면 그대로 스레드누수임
	또 다른문제는 이렇게 스레드풀을 만들면 스레드가 효율적으로 돌아가지않음
	사용하지않는 스레드가 다른서비스와 공유되지않고 살아있는채로 유지되기때문

  8.싱글스레드로 제한된 디스패처
	다수의 스레드를 사용하는 모든 디스패처에서는 공유상태문제를 생각해야함
	만약 신경쓰기귀찮다면 해결책중 하나로 싱글스레드를 사용할수있음
		val dispatcher11=Executors..newSingleThreadExecutor().asCoroutineDispatcher()
	이건 스레드 하나가 액티브한 상태로 유지되고,반드시 끝나고 닫아줘야한다는 문제점이 있어서,
	Dispatchers.Default나 병렬처리를 1로 제한한 Dispatchers.IO를 주로 사용함
		Dispatchers.Default.limitedParallelism(1)
	이 단일스레드는 스레드가 하나뿐이라서 스레드가 블로킹되면 순차처리된다는게 가장 큰 단점임

  9.프로젝트룸의 가상스레드 사용하기
	프로젝트룸은 버추얼스레드임(java 22)
	코틀린 코루틴을 사용할땐 크게 저걸 사용할일이 없고,
	저게 유용한경우는 스레드를 블로킹할수밖에 없는 Dispatchers.IO 대신 버추얼스레드를 사용할때 유용함
	
	중요하진않아서 필요해지면 보자

  10.제한받지 않는 디스패처
	Dispatchers.Unconfined는 디스패처를 스레드로 바꾸지않고,이건 시작한 스레드에서 실행이 되고,
	재개될때도 재개한 스레드에서 실행이 됨
	즉 해당 코루틴을 호출한 스레드에서 바로 실행이 되는것
	
	이건 단위테스트에서 유용하고,프로덕션에서 쓰긴 위험함

  11.메인디스패처로 즉시 옮기기
	코루틴을 배정하는것도 비용이 듬
	스레드에서 이미 실행되고있는 코루틴을 다시 배정하면 이동비용이 들고,잠시 지연이 생김(이전에 해당스레드에서 실행중인 코루틴을 기다려야하기때문)
	
	그래서 반드시 필요한경우에만 배정을 하는 Dispatchers.Main.immediate가 있음
	이건 메인함수에서 호출하면 스레드배정없이 즉시 실행됨

	메인디스패처 외에 다른 디스패처에서는 즉시 배정하는 옵션을 지원하지않고있고,
	그리고 이미 메인디스패처에서 호출이 되었다면
		withContext(Dispatchers.Main.immediate)
	를 쓰는게 더좋음

  12.컨티뉴에이션 인터셉터
	디스패칭은 코틀린언어에서 지원하는 컨티뉴에이션 인터셉션을 기반으로 작동함
	ContinuationInterceptor은 코루틴이 중단되었을때 interceptContiunation메서드로 컨티뉴에이션 객체를 수정하고 포장함
	또한 releaseInterceptedContinuation메서드가 컨티뉴에이션이 종료되면 호출됨
	
	컨티뉴에이션을 래핑할수있다는건,다양한 방법으로 제어할수있다는걸 의미함
	디스패처는 특정 스레드풀에서 실행되는 DispatchedContinuation으로 컨티뉴에이션 객체를 래핑하기위해 interceptContiunation를 사용함
	이떄 DispatchedContinuation은 디스패처가 작동하는 핵심요소임
	
	문제는 runTest도 같은 컨텍스트를 사용하고있다는것,그래서 키가 겹치는 문제가 있음(해결법은 밑에 테스트에서)

  13.작업의 종류에 따른 각 디스패처의 성능 비교
	cpu집약적인 연산에서는 Dispatchers.Default
	단순히 중단할때는 스레드수가 많은건 문제가 되지않음
	블로킹할때는 스레드수가 많을수록 종료시간이 빨라짐
	
	추가적으로 Dispatchers.IO는 cpu집약적인 연산에서 사용하면안됨,얘는 블로킹연산을 처리하기위한 용도라서 다른작업이 스레드전체를 블로킹할수있음

  14.요약
	Dispatchers.Default는 cpu집약적인연산에 사용됨
	Dispatchers.Main은 안드로이드에서 메인스레드에 접근할때 사용됨
	Dispatchers.Main.immediate는 Dispatchers.Main이 사용하는 스레드에서 실행되지만,꼭 필요할때만 재배정됨
	Dispatchers.IO는 블로킹연산을 해야할떄 사용됨
	병렬처리를 제한한 Dispatchers.IO나 특정 스레드풀을 사용하는 커스텀디스패처는 블로킹호출양이 아주 많을때 사용됨
	병렬처리가 1로 제한된 Dispatchers.Default나 Dispatchers.IO는 공유상태변경문제를 방지하기위해 사용됨
	Dispatchers.Unconfined는 코루틴이 실행될 스레드에 대해 신경쓸필요가 없을때 사용됨


13.코루틴 스코프 만들기
  1.CoroutineScope팩토리 함수
	CoroutineScope는 coroutineContext를 유일한 프로퍼티로 가지고있는 인터페이스임
	이걸 구현한 클래스를 만들고 내부에서 코루틴빌더를 직접 호출할수있지만,이방식은 자주사용되지않음
	
	대신 코루틴스코프 인스턴스를 프로퍼티로 가지고있다가,코루틴빌더를 호출할때 사용하는 방법이 선호됨
	
	코루틴 스코프 객체를 만드는 가장 쉬운 방법은 CoroutineScope 팩토리함수를 사용하는것
	이건 컨텍스트를 넘겨받아 스코프를 만듬,이때 잡이 컨텍스트에 없으면 구조화된동시성을 위해 job를 추가할수도있음

  2.안드로이드에서 스코프 만들기
	일반적으로 안드로이드에선 VieModels같은 view에서 코루틴이 시작하고,유스케이스나 저장소같은 계층에서는 보통 중단함수를 사용함
	코루틴을 프래그먼트나 액티비티에서 시작할수도 있음
	
	즉 인터페이스뷰모델에서 스코프를 정의한다음,
	구현뷰모델에서 그 스코프를 사용해서 launch같은 코루틴빌더를 사용하고,
	레포지토리같은곳에서는 suspend 함수를 만드는식으로 구성함
	또한 안드로이드에서는 메인스레드가 많은수의 함수를 호출해야하니,기본디스패처는 Dispatchers.Main을 선택하는게 좋음(인터페이스뷰모델에서 설정)
	
	또한 스코프를 취소가능하게 만들어야하니,인터페이스 뷰모델에서 Job을 직접 넣어주고
		protected val scope1=CoroutineScope(Dispatchers.Main+Job())
	onCleared()를 오버라이드해서 scope1.cancel()을 안에 넣어주면됨
	
	만약 전체스코프대신 스코프의 자식만 취소해야한다면
		override fun onCleared(){
			scope1.coroutineContext.cancelChildren()
		}
	을 사용하면되고
	해당스코프에서 시작된 코루틴들이 독립적으로 작동해야한다면(자식들이 하나가 뻗는다고 다뻗는걸 원하지않는다면) SupervisorJob을 사용할수있음
		protected val scope1=CoroutineScope(Dispatchers.Main+SupervisorJob())
	이렇게
	
	또한 잡히지않은 예외를 처리할때는,BaseActivity에 예외처리핸들러를 한번만 정의해두고,생성자로 뷰모델에 전달하는방식이 많이 사용됨(169p)

  3.viewModelScope와 lifecycleScope
	요즘은 스코프를 따로 정의하지않고 viewModelScope나 lifecycleScope를 자주 사용함
	얘들은 Dispatchers.Main+SupervisorJob()을 사용하고,뷰모델이나 라이프사이클이 종료되면 잡을 취소시킴
	
	스코프에서 특정컨텍스트(예외처리기)같은게 필요없다면 이게 젤편함

  4.백엔드에서 코루틴 만들기
	백엔드 프레임워크에서는 중단함수를 기본적으로 지원하고있음
	스프링부트는 컨트롤러함수가 suspend로 선언되는걸 허용하고,Ktor도 모든 핸들러는 기본적으로 중단함수임
	따로 스코프를 만들필요는 없음

  5.추가적인 호출을 위한 스코프만들기
	추가연산을 위한 스코프를 만들땐 함수나 생성자의 인자로 보통 주입함
	스코프의 호출을 중단하기위한 목적일경우,SupervisorScope를 사용하는것만으로 충분함
	또한 모든 예외는 로그를 통해 볼수있으므로,예외를 관제시스템에 보내고싶다면 CoroutineExceptionHandler를 사용해야함
	
	다른 디스패처를 설정하는것도 자주 사용되는 커스텀방법임
	스코프에서 블로킹호출을 한다면 Dispatchers.IO,안드로이드 메인뷰를 다뤄야하면 Dispatchers.Main

14.공유상태로 인한 문제
  1.서론
	코루틴을 사용할때는 동시사용에 대한 대비를 해야함 
	특히 리스트같은곳에서 동시에 접근하면 하나가 씹힐수있음

  2.동기화블로킹
	이런 문제를 해결하는 가장 고전적인 방법은 synchronized블록이나 동기화된 컬렉션을 사용하는것
	이거의 가장 큰 문제점은 synchronized블록 내에서 중단함수를 사용할수없고,
	코루틴이 자기차례를 기다릴때 스레드를 블로킹해버린다는것
	
	그래서 이건 사용되지않음

  3.원자성
	자바에서는 간단하게 사용할수있는 방법이 있는데,앞에 Atomic이 붙은 타입을 사용하는것
	얘들은 빠르고 스레드안전을 보장함
	
	이건 의도대로 동작하지만 사용성이 제한됨,즉 모든 연산에서 원자성을 가지는게 아니니까 잘 알아보고써야함
	보통 incrementAndGet이나 getAndUpdate같은걸 사용해야함
	
	또한 리스트같은 컬렉션의 경우 AtomicReference로 래핑할수있음,이땐 getAndUpdate로 값을 갱신하면됨
		val users=AtomicReference(listOf<User>())
		...
		user.getAndUpdate{it+newUser}
	이런식
	이건 하나의 변수나 하나의 레퍼런스의 안전을 보장하지만,좀 더 복잡한경우는 다른방법을 사용해야함

  4.싱글스레드로 제한된 디스패처
	가장 쉬운방법은 단일스레드를 쓰는것
	
	이때 두가지방법이 있는데
		코스 그레인드 스레드 한정:디스패처를 싱글스레드로 제한한 withContext로 전체함수를 래핑하는것,쉽지만 함수전체에서 멀티스레딩을 쓰지못함
		파인 그레인드 스레드 한정:상태를 변경하는부분만 래핑함,좀 더 번거롭지만 공유영역을 변경하지않는부분은 멀티스레딩할수있음
			즉 크리티컬섹션이나 cpu집약적인 부분에서는 더 나음,단 일반적인 중단함수에선 성능차이가 없음
	이렇게 됨
	
	대부분 표준디스패처가 같은 스레드풀을 사용하기떄문에,싱글스레드 디스패처는 쉽고 효율적임

  5.뮤텍스
	뮤텍스를 사용하는 방법도 있음,단 이건 뮤텍스 구현상 안에서 예외가 터지면 열쇠반납을 못하고 데드락걸리기때문에 finally에서 반드시 반납을 해줘야함
	이거의 장접은 스레드를 블로킹하지않고 코루틴을 중단시킨다는것,근데 좀 리스크가 큼
	코루틴이 중단되면 뮤텍스를 풀수없다는것도 있고
	
	그래서 전체함수를 뮤텍스로 래핑하는건 지양해야함,이걸 쓰려면 락을 두번걸지않고 중단함수를 호출하지않게 신경써야함
	
	보통싱글스레드를 선호함 그래서

  6.세마포
	세마포는 열쇠가 둘이상인 뮤텍스임
	이건 공유상태문제를 해결할순없지만,동시요청갯수를 제한할수있어 처리율 제한장치를 구현할때 도움이 됨
		val semaphore=Semaphore(10)
		suspend fun reqUser()=
			semaphore.withPermit{
				api.reqestUser("aaa")
			}
	이런식으로 사용함

  7.요약
	공유상태를 변경할때 가장 많이 쓰이는 방법은 싱글스레드제한된 디스패처를 사용하는것
	동기화가 필요한 특정 장소만 래핑하는 파인그레인드 스레드한정이나,전체함수를 래핑하는 코스 그레인드 스레드 한정도 사용할수있음
	또한 원자값이나 뮤텍스를 사용하는 방법도 있음

15.코틀린 코루틴 테스트하기
  1.서론
	중단함수의 동작을 테스트하는건 일반함수와 다르지않음
	runBlocking과 어설트만 사용해도 될정도임

  2.시간의존성 테스트
	근데 시간의존성을 테스트하기 시작하면 좀 달라짐
	즉 병렬처리되는지 이런것들을 테스트하기위해,모킹객체에 delay를 넣어두면 일반상황에서는 진짜 딜레이가 걸려서 테스트가 오래걸리게됨
	
	그래서 사용하는게 StandardTestDispatcher임
	이건 delay같은 의미없이 기다리는시간을 압축해줌(기다린것처럼 처리해줌)
 
  3.TestCoroutineScheduler와 StandardTestDispatcher
	delay를 호출하면 코루틴은 중단되고 설정한 시간 후에 재개됨
	이떄 TestCoroutineScheduler를 사용하면 delay를 가상시간동안 실행해서 실제시간이 흘러간상황과 동일하게 만들어줌
	
	TestCoroutineScheduler를 쓸떈 이를 지원하는 디스패처를 써야하는데,이게 StandardTestDispatcher임
	StandardTestDispatcher는 다른 디스패처와 달리 스레드선택에만 쓰이는게 아님,
	이거로 시작된 코루틴은 가상시간만큼 지나기전까지 실행되지않음
	코루틴을 시작하는 일반적인 방법은,실제시간처럼 작동하는 가상시간을 흐르게하여,
	그 시간동안 호출되었을 모든 작업을 실행하는 advanceUntilIdle를 사용하는것
	
	기본적으로 StandardTestDispatcher는 TestCoroutineScheduler를 만들기때문에 명시적으로 만들지않아도됨
	즉
		val dispatcher11=StandardTestDispatcher()
		CoroutineScope(dispatcher11).launch{
			print("a")
			delay(1000)
			print("a")
			delay(1000)
			print("a")
		}
		dispatcher11.scheduler.advanceUntilIdle()
	이렇게하면 순식간에 실행되지만,가상시간으로는 2초지난거임
	이떄 advanceUntilIdle를 빼버리면,영원히 실행됨
	
	또 다른 시간을 흐르게하는 방법은
		dispatcher11.scheduler.advanceTimeBy(1000)
		dispatcher11.scheduler.runCurrent()
	이렇게 시간을 넣어주고 돌리는것,그러면1000까지만 실행됨
	
	이렇게 StandardTestDispatcher를 사용해도되지만,더 쉬운건 TestScope를 사용하는것
	이건 StandardTestDispatcher의 모든 기능을 수행함
		val scope11=TestScope()
		scope.launch{
			print("a")
			delay(1000)
			print("a")
			delay(1000)
			print("a")
		}
		scope11.advanceTimeBy(1000)
		scope11.runCurrent()

  4.runTest
	runTest는 TestScope에서 코루틴을 시작하고,즉시 유휴상태가 될떄까지 시간을 흐르게함
	이걸 테스트할때는 제일 많이 씀
	
	코루틴에서는 스코프가 TestScope타입이므로 아무때나 currentTime을 사용할수있음
		@Test
		fun test1()=runTest{
			assertEquals(0,currentTime)
			delay(1000)
			assertEquals(1000,currentTime)
		}
		@Test
		fun test2()=runTest{
			assertEquals(0,currentTime)
			coroutineScope{
				launch{delay(1000)}
				launch{delay(1500)}
				launch{delay(2000)}
			}
			assertEquals(2000,currentTime)
		}
	이런식으로 사용할수있음이러면 가상시간을 쓰기때문에 테스트는 즉시끝나고,가상시간은 정확한 수치로 나오게됨

  5.백그라운드 스코프
	runTest함수는 다른함수처럼 스코프를 만들고,자식코루틴이 끝날때까지 기다림
	만약 무한루프를 돌때를 대비해서,backgroundScope를 제공함
	이걸 사용해서 코루틴빌더를 사용하면, 스코프가 종료될떄까지 기다리지않음,그래서 테스트가 기다릴필요없는 모든프로세스를 시작할떄 사용됨(뭐 띄울때)

  6.취소와 컨텍스트 전달 테스트
	구조화된 동시성 테스트를 할땐,중단함수로부터 컨텍스트를 받고 컨텍스트가 기대한값을 가지고있는지,잡이 적절한 상태인지 확인해야함
	이럴땐 mapAsync를 사용할수있음(27장)
	이건 순서를 보장하면서 비동기적으로 원소를 매핑함
	
	근데 이게 끝이 아니고,구조화된동시성을 지키는 중단함수가 정확하게 구현되어야함
	이걸 확인하는 가장 쉬운방법은,부모코루틴에서 CoroutineName같은 특정 컨텍스트를 명시하고,transformation으로 확인하는것
	
	중단함수에서 컨텍스트를 확인할떈,currentCoroutineContext나 coroutineContext프로퍼티를 사용하면됨
	코루틴빌더의 람다식이나 스코프함수에선 currentCoroutineContext를 써야하는데,
	현재 코루틴컨텍스트프로퍼티보다 CoroutineScope의 coroutineContext 프로퍼티가 우선하기때문
	
	취소를 확인하는 가장 쉬운 방법은,내부함수에서 잡을 참조하고,외부코루틴에서 코루틴을 취소한뒤,참조된 잡이 취소되는걸 확인하는것
	
	보통 이정도까지 할필요는없지만,라이브러리만들땐 쓰기좋음

  7.UnconfinedTestDispatcher
	이건 StandardTestDispatcher말고 다른 선텍지인데,
	이건 StandardTestDispatcher와 다르게 코루틴을 시작했을때 첫 지연 전까지 모든 연산을 즉시 수행함

  8.mock 사용하기
	모킹객체에서 delay를 사용하기 쉽지만,명확히 드러나지않음
	그래서 테스트함수에서 delay를 선호하는걸 보통 선호함

  9.디스패처를 바꾸는 함수 테스트하기
	보통은 runBlocking로 테스트하면되지만,함수가 실제로 디스패처를 바꾼다면,
	호출하는 함수를 모킹해서 사용한 스레드의 이름을 가져오는방법으로 확인할수있음
	
	만약 극히 드물지만,디스패처를 바꾸는함수에서 시간의존성을 테스트해야하면 209p참조

  10.함수실행중에 일어나는일 테스트하기
	함수를 새로운 코루틴에서 시작하고,바깥에서 가상시간을 조절하면서 테스트하면 함수실행중에 현재 상태를 시계열로 계속 확인할수있음
	즉 advanceTimeBy을 사용하면서 계속 시간진행을 시키면서 assertEquals로 확인하는방식

  11.새로운 코루틴을 시작하는 함수 테스트하기
	보통 백엔드에선 스프링에서 시작되지만,
	직접만든 스코프내부에서 코루틴을 시작할땐,스코프의 일부로 StandardTestDispatcher를 사용할수있음

  12.메인디스패처 교체하기
	단위테스트에는 메인함수가 없음,그래서 메인스레드 대신 쓰게 Dispatchers에는 setMain확장함수가 있음
	
	보통 @BeforeEach에다가 이 셋업을 넣고,테스트가 끝난뒤에는 AfterEach로 Dispatchers.resetMain()으로 반드시 초기화를 시켜줘야함

  13.코루틴을 시작하는 안드로이드함수 테스트하기
	이때까지했던거 총집편,실전연습

  14.룰이있는 테스트 디스패처 설정
	룰은 테스트클래스의 수명동안 반드시 실행되어야할 로직을 포함함(@BeforeEach,@AfterEach)
	보통 여기다가 뭐 넣기좋고,안드로이드 코루틴 테스트를 할땐 자주 사용함

16.채널
  1.서론
	채널은 송신자와 수신자의 수에 제한이 없고,채널을 통해 전송된 모든값은 단 한번만 받을수 있음
	채널은
		SendChannel:원소를 보내거나 채널을 닫는용도로 사용
		ReceiveChannel:원소를 받을때 사용
	이 두개의 인터페이스를 구현한 하나의 인터페이스임
	
	이 두 인터페이스는 구분되어있고,둘중 하나만 노출시켜서 채널의 진입점을 제한하는것도 가능
	이떄 Send와 Receive 둘 다 모두 중단함수(suspend)임
	원소를 보내고 받는 함수가 중단함수인건 필수적인 특징임
	
	또한
		receive를 호출했는데 채널에 원소가 없다면,코루틴은 원소가 들어올떄까지 중단됨
		send를 호출해서 던질려는데,채널이 꽉찼다면 빌때까지 중단됨
	채널은 송신자와 수신자 둘다 수에 제한이 없지만,일반적으로는 채널의 양쪽에 하나씩만 있는게 일반적임
		suspend fun aaa()=coroutineScope{
			val channel1=Channel<Int>()
			launch{
				repeat(5){index->
					delay(1000)
					channel1.send(index*2)
				}
			}
			launch{
				repeat(5){index->
					val received=channel1.receive()
					print(received)
				}
			}
		}	
	이건 그냥 생산자소비자패턴임,이론적으로는 send로 던지고 received로 받으면되지만,문제는 예외처리(비정상종료시 채널이 안닫힘)와 무한루프처리임
	이걸위해 무한루프을 위해 for문을,예외처리를 위해 produce함수를 사용하는게 좋음
		suspend fun aaa()=coroutineScope{
			val channel1=produce{
				repeat(5){index->
					delay(1000)
					send(index*2)
				}
			}
			for(element in channel1){
				print(element)
			}

		}
	채널을 for문을 돌리면 채널이 닫힐때까지 루프를 돌고,
	produce는 빌더로 시작된 코루틴이 어떻게 종료되든 상관없이 채널을 반드시 닫아줌(finally로 close하는느낌)
	그래서 produce빌더로 채널을 만드는게 가장 안전하고 편리함

  2.채널타입
	채널은 용량에따라 4가지로 구분할수있음
		Unlimited:용량제한 버퍼가 없고,send가 중단되지않음
		Buffered:특정 용량 크기 또는 기본값인 64로 설정된 채널
		Rendezvous(랑데뷰):용량이 0이라서 송신자와 수신자가 만날떄만 원소를 교환함
		conflated:버퍼크기가 1인 채널인데,새로운 원소가 기존원소를 대체함
	채널설정은 produce(capacity=Channel.UNLIMITED){} 이런식으로 설정할수있음
	만약 기본값으로 쓰면(produce{})랑데뷰로 동작하고,conflated를 사용하면 새로운값을 보내면 기존값이 유실됨(최신값만 살아있음)

  3.버퍼 오버플로일때
	버퍼가 꽉찼을때 동작을 커스텀할수있는데,
		suspend(기본값):버퍼가 가득차면 send를 멈춤
		drop_oldest:버퍼가 가득차면 가장 오래된 원소가 제거됨
		drop_latest:버퍼가 가득차면 가장 최근의 원소가 제거됨
	즉 conflated는 버퍼크기를 1로잡고 drop_oldest로 설정한거임
	
	이걸 설정하려면 produce를 사용할수없고 채널을 만들어서 설정해야함

  4.전달되지 않은 원소 핸들러
	onUndeliveredElement 파라미터는,원소가 어떠한 이유로 처리되지않았을때 호출됨
	보통 채널이 닫히거나 취소될때를 의미하지만,send나 receive등에서 에러를 던질때도 발생할수도 있음
	보통 채널에서 보낸 자원을 닫을떄 사용함
		channel1=Channel<Resource>(
			capacity,
			onUndeliveredElement={resource->resource.close()}
		)
	이렇게 람다를 넣으면됨(마지막 람다니까 그냥 마지막에 붙여도되긴함)

  5.팬아웃
	여러 코루틴이 하나의 채널로 원소를 받을때,원소를 적절히 처리하려면 반드시 for루프를 써야함
	이렇게 채널을 여러개 달아두면,fifo로 선입선출해서 가져감

  6.팬인
	여러 코루틴이 하나의 채널로 원소를 보낼땐,그냥 채널 하나로 던지면되고
	만약 다수의 채널을 하나로 합쳐야할땐 produce함수에서 fanIn함수를 사용해서 여러채널을 합칠수있음(리스트채널을 for돌리는거)
	//이건 있다는건지 만들라는건지 모르겠음

  7.파이프라인
	한 채널에서 받은 원소를 다른채널로 전송하는걸 파이프라인이라고 부름
	이럴땐 그냥 채널을 파라미터로 받아서 그거로 for돌려서 send하면됨

  8.통신의 기본형태로서의 채널
	채널은 서로 다른 코루틴이 통신할때 유용함
	충돌이 발생하지않고 공평함을 보장함(선입선출)
	또한 파이프라인을 설정할수있고,fanIn으로 생성된 결과를 하나로 합칠수있음
	
  9.실제 사용 예
	전형적인 채널을 사용하는 예는,데이터가 한쪽에서 생성되고,다른쪽에서 데이터를 처리하는것
	보통 서버에서의 알림,시간이 흐르면서 검색결과를 업데이트하는것 등
	
	보통은 채널과 플로우를 함께 사용하는게 좋음
	순수한 채널은 좀 복잡한 처리를 요할때 유용함,즉 큐를 위해 사용하면서,예외처리가 된다는느낌

  10.요약
	채널은 송수신자수에 제한이없고,
	채널로 보내진 데이터는 단 한번 받는게 보장됨
	보통 produce로 생성함
	채널은 특정 작업에 사용되는 코루틴의 수를 조절하는 파이프라인을 설정할때 사용될수 있음
	보통 플로우랑 묶어서 사용함

17.셀렉트
  1.서론
	셀렉트는 가장 먼저 완료되는 코루틴의 결과를 리턴해주는 함수임
	이걸 사용해서 여러 채널중 버퍼에 남은공간이 있는 채널을 먼저 확인해서 데이터를 보내거나,
	이용가능한 원소가 있는 채널로부터 데이터를 받을수있는지 여부도 확인할수있고,
	여러 데이터소스로 부터 나오는 결괏값을 합칠수도 있지만,잘 사용되진않음

  2.지연되는 값 선택하기
	이건 그냥 async를 여러개 만들고 셀렉트안에서 await를 다 걸어서 가장 빨리나오는애를 리턴하는 방식임
	구조상 매우 비효율적이기때문에 잘 사용되진않음

  3.채널에서 값 선택하기
	채널에서 사용할때 주로 사용하는 함수는
		onReceive:채널이 값을 가지고있을때 선택됨,값을 받아서 람다식의 인자로 사용하고,이게 선택되면 select는 람다식의 결과값을 반환
		onReceiveCatching:채널이 값을 가지고있거나 닫혔을때 선택됨,
			값이나 닫힘을 나타내는 ChannelResult를 받고,이걸 람다식의 결과값으로 사용
			이게 선택되면 람다식의 결과값을 반환
		onSend:채널버퍼에 공간이 있을때 선택됨,채널에 값을 보내고 채널의 참조값으로 람다식을 수행함,이게 선택되면 Unit를 반환
	즉 이건 채널 여러개를 두고 아무데나 던져도될때,빈곳에 던지기위해서 사용할수있음
	또한 여러채널중 아무데서나 받아도될때 받기위해서도 사용할수있음
	
18.핫 데이터소스와 콜드 데이터소스
  1.서론
	핫스트림데이터는 List직접연산이고,콜드스트림데이터는 Sequence연산이라고 생각하면됨
	또한 Channel은 핫이고,Flow는 콜드임

  2.핫vs콜드
	핫은 데이터를 소비하는것과 무관하게 원소를 생성하지만,콜드는 요청이 있을때만 작업을 수행하고,아무것도 저장하지않음
	리스트연산(핫)에서도 리스트연산은 한 함수를 전부 실행하고,중간리스트를 만들어서 다음 리스트를 실행하지만,
	시퀸스연산(콜드)에선 한 원소를 가지고 한 함수를 실행하고,다음함수를 실행하는식으로 레지하게 실행됨
	
	이런 차이때문에 콜드스트림은
		무한할수있음
		최소한의 연산만 수행(중간에 필터등으로 없어지는애들은 뒤에거 수행안함)
		중간값 보관이 필요없어서 메모리를 적게 사용함
	핫스트림은
		항상 사용가능한 상태(중간리스트가 나오니까)
		여러번 사용되었을때 매번 결과를 다시 계산할 필요가 없음
	이런 차이가 있음
  3.핫채널,콜드플로우
	플로우를 생성하는 가장 일반적인 방법은 produce자리에 flow를 써서 빌더를 사용하는것
	즉 채널이나 플로우나 사용방식자체는 비슷함(시퀸스와 일반연산이 비슷한것처럼)
	
	근데 동작방식은
		채널:핫이라 값을 곧바로 계산,별도의 코루틴에서 계산을 수행,수신자가 없으면 데이터생성이 중단됨(버퍼가 가득차면)
			소비를 신경쓰지않고,수신자수를 신경쓰지않음
		플로우:값을 필요할때만 생성,즉 빌더가 아니고 어떤처리도 하지않음,그래서 CoroutineScope가 필요없음
			얘는 빌더를 호출한 최종연산의 스코프에서 실행되고,플로우의 최종연산은 처음부터 데이터를 처리함
			즉 채널처럼 공유자원이 아니고,단지 요청이 들어오면 안에있는것들을 돌려서 가져오는느낌에 가까움

  4.요약
	핫은 가능한 빨리 원소를 만들고 저장하고,원소소비와 무관하게 생성함
	콜드는 최종연산에서 값이 필요하면(요청받으면) 생성함,중간과정의 모든 함수는 무엇을 해야할지만 정의한거고,최종연산이 없으면 수행되지않음
	원소를 저장하지않고 필요할때 원소를 생성하고,연산은 최소한으로 수행되고 무한정일수있음

19.플로우란 무엇인가?
  1.서론
	플로우는 비동기적으로 계산해야할 값의 스트림을 나타냄
	Flow인터페이스는 떠다니는 원소들을 모으고,플로우의 끝에 도달할때까지 각 값을 처리하는걸 의미하고,
	Flow의 collect는 컬렉션의 forEach와 비슷함
	
	Flow의 유일한 멤버함수는 collect고,다른 함수들은 다 확장함수로 정의되어있음
	collect는 시퀀스의 toList같은거임(여기까지 실행하라는 그런느낌)

  2.플로우와 값들을 나타내는 다른 방법들의 비교
	한번에 모든 값을 만들때는 list나 set을 사용하고,이때 얘들은 모든 원소의 계산이 완료된 컬렉션이라는걸 명심해야함
	즉 list나 set은 저 자체로 완결성을 가지고,가져다가 쓰면됨
	
	반대로 sequence는,원소를 하나씩 계산하고,sequence자체는 어떻게 처리할지에 대한 방법이지,저거자체로 완결성을 가지지않음
	시퀸스는 cpu집약적인 연산이나 블로킹연산일때,필요할때마다 값을 계산하는 플로우를 나타내기 적절함
	시퀀스의 최종연산은 중단함수가 아니라서,시퀸스빌더 내부에 중단점이 있다면 값을 기다리는 스레드가 블로킹됨
	그래서 시퀸스빌더의 스코프내에서는 SequenceScope리시버에서 호출되는 함수(yield,yieldAll)외에 다른 중단함수를 사용할수없음
	
	이 제약은 코루틴중단대신 스레드중단을 일으킬수있기때문에 추가된거
	그래서 만약 중단함수를 사용해야할떄,플로우를 사용하면됨
	시퀸스는
		데이터소스의 개수가 많거나 무한하거나
		원소가 무겁거나
		원소를 필요할때만 계산하거나 읽는 지연연산이 필요할떄
	만 정확히 들어맞음
	
	즉 시퀸스는 블로킹연산이 될수있는 위험성이 있음
	그래서 사용되는게 플로우임
	플로우를 사용하면 코루틴이 연산을 수행하는데 필요한 기능을 전부 사용할수있고,
	플로우빌더와 연산은 중단함수고 구조화된동시성과 적절한 예외처리를 지원함
	
	플로우는 코루틴을 사용해야하는 데이터 스트림으로 사용되어야함
	예를들어 api로 사용자를 얻어서 사용자 스트림을 만드는데 사용될수있음
	플로우함수를 호출함으로써 요청이 들어오자마자 처리할수있고,얼마나 많은 요청을 처리할지도 정할수있음
		abcFlow.toList():전체를 다 가져옴
		abcFlow.find{it.id==id}:특정값을 찾을떄까지 받아옴
	이렇게 사용함

  3.플로우의 특징
	collect와 같은 플로우의 최종연산은,스레드를 블로킹하는 대신 코루틴을 중단시킴
	플로우는 코루틴컨텍스트를 활용하고 예외를 처리하는등 코루틴 기능도 제공함
	플로우는 취소가능하고,구조화된 동시성을 가지고있고,
	플로우빌더는 중단함수가 아니고 어떤 스코프도 필요로 하지않고,플로우의 최종연산은 중단가능하고,
	연산이 실행될때 부모코루틴과의 관계가 정립됨(실행시 스코프가져옴)
	
	즉 플로우빌더는 중단함수가 아니라서 플로우는 스코프밖에서 생성될수있고,
	collect계열의 최종연산이 호출될때의 부모스코프를 가져감

  4.플로우명명법
	플로우는 헬퍼함수,플로우빌더등에서 시작되어야함
	플로우의 마지막연산은 최종연산이라 불리며,중단가능하거나 스코프를 필요로하는 유일한 연산임(collect등)
	시작연산과 최종연산 사이에 플로우를 변경하는 중간연산을 가질수있음

  5.실제사용예
	보통 채널보단 플로우를 쓰는 경우가 많음
	플로우가 사용되는 전형적인 예는
		웹소켓같이 서버가 보낸 이벤트를 통해 전달된 메시지를 받는경우
		텍스트입력이나 클릭등 액션이 감지된경우
		센서나 위치,지도등 기기정보변경을 받는경우
		db변경을 감지하는경우
	즉 서로 세션을 열어두고,이벤트발생을 처리할때 주로 사용됨
	
	이밖에도 동시성처리를위해 사용하기편함
	async보다 더 좋은건,처리율제한을 걸수있다는점

  6.요약
	플로우는 시퀸스와 달리 코루틴을 지원하고,비동기계산되는 값을 나타냄

20.플로우의 실제 구현
	대충 어떻게 구현됐는지같은거라 생략할거임

21.플로우 만들기





















