1.코틀린코루틴을 배워야하는 이유
  1.안드로이드에서 코루틴사용
	코루틴대신 사용할수있는것들은
		스레드전환:블로킹이 가능한 스레드를 먼저 사용하고,이후 메인스레드로 전환
		  단점:
		    스레드가 실행되면 멈출수없어서 메모리누수될수있음
			스레드를 많이생성하면 비용이 많이듬
			스레드를 자주 전환하면 복잡도가 올라가고 관리가 어려움
			코드가 쓸데없이 길어지고 이해가 어려움
		콜백:함수를 논블로킹으로 만들고,함수작업이 끝나면 호출될 콜백함수 넘겨주기
		  단점:
		    중간에 작업취소 어려움
			데이터소스가 여러곳일경우,동시처리어려움
			콜백지옥
			작업의 순서다루기가 어려움
		rxJava,리액티브스트림:데이터스트림내에서 일어나는 모든연산을 시작,처리,관찰 가능
		  단점:
		    콜백보다 모든면에서 낫지만,구현이 복잡함
	들이 있음,위에서 밑으로 내려갈수록 최신이고,좋음
	
	코틀린 코루틴의 핵심은 코루틴을 특정지점에서 멈추고 이후에 재개할수있다는것
	이거로 우리가 짠 코드를 메인스레드에서 실행하고,api로 데이터를 얻어올때 잠깐 중단시킬수도 있음
	코루틴을 중단시켰을때 스레드는 블로킹되지않고,뷰를 바꾸거나 다른 코루틴을 실행하는등의 또 다른 작업이 가능함
	데이터가 준비되면 코루틴은 메인스레드에서 대기하고있다가,메인스레드가 준비되면 멈춘지점에서 다시 작업을 수행함
	
	코루틴의 코드는 메인스레드에서 실행되지만,스레드를 블로킹하진않음
	코루틴의 중단은 데이터가 오는걸 기다릴때 코루틴을 잠시 멈추는방식으로 작동하고,이때 멈춰있는동안 메인스레드는 다른작업을 할수있음
	데이터가 준비되면 코루틴은 다시 메인스레드를 할당받아 이전에 멈춘지점부터 다시 시작함
	
	사실 코루틴자체는 async await와 큰차이없고,동작자체도 똑같음
		fun abc(){
			val user=async{user.getUser()}
			val prodect=async{pro.getProdect()}
			...(중간작업들)
			print(user.await(),prodect.await())
		}
	이러면 async를 먼저 다 날려두고,다른작업들을 처리하다가 await를 만나면 값이 들어왔는지 확인하고,
	안들어왔으면 다 들어올때까지 다른작업하다가 다 들어오면 처리하는느낌임
	
	또한 코틀린 코루틴은 for문을 논블로킹으로 처리하기같은 이런일을 할때 효과적임
	
  2.백엔드에서의 코루틴사용
	백엔드에서 코루틴을 사용할때 가장 큰 장점은 간결성임
	rxJava와 다르게 코루틴은 코드의 변화를 거의 주지않을수있음
	단순히 suspend제어자를 함수에 추가하는것만으로 충분함
	
	또한 스레드에 비해 비용이 싸다는 장점도 있음


2.시퀸스 빌더
    파이썬이나 자바스크립트는 제한된 형태의 코루틴을 사용함
		비동기함수(async,await)
		제너레이터함수(값을 순차적으로 반환하는 함수)
	코틀린에서는 비동기함수는 지원하고,제너레이터 대신 시퀸스를 제공함(그 컬렉션시퀸스같은거 맞음)
	
	시퀸스는 컬렉션과 비슷한개념이지만,필요할때마다 값을 하나씩 계산하는,lazy하게 동작함
	이건 요구되는 연산을 최소한으로 수행할수있고,메모리사용이 효율적이라는 장점이 있음(시퀸스가 없으면 중간리스트가 생기는데,저거쓰면 하나씩처리하니까)
	
	시퀸스자체로 동작을 시킬때는,제너레이터처럼 1순회 돌때마다 yield가 있는 위치까지 돌린후,그뒤에는 그위치부터 시작함
	
	시퀸스는 피보나치나 난수,임의의문자열들을 생성할때도 사용할수있음
	시퀸스빌더를 사용할때 주의점은,yield대신 중단함수를 사용하면 안된다는것
	중단이 필요하다면 시퀸스대신 플로우를 사용하는게 더 나음(전반적으로도 플로우가낫긴한듯)

3.중단은 어떻게 작동할까
	중단은 코루틴의 핵심임
	중단이란 실행을 중간에 멈추는것,실행을 멈추고 다른일을 하다가 다시 해당작업을 수행할수있음
	코루틴은 중단되면 Continuation객체를 반환함,이건 세이브포인트고,이걸 사용해서 멈췄던곳에서 다시 코루틴을 실행할수있음
	
	여기서 스레드와의 차이가 나타나는데,스레드는 저장이 불가능하고 멈추는것만 가능하고,코루틴은 중단됐을때 어떤 자원도 사용하지않고,
	다른스레드에서 시작할수있고,컨티뉴에이션 객체는 직렬화와 역직렬화가 가능하고,다시 실행될수있음
	
  1.재개
	작업을 재개하려면 코루틴이 필요하고,코루틴은 runBlocking나 launch와 같은 코루틴빌더를 통해 만들수있음
	중단함수는 말그대로 코루틴을 중단할수있는 함수고,이는 중단함수는 반드시 코루틴,혹은 다른 중단함수에 의해서 호출되어야함을 의미함
	즉 중단함주는 중단할수있는곳이 필요함
	
	코틀린은 코루틴내부에서 suspend가 붙은 main함수를 실행하고,중간에 중단될경우(suspendCoroutine),
	인자로 들어간 람다함수가 중단되기직전에 실행되고,이 함수는 컨티뉴에이션객체를 인자로 받음
	
	즉 중단된 이후에는 컨티뉴에이션 객체를 사용할수없기때문에,실행이 끝나기전에 람다함수로 끼어들어가서 사용하는것
	즉 람다함수에는 재시작을 위한 로직을 넣을수있음
	
	또한 suspendCoroutine에서는 잠깐동안 정지된뒤 재개되는 다른 스레드를 실행할수도있음
	즉 정해진시간뒤에 코루틴을 다시 재개하는 함수를,다른 스레드를 써서 만들수있다는거
	보통은 이렇게 직접하지않고 알람라이브러리,ScheduledExecutorService를 사용하긴하지만 동작원리자체는 같음
	이걸 코틀린코루틴에서 만들어둔게 delay함수임
	
	즉 일정시간이 지나면 continuation.resume(Unit)를 호출하게 알람을 설정하는것
	
  2.값으로 재개하기
	이때resume에 Unit를 넣는이유와,suspendCoroutine에 Unit를 제네릭타입인자로 사용하는이유는,
	suspendCoroutine을 호출할때 컨티뉴에이션 객체로 반환될 값의 타입을 지정할수있는데,
	이떄 resume로 반환되는 값은 반드시 지정된타입과 같은타입이어야하기때문
	
	즉 코루틴이 있으면 값을 요청하고,중단한후에 데이터를 받고나면 받은 데이터를 resume함수로 보내줘 라고
	컨티뉴에이션 객체를 통해 라이브러리에 전달할수있음
	그러면 스레드는 다른일을 할수있고,데이터가 도착하면 스레드는 코루틴이 중단된지점에서 재개하게됨
	즉 resume를 람다에 넣어서,값이 들어오면 재개하게 할수있는것

  3.예외로 재개하기
	만약 값을 받아오는데 실패했거나 하는 이유로 에러가 떴다면,코루틴이 발생한곳에서 예외를 발생시켜야함
	우리가 사용하는 모든 함수는 값을 반환하거나 예외를 던지고,이건 suspendCoroutine도 마찬가지임
	resume가 호출될때 suspendCoroutine는 인자로 들어온 데이터를 반환하고,
	resumeWithException이 호출되면 중단된지점에서 인자로 넣어둔 예외를 던짐
	
  4.함수가 아닌 코루틴을 중단시킨다
	여기서 중요한건 함수가 아닌 코루틴을 중단시킨다는것
	중단함수는 코루틴이 아니고,단지 코루틴을 중단시킬수있는 함수임
	즉
		continuation:Continuation<Unit>?=null
		suspentFunction()//continuation변수를 채우는 코루틴
		continuation?.resume(Unit)
	이런식으로 코드를 짜면 resume가 호출되지않고,다른스레드나 다른코루틴으로 재개하지않으면 프로그램은 실행된상태로 유지됨
	즉 메모리누수임
	그러니까 람다


4.코루틴의 실제 구현
  스킵해도됨 중요하지않은 구현방식이니까
  1.컨티뉴에이션 전달방식
	컨티뉴에이션은 함수에서 함수로 인자를 통해 전달되고,도중에 중단되면 null을 줘야하니 Any에서 Any?로 자동으로 바뀜
	이때 중단함수는 COROUTINE_SUSPENDED를 반환함
		suspend fun getUser():User?//이건
		suspend fun getUser(continuation:Continuation<*>):Any?
	이렇게 바뀜

  2.아주 간단한 함수
	suspend가 붙는다는건,함수의 매개변수에 continuation:Continuation<*>이 추가되고,
	함수의 리턴값으로 Continuation이 하나 추가된다는것과 비슷함
	이때 해당 함수가 실행되면,해당함수는 받은 매개변수 continuation을 자신만의 컨티뉴에이션인 aaContinuation으로 포장함
	즉 데코레이터로 싸는거,이때 클래스에 내래퍼가 없을때만 포장을해야함(내가 이미 포장한후에 중단했으면,재포장될수있으니)
	
	함수가 시작되는시점은 함수의 시작점과,중단이후 재개시점 두곳이고,현재상태는 label이라는 필드로 저장됨(해당 continuation의 시작위치)
	또한 함수가 중단되면,COROUTINE_SUSPENDED가 반환되고,이건 해당 함수를 호출한 함수부터 콜스택의 모든 함수를 다 넣어둠
	따라서 중단이 일어나면 콜스택의 모든 함수가 종료되고,이 중단된 코루틴을 실행하던 스레드는 다른코드들이 사용할수있어짐
	
  3.상태를 가진 함수
	즉 함수가 중단되면,현재상황과 실행위치,콜스택,변수등을 전부 상태로 기록하고,이걸 객체로 바꾼게 Continuation객체임

  4.값을받아 재개되는함수
	만약 중단함수로부터 값을 보내야할때는 값으로 재개되면 성공,예외로 재개되면 실패를 던지면됨

  5.콜스택
	함수a가 함수 b를 호출하면 가상머신은 a의 상태외 b가 끝나면 실행이될지점을 어딘가에 저장해야하는데,이걸 콜스택이라고 함
	코루틴을 중단하면 스레드를 반환해 콜스택의 정보가 사라짐,이걸 해결하기위해 중단객체에 컨티뉴에이션객체에 콜스택을 때려박음
	
	또한 컨티뉴에이션객체는 하나의 컨티뉴에이션이 다른하나를 참조하고,참조된객체가 또 다른 컨티뉴에이션객체를 참조하는식의 데코레이터패턴으로 구성됨
	컨티뉴에이션객체가 재개될때 각 컨티뉴에이션 객체는 자신이 담당하는 함수를 먼저 호출하고,함수의 실행이 끝나면 자신을 호출한 함수의 컨티뉴에이션을 재개함
	이걸 스택이 끝날때까지 반복함

  6.중단함수의 성능
	함수를 상태로 나누는건 매우 코스트가 낮고,컨티뉴에이션에 상태를 저장하는것도 간단함,그냥 메모리위치만 넣어주면되니까

  7.요약
	중단함수는 상태머신과 비슷해,함수가 시작될때외 중단함수를 호출한뒤의 상태를 가짐
	상태를 나타내는값과 로컬데이터는 컨티뉴에이션객체에 저장됨
	호출된 함수의 컨티뉴에이션객체는 호출한 함수의 컨티뉴에이션을 데코레이팅함,즉 컨티뉴에이션은 콜스택의 역할을 할수있어짐

5.코루틴:언어차원에서의 지원 vs 라이브러리

















