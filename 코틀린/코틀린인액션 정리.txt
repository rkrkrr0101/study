1.코틀린이 무엇인가
	스킵
2.코틀린 기초
	코틀린에선 if가 문이 아닌 식임
	그래서 자체적으로 값을 만들어낼수있음
		if(a>b) a else b
	이런식으로 if안에서 값을 뽑을수있음 삼항연산자처럼
	
	변수는
		val abc:자료형=값
		val abc=값
	이렇게 할수있음,자료형생략하면 타입추론해서 넣음,이땐 값이 무조건있어야함
	val은 변경불가능한 변수,var은 변경가능한 변수
	이때 변경불가능은 단순참조값을 변경못한다는거라,리스트를 대입했을경우 리스트를 통째로 바꾸진못하고,리스트값을 추가삭제하는건 가능
	val은 단 한번만 초기화가 가능함,이 초기화는 선언할때말고 뒤에서 해도됨(if문으로 여러값중 하나로 초기화가능)
	
	${변수명}으로 문자열내에서 변수를 편하게삽입할수있음
	
	코틀린에서 클래스접근자의 디폴트는 퍼블릭임,그리고 기본적으로 필드와 게터,혹은 세터까지도 자동으로 묶어서 선언됨(프로퍼티)
	val일경우 게터까지,var일경우 세터까지 자동으로 선언됨,이 세터를 지울방법은 없음
		class Person(
			val name:String,
			var isMarried:boolean
		)
	이런식으로 선언함
	이게 자바코드로 바뀔때 자동으로 getter를 생성하고 사용하는식으로 바뀌는거고,getName()같은 메서드가 숨어있다고 봐도됨
	그리고 추가적으로,프로퍼티의 이름의 시작이 is로 시작하는경우 getisMarried가 아닌,isMarried()로 getter를 만듬
	
	이 접근자는 커스텀으로 만들수있는데,즉 식을 넣을수도있음
		class Rectangle(val height:Int,val width:Int){
			val isSquare:Boolean
				get(){
				return height==width
				}
		}		
	이런식으로 해당 필드의 게터를 커스텀할수있음
	줄여서
		get()=height==width
	이렇게도 가능(어짜피 두개는 같으니까)
	
	코틀린에선 한파일안에 여러클래스를 넣는일이 자주있고,이걸 주저해서는안됨(크기가 작을경우)
	
	enum클래스는 기본적으로
		enum class Color{
			RED,GREEN
		}
	이런식이고,여기에서 필드를 추가하고,해당값마다 생성자를 추가하고,함수를 추가할수있음
		enum class Color(val r:Int,val g:Int,val b:Int){
			RED(255,0,0),GREEN(0,255,0); //이땐 무조건 세미콜론을 찍어야함
			fun rgb()=(r*256+g)*256+b
		}
	이렇게
	
	스위치문은 when을 사용하면됨
	여기선 break를 안써도되고,여러값을 묶어서 분기처럼 사용할수도있음
	그리고 when의 인자로 아무객체나 사용할수있음
		when(setOf(a1,a2))
			setOf(RED,GREEN)->ORANGE
			else->throw Exception("error")
	이렇게 집합으로 받아서 순서상관없이 그값이 있나 확인하는거도 가능
	뭐 스위치문쓸일이 많진않지만
	단 이렇게 객체를 사용하면,객체를 만들고 비교하기때문에,메모리에서 약간 손해보긴함,그래서 메모리가 중요하면 풀어서 or로 써야함
		
	코틀린에선 is을 사용해서 변수타입을 검사함,이때 저걸 통과하면,자동으로 해당타입으로 캐스팅을 해서 밑에서 사용할수있음
	즉 as써서 명시적으로 타입캐스팅할필요가 없음
	그리고 블록의 마지막값은 자동으로 해당값이 출력됨
	즉 블록의 마지막에 a가 있을경우 해당식의 출력으로 a가 나감
		a=a+b
	이거 축약된게,그 if문 삼항연산자임,값만 나열했는데 출력되는거
	
	반복문은 while와 for가 있는데,
	while는 똑같고,
	do-while는 1번실행을 강제하는 while
	for는 기본적으로 foreach라고 보면됨
	그래서 n번 반복할땐
		for(i in 1..100){}
	이렇게사용하면됨 파이썬이랑 같음
	그리고 역순으로 내려갈땐
		for (i in 100 downTo 1 step 2){}
	이러면 100부터 2씩 깍임
	
	맵에 대해 for 돌릴때도
		for((key,value) in abcMap){}
	이렇게 쌍으로 받으면됨//구조분해
	맵에 값 넣을때도
		abcMap[키값]=넣을값
	이렇게 하면 됨,put안써도됨
	그리고 리스트에서 인덱스도 같이돌리고싶으면
		for((index,element) in abcList.withIndex())
	하면됨
	
	in을 사용해 컬렉션안에 해당값이 있는지,!in을 사용해 컬렉션안에 해당값이 속하지않는지 검사할수있음 
		return 'c' in 'a'..'z'
	이건 comparable인터페이스를 구현한 모든클래스에서 가능함


	코틀린에서 예외처리도 try catch finally를 사용함
	자바와의 차이점은,모든체크예외는 언체크예외로 변환되서 따로 명시적으로 throws해줄필요가 없음 
	그리고 trycatch를 식으로 사용할수있음
		val q3:Int?=
			try{q1+q2}catch(e:Exception){null}
	이렇게 예외를 무시하는식으로도 사용할수있고 그럼
	이때 try를 반드시 중괄호로 감싸야하고,블럭내의 마지막값이 리턴값임
		
3.함수정의와 호출	
	코틀린에서 컬렉션은
		val set=hashSetOf(1,2,5)
		val list=arrayListOf(1,7,53)
		val map=hashMapOf(1 to "one",7 to "seven",53 to "fifty-three")
	이렇게 생성하면됨,맵에서 to는 키,밸류를 매칭해주는 함수인데,중위함수호출로 저렇게 사용할수있음(키워드아님)
	
	즉 특별한 컬렉션을 코틀린이 가진게 아니라,자바에서 컬렉션클래스를 래핑해서 쓰는거임
	그래서 자바에선 없던
		list.last()
		set.max()
	같은게 있음,어짜피 어댑터에 기능추가하는건쉬우니
	
	코틀린에선 함수의 파라미터에 해당파라미터가 뭔지 적어줄수있음
		joinToString(list,separator=" ",prefix=" ",postfix=".")
	단,하나라도 적으면 그 뒤에있는 모든 인자에 적어줘야함
	그리고 코틀린에선 함수의 파라미터에 디폴트값을 지정해둘수있음,입력안하면 그값들어가게
	이거로 오버로딩 잔뜩만들어야하는걸 줄일수있음
	이경우 순서대로면 상관없는데,중간에있는것(위에서 세퍼레이터나 프리픽스)을 생략하고 마지막거만 넣거나 그러려면 파라미터명을 명시해줘야함
	
	코틀린에선 함수나 프로퍼티를 최상위로 뽑는게 가능함,즉 모든클래스의 밖에 함수가 덩그러니있어도,그걸 실행시킬수있음
	내부적으론 클래스를 생성해서 그거로 감싸는건데,코틀린만쓸거면 신경안써도됨(파일명Kt.함수명()으로 실행할수있음 자바에선)
	그리고
		const val 변수명="ㅁㅇㅁ"
	로 상수도 만들수있음(퍼블릭 스태릭 파이널임)
	
	코틀린에선 확장함수라는 기능으로,해당 클래스에 외부에서 메서드를 추가하는게 가능함
	이 메서드는 퍼블릭메서드와 퍼블릭 필드만 건드릴수있음
	이건
		fun 추가할클래스.메서드명():리턴타입=함수내용
		fun String.lastChar():Char=this.get(this.length-1)
	으로 추가할수있음,이안에서도 this쓰면 해당클래스를 가리키고,this를 생략해도됨(get(length-1)도 같음)
	사용도 그냥 저안에 그메서드가 있다생각하고 쓰면됨
		val a="acb".lastChar()
	그리고 이 확장함수는,해당 패키지 내에서만 적용되고,다른패키지에서 적용하려면 임포트를 하면됨
		import strings.lastChar
		import strings.*
	이렇게
	as를 써서 이름바꾸는거도 가능,그러면 2개이상 같은이름으로 넣어서 충돌나는거도 해결가능
	
	확장함수는 오버라이딩할수없음,클래스의 일부가 아니기떄문
	
	코틀린 컬렉션도 이런 확장함수를 사용해서 확장된거임
	
	프로퍼티도 확장하는게 가능한데,이경우엔 상태를 저장할 방법은 없어서 필드를 넣을순없고,
	게터를 못넣으니 필수적으로 게터는 넣어줘야하고 초기화도 불가능
	크게쓸일있나싶음
	
	함수에 가변인자(갯수랜덤하게 받을수있게)사용도 가능,이건vararg키워드를 사용하면됨
		fun abc(vararg 변수명:타입):리턴타입{}
	그리고 저런데다가 배열때려박을땐
		val list=arrayListOf(1,2,3,4,5)
		abc(*list)
	이렇게 앞에 *를 붙이면 펼쳐줌
	
	
	중위호출은 인자가 하나뿐인 메서드를 중간에 넣어서 사용할수있는거
		1 to "one"
		1.to("one")
	이 두개는 같음,그냥 위에거가 보기 더 깔끔하니까 저렇게쓰는거,기본적으로 to같은걸 많이사용함
	중위호출을 가능하게하려면 fun앞에 infix를 붙이면됨
	to메서드는 pair인스턴스를 반환하는데,이건 두 원소로 이루어진 순서쌍을 반환함,맵에넣으면 앞이 키 뒤가 값이됨
	
	그리고 코틀린은 구조분해선언도 가능함
		val(a,b)=1 to "one"
	이러면 a에 1,b에 "one"가 들어감
	for루프에서 
		for (index,element) in collection.withIndex(){}
	이거도 마찬가지로 구조분해선언
	
	
	코틀린 문자열은 자바문자열과 같은데,추가적으로 몇개의 확장함수를 넣어뒀음
	spilt같은경우,자바의경우 정규식이라서 귀찮은게 좀있었는데(abc.spilt(".")동작안함),
	코틀린에선 기본적으로는 문자로 동작하고,정규식으로 쓰려면 
		".".toRegex()
	이렇게 명시해야함
	그리고 구분문자열을 여러개받을수있게 오버로딩도 해뒀음(abc.spilt("-","_"))
	
	그리고 """ """이렇게 3중따옴표로 묶은 문자열은,내부에서 어떤 문자도 이스케이프할필요가 없음
	추가로 3중따옴표는 줄바꿈도 표현할수있음(들여쓰기 줄바꿈 다들어감)
	
	
	코틀린에선 로컬함수로 추출된 메서드를 원함수 내부에 깔끔하게 중첩할수있음
	즉 함수내부에 함수를 정의해서,거기서 그걸 사용하는것
	이 로컬함수는 자신이 속한 함수의 모든파라미터와 변수를 사용할수있음
	이 로컬함수는,여러겹으로 올릴수도있긴한데 그러면 읽기힘드니까 1뎁스만 넣는게 좋음 
	
4.클래스,객체,인터페이스
	코틀린에서 인터페이스도 그냥 그대로쓰면됨,여기서도 디폴트메서드를 사용할수있지만,필드는 넣을수없음
	구현할땐
		class abc:구현인터페이스명{}
	이렇게 이름뒤에 콜론찍고 적으면됨,상속도 같고,인터페이스는 다중구현가능하고,상속은 하나만되는거도 같음
	그리고 구현할땐
		override fun abc(){}
	이렇게 오버라이드쓰면됨 
	
	그리고 인터페이스를 2개이상 구현할때,양쪽다 같은이름의 메서드가 디폴트로 있으면,강제적으로 그 메서드를 오버라이드해야함
	둘중 하나 선택할땐
		super<해당인터페이스명>.메서드명()
	으로 선택하거나,직접구현하면됨
	
	
	기본적으로 코틀린에서는 모든 클래스에 디폴트로 final이 붙어있어서 상속을 할수없음
	상속을 하려면 명시적으로
		open class 클래스명{}
	이렇게 open을 붙여줘야함
	그리고 추가적으로,열어둘(오버라이드가능하게할)메서드나 프로퍼티에도 open을 붙여야함,아니면 다 파이널임
		open fun abc(){}
	단,해당 클래스가 상속받고,오버라이드 한경우엔 디폴트로 열려있으니 final로 닫을수있음
		final override fun abc(){}
	이렇게 기본적으로 final로 잡아서,스마트캐스트가 가능해졌음(스마트캐스트는 이후 변경될가능성이 없어야,final이나 val이어야하니)
	
	코틀린에서도 추상클래스가 있는데,
		abstract class abc{}
	이렇게 만들면됨
	여기서 
		abstract fun abc() //추상메서드,반드시 구현해야함
		fun abcd(){...}//구현메서드,기본적으로 final임
	이렇게 여기서도 기본값으로 닫혀있음
	
	
	코틀린에서 접근자도 자바랑 거의비슷한데,여기선 기본값이 public임
	그리고 추가적으로 internal이라는,같은 모듈안에서만 볼수있는 접근자가 생겼음
	이걸쓰면,퍼블릭에서는 여기에 접근할수없음
	그리고 최상위에 private쓰는거도 가능한데,이러면 그 파일안에서만 접근가능함
	그리고 코틀린에서 protected는 같은 패키지안에서도 접근할수없음
	확장함수는 private,protected에 접근할수없음
	
	즉 protected는 그클래스나 그클래스를 상속해야보임
	
	자바에서 내부클래스는,기본적으로는 외부클래스에 대한 접근권한이 있음
	이거때문에,내부클래스에서 바깥클래스에 대한 참조를 묵시적으로 가지고있기때문에 직렬화문제가 날수있는데
	그래서 static으로 선언해서 바깥이랑 연결을 끊을수있는데(중첩클래스)
	코틀린에선 내부클래스의 기본값이 외부에 대한 접근권한이 없음(기본이 중첩클래스임)
	그래서 이런문제가 발생하지않음
	중첩클래스:바깥클래스의 참조를 저장하지않음
	내부클래스:바깥클래스의 참조를 저장함
	
	외부랑 연결을(this)만들고싶으면
		inner class abc
	이렇게 inner를 적어주면됨
	그리고 사용할떄도
		this@바깥클래스명.메서드명()
	이렇게 사용해야함
	
	sealed클래스는,해당 클래스를 상속한 하위클래스의 정의를 제한할수있음(추가적으로 open이 자동으로붙음)
	이걸 사용해서 하위클래스를 정의할땐,반드시 sealed이 붙은 상위클래스안에 중첩시켜야함
	즉 외부에서는 상속을 못하게 막고,명시적으로 상속하려면 자기안에서 이름적고가게 만들어둔거임
		sealed class abc{
			class abcd():abc()
			class abcde():abc()
		}
	이렇게 명시적으로 상속대상을 표시한거
	
	
	코틀린에서 생성자는 주생성자와 부생성자로 나뉨
	또한 초기화블록으로 init로직을 추가할수있음
	클래스에서
		class abc(val name:String,val age:Int=0//주생성자위치){
			val qwqw:String
			init{
				qwqw=name+age
			}
		}
		val qq=abc("abcd",10)
	이렇게 위에 생성자를 명시하고,init블록내에 로직을적으면 해당로직시 생성시에 호출됨
	자주쓰이는방법으로
		class abc(_name:String,_age:Int){
			val name=_name
			val age=_age
		}			
	이렇게 생성자에는 _로 표시해두고,그걸 바로 받는식으로도 사용할수있음
	즉 프로퍼티로 생성하려면 
		val name:String
	파라미터로 받으려면
		_name:String
	이렇게 쓰는거임
	그리고 생성자에 디폴트값도 넣을수있음
		val age:Int=0
	클래스에 기반클래스가 있으면,주생성자에서 기반클래스의 생성자를 호출해야함
		class abc(val name:String,val age:Int=0):ab(name){}
	이렇게 주생성자에 있는 프로퍼티나 파라미터를 넘겨줄수있음
	
	해당클래스의 생성자를 막고싶으면(인스턴스생성못하게)
		class abc private constructor(){}
	이렇게 해버리면 생성을 못하게할수있음,
	근데 그냥 함수를 최상위로 뽑거나(유틸클래스),싱글톤쓰려면 object를 사용해서 객체를 선언하는걸 선호하는듯
	
	생성자를 여러개쓰고싶으면
		class abc(_name:String,_age:Int){
			constructor(_name:String,_age:Int,_email:String){
				코드
			}
		}
	이렇게 부생성자를 사용하는거도 가능
	아예 주생성자를 없애고 부생성자만 여러개 쓰는거도 가능
		class abc{
			constructor(_name:String,_age:Int,_email:String){
				코드
			}
			constructor(_name:String,_age:Int,_email:String,_post:String){
				코드
			}
		}		
	어지간하면 디폴트값으로 처리하고,아예 파라미터가 달라지는경우엔 어쩔수없이 이렇게써야함
	그리고 주생성자가 없으면 부생성자에서 반드시 상위클래스를 초기화하거나,다른생성자에다가 생성을 위임해야함,즉 한번은 상위클래스를 초기화해야함		
		constructor(_name:String,_age:Int,_email:String):super(_name){}
		constructor(_name:String,_age:Int,_email:String,_post:String){
			super(_name) //상위클래스 생성자 호출
			코드
		}
	이런식임
	
	코틀린에선 인터페이스에 추상 프로퍼티를 넣을수있음
		interface abcd{
			val name:String
		}
	그리고 여기서 커스텀게터세터를 넣을수도있음
			interface abcd{
			val email:String
			val name:String
				get()=email.subStringBefore("@")
		}
	이경우에도 상태가 없는건 맞아서,구현하는데서 프로퍼티를 상속해야하는데,이떄 게터세터를 커스텀할수있음
	3가지방법이 있는데
		class abcde (override val name:String):abcd{}//1번
		
		override val name:String  //2번,내부필드에서 오버라이드하고 게터생성
			get()=abcd.subStringBefore("!") //필드를 사용하지않고 그냥 매번 해당값 계산해서리턴
		override val name="qwer" //3번 내부필드에서 값입력
	이렇게
	
	커스텀게터세터에서 자기자신의 필드값을 읽을땐,field를 사용하면됨
		override val name:String
			set(value:String){
				field=value
			}
	이렇게하면됨
	그리고 접근자의 가시성을 바꾸려면
		val name:String
			private set
	이렇게 하면됨
	
	그리고 코틀린에선 데이터클래스를 사용하면,equals,hashcode,toString를 자동으로 오버라이드해서 만들어줌
	자바에선 equals를 오버라이드해서 값비교를 하려면,hashcode도 같이 오버라이드를 해야하니(equals은 양쪽다 해시코드가 같아야하니까)
	이거도 같이해주는거,추가적으로 해시맵같은데서 키로도 쓸수있고
	tostring은 선언순서대로 이름:값으로 출력해줌,맘에안들면 바꾸면됨
	
	추가적으로 데이터불변성을 위한 copy()도 있음
	즉 모든값을 val로 선언하고,값변경필요성있으면 복제해서 새인스턴스를 만드는식으로 사용할수있게해줌
	다중스레드에서 유용함
	보통 데이터클래스는 이렇게 불변객체로 만드는편임
	
	코틀린에선 기본적으로 클래스를 final로 취급하고,명시하지않으면 상속을 못하게함
	근데 이런 상속금지한 클래스에 새로운 무언가를 추가해야하면 사용되는 패턴이 데코레이터패턴임
	해당클래스의 인터페이스를 상속받은다음 합성으로 해당클래스를 가져와서 사용하는것
	이건 보일러플레이트가 많아지는 단점이 있는데,이걸 없애주는게 by임
	인터페이스를 구현할때 by를 붙여서 이 인터페이스구현을 해당객체에 위임중이라는걸 알려서,
	내가 명시적으로 적지않은건 그냥 해당 합성클래스를 호출하게함
	사용은
		class abc(val qqq:abc()//합성클래스):abc by qqq{}
	이렇게 쓰는거임,그냥 변경하지않을 모든 메서드에 qqq.메서드명으로 실행시키는 보일러플레이트 보기싫어서 나온거라고 보면됨
	여기서 중요한건,합성이라서 해당 합성클래스의 구현에 대한 의존이 생기지않는다는게 장점임
	
	
	코틀린에서 object는 클래스를 정의하면서 인스턴스를 생성할때 사용되는 키워드임
	이건 싱글톤,컴패니언오브젝트,객체식(무명내부클래스)에서 사용됨
	
	싱글톤을 만드려면
		object abc{}
	이렇게 클래스대신 object라고 붙이면됨,클래스선언과 인스턴스선언을 합친거
	싱글톤이니까 생성자는 사용할수없고,초기화블록은 사용할수있음
	이거도 :로 인터페이스를 구현하거나 상속받을수있음
	스프링쓸거면 컴포넌트로 넣으면되니까 상관없을거같지만
	
	컴패니언오브젝트(동반객체)는 내부클래스인데,내부의 비공개멤버를 호출할 필요가 있을때 사용됨
	이건 클래스의 스태틱클래스로 사용할수있음,즉 클래스의 인스턴스를 생성하지않고 해당 내부클래스 안의 메서드를 호출할수있음
	주 사용처는 팩토리메서드같은거에 잘 사용됨(주생성자를 프라이빗으로 만들고 하는식)
		companion object{
			fun abc(){}
		}
	이런식으로 사용할수있음
	이런 동반객체에 이름을 붙일수있긴한데,한 클래스엔 동반객체를 하나이상 만들수는없음
	그리고 동반객체도 객체라서 인터페이스구현도 가능함
	보통 toJson,fromJson을 만들때 잘 사용함(이때 해당외부클래스의 이름 매개변수로 넣으면 그걸 콜한 인스턴스를 넣을수잇음)
	
	이런 동반객체도 확장함수를 사용할수있음
		fun abc.Companion.addmeth(){}
	이렇게 Companion을 붙이면됨 
	
	객체식은 무명객체를 만들어서 사용할때 사용됨
		abc.addMouseListener(
			object:MouseAdapter(){
				override fun mouseClicked(){}
			}
		)
	이런식으로 객체를 식으로 사용해서 넣을수있음,보통 이벤트리스너같은곳에서 사용됨
	이건 자바의 무명내부클래스와 다르게,여러 인터페이스를 구현할수있음
	그리고 객체식 안의 코드는 그 식이 포함된 함수의 변수에 접근할수있음(스코프가 해당 함수안 전체임)
	보통 객체식은 구현해서 던져줘야할 메서드가 2개이상일때 사용하고,하나만 던지면되면 걍 람다쓰는게 더 편함
	
	
5.람다로 프로그래밍
	람다는 다른함수에 넘길수있는 작은 코드조각임,보통 컬렉션같은데서 많이 사용되고,이건 자바의 메서드가 하나인 무명내부클래스를 대체할수있음
	
	컬렉션을 쓸때 수행하는 작업의 대부분은 일반적인패턴이라,람다를 받는 컬렉션함수로 이미 다 들어가있음
	최대값찾으려면
		abc.maxBy{it.age} //해당원소객체중 대상이되는 필드를 선택
		abc.maxBy(원소타입::대상필드)
		abc.maxBy(Person::age)
	이런식으로 사용할수있음,위와 밑은 같음
	이렇게 다 이미 만들어져있으니,직접 만들지말고 있는거쓸생각부터 먼저 하자
	
	람다식은 항상 중괄호로 감싸져있고,화살표앞이 파라미터,뒤가 식임
		val sum={x:int,y:int->x+y}
	이렇게 람다식을 변수에 저장할수도있음
	그리고 코드의 일부분을 블록처럼 실행하려면
		run{println(12)}
	이렇게 run을 써주면됨
	
	그리고 함수의 인자로 람다를 받을떄,마지막의 인자가 람다식이면 밖으로 뺴낼수있음
		abc.maxBy(){p:Person->p.age}
	그리고 람다가 유일한 인자라면 괄호를 지울수있음
		abc.maxBy{p:Person->p.age}
	즉
		abc.joinToString(" ",{p:Person->p.name})
		abc.joinToString(" "){p:Person->p.name}
	이 두개는 같음
	보통 람다식을 함수인자에서 2개이상 받아야하면 그냥 괄호안에 넣고(헷갈리니까)아니면 빼는편인듯
	그리고 파라미터의 타입이 항상 정해져있으면(컬렉션에선 보통 해당 컬렉션원소의 타입),타입도 생략해도 알아서 추론함
		abc.maxBy{p->p.age}
	대충 먼저 이렇게쓰고나서,컴파일에러뜨면 그때가서 타입적으면됨
	그리고 파라미터가 하나뿐이고 그 타입을 컴파일러가 추론할수있으면 it을 사용할수있음
		abc.maxBy{it.age}
	파라미터를 따로 지정하지않아야 it을 사용할수있음
	이건 람다식이 하나일때는 이렇게쓰고,람다식안에 람다식이 중첩되면 그냥 파라미터명시해서 쓰는게 보기편함
	
	그리고 람다가 여러줄일경우,마지막식이 람다의 결과값이 됨
	
	그리고 람다는,자기가 실행시킨 메서드가 가지고있는 로컬변수에 접근할수있음,이게 변수포획임
	그리고 자바와는 다르게,파이널변수가 아닌애들도 접근할수있고,람다안에서 바깥변수를 변경할수있음,즉 파이널이 아닌애들은 참조값을 가져감
	그리고 만약 변수에 람다를 담았으면,함수가 종료돼도 해당값에 접근할수있음(미니클래스처럼 사용할수있음)
	
	그리고 이미 만들어진 함수를 인자로 넘길수도있는데,이때 이중콜론을 사용하면됨,이러면 함수를 값으로 바꿀수있음
	이걸 멤버참조라고 부르는데,이건 프로퍼티나 메서드를 단 하나만 호출하는 함수값을 만들어줌
	그냥
		{Person::age}
		{Person::isAdult}//메서드
		{::salute}//최상위함수,최상위는 앞을비우면됨
	이거임,확장함수도 똑같이 사용할수있음
	이건 람다가 인자가 여럿인 다른함수에 작업을 위임할때,람다를 사용하지않고 행동을 변수로 들고있을수있어서 편함
		val Action=::sendEmail
		val p=Action(a,naver)
	생성자도 같은방식으로 들고있을수있음
	
	
	컬렉션을 쓸때 필수적으로 사용되는건 filter와 map임
	filter는 컬렉션의 모든 멤버를 foreach하면서 해당 람다가 T인값들만 모아 새 컬렉션을 만들어서 리턴해줌,단 값을변환할수는 없음
	map는 컬렉션의 모든 멤버를 foreach하면서 모든 원소에 해당람다를 적용시킨 값을 새 컬렉션에 담아 리턴해줌
	map은
		people.map(it.name)
		people.map(Person::name)
	이렇게 객체에서 특정값만 빼거나 할때도 잘 사용됨
	그리고 필터와 엮어서 필터링을 한 다음 값변환하는식으로도 잘 사용됨
		people.filter{it.age>30}.map(Person::name)
	이건 30살이상인 사람들의 이름만 출력하는 컬렉션을 반환하라는것
	
	그리고 람다식의 특성상,비효율적인 계산이 나올수있음(필터안에서 maxBy써서 값가져와서 비교한다던가,이러면 매번 maxBy를 계산해야함)
	그래서 상식선에서 가장 계산횟수가 최소화되게 만드는게좋음
	
	컬렉션의 모든 원소가 해당식을 만족시키는지를 알려면
		people.all{it.age<25}
	하나라도 해당식을만족시키는지 알려면
		people.any{it.age<25}
	해당식을 만족시키는갯수를 받으려면
		people.count{it.age<25}
	해당식을 만족시키는 원소를 하나만받으려면(여러개는 필터쓰면되니까,없으면 null반환,제일먼저찾은거반환)
		people.find{it.age<25}
	이렇게 사용하면됨
	
	groupBy는 사용하면,해당 식의 결과끼리 값을 묶어줌,즉 리스트의 리스트들로 그룹핑을 해줌
	flatMap은,중첩컬렉션에서 해당값을 전부 새로운 컬렉션에 담아서 람다식을 적용해서 리턴해줌
	즉 중첩리스트의 원소를 전부 모아서 봐야하는데,거기서 map을 써야하면 사용할수있음
	flatten()은 단순히 해당값을 새 컬렉션에 담아줌,즉 flatten+map=flatMap
	
	
	이렇게 컬렉션함수들을 연쇄하면(abc.map{...}.filter{...})계속 중간컬렉션이 생겨서 메모리차지하게됨
	그래서 이걸 묶어서 처리할수있는게 asSequence()임
	이건
		abc.asSequence()
			.map{...}
			.filter{...}
			.toList()
	이렇게 asSequence로 시작해서 toList로 끝내면됨
	이러면 각 원소마다,순서대로 한번씩 거쳐서 컬렉션에 추가해서,중간컬렉션이 생기지않음
	추가적으로 필터를 먼저쓰면 총계산량자체도 줄어듬(필터통과못하면 다음으로 안넘어가니까)
	
	자바 라이브러리 api에 람다를 넘길때도,구현할 메서드가 하나인 무명내부클래스를 사용하는 모든곳에 대신 람다를 사용할수있음
	구현해야하는 메서드의 파라미터를 주고,내용을 적는 그냥 평범한 람다로 대체할수있음
		button.setOnClickListener( new OnClickListener(){
				@Override
				public void OnClick(view v){
				...
				}
			}
		)
	이걸
		button.setOnClickListener{v:view->...}
	로 바꿀수있음
	즉 구현해야하는 추상메서드가 하나인 sam(단일추상메서드)인터페이스를 구현해야할때,람다를 넣으면 알아서 변환해줌
	대부분은 알아서 해주는데,수동으로 변경해야한다면,해당 함수형인터페이스의 이름으로 함수를 만들고,Runnable을 상속받아서,
	추상메서드의 매개변수만 받아서 구현하면됨
	필요해지면 찾아보자
	보통 오버로드한 메서드중 어떤타입의 메서드를 선택해야할지 애매할때 명시적으로 이렇게한다는듯
	
	추가적으로 람다에는 this가 없음(객체가 아니니)그래서 이벤트리스너 구현하는데 자기자신의 리스너등록을 해제해야하면 무명객체를 써야함
	
	
	수신객체를 명시하지않고,람다의 본문안에서 다른객체의 메서드를 호출할수 있게하는걸 수신객체지정 람다 라고 함
	대표적으로 with나 apply가있음
	
	with는 그 델파이나 다른곳에서 쓰던 with랑 똑같음
	해당대상을 with(abc)로 명시하고,거기에다가 붙이는 그냥 좀 짧게쓸수있는 그거
		with(abc){
			append(ada)//this.append(ada)도 가능
			toString()
		}
	이런식으로 abc를 this로 치환해서쓸수있는거(this는 생략가능하니까)
	그리고 당연히 이거도 마지막 식을 반환함
	이건 사실 언어상의 기능이 아닌,대상과 람다식으로 구성된 일반함수임
	즉
		with(abc,{this.append(ada)...})
	이거랑 같은데 마지막인자가 람다라서 밖으로 뺀거
	
	apply는 with와 거의 같은데,이건 마지막식이 아닌 대상객체(apply(abc){...}//이경우 abc가 리턴됨 )를 리턴한다는 차이만 있음
	그래서 초기화를 할때 유용함
	

6.코틀린 타입 시스템
	코틀린에서 변수에 널 허용하려면 타입뒤에 ?붙이면됨
		val abc:String?
		fun qqq(abc:String?){}
	이렇게 널허용을 하면 못하는게 좀있는데,널일지 해당타입일지를 몰라서 변수.메서드()가 사용불가능해지고,널이 아닌(abcd:String)값에 대입할수없음
	이때 
		if(abc!=null)abc.length
	이렇게 타입체크를 거치면 그때는 전부 사용할수있음(널이아닌게 확정났기떄문)
	물론 이렇게 귀찮게하진않고,키워드를 사용해서 처리함
	메서드호출할때
		abc?.length
	이렇게하면 널이면 이 호출은 무시되고(null반환),널이 아니면 동작함,즉 if (abc!=null)을 축약해둔거임
	주의할건,이렇게 반환된 값도 nullable이라는거(널이올지 값이올지 모르니)
	코틀린에선 프로퍼티읽는거도 메서드쓰니까 똑같이할수있음
		qqq?.name
	객체그래프에서 널이 가능한 중간객체가 여러개있으면,연쇄해서 ?.를 찍어서 편하게 사용할수있음
		val a=this.company?.address?.country
	이렇게,이거안쓰면 막 계속 if문 중첩해서 찾아야하는데 그걸 편하게 해결할수있음
	
	그리고 해당값이 널일경우,대체값을 주던지 예외를 던질수도있는데(식을 넣을수있음)
		val t:String=s ?:throw Exception
		val t:String=s ?:return "abc"
		val t:String=s ?:"abc"
	이렇게 엘비스연산자를 사용할수있음
	코틀린에선 return이나 throw도 식이라,엘비스에 이것들도 넣을수있음,이건 함수의 전제조건을 검사할때 유용함(맨위에서 체크하고 아니면 런하기)


	as?연산자는,해당타입으로 변경할수있으면 변경하고,변경할수없으면 널을 반환함,즉 안전한캐스트를 해줌
	이걸 엘비스랑 묶어서
		a as? Long ?:return false
	이런식으로 자주 사용함(이퀄구현할때 자주사용한다는듯)
	이렇게 안전한캐스트를 하면 해당타입으로 자동으로 스마트캐스트가 되니까
	
	
	그리고 해당값이 널이 아니라는걸 확정지을수있는데
		val t:String=s!!
	이렇게 !!두개로 ?를 떼버릴수있음
	이건 만약 저자리에 널이들어오면,npe바로터지니까 조심해야하고,가급적 사용하지않는게 좋음,뭐 써야할때 있긴하지만
	즉 이값은 절대 널이 아닌데,라이브러리상에서 널에이블로만 준다 이럴때는 사용할수있음
	즉 널체크를 마쳤는데 널금지로 변환할방법이 없을때 사용가능
	
	그리고 추가적으로,한줄에 !!를 두개이상 사용하면 예외터졌을때 알아보기 개빡세니까(어떤식에서 예외터졌는지 안알려줌)
	한줄에 !!는 하나씩만 넣어야함
	
	
	널이 될수있는값을 널이 아닌값만 인자로 받는 함수에 넘길땐,let과 안전한호출을 같이 사용할수있음(일반적으로 이렇게묶어씀)
	이걸 사용하면,해당식이 null인지를 검사하고 그결과를 변수에 넣어줌
	물론 널검사를 치고 그안에 넣을수도있긴한데 귀찮으니까
	이걸 사용하면 해당값이 널이 아닌경우에만 호출됨
		email?.let{email->sendEmailTo(email)}
		email?.let{sendEmailTo(it)}
	이렇게 사용할수있음(물론 )
	이건
		if(email!=null)sendEmailTo(email)
	과 같음
	let은 자신의 수신객체를 인자로 전달받은 람다에 넘김,즉 단순히 던져주는애고,널체크는 안전한호출로 처리하는거
	즉 해당 식을 임시로 저장하는 값을 만들필요없이 바로던질수있게해줌
	
	근데 만약 여러값을 검사해야할경우엔,let여러번 중첩시키면 보기힘드니까 걍 if문으로 처리하는게 편함


	만약 필드를 생성자에서 말고,이후에 초기화해야하는데,nullable 을 사용하기싫으면 lateinit를 사용할수있음
	이건 생성자를 지나서 나중에 초기화할수있음,단 이건 var이어야함
	초기화전에 여기접근하면 예외뜨니 주의(그래도 npe는 아니고,초기화전에 건드렸다는 예외라 고치긴쉬움)
	
	그리고 확장함수를 정의해서,해당값이  널에이블일때 호출가능한 함수를 만들수있음
	그렇게쓰면 그 함수 내부에서 this는 널이 될수있어서 명시적으로 널검사를 해줘야함
	보통은 널불가능으로 넣고,나중에 필요성이 생기면 널가능으로 푸는식으로 접근하는게 좋음
	그리고 널검사를 이렇게 함수안으로 넣을수있음
	
	코틀린에서 함수나 클래스의 모든 타입 파라미터는 널이 될수있고,그래서 제네릭을 사용하면 기본값으로 널에이블임(Any?로 추론함)
	그래서 안전한호출(?.)를 써야함
	이걸 널금지로 하고싶으면
		<T:Any>
	로 명시하면 제네릭인데 널을 허용하지않게하는게 가능함


	자바상호운용에서 @Notnull같은게 있으면,코틀린에서도 널불가로 처리해줌
	근데 이런게 없으면,플랫폼타입(널이 될수있는타입으로 처리해도되고 될수없는타입으로 처리해도 되는타입)으로 둠
	즉 거기서 널이 가능할지불가능할진 개발자책임이고,컴파일러는 모든걸 허용함
	코틀린컴파일러는 널불가능타입에 대한 널검사는 경고메시지를 띄우지만,플랫폼타입에서는 경고를 표시하지않음
	즉 알아서 잘 해야함
	널검사 없이 대입같은걸해도 딱히 예외는 안나는데,만약 거기 널들어있으면 바로 예외뜨는식(보통 npe는 아니고,좀 더 자세한게뜸)
	
	그래서 라이브러리를 쓸때는 해당라이브러리가 널을 반환하는지 아닌지를 체크해야함,모르겠으면 검사하는게 나음
	코틀린에서 직접 플랫폼타입을 선언할 방법은없지만,예외에선 나오는데
	플랫폼타입은(String!) 이런식으로 느낌표가 하나 붙어있음,즉 !는 널에관한 정보가 없다는뜻임
	
	코틀린에서 자바메서드를 상속할때,널가능성을 제대로 처리하는게 중요함
	구현메서드를 다른코틀린코드가 호출할수있으니 컴파일러는 널이 될수없는타입으로 선언한 모든파라미터에 !!를 붙이는데,
	자바코드가 널을 주면 바로예외임,파라미터를 사용하지않아도 예외임

	
	
	코틀린에서는 따로 원시타입(int등)과 래퍼타입(integer등)을 구분해서 사용하지않음
	내부적으론 알아서 객체쓸땐객체쓰고 원시타입쓸땐 원시타입쓰겠지만 우리가 알필요는없음
	대충 Int?처럼,원시타입에 널 넣을수없으니 이런경우에 Integer로 들어간다 이런느낌임
	
	코틀린은 한 타입의 숫자를 다른타입으로 자동변환하지않음
	즉 int를 long로 자동변환해주지않음
	그래서 i.toLong()이런걸 붙여서 써야함
	코틀린은 모든 원시타입에 대한 변환함수를 제공함,기본적으로 toXxx()임
	추가적으로는 숫자뒤에L붙이면 롱으로 취급해주고 이정도는있음

	코틀린에서 Any는,자바에서의 Object라고 봐도됨,단 Any는 널불가능이고,널허용하려면 Any?써야함
	자바에서 오브젝트를 받으면,코틀린에선 Any!라고 번역함
	단,object에 있는 wait나 notify같은메서드들은 없고,
	tostring,equals,hashcode는 any에서 나온거
	
	코틀린에서 Unit는,자바의 void와 거의비슷함,즉 리턴값이 없을때 Unit를 쓸수있음
	다른점은 Unit는 void와 달리 타입인자로 사용할수있음,
	이건 제네릭파라미터를 반환하는 함수를 오버라이드하면서 반환타입으로 Unit를 사용할때 사용됨
		Abcd<Unit>
	이러면 해당함수에서 리턴해야하는 의무를 없애고,void처럼 취급할수있음(정확히는 컴파일러가 마지막에 묵시적으로 return Unit를 넣어줌)

	코틀린에서 Nothing은,반환되는일이 없는,즉 성공할일이 없는 함수들이나 무한루프함수에서 사용되는 타입임
	즉 테스트에서 fail함수나,무한루프함수같은거,예외를 래핑한 함수에서도 사용할수있음
	즉 해당 함수가 정상적으로 끝나지않는다는게 보장되는걸 리턴값으로 표현해줌

	컬렉션에서 널가능성은,컬렉션 자체에서 널이 가능할수도있고,안의 값에서 가능할수도있음
	즉
		ArrayList<Int>? //리스트자체가 널일수있음
		ArrayList<Int?> //원소가 널일수있음
		ArrayList<Int?>? //리스트자체가 널일수도,원소가 널일수도있음
	이렇게 다됨
	
	코틀린에선 컬렉션을 읽기전용으로 만들수있음
		mutableList<T> //변경가능한 컬렉션,값을 추가,삭제,변경할수있음
		List<T>//읽기전용 컬렉션,생성자로 생성한뒤 값을 변경할수없음
	읽기전용에서 값을 변경하려면,새객체를 만들어서 부어야함
	단,리스트와 뮤테이블리스트가 같은 컬렉션 객체를 가리키는거도 가능해서,리스트라고 절대 변하지않는다고 보장할순없음
	그래서 공유된 컬렉션은 변경하지않는게 스레드안전에 좋음
	
	코틀린에선 
		List -> mutableList->ArrayList
		set -> mutableSet->HashSet
	이렇게 상속구조가 짜여있음,즉 ArrayList는 변경가능한 컬렉션임
	추가적으로 컬렉션을 상속하지 않는 Map도 Map(읽기전용)과 mutableMap(변경가능)으로 만들어짐,추가로 이거도 HashMap도 있고
	
	그리고 컬렉션을 생성할땐
		listOf()
		mutableListOf()
		mapOf()
		mutableMapOf()
	이런식으로 사용할수있음
		
	그리고 자바랑 코틀린을 혼용할때 조심해야하는건,자바에서 코틀린컬렉션을 쓸때는 읽기객체라도 내용을 변경할수있으니 조심

	그리고 자바에서 선언한 컬렉션은,코틀린에선 플랫폼으로 보는데,보통은 상관없지만 문제생길거같으면
		컬렉션이 널이될수있나?
		원소가 널이될수있나?
		오버라이드메서드가 컬렉션을 변경할수있나?
	를 따져서 정확한 타입으로 선언해야함

	그리고 추가적으로 배열을 선언할때
		arrayOfNulls() //해당크기만큼의 널로 가득찬 배열을 생성,당연히 널이 들어갈수있어야함
		Array<타입>(배열크기){람다식} //해당크기만큼 배열을만들고,해당크기만큼 for를 돌려서 연산할수있음
		Array<String>(26){i->('a'+i).toString()}
	이때 타입은 생략할수있음,어짜피 뒤에서 추론가능하니






	
	
	
		
		