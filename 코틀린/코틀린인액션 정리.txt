1.코틀린이 무엇인가
	스킵
2.코틀린 기초
	코틀린에선 if가 문이 아닌 식임
	그래서 자체적으로 값을 만들어낼수있음
		if(a>b) a else b
	이런식으로 if안에서 값을 뽑을수있음 삼항연산자처럼
	
	변수는
		val abc:자료형=값
		val abc=값
	이렇게 할수있음,자료형생략하면 타입추론해서 넣음,이땐 값이 무조건있어야함
	val은 변경불가능한 변수,var은 변경가능한 변수
	이때 변경불가능은 단순참조값을 변경못한다는거라,리스트를 대입했을경우 리스트를 통째로 바꾸진못하고,리스트값을 추가삭제하는건 가능
	val은 단 한번만 초기화가 가능함,이 초기화는 선언할때말고 뒤에서 해도됨(if문으로 여러값중 하나로 초기화가능)
	
	${변수명}으로 문자열내에서 변수를 편하게삽입할수있음
	
	코틀린에서 클래스접근자의 디폴트는 퍼블릭임,그리고 기본적으로 필드와 게터,혹은 세터까지도 자동으로 묶어서 선언됨(프로퍼티)
	val일경우 게터까지,var일경우 세터까지 자동으로 선언됨,이 세터를 지울방법은 없음
		class Person(
			val name:String,
			var isMarried:boolean
		)
	이런식으로 선언함
	이게 자바코드로 바뀔때 자동으로 getter를 생성하고 사용하는식으로 바뀌는거고,getName()같은 메서드가 숨어있다고 봐도됨
	그리고 추가적으로,프로퍼티의 이름의 시작이 is로 시작하는경우 getisMarried가 아닌,isMarried()로 getter를 만듬
	
	이 접근자는 커스텀으로 만들수있는데,즉 식을 넣을수도있음
		class Rectangle(val height:Int,val width:Int){
			val isSquare:Boolean
				get(){
				return height==width
				}
		}		
	이런식으로 해당 필드의 게터를 커스텀할수있음
	줄여서
		get()=height==width
	이렇게도 가능(어짜피 두개는 같으니까)
	
	코틀린에선 한파일안에 여러클래스를 넣는일이 자주있고,이걸 주저해서는안됨(크기가 작을경우)
	
	enum클래스는 기본적으로
		enum class Color{
			RED,GREEN
		}
	이런식이고,여기에서 필드를 추가하고,해당값마다 생성자를 추가하고,함수를 추가할수있음
		enum class Color(val r:Int,val g:Int,val b:Int){
			RED(255,0,0),GREEN(0,255,0); //이땐 무조건 세미콜론을 찍어야함
			fun rgb()=(r*256+g)*256+b
		}
	이렇게
	
	스위치문은 when을 사용하면됨
	여기선 break를 안써도되고,여러값을 묶어서 분기처럼 사용할수도있음
	그리고 when의 인자로 아무객체나 사용할수있음
		when(setOf(a1,a2))
			setOf(RED,GREEN)->ORANGE
			else->throw Exception("error")
	이렇게 집합으로 받아서 순서상관없이 그값이 있나 확인하는거도 가능
	뭐 스위치문쓸일이 많진않지만
	단 이렇게 객체를 사용하면,객체를 만들고 비교하기때문에,메모리에서 약간 손해보긴함,그래서 메모리가 중요하면 풀어서 or로 써야함
		
	코틀린에선 is을 사용해서 변수타입을 검사함,이때 저걸 통과하면,자동으로 해당타입으로 캐스팅을 해서 밑에서 사용할수있음
	즉 as써서 명시적으로 타입캐스팅할필요가 없음
	그리고 블록의 마지막값은 자동으로 해당값이 출력됨
	즉 블록의 마지막에 a가 있을경우 해당식의 출력으로 a가 나감
		a=a+b
	이거 축약된게,그 if문 삼항연산자임,값만 나열했는데 출력되는거
	
	반복문은 while와 for가 있는데,
	while는 똑같고,
	do-while는 1번실행을 강제하는 while
	for는 기본적으로 foreach라고 보면됨
	그래서 n번 반복할땐
		for(i in 1..100){}
	이렇게사용하면됨 파이썬이랑 같음
	그리고 역순으로 내려갈땐
		for (i in 100 downTo 1 step 2){}
	이러면 100부터 2씩 깍임
	
	맵에 대해 for 돌릴때도
		for((key,value) in abcMap){}
	이렇게 쌍으로 받으면됨//구조분해
	맵에 값 넣을때도
		abcMap[키값]=넣을값
	이렇게 하면 됨,put안써도됨
	그리고 리스트에서 인덱스도 같이돌리고싶으면
		for((index,element) in abcList.withIndex())
	하면됨
	
	in을 사용해 컬렉션안에 해당값이 있는지,!in을 사용해 컬렉션안에 해당값이 속하지않는지 검사할수있음 
		return 'c' in 'a'..'z'
	이건 comparable인터페이스를 구현한 모든클래스에서 가능함


	코틀린에서 예외처리도 try catch finally를 사용함
	자바와의 차이점은,모든체크예외는 언체크예외로 변환되서 따로 명시적으로 throws해줄필요가 없음 
	그리고 trycatch를 식으로 사용할수있음
		val q3:Int?=
			try{q1+q2}catch(e:Exception){null}
	이렇게 예외를 무시하는식으로도 사용할수있고 그럼
	이때 try를 반드시 중괄호로 감싸야하고,블럭내의 마지막값이 리턴값임
		
3.함수정의와 호출	
	코틀린에서 컬렉션은
		val set=hashSetOf(1,2,5)
		val list=arrayListOf(1,7,53)
		val map=hashMapOf(1 to "one",7 to "seven",53 to "fifty-three")
	이렇게 생성하면됨,맵에서 to는 키,밸류를 매칭해주는 함수인데,중위함수호출로 저렇게 사용할수있음(키워드아님)
	
	즉 특별한 컬렉션을 코틀린이 가진게 아니라,자바에서 컬렉션클래스를 래핑해서 쓰는거임
	그래서 자바에선 없던
		list.last()
		set.max()
	같은게 있음,어짜피 어댑터에 기능추가하는건쉬우니
	
	코틀린에선 함수의 파라미터에 해당파라미터가 뭔지 적어줄수있음
		joinToString(list,separator=" ",prefix=" ",postfix=".")
	단,하나라도 적으면 그 뒤에있는 모든 인자에 적어줘야함
	그리고 코틀린에선 함수의 파라미터에 디폴트값을 지정해둘수있음,입력안하면 그값들어가게
	이거로 오버로딩 잔뜩만들어야하는걸 줄일수있음
	이경우 순서대로면 상관없는데,중간에있는것(위에서 세퍼레이터나 프리픽스)을 생략하고 마지막거만 넣거나 그러려면 파라미터명을 명시해줘야함
	
	코틀린에선 함수나 프로퍼티를 최상위로 뽑는게 가능함,즉 모든클래스의 밖에 함수가 덩그러니있어도,그걸 실행시킬수있음
	내부적으론 클래스를 생성해서 그거로 감싸는건데,코틀린만쓸거면 신경안써도됨(파일명Kt.함수명()으로 실행할수있음 자바에선)
	그리고
		const val 변수명="ㅁㅇㅁ"
	로 상수도 만들수있음(퍼블릭 스태릭 파이널임)
	
	코틀린에선 확장함수라는 기능으로,해당 클래스에 외부에서 메서드를 추가하는게 가능함
	이 메서드는 퍼블릭메서드와 퍼블릭 필드만 건드릴수있음
	이건
		fun 추가할클래스.메서드명():리턴타입=함수내용
		fun String.lastChar():Char=this.get(this.length-1)
	으로 추가할수있음,이안에서도 this쓰면 해당클래스를 가리키고,this를 생략해도됨(get(length-1)도 같음)
	사용도 그냥 저안에 그메서드가 있다생각하고 쓰면됨
		val a="acb".lastChar()
	그리고 이 확장함수는,해당 패키지 내에서만 적용되고,다른패키지에서 적용하려면 임포트를 하면됨
		import strings.lastChar
		import strings.*
	이렇게
	as를 써서 이름바꾸는거도 가능,그러면 2개이상 같은이름으로 넣어서 충돌나는거도 해결가능
	
	확장함수는 오버라이딩할수없음,클래스의 일부가 아니기떄문
	
	코틀린 컬렉션도 이런 확장함수를 사용해서 확장된거임
	
	프로퍼티도 확장하는게 가능한데,이경우엔 상태를 저장할 방법은 없어서 필드를 넣을순없고,
	게터를 못넣으니 필수적으로 게터는 넣어줘야하고 초기화도 불가능
	크게쓸일있나싶음
	
	함수에 가변인자(갯수랜덤하게 받을수있게)사용도 가능,이건vararg키워드를 사용하면됨
		fun abc(vararg 변수명:타입):리턴타입{}
	그리고 저런데다가 배열때려박을땐
		val list=arrayListOf(1,2,3,4,5)
		abc(*list)
	이렇게 앞에 *를 붙이면 펼쳐줌
	
	
	중위호출은 인자가 하나뿐인 메서드를 중간에 넣어서 사용할수있는거
		1 to "one"
		1.to("one")
	이 두개는 같음,그냥 위에거가 보기 더 깔끔하니까 저렇게쓰는거,기본적으로 to같은걸 많이사용함
	중위호출을 가능하게하려면 fun앞에 infix를 붙이면됨
	to메서드는 pair인스턴스를 반환하는데,이건 두 원소로 이루어진 순서쌍을 반환함,맵에넣으면 앞이 키 뒤가 값이됨
	
	그리고 코틀린은 구조분해선언도 가능함
		val(a,b)=1 to "one"
	이러면 a에 1,b에 "one"가 들어감
	for루프에서 
		for (index,element) in collection.withIndex(){}
	이거도 마찬가지로 구조분해선언
	
	
	코틀린 문자열은 자바문자열과 같은데,추가적으로 몇개의 확장함수를 넣어뒀음
	spilt같은경우,자바의경우 정규식이라서 귀찮은게 좀있었는데(abc.spilt(".")동작안함),
	코틀린에선 기본적으로는 문자로 동작하고,정규식으로 쓰려면 
		".".toRegex()
	이렇게 명시해야함
	그리고 구분문자열을 여러개받을수있게 오버로딩도 해뒀음(abc.spilt("-","_"))
	
	그리고 """ """이렇게 3중따옴표로 묶은 문자열은,내부에서 어떤 문자도 이스케이프할필요가 없음
	추가로 3중따옴표는 줄바꿈도 표현할수있음(들여쓰기 줄바꿈 다들어감)
	
	
	코틀린에선 로컬함수로 추출된 메서드를 원함수 내부에 깔끔하게 중첩할수있음
	즉 함수내부에 함수를 정의해서,거기서 그걸 사용하는것
	이 로컬함수는 자신이 속한 함수의 모든파라미터와 변수를 사용할수있음
	이 로컬함수는,여러겹으로 올릴수도있긴한데 그러면 읽기힘드니까 1뎁스만 넣는게 좋음 
	
4.클래스,객체,인터페이스
	코틀린에서 인터페이스도 그냥 그대로쓰면됨,여기서도 디폴트메서드를 사용할수있지만,필드는 넣을수없음
	구현할땐
		class abc:구현인터페이스명{}
	이렇게 이름뒤에 콜론찍고 적으면됨,상속도 같고,인터페이스는 다중구현가능하고,상속은 하나만되는거도 같음
	그리고 구현할땐
		override fun abc(){}
	이렇게 오버라이드쓰면됨 
	
	그리고 인터페이스를 2개이상 구현할때,양쪽다 같은이름의 메서드가 디폴트로 있으면,강제적으로 그 메서드를 오버라이드해야함
	둘중 하나 선택할땐
		super<해당인터페이스명>.메서드명()
	으로 선택하거나,직접구현하면됨
	
	
	기본적으로 코틀린에서는 모든 클래스에 디폴트로 final이 붙어있어서 상속을 할수없음
	상속을 하려면 명시적으로
		open class 클래스명{}
	이렇게 open을 붙여줘야함
	그리고 추가적으로,열어둘(오버라이드가능하게할)메서드나 프로퍼티에도 open을 붙여야함,아니면 다 파이널임
		open fun abc(){}
	단,해당 클래스가 상속받고,오버라이드 한경우엔 디폴트로 열려있으니 final로 닫을수있음
		final override fun abc(){}
	이렇게 기본적으로 final로 잡아서,스마트캐스트가 가능해졌음(스마트캐스트는 이후 변경될가능성이 없어야,final이나 val이어야하니)
	
	코틀린에서도 추상클래스가 있는데,
		abstract class abc{}
	이렇게 만들면됨
	여기서 
		abstract fun abc() //추상메서드,반드시 구현해야함
		fun abcd(){...}//구현메서드,기본적으로 final임
	이렇게 여기서도 기본값으로 닫혀있음
	
	
	코틀린에서 접근자도 자바랑 거의비슷한데,여기선 기본값이 public임
	그리고 추가적으로 internal이라는,같은 모듈안에서만 볼수있는 접근자가 생겼음
	이걸쓰면,퍼블릭에서는 여기에 접근할수없음
	그리고 최상위에 private쓰는거도 가능한데,이러면 그 파일안에서만 접근가능함
	그리고 코틀린에서 protected는 같은 패키지안에서도 접근할수없음
	확장함수는 private,protected에 접근할수없음
	
	즉 protected는 그클래스나 그클래스를 상속해야보임
	
	자바에서 내부클래스는,기본적으로는 외부클래스에 대한 접근권한이 있음
	이거때문에,내부클래스에서 바깥클래스에 대한 참조를 묵시적으로 가지고있기때문에 직렬화문제가 날수있는데
	그래서 static으로 선언해서 바깥이랑 연결을 끊을수있는데(중첩클래스)
	코틀린에선 내부클래스의 기본값이 외부에 대한 접근권한이 없음(기본이 중첩클래스임)
	그래서 이런문제가 발생하지않음
	중첩클래스:바깥클래스의 참조를 저장하지않음
	내부클래스:바깥클래스의 참조를 저장함
	
	외부랑 연결을(this)만들고싶으면
		inner class abc
	이렇게 inner를 적어주면됨
	그리고 사용할떄도
		this@바깥클래스명.메서드명()
	이렇게 사용해야함
	
	sealed클래스는,해당 클래스를 상속한 하위클래스의 정의를 제한할수있음(추가적으로 open이 자동으로붙음)
	이걸 사용해서 하위클래스를 정의할땐,반드시 sealed이 붙은 상위클래스안에 중첩시켜야함
	즉 외부에서는 상속을 못하게 막고,명시적으로 상속하려면 자기안에서 이름적고가게 만들어둔거임
		sealed class abc{
			class abcd():abc()
			class abcde():abc()
		}
	이렇게 명시적으로 상속대상을 표시한거
	
	
	코틀린에서 생성자는 주생성자와 부생성자로 나뉨
	또한 초기화블록으로 init로직을 추가할수있음
	클래스에서
		class abc(val name:String,val age:Int=0//주생성자위치){
			val qwqw:String
			init{
				qwqw=name+age
			}
		}
		val qq=abc("abcd",10)
	이렇게 위에 생성자를 명시하고,init블록내에 로직을적으면 해당로직시 생성시에 호출됨
	자주쓰이는방법으로
		class abc(_name:String,_age:Int){
			val name=_name
			val age=_age
		}			
	이렇게 생성자에는 _로 표시해두고,그걸 바로 받는식으로도 사용할수있음
	즉 프로퍼티로 생성하려면 
		val name:String
	파라미터로 받으려면
		_name:String
	이렇게 쓰는거임
	그리고 생성자에 디폴트값도 넣을수있음
		val age:Int=0
	클래스에 기반클래스가 있으면,주생성자에서 기반클래스의 생성자를 호출해야함
		class abc(val name:String,val age:Int=0):ab(name){}
	이렇게 주생성자에 있는 프로퍼티나 파라미터를 넘겨줄수있음
	
	해당클래스의 생성자를 막고싶으면(인스턴스생성못하게)
		class abc private constructor(){}
	이렇게 해버리면 생성을 못하게할수있음,
	근데 그냥 함수를 최상위로 뽑거나(유틸클래스),싱글톤쓰려면 object를 사용해서 객체를 선언하는걸 선호하는듯
	
	생성자를 여러개쓰고싶으면
		class abc(_name:String,_age:Int){
			constructor(_name:String,_age:Int,_email:String){
				코드
			}
		}
	이렇게 부생성자를 사용하는거도 가능
	아예 주생성자를 없애고 부생성자만 여러개 쓰는거도 가능
		class abc{
			constructor(_name:String,_age:Int,_email:String){
				코드
			}
			constructor(_name:String,_age:Int,_email:String,_post:String){
				코드
			}
		}		
	어지간하면 디폴트값으로 처리하고,아예 파라미터가 달라지는경우엔 어쩔수없이 이렇게써야함
	그리고 주생성자가 없으면 부생성자에서 반드시 상위클래스를 초기화하거나,다른생성자에다가 생성을 위임해야함,즉 한번은 상위클래스를 초기화해야함		
		constructor(_name:String,_age:Int,_email:String):super(_name){}
		constructor(_name:String,_age:Int,_email:String,_post:String){
			super(_name) //상위클래스 생성자 호출
			코드
		}
	이런식임
	
	코틀린에선 인터페이스에 추상 프로퍼티를 넣을수있음
		interface abcd{
			val name:String
		}
	그리고 여기서 커스텀게터세터를 넣을수도있음
			interface abcd{
			val email:String
			val name:String
				get()=email.subStringBefore("@")
		}
	이경우에도 상태가 없는건 맞아서,구현하는데서 프로퍼티를 상속해야하는데,이떄 게터세터를 커스텀할수있음
	3가지방법이 있는데
		class abcde (override val name:String):abcd{}//1번
		
		override val name:String  //2번,내부필드에서 오버라이드하고 게터생성
			get()=abcd.subStringBefore("!") //필드를 사용하지않고 그냥 매번 해당값 계산해서리턴
		override val name="qwer" //3번 내부필드에서 값입력
	이렇게
	
	커스텀게터세터에서 자기자신의 필드값을 읽을땐,field를 사용하면됨
		override val name:String
			set(value:String){
				field=value
			}
	이렇게하면됨
	그리고 접근자의 가시성을 바꾸려면
		val name:String
			private set
	이렇게 하면됨
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
		
		