kubectl get pods
kubectl get pods --namespace=네임스페이스명
kubectl get pods --all-namespace
kubectl get all
kubectl describe pod123
kubectl run 파드명 --image=nginx   (파드는 런임 크리에이트안됨)
kubectl run 파드명 --image=nginx --labels=tiers=db 이런식으로 레이블은 넣으면됨
kubectl expose deployment 디플로이먼트명 --name=서비스 이름   기타등등(서비스 특정디플로이먼트에 생성할때)
,포드도 가능,이러면 셀렉터에 포드나 디플로이먼트가 가지고있던 레이블 전부가 들어감
kubectl run 파드명 --image=nginx --port=80 --expose 이런식으로 바로 서비스생성도 가능


kubectl describe 머시기 | grep -i image나 뭐 찾을거

kubectl run nginx --image=nginx
kubectl run nginx --image=nginx --dry-run=client -o yaml
kubectl create namespace dev
kubectl create ResourceQuota
kubectl create deployment --image=nginx nginx
kubectl create deployment --image=nginx nginx --dry-run=client -o yaml
kubectl create deployment --image=nginx nginx --dry-run=client -o yaml > nginx-deployment.yaml
kubectl create deployment --image=nginx nginx --replicas=4 --dry-run=client -o yaml > nginx-deployment.yaml

kubectl scale deployment --replicas=5 디플로이먼트명

servicename.namespace.svc.cluster.local

kubectl config set-context $(kubectl config current context) --namespace=dev

노드접근시 curl ip or dns(노드 ssh접근):포트(그노드의 포트접근)

서비스도 셀렉터넣어서 선택












yaml로 생성시 api버전
	pod:v1
	service:v1
	replicaset:apps/v1
	deployment:apps/v1
	
	
apiVersion: v1
kind: Pod
metadata:
	name: pod123
	namespace: dev
	labels:
		app: myapp
spec:
	containers:
		- name: con123
		  image: nginx
		  port: 80

apiVersion: apps/v1
kind: ReplicaSet
metadata:
	name: repl123
	labels:
		app: repl
spec:
	replicas: 3
	selector:
		matchLabels:
			app: podre1
	template:
		metadata:
			name: pod123
			labels:
				apps: podre1
		spec:
			containers:
				- name: pod123
				  image: nginx

apiVersion: v1
kind: Service
metadata:
	name: pod123
	namespace: dev
	labels:
		app: myapp
spec:
	type:LoadBalancer
	ports:
		- targetPort: 80
		  port: 80
		  nodePort: 30008		  
		  
For Windows: Ctrl+Insert to copy and Shift+Insert to