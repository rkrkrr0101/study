1.쿠버네티스란
	클러스터:쿠버네티스가 최종 사용자에게 줄수있는 전체 컴퓨팅 리소스를 제공하기위해 작동하는 여러시스템
		  쿠버네티스클러스터는 모두 단일 api로 제어되며 해당 api의 사용자가 사용할수 있는 시스템모음임
	
	나머지는생략
2.쿠버네티스 살펴보기
1.컨테이너
	컨테이너는 컨테이너 이미지,실행중인 프로세스,또는 프로세스를 격리하는 일련의 운영체제 개념을 말함
	보통 이 3가지를 혼합한느낌으로 사용함
	
	컨테이너 이미지는 앱 런타임을 포함하는데,이는 바이너리 라이브러리 컨테이너를 실행하는데 필요한 기타데이터로 구성되어 있음
	개발자는 자신의 컴퓨터에서 앱을 컨테이너 이미지로 패키지화하는데(개발자의 컴퓨터 환경 그대로 복사를 하는거)
	그러면 다른 컴퓨터나 서버에서 이미지를 배포하고 실행할때도 동일하게 작동할거라고 신뢰할수 있음
	
	컨테이너 이미지가 실행될땐 운영체제의 네임스페이스를 사용하여 실행됨
	이 네임스페이스는 프로세스를 포함하고 있으며,시스템에서 실행중인 다른 프로세스나 그런것들과 격리할수 있음
	즉 각 컨테이너는 분리된 고유한 파일시스템을 가지고있음을 의미하고,
	또한 각 컨테이너에 고유한 자체 네트워크와 프로세스식별자 네임스페이스가 있음을 의미함
	
	그리고 제어그륩을 사용하면 cpu나 메모리같은 리소스사용도 격리할수 있음
	
	이렇게 이미지를 뜨기위해 컨테이너 이미지 빌더 같은걸 기반으로 라이브러리등을 사용해서 이미지를 뜨고,
	이미지 레지스트리에 이미지를 푸시해서 거기서 받아쓰는형식으로 사용함
	
	푸시한 다음에 컨테이너를 사용해서 이미지를 받아서 써야하는데,이때 컨테이너 오케스트레이션을 사용함

2.컨테이너 오케스트레이션
	레지스트리에서 이미지를 저장후 동작하는 앱을 만들려면 컨테이너 이미지를 실행시켜야 함
	이때 쿠버네티스가 필요해지는데,쿠버네티스의 역할은 cpu,메모리같은 리소스를 가져와서 컨테이너를 배포하는데 사용할수 있도록
	컨테이너 지향 api로 변환하는것
	즉,쿠버네티스 api를 사용하면 컨테이너 이미지를 실행하기위해선 코어3개와 메모리 4기가가 필요합니다 처럼 원하는 상태를 표현할수 있어짐
	
	쿠버네티스 시스템은 이 리소스를 검토하고,이 이미지가 실행될수 있는 위치(노드)를 찾아서 해당위치에서 컨테이너가 실행되도록 스케줄 함
	개발자는 실행되는것만 확인하면되고,어디서 실행됐는지는 관심가질필요가 없음
	
	오케스트레이션 시스템은 컨테이너를 서버에 스케줄하는것 이상의 역할이 있음
	문제가 발생했을때 컨테이너를 복구하는것도 얘의 역할
	컨테이너 내부의 프로세스가 충돌하면 쿠버네티스가 이를 다시 시작함
	사용자 정의 상태 검사(헬스체크)를 정의하면,앱이 교착상태에 있어서 다시시작해야하는지(정상검사),로드밸런싱 조정 서비스(준비상태검사)를 해야하는지
	를 알수있음
	
	로드밸런싱(부하분산)과 관련하여 쿠버네티스는 다양한 레플리카간 트래픽의 로드밸런싱 방법을 정의하는 오브젝트도 제공함
	api오브젝트는 실행중인 컨테이너를 나타내는 로드밸런서를 생성해라같은 상태를 표현할수 있는 방법도 제공함
	이런 로드밸런서에는 검색하기 쉬운 이름이 부여되니까 클러스터내에서 쉽게 연결할수 있음
	
3.쿠버네티스 api
	쿠버네티스는 http,json기반의 restful api이며,api서버가 제공됨
	쿠버네티스의 모든 구성요소는 api를 통해 통신함
	
	1.기본오브젝트
		파드:파드는 가장 작은단위임,하나이상의 컨테이너로 구성되고,파드내에서는 네임스페이스와 네트워크를 컨테이너들끼리 공유함
		    레플리카(복제)의 단위기 때문에,보통 컨테이너 하나넣고 쓰는듯
			
		레플리카셋:파드들을 복제하기 쉽게 하나이상의 파드들을 묶어서,갯수를 지정해둔것
			   레플리카 숫자만 바꿔주면 알아서 파드갯수가 바뀜,복제는 시스템에서 알아서 해주니까 신경안써도됨
			   
		서비스:레플리카셋으로 복제하고 그냥 두면 한군데 트래픽이 몰리니까,그 트래픽을 로드밸런싱 하고,파드간의 통신을 할때 사용하는 오브젝트
			서비스가 생성되면 고정ip주소가 할당되고 패킷이 거기로 들어가면,이 서비스를 구현하는 파드집합으로 로드밸런스됨
			
			고정ip주소가 주어지면 dns이름이 클러스터의 dns서버에 프로그래밍되는데,이 dns이름은 서비스오브젝트와 같은(바로가기같은느낌)취급이고
			클러스터의 다른 컨테이너가 서비스의 ip주소를 검색할수 있게 해줌
			
			그리고 서비스의 로드밸런싱은 클러스터의 네트워크 패브릭에 프로그래밍되어,
			서비스ip주소와 통신하려고 시도하는 컨테이너가 파드에 로드밸런싱되는 형식으로 이루어짐
			이 패브릭프로그래밍은 동적이므로,파드가 어디로가든 재시작하든 뭘하든 클러스터의 현재상태와 일치하게 갱신되기때문에
			파드의 위치에 대해 신경안쓰고 맡겨도됨
		
		스토리지(퍼시스턴트 볼륨,컨피그맵,시크릿):
			볼륨은 파드에 볼륨을 추가할때 실행중인 각 컨테이너의 임의의 위치에 볼륨을 연결하도록 선택할수 있고,
			이렇게 컨테이너가 볼륨내 스토리지에 접근함
			다른컨테이너는 이 볼륨을 다른위치로 연결하거나(한볼륨을 두군데이상에서 동기화시키는식으로 쓸수있음),
			볼륨을 무시할수있음
			
			컨피그맵은 구성파일의 모음을 나타내는데,역시 이것도 용량을 차지하니까 볼륨으로 볼수있음 
			컨피그맵을 파드에 추가하면 컨테이너의 지정된 디렉토리에서 나타남
			
			그리고 시크릿은 볼륨내에서 컨피그맵과 동일하게 동작함
			시크릿은 볼륨으로 파드에 부착할수있고,컨테이너에 연결할수있음
			
			그리고 그냥볼륨을 써서 파드를 배포하면 모든 파드에 같은 볼륨을 연결해야한다는 문제때문데 퍼시스턴트 볼륨이 나옴
			이건 파드에 직접 볼륨을 결합하는 대신 별도의 오브젝트가 생성되고(퍼시스턴트볼륨),
			퍼시스턴트볼륨클레임이 이걸 특정 파드에 할당하고 이 요청으로 파드에 최종적으로 연결됨
			즉 서비스처럼 중간에 객체를 둬서 얘를 가지고 자동적으로 볼륨을 생성하고,상황에따라 다른볼륨을 연결할수있음
			
	2.클러스터 구성 오브젝트:네임스페이스,레이블,어노테이션
		네임스페이스:네임스페이스는 api오브젝트를 위한 폴더임
				클러스터에 있는 다른 모든 오브젝트를 포함하는 디렉터리로,종류별로 특정 폴더에 몰아넣고 거기다 기능이나 규칙을 적용시킬수있음
				네임스페이스를 삭제하면 그 안에 있던거 전부 사라지니까 주의해야함
				그것외에도 서비스용으로 작성된 dns이름과 컨테이너에 제공되는 dns검색경로에도 배치됨
		레이블과 레이블쿼리:
			레이블은 자기가 속한 집합(직접적으로)을 나타냄
			레플리카셋이나 디플로이먼트가 복제할때 갯수셀때도 레이블가지고 갯수를 세는식임
			그리고 검색할때도 키:값 으로 검색하고 저걸 조건으로 무슨 명령같은걸 적용시킬수도 있음
			보통 적용할 오브젝트 집합을 식별하는방법으로 노드셀렉터나 파드셀렉터같은 레이블셀렉터를 사용함
			이게 쿠버네티스가 느슨하게 오브젝트를 결합하는 기본적인 방법
		어노테이션:
			얘는 오브젝트 자체에 대한 주석임
			이건 시스템이 받아서 설정으로 쓰거나,아예 사용자가 주석으로 쓰려고 전화번호같은걸 적어둘수도 있음
			시스템은 여기서 아이콘같은걸 받거나 할수있음(키워드:밸류로 정확히썼을때)
	
	3.고급오브젝트:디플로이먼트,인그레스,스테이트풀셋
		디플로이먼트:레플리카셋에 배포기능을 추가한것
				다음버전으로 업데이트선언이 들어오면,레플리카셋을 내부적으로 하나 더 만들어서 그쪽으로 옮긴뒤 원래있던걸 삭제하는식
				여기서 한번에 다옮기지않고 25%정도씩 잘라가면서 옮김
		인그레스:서비스는 간단한정도의 로드밸런싱은 되지만 좀 커지면 분야가 아님
			  이때 사용하는게 http를 이해하는 인그레스임
			  얘는 경로및 호스트기반 http로드밸런서와 라우터를 나타냄
			  얘도 똑같이 가상ip주소를 받지만,얘는 http요청내용을 사용해서 다른 서비스로 라우팅함,
			  즉 서비스간에 로드밸런싱을 함
			  
		스테이트풀셋:앱은 수평으로 복제되고 같은레플리카로 취급될때 올바르게 작동함
				근데 어떤애들은 순서대로 실행시켜야하고 그런 상태가 필요할수 있는데,이때 스테이트풀셋을 사용함
				얘는 생성될때 0부터 n번까지 순서대로 생성되고 실행되고,삭제될떈 마지막부터 순서대로 삭제됨
				
	4,배치워크로드:잡과 크론잡
		잡:잡은 일회성으로 실행해야할 작업 집합
		  레플리카셋및 스테이트풀셋과 마찬가리고 컨테이너이미지를 실행해서 작업을 실행하는 파드를 생성하는데,
		  얘는 작업을 완료하고 종료할떄까지만 실행됨
		크론잡:얘는 잡에 일정을 추가해서 한시간단위같은 일정주기로 잡을 실행시킴
	
	5.클러스터 에이전트와 유틸리티:데몬셋
		데몬셋:데몬셋은 모든 노드에 하나씩 실행시켜야할때 사용됨
			 이걸 생성하면 각 노드가 데몬셋파드가 실행중인지 시스템이 계속 확인하면서 꺼지면 재생시키고,노드가 추가되면 추가하고 함
			 즉 모든노드에서 실행시켜야할게 있을때 사용


3.아키텍쳐
1.개념
	1.선언적구성
		쿠버네티스는 선언적 구성을 사용하는데,이게 쿠버네티스의 메인동작원칙임
		모든 행위는 선언적형태로(a파드 5개 이런식)으로 원하는 상태로 선언되고,+2개같은 명령으로 관리하지않음
		그리고 쿠버네티스는 그 선언된거에 책임을지고 5개로 만들어 둠
		그래서 노드에 문제가 생겨도 상태를 유지하려하기때문에 따로 뭐 손댈게없음
	2.조정 또는 컨트롤러
		이렇게 자가복구나 자가수정을 수행하기위해 쿠버네티스는 독립조정 또는 제어루프기반으로 구성됨
		보통 이런걸 설계할때 단일상태기반접근방식과 분산형 컨트롤러 방식이 있는데
			단일상태기반접근방식은 시스템이 모든걸 다 처리하는식임
			근데 이건 이해하긴쉬운데 문제생기면 전체가 다운됨
		
			분산형컨트롤러는 모든 작업을 최소단위로 잘라서,각 컨트롤러는 그 최소단위에만 책임을 지고 동작함
			이건 전체가 다운안된다는 장점이 있지만,이해하기가 힘듬(컨트롤러가 너무많으니까)
			
		쿠버네티스의 패턴은
			1.원하는상태를 받음(yaml로)
			2.그 오브젝트를 관찰함
			3.원하는상태와 오브젝트의 차이점을 찾음
			4.원하는상태와 일치하도록 조치함
		으로 이루어져있음
	3.암시적 또는 동적 그룹화
		여러 레플리카를 그룹화하든,로드밸런서의 백엔드를 식별하든 어쩌든 일단 걔가 속한 그룹을 구별해야함
		그때 암시적그룹과 명시적그룹이 있음
		
		명시적 그룹은 그 그룹에 속한 모든 멤버를 명시적으로 적는식이고,
		암시적 그룹은 멤버가 그 그룹의 키를 가지고있으면 그 그룹에 속하는식임
		
		명시적 그룹은 멤버가 잘 안바뀔떄 쓰는데,쿠버네티스의 경우엔 맨날맨날 바뀌고 파드단위가 언제든 사라질수 있기때문에 사용하지않음
		그래서 암시적 그룹을 사용함
		
		암시적 그룹은 항상 바뀔수있어서 서치에 코스트가 좀 들긴하지만,안정적이며 계속 그룹목록을 감시하지않아도되서 유연함
		
		쿠버네티스에서 암시적 그룹화는 레이블과 레이블셀렉터로 수행함

2.구조
	1.유닉스철학
		쿠버네티스는 일반적인 유닉스 철학인 각자 일을 잘 수행하는 작은조각,즉 모듈화를 기반으로 함
		쿠버네티스는 단일 바이너리에서 모든기능을 구현하지 않고,전체 시스템을 구현하는 작은 조각들의 모음임 
		그래서 api부분만 잘 맞춰주면 모든 모듈들을 교체할수 있음 
	2.api기반 상호작용
		쿠버네티스의 모든 상호작용은 api서버를 통해 이루어짐
		여기서 중요한점은 구성요소들이 사용하는 api가 사용자가 사용하는 api와 완전히 같다는것
		이건 시스템의 어느부분도 다른부분보다 특권을 갖지않고 상호간에 직접접근할수없다는것
		그래서 api만 맞춰주면 모든 구성요소를 대체하여 구현할수있음
		
		그리고 이건 버전이 좀 차이나도 시스템이 안정적으로 동작하게함(어짜피 api기반이니까 그게바뀌지않으면 됨)
		물론 api가 바뀌면 손대야하긴하지만
3.구성요소
	쿠버네티스는 워커와 헤드(마스터) 노드로 나누어지고,
	인프라를 구성하는 대부분의 요소는 헤드,컨트롤,플랜,노드에서 실행됨
	클러스터에는 일반적으로 노드수가 홀수인데 이 노드에는 etcd나 api서버같은 구성요소들을 실행함
	홀수인 이유는 알고리즘이 홀수여야하는 알고리즘을 사용해서 그럼
	
	그리고 클러스터의 실제 작업은 워커노드에서 수행됨
	
	그리고 쿠버네티스 구성요소가 생성되면 쿠버네티스 클러스터에 스케줄됨
	쿠버네티스의 관점에서 이게 다른작업들과 구별되진않지만,전체 api의 일부에 포함됨

	1.헤드노드의 구성요소
		헤드노드는 쿠버네티스 api기능을 구현하는 핵심요소들이 모아져있음
		일반적으로 그것들만 헤드노드에서 실행되고,헤드노드를 공유하는 사용자컨테이너는 없음
		
		etcd:
			etcd는 클러스터의 핵심임
			모든 클러스터의 오브젝트가 유지되는 키/밸류 저장소를 만들어서 저장함
			etcd는 분산합의 알고리즘으로 스토리지 서버 하나에 문제가 발생해도 데이터를 유지하고 다시 추가될때 복구할수있게 충분하게 복제가 됨
			
			etcd의 중요기능 2가지는
				첫번째는 낙관적인 동시성임,etcd에 저장된 모든값에는 해당 리소스버전이 있고,
				키값쌍이 etcd에 등록되면 특정리소스버전을 조건으로 지정할수있음
				즉 etcd를 사용하면 비교후교환(최신버전인지를 확인하고 교환하는것)을 구현할수 있음
				그러면 사용자가 값을 읽고 다른구성요소가 업데이트하지 않았다는걸 확인후 업데이트할수 있어지고,다중스레드를 안전하게 할수있어서
				서버의 처리량을 크게 줄일수 있음
				
				두번쨰는 워치 프로토콜임
				워치는 클라이언트가 전체 키값저장소의 변경사항을 효율적으로 감시할수 있다는것
				워치를 사용하면 클라이언트가 지속적으로 etcd에 폴링하지않아도 효과적으로 변경사항을 기다리고 대응할수있음
		api서버:
			api서버는 클러스터에서 중앙에서 통신을 담당함
			모든 클러스터내부의 상호작용은 얘를 거쳐서 감
		스케줄러:
			얘는 파드를 실행할 위치를 찾음
			스케줄되지않은 파드를 찾고,파드의 조건에 따라 노드를 선택해서 던져줌
		컨트롤러 관리자:
			얘는 레플리카셋,디플로이먼트,서비스등을 구현할때 필요한 조정제어루프를 실행하는것
			
			
	2.모든 노드의 구성 요소
		쿠블렛:
			얘는 클러스터의 일부인 모든 시스템의 노드데몬임
			얘는 노드의 cpu,메모리등을 클러스터에 연결함
			얘는 api서버와 통신해서 노드에서 실행될 컨테이너를 찾음
			마찬가지로 쿠블렛은 이런 컨테이너의 상태를 다시 api서버에 전달하므로 다른 조정제어루프가 컨테이너의 현재상태를 볼수있음
			
			쿠블렛은 컴퓨터에서 파드로 실행되고 있는 컨테이너의 상태를 스케줄링하고 보고하는것 외에도,
			컴퓨터에서 실행될것으로 예상되는 컨테이너의 상태를 확인하고 다시 시작하는 일을 담당함
			즉 컨테이너에서 문제가 생겨서 api서버로 올라갔다가 다시 내려오는게 아닌,선조치 후보고를 함
			대신 api서버엔 컨테이너 껏다켰다고 보고는 함
		
		kube-proxy:
				   모든 컴퓨터에서 실행되는 다른 구성 요소는 쿠브프록시임
				   얘는 쿠버네티스 서비스 로드밸런서 네트워킹 모델 구현을 담당함
				   얘는 클러스터의 모든 서비스에 대한 엔드포인트를 감시하고있음
				   그런 다음 노드의 네트워크를 프로그래밍해서 서비스의 가상ip주소를 통한 요청이 서비스의 엔드포인트에 도달하게 함(라우팅되게함)
				   쿠버네티스의 모든 서비스는 가상ip주소를 가지며,프록시는 로컬로드밸런서를 정의하고 구현하는 데몬임
				   얘는 클러스터의 어디든 파드에서 파드로 트래픽이 라우팅하게 함
	3.스케줄된 구성요소
		모든 요소들이 성공적으로 작동하면 최소한 실행 가능한 클러스터임
		근데 실질적으로 무조건쓰는게 몇개 더있음
		
			쿠버dns:
				서비스가 생성되면 가상ip주소를 얻지만,이걸 dns로 바꿔야 쉽게 쓰기좋음
				얘는 그 ip:문자열을 담당함
				얘 자체는 서비스로 표현되므로 프록시가 제공하는 동일한 라우팅이 dns트래픽을 쿠버dns컨테이너로 라우팅함
				중요한 차이점은 얘는 정적 ip주소가 부여된다는것
				즉 같은 스트링으로 어디 설정되는 신경안쓰고 저 정적주소를 넣으면 된다는것
				
			힙스터:
				요즘은 폐기됨
				얘는 모든 컨테이너의 cpu,메모리등의 메트릭을 수집하고 이걸모니터링할수있게 푸시해줌
				요즘은 메트릭서버가 기본임





				   

4.api서버
1.기본특성
	api서버는  모든 api서버의 상태는 외부에 저장되므로(etcd같은) api서버자체는 스테이트리스이고,
	부하관리와 고장대비를 위해 복제할수있음
	
	api서버는 로그를 출력하는데,받은 모든 요청에 대해 최소 1줄의 라인을 출력함
	그래서 용량 많이차지하니까 로그 로테이트식으로 오래된거 삭제하는식으로 씀
	
	그래도 api서버가 분석할때 제일중요하니까,외부하드에 저장계속하는게 나중에 문제생겼을땐 좋음
	
2.api서버의 구성
	1.api관리
		api의 주요 용도는 개별클라이언트의 요청 처리하는거지만,클라이언트가 api요청을 할땐 어떻게하냐면,
		api서버는 http서버이므로 모든 api요청은 http요청임

	2.api경로
		api요청은 http주소로 시작하는 restful api패턴을 따름
		모든 쿠버네티스 요청은 접두사/api/핵심api 또는 /apis/(api그룹별로 그룹화된api)  로 시작함
		api그룹은 원래 쿠버네티스api에 없었기 때문에 파드나 서비스같은 오리지널,코어 오브젝트는 api그룹이 없고
		후속 api들은 api그룹 아래 속하게됨
		예를들어 잡은 /apis/batch/v1/...경로에 있음
		
		리소스 경로에 대한 또 다른 정보는 리소스가 네임스페이스인지 아닌지임
		네임스페이스는 오브젝트에 그룹화 계층을 추가하고,네임스페이스 내에서만 네임스페이스 리소스를 만들수있으며,해당 네임스페이스이름은
		리소스의 http경로에 포함됨
		물론 네임스페이스에 없는 리소스도 있고,이경우에는 http경로에 네임스페이스 구성요소가 없음
		
		네임스페이스 리소스가 들어간 유형의 경로는
			 /api/v1/namespaces/<namespace-name>/<resource-type-name>/<resource-name>
			 /apis/<api-group>/<api-version>/namespaces/<namespace-name>/<resource-type-name>/<resource-name>
		이런식이고
		없는거의 유형은
			/api/v1/<resource-type-name>/<resource-name>
			/apis/<api-group>/<api-version>/<resource-type-name>/<resource-name>
		이렇게 네임스페이스만 빠져있음
	3.api검색
		api에 요청을 할수 있으려면 클라이언트가 어떤 api 오브젝트를 쓸수 있는지 알아야함
		이건 클라이언트측에서 api검색으로 수행함
			로컬호스트:포트/api
		를 날리면 api를 리턴하는데 
		
		거기의 종류별로 verbs가 사용할수 있는 api임
		다 이름 그대론데
			watch는 리소스에 대한 감시를 설정하는거고
			proxy는 api서버로 네트워크 포트에 프록시 네트워크 연결을 설정하는 특수작업임
			
		이거외에 리소스유형에서 하위리소스로 모델링된(pods/attach 같은식) 작업도 있음
		attach는 exec랑 비슷하게 파드 내에서 실행중인 컨테이너에 터미널을연결하는 기능임
	4.오픈 api 규격
		api서버에 엑세스할때 사용하는 리소스와 경로를 아는건 액세스에 필요한 정보의 일부임
		경로 외에도 보내고 받을 json페이로드를 알아야함
		api서버는 리소스스키마에 대한 정보를 알려줄 경로도 제공함
			/openapi/v2
		로 알아볼수있음 
		근데 뭐 오픈api로 api만들일이 있을까
	5.api변환
		api는 알파에서 시작해서(불안정함)베타를 거쳐 v1(ga,일반가용성)이 됨
		v1찍으면 한 1년은 확정적으로 쓸수있음
		
		쿠버네티스의 api는 api표현을 3가지로 함
			외부는 api요청으로 들어오는표현
			내부는 api서버 내에서 처리되는 오브젝트의 내부메모리
			스토리지는 api오브젝트를 지속시키기위해 스토리지 계층에 기록(etcd에 기록)
		즉 외부에서 요청들어오면 내부로가서 스토리지에 적고 리턴값 외부로 다시보내는식

3.요청관리
	쿠버네티스에서 api서버의 주요 목적은 http요청의 형태로 api호출을 수식하고 처리하는것
	이 요청들은 사용자가 하거나,시스템의 다른 구성요소에서 한것,
	이 두개 전부 같은방식으로 똑같이 처리됨
	
	1.요청의 유형
		get:특정 리소스에 관한 데이터를 달라는것
			즉 파드의 이름적고 보내면 그 파드에 대한 데이터를 줌
			
		List:이건 레이블을 조회하거나,특정 오브젝트를(디플로이먼트나 서비스나 그런) 검색하는것
			 오브젝트이름도 레이블이라고 볼수있으니 레이블조회라고 보면될듯
			 이거도 네임스페이스 선택해서 조회할수도 있고,특정오브젝트의 레이블을 검색할수도있음
		Post:리소스를 생성할때 사용 
			요청 메세지의 본문에는 새로 만들 리소스를 넣음
			post요청의 경우 경로는 리소스유형임(/api/v1/namespaces/default/pods 이런식)
			기존 리소스를 업데이트 하려면 특정리소스경로(/api/v1/namespaces/default/pods/파드이름)
			로 보냄
		delete:요청을 삭제할 시간이 되면 리소스경로에 대한 http delete요청이 사용됨
			   이건 영구적이므로 http요청이 만들어진 후에는 리소스가 삭제된다는거에 유의해야함


	2.요청의 수명
		인증:요청의 첫단계는 인증임
			api서버는 클라이언트 인증서,베어러 토큰,http 기본인증등 여러 인증모드를 지원함
			일반적으로 클라이언트 인증서,베어러토큰을 사용함
			이거외에도 다른 인증을 추가할수있음 
			
		rbac/인가:api서버가 요청에 대한 id를 판별하면 인가로 이동함
				쿠버네티스에 대한 모든 요청은 전통적인 rbac(역할기반접근제어)를 따름
				즉 롤에 따라 권한이 있는지 판별하고 ok fail을 날림
				
		승인제어:요청이 인증되고 인가되면 승인제어로 이동함
			  얘는 요청이 올바른 형식인지 판별하고(문법)요청이 처리되기전 수정사항을 잠재적으로 적용함(묵시적으로 허용된 단일형을 복수형으로 바꾼다던지)
			  여기서 오류가 판별나면 에러띄우고 리턴함
			  얘는 일반적인기능이라서 api서버의 다양한 기능에 사용됨
			  오브젝트에 기본값을 추가하는거나,정책을적용할때(모든 오브젝트엔 특정 레이블이 있어야한다 이런거)
			  그리고 모든 파드에 추가 컨테이너를 주입할때 같을때 사용할수있음
			  이런식으로 사이드카 컨테이너를 투명하게 주입가능
			  
		유효성 검사:유효성검사는 단일 오브젝트에 대해서만 수행됨
				얘는 요청에 포함된 특정 리소스가 유효함을 보장함
				즉 서비스이름이 dns에 들어가니까 서비스이름이 dns이름과 관련된 규칙을준수하는지 확인함
				
		전문화된 요청:표준 restful요청 외에도 api서버에는 클라이언트에 확장기능을 제공하는 여러 요청패턴이있음
				 /proxy,/exec,/attach,/logs 등등
				 가장 중요한 작업은 api서버에 장시간 지속되는 개방형 연결임
				 이런 요청은 즉각적인 응답보다 스트리밍 데이터를 제공함
				 
				 logs는 스트리밍 요청으로도 할수있고 일반요청으로도 할수있는데
				 그냥 현재까지 로그달라고하면 일반요청이고,follow 옵션을 붙여서 실시간갱신을 해달라고하면
				 api가 http응답을 계속열어두고 새 로그를 api서버를 통해 쿠블렛에서 수신할때 http 응답에 기록함
				 나머지는 양방향 스트리밍을 위해 웹소켓 프로토콜을 사용하고,http를 통해 이런 스트림데이터를 다중화해서
				 다수의 양방향 스트리밍을 가능하게 함
				 웹소켓은 http를 양방향 바이트 스트리밍 프로토콜로 변환하는 프로토콜이라고 생각하면됨
				 
				 이런거 외에도 여러 다중화 스트리밍 프로토콜을 사용하는데
				 보통 api서버가 독립적인 바이트스트림을 서비스하는게 매우 유용하기 때문
				 예를들어 컨테이너 내에서 명령어 실행할때는 stdin stdarr stdout 3개의 스트림을 유지해야함
				 한 웹소켓에서 스트림을 날릴때는 256바이트통신으로 날릴수있고,맨앞에 0,1,2로 구분함
					 0은 stdin,쓰기스트림,프로세스에기록,여기서는 데이터를 읽지않음
					 1은 stdout,출력스트림,프로세스에서 stdout을 읽음,이스트림에 데이터를 쓰면안됨
					 2는 stdarr,출력스트림,프로세스에서 stdarr을 읽음,이스트림에 데이터를 쓰면안됨
				 
				 /proxy는 클라이언트,클러스터 내에 실행중인 컨테이너나 서비스간의 통신을 외부에 노출없이 포트전달을 할수있도록 사용됨
				 이때는 첫바이트 뒤에 포트번호용 바이트 2개가 추가됨
		
		워치 동작:스트리밍외에도 api서버는 워치api를 지원함
			   워치는 변경경로를 모니터링함
			   폴링이빠르면 추가로드가 발생하고,느리면 지연시간이 길어지니,
			   대신 워치를 쓰면 한개의 연결로 짧은 업데이트가 가능함
			   사용자가 일부 api서버요청에 쿼리파라미터(?watch=true)를 추가해서 api서버에 감시연결을 설정하면,
			   api서버는 워치모드로 전환되고 클라이언트 서버간의 연결이 열린상태로 유지됨
			   마찬가지로 api서버가 반환하는 데이터는 더이상 api오브젝트가 아니고 변경유형과 api오브젝트를 포함하는 watch오브젝트임
			   이런식으로 클라이언트는 해당 오브젝트또는 오브젝트 집합에 대한 모든 변경사항을 관찰할수있음
			   
		낙관적 동시 업데이트:
			낙관적 동시성은 잠금장치를 사용하지 않고 대부분의 작업을 수행하고,동시쓰기가 발생하면 이를 감지해서 마지막쓰기를 거부하는것
			거부된 쓰기는 재시도되지않고 재시도하는건 클라이언트에 달려있음
			이떄 사용되는게 버전정보임
			자기가 읽었을때의 버전정보를 기억하고있다가 쓸때 확인하고 쓰고,만약 다르면 요청을 거부함
			직렬적으로 하면 순서대로 명령이 쌓이니까 성능상에 이슈가 발생하는데,이러면 병렬적으로 처리되기때문에 문제가 안생김
		
		대체 인코딩:
			api서버는 요청에 대해 json과 yaml,프로토콜 버퍼 인코딩을 사용할수있음
			요청의 인코딩 구분은 헤더로 구분함
			그리고 프로토콜 버퍼 인코딩은 처리량요청이 효율적이고 많아지는데,시각화하는게 어렵고 일부 클라이언트 라이브러리는 지원을 안함
		공통 응답 코드:
			202:수락됨,오브젝트를 만들거나 삭제하는 비동기요청이 수신됨,완료시점에 실제오브젝트가 반환
			400:잘못된 요청,서버가 요청을 구문분석할수없음
			401:권한없음,요청을 받았고 이해했지만 인증체계없이 요청이 수신됨
			403:금지된요청,요청을 받았고 이해했지만 접근이 금지됨
			409:충돌,요청을 받았지만 이전버전의 오브젝트 업데이트요청임
			422:처리할수없음,요청을 받았고 이해했지만 검증에 실패함
4.api서버 내부
	http restful 기본사항 외에도 api의 일부를 구현하는 몇가지 내부 서비스가 있음
	이런 제어루프는 api서버가 아닌 컨트롤러 관리자에서 실행되는데,일부는 api서버에서 실행해야함
	
	1.crd제어루프
		커스텀 리소스 데피니션(crd)는 실행중인 api서버에 추가할수 있는 동적 api 오브젝트임
		crd를 만드는건 새로운 http경로를 생성하므로 api서버는 서비스하는 방법을 알아야 함
		그래서 api서버내에 이런 경로를 추가하는 컨트롤러가 배치됨
		
		커스텀리소스의 경로생성은 쉽지만,삭제할땐 해당 유형의 자원과 관련된 모든 데이터를 삭제하기때문에 복구할수없음

5.api서버 디버깅
	api서버를 디버깅할땐 로그를 보고 해야함
	api의 로그는 기본로그 뿐 아니라 요청이 발생한 이유와 변경된 api서버 상태를 캡쳐하는 감사로그까지 크게 2종류가 있음
	그리고 특정 문제를 디버깅하기위해 더 자세히 설정할수도 있음
	
	1.기본로그
		기본적으로 api서버는 api서버로 전송되는 모든 요청을 기록함
		이 로그에는 클라이언트의 ip주소,요청경로,서버에서 반환한 코드가 포함됨
		예상못한 오류로 서버가 패닉에 빠지면 500오류를 반환하고 기록됨
		이 로그의 기록은 타임스템프 I0803(날짜) 19:59(시간)으로 시작하고 해당로그를 기록한 trace.go:76이 따라붙고 로그메시지로 구성됨
	2.감사로그
		감사로그는 쿠버네티스 api의 현재 데이터 상태를 유발한 서버의 상태와 일련의 클라이언트 상호작용을 서버 관리자가 포렌식으로 복구할수있게 기록한것
		즉 레플리카셋이 왜 레플리카가 100이됐는지,파드를 누가 삭제했는지 같은 기록이 남음
		감사로그는 기록된 위치에 대한 장착형 백엔드가 있음
		보통 감사로그는 파일에 기록되지만 웹훅에 기록될수도 있음
		두 경우 모두 기록된 데이터는 구조화된 json오브젝트임
	3.추가 로그 활성화
		로깅 세부수준을 조정해서 더 자세히 받을수도 있고 좀 덜받을수도 있음,기본값은 2인데 그냥 안건드리는게좋음
		특정부분에만 더 자세히적히길원하면 --vmodule플래그로 개별파일의 로그수준을 올릴수있음
	4.kubectl 요청 디버깅
		로그를 통해 디버깅하는것 외에도 kubectl명령줄 툴로 서버와 상호작용을 디버깅할수도 있음
		api서버와 마찬가지로 kubectl도 패키지로 로깅하고 --v상세표시플래그를 지원함
		
5.스케줄러		
	스케줄링은 워커노드에 컨테이너를 스케줄링하는것
1.스케줄링이란
	파드를 만들면 보통 nodeName이 없음
	nodeName은 파드가 실행될 노드를 나타내는데,스케줄러는 이런 노드네임이 없는 파드에 대해(watch로)api서버를 지속적으로 검사함
	이런파드들은 스케줄링의 대상이 됨
	그런다음 스케줄러는 파드에 적합한 노드를 선택하고,스케줄러가 선택한 노드네임으로 파드정의를 업데이트 함
	그렇게 노드네임이 생기면 해당노드에서 실행중인 쿠블렛은 파드가 있는지없는지(watch로)알게되고 해당파드가 없으면 해당파드를 실제로 실행시킴
	
	스케줄러를 건너뛰려면 노드네임을 적어줄수있긴한데,일반적으로는 이런식으로 하면 안됨,직접스케줄링은 클러스터의 효율성을 떨어뜨림
	
2.스케줄링 프로세스
	스케줄러가 노드에 할당되지 않은 파드를 발견하면 파드를 스케줄링할 노드를 결정해야함
	파드에 알맞은 노드는 여러 요인에 따라 결정되며,그중 일부는 고객이 제공하고 일부는 스케줄러가 계산함
	
	1.사전조건
		파드를 스케줄링할때 보통 2가지개념을 써서 결정함
		첫번째는 사전조건
		사전조건은 파드가 특정 노드에 적합한지를 나타냄
		사전조건은 엄격한 제한조건이라서 이걸 통과못하면 그 노드에는 절대 들어갈수가 없음
		여기에 들어가는게 메모리최소치나 레이블셀렉터 조회결과등이 있음
	2.우선순위
		두번쨰는 우선순위임
		이건 반드시 필요하진 않지만 이게 ok가 나면 점수가 높아져서,사전조건을 전부만족한애들끼리는 이게 높으면 데려감
		즉 특정 노드에 대한 스케줄링의 상대적 가치를 나타냄
		예를들어 이미 이미지가 있는 노드에 가중치를 줘서 이미지 재다운을 안해도되게 한다던가 같은거
		
		spreading는 우선순위중에 제일 중요한기능인데,같은 쿠버네티스 서비스 멤버인 파드가 없는 노드의 우선순위를 결정함
		이는 시스템이 고장나 특정 서비스의 모든 컨테이너를 사용할수 없을 가능성을 줄임(파드를 퍼트려서)
	3.상위레벨 알고리즘
		스케줄링에 필요한 모든 파드에 스케줄링 알고리즘이 적용됨
		스케줄러의 기본작동은
			1.현재 알려진 노드와 정상노드의 모든 목록을 가져옴
			2.각 사전조건을 만족하는 노드를 확인하고 목록을 만듬(스케줄링가능한노드목록)
			3.그중 우선순위로 정렬을 하고,제일높은애를 뽑아서 최종목록에 배치함(여기서 점수가 같으면 라운드로빈으로 균일해지게 뽑음)
	4.충돌
		파드가 스케줄링 된 시간과,컨테이너가 실제 실행되는 시간에는 지연시간이 있기때문에,그 사이 다른작업때문에 스케줄링 결정이 무효가 될수 있음
		우선순위조건이 바뀐건 좀 아쉽고 말정도인데,문제는 사전조건임
		만약 그 사이에 사전조건이 바뀌어서 노드가 파드의조건을 만족할수없게되면 파드는 실패한걸로 표시되고,
		레플리카셋은 그 파드를 지우고 새 파드를 만들어서 다시 스케줄링함
		
		여기서 중요한건,파드를 지우고 다시스케줄링하는건 레플리카셋(디플로이먼트)이기때문에 파드가 하나라도 반드시 레플리카셋으로 실행해야함
			

3.스케줄링 제어하기
	쿠버네티스가 하는 스케줄링을 세밀하게 제어하고싶으면,각자의 사전조건과 우선순위를 추가할수도 있지만,그러면 일이 많음
	이럴떈 사용자 정의 스케줄링을 할수있게 해주는 툴을 사용하면됨
	
	1.노드셀렉터
		쿠버네티스의 모든 오브젝트에는 연관된 레이블집합이 있음
		레이블로 오브젝트에 대한 메타데이터를 식별할수 있으며,레이블셀렉터로 다양한 작업을 위한 api를 동적으로 식별할수 있음
		
		클러스터에서 특정 파드 스케줄링에 사용하는 노드의 부분집합을 식별할때도 레이블셀렉터가 사용될수 있음
		클러스터의 모든 노드는 스케줄링 대상이지만,
		파드의 spec.nodeSelector필드를 넣으면 노드의 초기집합을 저기 적힌 레이블이 있는걸로 줄일수있음
		즉 노드의 레이블의 키:값을 지정하고 일치하는데만 스케줄링할수있음
		그리고 노드셀렉터는 스케줄링시에만 계산됨,노드가 중간에 바뀌면 그거까지는 체크못해줌
	2.노드 어피니티
		노드 셀렉터가 특정 노드에 위치하도록 보장해준다면,노드 어피니티는 좀 더 복잡한 논리표현을 해줌
		a or b 노드라거나,a노드는 안된다거나(!=) 등을 할수있음
		즉 TF와 or and를 지원한다고보면됨
		이거말고도 밸류말고 키만 보고 키가 존재하는지만 볼수도있고 그럼
		
		그리고 이런식으로 사전조건으로 적을수도 있고,저걸 우선순위로 줄수도 있음
			사전조건은 requiredDuringSchedulingIgnoredDuringExecution
			우선순위는 preferredDuringSchedulingIgnoredDuringExecution
			우선순위에서 weight:로 우선순위의 강도도 줄수있음
		그리고 똑같은방식으로 노드어피니티말고 파드어피니티도 가능함
	3.테인트와 톨러레이션
		테인트는 특정 노드에 테인트를 적용하면,그 노드에는 더이상 스케줄링을 하지 않게함
		그리고 톨러레이션은 그 테인트를 무시하고 스케줄링 대상에 추가할수 있게함
		즉 테인트는 그 노드를 오염됐다치고 무시하는거고,
		톨러레이션은 그 노드를 사용할수 있게 해주는건데,중요한건 테인트된 노드만 사용하는게아닌 전체 스케줄링대상에 테인트를 추가하는느낌임
		즉 톨러레이션이 걸려도 테인트노드가 아닌곳에서 실행될수있음
		
		
6.쿠버네티스 설치		
1.쿠베어드민
	쿠베어드민이 보통 설치툴같은데도 메인이 되는 가장 기본적인 설치 툴임
	보통 다른 툴들도 쿠베어드민기반으로 추가해서만듬
	여기엔 쿠블렛이 없으니 쿠블렛은 따로깔아야함

2.컨트롤플레인설치
	컨트롤플레인은 워커노드의 작업을 지시하는 구성요서임
	컨트롤플레인은 api서버,컨트롤러관리자,스케줄러로 이루어져있고,그외 상태저장용으로 etcd가 있음
	쿠베어드민엔 포함되어있음
	1.쿠베어드민 설정
		쿠베어드민을 설치하면 컨피그맵으로 설정들이 생성되어서 저장됨
		클러스터의 구성을 이해하기위한 참조용도와,업그레이드할때 사용할용도
		업그레이드할떈 이 컨피그맵을 수정한후 kubeadm upgrade함
	2.인증서
		쿠베어드민은 인증기관과 키를 생성하는데,보통은 다른데서 받아온거쓰니까 만들기전에 넣어두면 안만들고 그거씀
		kubeadm init하기전에 /etc/kubernetes/pki에 미리 넣어둬야함
		그러면 일단 있는키부터쓰고 없는거만 만듬
	3.etcd
		기본구성요소외에도 별도지정이 없으면 로컬etcd인스턴스를 시작하려고 시도함
		이 데몬은 구성요소와 같은방식으로 시작되고 볼륨연결로 데이터를 유지함
		근데 상용서비스급까지 올라가면 이러진않고 etcd클러스터를 배포함(가용성이높은)
		그리고 쿠버네티스구성요소는 쉽게 교체할수있지만,etcd는 쉽게 못바꾸니(상태가있으니까) 주의
		그래서 쿠버네티스클러스터에서 etcd 클러스터를 분리하는게좋음(상태가있어서 라이프사이클이 다름)
		
		그리고 etcd데이터는 암호화되지않음
		etcd 접근권한을 누가 얻게되면 그 즉시 이용할수있게됨
		뭐 보통은 etcd에 별거없긴한데 시크릿이 문제임
		그래서 시크릿은 암호화되어서 보관되게
			--experimental-encryption-provider-config
		로 대칭키로 암호화를 걸어야함
		
		암호화는 코스트를 소모하기때문에(쓰기성능에), 중요한거만 암호화걸어두는게 좋음
	4.쿠베컨피그
		쿠베어드민은 여러 쿠베컨피그를 생성함
		쿠베컨피그들은 인증수단에 사용됨
		이중 대부분은 api에 대해 쿠버네티스 서비스를 인증하는데 사용됨
	5.테인트
		상용환경에선 워크노드를 컨트롤플레인구성요소(마스터노드)와 분리해둬야함
		그래서 모든 마스터노드를 테인트걸어둠
		만약 마스터노드가 하나고 한컴퓨터에서 다해야하면 풀어둬야함
		
3.워커노드설치
	워커노드도 비슷하게 설치함
	모든노드엔 컨테이너런타임과 쿠블렛이 필요하고,워커노드엔 거기에 더해 kube-proxy데몬이 필요함
	워커노드를 설치할땐 tls부트스트랩(부팅)을 연달아 수행함
	쿠베어드민은 api서버에 공유토큰교환프로세스로 노드를 일시적으로 인증하고,컨트롤플레인ca에 인증서 서명요청을 수행하려고 시도함
	그후엔 이 자격증명을 런타임시 인증메커니즘으로 씀
	뭐 별로신경안써도될거같음

4.애드온
	마스터노드를 설치하고 워커노드를 깔았으면 워크로드를 배포해야하는데,그전에 애드온을 몇개배포해야함
	보통 로그집계,모니터링,서비스메시등을 추가함
	얘들은 쿠베어드민이 관리하지않음 


5.고가용성
	쿠베어드민은 보통 한번에 하나의 노드에서 보기떄문에,고가용성으로 설치하긴 좀 복잡함
	이럴떈 딴거쓰자

6.업그레이드
	업데이트할땐 운용중단없이 하나하나 업그레이드할수있음 필요하면 찾아보자







