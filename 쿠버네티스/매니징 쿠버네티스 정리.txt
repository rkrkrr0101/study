1.쿠버네티스란
	클러스터:쿠버네티스가 최종 사용자에게 줄수있는 전체 컴퓨팅 리소스를 제공하기위해 작동하는 여러시스템
		  쿠버네티스클러스터는 모두 단일 api로 제어되며 해당 api의 사용자가 사용할수 있는 시스템모음임
	
	나머지는생략
2.쿠버네티스 살펴보기
1.컨테이너
	컨테이너는 컨테이너 이미지,실행중인 프로세스,또는 프로세스를 격리하는 일련의 운영체제 개념을 말함
	보통 이 3가지를 혼합한느낌으로 사용함
	
	컨테이너 이미지는 앱 런타임을 포함하는데,이는 바이너리 라이브러리 컨테이너를 실행하는데 필요한 기타데이터로 구성되어 있음
	개발자는 자신의 컴퓨터에서 앱을 컨테이너 이미지로 패키지화하는데(개발자의 컴퓨터 환경 그대로 복사를 하는거)
	그러면 다른 컴퓨터나 서버에서 이미지를 배포하고 실행할때도 동일하게 작동할거라고 신뢰할수 있음
	
	컨테이너 이미지가 실행될땐 운영체제의 네임스페이스를 사용하여 실행됨
	이 네임스페이스는 프로세스를 포함하고 있으며,시스템에서 실행중인 다른 프로세스나 그런것들과 격리할수 있음
	즉 각 컨테이너는 분리된 고유한 파일시스템을 가지고있음을 의미하고,
	또한 각 컨테이너에 고유한 자체 네트워크와 프로세스식별자 네임스페이스가 있음을 의미함
	
	그리고 제어그륩을 사용하면 cpu나 메모리같은 리소스사용도 격리할수 있음
	
	이렇게 이미지를 뜨기위해 컨테이너 이미지 빌더 같은걸 기반으로 라이브러리등을 사용해서 이미지를 뜨고,
	이미지 레지스트리에 이미지를 푸시해서 거기서 받아쓰는형식으로 사용함
	
	푸시한 다음에 컨테이너를 사용해서 이미지를 받아서 써야하는데,이때 컨테이너 오케스트레이션을 사용함

2.컨테이너 오케스트레이션
	레지스트리에서 이미지를 저장후 동작하는 앱을 만들려면 컨테이너 이미지를 실행시켜야 함
	이때 쿠버네티스가 필요해지는데,쿠버네티스의 역할은 cpu,메모리같은 리소스를 가져와서 컨테이너를 배포하는데 사용할수 있도록
	컨테이너 지향 api로 변환하는것
	즉,쿠버네티스 api를 사용하면 컨테이너 이미지를 실행하기위해선 코어3개와 메모리 4기가가 필요합니다 처럼 원하는 상태를 표현할수 있어짐
	
	쿠버네티스 시스템은 이 리소스를 검토하고,이 이미지가 실행될수 있는 위치(노드)를 찾아서 해당위치에서 컨테이너가 실행되도록 스케줄 함
	개발자는 실행되는것만 확인하면되고,어디서 실행됐는지는 관심가질필요가 없음
	
	오케스트레이션 시스템은 컨테이너를 서버에 스케줄하는것 이상의 역할이 있음
	문제가 발생했을때 컨테이너를 복구하는것도 얘의 역할
	컨테이너 내부의 프로세스가 충돌하면 쿠버네티스가 이를 다시 시작함
	사용자 정의 상태 검사(헬스체크)를 정의하면,앱이 교착상태에 있어서 다시시작해야하는지(정상검사),로드밸런싱 조정 서비스(준비상태검사)를 해야하는지
	를 알수있음
	
	로드밸런싱(부하분산)과 관련하여 쿠버네티스는 다양한 레플리카간 트래픽의 로드밸런싱 방법을 정의하는 오브젝트도 제공함
	api오브젝트는 실행중인 컨테이너를 나타내는 로드밸런서를 생성해라같은 상태를 표현할수 있는 방법도 제공함
	이런 로드밸런서에는 검색하기 쉬운 이름이 부여되니까 클러스터내에서 쉽게 연결할수 있음
	
3.쿠버네티스 api
	쿠버네티스는 http,json기반의 restful api이며,api서버가 제공됨
	쿠버네티스의 모든 구성요소는 api를 통해 통신함
	
	1.기본오브젝트
		파드:파드는 가장 작은단위임,하나이상의 컨테이너로 구성되고,파드내에서는 네임스페이스와 네트워크를 컨테이너들끼리 공유함
		    레플리카(복제)의 단위기 때문에,보통 컨테이너 하나넣고 쓰는듯
			
		레플리카셋:파드들을 복제하기 쉽게 하나이상의 파드들을 묶어서,갯수를 지정해둔것
			   레플리카 숫자만 바꿔주면 알아서 파드갯수가 바뀜,복제는 시스템에서 알아서 해주니까 신경안써도됨
			   
		서비스:레플리카셋으로 복제하고 그냥 두면 한군데 트래픽이 몰리니까,그 트래픽을 로드밸런싱 하고,파드간의 통신을 할때 사용하는 오브젝트
			서비스가 생성되면 고정ip주소가 할당되고 패킷이 거기로 들어가면,이 서비스를 구현하는 파드집합으로 로드밸런스됨
			
			고정ip주소가 주어지면 dns이름이 클러스터의 dns서버에 프로그래밍되는데,이 dns이름은 서비스오브젝트와 같은(바로가기같은느낌)취급이고
			클러스터의 다른 컨테이너가 서비스의 ip주소를 검색할수 있게 해줌
			
			그리고 서비스의 로드밸런싱은 클러스터의 네트워크 패브릭에 프로그래밍되어,
			서비스ip주소와 통신하려고 시도하는 컨테이너가 파드에 로드밸런싱되는 형식으로 이루어짐
			이 패브릭프로그래밍은 동적이므로,파드가 어디로가든 재시작하든 뭘하든 클러스터의 현재상태와 일치하게 갱신되기때문에
			파드의 위치에 대해 신경안쓰고 맡겨도됨
		
		스토리지(퍼시스턴트 볼륨,컨피그맵,시크릿):
			볼륨은 파드에 볼륨을 추가할때 실행중인 각 컨테이너의 임의의 위치에 볼륨을 연결하도록 선택할수 있고,
			이렇게 컨테이너가 볼륨내 스토리지에 접근함
			다른컨테이너는 이 볼륨을 다른위치로 연결하거나(한볼륨을 두군데이상에서 동기화시키는식으로 쓸수있음),
			볼륨을 무시할수있음
			
			컨피그맵은 구성파일의 모음을 나타내는데,역시 이것도 용량을 차지하니까 볼륨으로 볼수있음 
			컨피그맵을 파드에 추가하면 컨테이너의 지정된 디렉토리에서 나타남
			
			그리고 시크릿은 볼륨내에서 컨피그맵과 동일하게 동작함
			시크릿은 볼륨으로 파드에 부착할수있고,컨테이너에 연결할수있음
			
			그리고 그냥볼륨을 써서 파드를 배포하면 모든 파드에 같은 볼륨을 연결해야한다는 문제때문데 퍼시스턴트 볼륨이 나옴
			이건 파드에 직접 볼륨을 결합하는 대신 별도의 오브젝트가 생성되고(퍼시스턴트볼륨),
			퍼시스턴트볼륨클레임이 이걸 특정 파드에 할당하고 이 요청으로 파드에 최종적으로 연결됨
			즉 서비스처럼 중간에 객체를 둬서 얘를 가지고 자동적으로 볼륨을 생성하고,상황에따라 다른볼륨을 연결할수있음
			
	2.클러스터 구성 오브젝트:네임스페이스,레이블,어노테이션
		네임스페이스:네임스페이스는 api오브젝트를 위한 폴더임
				클러스터에 있는 다른 모든 오브젝트를 포함하는 디렉터리로,종류별로 특정 폴더에 몰아넣고 거기다 기능이나 규칙을 적용시킬수있음
				네임스페이스를 삭제하면 그 안에 있던거 전부 사라지니까 주의해야함
				그것외에도 서비스용으로 작성된 dns이름과 컨테이너에 제공되는 dns검색경로에도 배치됨
		레이블과 레이블쿼리:
			레이블은 자기가 속한 집합(직접적으로)을 나타냄
			레플리카셋이나 디플로이먼트가 복제할때 갯수셀때도 레이블가지고 갯수를 세는식임
			그리고 검색할때도 키:값 으로 검색하고 저걸 조건으로 무슨 명령같은걸 적용시킬수도 있음
			보통 적용할 오브젝트 집합을 식별하는방법으로 노드셀렉터나 파드셀렉터같은 레이블셀렉터를 사용함
			이게 쿠버네티스가 느슨하게 오브젝트를 결합하는 기본적인 방법
		어노테이션:
			얘는 오브젝트 자체에 대한 주석임
			이건 시스템이 받아서 설정으로 쓰거나,아예 사용자가 주석으로 쓰려고 전화번호같은걸 적어둘수도 있음
			시스템은 여기서 아이콘같은걸 받거나 할수있음(키워드:밸류로 정확히썼을때)
	
	3.고급오브젝트:디플로이먼트,인그레스,스테이트풀셋
		디플로이먼트:레플리카셋에 배포기능을 추가한것
				다음버전으로 업데이트선언이 들어오면,레플리카셋을 내부적으로 하나 더 만들어서 그쪽으로 옮긴뒤 원래있던걸 삭제하는식
				여기서 한번에 다옮기지않고 25%정도씩 잘라가면서 옮김
		인그레스:서비스는 간단한정도의 로드밸런싱은 되지만 좀 커지면 분야가 아님
			  이때 사용하는게 http를 이해하는 인그레스임
			  얘는 경로및 호스트기반 http로드밸런서와 라우터를 나타냄
			  얘도 똑같이 가상ip주소를 받지만,얘는 http요청내용을 사용해서 다른 서비스로 라우팅함,
			  즉 서비스간에 로드밸런싱을 함
			  
		스테이트풀셋:앱은 수평으로 복제되고 같은레플리카로 취급될때 올바르게 작동함
				근데 어떤애들은 순서대로 실행시켜야하고 그런 상태가 필요할수 있는데,이때 스테이트풀셋을 사용함
				얘는 생성될때 0부터 n번까지 순서대로 생성되고 실행되고,삭제될떈 마지막부터 순서대로 삭제됨
				
	4,배치워크로드:잡과 크론잡
		잡:잡은 일회성으로 실행해야할 작업 집합
		  레플리카셋및 스테이트풀셋과 마찬가리고 컨테이너이미지를 실행해서 작업을 실행하는 파드를 생성하는데,
		  얘는 작업을 완료하고 종료할떄까지만 실행됨
		크론잡:얘는 잡에 일정을 추가해서 한시간단위같은 일정주기로 잡을 실행시킴
	
	5.클러스터 에이전트와 유틸리티:데몬셋
		데몬셋:데몬셋은 모든 노드에 하나씩 실행시켜야할때 사용됨
			 이걸 생성하면 각 노드가 데몬셋파드가 실행중인지 시스템이 계속 확인하면서 꺼지면 재생시키고,노드가 추가되면 추가하고 함
			 즉 모든노드에서 실행시켜야할게 있을때 사용


3.아키텍쳐
1.개념
	1.선언적구성
		쿠버네티스는 선언적 구성을 사용하는데,이게 쿠버네티스의 메인동작원칙임
		모든 행위는 선언적형태로(a파드 5개 이런식)으로 원하는 상태로 선언되고,+2개같은 명령으로 관리하지않음
		그리고 쿠버네티스는 그 선언된거에 책임을지고 5개로 만들어 둠
		그래서 노드에 문제가 생겨도 상태를 유지하려하기때문에 따로 뭐 손댈게없음
	2.조정 또는 컨트롤러
		이렇게 자가복구나 자가수정을 수행하기위해 쿠버네티스는 독립조정 또는 제어루프기반으로 구성됨
		보통 이런걸 설계할때 단일상태기반접근방식과 분산형 컨트롤러 방식이 있는데
			단일상태기반접근방식은 시스템이 모든걸 다 처리하는식임
			근데 이건 이해하긴쉬운데 문제생기면 전체가 다운됨
		
			분산형컨트롤러는 모든 작업을 최소단위로 잘라서,각 컨트롤러는 그 최소단위에만 책임을 지고 동작함
			이건 전체가 다운안된다는 장점이 있지만,이해하기가 힘듬(컨트롤러가 너무많으니까)
			
		쿠버네티스의 패턴은
			1.원하는상태를 받음(yaml로)
			2.그 오브젝트를 관찰함
			3.원하는상태와 오브젝트의 차이점을 찾음
			4.원하는상태와 일치하도록 조치함
		으로 이루어져있음
	3.암시적 또는 동적 그룹화
		여러 레플리카를 그룹화하든,로드밸런서의 백엔드를 식별하든 어쩌든 일단 걔가 속한 그룹을 구별해야함
		그때 암시적그룹과 명시적그룹이 있음
		
		명시적 그룹은 그 그룹에 속한 모든 멤버를 명시적으로 적는식이고,
		암시적 그룹은 멤버가 그 그룹의 키를 가지고있으면 그 그룹에 속하는식임
		
		명시적 그룹은 멤버가 잘 안바뀔떄 쓰는데,쿠버네티스의 경우엔 맨날맨날 바뀌고 파드단위가 언제든 사라질수 있기때문에 사용하지않음
		그래서 암시적 그룹을 사용함
		
		암시적 그룹은 항상 바뀔수있어서 서치에 코스트가 좀 들긴하지만,안정적이며 계속 그룹목록을 감시하지않아도되서 유연함
		
		쿠버네티스에서 암시적 그룹화는 레이블과 레이블셀렉터로 수행함

2.구조
	1.유닉스철학
		쿠버네티스는 일반적인 유닉스 철학인 각자 일을 잘 수행하는 작은조각,즉 모듈화를 기반으로 함
		쿠버네티스는 단일 바이너리에서 모든기능을 구현하지 않고,전체 시스템을 구현하는 작은 조각들의 모음임 
		그래서 api부분만 잘 맞춰주면 모든 모듈들을 교체할수 있음 
	2.api기반 상호작용
		쿠버네티스의 모든 상호작용은 api서버를 통해 이루어짐
		여기서 중요한점은 구성요소들이 사용하는 api가 사용자가 사용하는 api와 완전히 같다는것
		이건 시스템의 어느부분도 다른부분보다 특권을 갖지않고 상호간에 직접접근할수없다는것
		그래서 api만 맞춰주면 모든 구성요소를 대체하여 구현할수있음
		
		그리고 이건 버전이 좀 차이나도 시스템이 안정적으로 동작하게함(어짜피 api기반이니까 그게바뀌지않으면 됨)
		물론 api가 바뀌면 손대야하긴하지만
3.구성요소
	쿠버네티스는 워커와 헤드(마스터) 노드로 나누어지고,
	인프라를 구성하는 대부분의 요소는 헤드,컨트롤,플랜,노드에서 실행됨
	클러스터에는 일반적으로 노드수가 홀수인데 이 노드에는 etcd나 api서버같은 구성요소들을 실행함
	홀수인 이유는 알고리즘이 홀수여야하는 알고리즘을 사용해서 그럼
	
	그리고 클러스터의 실제 작업은 워커노드에서 수행됨
	
	그리고 쿠버네티스 구성요소가 생성되면 쿠버네티스 클러스터에 스케줄됨
	쿠버네티스의 관점에서 이게 다른작업들과 구별되진않지만,전체 api의 일부에 포함됨

	1.헤드노드의 구성요소
		헤드노드는 쿠버네티스 api기능을 구현하는 핵심요소들이 모아져있음
		일반적으로 그것들만 헤드노드에서 실행되고,헤드노드를 공유하는 사용자컨테이너는 없음
		
		etcd:
			etcd는 클러스터의 핵심임
			모든 클러스터의 오브젝트가 유지되는 키/밸류 저장소를 만들어서 저장함
			etcd는 분산합의 알고리즘으로 스토리지 서버 하나에 문제가 발생해도 데이터를 유지하고 다시 추가될때 복구할수있게 충분하게 복제가 됨
			
			etcd의 중요기능 2가지는
				첫번째는 낙관적인 동시성임,etcd에 저장된 모든값에는 해당 리소스버전이 있고,
				키값쌍이 etcd에 등록되면 특정리소스버전을 조건으로 지정할수있음
				즉 etcd를 사용하면 비교후교환(최신버전인지를 확인하고 교환하는것)을 구현할수 있음
				그러면 사용자가 값을 읽고 다른구성요소가 업데이트하지 않았다는걸 확인후 업데이트할수 있어지고,다중스레드를 안전하게 할수있어서
				서버의 처리량을 크게 줄일수 있음
				
				두번쨰는 워치 프로토콜임
				워치는 클라이언트가 전체 키값저장소의 변경사항을 효율적으로 감시할수 있다는것
				워치를 사용하면 클라이언트가 지속적으로 etcd에 폴링하지않아도 효과적으로 변경사항을 기다리고 대응할수있음
		api서버:
			api서버는 클러스터에서 중앙에서 통신을 담당함
			모든 클러스터내부의 상호작용은 얘를 거쳐서 감
		스케줄러:
			얘는 파드를 실행할 위치를 찾음
			스케줄되지않은 파드를 찾고,파드의 조건에 따라 노드를 선택해서 던져줌
		컨트롤러 관리자:
			얘는 레플리카셋,디플로이먼트,서비스등을 구현할때 필요한 조정제어루프를 실행하는것
			
			
	2.모든 노드의 구성 요소
		쿠블렛:
			얘는 클러스터의 일부인 모든 시스템의 노드데몬임
			얘는 노드의 cpu,메모리등을 클러스터에 연결함
			얘는 api서버와 통신해서 노드에서 실행될 컨테이너를 찾음
			마찬가지로 쿠블렛은 이런 컨테이너의 상태를 다시 api서버에 전달하므로 다른 조정제어루프가 컨테이너의 현재상태를 볼수있음
			
			쿠블렛은 컴퓨터에서 파드로 실행되고 있는 컨테이너의 상태를 스케줄링하고 보고하는것 외에도,
			컴퓨터에서 실행될것으로 예상되는 컨테이너의 상태를 확인하고 다시 시작하는 일을 담당함
			즉 컨테이너에서 문제가 생겨서 api서버로 올라갔다가 다시 내려오는게 아닌,선조치 후보고를 함
			대신 api서버엔 컨테이너 껏다켰다고 보고는 함
		
		kube-proxy:
				   모든 컴퓨터에서 실행되는 다른 구성 요소는 쿠브프록시임
				   얘는 쿠버네티스 서비스 로드밸런서 네트워킹 모델 구현을 담당함
				   얘는 클러스터의 모든 서비스에 대한 엔드포인트를 감시하고있음
				   그런 다음 노드의 네트워크를 프로그래밍해서 서비스의 가상ip주소를 통한 요청이 서비스의 엔드포인트에 도달하게 함(라우팅되게함)
				   쿠버네티스의 모든 서비스는 가상ip주소를 가지며,프록시는 로컬로드밸런서를 정의하고 구현하는 데몬임
				   얘는 클러스터의 어디든 파드에서 파드로 트래픽이 라우팅하게 함
	3.스케줄된 구성요소
		모든 요소들이 성공적으로 작동하면 최소한 실행 가능한 클러스터임
		근데 실질적으로 무조건쓰는게 몇개 더있음
		
			쿠버dns:
				서비스가 생성되면 가상ip주소를 얻지만,이걸 dns로 바꿔야 쉽게 쓰기좋음
				얘는 그 ip:문자열을 담당함
				얘 자체는 서비스로 표현되므로 프록시가 제공하는 동일한 라우팅이 dns트래픽을 쿠버dns컨테이너로 라우팅함
				중요한 차이점은 얘는 정적 ip주소가 부여된다는것
				즉 같은 스트링으로 어디 설정되는 신경안쓰고 저 정적주소를 넣으면 된다는것
				
			힙스터:
				요즘은 폐기됨
				얘는 모든 컨테이너의 cpu,메모리등의 메트릭을 수집하고 이걸모니터링할수있게 푸시해줌
				요즘은 메트릭서버가 기본임





				   

4.api서버
1.기본특성
	api서버는  모든 api서버의 상태는 외부에 저장되므로(etcd같은) api서버자체는 스테이트리스이고,
	부하관리와 고장대비를 위해 복제할수있음
	
	api서버는 로그를 출력하는데,받은 모든 요청에 대해 최소 1줄의 라인을 출력함
	그래서 용량 많이차지하니까 로그 로테이트식으로 오래된거 삭제하는식으로 씀
	
	그래도 api서버가 분석할때 제일중요하니까,외부하드에 저장계속하는게 나중에 문제생겼을땐 좋음
	
2.api서버의 구성
	1.api관리
		api의 주요 용도는 개별클라이언트의 요청 처리하는거지만,클라이언트가 api요청을 할땐 어떻게하냐면,
		api서버는 http서버이므로 모든 api요청은 http요청임

	2.api경로
		api요청은 http주소로 시작하는 restful api패턴을 따름
		모든 쿠버네티스 요청은 접두사/api/핵심api 또는 /apis/(api그룹별로 그룹화된api)  로 시작함
		api그룹은 원래 쿠버네티스api에 없었기 때문에 파드나 서비스같은 오리지널,코어 오브젝트는 api그룹이 없고
		후속 api들은 api그룹 아래 속하게됨
		예를들어 잡은 /apis/batch/v1/...경로에 있음
		
		리소스 경로에 대한 또 다른 정보는 리소스가 네임스페이스인지 아닌지임
		네임스페이스는 오브젝트에 그룹화 계층을 추가하고,네임스페이스 내에서만 네임스페이스 리소스를 만들수있으며,해당 네임스페이스이름은
		리소스의 http경로에 포함됨
		물론 네임스페이스에 없는 리소스도 있고,이경우에는 http경로에 네임스페이스 구성요소가 없음
		
		네임스페이스 리소스가 들어간 유형의 경로는
			 /api/v1/namespaces/<namespace-name>/<resource-type-name>/<resource-name>
			 /apis/<api-group>/<api-version>/namespaces/<namespace-name>/<resource-type-name>/<resource-name>
		이런식이고
		없는거의 유형은
			/api/v1/<resource-type-name>/<resource-name>
			/apis/<api-group>/<api-version>/<resource-type-name>/<resource-name>
		이렇게 네임스페이스만 빠져있음
	3.api검색
		api에 요청을 할수 있으려면 클라이언트가 어떤 api 오브젝트를 쓸수 있는지 알아야함
		이건 클라이언트측에서 api검색으로 수행함
			로컬호스트:포트/api
		를 날리면 api를 리턴하는데 
		
		거기의 종류별로 verbs가 사용할수 있는 api임
		다 이름 그대론데
			watch는 리소스에 대한 감시를 설정하는거고
			proxy는 api서버로 네트워크 포트에 프록시 네트워크 연결을 설정하는 특수작업임
			
		이거외에 리소스유형에서 하위리소스로 모델링된(pods/attach 같은식) 작업도 있음
		attach는 exec랑 비슷하게 파드 내에서 실행중인 컨테이너에 터미널을연결하는 기능임
	4.오픈 api 규격
		api서버에 엑세스할때 사용하는 리소스와 경로를 아는건 액세스에 필요한 정보의 일부임
		경로 외에도 보내고 받을 json페이로드를 알아야함
		api서버는 리소스스키마에 대한 정보를 알려줄 경로도 제공함
			/openapi/v2
		로 알아볼수있음 
		근데 뭐 오픈api로 api만들일이 있을까
	5.api변환
		api는 알파에서 시작해서(불안정함)베타를 거쳐 v1(ga,일반가용성)이 됨
		v1찍으면 한 1년은 확정적으로 쓸수있음
		
		쿠버네티스의 api는 api표현을 3가지로 함
			외부는 api요청으로 들어오는표현
			내부는 api서버 내에서 처리되는 오브젝트의 내부메모리
			스토리지는 api오브젝트를 지속시키기위해 스토리지 계층에 기록(etcd에 기록)
		즉 외부에서 요청들어오면 내부로가서 스토리지에 적고 리턴값 외부로 다시보내는식

3.요청관리
	쿠버네티스에서 api서버의 주요 목적은 http요청의 형태로 api호출을 수식하고 처리하는것
	이 요청들은 사용자가 하거나,시스템의 다른 구성요소에서 한것,
	이 두개 전부 같은방식으로 똑같이 처리됨
	
	1.요청의 유형
		get:특정 리소스에 관한 데이터를 달라는것
			즉 파드의 이름적고 보내면 그 파드에 대한 데이터를 줌
			
		List:이건 레이블을 조회하거나,특정 오브젝트를(디플로이먼트나 서비스나 그런) 검색하는것
			 오브젝트이름도 레이블이라고 볼수있으니 레이블조회라고 보면될듯
			 이거도 네임스페이스 선택해서 조회할수도 있고,특정오브젝트의 레이블을 검색할수도있음
		Post:리소스를 생성할때 사용 
			요청 메세지의 본문에는 새로 만들 리소스를 넣음
			post요청의 경우 경로는 리소스유형임(/api/v1/namespaces/default/pods 이런식)
			기존 리소스를 업데이트 하려면 특정리소스경로(/api/v1/namespaces/default/pods/파드이름)
			로 보냄
		delete:요청을 삭제할 시간이 되면 리소스경로에 대한 http delete요청이 사용됨
			   이건 영구적이므로 http요청이 만들어진 후에는 리소스가 삭제된다는거에 유의해야함


	2.요청의 수명
		인증:요청의 첫단계는 인증임
			api서버는 클라이언트 인증서,베어러 토큰,http 기본인증등 여러 인증모드를 지원함
			일반적으로 클라이언트 인증서,베어러토큰을 사용함
			이거외에도 다른 인증을 추가할수있음 
			
		rbac/인가:api서버가 요청에 대한 id를 판별하면 인가로 이동함
				쿠버네티스에 대한 모든 요청은 전통적인 rbac(역할기반접근제어)를 따름
				즉 롤에 따라 권한이 있는지 판별하고 ok fail을 날림
				
		승인제어:요청이 인증되고 인가되면 승인제어로 이동함
			  얘는 요청이 올바른 형식인지 판별하고(문법)요청이 처리되기전 수정사항을 잠재적으로 적용함(묵시적으로 허용된 단일형을 복수형으로 바꾼다던지)
			  여기서 오류가 판별나면 에러띄우고 리턴함
			  얘는 일반적인기능이라서 api서버의 다양한 기능에 사용됨
			  오브젝트에 기본값을 추가하는거나,정책을적용할때(모든 오브젝트엔 특정 레이블이 있어야한다 이런거)
			  그리고 모든 파드에 추가 컨테이너를 주입할때 같을때 사용할수있음
			  이런식으로 사이드카 컨테이너를 투명하게 주입가능
			  
		유효성 검사:유효성검사는 단일 오브젝트에 대해서만 수행됨
				얘는 요청에 포함된 특정 리소스가 유효함을 보장함
				즉 서비스이름이 dns에 들어가니까 서비스이름이 dns이름과 관련된 규칙을준수하는지 확인함
				
		전문화된 요청:표준 restful요청 외에도 api서버에는 클라이언트에 확장기능을 제공하는 여러 요청패턴이있음
				 /proxy,/exec,/attach,/logs 등등
				 가장 중요한 작업은 api서버에 장시간 지속되는 개방형 연결임
				 이런 요청은 즉각적인 응답보다 스트리밍 데이터를 제공함
				 
				 logs는 스트리밍 요청으로도 할수있고 일반요청으로도 할수있는데
				 그냥 현재까지 로그달라고하면 일반요청이고,follow 옵션을 붙여서 실시간갱신을 해달라고하면
				 api가 http응답을 계속열어두고 새 로그를 api서버를 통해 쿠블렛에서 수신할때 http 응답에 기록함
				 나머지는 양방향 스트리밍을 위해 웹소켓 프로토콜을 사용하고,http를 통해 이런 스트림데이터를 다중화해서
				 다수의 양방향 스트리밍을 가능하게 함
				 웹소켓은 http를 양방향 바이트 스트리밍 프로토콜로 변환하는 프로토콜이라고 생각하면됨
				 
				 이런거 외에도 여러 다중화 스트리밍 프로토콜을 사용하는데
				 보통 api서버가 독립적인 바이트스트림을 서비스하는게 매우 유용하기 때문
				 예를들어 컨테이너 내에서 명령어 실행할때는 stdin stdarr stdout 3개의 스트림을 유지해야함
				 한 웹소켓에서 스트림을 날릴때는 256바이트통신으로 날릴수있고,맨앞에 0,1,2로 구분함
					 0은 stdin,쓰기스트림,프로세스에기록,여기서는 데이터를 읽지않음
					 1은 stdout,출력스트림,프로세스에서 stdout을 읽음,이스트림에 데이터를 쓰면안됨
					 2는 stdarr,출력스트림,프로세스에서 stdarr을 읽음,이스트림에 데이터를 쓰면안됨
				 
				 /proxy는 클라이언트,클러스터 내에 실행중인 컨테이너나 서비스간의 통신을 외부에 노출없이 포트전달을 할수있도록 사용됨
				 이때는 첫바이트 뒤에 포트번호용 바이트 2개가 추가됨
		
		워치 동작:스트리밍외에도 api서버는 워치api를 지원함
			   워치는 변경경로를 모니터링함
			   폴링이빠르면 추가로드가 발생하고,느리면 지연시간이 길어지니,
			   대신 워치를 쓰면 한개의 연결로 짧은 업데이트가 가능함
			   사용자가 일부 api서버요청에 쿼리파라미터(?watch=true)를 추가해서 api서버에 감시연결을 설정하면,
			   api서버는 워치모드로 전환되고 클라이언트 서버간의 연결이 열린상태로 유지됨
			   마찬가지로 api서버가 반환하는 데이터는 더이상 api오브젝트가 아니고 변경유형과 api오브젝트를 포함하는 watch오브젝트임
			   이런식으로 클라이언트는 해당 오브젝트또는 오브젝트 집합에 대한 모든 변경사항을 관찰할수있음
			   
		낙관적 동시 업데이트:
			낙관적 동시성은 잠금장치를 사용하지 않고 대부분의 작업을 수행하고,동시쓰기가 발생하면 이를 감지해서 마지막쓰기를 거부하는것
			거부된 쓰기는 재시도되지않고 재시도하는건 클라이언트에 달려있음
			이떄 사용되는게 버전정보임
			자기가 읽었을때의 버전정보를 기억하고있다가 쓸때 확인하고 쓰고,만약 다르면 요청을 거부함
			직렬적으로 하면 순서대로 명령이 쌓이니까 성능상에 이슈가 발생하는데,이러면 병렬적으로 처리되기때문에 문제가 안생김
		
		대체 인코딩:
			api서버는 요청에 대해 json과 yaml,프로토콜 버퍼 인코딩을 사용할수있음
			요청의 인코딩 구분은 헤더로 구분함
			그리고 프로토콜 버퍼 인코딩은 처리량요청이 효율적이고 많아지는데,시각화하는게 어렵고 일부 클라이언트 라이브러리는 지원을 안함
		공통 응답 코드:
			202:수락됨,오브젝트를 만들거나 삭제하는 비동기요청이 수신됨,완료시점에 실제오브젝트가 반환
			400:잘못된 요청,서버가 요청을 구문분석할수없음
			401:권한없음,요청을 받았고 이해했지만 인증체계없이 요청이 수신됨
			403:금지된요청,요청을 받았고 이해했지만 접근이 금지됨
			409:충돌,요청을 받았지만 이전버전의 오브젝트 업데이트요청임
			422:처리할수없음,요청을 받았고 이해했지만 검증에 실패함
4.api서버 내부
	http restful 기본사항 외에도 api의 일부를 구현하는 몇가지 내부 서비스가 있음
	이런 제어루프는 api서버가 아닌 컨트롤러 관리자에서 실행되는데,일부는 api서버에서 실행해야함
	
	1.crd제어루프
		커스텀 리소스 데피니션(crd)는 실행중인 api서버에 추가할수 있는 동적 api 오브젝트임
		crd를 만드는건 새로운 http경로를 생성하므로 api서버는 서비스하는 방법을 알아야 함
		그래서 api서버내에 이런 경로를 추가하는 컨트롤러가 배치됨
		
		커스텀리소스의 경로생성은 쉽지만,삭제할땐 해당 유형의 자원과 관련된 모든 데이터를 삭제하기때문에 복구할수없음

5.api서버 디버깅
	api서버를 디버깅할땐 로그를 보고 해야함
	api의 로그는 기본로그 뿐 아니라 요청이 발생한 이유와 변경된 api서버 상태를 캡쳐하는 감사로그까지 크게 2종류가 있음
	그리고 특정 문제를 디버깅하기위해 더 자세히 설정할수도 있음
	
	1.기본로그
		기본적으로 api서버는 api서버로 전송되는 모든 요청을 기록함
		이 로그에는 클라이언트의 ip주소,요청경로,서버에서 반환한 코드가 포함됨
		예상못한 오류로 서버가 패닉에 빠지면 500오류를 반환하고 기록됨
		이 로그의 기록은 타임스템프 I0803(날짜) 19:59(시간)으로 시작하고 해당로그를 기록한 trace.go:76이 따라붙고 로그메시지로 구성됨
	2.감사로그
		감사로그는 쿠버네티스 api의 현재 데이터 상태를 유발한 서버의 상태와 일련의 클라이언트 상호작용을 서버 관리자가 포렌식으로 복구할수있게 기록한것
		즉 레플리카셋이 왜 레플리카가 100이됐는지,파드를 누가 삭제했는지 같은 기록이 남음
		감사로그는 기록된 위치에 대한 장착형 백엔드가 있음
		보통 감사로그는 파일에 기록되지만 웹훅에 기록될수도 있음
		두 경우 모두 기록된 데이터는 구조화된 json오브젝트임
	3.추가 로그 활성화
		로깅 세부수준을 조정해서 더 자세히 받을수도 있고 좀 덜받을수도 있음,기본값은 2인데 그냥 안건드리는게좋음
		특정부분에만 더 자세히적히길원하면 --vmodule플래그로 개별파일의 로그수준을 올릴수있음
	4.kubectl 요청 디버깅
		로그를 통해 디버깅하는것 외에도 kubectl명령줄 툴로 서버와 상호작용을 디버깅할수도 있음
		api서버와 마찬가지로 kubectl도 패키지로 로깅하고 --v상세표시플래그를 지원함
		
5.스케줄러		
	스케줄링은 워커노드에 컨테이너를 스케줄링하는것
1.스케줄링이란
	파드를 만들면 보통 nodeName이 없음
	nodeName은 파드가 실행될 노드를 나타내는데,스케줄러는 이런 노드네임이 없는 파드에 대해(watch로)api서버를 지속적으로 검사함
	이런파드들은 스케줄링의 대상이 됨
	그런다음 스케줄러는 파드에 적합한 노드를 선택하고,스케줄러가 선택한 노드네임으로 파드정의를 업데이트 함
	그렇게 노드네임이 생기면 해당노드에서 실행중인 쿠블렛은 파드가 있는지없는지(watch로)알게되고 해당파드가 없으면 해당파드를 실제로 실행시킴
	
	스케줄러를 건너뛰려면 노드네임을 적어줄수있긴한데,일반적으로는 이런식으로 하면 안됨,직접스케줄링은 클러스터의 효율성을 떨어뜨림
	
2.스케줄링 프로세스
	스케줄러가 노드에 할당되지 않은 파드를 발견하면 파드를 스케줄링할 노드를 결정해야함
	파드에 알맞은 노드는 여러 요인에 따라 결정되며,그중 일부는 고객이 제공하고 일부는 스케줄러가 계산함
	
	1.사전조건
		파드를 스케줄링할때 보통 2가지개념을 써서 결정함
		첫번째는 사전조건
		사전조건은 파드가 특정 노드에 적합한지를 나타냄
		사전조건은 엄격한 제한조건이라서 이걸 통과못하면 그 노드에는 절대 들어갈수가 없음
		여기에 들어가는게 메모리최소치나 레이블셀렉터 조회결과등이 있음
	2.우선순위
		두번쨰는 우선순위임
		이건 반드시 필요하진 않지만 이게 ok가 나면 점수가 높아져서,사전조건을 전부만족한애들끼리는 이게 높으면 데려감
		즉 특정 노드에 대한 스케줄링의 상대적 가치를 나타냄
		예를들어 이미 이미지가 있는 노드에 가중치를 줘서 이미지 재다운을 안해도되게 한다던가 같은거
		
		spreading는 우선순위중에 제일 중요한기능인데,같은 쿠버네티스 서비스 멤버인 파드가 없는 노드의 우선순위를 결정함
		이는 시스템이 고장나 특정 서비스의 모든 컨테이너를 사용할수 없을 가능성을 줄임(파드를 퍼트려서)
	3.상위레벨 알고리즘
		스케줄링에 필요한 모든 파드에 스케줄링 알고리즘이 적용됨
		스케줄러의 기본작동은
			1.현재 알려진 노드와 정상노드의 모든 목록을 가져옴
			2.각 사전조건을 만족하는 노드를 확인하고 목록을 만듬(스케줄링가능한노드목록)
			3.그중 우선순위로 정렬을 하고,제일높은애를 뽑아서 최종목록에 배치함(여기서 점수가 같으면 라운드로빈으로 균일해지게 뽑음)
	4.충돌
		파드가 스케줄링 된 시간과,컨테이너가 실제 실행되는 시간에는 지연시간이 있기때문에,그 사이 다른작업때문에 스케줄링 결정이 무효가 될수 있음
		우선순위조건이 바뀐건 좀 아쉽고 말정도인데,문제는 사전조건임
		만약 그 사이에 사전조건이 바뀌어서 노드가 파드의조건을 만족할수없게되면 파드는 실패한걸로 표시되고,
		레플리카셋은 그 파드를 지우고 새 파드를 만들어서 다시 스케줄링함
		
		여기서 중요한건,파드를 지우고 다시스케줄링하는건 레플리카셋(디플로이먼트)이기때문에 파드가 하나라도 반드시 레플리카셋으로 실행해야함
			

3.스케줄링 제어하기
	쿠버네티스가 하는 스케줄링을 세밀하게 제어하고싶으면,각자의 사전조건과 우선순위를 추가할수도 있지만,그러면 일이 많음
	이럴떈 사용자 정의 스케줄링을 할수있게 해주는 툴을 사용하면됨
	
	1.노드셀렉터
		쿠버네티스의 모든 오브젝트에는 연관된 레이블집합이 있음
		레이블로 오브젝트에 대한 메타데이터를 식별할수 있으며,레이블셀렉터로 다양한 작업을 위한 api를 동적으로 식별할수 있음
		
		클러스터에서 특정 파드 스케줄링에 사용하는 노드의 부분집합을 식별할때도 레이블셀렉터가 사용될수 있음
		클러스터의 모든 노드는 스케줄링 대상이지만,
		파드의 spec.nodeSelector필드를 넣으면 노드의 초기집합을 저기 적힌 레이블이 있는걸로 줄일수있음
		즉 노드의 레이블의 키:값을 지정하고 일치하는데만 스케줄링할수있음
		그리고 노드셀렉터는 스케줄링시에만 계산됨,노드가 중간에 바뀌면 그거까지는 체크못해줌
	2.노드 어피니티
		노드 셀렉터가 특정 노드에 위치하도록 보장해준다면,노드 어피니티는 좀 더 복잡한 논리표현을 해줌
		a or b 노드라거나,a노드는 안된다거나(!=) 등을 할수있음
		즉 TF와 or and를 지원한다고보면됨
		이거말고도 밸류말고 키만 보고 키가 존재하는지만 볼수도있고 그럼
		
		그리고 이런식으로 사전조건으로 적을수도 있고,저걸 우선순위로 줄수도 있음
			사전조건은 requiredDuringSchedulingIgnoredDuringExecution
			우선순위는 preferredDuringSchedulingIgnoredDuringExecution
			우선순위에서 weight:로 우선순위의 강도도 줄수있음
		그리고 똑같은방식으로 노드어피니티말고 파드어피니티도 가능함
	3.테인트와 톨러레이션
		테인트는 특정 노드에 테인트를 적용하면,그 노드에는 더이상 스케줄링을 하지 않게함
		그리고 톨러레이션은 그 테인트를 무시하고 스케줄링 대상에 추가할수 있게함
		즉 테인트는 그 노드를 오염됐다치고 무시하는거고,
		톨러레이션은 그 노드를 사용할수 있게 해주는건데,중요한건 테인트된 노드만 사용하는게아닌 전체 스케줄링대상에 테인트를 추가하는느낌임
		즉 톨러레이션이 걸려도 테인트노드가 아닌곳에서 실행될수있음
		
		
6.쿠버네티스 설치		
1.쿠베어드민
	쿠베어드민이 보통 설치툴같은데도 메인이 되는 가장 기본적인 설치 툴임
	보통 다른 툴들도 쿠베어드민기반으로 추가해서만듬
	여기엔 쿠블렛이 없으니 쿠블렛은 따로깔아야함

2.컨트롤플레인설치
	컨트롤플레인은 워커노드의 작업을 지시하는 구성요서임
	컨트롤플레인은 api서버,컨트롤러관리자,스케줄러로 이루어져있고,그외 상태저장용으로 etcd가 있음
	쿠베어드민엔 포함되어있음
	1.쿠베어드민 설정
		쿠베어드민을 설치하면 컨피그맵으로 설정들이 생성되어서 저장됨
		클러스터의 구성을 이해하기위한 참조용도와,업그레이드할때 사용할용도
		업그레이드할떈 이 컨피그맵을 수정한후 kubeadm upgrade함
	2.인증서
		쿠베어드민은 인증기관과 키를 생성하는데,보통은 다른데서 받아온거쓰니까 만들기전에 넣어두면 안만들고 그거씀
		kubeadm init하기전에 /etc/kubernetes/pki에 미리 넣어둬야함
		그러면 일단 있는키부터쓰고 없는거만 만듬
	3.etcd
		기본구성요소외에도 별도지정이 없으면 로컬etcd인스턴스를 시작하려고 시도함
		이 데몬은 구성요소와 같은방식으로 시작되고 볼륨연결로 데이터를 유지함
		근데 상용서비스급까지 올라가면 이러진않고 etcd클러스터를 배포함(가용성이높은)
		그리고 쿠버네티스구성요소는 쉽게 교체할수있지만,etcd는 쉽게 못바꾸니(상태가있으니까) 주의
		그래서 쿠버네티스클러스터에서 etcd 클러스터를 분리하는게좋음(상태가있어서 라이프사이클이 다름)
		
		그리고 etcd데이터는 암호화되지않음
		etcd 접근권한을 누가 얻게되면 그 즉시 이용할수있게됨
		뭐 보통은 etcd에 별거없긴한데 시크릿이 문제임
		그래서 시크릿은 암호화되어서 보관되게
			--experimental-encryption-provider-config
		로 대칭키로 암호화를 걸어야함
		
		암호화는 코스트를 소모하기때문에(쓰기성능에), 중요한거만 암호화걸어두는게 좋음
	4.쿠베컨피그
		쿠베어드민은 여러 쿠베컨피그를 생성함
		쿠베컨피그들은 인증수단에 사용됨
		이중 대부분은 api에 대해 쿠버네티스 서비스를 인증하는데 사용됨
	5.테인트
		상용환경에선 워크노드를 컨트롤플레인구성요소(마스터노드)와 분리해둬야함
		그래서 모든 마스터노드를 테인트걸어둠
		만약 마스터노드가 하나고 한컴퓨터에서 다해야하면 풀어둬야함
		
3.워커노드설치
	워커노드도 비슷하게 설치함
	모든노드엔 컨테이너런타임과 쿠블렛이 필요하고,워커노드엔 거기에 더해 kube-proxy데몬이 필요함
	워커노드를 설치할땐 tls부트스트랩(부팅)을 연달아 수행함
	쿠베어드민은 api서버에 공유토큰교환프로세스로 노드를 일시적으로 인증하고,컨트롤플레인ca에 인증서 서명요청을 수행하려고 시도함
	그후엔 이 자격증명을 런타임시 인증메커니즘으로 씀
	뭐 별로신경안써도될거같음

4.애드온
	마스터노드를 설치하고 워커노드를 깔았으면 워크로드를 배포해야하는데,그전에 애드온을 몇개배포해야함
	보통 로그집계,모니터링,서비스메시등을 추가함
	얘들은 쿠베어드민이 관리하지않음 


5.고가용성
	쿠베어드민은 보통 한번에 하나의 노드에서 보기떄문에,고가용성으로 설치하긴 좀 복잡함
	이럴떈 딴거쓰자

6.업그레이드
	업데이트할땐 운용중단없이 하나하나 업그레이드할수있음 필요하면 찾아보자





7.인증과 사용자관리
	쿠버네티스도 똑같이 계급기반으로 접근수준설정하고,사용자에 계급부여하는식임
	api서버에 대한 api요청은 인증,접근제어,승인제어 순으로 넘어간후에 요청이 처리됨
	
	인증은 이 사용자가 본인임을 증명해야함
	즉 계급과 api문법등이랑은 상관없이 사용자가 메타데이터에 있는 그사람인지를 증명해야함
	
	접근제어는 이 사용자의 계급이 그 작업을 수행해도되는지를 검증함
	
	승인제어는 그 작업이 올바른문법과 적절한 오브젝트로 구성되어있는지,즉 수행가능한지를 검증함
	
	이 3개를 통과해야 요청이 승인됨
	
1.사용자
	사용자는 어떻게 쿠버네티스api와 연결하고 접근권한을 얻는지와 연결이 있음
	일반적인경우는 사용자가 kubectl로 외부에서 api와 연결하지만,모든 api는 클러스터와의 상호작용의 기반이기때문에
	다른 오브젝트들도 api를 똑같이 사용함
	즉 사용자의 api는 다른 오브젝트랑 동등한수준임(처리권한도 그렇고)
	
	사용자는 쿠버네티스api로 관리하진않으며,보통 외부사용자 관리시스템으로 정의됨
	그래서 원래쓰던 사용자관리를 그대로사용할수있음(AD나 LDAP)
	
2.인증
	쿠버네티스는 api에 여러 인증방법을 지원함
	다른인증 메커니즘처럼 얘도 모든 접근의 첫 문지기역할임
	일단 이 사용자가 누구인지 물어보고,이 사용자의 자격증명이 우리가 가진값과 일치하는지를 체크함
	즉 사용자가 맞는지를 체크함
	이거에 따라 TF를 주고,권한이 맞는지 아닌지(사원이 과장급이 할수있는 딜리트명령을 날렸는지등) 확인은 얘역할이 아님
	
	다른 rest 기반 api와 마찬가지로 인증할떄 사용할수있는 여러전략이 있는데 3가지 주요그룹이있음 
		기본인증
		x.509 클라이언트인증서
		베어러 토큰
	최종적으로 사용자가 자격증명을 얻는방법은 운영자가 사용하도록 설정한 id제공자에 따라 다르지만,메커니즘은 이 3개중 하나를 따르게됨
	
	1.기본인증
		기본인증은 그냥 쿠버네티스 클러스터에서 사용하는 기본적인 인증플러그인임
		얘는 api클라이언트가(kubectl) http인증헤더를 사용자이름과 패스워드의 베이스64해시결합으로 설정함
		베이스64는 해시일뿐 전송된 자격증명에 대한 암호화는 아니므로 기본인증은 https와 함께 사용해야함
		
		api서버에서 기본인증을 구성하려면,관리자는 사용자이름,패스워드,사용자id,사용자연결그룹목록(""안에 나열)을 파일로 제공해야함
		이 형식은 UserInfo리소스 필드 형식과 같음
		
		이파일은 --basic-auth-file명령줄 파라미터로 api서버에 제공됨
		api서버는 이 파일의 변경사항을 모니터링하지않으므로 이게 바뀔때마다 서버재시작해야해서 상용클러스터엔 기본인증을 쓰지않음
		
		근데 뭐 집에서돌리긴 쉬워서 테스트용이나 이럴떈 잘쓰임 나중에 이부분만 갈면됨
	2.x.509클라이언트 인증서
		일반적으론 이걸 씀
		이게 안전하고 흔하고 쉽게 생성되기 때문
		얘는 ca서명에 대한 접근권한만 있으면 새 사용자를 쉽게 만들수있음
		얘가 그 맨날말하는 인증서기반 그거임
		
		상용수준으로 하면 요청이 안전하게 전송되는지는 물론이고,서비스간 통신도 암호화되어야함
		이럴때 인증서를 사용하면됨
		
		이 인증서 방식은 자체서명된 루트 ca인증서를 만든다음,
		이걸 서비스구성요소에 대한 다양한 인증서와 인증서구성요소를 만드는데 사용하는 관리인증서에 서명함
		
		모든 사용자에 대한 인증서를 하나로 만드는건 최선의방식은 아니지만,작업을 빨리시작하는덴 도움이 됨
		추가로 인증서가 필요하면,추가클라이언트 인증서에 서명하면됨
		
		여기에 쓰이는 툴은 openssl클라이언트와 cfssl이라는 클라우드플레어꺼가 많이쓰임
		
		만드는 순서는 
			먼저 클라이언트 인증서를 생성할때 사용하는 csr을 만들고 이후 서명요청을 하면됨
			여기서 사용자id를 userinfo리소스에 매핑해야함
		여기서 공통이름 cn은 사용자이름에 매핑되고,모든 조직필드는 사용자가 속한그룹에 매핑됨
		이런식으로 만들고 인증할땐 --client-ca-file=값만 지정하면됨,여기서 값은 디스크에 있는 파일
		
		이렇게 인증서생성을 단순화해도 인증방법은 알아둬야하니까 찾아보자
		
		그리고 인증서로 만들어뒀으면 자동화도 만들어서 일정시간지나면 자동갱신되게 해야함
		그리고 사용자가 적거나 중개수단들로 통신하면 인증서써도되지만,사용자가 많으면 토큰쓰는게 나음
	
	3.oidc
		오픈아이디연결은 oauth위에 구축된 인증계층임
		이걸 사용하면 사용자는 신뢰할수 있는 id제공자와 독립적으로 인증함
		이 사용자가 인증에 성공하면 인증제공자는 웹요청으로 하나이상의 토큰을 제공함
		
		토큰은 사용자가 읽을수있는 json을 조금넣어서 사용자이름,사용자id,사용자의 그룹같은정보를 공유할수있음
		이런 토큰은 해시기반이고,암호화되지않음
		그래서 이걸 포함한통신은 tls로 암호화해주는게좋음 
		
		json문서에서 필드는 클레임이라고 하고,사용자의 다양한 속성을 식별할수 있음
		이런 클레임은 대부분 표준화되어있지만,id제공자는 자체 사용자정의클레임을 추가할수있음
		api서버를 쓰면 이런거도 userinfo리소스에 어떻게 다시매핑될지 나타낼수있음
		
		api서버에서 oidc인증을 사용하려면 명령줄에 --oidc-issuer-url과 --oidc-client-id파라미터를 추가해야함
		이건 id제공자의 url과 클라이언트의 id이고,이 두값 모두 id제공자가 알려줌
		
		이 oidc는 중개자가 관련되어있다는점에서 다른인증유형과 약간 다름
		기본인증과 인증서인증도 api서버는 인증에 관련된 모든단계를 수행할수 있지만,oidc는 상호신뢰하는 id제공자에서 인증하고 토큰을 받는식임
		순서는
			1.사용자는 api서버에 인증하고 인가요청
			2.인증프런트엔드는 자격증명을 id제공자에 전달
			3.id제공자가 인증할수있으면 접근코드 반환,
			  반환된 접근코드는 id제공자에게 반환되고(스푸핑때문에 내부적으로 처리를따로함)id토큰과 리프레시토큰으로 교환
			4.사용자는 이 토큰들을 쿠베컨피그에 추가함
			5.쿠베컨피그파일엔 oidc인증정보가 포함되어있으므로,kubectl은 각 api요청에 베어러토큰을 삽입하게됨
			  토큰이 만료되면 kubectl은 만료된 id토큰을 발급자와 교환해서 새 토큰을 얻으려고 시도함
			6.api서버는 토큰과 사용자정보를 기반으로 id제공자에게 이토큰이 맞는지를 확인함
			7.토큰의 유효성이 확인되면 id공급자는 정보를 반환하고 api서버는 원래 api요청을 계속하도록 허용함
	4.웹훅
		경우에따라 관리자는 이미 베어러토큰을 생성할수 있는 시스템에 접근할수도있음
		이럴땐 사내시스템이 사용자에게 환경내의 여러 시스템을 인증하는데 사용가능한 수명이 긴 토큰을 부여할수도 있음
		뭐 정교하진않지만 토큰확인만 가능하다면 쿠버네티스는 신원을 확인할수 있음
		
		웹훅인증을 사용하면 api서버는 인바운드 요청에 있는 모든 베어러토큰을 추출하고(요청에 들어있는 모든 토큰) 인증서비스에 클라이언트post요청을 보냄
		이요청의 본문은 원래베어러 토큰과 함께 포함된 json형식의 tokenReview리소스가 됨
		인증서비스가 이토큰이 진짜인지 평가한후엔 이걸 본문으로 써서 자체응답을 다시 작성해야함,
		실패하면 TF만 있으면됨 진짜인지 아닌지
		성공하면 최소한으로 유저네임이랑 uid,그룹정도 적어주고 추가로 적을건 엑스트라필드에 적으면됨
		
	5.덱스
		어떤서비스가 각자의 유스케이스에 적합하지 않을때나 일반적으로 사용하는 디렉터리서비스를 쓰고싶으면
		oidc브로커인 덱스를 쓰면됨
		필요해지면 찾아보자
		
		그리고 쿠버네티스 인증메커니즘은 상호배타적이지않아서,여러개를 거쳐서 가도됨,일반적으로도 이렇게쓴대
		보통땐 하나통과하고 나머지거 스킵인데,맨앞게 고장나면 그거넘어가고 두번째거로 인증하는식
		
		
3.쿠베컨피그 파일
	이런 모든 인증메커니즘을 가지고 인증방법의 세부정보를 기록하는 쿠베컨피그파일을 만들어야함
	kubectl은 이 설정파일로 api서버에 요청할 위치와 방법을 결정함
	이파일은 일반적으로 홈의 /.kube/config밑에 있지만,바꿀수도있음
	
	쿠베컨피그에 자격증명을 포함할지는 인증메커니즘과 보안상태에 따라 달라짐
	이설정에 자격증명을 포함하면 이 파일에 접근할수있는 모든 사람이 자격증명을 사용할수있게되니까 사실상 패스워드급이 되어버림
	
	쿠베컨피그는 3가지 최상위구조가 있음
		user을 통해 사용자의 이름을 지정하고,클러스터에 인증할 메커니즘을 제공함
		
		clusters로 클러스터에 연결하는데 필요한 모든 데이터를 제공함,
		여기엔 api서버의 ip와 전체주소도메인네임이 포함되고,자체인증서 ca번들같은게 포함될수있음
		
		context는 사용자를 한개이상의 엔티티로 클러스터와 연결하는곳임
		이건 kubectl이 api서버에 연결하고 인증하는수단으로 쓰임
		
	모든 클러스터에 대한 자격증명은 쿠베컨피그하나로 표현할수있음
	그래서 한클러스터에서 다음클러스터로 변경하거나,클러스터와 사용자 둘다 전환하거나,같은클러스터에서 다른사용자로 전환하는게 간단함
	
		
4.서비스 계정
	사용자가 외부에서 인증할땐 앞에서처럼 처리하면되는데,파드내부의 프로세스가 api에 접근할땐 서비스계정을 사용함
	이떈 serviceAccount를 사용함
	
	서비스 어카운트는 모든 파드리소스에 대한 네임스페이스사용자계정이라고 생각하면됨
	이걸 만들땐 자동적으로 시크릿도 만들어지고,여기포함된 토큰으로(베어러토큰) 모든 api요청에 포함됨
	이런 자격증명은 다양한 쿠버네티스 클라이언트가 접근하도록 잘 알려진 파드에 포함됨
	
	프로세스를 인증할때도 jwt를 다시 사용하고,클레임을 다시 사용함
	api서버의 목표중 하나는 이 사용자에 대한 데이터를 userinfo리소스에 매핑하는것
	
	시작된 모든 파드엔 연관된 서비스어카운트가 있음
	
	만약 아무것도 기본값으로 사용자가 지정을 안해두면,기본서비스어카운트가 사용됨
	이건 네임스페이스 전체에서 쓸수있고,네임스페이스를 만들면 자동으로 만들어짐
	




	
	
	
8.인가	
	인가는 역할기반 접근제어임
	사용자의 신원을 인증에서 확인하고,그 사용자가 접근가능한 영역에 요청을했는지 확인하는것
	
1.REST
	쿠버네티스 api는 restful api임
	restful api의 장점은 확장성과 이동성등도 있지만,단순한구조로 쉽게 접근수준을 결정할수있다는거도 있음
	
	rest는 동사를 사용하여(get,list delete등) 리소스를 조작하는것임
	즉 목적대상과 동사를 써서 api에 주면 걔가 알아서 한다음 결과값을 돌려주는식
2.인가
	사용자가 인증되었다고 모두에게 동일한 접근권한을 부여해야하는건 아님
	사용자마다 처리가능한 영역이 있고,그외는(웹팀에게 서버백엔드영역 건드릴이유가없음) 못건드리게하고,사원은 딜리트를 못하게 한다던가 그런식
	이런걸 인가라고 함
	
	인증과 마찬가지로 인가도 api서버의 책임임
	kube-apiserver 실행파일에 적절한 --authorization-mode를 써서 다양한 권한부여 모듈을 구현하도록 api서버를 구성할수있음
	
	api서버는 각 요청을 쉼표로 구분된 --authorization-mode인수가 적힌 순서대로 권한부여모듈에 전달함
	각 모듈은 기권하거나 의사결정에 참여할수있음
	기권을하면 api요청은 다음모듈에 넘어가고,기권을 하지않으면(결정을하면) 인가과정은 멈추고 인가모듈의 결정을 반영함
	모듈이 요청을 거부하면 403을 던지고,요청이 허용되면 승인제어(어드미션컨트롤러평가)로 넘어감
	
	가장 단순한 모듈은 alwaysallow,alwaysDeny고 이건 요청을 허용하거나 거부함,즉 테스트용
	
	node모듈은 워커노드에서 수행된 api요청에 인가규칙을 적용함
	즉 노드도 막 다른영역거 못건드리게 막음
	
3.역할기반 접근제어
	rbac(역할기반접근제어)는 역할을 정의하고(뭐까지할수있는지),사용자에게 그 역할을 부여하는식임
	
	1.롤과 클러스터롤
		rbac모듈을 사용하면,리소스에 대한 작업수행권한이 롤 또는 클러스터롤 리소스 유형으로 정의됨
		
		롤은 특정 네임스페이스에서 권한을 부여하는것
		특정 네임스페이스에서 어떤api그룹에서 어떤 리소스에대한 어떤 권한 이런식으로 -로 배열식으로 나열하는느낌임
		즉 룰은 각 리소스마다 접근권한을 달리줄수있음
		
		클러스터롤은 클러스터내 전체에 권할을 부여하는것
		클러스터내에서 어떤api그룹에서 어떤 리소스에대한 어떤 권한 이런식으로 -로 배열식으로 나열함
		얘는 롤과 같은데,범위가 클러스터전체로 된것임
		이건 보통 관리자나 전체클러스터를 볼수만있게 권한을 주거나 할때 사용됨
		즉 겟,리스트,와치만 줘서 감시할수만 있게하는식으로 권한을 주고,바뀔때마다 뭔가 상호작용하게 만들수있음
		
	2.롤바인딩과 클러스터롤바인딩
		롤과 클러스터롤은 규칙을 지정만하지,타겟팅한 사용자와 그룹을 지정하진않음
		그건 롤바인딩과 클러스터롤바인딩이 함
		
		롤바인딩에서 네임스페이스를 지정하고,타겟의 종류와 이름,api그룹을 지정하고,롤레퍼런스에서 롤을 연결하면됨
		
		여기서 타겟의 종류로,유저,그룹,서비스어카운트가 있음
		유저와 그룹은 각각 userinfo username,groups필드로 정의가되고
		서비스어카운트는 적절한이름의 serviceaccount subject유형으로 명시적으로 지정됨
		
		서비스어카운트는 실행중인 모든 파드 프로세스에 대해 쿠버네티스 api자격증명을 제공함
		파드매니페스트에서 서비스어카운트네임을 지정했냐와 관계없이 모든파드에 연결된 서비스어카운트가 있고,이거때문에 보안문제가 발생할수있음
		그래서 rbac로 보완할수있음
		
	3.테스트권한인가
		클러스터의 사용자,그룹,워크로드가 증가하면 복잡성도 커짐
		rbac는 집합에 권한인가정책을 적용하는 간단한 매커니즘이지만 접근권한을 구현하고 디버깅하는건 복잡할떄도 있음
		그래서 kubectl은 쉽게 확인할수있는 명령어가 있음
			kubectl auth can-i 동사 목적대상
		으로 그 네임스페이스에서 목적대상에 동사를 지정할수있냐를 yes no로 대답해줌
		
		
	
9.승인제어
	승인제어는 api요청의 세번째단계임
	여기선 이미 요청이 실제사용자에게 왔고,사용자권한도 있는상태여야 들어올수있음(앞에 두단계거쳤으니까)
	이제 들어온 요청이 유효한 요청인지 확인하고,부합하지 않을때 어떻게 처리할지 정함
	
	실제로 클러스터에 문제가 생길만한걸 잡아내는곳이 승인제어고,여기선 리소스를 제한하고 정책을 적용하며 고급기능을 사용할수있음
	
	그리고 승인제어는 맨날맨날 바뀌는(계속 필요로하는 정책등이 생기니까)곳이라서 지금버전과 다를수있음
	
	
1.설정
	승인제어를 쓰는건 승인제어가 api함수기때문에 --enable-admission-pluguns플래그를 kube-apiserver런타임 파라미터에 추가하면됨
2.일반 컨트롤러
	쿠버네티스에서 즉시 사용할수 있는 어드미션 컨트롤러에는 두가지 목표가있음
	사용자가 지정한값이 없으면 기본값을 사용하고,필요한거보다 많은기능을 보유하지못하게 하는것
	사용자가수행할수 있는 대부분의 작업은 rbac로 제어되지만,어드미션 컨트롤러를 쓰면 인가의 단순한 분류외에 추가적으로 세분화정책을 정의할수있음
	
	1.파드보안정책
		PodSecurutyPolicies컨트롤러는 가장 많이 사용하는 어드미션컨트롤러의 하나임
		관리자는 이 컨트롤러를 써서 쿠버네티스 통제하에서 프로세스의 제약 조건을 지정할수 있음
		이 컨트롤러를 사용하면 
		관리자는 권한있는 콘텍스트에서도 파드를 실행할수없고,
		파드를 hostNetwork에 바인딩할수없고,
		특정 사용자로 실행해야하고,
		다양한 보안중심속성으로 제한되게 강제할수있음
		
		이 컨트롤러가 활성화되면 인가된 정책이 없은 사용자는 새 파드를 실행할수없음
		정책은 보안상태에 따라 허용되거나 제한될수 없음
		보통 상용환경에서는 PodSecurutyPolicies컨트롤러의 대부분의 정책을 사용함,그래야 보안이 크게강화됨
		
		저 권한있는 콘텍스트에서도 파드를 실행할수없는건,rbac에서 PodSecurutyPolicies권한을 룰에 추가해야만 만들수있게되는거임
		저 권한이 있으면 정의된 정책을 준수하는 한에서 파드를 선언할수 있음
		
	2.리소스 쿼터
		보통 클러스터엔 쿼터를 적용하는게 좋음
		쿼터는 사용자가 할당된거보다 리소스를 더 많이 못쓰게하며,전체 클러스터 사용률을 높임
		사용자 쿼터를 적용하려면 ResourceQuota컨트롤러를 활성화해야함
		
		이 컨트롤러는 새로 선언된 어떤 파드든 네임스페이스의 현재 쿼터사용율과 비교해서 먼저 평가되게 하고,
		워크로드가 실행하는동안 이 검사를 수행해 사용자에게 파드가 쿼터에 맞거나 맞지않을거라는걸 알려줌
		네임스페이스에 대한 쿼터가 정의되면,디플로이먼트나 레플리카셋같은거에서 생성된 파드도 전부 리소스요청과 제한이 들어있어야함
		
		보통 리소스는 cpu,메모리,볼륨이 들어가고 파드나 디플로이먼트같은걸 지정할수도있음(파드 몇개이상안되게)
		
		쿼터설정을 하면 제한을 초과할땐 한개파드만 시도해도 컨트롤러가 요청을 즉시 거부함(255/256일떄 2짜리 실행하려고하면거부)
		이건 디플로이먼트도 마찬가지임
		디플로이먼트가 3개를 레플리카했는데 2개자리만있으면 거부함
		
	3.상한범위
		ResourceQuota를 보완하기위해서 네임스페이스에 limitRange를 정의하면 LimitRange컨트롤러가 필요함
		얘는 특정 네임스페이스의 멤버인 파드에 리소스상한을 설정하는방법임
		즉 이걸 설정하면 설정값보다 큰 파드를 거부함(2/256인데 제한이 5면 6짜리파드실행하려고하면 거부)
		그리고 이걸설정했는데  리소스상한을 지정하지않으면 기본값으로 설정되고 이후 파드는 승인되니까 주의

3.동적 어드미션 컨트롤러
	지금까진 쿠버네티스에서 제공하는 어드미션컨트롤러였고,이건 다른 확장기능임
	
	동적 승인 제어는 사용자 정의 비즈니스 로직을 승인 제어 파이프라인에 넣는 메커니즘임
	여기선 검증과 변형이라는 두 유형이 있음
	
	검증에서 비즈니스 로직은 요구사항에따라 요청을 수락하거나 거부할수있고,거부할떈 적절한 http코드와 실패원인이 반환됨
	이때 최종사용자에게 일치하는 리소스규격을 선언하도록 지시해야함
	
	변형의 경우는 api서버에 대한 요청을 다시 평가하기도 하지만,이떈 목표를 달성하기위해 선언을 선택적으로 변형함
	쉬운경우는 리소스에 테이블을 적용하는거고,좀더 복잡한건 사이드카 컨테이너를 넣는것
	변형은 최종사용자의 부담을 얘가 좀 떠안고있지만,이런 작업들이 사용자 뒤에서 일어날때 좀 헷갈릴수있으니까 문서화가 필수임
	
	이 두경우 모두 사용자정의 웹훅으로 구현됨
	api서버는 요청이 있으면 다운스트림웹훅을 호출하고 admissionReview를 post함
	이 요청의 본문엔 원래요청과 오브젝트의 상태,요청한 사용자의 메타데이터가 포함되고,결과적으로 AdmissionResoponse오브젝트가 리턴됨
	이 오브젝트엔 요청이 허용되는지,오류원인과코드,변형패치의 내용에 관한 필드가 포함됨
	
	동적 어드미션컨트롤러를 사용하려면 --enable-admission-pluguns를 변경해서 api서버를 설정해야함()
		--enable-admission-pluguns=...,MutatingAdmissionWebhook,\ValidatingAdmissionWebhook
	
	1.어드미션 컨트롤러 검증
		자체적인 검증 어드미션컨트롤러를 구현할땐 컨트롤러는,
		모든 파드 크리에이트요청을 검증해서 각 파드에 environment레이블이 있고,
		레이블의값이 dev인지 prod인지 확인함
		
		먼저 만든 소스파일(파이썬이든뭐든)을 이미지로 따고,이미지를 파드나 디플로이먼트로 올리고,서비스를 만들고 서비스와 api서버(웹훅)을 연결해야함
		
	2.어드미션컨트롤러 변형
		이거도 똑같이 이미지만들어서 디플로이먼트로 올리는데,얘는 MutatingAdmissionWebhook을 쓰고,내부클러스터ip서비스를 가리킴
		그리고 변형은 사용자의 선언을 표준화할수있지만(생성된파드마다 사이드카로 붙어서 출력값을 변화시킬수있으니까)조심해서 써야함
		
	
	
	
	
	
	
10.네트워킹
	쿠버네티스를 쓰면 개발자는 앱배포 매니페스트와 함깨 네트워크리소스와 정책을 정의할수있음
	
1.컨테이너 네트워크 인터페이스
	파드가 다른 파드와 통신할땐,cni규격을 사용해 플러그인이 컨테이너의 네트워킹 네임스페이스에 인터페이스를 추가하거나 제거하고,
	여기를 통해 서로 통신함(dns에서 ip주소를 알아서 바꿔주니까 dns로)
	
	플러그인은 컨테이너런타임 대신 작업을 실행하고 실행상태를 반환함
	성공하면0 실패하면 다른코드를 반환하고,성공하면 ip,라우트,dns의 세부사항도 반환함
	
	1.플러그인 선택
		플러그인을 선택할떈
			어떤 네트워크의 토폴로지(영역,물리적으로 연결된방식)인지?
				네트워크의 토폴로지는 사용자환경에서 배포할 기능대부분에 영향을 줌
				예를들어 퍼블릭클라우드내의 가용영역에 배포할떈 캡슐화를 지원해야 구현할수있음
			각자의 조직에 꼭 필요한 기능은?
				배포에 무슨기능이 중요할지도 고려해야함
				파드간tls가 엄격하게 필요하면 tls를 제공하는플러그인을 쓰는식

2.kube-proxy
	쿠버네티스가 파드간 네트워킹을 지원해도,파드끼리 직접 통신하고있으면 고칠때 머리아프고,
	디플로이먼트로 복제한걸 일일히 ip맞춰줄순없음
	그래서 있는게 프록시임
	
	프록시는 권한있는 컨테이너의 프로세스로 실행되고,가상서비스ip주소의 연결을 담당함
	
	보통 프록시는 모든노드의 iptables을 조작함
	얘는 서비스ip로 향하는 트래픽을 서비스의 백엔드ip중 하나로 다시 보냄
	프록시는 컨트롤러라서 상태변화를 감시하고 변경이 생기면(파드가 재생성돼서 ip가바뀌었다던가)다시 적절하게 조정함(iptables수정)
	
	즉
		사용자가 서비스에 요청을 보내고
		서비스가 받아서 프록시에 보내고
		프록시가 부하적은 엔드포인트를 골라서
		거기다 요청보내고 사용자쪽에 엔드포인트의 값을 리턴함
		
	그래서 프록시는 로드밸런싱의 역할도 함

3.서비스검색
	높은수준의 동적 프로세스 스케줄링이 있는곳에선 서비스엔드포인트를 안정적으로 찾을 방법이 필요함
	즉 사용자가 dns에 요청을보내면 걔가 서비스에 요청을 보내는식,
	그뒤에 서비스 프록시순으로 똑같이 이어짐
	1.dns
		쿠버네티스에서 서비스를 검색하는 가장 일반적인 방법은 dns임
		쿠버네티스 기본요소엔 dns컨트롤러가 없지만,서비스리소스에 dns를 제공하는 애드온컨트롤러가 있음
		
		모든 서비스는 생성시 서비스이름.네임스페이스.svc.cluster.local의 형식의 가상서비스와 관련된 dns a 레코드를 가져옴
		단 헤드리스서비스는 a레코드대신 재량에따라 사용할수있는 a레코드 목록을 줌
	
	2.환경변수
		dns외에도 사용은 잘 안하지만 자동으로 추가되는 환경변수(env)를 사용해서 검색할수있는데,주의점은
		프로세스환경은 파드가 시작하는시간에 추가되기때문에,이렇게 검색할땐 파드 시작전에 필요한 서비스를 정의해야함
		파드가 시작한후엔 서비스업데이트를 고려하지않음(이미 파드는 만들어져서 미래일은 반영안함)
	
	
4.네트워크 정책
	쿠버네티스에서 보안에서 제일 중요한건,서비스가 적절한 고객에게만 노출되도록 보장하는것
	예를들어 db백엔드가 필요하면,api엔드포인트만 외부고객에게 노출하는것(파사드패턴같은식)
	즉 이러면 api만 데이터베이스에 접근하는게 가능해지고 직접통신으로부터 안전해짐
	이렇게 osi모델 3층과 4층에서 서비스격리는 공격대상영역을 제한하는데 도움이됨
	보통 이런건 방화벽으로 구현되어있고,iptables로 적용함
	
	정상적인상황에선 iptables은 서버관리자만 조작할수있고,규칙이 실행되는 노드의 로컬에 있음
	이걸 풀고싶으면 3층과 4층에 관련된 networkPolicy리소스를 쓰면됨
	이건 네임스페이스,파드,cidr블록에도 쓸수있는 송신및 수신(인그레스와 에그레스)규칙을 제공함
	
	필요해지면 보자,차단할떄 쓸일있을거같긴함

5.서비스메시
	서비스메시는 파드간 네트워킹이 필요할때 도와주는 스마트프록시모음임
	이런건 앱파드에서 사이드카로 작동하거나,데몬셋으로 작동함
	그러면 트래픽을 프록시하게 파드를 구성하면 파드가 메시의 일부가됨
	
	서비스메시의 기능은
		트래픽관리
			서비스메시는 특정 서비스에서 들어오는 요청을 처리할수있고,카나리아나 블루그린같은 배포를 가능하게함
			그리고 일부솔루션은 프로토콜을 인식해서,예를들면 속도를 체크해 엔드포인트의 선택가중치를 조절할수있음
		관찰성
			클러스터에 마이크로서비스를 배포할떈,파드간의 상호연결성을 이해하기 어려운데,이때 서비스메시가 분산추적으로 추적하기 쉽게 잘라줌
			즉 불필요한걸 제외하고 개별요청의 흐름만 추적할수있게해줌
		보안
			언더레이 네트워크가 기본암호화를 제공하지않을떄,서비스메시는 양쪽에 상호tls를 제공하기때문에 보안상 유리함
	
	
	





