1.쿠버네티스란
	클러스터:쿠버네티스가 최종 사용자에게 줄수있는 전체 컴퓨팅 리소스를 제공하기위해 작동하는 여러시스템
		  쿠버네티스클러스터는 모두 단일 api로 제어되며 해당 api의 사용자가 사용할수 있는 시스템모음임
	
	나머지는생략
2.쿠버네티스 살펴보기
1.컨테이너
	컨테이너는 컨테이너 이미지,실행중인 프로세스,또는 프로세스를 격리하는 일련의 운영체제 개념을 말함
	보통 이 3가지를 혼합한느낌으로 사용함
	
	컨테이너 이미지는 앱 런타임을 포함하는데,이는 바이너리 라이브러리 컨테이너를 실행하는데 필요한 기타데이터로 구성되어 있음
	개발자는 자신의 컴퓨터에서 앱을 컨테이너 이미지로 패키지화하는데(개발자의 컴퓨터 환경 그대로 복사를 하는거)
	그러면 다른 컴퓨터나 서버에서 이미지를 배포하고 실행할때도 동일하게 작동할거라고 신뢰할수 있음
	
	컨테이너 이미지가 실행될땐 운영체제의 네임스페이스를 사용하여 실행됨
	이 네임스페이스는 프로세스를 포함하고 있으며,시스템에서 실행중인 다른 프로세스나 그런것들과 격리할수 있음
	즉 각 컨테이너는 분리된 고유한 파일시스템을 가지고있음을 의미하고,
	또한 각 컨테이너에 고유한 자체 네트워크와 프로세스식별자 네임스페이스가 있음을 의미함
	
	그리고 제어그륩을 사용하면 cpu나 메모리같은 리소스사용도 격리할수 있음
	
	이렇게 이미지를 뜨기위해 컨테이너 이미지 빌더 같은걸 기반으로 라이브러리등을 사용해서 이미지를 뜨고,
	이미지 레지스트리에 이미지를 푸시해서 거기서 받아쓰는형식으로 사용함
	
	푸시한 다음에 컨테이너를 사용해서 이미지를 받아서 써야하는데,이때 컨테이너 오케스트레이션을 사용함

2.컨테이너 오케스트레이션
	레지스트리에서 이미지를 저장후 동작하는 앱을 만들려면 컨테이너 이미지를 실행시켜야 함
	이때 쿠버네티스가 필요해지는데,쿠버네티스의 역할은 cpu,메모리같은 리소스를 가져와서 컨테이너를 배포하는데 사용할수 있도록
	컨테이너 지향 api로 변환하는것
	즉,쿠버네티스 api를 사용하면 컨테이너 이미지를 실행하기위해선 코어3개와 메모리 4기가가 필요합니다 처럼 원하는 상태를 표현할수 있어짐
	
	쿠버네티스 시스템은 이 리소스를 검토하고,이 이미지가 실행될수 있는 위치(노드)를 찾아서 해당위치에서 컨테이너가 실행되도록 스케줄 함
	개발자는 실행되는것만 확인하면되고,어디서 실행됐는지는 관심가질필요가 없음
	
	오케스트레이션 시스템은 컨테이너를 서버에 스케줄하는것 이상의 역할이 있음
	문제가 발생했을때 컨테이너를 복구하는것도 얘의 역할
	컨테이너 내부의 프로세스가 충돌하면 쿠버네티스가 이를 다시 시작함
	사용자 정의 상태 검사(헬스체크)를 정의하면,앱이 교착상태에 있어서 다시시작해야하는지(정상검사),로드밸런싱 조정 서비스(준비상태검사)를 해야하는지
	를 알수있음
	
	로드밸런싱(부하분산)과 관련하여 쿠버네티스는 다양한 레플리카간 트래픽의 로드밸런싱 방법을 정의하는 오브젝트도 제공함
	api오브젝트는 실행중인 컨테이너를 나타내는 로드밸런서를 생성해라같은 상태를 표현할수 있는 방법도 제공함
	이런 로드밸런서에는 검색하기 쉬운 이름이 부여되니까 클러스터내에서 쉽게 연결할수 있음
	
3.쿠버네티스 api
	쿠버네티스는 http,json기반의 restful api이며,api서버가 제공됨
	쿠버네티스의 모든 구성요소는 api를 통해 통신함
	
	1.기본오브젝트
		파드:파드는 가장 작은단위임,하나이상의 컨테이너로 구성되고,파드내에서는 네임스페이스와 네트워크를 컨테이너들끼리 공유함
		    레플리카(복제)의 단위기 때문에,보통 컨테이너 하나넣고 쓰는듯
			
		레플리카셋:파드들을 복제하기 쉽게 하나이상의 파드들을 묶어서,갯수를 지정해둔것
			   레플리카 숫자만 바꿔주면 알아서 파드갯수가 바뀜,복제는 시스템에서 알아서 해주니까 신경안써도됨
			   
		서비스:레플리카셋으로 복제하고 그냥 두면 한군데 트래픽이 몰리니까,그 트래픽을 로드밸런싱 하고,파드간의 통신을 할때 사용하는 오브젝트
			서비스가 생성되면 고정ip주소가 할당되고 패킷이 거기로 들어가면,이 서비스를 구현하는 파드집합으로 로드밸런스됨
			
			고정ip주소가 주어지면 dns이름이 클러스터의 dns서버에 프로그래밍되는데,이 dns이름은 서비스오브젝트와 같은(바로가기같은느낌)취급이고
			클러스터의 다른 컨테이너가 서비스의 ip주소를 검색할수 있게 해줌
			
			그리고 서비스의 로드밸런싱은 클러스터의 네트워크 패브릭에 프로그래밍되어,
			서비스ip주소와 통신하려고 시도하는 컨테이너가 파드에 로드밸런싱되는 형식으로 이루어짐
			이 패브릭프로그래밍은 동적이므로,파드가 어디로가든 재시작하든 뭘하든 클러스터의 현재상태와 일치하게 갱신되기때문에
			파드의 위치에 대해 신경안쓰고 맡겨도됨
		
		스토리지(퍼시스턴트 볼륨,컨피그맵,시크릿):
			볼륨은 파드에 볼륨을 추가할때 실행중인 각 컨테이너의 임의의 위치에 볼륨을 연결하도록 선택할수 있고,
			이렇게 컨테이너가 볼륨내 스토리지에 접근함
			다른컨테이너는 이 볼륨을 다른위치로 연결하거나(한볼륨을 두군데이상에서 동기화시키는식으로 쓸수있음),
			볼륨을 무시할수있음
			
			컨피그맵은 구성파일의 모음을 나타내는데,역시 이것도 용량을 차지하니까 볼륨으로 볼수있음 
			컨피그맵을 파드에 추가하면 컨테이너의 지정된 디렉토리에서 나타남
			
			그리고 시크릿은 볼륨내에서 컨피그맵과 동일하게 동작함
			시크릿은 볼륨으로 파드에 부착할수있고,컨테이너에 연결할수있음
			
			그리고 그냥볼륨을 써서 파드를 배포하면 모든 파드에 같은 볼륨을 연결해야한다는 문제때문데 퍼시스턴트 볼륨이 나옴
			이건 파드에 직접 볼륨을 결합하는 대신 별도의 오브젝트가 생성되고(퍼시스턴트볼륨),
			퍼시스턴트볼륨클레임이 이걸 특정 파드에 할당하고 이 요청으로 파드에 최종적으로 연결됨
			즉 서비스처럼 중간에 객체를 둬서 얘를 가지고 자동적으로 볼륨을 생성하고,상황에따라 다른볼륨을 연결할수있음
			
	2.클러스터 구성 오브젝트:네임스페이스,레이블,어노테이션
		네임스페이스:네임스페이스는 api오브젝트를 위한 폴더임
				클러스터에 있는 다른 모든 오브젝트를 포함하는 디렉터리로,종류별로 특정 폴더에 몰아넣고 거기다 기능이나 규칙을 적용시킬수있음
				네임스페이스를 삭제하면 그 안에 있던거 전부 사라지니까 주의해야함
				그것외에도 서비스용으로 작성된 dns이름과 컨테이너에 제공되는 dns검색경로에도 배치됨
		레이블과 레이블쿼리:
			레이블은 자기가 속한 집합(직접적으로)을 나타냄
			레플리카셋이나 디플로이먼트가 복제할때 갯수셀때도 레이블가지고 갯수를 세는식임
			그리고 검색할때도 키:값 으로 검색하고 저걸 조건으로 무슨 명령같은걸 적용시킬수도 있음
			보통 적용할 오브젝트 집합을 식별하는방법으로 노드셀렉터나 파드셀렉터같은 레이블셀렉터를 사용함
			이게 쿠버네티스가 느슨하게 오브젝트를 결합하는 기본적인 방법
		어노테이션:
			얘는 오브젝트 자체에 대한 주석임
			이건 시스템이 받아서 설정으로 쓰거나,아예 사용자가 주석으로 쓰려고 전화번호같은걸 적어둘수도 있음
			시스템은 여기서 아이콘같은걸 받거나 할수있음(키워드:밸류로 정확히썼을때)
	
	3.고급오브젝트:디플로이먼트,인그레스,스테이트풀셋
		디플로이먼트:레플리카셋에 배포기능을 추가한것
				다음버전으로 업데이트선언이 들어오면,레플리카셋을 내부적으로 하나 더 만들어서 그쪽으로 옮긴뒤 원래있던걸 삭제하는식
				여기서 한번에 다옮기지않고 25%정도씩 잘라가면서 옮김
		인그레스:서비스는 간단한정도의 로드밸런싱은 되지만 좀 커지면 분야가 아님
			  이때 사용하는게 http를 이해하는 인그레스임
			  얘는 경로및 호스트기반 http로드밸런서와 라우터를 나타냄
			  얘도 똑같이 가상ip주소를 받지만,얘는 http요청내용을 사용해서 다른 서비스로 라우팅함,
			  즉 서비스간에 로드밸런싱을 함
			  
		스테이트풀셋:앱은 수평으로 복제되고 같은레플리카로 취급될때 올바르게 작동함
				근데 어떤애들은 순서대로 실행시켜야하고 그런 상태가 필요할수 있는데,이때 스테이트풀셋을 사용함
				얘는 생성될때 0부터 n번까지 순서대로 생성되고 실행되고,삭제될떈 마지막부터 순서대로 삭제됨
				
	4,배치워크로드:잡과 크론잡
		잡:잡은 일회성으로 실행해야할 작업 집합
		  레플리카셋및 스테이트풀셋과 마찬가리고 컨테이너이미지를 실행해서 작업을 실행하는 파드를 생성하는데,
		  얘는 작업을 완료하고 종료할떄까지만 실행됨
		크론잡:얘는 잡에 일정을 추가해서 한시간단위같은 일정주기로 잡을 실행시킴
	
	5.클러스터 에이전트와 유틸리티:데몬셋
		데몬셋:데몬셋은 모든 노드에 하나씩 실행시켜야할때 사용됨
			 이걸 생성하면 각 노드가 데몬셋파드가 실행중인지 시스템이 계속 확인하면서 꺼지면 재생시키고,노드가 추가되면 추가하고 함
			 즉 모든노드에서 실행시켜야할게 있을때 사용


3.아키텍쳐
1.개념
	1.선언적구성
		쿠버네티스는 선언적 구성을 사용하는데,이게 쿠버네티스의 메인동작원칙임
		모든 행위는 선언적형태로(a파드 5개 이런식)으로 원하는 상태로 선언되고,+2개같은 명령으로 관리하지않음
		그리고 쿠버네티스는 그 선언된거에 책임을지고 5개로 만들어 둠
		그래서 노드에 문제가 생겨도 상태를 유지하려하기때문에 따로 뭐 손댈게없음
	2.조정 또는 컨트롤러
		이렇게 자가복구나 자가수정을 수행하기위해 쿠버네티스는 독립조정 또는 제어루프기반으로 구성됨
		보통 이런걸 설계할때 단일상태기반접근방식과 분산형 컨트롤러 방식이 있는데
			단일상태기반접근방식은 시스템이 모든걸 다 처리하는식임
			근데 이건 이해하긴쉬운데 문제생기면 전체가 다운됨
		
			분산형컨트롤러는 모든 작업을 최소단위로 잘라서,각 컨트롤러는 그 최소단위에만 책임을 지고 동작함
			이건 전체가 다운안된다는 장점이 있지만,이해하기가 힘듬(컨트롤러가 너무많으니까)
			
		쿠버네티스의 패턴은
			1.원하는상태를 받음(yaml로)
			2.그 오브젝트를 관찰함
			3.원하는상태와 오브젝트의 차이점을 찾음
			4.원하는상태와 일치하도록 조치함
		으로 이루어져있음
	3.암시적 또는 동적 그룹화
		여러 레플리카를 그룹화하든,로드밸런서의 백엔드를 식별하든 어쩌든 일단 걔가 속한 그룹을 구별해야함
		그때 암시적그룹과 명시적그룹이 있음
		
		명시적 그룹은 그 그룹에 속한 모든 멤버를 명시적으로 적는식이고,
		암시적 그룹은 멤버가 그 그룹의 키를 가지고있으면 그 그룹에 속하는식임
		
		명시적 그룹은 멤버가 잘 안바뀔떄 쓰는데,쿠버네티스의 경우엔 맨날맨날 바뀌고 파드단위가 언제든 사라질수 있기때문에 사용하지않음
		그래서 암시적 그룹을 사용함
		
		암시적 그룹은 항상 바뀔수있어서 서치에 코스트가 좀 들긴하지만,안정적이며 계속 그룹목록을 감시하지않아도되서 유연함
		
		쿠버네티스에서 암시적 그룹화는 레이블과 레이블셀렉터로 수행함

2.구조
	1.유닉스철학
		쿠버네티스는 일반적인 유닉스 철학인 각자 일을 잘 수행하는 작은조각,즉 모듈화를 기반으로 함
		쿠버네티스는 단일 바이너리에서 모든기능을 구현하지 않고,전체 시스템을 구현하는 작은 조각들의 모음임 
		그래서 api부분만 잘 맞춰주면 모든 모듈들을 교체할수 있음 
	2.api기반 상호작용
		쿠버네티스의 모든 상호작용은 api서버를 통해 이루어짐
		여기서 중요한점은 구성요소들이 사용하는 api가 사용자가 사용하는 api와 완전히 같다는것
		이건 시스템의 어느부분도 다른부분보다 특권을 갖지않고 상호간에 직접접근할수없다는것
		그래서 api만 맞춰주면 모든 구성요소를 대체하여 구현할수있음
		
		그리고 이건 버전이 좀 차이나도 시스템이 안정적으로 동작하게함(어짜피 api기반이니까 그게바뀌지않으면 됨)
		물론 api가 바뀌면 손대야하긴하지만
3.구성요소
	쿠버네티스는 워커와 헤드(마스터) 노드로 나누어지고,
	인프라를 구성하는 대부분의 요소는 헤드,컨트롤,플랜,노드에서 실행됨
	클러스터에는 일반적으로 노드수가 홀수인데 이 노드에는 etcd나 api서버같은 구성요소들을 실행함
	홀수인 이유는 알고리즘이 홀수여야하는 알고리즘을 사용해서 그럼
	
	그리고 클러스터의 실제 작업은 워커노드에서 수행됨
	
	그리고 쿠버네티스 구성요소가 생성되면 쿠버네티스 클러스터에 스케줄됨
	쿠버네티스의 관점에서 이게 다른작업들과 구별되진않지만,전체 api의 일부에 포함됨

	1.헤드노드의 구성요소
		헤드노드는 쿠버네티스 api기능을 구현하는 핵심요소들이 모아져있음
		일반적으로 그것들만 헤드노드에서 실행되고,헤드노드를 공유하는 사용자컨테이너는 없음
		
		etcd:
			etcd는 클러스터의 핵심임
			모든 클러스터의 오브젝트가 유지되는 키/밸류 저장소를 만들어서 저장함
			etcd는 분산합의 알고리즘으로 스토리지 서버 하나에 문제가 발생해도 데이터를 유지하고 다시 추가될때 복구할수있게 충분하게 복제가 됨
			
			etcd의 중요기능 2가지는
				첫번째는 낙관적인 동시성임,etcd에 저장된 모든값에는 해당 리소스버전이 있고,
				키값쌍이 etcd에 등록되면 특정리소스버전을 조건으로 지정할수있음
				즉 etcd를 사용하면 비교후교환(최신버전인지를 확인하고 교환하는것)을 구현할수 있음
				그러면 사용자가 값을 읽고 다른구성요소가 업데이트하지 않았다는걸 확인후 업데이트할수 있어지고,다중스레드를 안전하게 할수있어서
				서버의 처리량을 크게 줄일수 있음
				
				두번쨰는 워치 프로토콜임
				워치는 클라이언트가 전체 키값저장소의 변경사항을 효율적으로 감시할수 있다는것
				워치를 사용하면 클라이언트가 지속적으로 etcd에 폴링하지않아도 효과적으로 변경사항을 기다리고 대응할수있음
		api서버:
			api서버는 클러스터에서 중앙에서 통신을 담당함
			모든 클러스터내부의 상호작용은 얘를 거쳐서 감
		스케줄러:
			얘는 파드를 실행할 위치를 찾음
			스케줄되지않은 파드를 찾고,파드의 조건에 따라 노드를 선택해서 던져줌
		컨트롤러 관리자:
			얘는 레플리카셋,디플로이먼트,서비스등을 구현할때 필요한 조정제어루프를 실행하는것
			
			
	2.모든 노드의 구성 요소
		쿠블렛:
			얘는 클러스터의 일부인 모든 시스템의 노드데몬임
			얘는 노드의 cpu,메모리등을 클러스터에 연결함
			얘는 api서버와 통신해서 노드에서 실행될 컨테이너를 찾음
			마찬가지로 쿠블렛은 이런 컨테이너의 상태를 다시 api서버에 전달하므로 다른 조정제어루프가 컨테이너의 현재상태를 볼수있음
			
			쿠블렛은 컴퓨터에서 파드로 실행되고 있는 컨테이너의 상태를 스케줄링하고 보고하는것 외에도,
			컴퓨터에서 실행될것으로 예상되는 컨테이너의 상태를 확인하고 다시 시작하는 일을 담당함
			즉 컨테이너에서 문제가 생겨서 api서버로 올라갔다가 다시 내려오는게 아닌,선조치 후보고를 함
			대신 api서버엔 컨테이너 껏다켰다고 보고는 함
		
		kube-proxy:
				   모든 컴퓨터에서 실행되는 다른 구성 요소는 쿠브프록시임
				   얘는 쿠버네티스 서비스 로드밸런서 네트워킹 모델 구현을 담당함
				   얘는 클러스터의 모든 서비스에 대한 엔드포인트를 감시하고있음
				   그런 다음 노드의 네트워크를 프로그래밍해서 서비스의 가상ip주소를 통한 요청이 서비스의 엔드포인트에 도달하게 함(라우팅되게함)
				   쿠버네티스의 모든 서비스는 가상ip주소를 가지며,프록시는 로컬로드밸런서를 정의하고 구현하는 데몬임
				   얘는 클러스터의 어디든 파드에서 파드로 트래픽이 라우팅하게 함
	3.스케줄된 구성요소
		모든 요소들이 성공적으로 작동하면 최소한 실행 가능한 클러스터임
		근데 실질적으로 무조건쓰는게 몇개 더있음
		
			쿠버dns:
				서비스가 생성되면 가상ip주소를 얻지만,이걸 dns로 바꿔야 쉽게 쓰기좋음
				얘는 그 ip:문자열을 담당함
				얘 자체는 서비스로 표현되므로 프록시가 제공하는 동일한 라우팅이 dns트래픽을 쿠버dns컨테이너로 라우팅함
				중요한 차이점은 얘는 정적 ip주소가 부여된다는것
				즉 같은 스트링으로 어디 설정되는 신경안쓰고 저 정적주소를 넣으면 된다는것
				
			힙스터:
				요즘은 폐기됨
				얘는 모든 컨테이너의 cpu,메모리등의 메트릭을 수집하고 이걸모니터링할수있게 푸시해줌
				요즘은 메트릭서버가 기본임
				   
























