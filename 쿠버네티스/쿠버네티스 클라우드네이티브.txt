1.소프트웨어세상의 세가지혁명
	스킵

2.쿠버네티스 첫걸음
1.도커
	1.이미지란?
		컨테이너 이미지는 그 앱실행에 필요한 모든걸 모아둔 압축파일이라고 보면됨
		이미지는 바이너리파일로 되어있음
		
		도커파일은 보통 베이스이미지라고 부르는 시작이미지를 가져와서,거기에 자기가 만든 앱을 넣어서 새 이미지를 만드는식으로 운용됨
		즉 밀키트사서 거기다 치즈넣어서 먹는거임
		
		도커파일은 텍스트파일로,이미지가 포함할걸 구체적으로 지정함
		즉, 이런식으로 하면 컴파일러같은건 외부의 경로로 지정할수있어서 용량이 매우 작아지게됨(기본베이스는 외부로빼고 바뀐거만 가지니까)
		
	2.포트포워딩
		컨테이너에서 실행되는 프로그램은 같은컴퓨터의 다른프로그램과 격리됨,즉 직접 포트로 접근할수없음
		그래서 내부포트랑 외부포트랑 연결시켜줘야함,즉 포트포워딩이 필요함
		
	3.컨테이너레지스트리
		기본 이미지를 외부에서 가져온다면 그 외부는 컨테이너레지스트리고,일반적으로 사용되는건 도커허브임
		물론 직접 레지스트리를 구축할수도있음
		


3.쿠버네티스 구축하기
1.클러스터아키텍쳐
	쿠버네티스는 여러서버가 하나의 클러스터로 작동함
	클러스터는 컨트롤플레인(마스터노드)과 노드(워커노드)로 구성되어있음
	
	마스터노드는 api서버 etcd 스케줄러 컨트롤러매니저로 구성되어있고
	워커노드는 쿠베렛,쿠베프록시,컨테이너런타임을 구성되어있음
	
	여기서 마스터노드는 여러개로 구성되어 고가용성을 보장함,즉 여러개로 복사해서 하나가 고장나도 정상적으로 동작하는걸 보장함(대역폭은좀깍여도)
	그리고 마스터노드는 정상작동하지만 네트워크장애때문에 일부컴포넌트가 통신하지못하는상황에서도
	컨트롤플레인의 고가용성으로 이걸처리할수있음(한마스터노드랑 통신안되면 다른마스터노드 사용해서 통신한다는소리)
	
	그리고 etcd도 여러노드에 걸쳐 복제되어서,절반이상이 사용가능하면(보통홀수로 해야함 3,5이런식)개별etcd가 고장나도 버팅수있음
	
	컨트롤플레인 장애는 앱을 다운시키진않지만 이상하게 동작하게할수있어서 마스터노드의 고가용성을 유지하는게 중요함
	단,워커노드장애는 별상관없는게 워커노드에 장애가생겼으면 그냥자동으로 지우고 다시만들어주면 알아서 정상작동하는 노드로 옮겨줌
	
2.자체호스팅비용
	자체호스팅하는건 너무 비싸고 단가안맞으니까 구글이나 아마존같은거쓰자는소리

3.관리형 쿠버네티스
	뭐 구글이랑 아마존 아주레 3개 있는거 소개하는거

4.턴키형 쿠버네티스
	얘는 관리형을 사용할수없을때 웹브라우저에서 버튼눌러서 클러스터를 받아 쓰는거
5.직접구축
	하지마라는데 하지말자

6.클러스터가없는 컨테이너 서비스
	클러스터신경쓸필요없이 이미지랑 cpu메모리같은거만 지정해주면 알아서 하고 값 돌려주는거,그 아마존람다같은 faas의 전형태같음 2019년책이니




4.쿠버네티스 오브젝트
1.디플로이먼트
	레플리카셋+업데이트시 레플리카셋을 여러개만들수있는권한이 있는,레플리카셋에 어댑터씌운오브젝트
	이때 갯수체크는 레이블기준으로 하기때문에 레이블을 똑같이 디플로이먼트 2개를 만들어서 카나리아도 할수있고 그럼
	
	그리고 컨테이너(파드)가 어떤이유든 종료되면,갯수맞추려고 다시 재생성날림(물론 갯수오버해서지울땐 제외)
	
	조회는 kubectl get deployment로 할수있고,
	한디플로이먼트 상세조회는 kubectl describe 디플로이먼트명 으로 할수있음
	
2.파드
	파드는 쿠버네티스의 제일 작은단위임
	쿠버네티스는 컨테이너의 묶음인 파드단위로 관리를 함
	그래서 파드는 컨테이너의 종류를 여러개 가지고 할수도있긴한데,일반적으로는 하나만넣고쓰는경우가 젤많은듯
	
	파드를 생성할땐 파드를 직접생성하는게 가능하긴한데,어지간하면 단 하나라도 디플로이먼트로 생성해서 관리하는게 좋음

	조회도 디플로이먼트랑 똑같이하면됨

3.레플리카셋
	레플리카셋은 파드의 갯수를 관리하는 오브젝트임
	얘는 자기가 관리하는 레이블명을 가진 파드의 갯수를 관리함
	디플로이먼트가 업데이트할땐,레플리카셋을 하나 더만들고 전레플리카셋의 갯수를 줄이는식으로 업데이트를 함
	
4.상태유지
	쿠버네티스는 사용자가 상태를 선언하고 그걸 쿠버네티스가 알아서 맞추는식으로 돌아감
	이건 쿠버네티스가 꺼질때까지 영원히 반복되고,이걸 조정루프라고 부름(계속 감시하고있음)
	
5.스케줄러
	스케줄러는 파드를 생성할 위치를 정하는 모듈임
	파드의 조건에 맞춰 파드가 생성될 가장 좋은 위치를 정해서 거기다 생성명령을 날림
	
6.yaml형식의 리소스매니지먼트
	쿠버네티스는 선언형시스템이라서 실제상태와 의도한상태를 조정해서 맞춰나감
	즉 의도한상태에서 스펙만 수정하면 쿠버네티스가 나머지일을 알아서 다하니까,디플로이먼트를 삭제하고 다시생성할이유가 없음
	
	쿠버네티스에 날린 yaml값은 내부db에 저장되어있고,그 기록을 감시하고있다가 변경사항이 생기면 거기맞춰 동작하는방식임
	
	쿠버네티스에 yaml을 적용하려면, kubectl apply -f 경로/파일이름.yaml을 하면됨
	
	그리고 여기에 접속하려면 서비스를 만들어서 연결할 앱의 레이블을 지정하고 외부포트와 파드포트를 지정하면 알아서 포워딩도 함
	

7.헬름
	헬름은 yaml템플릿을 관리하는 패키지매니저임
	얘는 다른사람들이 만들어둔걸 가져올수있고,yaml의 의존성을 명시해서 순서대로 설치하게 할수도있고 그런식으로 해야할일을 줄여줌
	즉,yaml을 둘러싼 래퍼를 만들어줌
	
	헬름에서 차트를 설치할땐,
		helm install --name 이름 ./경로
	를 하면 그위치에 지정한이름의 차트가 설치됨







5.리소스관리하기
1.리소스이해
	가장 안정적이면서 클러스터 리소스를 최대한 활용하려면,각 파드들을 적절한 위치에서 실행시켜야하고,그러려면 파드들의 리소스요구량을 알아야함
	그래서 파드들의 최소요구량과 최대요구량을yaml에 적어둬야함
	
	리퀘스트로 최저치(최소 이정도는있어야돌림)리미트로 최대치(아무리많이써도 이정도만씀)을 지정해둬야함
	만약 리미트를 초과하여 파드가 cpu를 사용하려고하면 쓰로틀링이걸리고 성능저하가 발생하고
	메모리를 초과하면 파드는 종료되고(아웃오브메모리) 다시실행됨
	
	쿠버네티스는 리소스 오버커밋을 허용함
	즉 노드는 리미트의 상한을 넘는 파드를 가질수있음,이건 항상 모든 파드가 상한을 치고있진 않을거라 계산하기때문
	여기서 만약 전체리소스의 사용량이 노드의 최대용량에 근접하면,쿠버네티스는 미리 부여한 우선순위에따라 파드를(컨테이너를)종료함
	이떄 우선순위가 없으면 리소스요청을 가장 많이 초과한파드부터 종료함
	
	그리고 이미지는 최대한 작게 유지하는게 여러점에서 좋음,
	작은건 빨리빌드되고,저장공간을 덜차지하고,풀링이 빠르고 보안취약점이 줄어듬
	
2.컨테이너 생명주기 관리
	컨테이너가 스턱상태(프로세스가 실행중이지만 요청을 처리할수없는상태)에 빠지는건 일반적임
	이상태를 감지하고 재시작해서 문제를 해결할수 있어야함
	
	여기서 사용되는게 활성프로브(livenessprove)와 준비성프로브(readinessprove)임
	활성프로브는 컨테이너가 살아있는지 헬스체크를 하고,
	준비성프로브는 컨테이너가 응답을 받을수있는지 체크를 함
	준비성프로브검사에서 실패하면,성공할때까지 파드가 속한 서비스의 엔드포인트에서 제거되고,성공하면 다시 넣음
	그리고 준비성프로브검사가 성공하고나서도,안정화를위해 몇초뒤까지 기다리게할수있음
	
	그리고 준비성프로브는 파일을 생성하고,exec로 파일이 존재하는지를 확인하는식으로 사용할수있음
	이건 테스트에서 유용한데,멈춰야할때 파일만 지워버리는걸로 서비스중단상태를 만들수있음
	
	프로브들은 컨테이너스펙에 지정할수있고,시작딜레이랑 중간딜레이와 패스,포트를 지정하고 넣으면됨
	프로브들은 http,tcp소켓,exec로 커맨드를 쓸수도 있음
	커맨드는 커맨드가 성공하면(리턴값이 0이면)성공함,이건 준비성프로브에서 잘쓰임
	
	그리고 파드가 멀쩡해도 파드를 중지해야할때에(노드업그레이드하거나 파드를 다른노드로 옮겨야할때)
	PodDisruptionBudget를 써서 파드를 제거할 양을 제한해서 순차적으로 제거할수있음
	minAvailable필드로 최소실행갯수를 지정할수있고
	maxUnAvailable로 퇴출할 총갯수나 비율을 제한할수있음
	
	그리고 이건 쿠버네티스의 자발적퇴출에만 적용되고,당연히 서버다운같은거엔 적용안됨
	

3.네임스페이스 사용
	네임스페이스로 리소스사용을 관리할수 있음
	네임스페이스마다 사용량을 제한하고(즉 네임스페이스를 가상클러스터로 사용할수있음) 내부의 격리된 상태를 만들수있음
	그리고 조심해야할건,네임스페이스를 삭제하면 안에있던 모든게 날아감(폴더랑같음)
	
	네임스페이스끼리 통신해야하면 dns에 적힌 이름으로 들어가면됨
	즉 dns에 이름을 추가하면 연결할 서비스를 정확히 지정할수있음,
	보통 기본값은 서비스.네임스페이스.svc.cluster.local임
	
	그리고 앞에서말했던거처럼,네임스페이스에 ResourceQuota를 만들어서 리소스총량을 제한할수있음
	이떄 cpu나 메모리같은거 뿐만아니라 파드의 총갯수같은거도 제한할수있음
	그리고 보통 이렇게쓰고,cpu나 메모리같은거 제한은 문제생길까봐 잘 안하는데
	파드총갯수는 실수로 엄청많이 복제될까봐(레플리카셋 레플리카 숫자 0하나 더넣던가그래서) 그런걸 막으려고 넣는거같음
	
	그리고 limitRange로 기본 리소스 요청과 상한을 정할수있는데,
	이걸 만들어두면 파드들의 리소스 요청상한 기본값을 지정하는거임
	그렇다고 이거만들어뒀다고 너무믿지말고,실수로 빼먹을까봐 넣어두는거니까 명시적으로 적어두는게 좋음
	



4.클러스터비용최적화
	레플리카(디플로이먼트)는 많으면 업데이트를 하거나 파드에 장애가 발생해도 처리하기 좋긴하지만,그 파드 하나하나가 다 리소스니까
	파드는 컨테이너의 조건에 따라(즉발적으로 반응해야하는지,좀 느려도되는지) 최대한 수를 줄이는게 좋음
	그리고 업데이트시 몇초정도 멈춰도 되면 레플리카셋도 한두개정도로 처리가 가능함
	
	그리고 파드의 요구사항도,최대한 현실과 가까워야함
	너무 제한이 높으면 비용이 높게나오고(요구치에따라 할당하니까)
	제한이 낮으면 제대로 실행이 안됨
	
	이건 직접 모니터링을 하면서 체크하는게 좋음,프로메테우스와 그라피나를 쓰던가,아마존같은데선 직접 통계도구 지원하니까 그거쓰던가
	그리고 메모리나 cpu는 실제 최대치보다 약간 높게잡는게 좋긴함 튈수있으니까(500정도쓰면 600)
	
	그리고 이떄 쓸수있는 애드온으로 Vertical pod autiscaler가 있는데,
	이건 디플로이먼트를 관찰하고 실제사용량에 따라 자동으로 파드의 리소스요청을 조정하는데,보통은 수정하진않고 제안만 하는 드라이런모드를 사용함
	1.노드최적화	
		모든 노드는 운영체제가 있어서 이거로 디스크,메모리cpu자원을 소모함
		그래서 노드크기가 작을수록 고정비가 오르는데,그렇다고 무조건 큰노드쓰면 문제생겼을때 일이 크게터짐
		
		그래서 일반적으론 노드가 파드를 5개정도 실행시킬수있게 하고,버려지는리소스를(고정비) 10%이하로 유지시키고
		파드를 10개이상 실행시킬땐 고정비를 5%미만으로 유지해야함
		
	2.스토리지 최적화
		스토리지도 다 비용임
		스토리지는 요청과 상한으로 조정이 불가능함
		그래서 실제 사용하는 처리량과 공간을 기준으로 가장 작고 낮은등급의 iops볼륨을 할당하는게 좋음
	3.더미리소스정리
		안쓰는 리소스들이 계속 쌓이면(잡같은거) 그거자체로 비용이니까 안쓰는게 있으면 정리해야함
		이떈 만든사람의 이름을 anno에 적어서 자기꺼 책임지고 관리하게하면됨
		
		그리고 트래픽이 매우낮거나 없는걸 메트릭을 써서 볼수있는데,이걸기준으로 낮은걸 삭제할수도 있음
		
	4.여유용량 파악
		그렇다고 완전히 꽉꽉채워두면 뭐 하나 문제터지면 그대로 쓰러지니까 어느정도 빈공간을 만들어둬야함
		이떄 확인하는방법은 현재 사용중인 노드중 제일큰걸 터트려보면됨
		그때 문제생기면 좀 더 여유공간을 만들어둬야함

	5.클라우드결제
		클라우드를 3년정액으로 사면 싸긴한데,나중에 증설해야하면 그대로 다 날아가니까,미래의 요구사항을 예측할수있을때 사용하면좋음
		그리고 스폿인스턴스는 필요할때 요구해서 사용하는식임
		근데 이건 비용은 싸긴한데 좀 불안정하니까 비선점형하고 섞어쓰는게 좋음,이떄 비율은 선점형을 66퍼센트 이하로 맞추는게 좋음
		
		그리고 선점형에다가 좀 덜 중요한 파드들을 어피니티로 우선스케줄링 할수있음
		
	6.클러스터 균형 유지
		보통 일반적으로 파드들을 퍼트려놓는데 쿠버네티스는,업데이트등의 이유로 한군데 몰릴수가 있음
		이러면 위험성이 커지니까,디스케줄러같은 도구를 크론잡으로 실행해서 균형을 맞춰주는게 좋음
		디스케줄러는 사용률이 낮은 노드를 찾고 다른노드에서 실행중인 파드를 종료해서 유휴노드로 스케줄되게하거나(즉 노는노드 일시키거나)
		두개이상의 레플리카가 같은노드에서 실행중일때 중복파드를 퇴출시킴
		
	
	
6.클러스터 운영하기
1.클러스터사이징과 스케일링
	클러스터의 크기는 가용성을 유지할수 있는 한 최대한 큰 노드를 쓰는게 좋음(그래야 고정비도 적고,가격도 쌈)
	보통 안정적인 마스터노드 갯수는 3개고,워커노드는 장애를 고려하면 두개로하고,모든 레플리카를 최소 2개는 실행하는게좋음
	스케줄러가 항상 균등하게 할당하진 않으므로,노드는 많으면 많을수록 좋음
	
	그리고 뭐 테스트할때까지 이렇게할필욘없고,테스트할땐 제일작은거로 쓰자
	
	그리고 뭐 클러스터 제한을 넘길수준까지 운영해야하거나 지역 두군데이상해야하면,
	클러스터 페더레이션으로 두개이상의 클러스터를 동기화시킬수있긴한데,쓸일이 있을까
	
	보통은 클러스터 두개(하나는 상용 하나는 테스트용도)면 충분한데,이것도 네임스페이스로 나누면 하나만써도됨
	
	그리고 사용할작업에 따라 노드어피니티로,gpu가 있는데서만 실행되는 컨테이너도 있을수있으니까 이렇게 우선순위주면됨
	
	수요나 요청에따라 클러스터를 확장하거나 축소할때,확장은(노드추가) 그냥 관리도구로 추가하면되고 
	축소할땐 노드를 비우고 해야하니 여유공간이없으면 작업이 취소되고 그럴수도있음,즉 정상적으로 종료되어야만 클러스터에서 사라짐
	
	보통 오토스케일링을 지원하는데 그렇다고 서비스초기에 바로 쓰지말고,처음엔 수동으로해보면서 수요예측한다음에 감잡히면 오토스케일링쓰는게 좋대
	보통 큰규모아니면 이것도 쓸일없을거고

2.검증과 감사
	쿠버네티스에서 적합성 검사에서 걸러내지못하는 문제들도 있음
		지나치게 용량이 큰 컨테이너이미지를 사용하면 클러스터리소스가 낭비됨
		단일파드레플리카만 지정하는 디플로이먼트는 고가용성보장이 안됨
		루트권한 클러스터실행은 보안위험이있음
	
	이런것들은 k8guard툴로 체크할수있음
	
	그리고 copper은 배포전에 쿠버네티스 매니페스트(yaml)를 검사하는 툴임
	일반적으로 두개 추가하는게 권장된대
	
	그리고 구글은 로그가 켜져있는게 기본값이지만 아닌애들도있다니까 확인

3.카오스 테스팅
	이건 랜덤하게 노드,파드,앱을 꺼서 테스트하는 툴임
	진짜로 문제상황을 만들어서 대처가되는지 검증하는것
	
	이쪽 툴로 카우스몽키가 있음
	
	그리고 파드를 무작위로 끄는건 카오스쿠베가 있음
	
	
	
	
	
	
	
7.유용한 쿠버네티스 도구
1.kubectl
	kubectl에서 alias로 별칭을 지정할수있음
		alias k=kubectl
	이렇게하면 k get pod하면 됨
	
	그리고 명령어도 별칭으로 압축할수있음
		alias kg=kubectl get
		alias kgd=kubectl get deployment
	이런식
	
	그리고 --로 옵션주면 전체입력이고,-로하면 단축어임
		--namespace의 단축어는 -n
		--selector의 단축어는 -l(레이블)
	그리고 리소스 단축형도 있음
		pod=po
		deployment=deploy
		sevice=svc
		persistentvolumes=pv
		
	그리고 배시를 쓰면 자동완성되니까 꼭 넣어두고,탭으로 자동완성가능
	그리고 배시쓸거면 kube-ps1쓰면 현재컨텍스트가 프롬프트에 표시되고,kube-shell쓰면 팝업으로 자동완성됨
	
	그리고 자세히 출력하고싶으면 -o wide를 하면 자세히 출력됨
		kubectl get pod -o wide
	
	그리고 get은 json으로도 출력이 가능한데
		kubectl get pod -o json
	하면 json으로 출력됨
	그리고 여기서 jq를깔고(json처리 프로그램) 파이프라인으로 json을 넘겨서 쿼리가 가능함
		kubectl get pod -o json | jq '.item[].metadata.name'
	이런식으로 파드의 이름만 출력한다거나,어떤거 웨어하고 오더바이한다거나
	
	그리고 kubectl get pods --watch 하면 자동으로 계속 갱신되고
	kubectl describe pods 파드이름 하면 파드이름에 대한 자세한 정보가 출력됨
	
2.리소스 다루기
	이건 명령형 커맨드(직접 kubectl로 만들고지우고)하는거라 안봐도될듯 알고있기도하고
	
	여기서 yaml을 적용하기전에
	kubectl diff 파일명.yaml으로 변경점을 알수있으니까
	apply하기전에 미리 저거해보고 적용하는게 좋음
	
	그리고 원래 있던 파드를 kubectl get --export로 yaml로 받아볼수있음
	이렇게해서 수정해서 적용해도됨
	

3.컨테이너 다루기
	클러스터의 작동 대부분은 컨테이너 안에서 이루어져서 문제가 생기면 찾기 쉽지않음
	
	1.컨테이너로그
		컨테이너 로그는 컨테이너가 정상작동하는지 문제가있어서 해결해야할때 유용한 정보임
		이떄 로그엔 표준출력과 표준오류가 모두 포함됨
		프로그램이 터미널에서 실행중이면 터미널에서 출력결과를 볼수있음
		
		이때 컨테이너의 로그를 보려면
			kubectl logs -n 네임스페이스명 --tail=로그볼갯수 파드이름
		으로 파드의 로그를 테일갯수만큼 볼수있음
		
		로그출력을 실시간으로 터미널로 스트림하고싶으면 --follow를 저기 붙이면됨
			kubectl logs -n 네임스페이스명 --tail=로그볼갯수 --follow 파드이름
		
		이건 api서버 로그볼때 유용한데,예를들어 rbac권한에러같은게 여기 표시돼서 바로볼수있음
		그리고 관리형서비스면 마스터노드접근이 불가능하니까 서비스업체별로 접근방법을 찾아야함
		
		그리고 파드에 컨테이너가 여러개면 -c 컨테이너명을 저 뒤에 붙이면됨
			kubectl logs -n 네임스페이스명 --tail=로그볼갯수 파드이름 -c 컨테이너이름
		
		그리고 그거로 충분하지않으면 컨테이너에 직접 연결해서 컨테이너의 출력을 볼수도 있음
			kubectl attach 컨테이너명
		
	2.kubespy로 리소스감시
		kubespy라는 툴은 앱 배포할때나 그럴때 클러스터 내 개별 리소스의 상태를 관찰하고 시간에 따른 변화를 사용자에게 보여줌
		예를들어 서비스가 생성될떄,ip주소가 할당될때 엔드포인트가 연결될때같이 모든 상황을 볼수있음
		
	3.컨테이너 포트포워딩
		kubectl port-forward로 서비스에 연결해서쓰는게 일반적이지만,파드에(컨테이너에) 직접 연결할수도 있음
			kubectl port-forward 파드이름 컴퓨터포트:컨테이너포트
		
	4.컨테이너에 명령어 실행
		컨테이너에 문제가 생기면 kubectl exec로 컨테이너에서 셸을 실행해서 명령어를 날려볼수있음 
			kubectl exec -it 파드명 명령어
		기본적으로는 첫번째컨테이너에 명령어를 실행하는데,이거도 -c 컨테이너이름으로 컨테이너 지정할수있음
		
	5.문제해결을 위한 컨테이너
		문제해결을위해 일회용 컨테이너를 만들고 실행해서 확인할수있음
			kubectl run 붙일dns이름 --image 이미지명 --expose --port 붙일포트번호
		로 생성하고
			kubectl run dns명 --image=이미지명 -rm -it --restart=Never\--command --쓸커맨드
		이런식으로 한번만들어서 커맨드 날리고 자동으로 삭제하는식으로 쓸수있음
		
		여기서 
		-rm은 실행후 컨테이너 이미지삭제하라는 플래그고
		-it는 컨테이너를 터미널을 통해 대화형으로 실행하라는거,이거넣어야 커맨드넣을수있음
		-restart=Never은 컨테이너 종료돼도 다시실행 생략하는거
		--command --는 뒤에나올 명령어를 실행하라는거
	
	6.비지박스 명령어
		busybox이미지는 문제생겼을때 자주 run하는 이미지임
		그리고 명령어실행패턴은 항상 같으니까(kubectl run~--command--까지) 전체를 alias해버리면 편함
		
		여기서 /bin/sh하면 대화형셸 실행이고
		nslookup 파드명 등 이 있음
		필요해지면보자
		
		그리고 컨테이너가 이미 셸을 포함하면
			kubectl exec -it 파드명 /bin/sh
		으로 컨테이너의 셸로 직접 접근할수 있는데
		만약 없으면 busybox를 빌드할때 복사해 넣어서 그거로 접근할수있음(도커파일에)
		
		그리고 비지박스에 없는 프로그램이 필요한데,공개 이미지에도 없으면 alpine나 우분투이미지를 실행하고 프로그램을 설치하면됨
		
	7.kubesquash디버깅
		상용 디버거를 컨테이너 내 프로세스와 연결하고싶으면 kubesquash로 디버거를 연결하면됨
		저걸 설치하고 실행중인 컨테이너의 이름을 지정해서 실행하면됨
		
		
4.컨텍스트와 네임스페이스
	만약 클러스터가 여러개면,이걸 구분하기위해 컨텍스트라는 개념이 있음
	컨텍스트는 클러스터와 사용자,네임스페이스의 조합임
	즉 네임스페이스랑 논리적으론 같은데,클러스터까지 확장된거임
	
	컨텍스트를 바꿀땐 kubectl config use-context 컨텍스트명으로 넘어갈수있고
	kubectl config get-context로 현재 알려진 컨텍스트를 볼수있음
	그리고 kubectl config current-context로 현재컨텍스트를 알수있음
	무슨 명령어를 실행하든 현재 컨텍스트에 실행되니까 컨텍스트 여러개일땐 주의해야함
	
	그리고 컨텍스트 변환을 쉽게하고싶으면 kubectx와 kubens 툴을 깔아서 쓰면됨
	그럼 이전컨텍스트를 기억하다가 왔다갔다하는식으로 쉽게쓸수있음
	kubens는 네임스페이스 전환임
	이거도 똑같이 기억하고 전환할수있음
		
		
5.셸과 도구
	click는 kubectl의 대화형버전임
	얘는 현재 작업중인 오브젝트를 기억함
	즉 get으로 목록불러오고,거기 인덱스번호로 작업을 할수있음
	
	kubed-sh는 클러스터 내에서 셸이 실행됨
	얘는 현재클러스터에서 js,루비,파이썬등 프로그램실행에 필요한 컨테이너를 자동으로 풀해서 실행함
	즉 이렇게 자동화가 됨
	
	stern은 정교한 로그 검색도구임 얘는 정규표현식으로 로그를 거를수있음,즉 쿼리가 됨
	
	






































