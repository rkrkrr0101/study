1.소프트웨어세상의 세가지혁명
	스킵

2.쿠버네티스 첫걸음
1.도커
	1.이미지란?
		컨테이너 이미지는 그 앱실행에 필요한 모든걸 모아둔 압축파일이라고 보면됨
		이미지는 바이너리파일로 되어있음
		
		도커파일은 보통 베이스이미지라고 부르는 시작이미지를 가져와서,거기에 자기가 만든 앱을 넣어서 새 이미지를 만드는식으로 운용됨
		즉 밀키트사서 거기다 치즈넣어서 먹는거임
		
		도커파일은 텍스트파일로,이미지가 포함할걸 구체적으로 지정함
		즉, 이런식으로 하면 컴파일러같은건 외부의 경로로 지정할수있어서 용량이 매우 작아지게됨(기본베이스는 외부로빼고 바뀐거만 가지니까)
		
	2.포트포워딩
		컨테이너에서 실행되는 프로그램은 같은컴퓨터의 다른프로그램과 격리됨,즉 직접 포트로 접근할수없음
		그래서 내부포트랑 외부포트랑 연결시켜줘야함,즉 포트포워딩이 필요함
		
	3.컨테이너레지스트리
		기본 이미지를 외부에서 가져온다면 그 외부는 컨테이너레지스트리고,일반적으로 사용되는건 도커허브임
		물론 직접 레지스트리를 구축할수도있음
		


3.쿠버네티스 구축하기
1.클러스터아키텍쳐
	쿠버네티스는 여러서버가 하나의 클러스터로 작동함
	클러스터는 컨트롤플레인(마스터노드)과 노드(워커노드)로 구성되어있음
	
	마스터노드는 api서버 etcd 스케줄러 컨트롤러매니저로 구성되어있고
	워커노드는 쿠베렛,쿠베프록시,컨테이너런타임을 구성되어있음
	
	여기서 마스터노드는 여러개로 구성되어 고가용성을 보장함,즉 여러개로 복사해서 하나가 고장나도 정상적으로 동작하는걸 보장함(대역폭은좀깍여도)
	그리고 마스터노드는 정상작동하지만 네트워크장애때문에 일부컴포넌트가 통신하지못하는상황에서도
	컨트롤플레인의 고가용성으로 이걸처리할수있음(한마스터노드랑 통신안되면 다른마스터노드 사용해서 통신한다는소리)
	
	그리고 etcd도 여러노드에 걸쳐 복제되어서,절반이상이 사용가능하면(보통홀수로 해야함 3,5이런식)개별etcd가 고장나도 버팅수있음
	
	컨트롤플레인 장애는 앱을 다운시키진않지만 이상하게 동작하게할수있어서 마스터노드의 고가용성을 유지하는게 중요함
	단,워커노드장애는 별상관없는게 워커노드에 장애가생겼으면 그냥자동으로 지우고 다시만들어주면 알아서 정상작동하는 노드로 옮겨줌
	
2.자체호스팅비용
	자체호스팅하는건 너무 비싸고 단가안맞으니까 구글이나 아마존같은거쓰자는소리

3.관리형 쿠버네티스
	뭐 구글이랑 아마존 아주레 3개 있는거 소개하는거

4.턴키형 쿠버네티스
	얘는 관리형을 사용할수없을때 웹브라우저에서 버튼눌러서 클러스터를 받아 쓰는거
5.직접구축
	하지마라는데 하지말자

6.클러스터가없는 컨테이너 서비스
	클러스터신경쓸필요없이 이미지랑 cpu메모리같은거만 지정해주면 알아서 하고 값 돌려주는거,그 아마존람다같은 faas의 전형태같음 2019년책이니




4.쿠버네티스 오브젝트
1.디플로이먼트
	레플리카셋+업데이트시 레플리카셋을 여러개만들수있는권한이 있는,레플리카셋에 어댑터씌운오브젝트
	이때 갯수체크는 레이블기준으로 하기때문에 레이블을 똑같이 디플로이먼트 2개를 만들어서 카나리아도 할수있고 그럼
	
	그리고 컨테이너(파드)가 어떤이유든 종료되면,갯수맞추려고 다시 재생성날림(물론 갯수오버해서지울땐 제외)
	
	조회는 kubectl get deployment로 할수있고,
	한디플로이먼트 상세조회는 kubectl describe 디플로이먼트명 으로 할수있음
	
2.파드
	파드는 쿠버네티스의 제일 작은단위임
	쿠버네티스는 컨테이너의 묶음인 파드단위로 관리를 함
	그래서 파드는 컨테이너의 종류를 여러개 가지고 할수도있긴한데,일반적으로는 하나만넣고쓰는경우가 젤많은듯
	
	파드를 생성할땐 파드를 직접생성하는게 가능하긴한데,어지간하면 단 하나라도 디플로이먼트로 생성해서 관리하는게 좋음

	조회도 디플로이먼트랑 똑같이하면됨

3.레플리카셋
	레플리카셋은 파드의 갯수를 관리하는 오브젝트임
	얘는 자기가 관리하는 레이블명을 가진 파드의 갯수를 관리함
	디플로이먼트가 업데이트할땐,레플리카셋을 하나 더만들고 전레플리카셋의 갯수를 줄이는식으로 업데이트를 함
	
4.상태유지
	쿠버네티스는 사용자가 상태를 선언하고 그걸 쿠버네티스가 알아서 맞추는식으로 돌아감
	이건 쿠버네티스가 꺼질때까지 영원히 반복되고,이걸 조정루프라고 부름(계속 감시하고있음)
	
5.스케줄러
	스케줄러는 파드를 생성할 위치를 정하는 모듈임
	파드의 조건에 맞춰 파드가 생성될 가장 좋은 위치를 정해서 거기다 생성명령을 날림
	
6.yaml형식의 리소스매니지먼트
	쿠버네티스는 선언형시스템이라서 실제상태와 의도한상태를 조정해서 맞춰나감
	즉 의도한상태에서 스펙만 수정하면 쿠버네티스가 나머지일을 알아서 다하니까,디플로이먼트를 삭제하고 다시생성할이유가 없음
	
	쿠버네티스에 날린 yaml값은 내부db에 저장되어있고,그 기록을 감시하고있다가 변경사항이 생기면 거기맞춰 동작하는방식임
	
	쿠버네티스에 yaml을 적용하려면, kubectl apply -f 경로/파일이름.yaml을 하면됨
	
	그리고 여기에 접속하려면 서비스를 만들어서 연결할 앱의 레이블을 지정하고 외부포트와 파드포트를 지정하면 알아서 포워딩도 함
	

7.헬름
	헬름은 yaml템플릿을 관리하는 패키지매니저임
	얘는 다른사람들이 만들어둔걸 가져올수있고,yaml의 의존성을 명시해서 순서대로 설치하게 할수도있고 그런식으로 해야할일을 줄여줌
	즉,yaml을 둘러싼 래퍼를 만들어줌
	
	헬름에서 차트를 설치할땐,
		helm install --name 이름 ./경로
	를 하면 그위치에 지정한이름의 차트가 설치됨


























































