1.소프트웨어세상의 세가지혁명
	스킵

2.쿠버네티스 첫걸음
1.도커
	1.이미지란?
		컨테이너 이미지는 그 앱실행에 필요한 모든걸 모아둔 압축파일이라고 보면됨
		이미지는 바이너리파일로 되어있음
		
		도커파일은 보통 베이스이미지라고 부르는 시작이미지를 가져와서,거기에 자기가 만든 앱을 넣어서 새 이미지를 만드는식으로 운용됨
		즉 밀키트사서 거기다 치즈넣어서 먹는거임
		
		도커파일은 텍스트파일로,이미지가 포함할걸 구체적으로 지정함
		즉, 이런식으로 하면 컴파일러같은건 외부의 경로로 지정할수있어서 용량이 매우 작아지게됨(기본베이스는 외부로빼고 바뀐거만 가지니까)
		
	2.포트포워딩
		컨테이너에서 실행되는 프로그램은 같은컴퓨터의 다른프로그램과 격리됨,즉 직접 포트로 접근할수없음
		그래서 내부포트랑 외부포트랑 연결시켜줘야함,즉 포트포워딩이 필요함
		
	3.컨테이너레지스트리
		기본 이미지를 외부에서 가져온다면 그 외부는 컨테이너레지스트리고,일반적으로 사용되는건 도커허브임
		물론 직접 레지스트리를 구축할수도있음
		


3.쿠버네티스 구축하기
1.클러스터아키텍쳐
	쿠버네티스는 여러서버가 하나의 클러스터로 작동함
	클러스터는 컨트롤플레인(마스터노드)과 노드(워커노드)로 구성되어있음
	
	마스터노드는 api서버 etcd 스케줄러 컨트롤러매니저로 구성되어있고
	워커노드는 쿠베렛,쿠베프록시,컨테이너런타임을 구성되어있음
	
	여기서 마스터노드는 여러개로 구성되어 고가용성을 보장함,즉 여러개로 복사해서 하나가 고장나도 정상적으로 동작하는걸 보장함(대역폭은좀깍여도)
	그리고 마스터노드는 정상작동하지만 네트워크장애때문에 일부컴포넌트가 통신하지못하는상황에서도
	컨트롤플레인의 고가용성으로 이걸처리할수있음(한마스터노드랑 통신안되면 다른마스터노드 사용해서 통신한다는소리)
	
	그리고 etcd도 여러노드에 걸쳐 복제되어서,절반이상이 사용가능하면(보통홀수로 해야함 3,5이런식)개별etcd가 고장나도 버팅수있음
	
	컨트롤플레인 장애는 앱을 다운시키진않지만 이상하게 동작하게할수있어서 마스터노드의 고가용성을 유지하는게 중요함
	단,워커노드장애는 별상관없는게 워커노드에 장애가생겼으면 그냥자동으로 지우고 다시만들어주면 알아서 정상작동하는 노드로 옮겨줌
	
2.자체호스팅비용
	자체호스팅하는건 너무 비싸고 단가안맞으니까 구글이나 아마존같은거쓰자는소리

3.관리형 쿠버네티스
	뭐 구글이랑 아마존 아주레 3개 있는거 소개하는거

4.턴키형 쿠버네티스
	얘는 관리형을 사용할수없을때 웹브라우저에서 버튼눌러서 클러스터를 받아 쓰는거
5.직접구축
	하지마라는데 하지말자

6.클러스터가없는 컨테이너 서비스
	클러스터신경쓸필요없이 이미지랑 cpu메모리같은거만 지정해주면 알아서 하고 값 돌려주는거,그 아마존람다같은 faas의 전형태같음 2019년책이니




4.쿠버네티스 오브젝트
1.디플로이먼트
	레플리카셋+업데이트시 레플리카셋을 여러개만들수있는권한이 있는,레플리카셋에 어댑터씌운오브젝트
	이때 갯수체크는 레이블기준으로 하기때문에 레이블을 똑같이 디플로이먼트 2개를 만들어서 카나리아도 할수있고 그럼
	
	그리고 컨테이너(파드)가 어떤이유든 종료되면,갯수맞추려고 다시 재생성날림(물론 갯수오버해서지울땐 제외)
	
	조회는 kubectl get deployment로 할수있고,
	한디플로이먼트 상세조회는 kubectl describe 디플로이먼트명 으로 할수있음
	
2.파드
	파드는 쿠버네티스의 제일 작은단위임
	쿠버네티스는 컨테이너의 묶음인 파드단위로 관리를 함
	그래서 파드는 컨테이너의 종류를 여러개 가지고 할수도있긴한데,일반적으로는 하나만넣고쓰는경우가 젤많은듯
	
	파드를 생성할땐 파드를 직접생성하는게 가능하긴한데,어지간하면 단 하나라도 디플로이먼트로 생성해서 관리하는게 좋음

	조회도 디플로이먼트랑 똑같이하면됨

3.레플리카셋
	레플리카셋은 파드의 갯수를 관리하는 오브젝트임
	얘는 자기가 관리하는 레이블명을 가진 파드의 갯수를 관리함
	디플로이먼트가 업데이트할땐,레플리카셋을 하나 더만들고 전레플리카셋의 갯수를 줄이는식으로 업데이트를 함
	
4.상태유지
	쿠버네티스는 사용자가 상태를 선언하고 그걸 쿠버네티스가 알아서 맞추는식으로 돌아감
	이건 쿠버네티스가 꺼질때까지 영원히 반복되고,이걸 조정루프라고 부름(계속 감시하고있음)
	
5.스케줄러
	스케줄러는 파드를 생성할 위치를 정하는 모듈임
	파드의 조건에 맞춰 파드가 생성될 가장 좋은 위치를 정해서 거기다 생성명령을 날림
	
6.yaml형식의 리소스매니지먼트
	쿠버네티스는 선언형시스템이라서 실제상태와 의도한상태를 조정해서 맞춰나감
	즉 의도한상태에서 스펙만 수정하면 쿠버네티스가 나머지일을 알아서 다하니까,디플로이먼트를 삭제하고 다시생성할이유가 없음
	
	쿠버네티스에 날린 yaml값은 내부db에 저장되어있고,그 기록을 감시하고있다가 변경사항이 생기면 거기맞춰 동작하는방식임
	
	쿠버네티스에 yaml을 적용하려면, kubectl apply -f 경로/파일이름.yaml을 하면됨
	
	그리고 여기에 접속하려면 서비스를 만들어서 연결할 앱의 레이블을 지정하고 외부포트와 파드포트를 지정하면 알아서 포워딩도 함
	

7.헬름
	헬름은 yaml템플릿을 관리하는 패키지매니저임
	얘는 다른사람들이 만들어둔걸 가져올수있고,yaml의 의존성을 명시해서 순서대로 설치하게 할수도있고 그런식으로 해야할일을 줄여줌
	즉,yaml을 둘러싼 래퍼를 만들어줌
	
	헬름에서 차트를 설치할땐,
		helm install --name 이름 ./경로
	를 하면 그위치에 지정한이름의 차트가 설치됨







5.리소스관리하기
1.리소스이해
	가장 안정적이면서 클러스터 리소스를 최대한 활용하려면,각 파드들을 적절한 위치에서 실행시켜야하고,그러려면 파드들의 리소스요구량을 알아야함
	그래서 파드들의 최소요구량과 최대요구량을yaml에 적어둬야함
	
	리퀘스트로 최저치(최소 이정도는있어야돌림)리미트로 최대치(아무리많이써도 이정도만씀)을 지정해둬야함
	만약 리미트를 초과하여 파드가 cpu를 사용하려고하면 쓰로틀링이걸리고 성능저하가 발생하고
	메모리를 초과하면 파드는 종료되고(아웃오브메모리) 다시실행됨
	
	쿠버네티스는 리소스 오버커밋을 허용함
	즉 노드는 리미트의 상한을 넘는 파드를 가질수있음,이건 항상 모든 파드가 상한을 치고있진 않을거라 계산하기때문
	여기서 만약 전체리소스의 사용량이 노드의 최대용량에 근접하면,쿠버네티스는 미리 부여한 우선순위에따라 파드를(컨테이너를)종료함
	이떄 우선순위가 없으면 리소스요청을 가장 많이 초과한파드부터 종료함
	
	그리고 이미지는 최대한 작게 유지하는게 여러점에서 좋음,
	작은건 빨리빌드되고,저장공간을 덜차지하고,풀링이 빠르고 보안취약점이 줄어듬
	
2.컨테이너 생명주기 관리
	컨테이너가 스턱상태(프로세스가 실행중이지만 요청을 처리할수없는상태)에 빠지는건 일반적임
	이상태를 감지하고 재시작해서 문제를 해결할수 있어야함
	
	여기서 사용되는게 활성프로브(livenessprove)와 준비성프로브(readinessprove)임
	활성프로브는 컨테이너가 살아있는지 헬스체크를 하고,
	준비성프로브는 컨테이너가 응답을 받을수있는지 체크를 함
	준비성프로브검사에서 실패하면,성공할때까지 파드가 속한 서비스의 엔드포인트에서 제거되고,성공하면 다시 넣음
	그리고 준비성프로브검사가 성공하고나서도,안정화를위해 몇초뒤까지 기다리게할수있음
	
	그리고 준비성프로브는 파일을 생성하고,exec로 파일이 존재하는지를 확인하는식으로 사용할수있음
	이건 테스트에서 유용한데,멈춰야할때 파일만 지워버리는걸로 서비스중단상태를 만들수있음
	
	프로브들은 컨테이너스펙에 지정할수있고,시작딜레이랑 중간딜레이와 패스,포트를 지정하고 넣으면됨
	프로브들은 http,tcp소켓,exec로 커맨드를 쓸수도 있음
	커맨드는 커맨드가 성공하면(리턴값이 0이면)성공함,이건 준비성프로브에서 잘쓰임
	
	그리고 파드가 멀쩡해도 파드를 중지해야할때에(노드업그레이드하거나 파드를 다른노드로 옮겨야할때)
	PodDisruptionBudget를 써서 파드를 제거할 양을 제한해서 순차적으로 제거할수있음
	minAvailable필드로 최소실행갯수를 지정할수있고
	maxUnAvailable로 퇴출할 총갯수나 비율을 제한할수있음
	
	그리고 이건 쿠버네티스의 자발적퇴출에만 적용되고,당연히 서버다운같은거엔 적용안됨
	

3.네임스페이스 사용
	네임스페이스로 리소스사용을 관리할수 있음
	네임스페이스마다 사용량을 제한하고(즉 네임스페이스를 가상클러스터로 사용할수있음) 내부의 격리된 상태를 만들수있음
	그리고 조심해야할건,네임스페이스를 삭제하면 안에있던 모든게 날아감(폴더랑같음)
	
	네임스페이스끼리 통신해야하면 dns에 적힌 이름으로 들어가면됨
	즉 dns에 이름을 추가하면 연결할 서비스를 정확히 지정할수있음,
	보통 기본값은 서비스.네임스페이스.svc.cluster.local임
	
	그리고 앞에서말했던거처럼,네임스페이스에 ResourceQuota를 만들어서 리소스총량을 제한할수있음
	이떄 cpu나 메모리같은거 뿐만아니라 파드의 총갯수같은거도 제한할수있음
	그리고 보통 이렇게쓰고,cpu나 메모리같은거 제한은 문제생길까봐 잘 안하는데
	파드총갯수는 실수로 엄청많이 복제될까봐(레플리카셋 레플리카 숫자 0하나 더넣던가그래서) 그런걸 막으려고 넣는거같음
	
	그리고 limitRange로 기본 리소스 요청과 상한을 정할수있는데,
	이걸 만들어두면 파드들의 리소스 요청상한 기본값을 지정하는거임
	그렇다고 이거만들어뒀다고 너무믿지말고,실수로 빼먹을까봐 넣어두는거니까 명시적으로 적어두는게 좋음
	



4.클러스터비용최적화
	레플리카(디플로이먼트)는 많으면 업데이트를 하거나 파드에 장애가 발생해도 처리하기 좋긴하지만,그 파드 하나하나가 다 리소스니까
	파드는 컨테이너의 조건에 따라(즉발적으로 반응해야하는지,좀 느려도되는지) 최대한 수를 줄이는게 좋음
	그리고 업데이트시 몇초정도 멈춰도 되면 레플리카셋도 한두개정도로 처리가 가능함
	
	그리고 파드의 요구사항도,최대한 현실과 가까워야함
	너무 제한이 높으면 비용이 높게나오고(요구치에따라 할당하니까)
	제한이 낮으면 제대로 실행이 안됨
	
	이건 직접 모니터링을 하면서 체크하는게 좋음,프로메테우스와 그라피나를 쓰던가,아마존같은데선 직접 통계도구 지원하니까 그거쓰던가
	그리고 메모리나 cpu는 실제 최대치보다 약간 높게잡는게 좋긴함 튈수있으니까(500정도쓰면 600)
	
	그리고 이떄 쓸수있는 애드온으로 Vertical pod autiscaler가 있는데,
	이건 디플로이먼트를 관찰하고 실제사용량에 따라 자동으로 파드의 리소스요청을 조정하는데,보통은 수정하진않고 제안만 하는 드라이런모드를 사용함
	1.노드최적화	
		모든 노드는 운영체제가 있어서 이거로 디스크,메모리cpu자원을 소모함
		그래서 노드크기가 작을수록 고정비가 오르는데,그렇다고 무조건 큰노드쓰면 문제생겼을때 일이 크게터짐
		
		그래서 일반적으론 노드가 파드를 5개정도 실행시킬수있게 하고,버려지는리소스를(고정비) 10%이하로 유지시키고
		파드를 10개이상 실행시킬땐 고정비를 5%미만으로 유지해야함
		
	2.스토리지 최적화
		스토리지도 다 비용임
		스토리지는 요청과 상한으로 조정이 불가능함
		그래서 실제 사용하는 처리량과 공간을 기준으로 가장 작고 낮은등급의 iops볼륨을 할당하는게 좋음
	3.더미리소스정리
		안쓰는 리소스들이 계속 쌓이면(잡같은거) 그거자체로 비용이니까 안쓰는게 있으면 정리해야함
		이떈 만든사람의 이름을 anno에 적어서 자기꺼 책임지고 관리하게하면됨
		
		그리고 트래픽이 매우낮거나 없는걸 메트릭을 써서 볼수있는데,이걸기준으로 낮은걸 삭제할수도 있음
		
	4.여유용량 파악
		그렇다고 완전히 꽉꽉채워두면 뭐 하나 문제터지면 그대로 쓰러지니까 어느정도 빈공간을 만들어둬야함
		이떄 확인하는방법은 현재 사용중인 노드중 제일큰걸 터트려보면됨
		그때 문제생기면 좀 더 여유공간을 만들어둬야함

	5.클라우드결제
		클라우드를 3년정액으로 사면 싸긴한데,나중에 증설해야하면 그대로 다 날아가니까,미래의 요구사항을 예측할수있을때 사용하면좋음
		그리고 스폿인스턴스는 필요할때 요구해서 사용하는식임
		근데 이건 비용은 싸긴한데 좀 불안정하니까 비선점형하고 섞어쓰는게 좋음,이떄 비율은 선점형을 66퍼센트 이하로 맞추는게 좋음
		
		그리고 선점형에다가 좀 덜 중요한 파드들을 어피니티로 우선스케줄링 할수있음
		
	6.클러스터 균형 유지
		보통 일반적으로 파드들을 퍼트려놓는데 쿠버네티스는,업데이트등의 이유로 한군데 몰릴수가 있음
		이러면 위험성이 커지니까,디스케줄러같은 도구를 크론잡으로 실행해서 균형을 맞춰주는게 좋음
		디스케줄러는 사용률이 낮은 노드를 찾고 다른노드에서 실행중인 파드를 종료해서 유휴노드로 스케줄되게하거나(즉 노는노드 일시키거나)
		두개이상의 레플리카가 같은노드에서 실행중일때 중복파드를 퇴출시킴
		
	
	










































