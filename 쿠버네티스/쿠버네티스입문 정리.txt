1.소개
	스킵
2.설치
	스킵

3.쿠버네티스로 컨테이너 실행	
1.kubectl
	kubectl의 기본 구조는
		kubectl 커맨드 타입or이름 (플래그)  플래그는 옵션
	임
	만약 kubectl get pod 를 하면 포드 전체를 겟(표시)하고
	   kubectl get abcd를 하면 abcd라는 이름을 가진걸 겟함
	   
	   
	여기서 커맨드에는
		get:명시된 데이터를 받아옴
		run:명시된 이름으로 명시된 이미지의 파드를 생성함
		apply:명시된 위치의 yaml파일을 기반으로 선언적으로 디플로이먼트를 생성해서 파드를 생성함
		scale:파드의 갯수를 늘이거나 줄임
		expose:명시된이름으로 명시된 타입의 서비스를 생성함
		port-forward:명시된 이름의 객체를 뒤에 포트(8080:25500)의 외부포트로 매핑함
		logs -f:명시된이름의 객체의 로그를 수집함
		exec:명시된 이름의 객체에 뒤에 나올 명령을 실행하라고 함
		  (kubectl (-n default) (exec) ((my-pod) (-c my-container)) (-- ls /) )
		          디폴트 네임스페이스에서 실행해라 마이포드를    마이컨테이너에 있는걸    쿠버네티스관련옵션을 전부 종료시키는
			마이컨테이너에 있는 마이포드의 쿠버네티스관련옵션을 전부 종료시키는 명령을 실행해라
		api-resources:사용할수 있는 자원들을 표시함	
			
	2.kubeconfig환경변수
		kubectl의 환경변수는 home/.kube/config에 있음
		여기서 클러스터에서 사용할수 있는 자원을 확인하는건 kubectl api-resources로 확인할수있음
		
		도커 데스크톱으로 쿠버네티스를 쓰면 자동으로 kubeconfig가 생성되고,
		--kubeconfig옵션으로 다른 설정파일을 지정할수 있음
		다중 클러스터에 다른 인증정보로 접근할때 사용함
		
	3.다양한 사용 예
		단순히 명령실행말고,파이프라인으로 현재값의 출력을 다음명령의 입력으로 넣을수도 있고 그런식으로 스크립트식 사용도 가능함
		
			
			
			
			
2.디플로이먼트를 이용해 컨테이너 실행
	앞에서 run으로 생성한건 직접 파드를 하나 추가한거고,보통은 apply로 디플로이먼트를 생성함
	이렇게해야 선언적으로 생성할수있어서 관리하기가 편함
			
3.클러스터 외부에서 클러스터 안 앱에 접근하기
	쿠버네티스 외부에서 쿠버네티스 내부에 접근하려면,직접 접근하면 안되고 쿠버네티스의 서비스를 통해서 접근해야함
	그래서 서비스를 생성해서 그쪽을 통해서 접근해야함
		kubectl expose deployment 이름 --type=NodePort
	하면 노드포트타입의 디플로이먼트를 생성하고(노드포트는 모든 노드의 포트를 할당함,즉 전체를 다받음 )
		kubectl get service로 포트를 확인하고 그 포트로 접속하면됨
		좀더 자세히 보려면
			kubectl describe service 이름
		으로 상세하게 볼수있음
			
			
			
			
			
			
4.쿠버네티스 아키텍쳐
1.쿠버네티스 클러스터 전체 구조
	쿠버네티스 클러스터는 클러스터를 관리하는 마스터와 실제컨테이너를 실행시키는 노드로 구성됨
	마스터에는 etcd(모든 설정등 적는건 여기다들어있음),apiserver(모든건 여기통해서 입출력을 함) 등이 들어있음
	
	노드는 kubelet,kube-porxy,docker등 컴포넌트가 실행되고,실제 사용하는 컨테이너의 대부분은 노드에서 실행됨
	
	구조는
		쿠버네티스에 명령을 주면 리버스프록시로 마스터api에 명령을 전달하고 걔가 노드랑 etc등으로 명령을 전달하고 실행시킴
	
	
	쿠버네티스의 관리용 컴포넌트들도 다 컨테이너로 실행됨
	
2.쿠버네티스의 주요 컴포넌트
	쿠버네티스는 기본적으로 클러스터를 관리함
	클러스터는 단일컴퓨터뿐만 아니라 여러대컴퓨터를 묶음으로 다루는걸 뜻하므로 여러가지의 컴포넌트를 포함함
	
	쿠버네티스의 컴포넌트는 관리에 필수인 마스터컴포넌트,노드컴포넌트와 추가로 붙인 애드온컴포넌트로 나눠짐
	
	1.마스터컴포넌트
		etcd:etcd는 키밸류 저장소임
			분산시스템에서 노드 사이의 상태를 공유하는,데이터베이스 역할을 함
			etcd는 서버 하나당 프로세스 하나만(즉 전체에서 하나밖에없음,클러스터링등으로 같은걸 복사할순있지만)존재함
			
		kube-apiserver:얘는 쿠버네티스의 api를 사용할수 있도록하는 컴포넌트임
						얘는 클러스터로 온 명령이 유효한지 검증하고(문법과 권한)그걸 실행해서 돌려줌
						얘는 수평적으로 확장 가능하니까(어짜피 api서버라서 유일성같은거없음)서버여러대에 여러개설치가능
		
		kube-scheduler:얘는 클러스터 안에 자원 할당이 가능한 노드중 알맞은 노드를 선택해서 파드를 생성하는 컨포넌트
						파드는 여러 요구조건을 받을수있으며,거기에 맞는 노드를 선택해서 생성함
		
		kube-controller-manager:얘는 파드들을 관리하는 컨트롤러를 실행하는 컴포넌트임
								클러스터에서 새로운 컨트롤러를 생성하고 실행할때 컨트롤러 매니저의 큐에 넣어서 실행하는식으로 동작함
		
		cloud-controller-manager:얘는 쿠버네티스의 컨트롤러를 클라우드와 연결해서 관리하는 컴포넌트임,필요해지면보자
		
	2.노드용 컴포넌트
		kubelet:얘는 클러스터 안의 모든 노드에서 실행하는 컴포넌트,파드컨테이너들의 실행을 직접 관리함,파드스펙이라는 조건설정을 전달받아서 실행하고
				컨테이너가 정상적으로 실행되는지 헬스체크를 진행함,단 노드안에 있는 컨테이너라도 쿠버네티스가 안만들었으면 관리하지않음
				(컨테이너안 파드 지웠을때 바로재시작거는게 얘인듯)
				
		kube-proxy:클러스터안에 별도의 가상 네트워크를 설정하고 관리하는 컴포넌트
		
		컨테이너 런타임:실제로 컨테이너를 실행시키는 컴포넌트,대표적으로 도커가 있음
		
	3.애드온
		네트워킹 애드온:클러스터 안에 가상네트워크를 구성해 사용할떄 프록시이외에 네트워킹 애드온을 사용함,얘가 직접 서버구성할때 가장 까다로움
		
		dns애드온:클러스터 안에서 동작하는 dns서버,쿠버네티스 서비스에 dns레코드를 제공함,쿠버네티스 안에 실행된 컨테이너들은 자동으로 dns서버에 등록됨
				주로 coreDNS를 사용함 
				
		대시보드 애드온:kubectl로 명령 주지만,gui로 볼때 대시보드애드온으로 사용할수있음
		
		컨테이너 자원 모니터링:컨테이너들의 자원사용량등을 시계열형식으로 저장해서 볼수있음
		
		클러스터 로깅:클러스터 안 개별 컨테이너의 로그와 구성요소의 로그를 모아서 보는 애드온
		
			
3.오브젝트와 컨트롤러			
	쿠버네티스는 오브젝트와 오브젝트를 관리하는 컨트롤러로 나눠짐
	사용자는 템플릿등으로 쿠버네티스에 자원의 바라는 상태를 정의하고,컨트롤러는 바라는상태와 현재상태가 일치하도록 오브젝트를 생성/삭제함
	오브젝트에는 파드,서비스,볼륨,네임스페이스 등이 있고 컨트롤러에는 레플리카셋,디플로이먼트,스테이트풀셋,데몬셋,잡등이 있음
	
	1.네임스페이스
		네임스페이스는 클러스터 하나를 논리적인 단위로 나눠서 실행하는것,
		이해하자면,컴퓨터 하나에 특정 폴더에 프로그램 바로가기로 싹 몰아두고 이름붙이는느낌임,그래서 그폴더를 전부 실행하거나 실행에 제한걸거나 하는식
		
		네임스페이스를 지정할때는 
			--namespace=붙일이름 
		으로 하나하나붙여도되는데
		
		그냥 디폴트값을 바꿀수도있음
			kubectl config current-context
		로 현재 컨텍스트 이름를 확인하고
			kubectl config set-context 컨텍스트이름 --namespace=붙일이름
		으로 디폴트값을 바꾸면 새로생성한값의 네임스페이스가 바뀜
		
		네임스페이스 전체검색하려면
			kubectl get pod --all-namespaces
		하면됨
		
		바꾼값 다시 디폴트로 바꾸려면 
			--namespace=""
		하면됨
		
	2.템플릿
		쿠버네티스 클러스터의 오브젝트나 컨트롤러가 어떤 상태여야 하는지 적용할떈 yaml형식의 템플릿을 적용함
		템플릿은 들여쓰기로 구조가 바뀌고(파이썬처럼),
		scalars(스트링,넘버),sequences(어레이,리스트),mappings(해시,딕셔너리) 3기초요소로 표현됨
		
		템플릿의 기본형식은
			apiversion:v1
			kind:Pod(생성종류)
			metadata:
			spec:
		로 구성됨
		apiversion은 api버전이고(쿠버네티스버전과 관련된)
		kind는 어떤 오브젝트나 컨트롤러의 작업인지를 명시하고
		metadata는 해당 오브젝트의 이름이나 레이블등을 설정하고
		spec는 파드가 어떤 컨테이너를 가지고 실행하며,실행할때 어떻게 동작해야할지를 명시함
		
		kubectl explain 생성종류  로 현재 생성할거에 무슨 하위필드가 있는지 출력해서 볼수있음
		
		하위필드를 포함해 특정필드를 커맨드라인에서 지정할때는 .metadata.anno이런식으로 .으로 이어가면됨,맨앞에도 .붙이는거에 주의
		필드설명없이 그 아래에 속한 모든필드를 보려면 --recursive옵션을 쓰면됨
		
		
			
			
			
			
5.파드
1.파드개념
	쿠버네티스는 파드라는 단위로 컨테이너를 묶어서 관리하므로,파드는 안에 컨테이너가 여러개로 구성되긴함
	그리고 파드 하나는 ip를 공유하고,내부의 컨테이너들끼리 포트로 구분해가며 데이터를 받음
	그리고 컨테이너 하나에 프로세스를 여러개 실행시킬수도 있지만,그러면 개빡세니까 보통은 컨테이너 하나에 프로세스 하나씩 해서 돌리는거같음
	
2.파드사용하기
	파드를 설정할때는
	yaml에
		api버전
		종류 파드
		메타데이터
			이름:붙일이름
			라벨
				앱:붙일이름
		스펙
			컨테이너들
				-이름:붙일이름
				 이미지:사용할이미지
				 포트
					-컨테이너포트:사용할포트번호
	
	이런식으로 설정함
	저기서 라벨은 오브젝트를 식별하는 레이블
	그리고 상위 바로 밑에 -를 붙이는건 여기서부터 하위필드를 배열로 묶겠다는 뜻임


3.파드 생명 주기
	파드는 생성부터 삭제까지의 과정에 생명주기가 있음
	
		pending:파드를 생성하는 중일때 나옴,이미지를 다운로드한후에 컨테이너를 실행해야하니까 시간 좀 걸림
		running:파드 안 모든 컨테이너가 실행중인 상태,1개이상의 컨테이너가 실행중이거나 시작,재시작상태일수 있음
		succeeded:성공적으로 모든 컨테이너가 실행 종료된상태,정상종료니까 재시작되지않음
		failed:파드 안 모든 컨테이너중 정상적인 실행 종료가 되지 않은 컨테이너가 있는 상태
		unknown:파드의 상태를 확인할수 없는 상태,파드가 있는 노드와 통신할수 없을때 주로 나옴
		
	
	현재 파드 생명주기는 
		kubectl describe pods 파드이름
	을 실행하고 status를 보면 나옴
	거기서 밑에 type가 있는데
	각 타입별 정보는
		initialized:모든 초기화컨테이너가 성공적으로 시작 완료됨
		Ready:파드는 요청을 실행할수 있고 모든 연결된 서비스의 로드밸런싱 풀에 추가되어야 한다는 뜻
		containersready:파드안 모든 컨테이너가 준비상태라는 뜻
		podScheduled:파드가 하나의 노드로 스케줄을 완료했다는 뜻
		unschedulable:스케줄러가 자원의 부족이나 다른 제약등으로 당장 파드를 스케줄 할수 없다는 뜻
	
4.kubelet로 컨테이너진단
	컨테이너가 실행 된 후에는 kubelet가 주기적으로 컨테이너를 진단함,이때 필요한 프로브는 2개가있음
		livenessprobe:컨테이너가 실행됐는지 확인함,이게 실패하면 kubelet는 컨테이너를 종료시키고 재시작 정책에 따라 컨테이너를 재시작함
		readinessprobe:컨테이너가 실행된 후 실제로 서비스 요청에 응답할수 있는지 진단함
					   이 진단이 실패하면 엔드포인트 컨트롤러는 해당 파드에 연결된 모든 서비스를 대상으로 엔드포인트 정보를 제거함
					   즉 서비스 연결이 안될거같으면 거기 연결 못하게 다지워버림
					   
					   
	
	컨테이너 진단할땐 컨테이너가 구현한 핸들러를 kubelet가 호출해서 실행함
	핸들러에는 3종류가 있음
		execaction:컨테이너 안에 지정된 명령을 실행하고 종료코드가 0일때 성공
		tcpsocketaction:컨테이너 안에 지정된 ip,포트로 tcp상태를 확인하고 열려있으면 성공
		httpgetaction:컨테이너 안에 지정된 ip,포트,경로로 http get명령을 보내서 응답코드가 200~400사이면 성공
		
	결과는 success,failure,unknown3개가 있음,언노운은 진단이 실패하서 컨테이너 상태를 알수없을때 나옴
		
	
5.초기화 컨테이너
	초기화 컨테이너는 앱 컨테이너가 실행되기 전 파드를 초기화함
	보안상이유로 앱 컨테이너이미지와 같이 두면 안되는 앱의 소스코드를 별도로 관리할때 유용
	초기화 컨테이너의 특징은
		초기화 컨테이너는 여러개를 구성할수 있음,초기화컨테이너가 여러개있으면 파드템플릿에 명시한 순서되로 초기화컨테이너가 실행됨
		
		초기화 컨테이너의 실행이 실패하면 성공할때까지 재시작함,그래서 무조건 순서대로 실행되니까 절차적으로 실행시켜서,
		쿠버네티스의 선언적이라는 특징에서 벗어날수있음
		
		초기화 컨테이너가 모두 실행 된 후 앱 컨테이너 실행이 시작됨
	
	
	그래서 이런특징을 이용해 파드를 실행할때 앱 컨테이너가 외부의 조건을 만족할때까지 기다렸다가 실행하게 만들수있음
	그리고 초기화 컨테이너는 readinessprobe를 지원하지 않음,파드가 준비되기 전 실행하고 사라지는 컨테이너이기때문
	
	초기화 컨테이너 yaml은
		api버전
		종류 파드
		메타데이터
			이름:붙일이름
			라벨
				앱:붙일이름
		스펙
			init컨테이너들
				-이름:이름
				이미지:이미지
				커맨드:실행하고 할 커맨드를 입력함(몇초 기다려라 이런거)
				
6.파드인프라컨테이너
	쿠버네티스에는 모든 파드에서 항상 실행되는 pause라는 컨테이너가 있음,이걸 파드 인프라 컨테이너 라고 함
	얘는 파드 안 기본 네트워크로 실행되고,프로세스 식별자가 1로 설정되므로 컨테이너의 부모 컨테이너 역할을 함
	파드 안 다른 컨테이너는 pause가 제공하는 네트워크를 공유해서 사용함,그래서 다른컨테이너가 재시작돼도 ip가 유지되지만,
	얘가 재시작되면 ip가 바뀌고 파드 안의 다른 모든 컨테이너도 전부 재시작함
	
	이 인프라를 바꿀수도 있는데 --pod-infra-container-image옵션으로 다른 컨테이너를 인트라컨테이너로 지정할수 있음
	

7.스태틱 파드
	얘들은 api서버를 거치지 않고 kubelet가 직접 실행하는 파드들임
	여기에 추가하고싶으면 --pod-mainfest-path라는 옵션에 지정한 디렉토리에 스태틱파드에 추가할 파드들을 넣어두면 kubelet가 감지해서 실행함
	
	얘들은 kubelet가 직접 관리하면서 이상이 생기면 재시작함
	그리고 kubelet가 실행중인 노드에서만 실행되고,다른노드에서는 실행되지 않음
	그리고 apiserver로 파드를 조회할수는있지만,거기에 명령을 내릴순 없음
	
	보통 스태틱파드는 apiserver나 etcd같은 시스템파드를 실행하는 용도로 많이 사용함 


8.파드에 cpu와 메모리 자원 할당
	만약 노드 하나에 자원 사용량이 많은 파드들이 모여있으면 파드들의 성능이 나빠지고,전체 클러스터의 자원사용 효율도 낮음
	어떤 노드에는 파드가 없어서 cpu메모리가 남고, 어떤 너드는 파드가 많아서 모자라는 그런일이 나타날수 있음
	
	그래서 쿠버네티스에서는 파드에서 자원의 최소치와 최대치를 지정할수 있게 준비해뒀음
	.spec.containers[].resources.limits.cpu
									   .memory
								.requests.cpu
										 .memory
							
	여기서 리미트는 그 파드가 쓸수있는 한도고,리퀘스트는 최소한 그정도는 써야한다는거임
	즉 노드에 배치될떄, 리퀘스트만큼 자원 여유가 있는 노드여야 거기에 스케줄링해서 배치해서 실행되고,
	그런게 없으면 pending로 대기하고 실행하지않다가 자원여유가 생기면 실행함
	
	리미트는 자원의 최대량임,파드가 아무리 많이써도 리미트 이상은 사용할수 없게 막음
	
	노드에 배치할때는 현재사용량을 보는게 아니라 리미트와 리퀘스트만 봄
	리미트가 설정되어있으면 리미트의 총합만큼을 보고 자리가 남으면 거기넣고,리미트가 설정안되면 리퀘스트의 총합을 가지고 넣음
	리미트가 설정안되면 오류가 날수있지만,노드자원을 최대한 많이 사용할수 있다는 장점이 있긴함
	
	그리고 cpu는 코어의 0.1단위로 잘라서 사용할수 있음

9.파드에 환경변수 설정
	컨테이너를 사용할때 장점은,개발환경에서 만든 컨테이너에 환경변수만 바꿔서 실제환경에서 실행해도 그대로 동작한다는 점임
	여기서 환경변수 설정하는방법은 스펙.컨테이너 밑에 env에 넣어주면됨
	
		api버전
		종류 파드
		메타데이터
			이름:붙일이름
			라벨
				앱:붙일이름
		스펙
			컨테이너들
				-이름:붙일이름
				 이미지:사용할이미지
				 포트
					-컨테이너포트:사용할포트번호
				env:
					-이름:이름1
					 값:값1
					-이름:이름2
					 valuefrom:
						필드ref:
						필드path:spec.nodeName이나 metadata.name,status.podIP등등 참조값 전부가능
					-이름:이름3
					 valuefrom:
						resourcefieldref:
							컨테이너이름:가져올컨테이너이름
							resource:requests.cpu,limits.cpu등등 
	
	이런식으로 가져오거나 설정할수있음
							
	이름은 환경변수의 이름이고(즉 저기에 적힌거:값 이런식으로 그대로 바로 적용됨 사용자정의아니면,즉 cpu사용량같은거 적어두면 바로적용됨)
	값(value)은 직접 적은 상수값
	valuefrom은 값을 어디서 참조하는거
	fieldref는 파드의 현재 설정 내용을 값으로 설정한다는 선언(현재파드내에서 가져온다는거)
	fieldpath는 어디서 값을 가져올것인지,즉 값을 참조하려는 항목의 위치를 지정
	resourcefieldref는 컨테이너에 cpu메모리 사용량을 얼마나 할당했는지에 관한 정보를 가져옴
	containername은 환경변수 설정을 가져올 컨테이너의 이름
	resource는 어떤 자원의 정보를 가져올지 설정


10.파드에 환경설정 내용 적용
	파드는 환경설정 내용을 yaml하나에 모두 작성한 후 적용해야함
	적용할떄는
		kubectl apply -f pod-all.yame
	을 실행하면됨
	
	확인할땐 
		kubectl exec -it kubernetes-simple-pod sh
	를 실행해서 컨테이너 안에 접속하고
		env
	치면 나옴
	
	
11.파드 구성 패턴
	1.사이드카패턴
		원래 사용하던 컨테이너의 기능을 확장하거나 강화하는 용도의 컨테이너를 추가하는것
		기본 컨테이너는 원래기능에만 충실하게 구성하고,나머지 공통부가기능들은 사이드카 컨테이너를 추가해서 사용하는것
		로그수집 컨테이너처럼 파일긁어서 보내는 역할만 하는 컨테이너가 예,이건 어딜붙여도 파일저장만 하면 똑같이쓸수있음
	2.앰배서더 패턴
		얘는 파드안에 프록시역할을 하는 컨테이너를 추가하는 패턴
		즉 파드 안에서 외부서버에 접근할때 내부프록시에 접근하게 하고,연결은 프록시에서 알아서 처리함
		이러면 파드의 트래픽을 더 세밀하게 제어할수 있음
	3.어댑터 패턴
		어댑터 패턴은 파드 외부로 노출되는 정보를 표준화하는 어댑터 컨테이너를 사용한다는 뜻임
		즉 파드 내부에서 정보를 어댑터로 보내고,저기서 정보를 취합해서 중앙모니터링에 보내면 거기서 모니터링하는데 이용하는 그런식
		



















