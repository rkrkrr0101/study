1.컨테이너인프라환경
	별거없음 스킵
	뭐 마이크로서비스 아키텍쳐정도는 나중에 책 한권사든가하자  
	
	
2.설치
	버추얼박스 베이그런트 푸티 수퍼푸티 설치
	
	베이그런트 명령
		vagrant init:기본파일생성(vagrantfile 생성)
		vagrant up:vagrantfile를 읽고 프로비저닝(서버 설정하고 파일넣어서 가동시키는것) 실행
		vagrant halt:가상머신 종료
		vagrant destroy:가상머신 삭제
		vagrant ssh:가상머신에 ssh로 접속,만약 여러개일경우 이름을 뒤에 적어야함
		vagrant provision:설정변경시 그걸 적용(켜진상태에서 바꾸는거)
		
	루비작성할때 vb.customise 같은거 뒤에 뛰워야 매개변수로 인식안함(vb.customise[...]이러면안되고 vb.customise [...]이래야함)
	
	
3.쿠버네티스
1.쿠버네티스 이해
	쿠버네티스는 컨테이너 관리형 도구,주로 도커를 올려서 사용함
	보통은 관리형 쿠버네티스(구글아마존같은)를 사용함
	이책은 직접 테스트용도니 직접설치해서 베이그란트로 가상머신돌려서 설치해서 사용
	
	쿠버네티스 안에서 서치야 kubectl get 쓰면되고(여기서 뒤에 --all-namespaces붙이면 디폴트말고 나머지서치한다는거)
	
	마스터노드는 api서버,etcd,컨트롤러매니저,스케줄러로 구성되어있고,외부통신(우리가 인풋할거)로 kubectl이 있음
	워커노드는 kubelet,컨테이너런타임,파드로 구성되어있음,
	kubelet는 파드스펙을 받아서 컨테이너 런타임한테 전달하고,제대로생성됐는지를 모니터링함
	컨테이너런타임은 실제로 컨테이너를 생성(실행)시키는애
	파드는 컨테이너런타임이 생성시킨애
	
	그외에 네트워크플러그인,dns로 구성됨(이건선택사항)
	
	우리가 파드에 접속하면,kubeproxy로 일단 접근하게되는데,그럼 프록시가 서비스에 전달하고 서비스는 파드주소로 전달하는식
	
	쿠버네티스는 선언형이기때문에,우리는 이렇게 해주세요 하고 발주만내고,거기맞추는건 쿠버네티스가 알아서함
	그리고 쿠버네티스 안에서도,마스터노드는 생성감시만 하고,
	직접생성은 밑에단에서 계속 논리적객체가(디플로이먼트같은) 생성되면서 밑단으로 하청주면서 컨테이너런타임까지 내려가서 파드까지(컨테이너까지)생성되면 완성임
	
	즉,선언한 형태와 일치하도록,api서버(etcd)에 있는 값과 계속 비교하면서 거기에 맞게 맞춰나감
	
	그리고 kubectl은 실제로,마스터노드가 아닌 클러스터 외부에서도 클러스터 정보만 있으면 사용할수있음
	kubelet는,여기 문제가 생기면 파드가 정상적으로 관리되지않음,만약 삭제를 날려도 얘에 문제가 생기면 삭제명령이 전달이안됨(모든명령이 그럼 중간이 막히니)
	kubeproxy에 문제가 생기면,파드는 정상적으로 동작하는데,파드에 접속을 할수없음(서비스에 접근이안되니까)
	
2.쿠버네티스 사용법
	파드를 생성할떈 create,run,apply3개가 있는데,create와 run보단,yaml을 apply하는식으로 apply가 주로쓰임
	쿠버네티스는 선언형이라서,복구를 위해선 파일이 남아있는게 편하기때문(그리고 크리에이트는 파드는생성못하고,디플로이먼트를 생성해야됨)
	
	쿠버네티스의 오브젝트는 
		파드:쿠버네티스에서 관리하는최소단위,전체가 1개의아이피,1개이상의 컨테이너로 구성
		네임스페이스:쿠버네티스에서 오브젝트들을 관리하는 폴더같은형식,일반적으론 자기가 속한구역만 접근할수있고,필요하면 외부접근도 가능
		볼륨:컨테이너나 파드에서 사용하는 디스크용량,이거도 파드날아갈때 같이날아가는형태랑,계속 보존되는 형태 2개가있음
		서비스:파드들을 로드밸런싱하고,파드들이 어딜가도 상관없이 연결가능하게 테이블을 관리하는오브젝트,여기에 명령을보내면 얘가 적절한파드로 명령을보냄
		레플리카셋:파드들을 묶어서 지정된갯수만큼 실행시키는걸 보장하는 오브젝트
		디플로이먼트:레플리카셋에서 롤업데이트를 추가한것
	디플로이먼트도 보통 yaml로 선언하고 apply로 적용시킴,사실 거의모든걸 다 이렇게함
	
	파드는 만약에 문제가 생겨서 종료되면,자동으로 다른 노드나 같은노드에 재생성됨(디플로이먼트로 생성했을때)
	이때 삭제하려면 디플로이먼트 레플리카 수를 줄이거나,디플로이먼트를 삭제함
	
	만약 특정노드에 파드생성을 막으려면 cordon으로 막으면되고(테인트랑 똑같은데,테인트는 톨러레이션있는걸 통과시킨다는거만 다름,cordon이 일괄방어)
	특정노드의 파드를 전부 삭제하고 cordon을 씌우려면 drain을 하면됨
	드레인은 데몬셋을 지울수없으므로,뒤에 --ignore-daemonsets로 데몬셋을 무시하게해야함
	cordon을 취소하려면 uncordon하면됨
	
	파드를 업데이트할땐 apply로 하고,뒤에 --record를 붙이면 배보정보를 기록하는데,
	이걸가지고 롤백할수있음(언두)
	
	버전은 kubectl rollout history로 볼수있고,
	여기있는 숫자를 
		kubectl rollout undo 오브젝트 오브젝트명 --to-revision=버전
	으로 되돌릴수있음,그러면 현재오브젝트의 파드들이 전부삭제되고,그버전으로 다시생성됨
	
		


3.서비스
	서비스는 파드들에 통신하는 방식임
	직접 통신을 하면,파드들의 위치가 바뀔때마다 ip값이 바뀌므로,서비스를 거쳐서 서비스에있는 테이블로 파드에 접근함
	
	가장 간단한 방식은 노드포트임
	이건 모든 노드에 특정 포트번호를 매핑해서,
	이포트번호로 오는 모든 요청을 노드포트로 전달하고(서비스로전달)
	서비스가 부하가 덜걸린 파드(서비스셀렉터에 적힌 레이블을 가진 파드)로 전달하는식
	
	서비스의 타입을 정할떈,yaml에 type:NodePort 이런식으로 적으면됨
	
	그리고 간단히 서비스 만들떈,expose로 yaml안만들고 만들수도 있긴한데,보통 추천하진않는듯
	이땐 노드포트번호가 30000~32767사이에서 랜덤하게 지정됨
	
	
	인그레스는 노드포트가 여러개있을때,들어온 명령별로 뒤에 뭐붙었나를 확인하고,그거에따라 다르게 배분하는애임
	만약 naver.com이 들어오면 1번서비스,naver.com/ip가 들어오면 2번서비스 이런식임
	인그레스 접근순서:사용자요청-노드에전달-인그레스에전달-서비스에전달-파드에전달-사용자에게전달
	인그레스는 고유한 주소를 제공해 사용목적에 따른 다른응답을 제공하고,트래픽에 대한 l4/l7로드밸런싱과 보안인증서를 처리할수있음
	
	인그레스는 파드와 직접 통신할수 없어서,중간에 무조건 노드포트나 로드밸런서를 끼우고 통신해야함
	
	
	로드밸런서는,노드에 접근하지않고,자기가 직접 부하를 관리하면서 파드에 다이렉트로 명령을 보내는방식임
	사용자는 로드밸런서에만 접근하면,노드의 번호를 몰라도 원하는 파드에 접근할수있음
	로드밸런서는 보통 클라우드에선 그 서비스업체거를 쓰면되는데,온프레미스에선 metallb같은걸 깔아야함
	
	로드밸런서를 쓰면 서비스에 외부와 통신할수있는 ip가(external-ip)부여되고,그거로 외부와통신하면 자동으로 부하도 분산됨
	
	hpa는 자동으로 부하에따라서 파드수를 조절하는것(오토스케일러)
	hpa를 쓰려면 디플로이먼트들의 리소스필요량과 리미트가 설정되어있어야함(안써도 기본적으로 적어둬야하지만)
	그리고 이때 이 정보들을 수집할 메트릭서버가 있어야함(프로메테우스같은)
	
	그리고 hpa의 부하는,전체파드의 부하를 총합한후 나눈거기때문에,한두개가 넘는다고 바로 생성하진않음
	즉,부하 5를넘으면 분리한다면, 만약 29일경우 29/5 한뒤에 올림을 함
	
	


4.쿠버네티스 오브젝트
	데몬셋은 각 노드에 하나씩 배포해야할때 사용함
	보통 로그수집이나,네트워크 통신 이런걸쓸때 사용함
	데몬셋을 사용하면 모든 노드에 하나씩 배포해야한다는걸 신경안써도됨
	
	컨피그맵은 설정정보를 담아둔 오브젝트임
	보통 기본설정을 여기다가 적어두고 이걸 디플로이먼트같은 다른오브젝트에서 받아서 쓰는식으로 사용함
	유사한거로 시크릿이 있는데,이건 컨피그맵이랑 구조는똑같은데,좀더 민감한 정보를 넣어둠(비밀번호같은)
	
	pv와pvc는 퍼시스턴트볼륨과 퍼시스턴트볼륨클레임으로, 만약 파드에서 생성한 내용을 기록하고 보관하거나,모든파드가 같은값을 읽어야할때 사용함
	pv에는 정적과 동적이 있는데,정적은 미리 일정크기로 볼륨을 생성해 두는거고,동적은 pvc요청이 들어오면 그크기에맞춰 생성하는것
	이떄도,원래 있던 공간을 묶어두고,pv에 바운드시키는느낌
	
	pvc는 볼륨을 요청하는것,그리고 pvc에 적힌 스토리지는,동적볼륨이 아니라면 대충 레이블같은 그근처크기를 달라는느낌임
	동적볼륨일경우 요청하는순간에 볼륨을 생성해서 바운드함,이땐 StorageClass를 사용하면됨
	만약 같은pvc를 파드들에 동시에 사용하면,모든 파드들은 같은 볼륨을 보게됨
	이때는 디플로이먼트에서 볼륨마운트를 하고,볼륨에 pvc로 클레임이름을 연결해주면됨
	
	그리고 pv와 pvc를 안쓰고,한컴퓨터에서 처리할거면 그냥 디플로이먼트에서 볼륨을 마운트하고 그볼륨을 사용하는식으로도 쓸수있긴함
	
	스테이트풀셋은 파드를 순서대로 만들필요가 있을때(db같은)사용함
	이걸 사용하면 각 파드가 순서대로 생성되어서 고정된이름,볼륨,설정을 가질수있고,volumeClaimTemplates로 자동으로 pvc를 생성할수도있음
	이건 전번호가 러닝에 들어가야 다음거가 시작됨,삭제할때도 역순으로 마지막거부터 삭제하고 하나씩 삭제함
	
	스테이트풀셋은 효율적인 오브젝트는 아니므로,어쩔수없이 필요할때만 사용해야함(쿠버네티스는 상태없는 걍 막다뤄도되는걸 좋아함)
	
	
	
	
	
	
	
	
	
	
	
	
	
	
4.도커	
1.도커를 알아야하는이유
	사실 도커몰라도 대충 이미지에 추가만 할수있으면 쿠버네티스를 돌릴수있음,어지간한건 이미지가 다있음
	그래도 트러블슈팅하려면 알고는있어야함
	
	쿠버네티스와 도커와의 관계는,도커는 파드가 관리하는 컨테이너를 구성함
	파드는 쿠버네티스로부터 ip를 받아 컨테이너가 외부와 통신할수있게 해주고,
	컨테이너가 정상적으로 동작하는지 헬스체크하고,네트워크나 저장공간을 공유하게 만듬
	그래서 컨테이너들은 마치 하나의 호스트에 존재하는 것처럼 작동할수있음(그렇다고 기본적으로 얘들이 공용공간만 아니면 충돌하진않음,각컨테이너가 하나의 머신임)
	이런 컨테이너들을 논리적으로 관리하는게 쿠버네티스
	
	보통 이런 컨테이너들을 생성하고,관리할떈 도커를 사용함
	
	
2.도커로 컨테이너 다루기
	컨테이너와 컨테이너 이미지는,이미지는 그자체론 사용할수없고 이게 도커같은 cri로 불러들여야 사용할수있음
	즉 보조기억장치에서 주기억장치로 넘어가야 동작하는거랑비슷함
	그래서 컨테이너를 삭제할땐,컨테이너만 끄는게 아니라 이미지와 컨테이너를 둘다 삭제해야 용량이 온전히 복원됨
	
	컨테이너 이미지들은 레지스트리에 모여있음,디폴트값은 도커허브
		docker search 이미지명
	으로 검색할수있음
	
	검색한 이미지를 다운로드받으려면
		docker pull 이미지명
	으로 다운받을수있음
	
	이러면 레이어들을 받는데,이미지는 사실 그자체로 파일이 아닌,레이어들의 묶음을 나타낸 값임
	즉 이미지는 레이어들의 위치값을 묶어둔 차트라고 볼수있음
	그래서 이미지를 여러개받았을떄,레이어가 겹치면 그건 다운받지않고 있는걸 가져다가 써서 용량소모를 줄임
	
	그리고 이미지 뒤에 이미지명:latest처럼 태그를 붙일수있는데,이 태그로 자기가 무슨버전 받을건지를 정할수있고,
	기본값은 lasest인데 이건 무조건 버전을 명시해서 받아야함,아니면 yaml에 기록도 안되고 나중에 파드의 동일성도 깨짐(무조건 마지막거를 받으니까 저러면)
	
	
	컨테이너를 생성할땐
		docker run -d --restart always 이미지명
	이런식으로 하면되는데
	런은 생성하라는거고
	-d는 백그라운드로 구동하라는소리임
	--restart always는 컨테이너가 정상적으로 종료되지않았을때 재시작정책에 관한거임,always는 비정상종료시 재시작,도커시작시 시작함
	이거외에도 no는 재시작하지않음(기본값) unless-stopped는 재시작은 하는데 도커시작시엔 정지하지 않은거만 시작
	
	이러면 16진수 문자열이 나오는데 이게 컨테이너의 id값임
	
	컨테이너를 확인할땐
		docker ps
	로 전체를 확인할수있고
		docker ps -f id=id값
	으로 검색할수있음,이떄 id값은 like라서 앞자리만 적어도 검색함
	이거말고
		docker ps -f name=이미지명
	으로 이미지로 검색할수도있음
	
	이렇게 만들고나서 접근할땐 curl로 접근하면되는데
		curl 127.0.0.1
	로 접근하면 접근이 안되는데,그이유는 호스트네트워크랑 도커랑 연결이 안되어있기때문,그래서 로컬호스트의 80번포트엔 가는데 거긴아무것도없음
	그래서 컨테이너를 생성할때 80번포트를 호스트의 몇번포트에 바인딩할건지를 명시해줘야함
		docker run -d -p 8080:80 --name 이름 --restart always 이미지명
	이런식으로 -p 호스트포트:컨테이너포트 로 매핑을 해서 호스트포트로 받아야함
	
	
	컨테이너의 내부 파일을 변경할땐,간단히
		docker cp 호스트경로 컨테이너이름:컨테이너내부경로
	이런식으로 넣을수도 있긴하지만,간단히 한번넣고말거나 로그꺼내볼때쓰고
	
	여러번 사용해야 한다면
		호스트의 디렉토리와 컨테이너 내부를 연결하는 바인드 마운트
		호스트의 디렉토리를 볼륨으로 만들어서 볼륨을 컨테이너내부와 연결하는 볼륨
	을 사용함
	
	바인드 마운트는 디렉토리와 컨테이너 내부를 연결하는데,
	그러면 어느 한쪽에서 파일을 변경하면 그게 양쪽에 동시에 반영됨(사실 컨테이너내부는 전부 바로가기라고 보면됨)
	바인드마운트의 단점은,컨테이너 내부의 그위치에 있는 파일 전부가 삭제되고,디렉토리로 덮어쓰여짐
	
	볼륨은 디렉토리를 볼륨으로 만들어서 그걸 컨테이너에 연결하는데,
	이러면 다른 호스트에서도 볼륨지정을 하면 이 볼륨을 같이쓸수있음(다른컴퓨터에서도 사용가능)
	그리고 볼륨은 파일명이 중복되지않으면 사라지지않고,겹친거만 컨테이너 우선으로 덮어쓰여짐
	
	둘중에는 볼륨이 더 많이쓰이는듯
	
	바인드마운트의 사용방법은
		docker run -d -p 8080:80 -v 로컬경로:컨테이너경로 --restart always --name 이름 이미지명
	으로 바인드할수있음
	이러면 호스트에 있는거로 컨테이너경로에 있는폴더속을 포맷하고 호스트로 덮어씀
	
	
												(cp는 리눅스에서 카피명령어)
	
	볼륨을 사용할땐
		docker volume create 볼륨명
	하면 볼륨이 생성되는데,경로는 /var/lib/docker/volumes/볼륨명/_data로 자동으로 지정됨
	볼륨의 확인은 
		docker volume inspect 볼륨명
	으로 할수있음
	
	이걸 연결할땐 
		docker run -d -v 볼륨명:컨테이너경로 -p 호스트포트:컨테이너포트 --restart always --name 이름 이미지명
	으로 그냥 볼륨명만 써서 연결할수있음
	이러면 컨테이너와 볼륨의 파일들이 이름만 안겹치면 다 살아있음
	그리고 파일을 넣을땐 cp로 /var/lib/docker/volumes/볼륨명/_data에 넣어주면 자동으로 동기화됨
	
	사용중인 볼륨을 조회할땐
		docker volume ls
	볼륨을 삭제할떈
		docker volume rm
	
	
	
	사용하지 않는 컨테이너를 삭제할땐,컨테이너를 정지하고 컨테이너를 삭제하고 이미지를 삭제해야함
	
	컨테이너를 
		docker ps -f ancestor=이미지명
	으로 검색하고(ancestor는 생성할때의 이미지명)
	컨테이너를 정지할땐
		docker stop 컨테이너이름 or id값
	으로 정지할수있음
	만약 특정 이미지의 컨테이너를 전부정지하려면
		 docker stop $(docker ps -q -f ancestor=이미지명)
	으로 정지할수있음(-q는 quite로 검색된걸 id값만 출력)
	
	그리고 컨테이너를 재시작하려면
		docker start 컨테이너명 하면되고
	컨테이너를 삭제하려면 
		docker rm 컨테이너명 
	하면됨,이것도 위와같이 $를 쓸수있음
	
	그리고 이미지를 삭제할땐
		docker rmi 이미지명
	하거나
		docker rmi $(docker images -q nginx)
	로 특정이미지의 모든태그를 삭제할수도있음
	
	
	
	
3.컨테이너 이미지 만들기
	기본적으로 빌드는,컨테이너 내부에서 자동으로 빌드하고 그걸 사용하는식과,밖에서 빌드하고 넣어주는식이 있음
	기본은 밖에서 빌드하고 넣어주는건데
		일단 mvnw(메이븐)으로 빌드한다음에
		도커파일에 
		실행이미지를 임포트한다음
		빌드한걸 호스트에서 카피해가는 명령어를 넣고 
		이미지를 실행시킬때 그곳을 실행시키는식으로 명령어를 짜서 
		이미지를 만들면됨
	그리고 도커를 런해서 컨테이너를 실행시키고 포트를 부여하고 거기 접근하면됨
	
	이때 도커파일에 따라 해시값이 부여되므로,도커파일에 약간의 변화가있을떄만 해시값이 바뀜(image id)
	
	이때 실행이미지를 실행전용이미지로 사용하면 용량사용을 확 줄일수 있음
	자바의경우 openjdk가 컴파일랑 실행 둘다 들어간거고,distroless가 실행만 들어간것
	
	이때 그냥 openjdk를 사용하고,git에서 소스를 받아서 컨테이너내에서 컴파일 하는식으로도 할수있음
	이러면 따로 뭐 할필요없이 ci/cd가 되는것
	이러려면
		openjdk를 임포트하고
		run git clone로 소스코드를 받아오고
		workdir로 소스코드있는데로 이동한다음에
		run mvnw로 메이븐으로 컴파일하고
		실행할곳으로 파일을 옮기고
		이미지가 실행되면 그곳을 실행
	하면됨
	
	이건 문제가,원터치로 되긴하는데 용량이 그냥openjdk쓰는거보다 많이들어감,openjdk+컴파일중간파일들이 섞여있기떄문
	
	그래서 사용하는게 멀티 스테이지 빌드임,이건 도커 17.06부터 지원함
		이건 스테이지 2개를 만들고,
		생산전용스테이지에서 openjdk임포트를 한 다음에 컴파일하고 생산하고,
		생산파일을 실행용으로 옮기고
		실행용에서는 실행전용이미지를 임포트한다음
		실행용에서  실행할위치와 명령어를 정하고 
		명령이 들어오면 그곳을 실행
	하는식임
	이러면 댕글링이미지라는 생산전용이미지가 쌓이므로,dangling=true로 이미지명이 없는걸 주기적으로 지워주면됨
	
	
4.쿠버네티스에서 직접만든 컨테이너 사용
	쿠버네티스에서 직접만든 컨테이너를 사용할땐,모든 노드에 이미지를 넣어줄게 아니면,
	도커허브에 이미지를 올리거나,자기레지스트리에 이미지를 올려서
	그걸 받아야함
	클라우드같은경우 보통 이미지저장소가 있고 그거쓰면되고,
	개인환경일경우 로컬로 도커레지스트리같은거 쓰면됨
	
	도커레지스트리같은거의 경우,인증서를 가지고있어야하고
	컨테이너로 구동되기때문에,볼륨을 연결해서 컨테이너가 사라질때마다 내부저장소들이 사라지지않게해야함
	그렇게 설정하고나서 레지스트리에 자기 이미지를 등록할땐
	이미지의 이름을
		ip주소나 url:포트번호/이미지이름:태그
	이런식으로 한다음에
		docker push 이미지이름
	하면 ip주소의 포트번호로 이미지를 던지고 레지스트리가 그 이미지를 받아서 저장함
	
	그리고 쿠버네티스에선 이미지를 이미지이름(ip주소와 포트가 들어간이름)으로 받아서 디플로이먼트생성하면됨
	
	
	
	
	
	
5.젠킨스
	
	
	
	
	
	
	
	