1.컨테이너인프라환경
	별거없음 스킵
	뭐 마이크로서비스 아키텍쳐정도는 나중에 책 한권사든가하자  
	
	
2.설치
	버추얼박스 베이그런트 푸티 수퍼푸티 설치
	
	베이그런트 명령
		vagrant init:기본파일생성(vagrantfile 생성)
		vagrant up:vagrantfile를 읽고 프로비저닝(서버 설정하고 파일넣어서 가동시키는것) 실행
		vagrant halt:가상머신 종료
		vagrant destroy:가상머신 삭제
		vagrant ssh:가상머신에 ssh로 접속,만약 여러개일경우 이름을 뒤에 적어야함
		vagrant provision:설정변경시 그걸 적용(켜진상태에서 바꾸는거)
		
	루비작성할때 vb.customise 같은거 뒤에 뛰워야 매개변수로 인식안함(vb.customise[...]이러면안되고 vb.customise [...]이래야함)
	
	
3.쿠버네티스
1.쿠버네티스 이해
	쿠버네티스는 컨테이너 관리형 도구,주로 도커를 올려서 사용함
	보통은 관리형 쿠버네티스(구글아마존같은)를 사용함
	이책은 직접 테스트용도니 직접설치해서 베이그란트로 가상머신돌려서 설치해서 사용
	
	쿠버네티스 안에서 서치야 kubectl get 쓰면되고(여기서 뒤에 --all-namespaces붙이면 디폴트말고 나머지서치한다는거)
	
	마스터노드는 api서버,etcd,컨트롤러매니저,스케줄러로 구성되어있고,외부통신(우리가 인풋할거)로 kubectl이 있음
	워커노드는 kubelet,컨테이너런타임,파드로 구성되어있음,
	kubelet는 파드스펙을 받아서 컨테이너 런타임한테 전달하고,제대로생성됐는지를 모니터링함
	컨테이너런타임은 실제로 컨테이너를 생성(실행)시키는애
	파드는 컨테이너런타임이 생성시킨애
	
	그외에 네트워크플러그인,dns로 구성됨(이건선택사항)
	
	우리가 파드에 접속하면,kubeproxy로 일단 접근하게되는데,그럼 프록시가 서비스에 전달하고 서비스는 파드주소로 전달하는식
	
	쿠버네티스는 선언형이기때문에,우리는 이렇게 해주세요 하고 발주만내고,거기맞추는건 쿠버네티스가 알아서함
	그리고 쿠버네티스 안에서도,마스터노드는 생성감시만 하고,
	직접생성은 밑에단에서 계속 논리적객체가(디플로이먼트같은) 생성되면서 밑단으로 하청주면서 컨테이너런타임까지 내려가서 파드까지(컨테이너까지)생성되면 완성임
	
	즉,선언한 형태와 일치하도록,api서버(etcd)에 있는 값과 계속 비교하면서 거기에 맞게 맞춰나감
	
	그리고 kubectl은 실제로,마스터노드가 아닌 클러스터 외부에서도 클러스터 정보만 있으면 사용할수있음
	kubelet는,여기 문제가 생기면 파드가 정상적으로 관리되지않음,만약 삭제를 날려도 얘에 문제가 생기면 삭제명령이 전달이안됨(모든명령이 그럼 중간이 막히니)
	kubeproxy에 문제가 생기면,파드는 정상적으로 동작하는데,파드에 접속을 할수없음(서비스에 접근이안되니까)
	
2.쿠버네티스 사용법
	파드를 생성할떈 create,run,apply3개가 있는데,create와 run보단,yaml을 apply하는식으로 apply가 주로쓰임
	쿠버네티스는 선언형이라서,복구를 위해선 파일이 남아있는게 편하기때문(그리고 크리에이트는 파드는생성못하고,디플로이먼트를 생성해야됨)
	
	쿠버네티스의 오브젝트는 
		파드:쿠버네티스에서 관리하는최소단위,전체가 1개의아이피,1개이상의 컨테이너로 구성
		네임스페이스:쿠버네티스에서 오브젝트들을 관리하는 폴더같은형식,일반적으론 자기가 속한구역만 접근할수있고,필요하면 외부접근도 가능
		볼륨:컨테이너나 파드에서 사용하는 디스크용량,이거도 파드날아갈때 같이날아가는형태랑,계속 보존되는 형태 2개가있음
		서비스:파드들을 로드밸런싱하고,파드들이 어딜가도 상관없이 연결가능하게 테이블을 관리하는오브젝트,여기에 명령을보내면 얘가 적절한파드로 명령을보냄
		레플리카셋:파드들을 묶어서 지정된갯수만큼 실행시키는걸 보장하는 오브젝트
		디플로이먼트:레플리카셋에서 롤업데이트를 추가한것
	디플로이먼트도 보통 yaml로 선언하고 apply로 적용시킴,사실 거의모든걸 다 이렇게함
	
	파드는 만약에 문제가 생겨서 종료되면,자동으로 다른 노드나 같은노드에 재생성됨(디플로이먼트로 생성했을때)
	이때 삭제하려면 디플로이먼트 레플리카 수를 줄이거나,디플로이먼트를 삭제함
	
	만약 특정노드에 파드생성을 막으려면 cordon으로 막으면되고(테인트랑 똑같은데,테인트는 톨러레이션있는걸 통과시킨다는거만 다름,cordon이 일괄방어)
	특정노드의 파드를 전부 삭제하고 cordon을 씌우려면 drain을 하면됨
	드레인은 데몬셋을 지울수없으므로,뒤에 --ignore-daemonsets로 데몬셋을 무시하게해야함
	cordon을 취소하려면 uncordon하면됨
	
	파드를 업데이트할땐 apply로 하고,뒤에 --record를 붙이면 배보정보를 기록하는데,
	이걸가지고 롤백할수있음(언두)
	
	버전은 kubectl rollout history로 볼수있고,
	여기있는 숫자를 
		kubectl rollout undo 오브젝트 오브젝트명 --to-revision=버전
	으로 되돌릴수있음,그러면 현재오브젝트의 파드들이 전부삭제되고,그버전으로 다시생성됨
	
		
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	