1.머신러닝
	스킵
2.kubeflow
1.설치
	스킵
2.쿠브플로우 컴포넌트
	쿠브플로우의 컴포넌트로는,대쉬보드,쥬피터노트북서버,페어링,카티브,파이프라인,ml모델트레이닝,서빙모델,메타데이터가 있음
	
	대쉬보드는 각 컴포넌트에 접근할수있는 게이트웨이임,쿠버네티스 게이트웨이를 통해서 쿠브플로우의 컴포넌트들의 엔드포인트에 접근할수있음
	여기서 접근할수있는 컴포넌트에는
		주피터노트북서버
		카티브
		파이프라인
		아티팩트 스토어
		매니지 컨트리뷰터
	가 있음,단 매니지컨트리뷰터는 현재 사용자가 현재 네임스페이스의 소유자일때만 노출됨
	
	대시보드에 접근은 그냥 서비스 ip포트보고 접근하면됨
	
	노트북서버는 쿠버네티스위에서 실행되는 쥬피터노트북임,쿠버네티스에서 리소스를 할당받아서,별로 뭐할필요없이 바로 사용할수있음
	
	노트북을 생성할땐,대쉬보드에서 뉴서버를 누르고,노트북이름과 네임스페이스를 적으면(기본값은 현재네임스페이스)됨
	그리고 노트북에서 사용할 도커이미지를 선택하면됨
	여기선 스탠다드이미지(텐서플로,kubectl,gcp관련,쿠브플로우라이브러리포함)와 커스텀이미지중에 선택하면됨
	그리고 cpu와 메모리를 입력하고(k8s 메모리쿼터)
	워크스페이스 볼륨,데이터볼륨을 입력하면됨(pv),이미 만들어진 pv사용도 가능하고,신규볼륨생성도 가능함
	그리고 옵션으로 환경변수나 시크릿같은 값을 별도로 정의할수있고,gpu할당도 할수있음
	
	쥬피터노트북은 k8s의 리소스를 사용할수있음,그래서 노트북터미널창에서 k get pod같은거 치면 들어감(물론 자기네임스페이스만)
	여기선 파드,디플로이먼트,서비스,잡,tf잡,파이토치잡을 사용할수있음
	
	기본적으로 노트북은 스테이트풀셋으로 관리됨
	
	페어링은 쿠브플로우가 설치된 환경에서 쉽게 ml모델을 학습/배포할수있는 패키지임
	얘가 하는일은
		작성한 모델코드를 도커라이징
		클라우드에서 트레이닝잡을 실행시킬수있는 api지원
		고차원 api지원으로 인해 학습된모델배포를 쉽게함
		
	페어링은 노트북,파이썬함수,파이썬파일을 도커이미지로 빌드하고,
	이미지가 빌드되면 설정한 도커레지스트리에 푸시하고,
	푸시가 완료되면 설정한 배포리소스타입에 따라 job,tfjob,kfserving등의 리소스로 변환해서 api서버에 요청함
	이과정을 나누면
		preprocessor:작성코드를 도커이미지에 넣을수있게 패키지화
		builder:패키지파일을 도커이미지화
		deployer:생성된 이미지를 클러스터에 배포
	로 볼수있음
	
	페어링은 파이썬 3.6이상에서 설치할수있음
	페어링은 도커레지스트리정보와 쿠브플로우클러스터에 접근할수있는 권한이 필요함(클러스터는 쿠브플로우로깔면 알아서가져오고,레지스트리는 넣어줘야함,검색)
	
	페어링패키지의 핵심은 fairing.config임
		fairing.config.set_builder('append',베이스이미지,레지스트리,푸시=true)//빌더설정
		fairing.config.set_deployer('job')//디플로이어설정
		fairing.config.fn(train)//동작함수설정(모델실행함수)
	이렇게 하면,빌더에있는 베이스이미지를 기반으로,모델실행함수를 실행하는 도커이미지를 생성하고,
	그걸 레지스트리에 푸시함
	그리고 그걸로 잡을 쿠버네티스클러스터에 실행요청함
	
	preprocessor(전처리기)는 도커이미지로 패키지화 할 대상을 설정함,기본값은 노트북이면 notebook,아니면 python
	전처리기는 4개의 타입이 있음
		python:파이썬파일을 패키징함,도커이미지에선 python /app/파일명으로 cmd가 생성됨,
				파이썬파일 그대로쓰기때문에 분기로 페어링실행과 train()을 구분함
		notebook:쥬피터노트북파일을 파이썬으로 변환한후 그걸 패키징함
		full_notebook:노트북파일을 수행한후 결과를 다시 노트북파일로 생성
		function:단일함수를 패키징함
	보통 노트북이나 파이썬을 쓰는듯
	그리고 전처리기는 페어링이 추가된 소스가 아닌 다른 리소스들의 리스트를 파라미터로 받음
		fairing.config.set_preprocessor('notebook',input_files=["data.csv","requirements.txt"])
		
	빌더는 전처리기가 생성한 패키지를 도커이미지화 시킴
	여기도 타입3개가 있는데
		append:도커 클라이언트를 사용하지않고,자체 라이브러리를 통해 이미지를 생성함
			   도커클라이언트를 사용할수없는환경에서 사용하기좋긴한데,도커데몬의 설정값을 사용할수없어서,
			   로그인이 필요한 레지스트리면 config.json을 만들어줘야함
		cluster:구글컨테이너툴인 kaniko를 사용해서 도커이미지를 만듬
				직렬화된 파이썬파일을 스토리지에 업로드하고 카니코잡을 쿠버네티스클러스터에 요청함,
				카니코잡은 스토리지에서 직렬화된 파이썬파일을 다운로드한후 이미지를 생성함
				스토리지는 클라우드서비스의 스토리지와 클러스터내 minio를 사용할수있음,
				레지스트리 푸시는 kaniko에서 처리하기때문에 클러스터가 해당레지스트리에 푸시할수있는 권한을 가지고있어야함
		docker:로컬 도커클라이언트로 도커이미지생성함
			   로컬에서 진행해서,로컬환경이 대상레지스트리에 푸시/풀권한이 있어야함
		
	디플로이어는 이미지생성이 완료되면 해당 이미지의 배포를 진행함,여기서 배포는 mljob이 될수도있고,서빙모델배포가 될수도있음
	사용방법은
		fairing.config.set_deployer('job',
									namespace='test',
									pod_spec_mutators=[k8s_utils.get_resource_mutator(cpu=2,memory=5)])
	
	이런식으로 배포형태(job,tfjob,serving,kfserving등을 선택)를 정하고,
	네임스페이스를 정한다음
	배포될 파드의 스펙을 정함(pvc나 리소스설정등)
		k8s_utils.get_resource_mutator로 리소스설정
		k8s_utils.mounting_pvc로 pvc설정
	을 할수있음
	
	config.run은 설정된 값기준으로 페어링을 실행해줌
	config.fn은 함수를 입력값으로 받아,전처리기를 function으로 설정하고 run을 실행하는 함수를 반환함
	
	페어링은 config클래스에서 좀 더 ml트레인에 특화된 클래스를 제공함
		backendinterface:백엔드인터페이스는 트레인잡이나 서빙잡을 실행할때 클러스터의 환경을 제공해주는 기본클래스임
		이 클래스를 상속해서 특정 클러스터의 특성에 맞게 전처리기,빌더,디플로이어 및 부가기능을 제공함,보통 클라우드는 다 있음
		
		trainjob:config클래스에서 나눠설정하던걸 모아둔거,백엔드클래스설정이 필요
		
		predictionendpoint:예측모델의 서비스를 생성함,모델생성,모델학습,예측까지 하나의클래스에서 설정할수있음
	
	
	
	
	카티브는
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	