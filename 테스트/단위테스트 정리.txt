1.단위테스트의 목표
	단위테스트에 시간을 쓸때는 테스트에 드는 노력을 가능한 최소화하고,그에 따르는 이득을 최대화해야함
	보통 이런 단위테스트가 매우 효과적인곳은
		무난히 성장하고
		유지보수가 많이 필요하지않고
		끊임없이 고객의 요구가 변화하고
		거기에 신속하게 대응해야하는
	프로젝트가 효과적임
	단위테스트를 만드는것도 중요하지만,어떤 단위테스트가 좋은지를 분석하는 비용편익분석방법을 아는것도 중요함
	
	단위테스트의 가장 큰 목표는 소프트웨어의 지속가능한 성장이 가능하게 한다는것(회귀테스트)
	단위테스트를 만들기 쉬우면 코드가 좋아진다는건,
	단위테스트를 만들기 어려우면 코드가 나쁘다(강결합)는 참일수 있지만,
	단위테스트를 만들기 쉬우면 좋은코드다 는 참이 아닐가능성이 높음(결합도가 낮다고 다 좋다고는못하니까)
	즉 좋은 부정지표지만 나쁜 긍정지표임
	즉 단위테스트의 주 목표는,회귀에 대한 보험이라고 할수있음
	단 내야하는 비용도 있는데,이게 테스트에는 상당한 노력이 필요하다는것
	이건 조금만 프로젝트가 길어지면 손익분기점에 쉽게 도달하지만,한번쓰고 버릴거엔 별의미없음
	
	단위테스트가 프로젝트성장에 도움이 되는건 맞지만,테스트를 작성하는거만으로는 충분하지않음
	잘못 작성된 테스트는 프로젝트가 침체기에 들어가는걸 늦출순있지만,피하게할수는없음
	
	모든 테스트의 가치는 똑같지않음,
	어떤테스트는 아주 중요하고 프로젝트에 큰 기여를 하지만,
	어떤테스트는 잘못된 경고가 발생하고,회귀오류를 알아내는데 도움을 주지않고 유지보수가 어렵고 느림
	
	테스트의 비용은,각 활동을 할때 필요한 시간에 따라 결정됨
		기반코드 리팩토링시 테스트도 리팩토링해야하는지
		각 코드변경시 테스트실행시간
		테스트가 잘못된 경고를 발생시킬때 수정하는시간
		기반코드를 이해하려고할떄 테스트를 읽어서 걸리는시간
	등이 있음,이때 유지비용이 너무높아서 가치가 0이거나 -로 떨어질수있음,그런테스트는 제거하고,고품질 테스트만 남기는게 좋음
	
	테스트코드도 아무의미없이 늘어나면 비용만 증가하니,가능한 적은 코드로 해결하는게 좋음
	
	
	프로젝트에 테스트가 얼마나 잘됐는지를 알아보는 지표로 보통 사용하는건 커버리지지표임
	커버리지지표는 분기커버리지와 코드커버리지가 있음
	하지만 이 커버리지지표도 좋은 부정지표지만 나쁜 긍정지표임
	그냥 테스트가 많으면(커버하는 영역이 많으면) 좋은게 아닌,거기에 따른 회귀시를 책임질수있어야함
	
	코드커버리지는 실행코드라인수/전체라인수 임
	그래서 if문을 여러줄로 처리하거나 한줄로 처리하거나 할때 영향을 받음(즉 장난질이 가능함)
	
	분기커버리지는 코드커버리지보다 좀 더 나음,이건 통과분기/전체분기수 임
	이건 if나 switch같은 제어구조에 중점을 두고,분기를 통과했냐안했냐에만 영향을 받음
	즉 코드커버리지보다 장난질이 어려움
	단 이거도 문제가있는데,
		테스트대상시스템의 모든 가능한 결과를 검증했다고 보장할수없고
		외부라이브러리의 코드경로를 고려할수는없음
	이라는 문제가 있음(전역변수변경같은건 체크못하고,검증을 하지않으면 체크는되는데 넘어가서 장난질이 가능)
	즉 프로젝트의 테스트를 평가하는데 하나의 지표로 사용할순있지만,이거만 봐서는 안됨
	
	커버리지 지표는 목표가 되어서는 안되고,자연스럽게 해당기준을 충족하는식이 되어야함
	즉 낮으면 나쁘지만 높은건 별의미없음
	
	테스트스위트의 품질측정은,스위트내 테스트를 각각 평가하는방법밖에 없음
	성공적인 테스트스위트는
		개발주기에 통합되어있음
		코드베이스에서 중요한부분만을 대상으로 함
		최소한의 유지비로 최대한의 가치를 끌어냄
	라는 특성을 가지고있음
	
	개발주기통합은,코드 변경시마다 테스트를 실행시키는걸 말하고,
	
	코드베이스에서 중요한부분만을 대상으로 한다는건,즉 도메인영역을 최우선적으로 높게가져가야 한다는것
	통합테스트처럼 전체를 보는 테스트도 필요하긴하지만,제일 중요한건 도메인영역의 단위테스트임
	그래서 도메인영역은 다른영역과 분리해서 테스트가 쉽게하는게 중요함
	
	가장 어려운건 최소비용으로 최대편익을 끌어내는거임,이건
		가치있는테스트와 가치없는테스트를 식별
		가치있는테스트 작성
	로 나눠짐
	
	
2.단위테스트란 무엇인가	
	단위테스트는
		작은 코드 조각을 검증하고
		빠르게 수행하고
		격리된방식으로 처리하는 자동화된 테스트
	임
	여기서 격리된방식으로 처리하는 자동화된테스트라는 부분에서 고전파와 런던파로 나눠짐
	런던파는 진짜 해당코드를 완벽히 격리(모든의존성을)하고,고전파는 그냥 테스트끼리만 격리되면 ok라는느낌임
	
	그래서 런던파의경우엔 목을 사용해서 모든의존성을 대체하고,해당클래스에만 집중함
	이거의 장점은
		문제가 생기면(테스트가깨지면),무조건 그코드잘못임
		객체그래프를 분할할수있음
		테스트생성이 간단해짐(그냥 클래스단위로 뽑으면됨)
	이걸위해 모든 의존성을 목으로 대체하면됨
	
	고전파는 그냥 의존성있는건 다 그대로 사용하고(프로덕트랑 똑같이),테스트끼리만 충돌나지않게 처리함(트랜잭션이나 직접지우거나 하는식으로)
	이쪽은 목을 외부의존성(레포지토리같은)에서만 사용하고,다른의존성들은 그냥 가져감
	특히 별문제없는 공유의존성(스프링같은)것들은 같이 가져가서 테스트의 병렬실행들을 할수도있음(물론 런던파도 가능)
	물론 공유의존성의경우엔 테스트실행속도가 낮아지기때문에,가능하면 통합테스트로 빼는게나음
	
	즉
		런던파:단일클래스끼리 격리하고(클래스여러개가 한테스트에 들어가면안됨),불변의존성외에 모든의존성을 모킹함
		고전파:단위테스트끼리 격리하고(클래스여러개가 한테스트에 들어가도됨),공유의존성만 모킹함
	으로 나눠짐
	여기서 불변의존성은 절대 변하지않는 의존성임,enum이나 상수클래스같은거(즉 vo)
	그리고 모든 외부의존성이 공유의존성은 아님,즉 수정하는기능이 없이 같은값을 조회하는기능만 있다면 공유의존성은 아님
	물론 외부상황에 따라 값이 바뀔수있으니 이런건 휘발성 의존성임
	
	런던파의 특징은
		장점
			입자성이 좋음,테스트가 세밀해서 한번에 한클래스만 확인함
			서로 연결된클래스가 커져도 테스트가 똑같이 쉬움
			테스트가 실패했을시 어떤기능이 실패했는지 바로보임
		단점
			변경에 좀 취약함
			다 모킹을치면되니 따로 테스트를 코드에 대한 부정지표로 사용할수없어짐
			테스트가 코드에 결합될 확률(과도한명세)이 높아짐(가장큰문제)
	이 있음
	
	그래서 두 분파마다 통합테스트의 정의도 좀 다름
	고전파의 거의 모든 테스트는 런던파에겐 통합테스트임
	통합테스트는 유닛테스트의 기준중 하나 이상을 충족하지못하는 테스트임
	예를들어 공유의존성이 있으면 테스트간 격리가 되지않고,
	외부의존성에 접근하면 테스트가 느려지고,
	두가지이상의 동작단위를 검증하는식임
	
	이 통합테스트의 일부로 e2e테스트가 있음
	
	
3.단위테스트 구조	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	