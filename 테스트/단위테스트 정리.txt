1.단위테스트의 목표
	단위테스트에 시간을 쓸때는 테스트에 드는 노력을 가능한 최소화하고,그에 따르는 이득을 최대화해야함
	보통 이런 단위테스트가 매우 효과적인곳은
		무난히 성장하고
		유지보수가 많이 필요하지않고
		끊임없이 고객의 요구가 변화하고
		거기에 신속하게 대응해야하는
	프로젝트가 효과적임
	단위테스트를 만드는것도 중요하지만,어떤 단위테스트가 좋은지를 분석하는 비용편익분석방법을 아는것도 중요함
	
	단위테스트의 가장 큰 목표는 소프트웨어의 지속가능한 성장이 가능하게 한다는것(회귀테스트)
	단위테스트를 만들기 쉬우면 코드가 좋아진다는건,
	단위테스트를 만들기 어려우면 코드가 나쁘다(강결합)는 참일수 있지만,
	단위테스트를 만들기 쉬우면 좋은코드다 는 참이 아닐가능성이 높음(결합도가 낮다고 다 좋다고는못하니까)
	즉 좋은 부정지표지만 나쁜 긍정지표임
	즉 단위테스트의 주 목표는,회귀에 대한 보험이라고 할수있음
	단 내야하는 비용도 있는데,이게 테스트에는 상당한 노력이 필요하다는것
	이건 조금만 프로젝트가 길어지면 손익분기점에 쉽게 도달하지만,한번쓰고 버릴거엔 별의미없음
	
	단위테스트가 프로젝트성장에 도움이 되는건 맞지만,테스트를 작성하는거만으로는 충분하지않음
	잘못 작성된 테스트는 프로젝트가 침체기에 들어가는걸 늦출순있지만,피하게할수는없음
	
	모든 테스트의 가치는 똑같지않음,
	어떤테스트는 아주 중요하고 프로젝트에 큰 기여를 하지만,
	어떤테스트는 잘못된 경고가 발생하고,회귀오류를 알아내는데 도움을 주지않고 유지보수가 어렵고 느림
	
	테스트의 비용은,각 활동을 할때 필요한 시간에 따라 결정됨
		기반코드 리팩토링시 테스트도 리팩토링해야하는지
		각 코드변경시 테스트실행시간
		테스트가 잘못된 경고를 발생시킬때 수정하는시간
		기반코드를 이해하려고할떄 테스트를 읽어서 걸리는시간
	등이 있음,이때 유지비용이 너무높아서 가치가 0이거나 -로 떨어질수있음,그런테스트는 제거하고,고품질 테스트만 남기는게 좋음
	
	테스트코드도 아무의미없이 늘어나면 비용만 증가하니,가능한 적은 코드로 해결하는게 좋음
	
	
	프로젝트에 테스트가 얼마나 잘됐는지를 알아보는 지표로 보통 사용하는건 커버리지지표임
	커버리지지표는 분기커버리지와 코드커버리지가 있음
	하지만 이 커버리지지표도 좋은 부정지표지만 나쁜 긍정지표임
	그냥 테스트가 많으면(커버하는 영역이 많으면) 좋은게 아닌,거기에 따른 회귀시를 책임질수있어야함
	
	코드커버리지는 실행코드라인수/전체라인수 임
	그래서 if문을 여러줄로 처리하거나 한줄로 처리하거나 할때 영향을 받음(즉 장난질이 가능함)
	
	분기커버리지는 코드커버리지보다 좀 더 나음,이건 통과분기/전체분기수 임
	이건 if나 switch같은 제어구조에 중점을 두고,분기를 통과했냐안했냐에만 영향을 받음
	즉 코드커버리지보다 장난질이 어려움
	단 이거도 문제가있는데,
		테스트대상시스템의 모든 가능한 결과를 검증했다고 보장할수없고
		외부라이브러리의 코드경로를 고려할수는없음
	이라는 문제가 있음(전역변수변경같은건 체크못하고,검증을 하지않으면 체크는되는데 넘어가서 장난질이 가능)
	즉 프로젝트의 테스트를 평가하는데 하나의 지표로 사용할순있지만,이거만 봐서는 안됨
	
	커버리지 지표는 목표가 되어서는 안되고,자연스럽게 해당기준을 충족하는식이 되어야함
	즉 낮으면 나쁘지만 높은건 별의미없음
	
	테스트스위트의 품질측정은,스위트내 테스트를 각각 평가하는방법밖에 없음
	성공적인 테스트스위트는
		개발주기에 통합되어있음
		코드베이스에서 중요한부분만을 대상으로 함
		최소한의 유지비로 최대한의 가치를 끌어냄
	라는 특성을 가지고있음
	
	개발주기통합은,코드 변경시마다 테스트를 실행시키는걸 말하고,
	
	코드베이스에서 중요한부분만을 대상으로 한다는건,즉 도메인영역을 최우선적으로 높게가져가야 한다는것
	통합테스트처럼 전체를 보는 테스트도 필요하긴하지만,제일 중요한건 도메인영역의 단위테스트임
	그래서 도메인영역은 다른영역과 분리해서 테스트가 쉽게하는게 중요함
	
	가장 어려운건 최소비용으로 최대편익을 끌어내는거임,이건
		가치있는테스트와 가치없는테스트를 식별
		가치있는테스트 작성
	로 나눠짐
	
	
2.단위테스트란 무엇인가	
	단위테스트는
		작은 코드 조각을 검증하고
		빠르게 수행하고
		격리된방식으로 처리하는 자동화된 테스트
	임
	여기서 격리된방식으로 처리하는 자동화된테스트라는 부분에서 고전파와 런던파로 나눠짐
	런던파는 진짜 해당코드를 완벽히 격리(모든의존성을)하고,고전파는 그냥 테스트끼리만 격리되면 ok라는느낌임
	
	그래서 런던파의경우엔 목을 사용해서 모든의존성을 대체하고,해당클래스에만 집중함
	이거의 장점은
		문제가 생기면(테스트가깨지면),무조건 그코드잘못임
		객체그래프를 분할할수있음
		테스트생성이 간단해짐(그냥 클래스단위로 뽑으면됨)
	이걸위해 모든 의존성을 목으로 대체하면됨
	
	고전파는 그냥 의존성있는건 다 그대로 사용하고(프로덕트랑 똑같이),테스트끼리만 충돌나지않게 처리함(트랜잭션이나 직접지우거나 하는식으로)
	이쪽은 목을 외부의존성(레포지토리같은)에서만 사용하고,다른의존성들은 그냥 가져감
	특히 별문제없는 공유의존성(스프링같은)것들은 같이 가져가서 테스트의 병렬실행들을 할수도있음(물론 런던파도 가능)
	물론 공유의존성의경우엔 테스트실행속도가 낮아지기때문에,가능하면 통합테스트로 빼는게나음
	
	즉
		런던파:단일클래스끼리 격리하고(클래스여러개가 한테스트에 들어가면안됨),불변의존성외에 모든의존성을 모킹함
		고전파:단위테스트끼리 격리하고(클래스여러개가 한테스트에 들어가도됨),공유의존성만 모킹함
	으로 나눠짐
	여기서 불변의존성은 절대 변하지않는 의존성임,enum이나 상수클래스같은거(즉 vo)
	그리고 모든 외부의존성이 공유의존성은 아님,즉 수정하는기능이 없이 같은값을 조회하는기능만 있다면 공유의존성은 아님
	물론 외부상황에 따라 값이 바뀔수있으니 이런건 휘발성 의존성임
	
	런던파의 특징은
		장점
			입자성이 좋음,테스트가 세밀해서 한번에 한클래스만 확인함
			서로 연결된클래스가 커져도 테스트가 똑같이 쉬움
			테스트가 실패했을시 어떤기능이 실패했는지 바로보임
		단점
			변경에 좀 취약함
			다 모킹을치면되니 따로 테스트를 코드에 대한 부정지표로 사용할수없어짐
			테스트가 코드에 결합될 확률(과도한명세)이 높아짐(가장큰문제)
	이 있음
	
	그래서 두 분파마다 통합테스트의 정의도 좀 다름
	고전파의 거의 모든 테스트는 런던파에겐 통합테스트임
	통합테스트는 유닛테스트의 기준중 하나 이상을 충족하지못하는 테스트임
	예를들어 공유의존성이 있으면 테스트간 격리가 되지않고,
	외부의존성에 접근하면 테스트가 느려지고,
	두가지이상의 동작단위를 검증하는식임
	
	이 통합테스트의 일부로 e2e테스트가 있음
	
	
3.단위테스트 구조	
	단위테스트는 기본적으로 aaa패턴(gwt랑같음)를 따르는게 좋음
	g에선 테스트대상을 테스트하기 직전으로 만들고
	w에선 메서드를 호출(보통 1줄)
	t에선 결과를 검증함
	보통은 순서대로하지만,tdd를 하려면 거꾸로 검증부터 만드는것도 가능함
	
	만들다보면 준비와 실행이 여러개(준비-실행-검증-실행-검증)될수도 있는데,이건 대부분 테스트를 쪼개야함
	이런건 통합테스트의 영역이지(여기서도 비용아끼려고 묶는거),단위테스트의 영역은 아님
	
	그리고 테스트에서 로직(if)이 들어가면안됨,이런거도 반드시 여러테스트로 나눠야함
	이건 통합테스트도 똑같음
	
	보통 준비구절이 가장 크고,만약 너무크면 별도의 프라이빗메서드로뽑아낼순있음 
	실행은 1줄(이게 2줄이상이면 api에 문제가 있을수있음,보통 캡슐화),근데 유틸리티나 인프라의경우엔 그럴수도있음
	검증은 적당히 있으면됨,그래도 너무많으면 그러니까 결과값과 같다고 생각되는 객체를 만들어서 equal비교를 하는게 좋음
	
	그리고 보통 유닛테스트에는 종료(afterEach)가 필요없음,이건 통합테스트의 영역임
	
	테스트대상의 이름을 sut같은 특정이름으로 고정하는거도 효과적임
	
	테스트 픽스처(준비대상)을 재사용할떄,막하면 결합도가 올라가고 안좋은게 많음
	이건 전체에서 반드시 똑같은걸 사용한다는 보장(보통 레이어드에서 서비스,레포지토리)이 있을때만 가능하고,
	안에 데이터들을 넣는거같은경우엔 반복을 포함해서 각각 따로하는게 좋음
	이 데이터넣는걸 꼭 뽑고싶다면 비공개팩토리메서드로 뽑을순있음,이때 종류별로 여러개를 두고,이름을 빡빡하게 길게 적는게좋음(하는일을 다적는식)
	
	테스트의 이름은
		엄격한 규칙을 만들지않고
		도메인에 익숙한 비개발자에게 시나리오를 설명하는거처럼 이름짓자
		단어를 밑줄단위로 구분
		반드시 확정적인 단어를 사용(했으면좋겠다 사용금지)
	
	
4.좋은 단위테스트의 4대 요소	
	단위테스트의 4대요소는
		회귀방지
		리팩터링내성
		빠른피드백
		유지보수성
	이 4가지가 기본임
	이 4가지를 가지고 통합테스트와 e2e테스트도 분석할수 있음
	
	회귀방지는,소프트웨어 버그 감지임
	수정을 했을때 기능이 정상적으로 작동하지 않는걸 감지하는것
	이건 코드가 자산이 아닌 책임이기때문에,확률적으로 코드가 늘어날수록 심해지기때문에,이걸 보호해주는게 중요하고,
	그게 회귀방지임
	
	회귀방지에 대해 평가할때 고려해야할건
		테스트도중 실행되는 코드의 양
		코드복잡도
		코드의 도메인 유의성
	임
	코드가 많으면 많을수록 테스트에서 회귀가 나타날 가능성이 높음(검증까지 합쳐서)
	복잡한 비즈니스로직 코드 테스트가 보일러플레이트 코드 테스트보다 훨씬 중요함
	반면 단순한 코드를 테스트하는건 가치가 거의없음
	실수할일이 별로없기때문에 회귀오류가 잘 생기지않음
	그리고 우리가 작성하지않는 코드도 작성한코드만큼 영향을 끼치기때문에,이거도 테스트범주에 포함시켜서 의존성을 검증하는거도 중요함
	
	리팩터링내성은,api의 수정없이 메서드 내부로직을 수정했을때,결과가 정상일때 테스트도 정상일수 있냐를 나타냄
	즉 테스트를 실패로 바꾸지않고 메서드를 수정할수있냐임
	이런 실제론 정상이지만 테스트가 실패하는걸 거짓양성이라고 함
	리팩터링내성 지표에서의 테스트점수는 거짓양성이 얼만큼 적게나오냐를 보면됨
	이 거짓양성은 계속 에러가 뜨면서 진짜양성에 대한 위험느낌도 줄여버리고,테스트에 대한 신뢰가 떨어짐
	그리고 리팩터링을 잘 하지않게됨,테스트를 수정해야하는게 귀찮아지니까
	
	거짓양성의 원인은 테스트와 구현의 결합도때문임
	즉 테스트는 내부구현에 의존하면안되고,메서드의 api에만 의존해야함
	즉 중간결과같은거에 의존하면안되고,최종결과(리턴으로 받은)에만 의존해야함
	이러면 메서드api의 매개변수갯수의 변화같은일 말고는 거짓양성이 거의 사라짐(이런건 해결하기쉬워서 ㄱㅊ)
	
	
	회귀방지는 프로젝트 초반부터 중요하고,리팩터링내성은 프로젝트 중반부터 중요해짐
	회귀방지는 거짓음성으로 표현할수있고(실패해야하는데 실패하지않음)
	리팩터링내성은 거짓양성으로 표현할수있음(성공해야하는데 실패함)
	이 두가지를 가지고 테스트의 정확도를 알수있음 
		정확도=발견된버그수/거짓양성
	이게 정확도임
	여기서 두가지방법이 있는데,회귀방지를 올리거나(분자),리팩터링내성을 올리는것(분모)
	
	단기적으로는 거짓양성이 거짓음성만큼 나쁘진않지만,장기적으로 보게되면 영향이 점점 커짐(리팩터링은 초반엔 중요하지않으니)
	
	
	빠른피드백은 단위테스트의 필수속성임
	속도가 빠를수록 비용이 낮아져서 회전율을 올릴수있음
	유지보수성지표는 유지비를 나타냄
		테스트가 얼마나 이해가 어려운지
			테스트는 라인수가 적고,품질이 높고,절차를 생략하지않아야함
		테스트가 얼마나 실행이 어려운지
			테스트는 의존성이 가능한만큼 작으면 좋음
	으로 나타낼수있음
	
	테스트의 가치는,회귀방지*리팩터링내성*빠른피드백*유지보수성임
	이건 각각 0~1사이이고,즉 하나라도 0이면 테스트의 가치는 0임
	물론 이런 특성을 측정해주는 도구는 없고,모든 가치를 1로만드는거도 불가능함(cap같은느낌)
	회귀방지와 리팩터링내성,빠른피드백은 서로 상호배타적이라 3개를 모두 1로올릴수없기때문
	예를들어 e2e테스트는 회귀방지와 리팩터링내성을 올리고 빠른피드백을 매우 낮춘거고
	매우 간단한코드테스트는 리팩터링내성과 빠른피드백을 올리고 회귀방지를 매우낮춘거임(간단하니까 버그가 나올구석이 없음)
	깨지기쉬운테스트는 빠른피드백과 회귀방지를 올리고 리팩터링내성을 낮춘거
	
	일반적으로는 리팩터링내성을 1로잡고,회귀방지와 빠른피드백사이에서 줄타기를 함
	왜냐면 리팩터링내성은 보통 1이거나 0인경우가 많기때문
	
	테스트피라미드에서,e2e는 회귀방지쪽에 더 투자를하고,통합은 중간,단위테스트는 빠른피드백에 더 투자를 함
	즉 리팩터링내성은 어디서도 포기하지않음
	여기서 e2e가 가장 갯수가 적은이유는,빠른피드백부분에서 점수가 매우낮고,유지보수성이 결여되기때문(외부의존성)
	그래서 e2e는가장 중요한 기능에만 사용해야함
	
	
	또한 테스트엔 블랙박스테스트와 화이트박스 테스트가 있는데,
		블랙박스는 api만 테스트하는것(사전조건,사후조건,불변식),즉 인터페이스에서 파생됨
		화이트박스는 애플리케이션의 내부작업을 검증하는것,즉 소스코드에서 파생됨
	보통 화이트박스는 회귀방지가 뛰어나지만,리팩터링내성이 낮고
	블랙박스는 리팩터링내성이 높지만 회귀방지가 낮음
	보통 리팩터링내성은 포기할수없기때문에 블랙박스를 많이 사용함,유일한 예외는 복잡도가 높은 유틸클래스일경우엔 화이트박스를 사용할수있음
	
	그리고 테스트를 작성할땐 블랙박스,테스트를 분석할땐 화이트박스방식을 사용하면됨
	즉 코드커버리지로 어떤분기에 진입안했냐만 확인하고,코드내부를 모르는거처럼 해당분기에 들어가는 로직테스트를 만드는식
	
	그리고 검증문을 만들때 소스코드에 의존하지말고,테스트에서 별도의 리터럴과 상수집합을 만들어서 사용하는게 좋음
	안그러면 동어반복테스트가 될수있음(아무것도 검증하지 않는)
	
	
5.목과 테스트취약성
	목을 사용하면 리팩터링내성이 내려가는경우가 있고,오히려 바람직한경우도 있음
	
	테스트대역에는 크게 목과 스텁으로 나누어지는데,목은 외부의존성에 대해 사용하고,스텁은 내부의존성에 대해 사용함
	즉 이메일전송은 목을 사용하고,db는 스텁을 사용함
	그리고 목은 라이브러리의 목(도구로써의 목)과 테스트대역으로써의 목이 있는데,그냥 동음이의어같은느낌임(보통 라이브러리의 목은 스텁같은느낌)
	
	그리고 목은 외부로 나가는 상호작용을 검사하고 모방하는데,스텁은 내부로 들어오는 상호작용을 모방만 해야함
	왜냐면 외부로 나가는 외부의존성은 그게 최종결과물인데,스텁의 경우엔 보통 중간산출물같은거라,테스트와 구현이 결합될확률이 높아지기때문
	
	cqs에서(명령조회분리) 명령을 대체하는건 목이고,조회를 대체하는건 스텁임
	명령은 void로 리턴되고,조회는 값으로 리턴되기때문
	
	
	모든 제품코드는 api(공개api와 비공개api)와 식별할수있는 동작 또는 구현세부사항으로 나눠짐
	이건 이진선택이라 겹치지않음
	
	공개api와 비공개api는 public냐 privite냐이고,
	식별할수있는 동작은
		클라에 도움이되는 연산을 노출하던가(연산은 계산을 수행하거나 부작용을 일으키거나 함)
		클라에 도움이되는 상태를 노출하던가
	둘중 하나고,구현세부사항은 둘중 아무것도 하지않음
	이상적으로 공개api와 식별할수있는 동작은 일치해야하고,모든 구현세부사항은 비공개api여야함
	그래서 밖에서 사용할필요없는 get,set은 삭제하고,반드시 필요한거만 만드는게좋음
	
	이때 클래스가 구현세부사항을 유출하는지 판단할때 도움이되는 규칙이 있는데,
	단일목표를 달성할때 클래스에서 호출해야하는 연산의 수가 1보다 크면 구현세부사항을 노출할 가능성이 있음(즉 한번에 못끝내면)
	
	잘설계된 api는 캡슐화가 잘되어있고 불변성위반이 일어나지않음
	코드베이스 유지보수에서 가장 중요한건 캡슐화임,이때 실수할가능성을 최대한 없애고,묻지말고답하라 원칙을 지키는게 좋음
	반드시 필요한거만 노출하고,나머지는 전부 숨겨야함 
	
	헥사고날아키텍쳐에서의 테스트는,헥사고날아키텍쳐가 프랙탈구조를 가지는거처럼 테스트도 프랙탈구조를 가지게됨
	즉 달성하고자 하는 목표는 같지만,이걸 서로 다른수준에서 동작을 검증할수있음
	
	시스템 내부통신(도메인간의 통신,구현세부사항)과 달리 시스템 외부통신은 항상 식별할수있는 동작임
	이 시스템간 통신은 하위호환성을 지켜야함
	
	런던파와 고전파의 차이는,이 시스템 내부통신과 외부통신을 구분하지않고 모두 목을 사용하는데 있음
	고전파는 외부의존성만 모킹에 의존함
	단,여기서도 외부에서 관찰할수없는 외부의존성은(애플리케이션이 외부의존성의 프록시역할만 할때,예로 db가있음)내부의존성으로 간주해도됨
	
	
6.단위테스트 스타일
	단위테스트 스타일엔
		출력기반:메서드의 출력을 테스트
		상태기반:메서드가 변경시킨 상태를 테스트(db등)
		통신기반:목을 사용해 협력자와 통신하는지를 테스트
	3가지가 있음
	이건 위에서부터 아래로 좋지만,출력기반테스트를 할땐 코드부터 거기에 맞춰줘야함(순수함수로 작성되어야함,즉 헥사고날아키텍쳐)
	
	출력기반테스트는 테스트대상시스템에 입력을 넣고 나오는 출력을 검사하는 방식임
	즉 반환값만 검증하면될때 사용할수있고(사이드이펙트가 없을때),이게 가장 좋은 테스트방법임
	
	상태기반테스트는 메서드가 끝나고 변경시킨 상태를 검사하는방식임
	이건 db에 저장,삭제등을 테스트할때 사용할수있음(외부의존성)
	
	통신기반테스트는 목을 사용해서 테스트대상시스템과 협력자간의 통신을 검증함
	
	기본적으로 3가지 방법 다 회귀방지와 피드백속도는 별차이없음,문제는 리팩터링내성임
	출력기반은 api상세에만 의존하므로,가장 내부구현과 결합이 덜됨
	상태기반은 거짓양성이 되기 쉬움(사이드이펙트에 의존하므로)
	통신기반은 허위경보에 가장 취약함,목을 사용하면 테스트가 깨지기 쉬워짐,물론 상호작용의 사이드이펙트가 외부환경에 보일땐 괜ㅊ낳음
	물론 캡슐화를 잘 지키고 테스트를 식별할수있는 동작에만 결합하면 거짓양성을 최소한으로 줄일수있음
	
	그리고 유지보수성에서도 차이가 있음
	이 유지보수성은
		테스트를 이해하기 얼마나 어려운가(ex:테스트크기)
		테스트를 실행하기 얼마나 어려운가(ex:외부의존성갯수)
	두가지임
	
	보통 출력기반이 제일 유지보수가 쉽고(항상 짧고 간결하고 외부의존성이 없음)
	상태기반은 출력기반보다 어려움,일단 외부의존성이 있고,검증문이 길어져서 테스트크기가 커짐(이건 객체를 비교하는식으로 줄일수있음)
	통신기반은 여기서 가장 유지보수가 어려움,외부의존성도 있고,목을 세팅도 해야하고,목이 체인으로 묶여있을때도 처리해야함
	
	즉 출력기반이 가장 좋고,이게 가장 많아야함
	근데 그려려면 애초에 코드가 함수형아키텍쳐(클린아키텍쳐쪽)이어야함
	즉 도메인모델을 뽑아내고,거기서 pojo로 모든 코드가 적혀야함,그리고 사이드이펙트가 없어야함
	물론 사이드이펙트로 예외를 던지거나,localdate.now()로 시간을 받아올수있음
	
	이 순수함수인지 판단하기 제일 좋은방법은
		val x=abcFun(2)
	이런식으로 바로 대입할수있으면 보통 순수함수임
	
	물론 사이드이펙트가 아예없는 프로그램을 만들순없고,목표는 사이드이펙트부분과 순수함수부분을 분리해내는것임
	즉 도메인부분과 서비스부분을 분리하는것
	서비스쪽에서 사이드이펙트를 처리하고,예외를 던지고,시간을 받아오는식으로 하면됨
	(이건 헥사고날과 함수형의 차이인듯,헥사고날은 이런거도 도메인안에서 처리하는데,함수형은 밀어내니)
	
	
	기본적으로 함수형 아키텍쳐로 기존코드를 고치려면,
		프로세스외부의존성에서 목으로 변경
		목을 함수형아키텍쳐로 변경
	이 두단계를 거쳐야함
	가장 테스트가 어려운곳(험블)은 외부의존성이고,특히 공유의존성이기까지하면 더더욱심함
	그래서 이걸 목과 실제코드를 받을수있는 인터페이스로 변경하고,테스트에선 목을 주입하는식임
	이렇게하면 공유의존성이 사라지고,험블과 험블이아닌곳을 분리해서 통합테스트를 유닛테스트로 분리해낼수있음
	
	여기까지만 해도 많이나아지는데,여기서 함수형아키텍쳐로 변경하면 유지보수성도 높일수있음
	즉 사이드이펙트를 아예 도메인외부로 밀어내는것(헥사고날과 다르게 함수형이라)
	즉 직접 외부의존성을 건드리지않고 외부의존성을 건드릴수있는 자료만 반환하고,
	외부의존성을 처리하는 클래스를 따로만든다음,
	서비스단에서 그걸 조립하는거만 처리하는거임
	
	이렇게하면 각각의 책임이 전부 나눠져서(내부로직처리,외부의존성처리,조립처리) 유지보수성이 올라감
	
	이 함수형아키텍쳐의 단점은,항상 적용할수있는건 아니고(사이드이펙트가 반드시필요할수있고,캡슐화시키는게 맞을수도있음)
	그리고 외부로 밀어냄으로써 성능에 영향을미침(외부의존성호출이 늘어서)
	그리고 코드양이 늘어날수있음(물론 유지보수성이 늘어나서 서로영향을 안줘서 수정은 쉽지만 처음에 할게 늘어남)
	
	
7.가치있는 단위테스트를 위한 리팩터링	
	테스트 스위트를 개선하기위해선,기반코드가 잘 만들어져있어야하고,이걸위해서 리팩토링을 할수있음
	모든 코드는
		복잡도 or 도메인유의성
		협력자수
	이 2가지를 x,y축으로 잡고 4부분으로 나눌수있음
	여기서 복잡도는 코드 내 분기의 수로 정의할수있고(클수록 높아짐)
	도메인유의성은 코드가 프로젝트의 문제도메인에 대해 얼마나 의미있는지(도메인계층과 얼마나 가까운지),즉 유틸코드는 여기서 멀리떨어짐
	이쪽으로만 보면 도메인 그자체인 도메인영역은 단위테스트하기 매우 좋은곳임
	
	또하나는 클래스나 메서드가 가진 협력자수임
	여기서 협력자는 가변의존성(시간같은)이거나 외부의존성임
	협력자가 많을수록 테스트비용이 많이드는데,이건 테스트크기에 따라 달라지는 유지보수성지표때문임
	또 협력자의 유형도 중요한데,도메인모델이면 외부협력자를 사용하면안됨(pojo로 구현)
	그리고 리팩터링내성을 잘 지키려면 목을 신중하게써야하는데,이건 애플리케이션의 경계를 넘는 상호작용을 검증할때(외부api호출)만 사용해야함
	그리고 이런 애플리케이션의 경계를 넘는 상호작용은 도메인이 아닌 어플리케이션서비스단에서 처리하는게좋음
	
	이렇게 2가지지표로,협력자수를 x축으로 잡고,복잡도와 도메인유의성을 y축으로 잡으면
		도메인모델 및 알고리즘 | 지나치게 복잡한코드
		간단한코드         | 컨트롤러
	이렇게 나눌수있게됨
	여기서
		도메인모델 및 알고리즘:도메인모델과,꼭 도메인모델이 아니라도 알고리즘이 복잡한코드(협력자수는 낮은데 코드만 복잡할경우)
		간단한코드:협력자수도 낮은데 복잡도도 낮은코드,생성자같은거
		컨트롤러:어플리케이션서비스처럼 여러작업들을 순차실행시키거나,외부api통신등을 하는친구들,코드는 간단하고 협력자수는 높음
		지나치게 복잡한 코드:모든작업을 직접하는 컨트롤러처럼 협력자수도 높고 코드도 복잡한애들
	여기서 우리는 도메인모델을 유닛테스트하고,
	컨트롤러(웹에선 컨트롤러와 어플리케이션서비스쪽)를 통합테스트하는식으로 진행하고,
	간단한코드는 테스트를 작성하지 않는식으로 진행하면되는데,
	문제는 지나치게 복잡한코드임
	
	지나치게 복잡한코드는 단위테스트를 만들긴 어려운데,테스트커버리지 없이 내버려두는건 매우 위험함
	이건,해당부분의 코드를 리팩토링해서,
		험블영역(컨트롤러영역으로 내려보낼 외부의존성같은걸 처리하는부분)
		알고리즘(로직을 담당할 도메인이나 로직부분)
	으로 나눠내는게 가장 좋음
	
	물론 테스트커버리지 100%를 달성할순없지만,그걸 목표로하면 안됨
	
	이렇게 리팩토링할땐,테스트가 가능한부분을 먼저 추출해내고(알고리즘영역),험블객체는 이 알고리즘을 감싸는 얇은 래퍼객체가 되어야함
	이러면 알고리즘영역은 테스트가 가능한 도메인모델 및 알고리즘으로 가게되고,
	험블객체는 협력자수는 많지만 로직이 없는 컨트롤러영역으로 가게됨
	이렇게되면 단일책임원칙도 지키게되고,비즈니스로직과 그 외부분을 분리해낼수있음
	
	실제로 코드를 리팩토링할때 순서는,
		도메인의 암시적의존성을 명시적의존성으로 변경(내부에서 스태틱으로 사용하던 database같은것들을 인터페이스로 뽑고 생성자에서 명시적으로 받기)
		명시적의존성을 외부로 분리(도메인모델의 리턴값에 의존하는식으로,이걸 돌릴때는 실제객체를 di받고,테스트시엔 목객체를 넣는식으로 사용하면됨)
		도메인의 자기의 책임이 아닌코드가 있을경우,해당도메인으로 넘겨주거나,애매하면 도메인서비스를 생성		
	이때 orm을 사용하면 괜찮지만,아닐경우엔 데이터베이스의 원시데이터를 클래스인스턴스로 변경하는 로직이 필요한데,
	이건 복잡한로직이므로 별도로 빼는게좋음(xxxxFactory같은거 만들어서),
	이건 복잡하지만 도메인유의성이 낮아 유틸리티코드에 들어감(일단 얘도 단위테스트를 해야하는쪽에 들어감)
	
	그리고 도메인의 코드들은 묻지말고답하라 원칙을 지켜서,자기일은 자기가 해당값들을 받아서 직접 처리하는식으로 하는게 좋음
	이렇게 리팩토링을 하면,로직부분에선 사이드이펙트가 없고,모든 사이드이펙트는 서비스부분에서 처리되게됨
	이렇게 유틸리티코드와 도메인을 단위테스트하고,컨트롤러(서비스와 컨트롤러)를 통합테스트하는식으로 처리하면됨
	
	그리고 도메인로직의 분기점중,일반적으로 들어오지 않는,버그로만 들어올수있는 분기점의경우(음수가 들어오면안되는데 음수가 들어올때)에도 테스트에 넣는게 좋음
	도메인유의성이 있는 전제조건의 경우 테스트할 가치가있고,도메인유의성이 없는(단순 보호장치같은)전제조건은 테스트할 가치가 없음
	즉 직접적으로 도메인의 값이 조건일경우 테스트하는게 맞고,아닐경우는 안만드는게 낫다는거인듯?
	
	
	만약 프로세스의 중간결과를 기반으로 외부의존성에서 추가데이터 조회가 필요할경우엔,의사결정단계를 더 세분화해서,
	중간단계가 나오는걸 한덩어리로 끊고가야함
	이건 잘못하면 지나치게 복잡한 사분면으로 갈수있지만,이걸 해결하기위해 canExecute/Execute패턴을 사용할수있음
	이건 비즈니스로직이 도메인모델에서 컨트롤러로 유출되는걸 방지하는거임
	즉 도메인에서 현재 해당작업이 가능한지를 나타내는 메서드를 추가하고(canExecute),
	서비스에서 도메인의 해당작업을 진행할때,저걸 확인한뒤에 로직을 진행하는거임
	이러면 서비스단에서 처리하면서도 의사결정복잡도(if문갯수)를 올리지않을수있음
	
	만약 이게 불가능할경우엔,도메인 이벤트를 사용해서 이벤트기반으로 처리해야함
	
	
8.통합테스트를 하는 이유	
	통합테스트는 프로세스 외부의존성과 통합해 어떻게 작동하는지를 검증함
	즉 컨트롤러 사분면의 코드를 테스트함
	보통 외부의존성과 도메인모델을 연결하는 코드를 확인하는경우가 많음(서비스)
	
	물론 컨트롤러 사분면에서도 단위테스트가 나올수있음,이건 외부의존성을 목으로 대체할경우에 가능한데,
	이건 db에 대해서는 불가능하고 외부api같은거만 의존할때는 가능함
	
	테스트는 단위테스트와 통합테스트의 균형을 유지하는게 중요함
	통합테스트는 외부의존성을 가지기때문에 느리고 유지비가 비쌈
	하지만 회귀방지가 높고 리팩터링내성도 우수함
	
	보통 단위테스트는 비즈니스시나리오의 예외상황을 주로 확인하고,통합테스트는 주요흐름(성공로직)과 단위테스트가 다루지못한 예외상황을 확인하게됨
	즉 가능하면 최대한 단위테스트로 뽑고,불가능하면 통합테스트로 두면됨
	그리고 어플리케이션이 단순하면 단순할수록 유닛테스트의 갯수가 줄어들고,복잡하면 결국 피라미드모양이 됨(유닛이 제일많은)

	통합테스트는 외부의존성과의 상호작용을 모두 테스트해야하기때문에,가장 긴 주요흐름을 선택하고,
	만약 모든 상호작용을 거치는 흐름이 없으면 각 상호작용마다 추가로 통합테스트를 작성해야함
	그리고 통합테스트에서는 어떤 예외가 발생하여 프로그램이 즉시 실패하면 해당예외는 테스트할필요가 없음
	보통 이런건 단위테스트쪽의 영역임
	이렇게 문제가 있을때 즉시 실패하게하는걸 빠른실패원칙이라고 하고,이건 프로그램의 안정성을 높임
	보통 메서드시작부분에서 전제조건을 확인하고 틀리면 예외던지는게 이거임
	
	
	프로세스외부의존성은 두가지로 나뉨
		관리의존성:어플리케이션에서만 접근할수있는 의존성(db)
		비관리의존성:아무나 막 접근할수있고,내가 제어할수없는 의존성(외부api,메세지버스)
	보통 관리의존성은 실제 인스턴스를 사용하고,비관리의존성은 목으로 대체하면됨
	근데 관리의존성이면서 비관리의존성인 경우도 있음,예를들면 다른어플리케이션에서도 접근가능한 db테이블이라던가
	이경우엔 서로 볼수있는부분은 비관리의존성,볼수없는부분은 관리의존성으로 나눠서 처리해야함
	그래서 볼수있는부분은 목으로 처리하면됨
	
	그리고 통합테스트에서 실제db를 사용할수없으면,그냥 작성안하는게 낫고,통합테스트를 쓸거면 실제db를 사용해야함
	
	통합테스트에서는,가장 긴 주요흐름과 단위테스트로 커버할수없는 모든 예외상황을 다루면됨
	보통 가장 긴 주요흐름은 모든 프로세스외부의존성을 거치는것임
	그리고 단위테스트에서 테스트하지않았지만,만약 이게 빠른실패원칙에 들어가면 테스트를 만들필요는없음
	
	
	만약 외부의존성 인터페이스에 구현이 하나밖에 없고,추가될일도 없으면 그냥 클래스하나만 쓰는게 나음
	보통 인터페이스를 사용하는 이유는,목을 사용하기 위해서임
	그러니 비관리의존성의 경우만 인터페이스를 사용하고,관리의존성의 경우는 그냥 구현체를 사용해도됨
	물론 구현체가 2개이상일경우(진짜 추상화)엔 인터페이스를 쓰면됨,이건 단일구현일경우의 이야기
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	