1.단위테스트의 기초
  1.단위테스트 정의
    단위테스트의 단위는 작업단위,혹은 유즈케이스를 의미함
	작업단위는 또 진입점과 종료점사이를 말하는데,진입점은 호출될떄 시작하는지점이고 종료점은 어떤 한 출력이나 리턴이 일어나는걸 말함
	
  2.진입점과 종료점	
    작업단위에는 하나의 진입점과 여러개의 종료점이 있을수있고,종료점은 한 함수실행에서 여러개가 한번에 실행될수있음
	또한 한 작업단위가 함수 하나일수도있지만,여러함수일수도 있고,모듈이나 컴포넌트단위일수도있음
	어떻게 자르든 외부에서 접근하는 시작점이 진입점임(보통 파사드나 서비스로 묶어서 실행하면 그 실행메서드가 진입점인것)
	
	종료점에는 함수의 리턴값,특정 상태값의 변경,db의 변경이나 카프카 통신,로깅같은 사이드이펙트 출력(의존성 호출),예외 리턴등이 있을수있음
	
	종료점은 작업단위의 최종 결과를 의미하고,각 종료점마다 테스트를 만드는느낌으로 접근하면 쉬움
	종료점이 새로 생긴다는건 추가적인 요구사항이나,결과에 영향을 미치는 무언가가 생겼다는것

  3.다른종료점,다른 기법
    종료점을 분류하는 이유는,각 종료점마다 테스트방법이 다르기때문
	반환값은 그냥 바로 테스트를 만들면되고
	상태값변경은 좀 귀찮음,함수호출후에 다시 상태를 확인해서 체크해야함
	의존성 호출은 외부에 실행주도권이 있어서 모킹하던지 해야해서 제일 귀찮음
	
	그래서 의존성호출은 최대한 줄이고,꼭 필요한데서만 쓰는게 좋음

  4.좋은 단위테스트의 특징
    좋은 테스트는
	  테스트 작성자의 의도를 이해하기 쉬워야함
	  읽고쓰기 쉬워야함
	  테스트자동화가 가능해야함
	  같은 조건에서 실행결과는 항상 같아야함
	  의미있는테스트여야하고,구체적 결과를 제공하여 문제를 쉽게 파악하고 해결할수있어야함
	  누구나 쉽게 실행할수 있어야함
	  실패할때 뭐가 문제인지 쉽게 알수있어야함
	이걸 만족시켜야함
	
	좋은 단위테스트는
	  빠르게 실행되어야함
	  테스트환경을 일관되게 유지하고,테스트결과가 항상 예측가능해야함
	  다른테스트와 완전히 독립적으로 실행되어야함
	  외부의존성(db등)이 없어도 메모리내에서 실행되어야함
	  가능한 동기적인 흐름으로  실행되어야함(가능하면 스레드를 사용하지 않아야함)
	임
	모든 테스트가 좋은 단위테스트일 필요는 없고,그런건 그냥 통합테스트로 만들어도됨
	
	또한 외부의존성을 메모리로 실행시킬때는 스텁을 사용할수도 있음
	대표적으로 db를 인메모리 db로 바꾸는건데,이건 쓰기편하긴한데 위치가 애매하다는건 알고써야함
	실제 db만큼 신뢰성과 정확성을 보장하지못하고,스텁만큼 설정이 쉽지않고,안시 sql만 사용할수있음
	만약 안시sql만 사용하지않는다면 스텁을 쓰고,통합테스트에선 실제db를 사용하는게 좋음
	
	단위테스트 체크리스트는
	  2년전에 만든 테스트가 여전히 잘 돌아가는가?(회귀테스트)
	  내가 2달전에 만든 테스트를 팀 내 다른동료가 실행했을때 문제가없나?(회귀테스트)
	  내가 만든 테스트가 수분내로 전부 실행되는가?(단위테스트의 속도)
	  버튼 하나만 눌러서 모든 테스트실행이 가능한가?(테스트의 속도)
	  기본적인 테스트를 몇분내로 만들수있나?(테스트 작성시 내외부 의존성의 존재여부)
	  다른 팀 코드에 버그가있어도 내 테스트는 통과하나?(테스트가 외부의존성에서 독립적인지 여부)
	  내 테스트는 다른 실행환경에서 실행해도 같은결과를 보장하나?(테스트가 외부의존성에서 독립적인지 여부)
	  db,네트워크,배포없이 내 테스트는 동작하나?(테스트가 외부의존성에서 독립적인지 여부)
	  하나의 테스트를 삭제,이동,변경해도 다른테스트는 영향을 받지않나?(테스트간 의존성이 없는지 여부)
	이것들을 다 만족해야함,하나라도 틀리면 통합테스트거나 할수있음

  5.통합 테스트
    통합테스트는 단위테스트의 조건을 하나라도 만족시키지 못한 모든 테스트임
	예를들어 실제 의존성(db등)을 사용한다거나
	
	통합테스트의 문제는 한번에 너무 많은걸 테스트한다는데 있음
	자동차의 엔진만 테스트하는게 아닌,자동차가 움직이는지를 테스트하면 정상동작일땐 괜찮은데 이상동작일땐 어디서 문젠지를 찾기어려움
	
	가장 중요한건
	  가독성:읽기쉬워야 유지보수,디버깅도 쉽고 뭐가 문제인지도 알기쉬움
	  유지보수성:테스트코드떄문에 기존테스트나 프로덕션코드관리가 어려우면 문제가 있을확률이 높음
	  신뢰성:테스트가 실패했을때 그 결과를 믿을수없으면 테스트의미가 없음
	임

  6.단위테스트
    단위테스트란 진입점을 통해 작업단위를 호출하고,그 종료점을 확인하는 자동화된 코드임
	잘 작성된 단위테스트는 신뢰성이 높고 가독성이 좋아서 유지보수가 용이함
	해당 코드가 직접 변경되지않는한 동일한 결과를 보장해야함
	
	게터와 세터같은건 조건문이나 논리가 없어서 테스트를 만들 가치가 없음
	조건이나 논리가 들어가면 이 논리가 제대로 동작하는지를 테스트해야함

  7.테스트 주도 개발
    기능을 만들기 전에 테스트를 먼저 만드는게 tdd임
	이거의 순서는
	  어떤 기능이 필요할지 요구사항정리
	  목표하는 기능구현을 검증하는 테스트코드작성
	  테스트 실행 후 테스트코드 실패 확인
	  테스트가 통과하게 코드 수정
	  테스트 실행 후 테스트코드 성공 확인
	  리팩터링으로 코드 다듬기(맘에들때까지반복)
	  테스트 실행 후 테스트코드 성공 확인
	이렇게 하는방식임

    즉 테스트가 일부러 실패하게 테스트를 작성하거나,기능자체를 비워서 테스트가 실패하게 하고,해당 테스트가 성공하게 코드를 수정하는방식임
	강타입언어의 경우엔 인터페이스나 클래스까지만 만들고 테스트를 만듬
	구현은 테스트가 일단 통과되게 만드는걸 가장 먼저 신경쓰고,테스트가 통과한 뒤에 리팩터링함
	
	tdd의 가장 큰 장점은,테스트 자체를 검증할수있어서 테스트를 수정하지않아도됨
	  
2.첫번째 단위테스트
  대부분 생략함 그래도 좀 볼만하다싶은거만 남김
  
  aaa패턴(gwt패턴)을 사용하면 쉽게 테스트를 만들수있음
  
  테스트이름은 무엇보다 중요함
  제목만 읽어도 뭘하고싶은지 알수있어야함
  이때 고려해야할 요소는
    테스트하려는 대상
	입력값이나 상황에 대한 설명
	기댓값이나 결과에 대한 설명
  즉 테스트대상을 명시하고,어떤입력이나 상황이 주어지면 어떤 결과로 이어져야하는지 간결하고 명확하게 적으면됨
  
  검증에서 단순 문자열동등비교는 유지보수성이 좀 떨어짐
  그래서 정규표현식등을 사용하면 테스트대상 코드가 변경되어도 테스트 실패 가능성을 줄일수있음
  메시지가 담고있는 의미가 중요하지,마침표나 공백이 추가됐다고 테스트가 실패하는건 좋지않음
  즉 거짓양성의 가능성을 낮춰야함
 
  1.팩토리함수 사용
    beforeEach를 사용하면 beforeEach와 테스트코드를 계속 스크롤해야하는 귀찮음이 생김
	또한 beforeEach는 쓰레기통처럼 쓰이게되는경우도 많음
	
	그래서 아예 팩토리함수로 만드는게 더 좋을수있음
	팩토리함수를 만들고,테스트의 준비부분에서 팩토리함수를 호출하는식으로 동작시키는거임
	이러면 필요할때만 팩토리함수로 찾아가서 코드를 자세히 살피면되고,필요없을땐 그냥 함수명만 보고 그렇구나 하고 넘어가면됨(캡슐화)
  
	  
3.의존성 분리와 스텁
  1.의존성유형
    의존성은 외부로 나가는 의존성,즉 작업단위의 종료점을 나타내는 의존성과,내부로 들어오는 의존성,즉 종료점을 나타내지않는 의존성이 있음
	외부로 나가는 의존성은,db저장,로거호출등 작업단위 내 특정 논리흐름의 끝을 나타내고
	내부로 들어오는 의존성은 특정 데이터나 동작을 작업단위에 제공하는역할을 함,즉 db쿼리등이 있음

  2.모킹의 종류
    페이크는 스텁과 목을 포함한 일반적인 이름이고,실제구현을 대체하는 가벼운버전(인메모리db처럼)을 의미하기도함
	
	스텁은 테스트에서 사용될값을 지정하는데,보통 메서드의 매개변수로 넣어서 사용하거나,gwt의 g에서 생성함
	즉 스텁은 가짜객체를 의존성주입으로 사용할때 스텁이라고 말함
	
	목은 다른 소프트웨어구성요소에 간접출력을 보낼때 독립적으로 로직을 검증할때 사용되면 목이라고 부름
	
	스텁은 내부로 들어오는 의존성을 끊어주고,즉 가짜 동작이나 데이터를 코드내부로 보내는 가짜함수를 의미함,
	스텁은 검증하지않음,그래서 하나의 테스트에서 여러 스텁을 사용할수있음
	
	목은 외부로 나가는 의존성을 끊어주고,목은 가짜모듈이나 객체 및 호출여부를 검증하는 함수를 의미함,
	목은 단위테스트의 종료점을 나타냄,그래서 하나의테스트에 목은 하나만 사용할수있음(검증은 한테스트에 하나만)
	
	근데 보통 대충 목으로 때려부르기도함
	
	즉 
	  목은 테스트대상코드가 외부시스템과 상호작용할떄,호출여부와 인수를 검증하고
	  스텁은 미리 정의된 가짜데이터를 제공하여 테스트대상코드의 입력을 시뮬레이션하고
	  페이크는 실제 구현을 대체하는 가벼운버전의 구성요소를 제공하여 테스트를 수행함
	이런식임
	
  3.스텁을 사용하는 일반적인 설계방식
    시간같은 우리가 제어할수없는 코드가 로직에 있으면,이 로직은 테스트하기 매우 까다로워짐(항상 같은결과를 받을수없음)
    그래서 이런 제어할수없는 코드를 제어할수있게 코드를 만들고(의존성역전),이걸 이용해서 테스트를 짜야함
	
	일반적으로 이런 제어할수없는부분을 매개변수로 주입할수도있고,di받을수도있음
	또한 함수형프로그래밍을 쓰면 함수단위로 주입받을수도있고,객체지향에선 객체단위로 주입받을수도 있음
	
	객체지향에선 인터페이스를 만들고,그걸 의존하며 프로덕션과 테스트의 실제 di가 다르게 이뤄지는방식을 주로 사용함
	이때 생성자주입이나 메서드의 파라미터주입으로 객체를 보통 집어넣음
	
	
4.모의 객체를 사용한 상호작용테스트	  
  1.상호작용테스트
    작업단위가 제어할수없는 영역을 테스트할땐 모킹객체를 사용해서 외부로 나가는 의존성을 끊어서 테스트할수있음
	
	만약 함수나 객체를 직접 생성해서 사용한다면,이건 테스트하기 매우 까다로워짐
	그래서 매개변수를 주입하는 방식으로 리팩터링하거나,객체나 함수를 주입하는방식으로 리팩터링하는게 좋음
	물론 사파적인 방식을 사용하면 저렇게 테스트하는게 가능하긴하지만,가독성과 유지보수성때문에 최후의수단으로 사용함

  2.목과 스텁을 구분하는것의 중요성
    목은 작업단위의 요구사항을 검증하기위해 사용하는거고,스텁은 들어오는 정보나 동작을 나타낼때 사용하는거임
	이걸 구분해서 만들지않으면 가독성과 유지보수성이 떨어짐
	
	목은 반드시 검증해야하지만 스텁은 검증하지않기때문
	이걸 구분하지않으면 목을 여러개만들거나,스텁을 검증하거나 이런일이 발생할수있음

  3.복잡한 인터페이스 다루기
    인터페이스를 테스트용으로 구현해서 사용할땐
	  온전한 제어권이 있는 인터페이스여야함
	  작업단위나 컴포넌트의 요구사항에 맞게 설계된 인터페이스여야함
	를 만족한애들만 하는게 좋음
	
	또한 인터페이스가 복잡하다면,인터페이스분리원칙에 따라 인터페이스를 분리하는게 나음(포트어댑터)

  4.부분모의객체
    보통 테스트프레임워크에서는 스파이기능이 있음
	이건 특정 객체나 함수가 호출되었는지,몇번호출되었는지,어떤인수로 호출되었는지를 파악할수있음
	이걸 사용하면 테스트가 더 복잡해지거나,불안정해질수 있지만,레거시코드를 테스트를 만들어야할땐 괜찮은선택지임
	
	부분모의객체는 실제객체에서 일부분만 모킹함수로 대체하는방식임
	즉 원래 객체를 오버라이드해서 특정 메서드를 오버라이딩해서 모킹메서드로 바꿨다고 생각하면됨(보통 프록시처럼 만들거임)
    
	
5.격리 프레임워크
  1.격리프레임워크 정의
    격리프레임워크는 런타임에 가짜 객체를 생성하고 설정할수있는 재사용가능한 라이브러리를 의미함
	이런 객체는 동적스텁이나 동적 목이라고 부름
	
	작업단위를 의존성에서 격리시킬수있기때문에 격리프레임워크라고 부르는거
	
  js관련 프레임워크사용법은 스킵
  2.격리 프레임워크의 장점과 함정
    격리프레임워크를 사용하면,쉽게 가짜모듈을 만들수있고 테스트가 편해지지만,뭐든 쉽게 만들수있어서 필요없는곳에 모킹을 하게됨(고전파런던파)
	가능하면 모킹을 하지않고 하는게 낫고,상호작용기반 테스트를 반환값기반 테스트로 바꿀수있으면 바꾸는게 좋음
	
6.비동기 코드 단위 테스트	
  비동기코드는 코드가 끝날때까지 기다리는게 당연한행위가 아닌,명확한 의도가 있는 행위가 됨
  이러면 코드테스트가 좀 까다로워짐
  
  그래서 처음엔 통합테스트로 접근해볼순있지만,실행시간이 길고,불안정하고,테스트와 관계없는곳까지 같이테스트를 해야하고,거짓양성이 잘나옴
  그래서 가능하면 유닛테스트쪽으로 테스트하게 리팩터링하는게 좋음
  
  1.코드를 단위테스트에 적합하게 만들기
    이떄 사용할수있는 패턴이 두가지정도가 있음
	  진입점 분리:순수로직부분을 별도의 함수로 분리해서,이 함수를 유닛테스트
	  어댑터 분리:본질적으로 비동기적 요소를 분리하고,이걸 추상화해서 동기적인요소로 대체(포트어댑터)
	이렇게
	
	진입점 분리는 비동기코드 내에서 순수로직부분을 별도로 떼어내서,이 로직부분만 유닛테스트를 할수있게 만드는 패턴임
	이러면 외부의존성없이 동기적으로 이 함수작업단위를 검증할수있음
	또한 기존의 전체비동기코드는 상위수준의 통합테스트로 전체를 검증하는식으로 할수있음
	즉 다수의 유닛테스트와 소수의 통합테스트로 진행하는느낌
	
	어댑터 분리는 비동기코드를 의존성처럼 생각하고,해당부분을 사용하는 부분을 인터페이스로 의지하게하고,이 인터페이스를 구현한 어댑터에 비동기코드를 넣는방식임
	이러면 사용하는쪽에선 di받아쓰면되고,문제가 있거나 하면 어댑터채로 바꿔쓸수있음
	이러면 테스트에서 서비스를 테스트할땐 스텁을 만들어서 사용하면됨

  2.기타 js관련 타이머테스트와 ui,dom테스트등
    스킵

7.신뢰할 수 있는 테스트
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	  
	  
	  
	  
	  
	  
	  